<html><head></head><body>
		<div id="_idContainer111">
			<h1 id="_idParaDest-103" class="chapter-number"><a id="_idTextAnchor102"/>4</h1>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Jungle Jump – Running and Jumping in a 2D Platformer</h1>
			<p>In this chapter, you’ll build a <em class="italic">platformer</em> game in the tradition of classics such as <em class="italic">Super Mario Bros</em>. Platform games are a very popular genre, and understanding how they work can help you make a variety of different game styles. If you’ve never attempted making one before, the player movement in platformers can be surprisingly complex to implement, and you’ll see how Godot’s <strong class="source-inline">CharacterBody2D</strong> node has features to help you in <span class="No-Break">that process.</span></p>
			<p>In this project, you will learn about <span class="No-Break">the following:</span></p>
			<ul>
				<li>Using the <span class="No-Break"><strong class="source-inline">CharacterBody2D</strong></span><span class="No-Break"> node</span></li>
				<li>Using the <span class="No-Break"><strong class="source-inline">Camera2D</strong></span><span class="No-Break"> node</span></li>
				<li>Combining animations and user input to produce complex <span class="No-Break">character behavior</span></li>
				<li>Designing levels <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">TileMap</strong></span></li>
				<li>Creating an infinitely scrolling background <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">ParallaxLayer</strong></span></li>
				<li>Transitioning <span class="No-Break">between scenes</span></li>
				<li>Organizing your project and planning <span class="No-Break">for expansion</span></li>
			</ul>
			<p>Here is a screenshot of the <span class="No-Break">completed game:</span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B19289_04_01.jpg" alt="Figure 4.1: Completed game screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: Completed game screenshot</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Technical requirements</h1>
			<p>As with the previous projects, you’ll start by downloading the art assets for the game, which can be found <span class="No-Break">here:</span><span class="No-Break"> </span><a href="https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads"><span class="No-Break">https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads</span></a></p>
			<p>You can also find the complete code for this chapter on GitHub <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter04%20-%20Jungle%20Jump"><span class="No-Break">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter04%20-%20Jungle%20Jump</span></a></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Setting up the project</h1>
			<p>To create a new<a id="_idIndexMarker236"/> project, start by opening <strong class="bold">Project Settings</strong> so that you can configure the defaults that <span class="No-Break">you’ll need.</span></p>
			<p>The art assets for this <a id="_idIndexMarker237"/>game use a <strong class="bold">pixel art</strong> style, which means they look best when the images are not <a id="_idIndexMarker238"/>smoothed, which is Godot’s default setting for <span class="No-Break"><strong class="bold">texture filtering</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B19289_04_02.jpg" alt="Figure 4.2: Texture filtering"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: Texture filtering</p>
			<p>While it’s possible to set this on each <strong class="source-inline">Sprite2D</strong>, it’s more convenient to specify the default setting. Click the <strong class="bold">Advanced</strong> toggle in the top right and find the <strong class="bold">Rendering/Textures</strong> section on the left. In the settings list, scroll to the bottom and find the <strong class="bold">Canvas Textures/Default Texture Filter</strong> setting. Change it from <strong class="bold">Linear</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Nearest</strong></span><span class="No-Break">.</span></p>
			<p>Then, under <strong class="bold">Display/Window</strong>, change <strong class="bold">Stretch/Mode</strong> to <strong class="bold">canvas items</strong> and <strong class="bold">Aspect</strong> to <strong class="bold">expand</strong>. These settings<a id="_idIndexMarker239"/> will allow the user to resize the game window while preserving the image’s quality. Once the project is complete, you’ll be able to see the effects of <span class="No-Break">this setting.</span></p>
			<p>Next, you can set up the collision layers. Because this game will have several different types of collision objects that need to interact in different ways, you’ll use Godot’s <strong class="bold">collision layer</strong> system to help organize them. The layers will be more convenient to use if they’re assigned names, so go to the <strong class="bold">Layer Names | 2D Physics</strong> section and name the first four layers like this (by typing directly in the box next to the <span class="No-Break">layer number):</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B19289_04_03.jpg" alt="Figure 4.3: Setting physics layer names"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: Setting physics layer names</p>
			<p>Finally, add the <a id="_idIndexMarker240"/>following actions for the player controls to the <strong class="bold">Input </strong><span class="No-Break"><strong class="bold">Map</strong></span><span class="No-Break"> area:</span></p>
			<table id="table001" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Action name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Key(s)</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">right</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><em class="italic">D</em></span><span class="No-Break">, →</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">left</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><em class="italic">A</em></span><span class="No-Break">, ←</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">jump</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Space</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">up</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><em class="italic">S</em></span><span class="No-Break">, </span><span class="No-Break">↑</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">down</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><em class="italic">W</em></span><span class="No-Break">, </span><span class="No-Break">↓</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Figure">Make sure you use the exact names for the input actions since you’ll be referencing them in code later.</p>
			<p>That’s all you need<a id="_idIndexMarker241"/> to set in <strong class="bold">Project Settings</strong>. But before you start making the player scene, you need to learn about a different type of <span class="No-Break">physics node.</span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor106"/>Introducing kinematic bodies</h1>
			<p>A platformer requires gravity, collisions, jumping, and other physics behavior, so you might think that <strong class="source-inline">RigidBody2D</strong> would be<a id="_idIndexMarker242"/> the perfect choice to implement the character’s movement. In practice, you’ll find that the more realistic physics of the rigid body are not desirable for a platform character. To the player, realism is less<a id="_idIndexMarker243"/> important than responsive control and an action feel. So, as the developer, you want to have precise control over the character’s movements and collision response. For this reason, a <strong class="bold">kinematic</strong> style of physics is usually the better choice for a <span class="No-Break">platform character.</span></p>
			<p>The <strong class="source-inline">CharacterBody2D</strong> node is designed for implementing physics bodies that are to be controlled directly via code. These nodes detect collisions with other bodies when they move but are not affected by global physics properties such as gravity or friction. This doesn’t mean that they can’t be affected by gravity and other forces – just that you must calculate those forces and their effects in code; the physics engine will not move a <strong class="source-inline">CharacterBody2D</strong> <span class="No-Break">node automatically.</span></p>
			<p>When moving a <strong class="source-inline">CharacterBody2D</strong> node as with <strong class="source-inline">RigidBody2D</strong>, you should not set its <strong class="source-inline">position</strong> property directly. Instead, you must use the <strong class="source-inline">move_and_collide()</strong> or <strong class="source-inline">move_and_slide()</strong> methods provided by the body. These methods move the body along a given vector and instantly stop it if a collision is detected with another body. It’s then up to you to decide on any <span class="No-Break"><strong class="bold">collision response</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>Collision response</h2>
			<p>After a collision, you <a id="_idIndexMarker244"/>may want the <a id="_idIndexMarker245"/>body to bounce, slide along a wall, or alter the properties of the object it hit. The way you handle collision response depends on which method you use to move <span class="No-Break">the body:</span></p>
			<h3>move_and_collide()</h3>
			<p>When using this method, the function returns a <strong class="source-inline">KinematicCollision2D</strong> object upon collision. This object contains information about the collision and the colliding body. You can use this information to determine the response. Note that the function returns <strong class="source-inline">null</strong> when movement is completed successfully with <span class="No-Break">no collision.</span></p>
			<p>For example, if you want the<a id="_idIndexMarker246"/> body to bounce off the colliding object, you could use the <span class="No-Break">following script:</span></p>
			<pre class="source-code">
extends CharacterBody2D
velocity = Vector2(250, 250)
func _physics_process(delta):
    var collision = move_and_collide(velocity * delta)
    if collision:
        velocity = velocity.bounce(collision.get_normal())</pre>
			<h3>move_and_slide()</h3>
			<p>Sliding is a very common option for collision response. Imagine a player moving along a wall in a top-down game, or<a id="_idIndexMarker247"/> running along the ground in a platformer. While it’s possible to code the response yourself after using <strong class="source-inline">move_and_collide()</strong>, <strong class="source-inline">move_and_slide()</strong> provides a convenient way to implement sliding movement. When using this method, the body will automatically slide along the surface of a colliding object. In addition, sliding collisions will allow you to detect the orientation of the surface using methods such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">is_on_floor()</strong></span><span class="No-Break">.</span></p>
			<p>Since this project will require you to allow the player character to run along the ground and up/down slopes, <strong class="source-inline">move_and_slide()</strong> is going to play a large role in your <span class="No-Break">player’s movement.</span></p>
			<p>Now that you have an understanding of what kinematic bodies are, you’ll use one to make the character for <span class="No-Break">this game.</span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Creating the player scene</h1>
			<p>The Godot node that implements<a id="_idIndexMarker248"/> kinematic movement and collision is called <span class="No-Break"><strong class="source-inline">CharacterBody</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">2D</strong></span><span class="No-Break">.</span></p>
			<p>Open a new scene and add a <strong class="source-inline">CharacterBody2D</strong> node named <strong class="source-inline">Player</strong> as the root and save the scene. Don’t forget to click the <strong class="bold">Group Selected Node(s)</strong> button. When saving the <strong class="source-inline">Player</strong> scene, you should also create a new folder to contain it. This will help keep your project folder <a id="_idIndexMarker249"/>organized as you add more scenes <span class="No-Break">and scripts.</span></p>
			<p>Look at the properties of <strong class="source-inline">CharacterBody2D</strong> in the Inspector. Notice the default values of <strong class="bold">Motion Mode</strong> and <strong class="bold">Up Direction</strong>. “Grounded” mode means the body will consider one collision direction as the “floor,” the opposite wall as the “ceiling,” and any others as “walls” – which one is determined by <span class="No-Break"><strong class="bold">Up Direction</strong></span><span class="No-Break">.</span></p>
			<p>As you’ve done in previous projects, you’ll include all the nodes the player character needs to function in the Player scene. For this game, that means handling collisions with various game objects, including<a id="_idIndexMarker250"/> platforms, enemies, and collectibles; displaying animations for actions, such as running or jumping; and attaching a camera to follow the player around <span class="No-Break">the level.</span></p>
			<p>Scripting the various animations can quickly become unmanageable, so you’ll need to use a <strong class="bold">finite-state machine</strong> (<strong class="bold">FSM</strong>) to manage <a id="_idIndexMarker251"/>and track the player’s state. See <a href="B19289_03.xhtml#_idTextAnchor066"><span class="No-Break"><em class="italic">Chapter </em></span><span class="No-Break"><em class="italic">3</em></span></a> to review how a simplified FSM can be built. You’ll follow a similar pattern for <span class="No-Break">this project.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Collision layers and masks</h2>
			<p>A body’s <strong class="bold">Collision/Layer</strong> property sets <a id="_idIndexMarker252"/>what layer(s) in the physics world the body is found on. <strong class="source-inline">Player</strong> needs to be assigned to the “player” layer (which you named in <strong class="bold">Project Settings</strong>). Similarly, <strong class="bold">Collision/Mask</strong> sets which layers the body can “see” or interact with. If an object is on a layer that is not in the player’s <strong class="bold">Mask</strong>, then the <a id="_idIndexMarker253"/>player won’t interact with it <span class="No-Break">at all.</span></p>
			<p>Set the player’s <strong class="bold">Layer</strong> to <strong class="bold">player</strong> and <strong class="bold">Mask</strong> to <strong class="bold">environment</strong>, <strong class="bold">enemies</strong>, and <strong class="bold">items</strong>. Click the three dots to the right to open a list of checkboxes showing the names you’ve assigned to <span class="No-Break">the layers:</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B19289_04_04.jpg" alt="Figure 4.4: Setting collision layers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: Setting collision layers</p>
			<p>This will ensure that the player is on the “player” layer so that other objects can be configured to detect the <a id="_idIndexMarker254"/>player or not. Setting the <strong class="bold">Mask</strong> value to <a id="_idIndexMarker255"/>all three layers means the player will be able to interact with objects on any of <span class="No-Break">those layers.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>About AnimationPlayer</h2>
			<p>Earlier in this book, you used <strong class="source-inline">AnimatedSprite2D</strong> to display the frame-based animations of your characters. This is a great tool, but it’s only useful for animating the visual texture of a <a id="_idIndexMarker256"/>node. What if you want to also animate any of a node’s <span class="No-Break">other properties?</span></p>
			<p>This is where <strong class="source-inline">AnimationPlayer</strong> comes in. This node is a very powerful tool for creating animations that can affect multiple nodes at once; you can modify any of <span class="No-Break">their properties.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Animations</h2>
			<p>To set up the <a id="_idIndexMarker257"/>character’s animations, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Add a <strong class="source-inline">Sprite2D</strong> node to <strong class="source-inline">Player</strong>. Drag the <strong class="source-inline">res://assets/player_sheet.png</strong> file from the <strong class="bold">FileSystem</strong> dock and drop it into the <strong class="bold">Texture</strong> property. The player animation will be saved in the form of a <span class="No-Break">sprite sheet:</span></li>
			</ol>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B19289_04_05.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: Sprite sheet</p>
			<ol>
				<li value="2">You’ll use <strong class="source-inline">AnimationPlayer</strong> to handle the animations, so, in the <strong class="bold">Animation</strong> properties of <strong class="source-inline">Sprite2D</strong>, set <strong class="bold">HFrames</strong> to <strong class="source-inline">19</strong>. Then, set <strong class="bold">Frame</strong> to <strong class="source-inline">7</strong> to see the player standing. Finally, move <strong class="source-inline">Sprite2D</strong> upward until its feet are standing on the ground by setting <strong class="bold">Position</strong> to <strong class="source-inline">(0, -16)</strong>. This will make it easier to code the player’s<a id="_idIndexMarker258"/> interactions later because you will know that the player’s <strong class="source-inline">position</strong> property represents the location of <span class="No-Break">its feet.</span></li>
				<li>Add an <strong class="source-inline">AnimationPlayer</strong> node to the scene. You’ll use this node to change the <strong class="bold">Frame</strong> property of <strong class="source-inline">Sprite2D</strong> to the appropriate values for <span class="No-Break">each animation.</span></li>
				<li>Before you start, review the different parts of the <span class="No-Break"><strong class="bold">Animation</strong></span><span class="No-Break"> panel:</span></li>
			</ol>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B19289_04_06.jpg" alt="Figure 4.6: The Animation panel"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: The Animation panel</p>
			<ol>
				<li value="5">Click the <strong class="bold">Animation</strong> button and select <strong class="bold">New</strong>. Name the new <span class="No-Break">animation </span><span class="No-Break"><strong class="source-inline">idle</strong></span><span class="No-Break">.</span></li>
				<li>Set its <strong class="bold">Length</strong> to <strong class="source-inline">0.4</strong> seconds. Click the <strong class="bold">Loop</strong> icon to make the animation loop, and set the track’s <strong class="bold">Update Mode</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Continuous</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Change the <strong class="bold">Frame</strong> property of <strong class="source-inline">Sprite2D</strong> to <strong class="source-inline">7</strong>, which is the first frame of the idle animation, and click the <strong class="bold">keyframe</strong> icon next to the property to add an animation track with <a id="_idIndexMarker259"/>a <span class="No-Break">new keyframe:</span></p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B19289_04_07.jpg" alt="Figure 4.7: Adding a keyframe"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: Adding a keyframe</p>
			<ol>
				<li value="7">Slide the play scrubber to <strong class="source-inline">0.3</strong> (you can adjust the zoom slider in the bottom right to make it easier to find). Add a keyframe for frame <strong class="source-inline">10</strong>, which is the last frame <span class="No-Break">of </span><span class="No-Break"><strong class="bold">idle</strong></span><span class="No-Break">.</span></li>
				<li>Press the <strong class="bold">Play</strong> button to see the animation play. If it doesn’t look correct, go back to the previous paragraph and make sure you’ve followed the steps exactly, especially the fact that you start on frame <strong class="source-inline">7</strong> and ended on <span class="No-Break">frame </span><span class="No-Break"><strong class="source-inline">10</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Now, repeat this process for the other animations. See the following table for a list of <span class="No-Break">their settings:</span></p>
			<table id="table002" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Length</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Frames</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Looping</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">idle</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">0.4</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">7 </strong>→ <span class="No-Break"><strong class="source-inline">10</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">On</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">run</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">0.5</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">13 </strong>→<strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline">18</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">On</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">hurt</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">0.2</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">5 </strong>→ <strong class="source-inline">6</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">On</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">jump_up</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">0.1</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">11</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Off</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">jump_down</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">0.1</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">12</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Off</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>There are also<a id="_idIndexMarker260"/> animations in the sprite sheet for crouching and climbing, but you can add those later, once the basic movement <span class="No-Break">is completed.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Collision shape</h2>
			<p>As with other bodies, <strong class="source-inline">CharacterBody2D</strong> needs a shape assigned to define its collision bounds. Add a <strong class="source-inline">CollisionShape2D</strong> node and create a new <strong class="source-inline">RectangleShape2D</strong> inside it. When sizing the shape, you want it to reach the bottom of the image (the player’s feet) but be <a id="_idIndexMarker261"/>a little bit narrower than the player’s image. In general, making the shape a bit smaller than the image will result in a better feel when playing, avoiding the experience of hitting something that looks like it wouldn’t result in <span class="No-Break">a collision.</span></p>
			<p>You’ll also need to offset the shape a small amount to make it fit. Setting the <strong class="source-inline">CollisionShape2D</strong> node’s <strong class="bold">Position</strong> to <strong class="source-inline">(0, -10)</strong> works well. When you’re done, it should look approximately <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B19289_04_08.jpg" alt="Figure 4.8: Player collision shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: Player collision shape</p>
			<p class="callout-heading">Multiple shapes</p>
			<p class="callout">In some cases, depending on the complexity of your character and its interactions with other objects, you may want to add multiple shapes to the same object. You might have one shape at the player’s feet to detect ground collisions, another on its body to detect damage, and yet another <a id="_idIndexMarker262"/>covering the player’s front to detect contact <span class="No-Break">with walls.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>Finishing the player scene</h2>
			<p>Add a <strong class="source-inline">Camera2D</strong> node to the <strong class="source-inline">Player</strong> scene. This node will keep the game window centered on the player as it moves around the level. You can also use it to zoom in on the player since pixel art is<a id="_idIndexMarker263"/> relatively small compared to the game window’s size. Remember, since you set the filtering option in <strong class="bold">Project Settings</strong>, the player’s texture will remain pixelated and blocky when <span class="No-Break">zoomed in.</span></p>
			<p>To enable the camera, set the <strong class="bold">Enabled</strong> property to <strong class="bold">On</strong>, then set <strong class="bold">Zoom</strong> to <strong class="source-inline">(2.5, 2.5)</strong>. Values smaller than 1 zoom the camera out, while larger values zoom <span class="No-Break">it in.</span></p>
			<p>You’ll see a pinkish-purple rectangle surrounding the player. That’s the camera’s <strong class="bold">screen rectangle</strong> and it shows what the camera will see. You can adjust the <strong class="bold">Zoom</strong> property to increase or decrease its size to see more or less of the world around <span class="No-Break">the player.</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Player states</h2>
			<p>The player character has a wide<a id="_idIndexMarker264"/> variety of behaviors, such as jumping, running, and crouching. Coding such behaviors can become very complex and hard to manage. One solution is to use Boolean variables (<strong class="source-inline">is_jumping</strong> or <strong class="source-inline">is_running</strong>, for example), but this leads to possibly confusing states (what if <strong class="source-inline">is_crouching</strong> and <strong class="source-inline">is_jumping</strong> are both <strong class="source-inline">true</strong>?) and quickly leads to <span class="No-Break"><strong class="source-inline">_spaghetti_ code</strong></span><span class="No-Break">.</span></p>
			<p>A better solution to this problem is to use a state machine to handle the player’s current state and control the transition to other states. This concept was introduced in <a href="B19289_03.xhtml#_idTextAnchor066"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, and you’ll expand on it in <span class="No-Break">this project.</span></p>
			<p>Here is a diagram of the player’s states and the transitions <span class="No-Break">between them:</span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B19289_04_09.jpg" alt="Figure 4.9: Player state diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9: Player state diagram</p>
			<p>As you can see, state<a id="_idIndexMarker265"/> diagrams can become quite complex, even with a relatively small number <span class="No-Break">of states.</span></p>
			<p class="callout-heading">Other states</p>
			<p class="callout">Note that while the sprite sheet contains animations for them, the <strong class="source-inline">CROUCH</strong> and <strong class="source-inline">CLIMB</strong> states are not included here. This is to keep the number of states manageable at the beginning of the project. Later, you’ll have the opportunity to <span class="No-Break">add them.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Player script</h2>
			<p>Attach a new script to the <strong class="source-inline">Player</strong> node. Note that the dialog shows a <strong class="bold">Template</strong> property with Godot’s default <strong class="bold">Basic Movement </strong>for this node type. Uncheck the <strong class="bold">Template</strong> box – you won’t need that example code for <span class="No-Break">this project.</span></p>
			<p>Add the following code to<a id="_idIndexMarker266"/> start setting up the player’s state machine. As in the <em class="italic">Space Rocks</em> game, you can use an <strong class="source-inline">enum</strong> type to define the allowed states for the system. When you want to change the player’s state, you can <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">change_state()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
extends CharacterBody2D
@export var gravity = 750
@export var run_speed = 150
@export var jump_speed = -300
enum {IDLE, RUN, JUMP, HURT, DEAD}
var state = IDLE
func _ready():
    change_state(IDLE)
func change_state(new_state):
    state = new_state
    match state:
        IDLE:
            $AnimationPlayer.play("idle")
        RUN:
            $AnimationPlayer.play("run")
        HURT:
            $AnimationPlayer.play("hurt")
        JUMP:
            $AnimationPlayer.play("jump_up")
        DEAD:
            hide()</pre>
			<p>For now, the script <a id="_idIndexMarker267"/>only changes which animation is playing, but you’ll add more state <span class="No-Break">functionality later.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Player movement</h2>
			<p>The player needs three controls: left, right, and jump. Comparing the current state to which keys are pressed will trigger a state change if the<a id="_idIndexMarker268"/> transition is allowed by the state diagram’s rules. Add the <strong class="source-inline">get_input()</strong> function to process the inputs and determine the result. Each <strong class="source-inline">if</strong> condition represents one of the transitions in the <span class="No-Break">state diagram:</span></p>
			<pre class="source-code">
func get_input():
    var right = Input.is_action_pressed("right")
    var left = Input.is_action_pressed("left")
    var jump = Input.is_action_just_pressed("jump")
    # movement occurs in all states
    velocity.x = 0
    if right:
        velocity.x += run_speed
        $Sprite2D.flip_h = false
    if left:
        velocity.x -= run_speed
        $Sprite2D.flip_h = true
    # only allow jumping when on the ground
    if jump and is_on_floor():
        change_state(JUMP)
        velocity.y = jump_speed
    # IDLE transitions to RUN when moving
    if state == IDLE and velocity.x != 0:
        change_state(RUN)
    # RUN transitions to IDLE when standing still
    if state == RUN and velocity.x == 0:
        change_state(IDLE)
    # transition to JUMP when in the air
    if state in [IDLE, RUN] and !is_on_floor():
        change_state(JUMP)</pre>
			<p>Note that the jump check is using <strong class="source-inline">is_action_just_pressed()</strong> rather than <strong class="source-inline">is_action_pressed()</strong>. While the latter returns <strong class="source-inline">true</strong> so long as the key is held down, the former is only <strong class="source-inline">true</strong> in the<a id="_idIndexMarker269"/> frame after the key was pressed. This means that the player must press the jump key each time they want <span class="No-Break">to jump.</span></p>
			<p>Call this function from <strong class="source-inline">_physics_process()</strong>, add the pull of gravity to the player’s <strong class="source-inline">velocity</strong>, and call the <strong class="source-inline">move_and_slide()</strong> method <span class="No-Break">to move:</span></p>
			<pre class="source-code">
func _physics_process(delta):
    velocity.y += gravity * delta
    get_input()
    move_and_slide()</pre>
			<p>Remember, since the <strong class="bold">Up Direction</strong> property is set to <strong class="source-inline">(0, -1)</strong>, any collision below the player’s feet will be considered the “floor,” and <strong class="source-inline">is_on_floor()</strong> will be set to <strong class="source-inline">true</strong> by <strong class="source-inline">move_and_slide()</strong>. You can <a id="_idIndexMarker270"/>use this fact to detect when the jump ends by adding this right <span class="No-Break">after </span><span class="No-Break"><strong class="source-inline">move_and_slide()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if state == JUMP and is_on_floor():
    change_state(IDLE)</pre>
			<p>The jump will look better if the animation switches from <strong class="source-inline">jump_up</strong> to <strong class="source-inline">jump_down</strong> <span class="No-Break">when falling:</span></p>
			<pre class="source-code">
if state == JUMP and velocity.y &gt; 0:
    $AnimationPlayer.play("jump_down")</pre>
			<p>Later, once the level is complete, the player will be passed a spawn location. To handle this, add this function to <span class="No-Break">the script:</span></p>
			<pre class="source-code">
func reset(_position):
    position = _position
    show()
    change_state(IDLE)</pre>
			<p>With that, you have finished adding movement, and the correct animation should play for each situation. This would be a good point to stop and test the player to make sure everything is working. You can’t just run the scene, though, because the player will just start falling without any surface to <span class="No-Break">stand on.</span></p>
			<h3>Testing the movement</h3>
			<p>Create a new scene and add a <strong class="source-inline">Node</strong> object called <strong class="source-inline">Main</strong> (later, this will become your main scene). Add an instance of <strong class="source-inline">Player</strong>, then add a <strong class="source-inline">StaticBody2D</strong> node with a rectangular collision <a id="_idIndexMarker271"/>shape. Stretch the collision shape horizontally so that it’s wide enough to walk back and forth on, and place it below <span class="No-Break">the character:</span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B19289_04_10.jpg" alt="Figure 4.10: Test scene with a platform"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10: Test scene with a platform</p>
			<p>Since it doesn’t have a <strong class="source-inline">Sprite2D</strong> node, the static body will be invisible if you run the game. In the menu, choose <strong class="bold">Debug</strong> &gt; <strong class="bold">Visible Collision Shapes</strong>. This is a useful debug setting that will draw the collision shapes while the game is running. You can turn it on whenever you need to test or <span class="No-Break">troubleshoot collisions.</span></p>
			<p>Press <strong class="bold">Play Scene</strong>; you should see the player stop falling and run the <strong class="source-inline">idle</strong> animation when it hits the <span class="No-Break">static body.</span></p>
			<p>Before moving on, make <a id="_idIndexMarker272"/>sure that all the movements and animations are working correctly. Run and jump in all directions and check that the correct animations are playing whenever the state changes. If you find any problems, review the previous sections and make sure you didn’t miss <span class="No-Break">a step.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Player health</h2>
			<p>Eventually, the player is going to<a id="_idIndexMarker273"/> encounter danger, so you should add a damage system. The player will start with three hearts and lose one each time they <span class="No-Break">are damaged.</span></p>
			<p>Add the following to the top of the script (just after the <span class="No-Break"><strong class="source-inline">extends</strong></span><span class="No-Break"> line):</span></p>
			<pre class="source-code">
signal life_changed
signal died
var life = 3: set = set_life
func set_life(value):
    life = value
    life_changed.emit(life)
    if life &lt;= 0:
        change_state(DEAD)</pre>
			<p>You’ll emit the <strong class="source-inline">life_changed</strong> signal whenever the value of <strong class="source-inline">life</strong> changes, notifying the display to update. <strong class="source-inline">dead</strong> will be emitted when <strong class="source-inline">life</strong> <span class="No-Break">reaches </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
			<p>Add <strong class="source-inline">life = 3</strong> to the <span class="No-Break"><strong class="source-inline">reset()</strong></span><span class="No-Break"> function.</span></p>
			<p>There are two possible <a id="_idIndexMarker274"/>ways for the player to be hurt: running into a spike object in the environment or being hit by an enemy. In either event, the following function can <span class="No-Break">be called:</span></p>
			<pre class="source-code">
func hurt():
    if state != HURT:
        change_state(HURT)</pre>
			<p>This code is being nice to the player: if they’re already hurt, they can’t get hurt again (at least for a brief time until the <strong class="source-inline">hurt</strong> animation has stopped playing). Without this, it’s easy to get stuck in a loop of getting hurt, resulting in a <span class="No-Break">quick death.</span></p>
			<p>There are a few things to do when the state changes to <strong class="source-inline">HURT</strong> in the <strong class="source-inline">change_state()</strong> function you <span class="No-Break">created earlier:</span></p>
			<pre class="source-code">
HURT:
    $AnimationPlayer.play("hurt")
    velocity.y = -200
    velocity.x = -100 * sign(velocity.x)
    life -= 1
    await get_tree().create_timer(0.5).timeout
    change_state(IDLE)
DEAD:
    died.emit()
    hide()</pre>
			<p>When they’re hurt, not only do they lose one <strong class="source-inline">life</strong>, but they are also bounced up and away from the damaging object. After a short time, the state changes back <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">IDLE</strong></span><span class="No-Break">.</span></p>
			<p>Also, the input should be <a id="_idIndexMarker275"/>disabled during the <strong class="source-inline">HURT</strong> state. Add this to the beginning <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">get_input()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if state == HURT:
    return</pre>
			<p>Now, the player is ready to take damage once the rest of the game has been set up. Next, you will create the objects that the player will collect in <span class="No-Break">the game.</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Collectible items</h1>
			<p>Before you start <a id="_idIndexMarker276"/>making the level, you need to create some items that the player can collect, since those will be part of the level as well. The <strong class="source-inline">assets/sprites</strong> folder contains sprite sheets for two types of collectibles: cherries <span class="No-Break">and gems.</span></p>
			<p>Rather than make a separate scene for<a id="_idIndexMarker277"/> each type of item, you can use a single scene and swap out the <strong class="source-inline">texture</strong> property in the script. Both objects have the same behavior: animating in place and disappearing when collected by the player. You can also add a <strong class="source-inline">tween</strong> effect for the collection (see <a href="B19289_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Scene setup</h2>
			<p>Start the new scene with <strong class="source-inline">Area2D</strong> and name it <strong class="source-inline">Item</strong>. Save the scene in a new <span class="No-Break"><strong class="source-inline">items</strong></span><span class="No-Break"> folder.</span></p>
			<p>An area is a good choice for these<a id="_idIndexMarker278"/> objects because you want to detect when the player contacts them, but you don’t need a collision response from them. In the Inspector, set <strong class="bold">Collision/Layer</strong> to <strong class="source-inline">collectibles</strong> (layer 4) and <strong class="bold">Collision/Mask</strong> to <strong class="source-inline">player</strong> (layer 2). This will ensure that only the <strong class="source-inline">Player</strong> node will be able to collect them, while the enemies will pass <span class="No-Break">right through.</span></p>
			<p>Add three child nodes: <strong class="source-inline">Sprite2D</strong>, <strong class="source-inline">CollisionShape2D</strong>, and <strong class="source-inline">AnimationPlayer</strong>. Drag <strong class="source-inline">res://assets/sprites/cherry.png</strong> into the <strong class="source-inline">Sprite2D</strong> node’s <strong class="bold">Texture</strong>. Set <strong class="bold">HFrames</strong> to <strong class="source-inline">5</strong>. Then, add a circle shape to <strong class="source-inline">CollisionShape2D</strong> and size <span class="No-Break">it appropriately:</span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B19289_04_11.jpg" alt="Figure 4.11: Item with collision"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11: Item with collision</p>
			<p class="callout-heading">Choosing a collision size</p>
			<p class="callout">As a general rule, you should size your collision shapes so that they benefit the player. This means that enemy hitboxes should be a little smaller than the image, while the hitboxes of beneficial items should be slightly oversized. This reduces player frustration and results in a better <span class="No-Break">gameplay experience.</span></p>
			<p>Add a new animation to <strong class="source-inline">AnimationPlayer</strong> (you only need one, so you can name it anything you like). Set <strong class="bold">Length</strong> to <strong class="source-inline">1.6</strong> seconds, <strong class="bold">Snap</strong> to <strong class="source-inline">0.2</strong> seconds, and <strong class="bold">Looping</strong> to <strong class="bold">on</strong>. Click the <strong class="bold">Autoplay on Load</strong> button <a id="_idIndexMarker279"/>so that the animation will <span class="No-Break">start automatically.</span></p>
			<p>Set the <strong class="source-inline">Sprite2D</strong> node’s <strong class="bold">Frame</strong> property to <strong class="source-inline">0</strong> and click the key button to create the track. This sprite sheet only contains half the animation, so the animation needs to play the frames in the <span class="No-Break">following order:</span></p>
			<p class="author-quote"><em class="italic">0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</em></p>
			<p>Drag the scrubber to time <strong class="source-inline">0.8</strong> and key <strong class="bold">Frame</strong> at <strong class="source-inline">4</strong>. Then, key <strong class="bold">Frame</strong> <strong class="source-inline">1</strong> at time <strong class="source-inline">1.4</strong>. Set <strong class="bold">Update Mode</strong> to <strong class="bold">Continuous</strong> and press the <strong class="bold">Play</strong> button. You will have a nicely animated cherry! Note that you can also drag the <strong class="source-inline">res://assets/sprites/coin.png</strong> image into <strong class="bold">Texture</strong> and it will work just the same since it has the same number of frames. This will make it easy to spawn both cherries and gems in <span class="No-Break">your game.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Collectible script</h2>
			<p>The <strong class="source-inline">Item</strong> script needs to do <span class="No-Break">two things:</span></p>
			<ul>
				<li>Set the start <a id="_idIndexMarker280"/>conditions (which <strong class="source-inline">texture</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">position</strong></span><span class="No-Break">)</span></li>
				<li>Detect when the <span class="No-Break">player overlaps</span></li>
			</ul>
			<p>For the first part, add the following code to your new <span class="No-Break">item script:</span></p>
			<pre class="source-code">
extends Area2D
signal picked_up
var textures = {
    "cherry": "res://assets/sprites/cherry.png",
    "gem": "res://assets/sprites/gem.png"
}
func init(type, _position):
    $Sprite2D.texture = load(textures[type])
    position = _position</pre>
			<p>You’ll emit the <strong class="source-inline">picked_up</strong> signal when the player collects the item. In the <strong class="source-inline">textures</strong> dictionary, you will find a list of the item types and their corresponding image files. Note that you can quickly paste those paths into the script by dragging the file from <strong class="bold">FileSystem</strong> and dropping it into the <span class="No-Break">script editor.</span></p>
			<p>Next, the <strong class="source-inline">init()</strong> function sets <strong class="source-inline">texture</strong> and <strong class="source-inline">position</strong>. Your level script will use this to spawn all the items that you’ve placed in your <span class="No-Break">level map.</span></p>
			<p>Finally, connect the <strong class="source-inline">body_entered</strong> signal of <strong class="source-inline">Item</strong> and add <span class="No-Break">this code:</span></p>
			<pre class="source-code">
func _on_item_body_entered(body):
    picked_up.emit()
    queue_free()</pre>
			<p>This signal will allow the game’s main script to react to the item being picked up. It can add to the score, increase<a id="_idIndexMarker281"/> the player’s health, or any other effect you want the item <span class="No-Break">to apply.</span></p>
			<p>You might have noticed that these collectible items are set up very much like the coins from <em class="italic">Coin Dash</em> were. Areas are very useful for any type of item where you need to know when it’s been touched. In the next section, you’ll start laying out the level scene so that you can place <span class="No-Break">these collectibles.</span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Designing the level</h1>
			<p>For most of you, this <a id="_idIndexMarker282"/>section will take up the largest chunk of your time. Once you start designing a level, you’ll find it’s a lot of fun to lay out all the pieces and create challenging jumps, secret paths, and <span class="No-Break">dangerous encounters.</span></p>
			<p>First, you’ll create a generic <strong class="source-inline">Level</strong> scene containing all the nodes and code that is common to all levels. You<a id="_idIndexMarker283"/> can then create any number of <strong class="source-inline">Level</strong> scenes that inherit from this <span class="No-Break">master level.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/>Using TileMaps</h2>
			<p>Create a new scene and add a <strong class="source-inline">Node2D</strong> node named <strong class="source-inline">LevelBase</strong>. Save the scene in a new folder called <strong class="source-inline">levels</strong>. This is where you’ll save all the levels you create, and they will all inherit<a id="_idIndexMarker284"/> functionality from this <strong class="source-inline">level_base.tscn</strong> scene. They’ll all have the same node hierarchy – only the layout will <span class="No-Break">be different.</span></p>
			<p>A tilemap is a common tool for <a id="_idIndexMarker285"/>designing game environments using a grid of tiles. They allow you to draw a level layout by painting the tiles onto the grid rather than placing many individual nodes one at a time. They are also more efficient because they batch all the individual tile textures and collision shapes into a single <span class="No-Break">game object.</span></p>
			<p>Add a <strong class="source-inline">TileMap</strong> node; a new <strong class="bold">TileMap</strong> panel will appear at the bottom of the editor window. Note that it says <strong class="bold">The edited TileMap has no </strong><span class="No-Break"><strong class="bold">TileSet resource</strong></span><span class="No-Break">.</span></p>
			<h3>About TileSets</h3>
			<p>To draw a map using <strong class="source-inline">TileMap</strong>, it must have <strong class="source-inline">TileSet</strong> assigned. This <strong class="source-inline">TileSet</strong> contains all the individual tile textures, along with any collision shapes they <span class="No-Break">may have.</span></p>
			<p>Depending on how many tiles <a id="_idIndexMarker286"/>you may have, it can be time-consuming to create <strong class="source-inline">TileSet</strong>, especially for the first time. For that reason, some pre-generated tilesets have been included in the <strong class="source-inline">assets</strong> folder. Feel free to use those instead, but <a id="_idIndexMarker287"/>do read through the following section. It contains useful information to help you understand how <strong class="source-inline">TileSet</strong> works. If you’d rather use the provided tilesets, skip to the <em class="italic">Using the provided </em><span class="No-Break"><em class="italic">TileSets</em></span><span class="No-Break"> section.</span></p>
			<h4>Creating a TileSet</h4>
			<p>In Godot, <strong class="source-inline">TileSet</strong> is a type of <strong class="source-inline">Resource</strong>. Examples of other resources include <strong class="source-inline">Texture</strong>, <strong class="source-inline">Animation</strong>, and <strong class="source-inline">RectangleShape2D</strong>. They are not nodes; instead, they are containers that hold a certain type of data and are usually saved as <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">tres</strong></span><span class="No-Break"> files.</span></p>
			<p>These are the steps for <a id="_idIndexMarker288"/>creating a <span class="No-Break"><strong class="source-inline">TileSet</strong></span><span class="No-Break"> container:</span></p>
			<ol>
				<li>Click <strong class="bold">New TileSet</strong> in the <strong class="bold">Tile Set</strong> area of <strong class="source-inline">TileMap</strong>. You’ll see that you now have a <strong class="bold">TileSet</strong> panel available, which you can select at the bottom of the editor window. You can click the two upward arrows, <img src="image/B19289_04_12.png" alt=""/>, to make the panel fill the editor screen. Click it again to shrink <span class="No-Break">the panel.</span></li>
				<li>The <strong class="bold">Tiles</strong> tab on the left-hand side of the <strong class="source-inline">TileSet</strong> panel is where you can place the textures that you want to slice up into tiles. Drag <strong class="source-inline">res://assets/environment/tileset.png</strong> into this box. A popup will appear, asking if you’d like to automatically create tiles. Select <strong class="bold">Yes</strong>. You’ll see that boxes have been drawn around all the <strong class="source-inline">16x16</strong> pixel tiles in <span class="No-Break">the image:</span></li>
			</ol>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B19289_04_13.jpg" alt="Figure 4.12: Adding a TileSet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12: Adding a TileSet</p>
			<ol>
				<li value="3">Try selecting the <strong class="bold">TileMap</strong> panel at the bottom and then select the grass block image in the top left of the tiles. Then, click in<a id="_idIndexMarker289"/> the editor window to draw some tiles by left-clicking in the editor window. You can right-click on a tile to <span class="No-Break">clear it:</span></li>
			</ol>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B19289_04_14.jpg" alt="Figure 4.13: Drawing with TileMaps"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13: Drawing with TileMaps</p>
			<p>If all you wanted to do was draw a background, you’d be done. However, you also need to add collisions<a id="_idIndexMarker290"/> to these tiles so that the player can stand <span class="No-Break">on them.</span></p>
			<ol>
				<li value="4">Open the <strong class="bold">TileSet</strong> panel again and, in the Inspector, find the <strong class="bold">PhysicsLayers</strong> property and click <span class="No-Break"><strong class="bold">Add Element</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B19289_04_15.jpg" alt="Figure 4.14: Adding a physics layer to TileSet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14: Adding a physics layer to TileSet</p>
			<p>Since these tiles will be in the <strong class="source-inline">environment</strong> layer, you don’t need to change the <span class="No-Break">layer/mask settings.</span></p>
			<ol>
				<li value="5">Click <strong class="bold">Paint</strong> in the <strong class="bold">TileSet</strong> panel <a id="_idIndexMarker291"/>and, under <strong class="bold">Paint Properties</strong>, choose <strong class="source-inline">Physics </strong><span class="No-Break"><strong class="source-inline">Layer 0</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B19289_04_16.jpg" alt="Figure 4.15: Adding collisions to tiles"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15: Adding collisions to tiles</p>
			<ol>
				<li value="6">Start clicking on the tiles to add the default square collision shape to them. If you want to edit a tile’s collision shape, you can do so – click the tile again to apply the changes. If you get stuck with a shape you don’t like, click the three dots and choose <strong class="bold">Reset to default </strong><span class="No-Break"><strong class="bold">tile shape</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>You can also <a id="_idIndexMarker292"/>drag the <strong class="source-inline">props.png</strong> image into the texture list for some decorative items to spice up <span class="No-Break">your level.</span></p>
			<h3>Using the provided TileSets</h3>
			<p>Pre-configured tilesets have been included in the <strong class="source-inline">assets</strong> download for this project. There are three to be <a id="_idIndexMarker293"/>added to three different <span class="No-Break"><strong class="source-inline">TileMap</strong></span><span class="No-Break"> nodes:</span></p>
			<ul>
				<li> <strong class="source-inline">World</strong> – <strong class="source-inline">tiles_world.tres</strong>: Ground and <span class="No-Break">platform tiles</span></li>
				<li> <strong class="source-inline">Items</strong> – <strong class="source-inline">tiles_items.tres</strong>: Markers for <span class="No-Break">spawning collectibles</span></li>
				<li> <strong class="source-inline">Danger</strong> – <strong class="source-inline">tiles_spikes.tres</strong>: Items that cause damage <span class="No-Break">on collision</span></li>
			</ul>
			<p>Create the <strong class="source-inline">Items</strong> and <strong class="source-inline">Danger</strong> tilemaps and add the associated tileset to the <strong class="bold">Tile </strong><span class="No-Break"><strong class="bold">Set</strong></span><span class="No-Break"> property.</span></p>
			<p>Add an instance of the <strong class="source-inline">Player</strong> scene and a <strong class="source-inline">Marker2D</strong> node named <strong class="source-inline">SpawnPoint</strong>. You can use this node to mark where in your level you want the player <span class="No-Break">to start.</span></p>
			<p>Attach a script to the <span class="No-Break"><strong class="source-inline">Level</strong></span><span class="No-Break"> node:</span></p>
			<pre class="source-code">
extends Node2D
func _ready():
    $Items.hide()
    $Player.reset($SpawnPoint.position)</pre>
			<p>Later, you’ll be scanning the <strong class="source-inline">Items</strong> map to spawn collectibles in the designated locations. This map layer shouldn’t be seen, so you could set it as hidden in the scene. However, this is easy to forget, so <strong class="source-inline">_ready()</strong> ensures that it’s not visible <span class="No-Break">during gameplay.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Designing the first level</h2>
			<p>Now, you’re ready to start drawing the level! Click <strong class="bold">Scene</strong> &gt; <strong class="bold">New Inherited Scene</strong> and choose <strong class="source-inline">level_base.tscn</strong>. Name the root node <strong class="source-inline">Level01</strong> and save it (in the <strong class="source-inline">levels</strong> folder). Notice that the child <a id="_idIndexMarker294"/>nodes are colored yellow, indicating that they are <strong class="bold">inherited</strong> from the original <strong class="source-inline">level_base.tscn</strong>. If you make changes to that original scene, those changes will also appear in <span class="No-Break">this scene.</span></p>
			<p>Start with the <strong class="source-inline">World</strong> map and be creative. Do you like lots of jumps, or twisty tunnels to explore? Long runs or careful <span class="No-Break">upward climbs?</span></p>
			<p>Before going too far with your level design, make sure you experiment with jump distance. You can change the player’s <strong class="source-inline">jump_speed</strong>, <strong class="source-inline">run_speed</strong>, and <strong class="source-inline">gravity</strong> properties to alter how high and how far they can jump. Set up some different gap sizes and run the scene to try them out. Don’t forget to drag the <strong class="source-inline">SpawnPoint</strong> node to the place you want the player <span class="No-Break">to start.</span></p>
			<p>How you set the player’s movement properties will have a big impact on how your level should be laid out. Make sure you’re happy with your settings before spending too much time on the <span class="No-Break">full design.</span></p>
			<p>Once you have the <strong class="source-inline">World</strong> map set up, use the <strong class="source-inline">Items</strong> map to mark the locations where you’d like to spawn the cherries and gems. The tiles that mark the spawn locations are drawn with a magenta background to make them stand out. Remember, they’ll be replaced at runtime and the tiles themselves won’t <span class="No-Break">be seen.</span></p>
			<p>Once you have your level laid out, you can limit the horizontal scrolling of the player camera to match the size of the map (plus a small buffer on each end). Add this code <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">level_base.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func _ready():
    $Items.hide()
    $Player.reset($SpawnPoint.position)
    set_camera_limits()
func set_camera_limits():
    var map_size = $World.get_used_rect()
    var cell_size = $World.tile_set.tile_size
    $Player/Camera2D.limit_left = (map_size.position.x - 5)
        * cell_size.x
    $Player/Camera2D.limit_right = (map_size.end.x + 5) *
        cell_size.x</pre>
			<p>The script also needs to scan the <strong class="source-inline">Items</strong> map and look for the item markers. Collecting items will add to the <a id="_idIndexMarker295"/>player’s score, so you can add a variable to track that <span class="No-Break">as well:</span></p>
			<pre class="source-code">
signal score_changed
var item_scene = load("res://items/item.tscn")
var score = 0: set = set_score
func spawn_items():
    var item_cells = $Items.get_used_cells(0)
    for cell in item_cells:
        var data = $Items.get_cell_tile_data(0, cell)
        var type = data.get_custom_data("type")
        var item = item_scene.instantiate()
        add_child(item)
        item.init(type, $Items.map_to_local(cell))
        item.picked_up.connect(self._on_item_picked_up)
func _on_item_picked_up():
    score += 1
func set_score(value):
    score = value
    score_changed.emit(score)</pre>
			<p>The <strong class="source-inline">spawn_items()</strong> function uses <strong class="source-inline">get_used_cells()</strong> to get a list of which cells in <strong class="source-inline">TileMap</strong> are not empty. These cells are in <strong class="source-inline">_map coordinates_</strong>, not pixel coordinates, so later, when you<a id="_idIndexMarker296"/> spawn the item, you can use <strong class="source-inline">map_to_local()</strong> to convert <span class="No-Break">the values.</span></p>
			<p>The marker tiles<a id="_idIndexMarker297"/> have a <strong class="bold">custom data</strong> layer attached to them (similar to the physics layer you added to the world tiles) that specifies what type they are: <strong class="source-inline">gem</strong> or <strong class="source-inline">cherry</strong>. That’s then used to tell the new instance which type of item it <span class="No-Break">should be.</span></p>
			<p>The <strong class="source-inline">score</strong> variable is there to keep track of how many items the player has collected. You could have this trigger completion of the level, give a bonus, and <span class="No-Break">so on.</span></p>
			<p>Add <strong class="source-inline">spawn_items()</strong> to <strong class="source-inline">_ready()</strong> and try running the level. You should see gems and cherries appear wherever you’ve added them. Also, check that they disappear when you <span class="No-Break">collect them.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Adding dangerous objects</h2>
			<p>The <strong class="source-inline">Danger</strong> map layer is<a id="_idIndexMarker298"/> designed to hold the spike objects that will harm the player when touched. Any tile on this <strong class="source-inline">TileMap</strong> will cause damage to the player! Try placing a few of them where you can easily test running <span class="No-Break">into them.</span></p>
			<p>In the <strong class="bold">Node</strong> tab, add the <strong class="source-inline">Danger</strong> tilemap to a group called <strong class="source-inline">danger</strong> so that you can easily identify it when colliding. This will also allow you to make other harmful objects upon adding them to the <span class="No-Break">same group.</span></p>
			<h3>About slide collisions</h3>
			<p>When a <strong class="source-inline">CharacterBody2D</strong> node is moved with <strong class="source-inline">move_and_slide()</strong>, it may collide with more than one object in the same frame’s movement. For example, when running into a corner, the body may hit the wall and the floor at the same time. You can use the <strong class="source-inline">get_slide_collision_count()</strong> function to find out how many collisions occurred; then, you can get information about each collision <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">get_slide_collision()</strong></span><span class="No-Break">.</span></p>
			<p>In the case of <strong class="source-inline">Player</strong>, you <a id="_idIndexMarker299"/>want to detect when a collision occurs against the <strong class="source-inline">Danger</strong> tilemap. You can do this just after using <strong class="source-inline">move_and_slide()</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">player.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if state == HURT:
    return
for i in get_slide_collision_count():
    var collision = get_slide_collision(i)
    if collision.get_collider().is_in_group("danger"):
        hurt()</pre>
			<p>Note that before checking for a collision with the <strong class="source-inline">danger</strong> group, you can first check if the player is already in the <strong class="source-inline">HURT</strong> state. If they are, you can skip checking to see if they are colliding with a <span class="No-Break">dangerous object.</span></p>
			<p>The <strong class="source-inline">for</strong> loop iterates through the number of collisions given by <strong class="source-inline">get_slide_collision_count()</strong> to check each one for an object in the <span class="No-Break">danger group.</span></p>
			<p>Play your scene and try running into one of the spikes. You should see the player change to the <strong class="source-inline">HURT</strong> state (playing the animation) for a brief time before returning to <strong class="source-inline">IDLE</strong>. After three hits, the player will enter the <strong class="source-inline">DEAD</strong> state, which currently only hides <span class="No-Break">the player.</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Scrolling background</h2>
			<p>There are two background images in the <strong class="source-inline">res://assets/environment/</strong> folder: <strong class="source-inline">back.png</strong> and <strong class="source-inline">middle.png</strong>, for the far and near background, respectively. By placing these images behind the tilemap <a id="_idIndexMarker300"/>and scrolling them at different speeds relative to the camera, you can create an attractive illusion of depth in <span class="No-Break">the background:</span></p>
			<ol>
				<li>Add a <strong class="source-inline">ParallaxBackground</strong> node to the <strong class="source-inline">LevelBase</strong> scene (so that it will be present on all inherited levels). This node works with the camera to create a scrolling effect. Drag this node to the top of the scene tree so that it will be drawn behind the rest of the nodes. Next, add a <strong class="source-inline">ParallaxLayer</strong> node as its child. <strong class="source-inline">ParallaxBackground</strong> can have any number of <strong class="source-inline">ParallaxLayer</strong> children, allowing you to make multiple independently <span class="No-Break">scrolling layers.</span></li>
				<li>Add a <strong class="source-inline">Sprite2D</strong> node as a child of <strong class="source-inline">ParallaxLayer</strong> and drag the <strong class="source-inline">back.png</strong> image into its <strong class="bold">Texture</strong> area. Uncheck the <strong class="bold">Offset/Centered</strong> property so that it will be positioned relative to the screen origin. It’s also a little small, so set the <strong class="source-inline">Sprite2D</strong> node’s <strong class="bold">Scale</strong> to <strong class="source-inline">(</strong><span class="No-Break"><strong class="source-inline">1.5, 1.5)</strong></span><span class="No-Break">.</span></li>
				<li>On <strong class="source-inline">ParallaxLayer</strong>, set <strong class="bold">Motion/Scale</strong> to <strong class="source-inline">(0.2, 1)</strong> (you’ll need to click the <strong class="bold">link</strong> icon to allow the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> values to be set separately). This setting controls how fast the background scrolls concerning the camera movement. By setting it to a number less than <strong class="source-inline">1</strong>, the image will only move a small amount as the player moves<a id="_idIndexMarker301"/> left <span class="No-Break">and right.</span></li>
				<li>You need to be sure the image repeats if your level is wider than the size of the image, so set <strong class="bold">Motion/Mirroring</strong> to <strong class="source-inline">(576, 0)</strong>. This is exactly the width of the image (<strong class="source-inline">384</strong> times <strong class="source-inline">1.5</strong>), so the image will be repeated when it has moved by that number <span class="No-Break">of pixels.</span></li>
				<li>Note that this background image is designed for levels that are wide rather than tall. If you jump too high, you’ll see the top of the image. You can fix this by setting the top limit of the camera. If you haven’t moved the background’s position, its top-left corner will still be at (<strong class="source-inline">0, 0)</strong>, so you can set the <strong class="bold">Top</strong> limit on the camera to <strong class="source-inline">0</strong>. If you have moved <strong class="source-inline">ParallaxLayer</strong> or its <strong class="source-inline">Sprite2D</strong> node, you can find the correct value to use by looking at the <strong class="source-inline">y</strong> value of the <span class="No-Break">node’s </span><span class="No-Break"><strong class="bold">Position</strong></span><span class="No-Break">.</span></li>
				<li>Try playing the level and running left and right. You should see the background moving by a small amount compared to how far <span class="No-Break">you run.</span></li>
				<li>Add another <strong class="source-inline">ParallaxLayer</strong> (also as a child of <strong class="source-inline">ParallaxBackground</strong>) and give it a <strong class="source-inline">Sprite2D</strong> child. This time, use the <strong class="source-inline">middle.png</strong> image. This image is much narrower than the sky image, so you’ll need to adjust some settings to make it repeat properly. This is because <strong class="source-inline">ParallaxBackground</strong> needs to have images<a id="_idIndexMarker302"/> that are at least as big as the <span class="No-Break">viewport area.</span></li>
				<li>Find the <strong class="source-inline">Sprite2D</strong> node’s <strong class="bold">Texture/Repeat</strong> property in the <strong class="bold">CanvasItem</strong> section and set it to <strong class="source-inline">Mirror</strong>. Then, expand the <strong class="bold">Region</strong> section and check the <strong class="bold">Enabled</strong> box. Under <strong class="bold">Rect</strong>, set the width and height to <strong class="source-inline">(880, 368)</strong>. <strong class="source-inline">880</strong> is the width of the image (<strong class="source-inline">176</strong>) multiplied by <strong class="source-inline">5</strong>, so you will now see five repetitions of the image, each one a mirror of <span class="No-Break">the last.</span></li>
				<li>Move the <strong class="source-inline">Sprite2D</strong> node so that the image overlaps the bottom half of the <span class="No-Break">ocean/sky image:</span></li>
			</ol>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B19289_04_17.jpg" alt="Figure 4.16: Parallax background setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16: Parallax background setup</p>
			<ol>
				<li value="10">Set the second <strong class="source-inline">ParallaxLayer</strong> node’s <strong class="bold">Motion/Scale</strong> to <strong class="source-inline">(0.6, 1)</strong> and <strong class="bold">Motion/Mirroring</strong> to (<strong class="source-inline">880, 0)</strong>. Using a higher scale factor means that this layer will scroll a little bit<a id="_idIndexMarker303"/> faster than the cloud layer behind it. Play the scene to test <span class="No-Break">the effect.</span></li>
			</ol>
			<p>Your <strong class="source-inline">Level</strong> scene’s node tree should now look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B19289_04_18.jpg" alt="Figure 4.17: Level scene nodes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17: Level scene nodes</p>
			<p>Your level scene now has all the pieces you need to create your level design. Do you want your player to have to make very precise jumps (a parkour level), run through a series of winding passages trying to find all the items (a maze level), or some combination of the two? This is your chance to try out some creative ideas, but make sure you leave some room for the next object you’ll <span class="No-Break">make: enemies.</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Adding enemies</h1>
			<p>There are many<a id="_idIndexMarker304"/> different behaviors you could add for an enemy. For this game, the <a id="_idIndexMarker305"/>enemy will walk along a platform in a straight line and change direction when hitting <span class="No-Break">an obstacle.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Scene setup</h2>
			<p>As before, you’ll need to<a id="_idIndexMarker306"/> create a new scene to represent <span class="No-Break">the enemy:</span></p>
			<ol>
				<li>Start with a <strong class="source-inline">CharacterBody2D</strong> node named <strong class="source-inline">Enemy</strong> and give it three children: <strong class="source-inline">Sprite2D</strong>, <strong class="source-inline">CollisionShape2D</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">AnimationPlayer</strong></span><span class="No-Break">.</span></li>
				<li>Save the scene in a folder called <strong class="source-inline">enemies</strong>. If you decide to add more enemy types to the game, you can save them <span class="No-Break">all here.</span></li>
				<li>Set the body’s collision <strong class="bold">Layer</strong> to <strong class="bold">enemies</strong> and its <strong class="bold">Mask</strong> to <strong class="bold">environment</strong>, <strong class="bold">player</strong>, and <strong class="bold">enemies</strong>. As with the player, this determines which types of objects the enemy will <span class="No-Break">collide with.</span></li>
				<li>It’s also useful to group enemies together, so click the <strong class="bold">Node</strong> tab and add the body to a group <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">enemies</strong></span><span class="No-Break">.</span></li>
				<li>Add <strong class="source-inline">res://assets/sprites/opossum.png</strong> to <strong class="bold">Texture</strong> and set <strong class="bold">Animation/Hframes</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">6</strong></span><span class="No-Break">.</span></li>
				<li>Add a rectangular collision shape that covers most (but not all) of the image, making sure that the bottom of the collision shape is aligned with the bottom of the <span class="No-Break">opossum’s feet:</span></li>
			</ol>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B19289_04_19.jpg" alt="Figure 4.18: Enemy collision shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18: Enemy collision shape</p>
			<ol>
				<li value="7">Add a new animation to <strong class="source-inline">AnimationPlayer</strong> called <strong class="source-inline">walk</strong>. Set <strong class="bold">Length</strong> to <strong class="source-inline">0.6</strong> seconds and turn <strong class="bold">Looping</strong> and <strong class="bold">Autoplay on </strong><span class="No-Break"><strong class="bold">Load</strong></span><span class="No-Break"> on.</span></li>
				<li>The <strong class="source-inline">walk</strong> animation needs to have two tracks: one that sets the <strong class="bold">Texture</strong> property of the <strong class="source-inline">Sprite2D</strong> node and one that changes its <strong class="bold">Frame</strong> property. Click the key icon next to <strong class="bold">Texture</strong> to add the first track, then add keyframes for <strong class="bold">Frame</strong> <strong class="source-inline">0</strong> at time<a id="_idIndexMarker307"/> zero, and <strong class="bold">Frame</strong> <strong class="source-inline">5</strong> at time <strong class="source-inline">0.5</strong>. Don’t forget to change <strong class="bold">Update Mode</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Continuous</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>When finished, your animation should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B19289_04_20.jpg" alt="Figure 4.19: Enemy animations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19: Enemy animations</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>Scripting the enemy</h2>
			<p>By now, moving a <strong class="source-inline">CharacterBody2D</strong> node be familiar to you. Look at this script and try to understand what it’s <a id="_idIndexMarker308"/>doing before reading the explanation <span class="No-Break">provided after:</span></p>
			<pre class="source-code">
extends CharacterBody2D
@export var speed = 50
@export var gravity = 900
var facing = 1
func _physics_process(delta):
    velocity.y += gravity * delta
    velocity.x = facing * speed
    $Sprite2D.flip_h = velocity.x &gt; 0
    move_and_slide()
    for i in get_slide_collision_count():
        var collision = get_slide_collision(i)
        if collision.get_collider().name == "Player":
            collision.get_collider().hurt()
        if collision.get_normal().x != 0:
            facing = sign(collision.get_normal().x)
            velocity.y = -100
    if position.y &gt; 10000:
        queue_free()</pre>
			<p>In this script, the <strong class="source-inline">facing</strong> variable keeps track of the movement in the <strong class="source-inline">x</strong> direction, either <strong class="source-inline">1</strong> or <strong class="source-inline">-1</strong>. As with the player, after moving, you must check the slide collisions. If the colliding object is the player, you must call its <span class="No-Break"><strong class="source-inline">hurt()</strong></span><span class="No-Break"> function.</span></p>
			<p>Next, you must check whether the colliding body’s <strong class="bold">normal</strong> vector has an <strong class="source-inline">x</strong> component that isn’t <strong class="source-inline">0</strong>. This means it points to<a id="_idIndexMarker309"/> the left or right, which means it is a wall or other obstacle. The direction of the normal is then used to set the new facing. Giving the body a small upward velocity will give the enemy a small bounce effect when turning around, which will look <span class="No-Break">more appealing.</span></p>
			<p>Lastly, if for some reason the enemy falls off a platform, you don’t want the game to have to track it falling forever, so you must delete any enemy whose <strong class="source-inline">y</strong> coordinate becomes <span class="No-Break">too large.</span></p>
			<p>Add an instance of <strong class="source-inline">Enemy</strong> to your level scene. Make sure it has some obstacles on either side and play the scene. Check that the enemy walks back and forth between the obstacles. Try putting the player in<a id="_idIndexMarker310"/> its path and verify that the player’s <strong class="source-inline">hurt()</strong> function <span class="No-Break">is called.</span></p>
			<p>You may notice that if you jump on top of the enemy, nothing happens. We will handle that <span class="No-Break">part next.</span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>Damaging the enemy</h2>
			<p>It’s not fair if the player can’t hit back, so<a id="_idIndexMarker311"/> in the tradition of Mario, jumping on top of the enemy will <span class="No-Break">defeat it.</span></p>
			<p>Start by adding a new animation to the enemy’s <strong class="source-inline">AnimationPlayer</strong> node called <strong class="source-inline">death</strong>. Set <strong class="bold">Length</strong> to <strong class="source-inline">0.3</strong> and <strong class="bold">Snap</strong> to <strong class="source-inline">0.05</strong>. Don’t turn on looping for <span class="No-Break">this animation.</span></p>
			<p>The <strong class="source-inline">death</strong> animation will also set both <strong class="bold">Texture</strong> and <strong class="bold">Frame</strong>. Drag the <strong class="source-inline">res://assets/sprites/enemy_death.png</strong> image into the sprite’s <strong class="bold">Texture</strong> area and then click the key to add a keyframe for it. As before, keyframe the <strong class="source-inline">0</strong> and <strong class="source-inline">5</strong> values of <strong class="bold">Frame</strong> at the start and end of the animation. Remember to set <strong class="bold">Update Mode</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Continuous</strong></span><span class="No-Break">.</span></p>
			<p>Add the following code to <strong class="source-inline">enemy.gd</strong> so that you have a way to trigger the death animation on <span class="No-Break">the enemy:</span></p>
			<pre class="source-code">
func take_damage():
    $AnimationPlayer.play("death")
    $CollisionShape2D.set_deferred("disabled", true)
    set_physics_process(false)</pre>
			<p>When the player hits the enemy under the right conditions, it will call <strong class="source-inline">take_damage()</strong>, which plays the <strong class="source-inline">death</strong> animation, disables collision, and <span class="No-Break">halts movement.</span></p>
			<p>When the death animation finishes playing, it’s OK to remove the enemy, so connect the <strong class="source-inline">animation_finished</strong> signal <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">AnimationPlayer</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B19289_04_21.jpg" alt="Figure 4.20: AnimationPlayer’s signals"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20: AnimationPlayer’s signals</p>
			<p>This signal is called every time <a id="_idIndexMarker312"/>any animation finishes, so you need to check if it’s the <span class="No-Break">correct one:</span></p>
			<pre class="source-code">
func _on_animation_player_animation_finished(anim_name):
    if anim_name == "death":
        queue_free()</pre>
			<p>To complete this process, go to the <strong class="source-inline">player.gd</strong> script and add the following code to the section of <strong class="source-inline">_physics_process()</strong> where you check the collisions. This code will check if the player hit an enemy <span class="No-Break">from above:</span></p>
			<pre class="source-code">
for i in get_slide_collision_count():
    var collision = get_slide_collision(i)
    if collision.get_collider().is_in_group("danger"):
        hurt()
    if collision.get_collider().is_in_group("enemies"):
        if position.y &lt; collision.get_collider().position.y:
            collision.get_collider().take_damage()
            velocity.y = -200
        else:
            hurt()</pre>
			<p>This code compares the <strong class="source-inline">y</strong> position of the player’s feet to the enemy’s <strong class="source-inline">y</strong> position to see if the player is above the enemy. If they <a id="_idIndexMarker313"/>are, the enemy should be hurt; otherwise, the player <span class="No-Break">should be.</span></p>
			<p>Run the level again and try jumping on the enemy to check that everything is working <span class="No-Break">as expected.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/>Player script</h2>
			<p>You’ve made <a id="_idIndexMarker314"/>several additions to the player’s script. Here’s what the full script should look <span class="No-Break">like now:</span></p>
			<pre class="source-code">
extends CharacterBody2D
signal life_changed
signal died
@export var gravity = 750
@export var run_speed = 150
@export var jump_speed = -300
enum {IDLE, RUN, JUMP, HURT, DEAD}
var state = IDLE
var life = 3: set = set_life
func _ready():
    change_state(IDLE)
func change_state(new_state):
    state = new_state
    match state:
        IDLE:
            $AnimationPlayer.play("idle")
        RUN:
            $AnimationPlayer.play("run")
        HURT:
            $AnimationPlayer.play("hurt")
            velocity.y = -200
            velocity.x = -100 * sign(velocity.x)
            life -= 1
            await get_tree().create_timer(0.5).timeout
            change_state(IDLE)
        JUMP:
            $AnimationPlayer.play("jump_up")
        DEAD:
            died.emit()
            hide()
func get_input():
    if state == HURT:
        return
    var right = Input.is_action_pressed("right")
    var left = Input.is_action_pressed("left")
    var jump = Input.is_action_just_pressed("jump")
    # movement occurs in all states
    velocity.x = 0
    if right:
        velocity.x += run_speed
        $Sprite2D.flip_h = false
    if left:
        velocity.x -= run_speed
        $Sprite2D.flip_h = true
    # only allow jumping when on the ground
    if jump and is_on_floor():
        change_state(JUMP)
        velocity.y = jump_speed
    # IDLE transitions to RUN when moving
    if state == IDLE and velocity.x != 0:
        change_state(RUN)
    # RUN transitions to IDLE when standing still
    if state == RUN and velocity.x == 0:
        change_state(IDLE)
    # transition to JUMP when in the air
    if state in [IDLE, RUN] and !is_on_floor():
        change_state(JUMP)
func _physics_process(delta):
    velocity.y += gravity * delta
    get_input()
    move_and_slide()
    if state == HURT:
        return
    for i in get_slide_collision_count():
        var collision = get_slide_collision(i)
        if collision.get_collider().is_in_group("danger"):
            hurt()
        if collision.get_collider().is_in_group("enemies"):
            if position.y &lt;
            collision.get_collider().position.y:
                collision.get_collider().take_damage()
                velocity.y = -200
            else:
                hurt()
    if state == JUMP and is_on_floor():
        change_state(IDLE)
    if state == JUMP and velocity.y &gt; 0:
        $AnimationPlayer.play("jump_down")
func reset(_position):
    position = _position
    show()
    change_state(IDLE)
    life = 3
func set_life(value):
    life = value
    life_changed.emit(life)
    if life &lt;= 0:
        change_state(DEAD)
func hurt():
    if state != HURT:
        change_state(HURT)</pre>
			<p>If you’re having any trouble with the player code, try to think about what part could be the problem. Is it the<a id="_idIndexMarker315"/> movement? The hit detection when running into an enemy? If you can narrow down the problem, it’ll help you determine which part of the script you should be <span class="No-Break">focusing on.</span></p>
			<p>Make sure you’re satisfied with how the player is behaving before moving on to the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Game UI</h1>
			<p>As in the previous <a id="_idIndexMarker316"/>projects you’ve worked on, you’ll need a HUD to display information during gameplay. Collecting items will increase the player’s score, so that number should be displayed, as well as the player’s remaining life value, which will be shown as a series <span class="No-Break">of hearts.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Scene setup</h2>
			<p>Create a new scene with a <strong class="source-inline">MarginContainer</strong> root node named <strong class="source-inline">HUD</strong> and save it in a new <strong class="source-inline">ui</strong> folder. Set <strong class="bold">Layout</strong> to <strong class="bold">Top Wide</strong> and, in the <strong class="bold">Theme Overrides/Constants</strong> section of the Inspector, set the<a id="_idIndexMarker317"/> right and left margins to <strong class="source-inline">50</strong> and the top/bottom margins <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">20</strong></span><span class="No-Break">.</span></p>
			<p>Add an <strong class="source-inline">HBoxContainer</strong> node to keep things aligned and give it two children, <strong class="source-inline">Label</strong> and <strong class="source-inline">HBoxContainer</strong>, named <strong class="source-inline">Score</strong> and <span class="No-Break"><strong class="source-inline">LifeCounter</strong></span><span class="No-Break">, respectively.</span></p>
			<p>On the <strong class="source-inline">Score</strong> label, set the <strong class="bold">Text</strong> property to <strong class="source-inline">100</strong> and in the Inspector, under <strong class="bold">Layout/Container Sizing</strong>, check the <strong class="bold">Expand</strong> box. In <strong class="bold">Label Settings</strong>, add a new settings object to configure the font. Drag <strong class="source-inline">res://assets/Kenney Thick.ttf</strong> into the <strong class="bold">Font</strong> property and set <strong class="bold">Size</strong> to <strong class="source-inline">48</strong>. Under <strong class="bold">Outline</strong>, set <strong class="bold">Size</strong> to <strong class="source-inline">16</strong> and <strong class="bold">Color</strong> to black. You should see <strong class="source-inline">100</strong> displayed in white with a <span class="No-Break">black outline.</span></p>
			<p>For <strong class="source-inline">LifeCounter</strong>, add a <strong class="source-inline">TextureRect</strong> child and name it <strong class="source-inline">L1</strong>. Drag <strong class="source-inline">res://assets/heart.png</strong> into its <strong class="bold">Texture</strong> area and set <strong class="bold">Stretch Mode</strong> to <strong class="bold">Keep Aspect Centered</strong>. Select <strong class="source-inline">L1</strong> and duplicate (<em class="italic">Ctrl</em> + <em class="italic">D</em>) it four times so that you have a row of <span class="No-Break">five hearts:</span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B19289_04_22.jpg" alt="Figure 4.21: HUD node setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21: HUD node setup</p>
			<p>When you’re finished, your HUD should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B19289_04_23.jpg" alt="Figure 4.22: HUD preview"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.22: HUD preview</p>
			<p>The next step will be<a id="_idIndexMarker318"/> to add a script so that the HUD can update during <span class="No-Break">the game.</span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Scripting the HUD</h2>
			<p>This script needs two <a id="_idIndexMarker319"/>functions that can be called to update the two values <span class="No-Break">being displayed:</span></p>
			<pre class="source-code">
extends MarginContainer
@onready var life_counter = $HBoxContainer/LifeCounter.get_children()
func update_life(value):
    for heart in life_counter.size():
        life_counter[heart].visible = value &gt; heart
func update_score(value):
    $HBoxContainer/Score.text = str(value)</pre>
			<p>Note that, in <strong class="source-inline">update_life()</strong>, you calculate how many hearts to display by setting <strong class="source-inline">visible</strong> to <strong class="source-inline">false</strong> if the number of that <a id="_idIndexMarker320"/>heart is less than the <span class="No-Break">life amount.</span></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Attaching the HUD</h2>
			<p>Open <strong class="source-inline">level_base.tscn</strong> (the base level <a id="_idIndexMarker321"/>scene, not your <strong class="source-inline">Level01</strong> scene) and add <strong class="source-inline">CanvasLayer</strong>. Add an instance of <strong class="source-inline">HUD</strong> as a child of <span class="No-Break">this </span><span class="No-Break"><strong class="source-inline">Canvaslayer</strong></span><span class="No-Break">.</span></p>
			<p>Select the level’s <strong class="source-inline">Player</strong> instance and connect its <strong class="source-inline">life_changed</strong> signal to the HUD’s <span class="No-Break"><strong class="source-inline">update_life()</strong></span><span class="No-Break"> method:</span></p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B19289_04_24.jpg" alt="Figure 4.23: Connecting a signal"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.23: Connecting a signal</p>
			<p>Do the same with the <strong class="source-inline">score_changed</strong> signal of the <strong class="source-inline">Level</strong> node, connecting it to the HUD’s <span class="No-Break"><strong class="source-inline">update_score()</strong></span><span class="No-Break"> method.</span></p>
			<p>Note that if you don’t want to use the scene tree to connect the signals, or if you find the signal connection window confusing or difficult to use, you can accomplish the same thing in your script by adding<a id="_idIndexMarker322"/> these lines to the <strong class="source-inline">_ready()</strong> function <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">level.gd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$Player.life_changed.connect($CanvasLayer/HUD.update_life)
score_changed.connect($CanvasLayer/HUD.update_score)</pre>
			<p>Play the game and verify that you can see the HUD and that it updates correctly. Make sure you collect some items and let the enemy hit you. Is your score increasing? When you’re hit, do you lose one heart? Once you’ve checked this, you can continue to the next section and make the <span class="No-Break">title screen.</span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Title screen</h1>
			<p>The title <a id="_idIndexMarker323"/>screen is the first thing the player will see, and the game will return to this screen when the player dies and the <span class="No-Break">game ends.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Scene setup</h2>
			<p>Start with a <strong class="source-inline">Control</strong> node <a id="_idIndexMarker324"/>and set <strong class="bold">Layout</strong> to <strong class="bold">Full Rect</strong>. Add a <strong class="source-inline">TextureRect</strong> node using the <strong class="source-inline">back.png</strong> image. Set <strong class="bold">Layout</strong> to <strong class="bold">Full Rect</strong> and <strong class="bold">Stretch Mode</strong> to <strong class="bold">Keep </strong><span class="No-Break"><strong class="bold">Aspect Covered</strong></span><span class="No-Break">.</span></p>
			<p>Add another <strong class="source-inline">TextureRect</strong>, this time using <strong class="source-inline">middle.png</strong> and setting <strong class="bold">Stretch Mode</strong> to <strong class="bold">Tile</strong>. Drag the width of the rectangle until it’s wider than the screen and arrange it so that it covers the <span class="No-Break">bottom half.</span></p>
			<p>Add two <strong class="source-inline">Label</strong> nodes named <strong class="source-inline">Title</strong> and <strong class="source-inline">Message</strong> and set their <strong class="bold">Text</strong> properties to <strong class="source-inline">Jungle Jump</strong> and <strong class="source-inline">Press Space to Play</strong>, respectively. Add the font to each one as you’ve done before, setting the title to size <strong class="source-inline">72</strong> and the message to size <strong class="source-inline">48</strong>. Set the title’s layout to <strong class="bold">Centered</strong> and the message’s layout to <span class="No-Break"><strong class="bold">Center Bottom</strong></span><span class="No-Break">.</span></p>
			<p>When you’re finished, the scene should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B19289_04_25.jpg" alt="Figure 4.24: Title screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.24: Title screen</p>
			<p>To make the title screen more interesting, add an <strong class="source-inline">AnimationPlayer</strong> node to it. Create a new animation named <strong class="source-inline">intro</strong> and set it to autoplay. In this animation, you can animate the elements of the screen to make them move, appear, fade in, or any other effect <span class="No-Break">you like.</span></p>
			<p>For example, keyframe the current <strong class="bold">Position</strong> of <strong class="source-inline">Title</strong> at time <strong class="source-inline">0.5</strong>. Then, at time <strong class="source-inline">0</strong>, drag <strong class="source-inline">Title</strong> off the top of the screen and add another keyframe. Now, the title will drop onto the screen when you play <span class="No-Break">the scene.</span></p>
			<p>Feel free to add tracks that <a id="_idIndexMarker325"/>animate the other nodes’ properties. For example, here is an animation that drops the title down, fades in the two textures, and then makes the <span class="No-Break">message appear:</span></p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B19289_04_26.jpg" alt="Figure 4.25: Title screen animations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.25: Title screen animations</p>
			<p>This title screen has been kept simple, but you should feel free to add to it if you’d like. You could show an example of some platforms, add an animation of the character running across the screen, or some other game art. But what happens when the player hits “start”? For this, you need to load the first level in the <span class="No-Break">main scene.</span></p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor137"/>Setting up the main scene</h1>
			<p>You’ve made<a id="_idIndexMarker326"/> some level scenes, but eventually, you’re going to want to make more than one. How does the game know which one to load? Your <strong class="source-inline">Main</strong> scene is going to take care <span class="No-Break">of that.</span></p>
			<p>Delete any extra nodes you added to <strong class="source-inline">main.tscn</strong> when you were testing the player’s movement. This scene will now be responsible for loading the current level. Before it can do that, however, you need a way to keep track of the current level. You can’t keep track of that variable in the level scene because that will be replaced with a newly loaded level when it ends. To keep track of data that needs to be carried from scene to scene, you can<a id="_idIndexMarker327"/> use <span class="No-Break">an </span><span class="No-Break"><strong class="bold">autoload</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">About autoloads</p>
			<p class="callout">In Godot, you can configure a script or scene as an autoload. This means that the engine will automatically load it at all times. Even if you change the current scene in <strong class="source-inline">SceneTree</strong>, the autoloaded node will remain. You can also refer to that autoloaded scene by name from any other node in <span class="No-Break">your game.</span></p>
			<p>In the <strong class="bold">Script</strong> editor, create<a id="_idIndexMarker328"/> a new script named <strong class="source-inline">game_state.gd</strong> and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
extends Node
var num_levels = 2
var current_level = 0
var game_scene = "res://main.tscn"
var title_screen = "res://ui/title.tscn"
func restart():
    current_level = 0
    get_tree().change_scene_to_file(title_screen)
func next_level():
    current_level += 1
    if current_level &lt;= num_levels:
        get_tree().change_scene_to_file(game_scene)</pre>
			<p>You should set <strong class="source-inline">num_levels</strong> to the number of levels you’ve created in the <strong class="source-inline">levels</strong> folder. Make sure you name them consistently as <strong class="source-inline">level_01.tscn</strong>, <strong class="source-inline">level_02.tscn</strong>, and so on so that they can be <span class="No-Break">found easily.</span></p>
			<p>To add this script as an autoload, open <strong class="bold">Project Settings</strong> and find the <strong class="bold">Autoload</strong> tab. Click the folder icon to <a id="_idIndexMarker329"/>choose <strong class="source-inline">game_state.gd</strong> and then click the <span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break"> button.</span></p>
			<p>Next, add this script to your <span class="No-Break"><strong class="source-inline">Main</strong></span><span class="No-Break"> scene:</span></p>
			<pre class="source-code">
extends Node
func _ready():
    var level_num = str(GameState.current_level).pad_zeros(2)
    var path = "res://levels/level_%s.tscn" % level_num
    var level = load(path).instantiate()
    add_child(level)</pre>
			<p>Now, whenever the <strong class="source-inline">Main</strong> scene is loaded, it will include the level scene that corresponds to the <span class="No-Break">current level.</span></p>
			<p>The title screen needs to transition to the game scene, so attach this script to the <span class="No-Break"><strong class="source-inline">Title</strong></span><span class="No-Break"> node:</span></p>
			<pre class="source-code">
extends Control
func _input(event):
    if event.is_action_pressed("ui_select"):
        GameState.next_level()</pre>
			<p>Finally, you can call the <strong class="source-inline">restart()</strong> function when the player dies by adding it to <strong class="source-inline">level.gd</strong>. In the <strong class="source-inline">Level</strong> scene, connect the <strong class="source-inline">Player</strong> instance’s <span class="No-Break"><strong class="source-inline">died</strong></span><span class="No-Break"> signal:</span></p>
			<pre class="source-code">
func _on_player_died():
    GameState.restart()</pre>
			<p>You should now be able to play through the game fully. Make sure <strong class="source-inline">title.tscn</strong> is set as the game’s main scene (that is, the <a id="_idIndexMarker330"/>one that runs first). If you’ve previously set a different scene to be the “main” scene, you can change this in <strong class="bold">Projects Settings</strong> <span class="No-Break">under </span><span class="No-Break"><strong class="bold">Application/Run</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B19289_04_27.jpg" alt="Figure 4.26: Choosing a main scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.26: Choosing a main scene</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Transitioning between levels</h1>
			<p>Your levels now need <a id="_idIndexMarker331"/>a way to transition from one to the next. In the <strong class="source-inline">res://assets/environment/props.png</strong> sprite sheet, there is an image of a door that you can use for your level’s exit. Finding and walking into the door will take the player to the <span class="No-Break">next level.</span></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>Door scene</h2>
			<p>Make a new scene with an <strong class="source-inline">Area2D</strong> node <a id="_idIndexMarker332"/>named <strong class="source-inline">Door</strong> and save it in the <strong class="source-inline">items</strong> folder. Add a <strong class="source-inline">Sprite2D</strong> node and use the <strong class="source-inline">props.png</strong> image as <strong class="bold">Texture</strong>. Under <strong class="bold">Region</strong>, click <strong class="bold">Enabled</strong>, and then click the <strong class="bold">Edit Region</strong> button to select the door image from the sprite sheet. Then, in <strong class="bold">Offset/Offset</strong>, set <strong class="bold">y</strong> to <strong class="source-inline">-8</strong>. This will ensure that when the door is placed at the tile location, it will be <span class="No-Break">positioned correctly.</span></p>
			<p>Add a <strong class="source-inline">CollisionShape2D</strong> node and give it a rectangular shape that covers the door. Put the door on the <strong class="source-inline">items</strong> layer and set its mask so that it only scans the <span class="No-Break"><strong class="source-inline">player</strong></span><span class="No-Break"> layer.</span></p>
			<p>This scene doesn’t need a script because you’re just going to use its <strong class="source-inline">body_entered</strong> signal in the <span class="No-Break">level script.</span></p>
			<p>To place the door in the level, you <a id="_idIndexMarker333"/>can use the door object from the <strong class="source-inline">tiles_items</strong> tileset, which you are using in your <strong class="source-inline">Items</strong> tilemap to place the cherries and gems. Place a door in your level and <span class="No-Break">open </span><span class="No-Break"><strong class="source-inline">level.gd</strong></span><span class="No-Break">.</span></p>
			<p>At the top of <strong class="source-inline">level.gd</strong>, define the <span class="No-Break">door scene:</span></p>
			<pre class="source-code">
var door_scene = load("res://items/door.tscn")</pre>
			<p>Then, update <strong class="source-inline">spawn_items()</strong> so that it also <span class="No-Break">instantiates doors:</span></p>
			<pre class="source-code">
func spawn_items():
    var item_cells = $Items.get_used_cells(0)
    for cell in item_cells:
        var data = $Items.get_cell_tile_data(0, cell)
        var type = data.get_custom_data("type")
        if type == "door":
            var door = door_scene.instantiate()
            add_child(door)
            door.position = $Items.map_to_local(cell)
            door.body_entered.connect(_on_door_entered)
        else:
            var item = item_scene.instantiate()
            add_child(item)
            item.init(type, $Items.map_to_local(cell))
            item.picked_up.connect(self._on_item_picked_up)</pre>
			<p>Add the function that will be called when the player touches <span class="No-Break">the door:</span></p>
			<pre class="source-code">
func _on_door_entered(body):
    GameState.next_level()</pre>
			<p>Play the game and try walking into the door. If you’ve set <strong class="source-inline">num_levels</strong> in <strong class="source-inline">game_state.gd</strong> to a number greater than 1, the game will attempt to load <strong class="source-inline">level_02.tscn</strong> when you<a id="_idIndexMarker334"/> touch <span class="No-Break">the door.</span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Screen settings</h2>
			<p>Recall that at the beginning of this chapter, you set <strong class="bold">Stretch/Mode</strong> and <strong class="bold">Aspect</strong> in <strong class="bold">Project Settings</strong> to <strong class="source-inline">canvas_items</strong> and <strong class="source-inline">expand</strong>, respectively. Run the game, and then try resizing the game window. Notice that if you make the window wider, you can see more of the game<a id="_idIndexMarker335"/> world to the player’s left/right. This is what the <strong class="source-inline">expand</strong> value <span class="No-Break">is doing.</span></p>
			<p>If you want to prevent this, you can set it to <strong class="source-inline">keep</strong> instead, which will always show the same amount of the game world as shown by the camera. However, it also means that if you make your window a different shape than the game, you’ll get black bars to fill in the <span class="No-Break">extra space.</span></p>
			<p>Alternatively, setting <strong class="source-inline">ignore</strong> will not display the black bars, but the game content will be stretched to fill the space, distorting <span class="No-Break">the image.</span></p>
			<p>Take some time to experiment with the various settings and decide which one <span class="No-Break">you prefer.</span></p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Finishing touches</h1>
			<p>Now that you’ve completed the main structure of the game, and hopefully designed a few levels for the<a id="_idIndexMarker336"/> player to enjoy, you can consider making some additions to improve the gameplay. In this section, you’ll find a few more suggested features – add them as-is or adjust them to <span class="No-Break">your liking.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Sound effects</h2>
			<p>As with the previous projects, you can add audio effects and music to improve the experience. In <strong class="source-inline">res://assets/audio/</strong>, you’ll find audio files you can use for different game<a id="_idIndexMarker337"/> events, such as player jump, enemy hit, and item pickup. There are also two music files: <strong class="source-inline">Intro Theme</strong> for the title screen and <strong class="source-inline">Grasslands Theme</strong> for the <span class="No-Break">level scene.</span></p>
			<p>Adding these to the game will be left to you, but here are a <span class="No-Break">few tips:</span></p>
			<ul>
				<li>You may find it helpful to adjust the volume of individual sounds. This can be set with the <strong class="bold">Volume dB</strong> property. Setting a negative value will reduce the <span class="No-Break">sound’s volume.</span></li>
				<li>You can attach the music to the master <strong class="source-inline">level.tscn</strong> scene; that music will be used for all levels. You could also attach separate music to individual levels if you want to set a <span class="No-Break">certain mood.</span></li>
				<li>Your first thought might be to put <strong class="source-inline">AudioStreamPlayer</strong> on the <strong class="source-inline">Item</strong> scene to play the pickup sound. However, since the pickup is deleted when the player touches it, that won’t work well. Instead, put the audio player in the <strong class="source-inline">Level</strong> scene, since that’s where the result of the pickup is handled (increasing <span class="No-Break">the score).</span></li>
			</ul>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>Double jumping</h2>
			<p>Double jumps are a popular <a id="_idIndexMarker338"/>platforming feature. The player gets a second, usually smaller, upwards boost if they press the jump key a second time while in the air. To implement this feature, you need to add a few things to the <span class="No-Break">player script.</span></p>
			<p>First, you will need variables to track the number of jumps and determine how big the second boost <span class="No-Break">will be:</span></p>
			<pre class="source-code">
@export var max_jumps = 2
@export var double_jump_factor = 1.5
var jump_count = 0</pre>
			<p>When entering the <strong class="source-inline">JUMP</strong> state, reset the number <span class="No-Break">of jumps:</span></p>
			<pre class="source-code">
JUMP:
    $AnimationPlayer.play("jump_up")
    jump_count = 1</pre>
			<p>In <strong class="source-inline">get_input()</strong>, allow the jump if it meets the conditions that have been. Put this before the <strong class="source-inline">if</strong> statement where <a id="_idIndexMarker339"/>you check if the player is on <span class="No-Break">the floor:</span></p>
			<pre class="source-code">
if jump and state == JUMP and jump_count &lt; max_jumps and jump_count &gt; 0:
    $JumpSound.play()
    $AnimationPlayer.play("jump_up")
    velocity.y = jump_speed / double_jump_factor
    jump_count += 1</pre>
			<p>In <strong class="source-inline">_physics_process()</strong>, when you land on the ground, reset the <span class="No-Break">jump count:</span></p>
			<pre class="source-code">
if state == JUMP and is_on_floor():
    change_state(IDLE)
    jump_count = 0</pre>
			<p>Play your game and try out the double jumps. Note that this code makes the second jump 2/3rds the size of the upward speed of the initial jump. You can adjust this according to <span class="No-Break">your preferences.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>Dust particles</h2>
			<p>Spawning dust particles at the <a id="_idIndexMarker340"/>character’s feet is a low-effort effect that can add a lot of character to your player’s movements. In this section, you’ll add a small puff of dust to the player’s feet that is emitted whenever they land on the ground. This adds a sense of weight and impact to the <span class="No-Break">player’s jumps.</span></p>
			<p>Add a <strong class="source-inline">CPUParticles2D</strong> node to the <strong class="source-inline">Player</strong> scene and name it <strong class="source-inline">Dust</strong>. Set the <span class="No-Break">following properties:</span></p>
			<table id="table003" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Property</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Value</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Amount</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">20</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Lifetime</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">0.45</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">One Shot</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">On</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Speed Scale</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">2</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Explosiveness</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">0.7</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Emission Shape</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Rectangle</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Rect Extents</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">1, 6</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Initial <span class="No-Break">Velocity Max</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">10</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Scale <span class="No-Break">Amount Max</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">3</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Position</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">2, 0</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Rotation</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">90</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>The default particle color is white, but the dust effect will look better in a tan shade. It should also fade away so that it appears to dissipate. This can be accomplished with <strong class="source-inline">Gradient</strong>. In the <strong class="bold">Color/Color Ramp</strong> area, select <span class="No-Break"><strong class="bold">New Gradient</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">Gradient</strong> has two colors: a start<a id="_idIndexMarker341"/> color on the left and an end color on the right. These can be selected using the small rectangles at either end of the gradient. Clicking on the large square on the right allows you to set the color for the <span class="No-Break">selected rectangle:</span></p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B19289_04_28.jpg" alt="Figure 4.27: Color Ramp"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.27: Color Ramp</p>
			<p>Set the start color to a tan shade, and set the end to the same color, but with the alpha value set to <strong class="source-inline">0</strong>. You should see a continuously puffing smoke effect. In the Inspector, set <strong class="bold">One Shot</strong> to on. Now, the particles will only emit once, each time you check the <span class="No-Break"><strong class="bold">Emitting</strong></span><span class="No-Break"> box.</span></p>
			<p>Feel free to alter the <a id="_idIndexMarker342"/>properties that have been provided here. Experimenting with particle effects can be great fun, and often, you’ll stumble upon a very nice effect just <span class="No-Break">by tinkering.</span></p>
			<p>Once you’re happy with its appearance, add the following to the player’s <span class="No-Break"><strong class="source-inline">_physics_process()</strong></span><span class="No-Break"> code:</span></p>
			<pre class="source-code">
if state == JUMP and is_on_floor():
    change_state(IDLE)
    $Dust.emitting = true</pre>
			<p>Run the game and observe the puff of dust every time your character lands on <span class="No-Break">the ground.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Ladders</h2>
			<p>The player sprite sheet includes<a id="_idIndexMarker343"/> frames for a climbing animation, and the tileset contains<a id="_idIndexMarker344"/> ladder images. Currently, the ladder tiles do nothing – in <strong class="source-inline">TileSet</strong>, they do not have any collision shape assigned. That’s OK because you don’t want the player to collide with the ladders – you want them to be able to move up and down <span class="No-Break">on them.</span></p>
			<h3>Player code</h3>
			<p>Start by selecting the player’s <strong class="source-inline">AnimationPlayer</strong> node <a id="_idIndexMarker345"/>and adding a new animation called <strong class="source-inline">climb</strong>. Its <strong class="bold">Length</strong> should be <strong class="source-inline">0.4</strong> and it should be set to <strong class="bold">loop</strong>. The <strong class="bold">Frame</strong> values for <strong class="source-inline">Sprite2D</strong> are <em class="italic">0 -&gt; 1 -&gt; 0 -&gt; </em><span class="No-Break"><em class="italic">2</em></span><span class="No-Break">.</span></p>
			<p>Go to <strong class="source-inline">player.gd</strong> and add a new state, <strong class="source-inline">CLIMB</strong>, to the <strong class="source-inline">state</strong> enum. In addition, add two new variable declarations at the top of <span class="No-Break">the script:</span></p>
			<pre class="source-code">
@export var climb_speed = 50
var is_on_ladder = false</pre>
			<p>You’ll use <strong class="source-inline">is_on_ladder</strong> to keep track of whether the player is on a ladder or not. Using this, you can decide whether the up and down actions should have <span class="No-Break">any effect.</span></p>
			<p>In <strong class="source-inline">change_state()</strong>, add a condition for the <span class="No-Break">new state:</span></p>
			<pre class="source-code">
CLIMB:
    $AnimationPlayer.play("climb")</pre>
			<p>In <strong class="source-inline">get_input()</strong>, you need to check for the input actions and then determine if they change <span class="No-Break">the state:</span></p>
			<pre class="source-code">
var up = Input.is_action_pressed("climb")
var down = Input.is_action_pressed("crouch")
if up and state != CLIMB and is_on_ladder:
    change_state(CLIMB)
if state == CLIMB:
    if up:
        velocity.y = -climb_speed
        $AnimationPlayer.play("climb")
    elif down:
        velocity.y = climb_speed
        $AnimationPlayer.play("climb")
    else:
        velocity.y = 0
        $AnimationPlayer.stop()
if state == CLIMB and not is_on_ladder:
    change_state(IDLE)</pre>
			<p>Here, you have three new conditions to check. First, if the player is not in the <strong class="source-inline">CLIMB</strong> state but is on a ladder, then pressing up should make the player start climbing. Second, if the player is currently climbing, then the up and down inputs should make them move up and down the ladder, but <a id="_idIndexMarker346"/>stop the animation from playing if no action is pressed. Finally, if the player leaves the ladder while climbing, they leave the <span class="No-Break"><strong class="source-inline">CLIMB</strong></span><span class="No-Break"> state.</span></p>
			<p>You also need to make sure that gravity doesn’t pull the player downward while they’re on a ladder. Add a condition to the gravity code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">_physics_process()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if state != CLIMB:
    velocity.y += gravity * delta</pre>
			<p>Now, the player is ready to climb, which means you can add some ladders to <span class="No-Break">your level.</span></p>
			<h3>Level setup</h3>
			<p>Add an <strong class="source-inline">Area2D</strong> node named <strong class="source-inline">Ladders</strong> to the <strong class="source-inline">Level</strong> scene, but<a id="_idIndexMarker347"/> don’t add a collision shape to it yet. Connect its <strong class="source-inline">body_entered</strong> and <strong class="source-inline">body_exited</strong> signals and set its collision <strong class="bold">Layer</strong> to <strong class="source-inline">items</strong> and <strong class="bold">Mask</strong> to <strong class="source-inline">player</strong>. This ensures that only the player can interact with the ladder. These signals are how you’ll let the player know they are or aren’t on <span class="No-Break">a ladder:</span></p>
			<pre class="source-code">
func _on_ladders_body_entered(body):
    body.is_on_ladder = true
func _on_ladders_body_exited(body):
    body.is_on_ladder = false</pre>
			<p>Now, the level needs to look for any ladder tiles and add collision shapes to the <strong class="source-inline">Ladders</strong> area whenever it finds <a id="_idIndexMarker348"/>one. Add the following function to <strong class="source-inline">level.gd</strong> and call it <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">_ready()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func create_ladders():
    var cells = $World.get_used_cells(0)
    for cell in cells:
        var data = $World.get_cell_tile_data(0, cell)
        if data.get_custom_data("special") == "ladder":
            var c = CollisionShape2D.new()
            $Ladders.add_child(c)
            c.position = $World.map_to_local(cell)
            var s = RectangleShape2D.new()
            s.size = Vector2(8, 16)
            c.shape = s</pre>
			<p>Note that the collision shapes you’re adding are only <strong class="source-inline">8</strong> pixels wide. If you make the shape the full width of the ladder tile, then the player will still look as though they’re climbing even when they’re hanging off the side, which looks a <span class="No-Break">bit odd.</span></p>
			<p>Try it out – go to one of your level scenes and place some ladder tiles anywhere you’d like on your <strong class="source-inline">World</strong> tile map. Play the scene and try climbing <span class="No-Break">the ladders.</span></p>
			<p>Note that if you’re at the top of a ladder and step on it, you’ll fall to the bottom rather than climb down (although pressing up as you fall will cause you to grab the ladder). If you prefer to automatically transition to the climbing state, you can add an additional falling check <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">_physics_process()</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Moving platforms</h2>
			<p>Moving platforms are<a id="_idIndexMarker349"/> a fun addition to your level design toolkit. In this section, you’ll make a moving platform that you can place anywhere on your level and set its movement <span class="No-Break">and speed.</span></p>
			<p>Start with a new scene using a <strong class="source-inline">Node2D</strong> node and name it <strong class="source-inline">MovingPlatform</strong>. Save the scene and add <strong class="source-inline">TileMap</strong> as a child. Since your platform art is all in sprite sheets and they’ve already been sliced into tiles and had collisions added, this will make your platform easy to draw. Add <strong class="source-inline">tiles_world.tres</strong> as <strong class="bold">Tile Set</strong>. You’ll also need to check the <strong class="bold">Collision Animatable</strong> box, which will make sure the collisions work properly even <span class="No-Break">while moving.</span></p>
			<p>Draw a few tiles into <strong class="source-inline">TileMap</strong>, but make sure to start at the origin, <strong class="source-inline">(0, 0)</strong>, so that things will line up cleanly. These tiles work well for a <span class="No-Break">floating platform:</span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B19289_04_29.jpg" alt="Figure 4.28: Floating platform"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.28: Floating platform</p>
			<p>Add a script to the root node and start with <span class="No-Break">these variables:</span></p>
			<pre class="source-code">
@export var offset = Vector2(320, 0)
@export var duration = 10.0</pre>
			<p>These will allow you to set the movement amount and speed. <strong class="source-inline">offset</strong> is relative to the starting point, and since it’s a <strong class="source-inline">Vector2</strong> node, you can have platforms that move horizontally, vertically, or diagonally. <strong class="source-inline">duration</strong> is measured in seconds and represents how long the <em class="italic">complete</em> cycle <span class="No-Break">will take.</span></p>
			<p>The platform will always be moving, so you can start the animation in <strong class="source-inline">_ready()</strong>. It will use a <strong class="source-inline">tween</strong> method to animate the position in two steps: from the start position to the offset position and <span class="No-Break">vice versa:</span></p>
			<pre class="source-code">
func _ready():
    var tween = create_tween().set_process_mode(
        Tween.TWEEN_PROCESS_PHYSICS)
    tween.set_loops().set_parallel(false)
    tween.tween_property($TileMap, "position", offset,
        duration / 2.0).from_current()
    tween.tween_property($TileMap, "position",
        Vector2.ZERO, duration / 2.0)</pre>
			<p>Here are a few notes about <span class="No-Break">tween usage:</span></p>
			<ul>
				<li>You need to set the process mode so that the movement will be synced to physics and the player will be able to collide properly with the platform (that is, stand <span class="No-Break">on it).</span></li>
				<li><strong class="source-inline">set_loops()</strong> tells <strong class="source-inline">tween</strong> to repeat <span class="No-Break">once finished.</span></li>
				<li><strong class="source-inline">set_parallel(false)</strong> tells <strong class="source-inline">tween</strong> to perform the two property tweens sequentially rather than at<a id="_idIndexMarker350"/> the <span class="No-Break">same time.</span></li>
				<li>You can also experiment with other tween curves. Adding <strong class="source-inline">tween.set_trans(Tween.TRANS_SINE)</strong>, for example, will make the platform slow down at the ends of the movement for a more natural look. Try experimenting with the other <span class="No-Break">transition types.</span></li>
			</ul>
			<p>Now, you can add instances of <strong class="source-inline">MovingPlatform</strong> to the level scene. To make sure things line up properly, make sure you turn on <span class="No-Break">grid snapping:</span></p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B19289_04_30.jpg" alt="Figure 4.29: Enabling grid snapping"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.29: Enabling grid snapping</p>
			<p>The default value is <strong class="source-inline">(8, 8)</strong>, but you can change it by clicking the three dots next to the icon and choosing <span class="No-Break"><strong class="bold">Configure Snap</strong></span><span class="No-Break">.</span></p>
			<p>When you run the game now, you will have a lot more to interact with. The ladders and moving platforms give you a lot more possibilities for your level designs. But you don’t have to stop there! Considering everything you’ve done in this chapter, there are many other features that you could still add. The player animation includes a “crouching” animation – what if the enemies could throw things at the player that could be ducked under? Many platformer <a id="_idIndexMarker351"/>games include additional movement mechanics such as sliding down slopes, wall jumps, changing gravity, and many more. Choose one and see if you can <span class="No-Break">add it.</span></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Summary</h1>
			<p>In this chapter, you learned how to use the <strong class="source-inline">CharacterBody2D</strong> node to create arcade-style physics for player movement. This is a powerful node that can be used for a wide variety of game objects – not just <span class="No-Break">platform characters.</span></p>
			<p>You learned about the <strong class="source-inline">TileMap</strong> node for level design – a powerful tool with even more features than you used in this project. An entire chapter could be written on all of the different things you can do with it. For more information, see the <em class="italic">Using TileMaps</em> page on the Godot documentation <span class="No-Break">website: </span><span class="No-Break">https://docs.godotengine.org/en/latest/tutorials/2d/using_tilemaps.html</span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">Camera2D</strong> and <strong class="source-inline">ParallaxBackground</strong> are also key tools for any game where you want to move around in a world that’s bigger than the size of the screen. The camera node in particular will be a node that you’ll use in most <span class="No-Break">2D projects.</span></p>
			<p>You also made extensive use of what you learned in earlier projects to tie everything together. Hopefully, at this point, you have a good grasp of the scene system and how a Godot project <span class="No-Break">is structured.</span></p>
			<p>Once again, before moving on, take a few moments to play your game and look through its various scenes and scripts to review how you built it. Review any sections of this chapter that you found particularly tricky. And most importantly, before moving on, try to make some changes to <span class="No-Break">the project.</span></p>
			<p>In the next chapter, you’ll make the jump <span class="No-Break">to 3D!</span></p>
		</div>
	</body></html>