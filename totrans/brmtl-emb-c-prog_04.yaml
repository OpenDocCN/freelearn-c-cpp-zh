- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing the Linker Script and Startup File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we undertake an in-depth exploration of the core components
    of embedded **bare-metal programming**, focusing on three critical areas: the
    microcontroller memory model, the writing of the linker script, and the startup
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll explore the microcontroller memory model to understand how memory
    is organized and utilized. This knowledge is important for accurately allocating
    program code and data sections within the microcontroller memory. Next, we’ll
    go through the intricacies of writing linker scripts. These scripts are essential
    for correctly mapping our program to the appropriate sections of the microcontroller’s
    memory, ensuring that the executable runs as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will learn about the startup file and then proceed to write our
    own, focusing on initializing the vector table and configuring `Reset_Handler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the memory model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The linker scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the linker script and startup file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the STM32 memory model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the STM32 memory map consists of various memory areas, our primary focus
    in developing the linker script and startup file revolves around two critical
    areas: **flash memory** and **static random access memory** (**SRAM**). These
    areas are of utmost importance because they are directly involved in program storage.
    In the initial parts of this section, we will learn about the characteristics
    of these memory areas and the distinct roles they play.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.1* shows a section of the stm32f411 memory map, highlighting the
    flash memory and SRAM.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: A section of the STM32F11 memory map, highlighting the flash
    memory and SRAM areas](img/B21914_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: A section of the STM32F11 memory map, highlighting the flash memory
    and SRAM areas'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with flash memory.
  prefs: []
  type: TYPE_NORMAL
- en: Flash memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the primary advantages of flash memory is its non-volatile nature. This
    means that data stored in flash memory remains intact even when the power supply
    is disconnected. In STM32 microcontrollers (as well as other microcontrollers),
    flash memory is typically where the executable code is stored and is read-only
    during normal operation. Flash memory starts at the `0x08000000` address. However,
    its size varies depending on the specific STM32 microcontroller model.
  prefs: []
  type: TYPE_NORMAL
- en: STM32 microcontrollers come in various series and models, offering a range of
    flash memory densities to accommodate different application requirements.
  prefs: []
  type: TYPE_NORMAL
- en: What is memory density?
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory density** refers to the concentration of memory storage within a given
    physical space or component. Memory density is often expressed in terms of bits
    or bytes stored per unit of physical area, such as bits per square millimeter
    or bytes per square centimeter. It measures how densely or compactly data can
    be stored within that space. Higher memory density means that we can store more
    data than we can in a smaller physical space.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory size, on the other hand, refers to the total amount of memory (storage
    capacity) available in a given storage device. It is typically measured in units
    such as bytes, **kilobytes** (**KB**), **megabytes** (**MB**), **gigabytes** (**GB**),
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s talk about some operational nuances of flash memory.
  prefs: []
  type: TYPE_NORMAL
- en: Flash memory, including STM32 flash memory, has a limited number of program
    and erase cycles. Each time we write (program) or erase, it consumes one of these
    cycles. It is important to consider these limitations when designing applications
    that frequently write to or erase data from flash memory.
  prefs: []
  type: TYPE_NORMAL
- en: STM32 microcontrollers are known for their low power consumption, and this extends
    to their flash memory operations. Efficient power management ensures that the
    microcontroller can operate on minimal power while reading from or writing to
    flash memory, making STM32 devices suitable for battery-powered applications.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure data integrity, STM32 flash memory often includes built-in error correction
    mechanisms. These mechanisms help identify and correct errors that may occur during
    data storage and retrieval, enhancing the reliability of the stored firmware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some key attributes of the STM32 flash memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-only nature**: Primarily used for storing program code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x08000000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variable size**: Dependent on the specific STM32 microcontroller model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x08000004`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at the other primary memory areas relevant to writing our
    linker script and startup file.
  prefs: []
  type: TYPE_NORMAL
- en: SRAM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SRAM** is a type of volatile memory, meaning it loses its contents when the
    power supply is disconnected. It is used in STM32 microcontrollers for temporary
    data storage during program execution. Unlike flash memory, which is used for
    long-term storage of program code, SRAM is designed for high-speed access and
    low latency, making it ideal for storing variables, intermediate data, and managing
    the stack during runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Like flash memory, the STM32 microcontrollers feature varying sizes of SRAM,
    tailored to the needs of different applications. The size of the SRAM determines
    the amount of runtime data that can be handled and affects the overall performance
    of the microcontroller in handling complex tasks or multitasking. The SRAM in
    STM32 microcontrollers starts at the `0x20000000` address. Like flash memory,
    its size varies depending on the specific STM32 microcontroller model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key attributes of the STM32 SRAM:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read and write**: Variables and the stack are stored here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x20000000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variable size**: Dependent on the specific STM32 microcontroller model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before moving on to introduce the linker script, let’s touch on one other memory
    area that is not relevant to the linker script, but is still relevant to our understanding
    of the memory layout of our microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Peripheral memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Peripheral memory** is dedicated to managing and interfacing with the microcontroller’s
    onboard peripherals. These peripherals include components such as timers, communication
    interfaces (UART, SPI, I2C), and **analog-to-digital converters** (**ADCs**).
    Peripheral memory is made up of registers that are used to configure and manage
    these peripherals.'
  prefs: []
  type: TYPE_NORMAL
- en: An important aspect of microcontroller architecture is the use of **memory-mapped
    input/output** (**I/O**). Memory-mapped I/O is a technique where peripheral registers
    are assigned specific addresses in the system’s memory space. This approach allows
    firmware to interact with hardware peripherals by reading from or writing to these
    memory addresses, just as it would with regular memory. The peripheral memory
    area of the STM32 memory map is the memory-mapped area for the peripheral registers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the major memory areas, we are ready to learn
    about the linker script.
  prefs: []
  type: TYPE_NORMAL
- en: The linker script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linker scripts play an important role in the build process, especially in defining
    the memory layout and allocating various memory sections used by the firmware.
    They specify where different sections of the firmware, such as code, data, and
    uninitialized data, are to be placed in the microcontroller’s memory.
  prefs: []
  type: TYPE_NORMAL
- en: While linker scripts set up the structure and boundaries for these sections,
    it is important to note that they do not populate these sections with data. The
    actual process of initializing data with specific values is handled by the startup
    code, which runs when the microcontroller boots up. We provide these linker scripts
    to the linker to effectively guide the organization of memory during the linking
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: The build process with the linker highlighted](img/B21914_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: The build process with the linker highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the linking process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the build process, the linking of object files is an important step that
    transforms individual pieces of code into functional firmware. The assembler generates
    object files from source code, each containing code and data sections necessary
    for the firmware. However, these object files often have unresolved internal references
    to variables and functions, making them incomplete on their own. For instance,
    an object file may contain a reference to an `adc_value` variable that is defined
    elsewhere. It is the linker’s job to amalgamate these object files, systematically
    resolving all such unresolved symbols to create a cohesive output file. To fully
    appreciate the meticulous work of the linker, we have to understand the attributes
    assigned to each section by the linker.
  prefs: []
  type: TYPE_NORMAL
- en: Section attributes and their implications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each section within an object file is identified by a unique name and size,
    with specific attributes that dictate how they should be treated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loadable sections**: These sections contain content that must be loaded into
    memory at runtime. They are essential for the execution of the program and include
    executable code and initialized data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allocatable sections**: These sections do not carry content by themselves.
    Instead, they signal that a certain area of memory should be reserved, typically
    for uninitialized data that will be defined at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-loadable, non-allocatable sections**: Often, a section that is neither
    loadable nor allocatable contains debugging information or metadata that helps
    in the development process but is not required for the program’s execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A crucial aspect of the linking process is the determination of two types of
    addresses for each allocatable and loadable output section: the **virtual memory
    address** (**VMA**) and the **load memory** **address** (**LMA**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the roles of these two addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VMA**: This address represents where the section will reside in memory during
    the execution of the output file. It is the runtime address used by the system
    to access the section’s data or instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LMA**: Conversely, the LMA is the address where the section is physically
    loaded into memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most scenarios, the VMA and LMA are identical
  prefs: []
  type: TYPE_NORMAL
- en: A notable exception occurs when a data section is initially loaded into flash
    memory but then copied to SRAM upon startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a clearer and more comprehensive understanding of the latter stages
    of the build process, it’s essential to delve into another fundamental aspect
    of our discussion: the specific responsibilities and contributions of the locator
    within the build process.'
  prefs: []
  type: TYPE_NORMAL
- en: Address relocation and the locator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The output file produced by the linker is not immediately suitable for use on
    a target microcontroller. This is because the addresses assigned to different
    sections during the linking process do not necessarily correspond to the actual
    memory layout of the target device. Therefore, these addresses must be relocated
    to match the target’s memory space accurately. This is the job of the locator.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: The build process, highlighting the relationship between the
    relocatable file, the locator, and the final executable output](img/B21914_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: The build process, highlighting the relationship between the relocatable
    file, the locator, and the final executable output'
  prefs: []
  type: TYPE_NORMAL
- en: In the GNU toolchain, the locator functionality is integrated into the linker,
    streamlining the process of address relocation. This capability ensures that the
    final executable is correctly mapped to the microcontroller’s memory, making it
    ready for execution.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we examined the build process. From this, we observed that
    the process of linking object files in embedded systems development involves meticulous
    organization of code and data sections, symbol resolution, and address relocation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we shall explore the key components of the linker script
    in detail. This exploration will offer additional insights and deepen our understanding
    of the core elements discussed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Key components of the linker script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key components of a linker script include the **memory layout**, **section****definitions**,
    **options**, and **symbols**, each playing a unique role in ensuring that the
    firmware is correctly placed and executed within the microcontroller’s memory.
  prefs: []
  type: TYPE_NORMAL
- en: Memory layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This part of the linker script specifies the various memory types available
    in the microcontroller, such as flash memory and SRAM. It includes their start
    addresses and sizes, for instance, flash starting at `0x08000000` or SRAM at `0x20000000`.
  prefs: []
  type: TYPE_NORMAL
- en: Section definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A critical aspect of the linker script is defining how and where different
    sections of the program are placed. The `.text` section, containing the program
    code, is usually positioned at the beginning of flash memory. Following this,
    the `.bss`) and `.data` sections are allocated in SRAM. The linker script also
    ensures proper alignment of these sections for efficient memory access and program
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.``text`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.text` section holds the executable instructions of our program. It’s where
    the actual code that the processor executes resides.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.text` section varies based on the amount of code in your program. In STM32
    microcontrollers, it generally starts at a predefined memory address, often in
    the lower region of the flash memory. For example, `0x00000000` and then relocated
    to `0x08000000`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.``bss`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bss` section is used for uninitialized global and static variables. Variables
    in this section don’t have initial values when the program starts.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.``data`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.data` section contains initialized global and static variables. Unlike variables
    in `.bss`, these variables have initial values specified in our code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.data` section are typically copied from flash memory to SRAM to allow faster
    access and modification.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management**: The process of copying these values from flash memory to SRAM
    is handled by the startup code, executed before the main function of our program.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.rodata`: This section is used for constant data, such as string literals
    and constant arrays. It’s read-only and usually stored in flash memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.heap` and `.stack` are sections used for dynamic memory allocation (`malloc`,
    `free`) and function call stacks, respectively. They are part of SRAM and are
    crucial for runtime memory management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table summarizes the key sections and their placement in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Section** | **Purpose** | **Placed in** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `.``text` | Holds executable program instructions. | `FLASH` |'
  prefs: []
  type: TYPE_TB
- en: '| `.``bss` | Holds uninitialized global/static variables. | `SRAM` |'
  prefs: []
  type: TYPE_TB
- en: '| `.``data` | Holds initialized global/static variables with initial values.
    | `FLASH` (`SRAM` at runtime) |'
  prefs: []
  type: TYPE_TB
- en: '| `.``rodata` | Holds constant data (string literals, constant arrays). | `FLASH`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1: Linker script sections and their placement in memory'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the characteristics of these sections is important for having
    a properly functioning executable.
  prefs: []
  type: TYPE_NORMAL
- en: Options and symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Options** in linker scripts are commands or directives that influence the
    behavior of the linker. A typical linker script includes directives for setting
    the entry point of the program and directives for defining the memory layout.'
  prefs: []
  type: TYPE_NORMAL
- en: Symbols in linker scripts are identifiers that act as placeholders or references
    to specific memory locations, values, or addresses within the microcontroller’s
    memory space. Symbols can be used to represent the start or end addresses of memory
    sections or specific variables in the program. For example, a symbol might be
    defined to represent the beginning of the flash memory or the start of the SRAM
    region. We can also use symbols to define important constants or values that are
    used throughout the firmware (such as source code files). These might include
    hardware addresses, configuration values, or size limits. By using symbols, the
    code becomes more readable and maintainable, as these values can be changed in
    one place (the linker script), rather than in multiple locations throughout the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the key components of linker scripts, we will
    proceed to learn about some of the essential directives within these scripts.
    Each directive in a linker script instructs the linker on how to process and organize
    the input object files into the final executable.
  prefs: []
  type: TYPE_NORMAL
- en: Linker script directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learn about the essential directives of linker scripts.
    These directives dictate the memory layout and how various sections—code, data,
    and others—are allocated within the target microcontroller’s memory. We will explore
    the key directives, their functionality, and how they influence the overall structure
    and efficiency of the compiled firmware. Let’s start with the `MEMORY` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Memory directive (MEMORY)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MEMORY` directive delineates the microcontroller’s memory regions. Each
    defined block within the `MEMORY` section represents a distinct area of memory,
    characterized by its name, start address, and size. This directive allows us to
    define the memory layout of the target device, specifying different memory regions
    and their attributes. It plays an important role in guiding the linker on how
    to allocate sections of the program (code, data, etc.) across the microcontroller’s
    physical memory.
  prefs: []
  type: TYPE_NORMAL
- en: Usage template
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The general syntax for the `MEMORY` directive is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`name`: An identifier we give to the memory region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributes`: This specifies the access permissions for the region, such as
    read, write, and execute permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORIGIN`: This defines the start address of the memory region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LENGTH`: This specifies the size of the memory region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider a microcontroller with flash memory for storing executable code and
    SRAM for data storage. A linker script might define these memory regions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, two memory regions are defined: `FLASH` and `SRAM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FLASH` is marked with read (`r`) and execute (`x`) permissions (`rx`), indicating
    that this region can store executable code but is not writable during program
    execution. It starts at the `0x08000000` address and extends for `256K` bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SRAM` is given read (`r`), write (`w`), and execute (`x`) permissions (`rwx`),
    allowing it to store data and executable code that can be modified during runtime.
    It begins at the `0x20000000` address and extends for `64K` bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `MEMORY` directive, with its comprehensive definition of memory regions
    and attributes, lays the foundation for efficient and effective memory management
    in firmware development. Before moving on to the next directive, let’s examine
    all the attributes that can be specified to detail the characteristics and permissions
    of the memory sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r`: This attribute allows memory to be read. It is important for sections
    of memory containing executable code or constants that the program needs to read
    during execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: This attribute permits data to be written to the memory. It is important
    for memory areas where the program stores data dynamically during execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: This attribute allows the execution of code from the specified memory
    region. It is typically assigned to flash memory where the program code resides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw`: This is a combination of read and write permissions, allowing both operations
    in the specified memory region. It’s commonly used for sections such as SRAM where
    temporary data and variables are stored and modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rx`: This combines read and execute permissions. It’s often used for flash
    memory to indicate that the region contains executable code that the processor
    can read and execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rwx`: This attribute combines all three permissions, making the memory region
    fully accessible for reading, writing, and executing. This is less commonly used
    due to security and system stability considerations but might be applicable in
    certain development or debug scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`empty`: If no attribute is specified, the memory region does not grant any
    access permissions by default. This might be used in special cases where permissions
    are controlled or modified by other means within the firmware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s examine the `ENTRY` directive.
  prefs: []
  type: TYPE_NORMAL
- en: The entry directive (ENTRY)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This directive specifies the entry point of the program, which is the first
    piece of code to execute upon reset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a usage example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `Reset_Handler` is designated as the entry point of the program,
    meaning, the first function to execute. In firmware development, `Reset_Handler`
    takes care of initializing the system and jumping to the main program.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `SECTIONS` directive.
  prefs: []
  type: TYPE_NORMAL
- en: The sections directive (SECTIONS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This directive defines the mapping and ordering of sections from input files
    into the output file.
  prefs: []
  type: TYPE_NORMAL
- en: Usage example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s see a template of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`output_section_name`: This is the name given to the output section being defined.
    Common names include `.text` for executable code, `.data` for initialized data,
    and `.bss` for uninitialized data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`address`: This is optional and specifies the start address of the section
    in memory. This is often left to the linker to determine, based on the order of
    sections and memory regions defined in the script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input_section_information`: This determines which input sections (from the
    compiled object files) should be included in this output section. Wildcards such
    as `*(.text)` can be used to include all `.text` sections from all input files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>memory_region`: This assigns the section to a specific memory region defined
    in the `MEMORY` block of the linker script. We use this to tell the linker where
    in the target’s memory map this section should reside, for example, `FLASH` or
    `SRAM`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[AT>load_address]`: This is optional and specifies the load address of the
    section. This is used in scenarios where the execution address differs from the
    load address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ALIGN(expression)]`: This is optional and aligns the start of the section
    to an address that is a multiple of the value specified by `expression`. This
    is particularly useful for ensuring that sections begin at addresses that meet
    specific alignment requirements, which can enhance access speed and compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:phdr_expression]`: This is optional and associates the section with a program
    header. Program headers are part of the **Executable and Linkable Format** (**ELF**)
    file structure; they provide the system loader with information about how to load
    and run different segments of a program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[=fill_expression]`: This is optional and specifies a byte value to fill gaps
    between sections or at the end of sections to reach a certain alignment. This
    can be useful for initializing memory regions to a known state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s see an example of the `SECTIONS` directive in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SECTIONS`: This keyword begins the section of the linker script where output
    sections are defined. Output sections are areas of memory that hold the code and
    data from the input files being linked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.text 0x08000000`: This line defines an output section named `.text` and sets
    its starting address to `0x08000000`. The `.text` section typically contains executable
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ *(.text) }`: This line specifies what goes into the `.text` output section.
    The `*(.text)` syntax means all `.text` sections from all input files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>FLASH`: This directive tells the linker to place the `.text` section in a
    memory region named `FLASH`. The `FLASH` region will be defined in the `MEMORY`
    directive block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the importance of the `*(.text)` syntax, let’s examine the process
    of merging sections.
  prefs: []
  type: TYPE_NORMAL
- en: Sections merging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we learned earlier, the assembler generates an object file for each source
    file, with each containing its `.text`, `.data`, `.bss`, and other sections. These
    sections from all object files are then merged by the linker into unified `.text`,
    `.data`, and `.bss` sections for the final executable.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a firmware project with two source files, `main.c` and `delay.c`. The
    assembly process yields `main.o` and `delay.o`, each with its own sections. The
    linker’s task is to consolidate these into a single set of sections for the final
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure depicts this process. Note that merging is *not* performed
    through an addition process; this is merely a visual aid to enhance your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: The merging process involving two source files: main.c and delay.c,
    resulting in the production of the final executable, final.elf](img/B21914_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: The merging process involving two source files: main.c and delay.c,
    resulting in the production of the final executable, final.elf'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore the purpose of the `AT >` directive. To do this, it is essential
    to revisit the concepts of the LMA and VMA.
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at the LMA and VMA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we learned earlier, each allocatable and loadable output section in a binary
    output file is associated with two types of addresses: the LMA and the VMA. These
    addresses are crucial for defining how and where a section of the binary is processed
    during the system’s startup and its subsequent runtime operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LMA**: This is the physical address in the binary image where the section
    is stored before program execution begins. It determines from where the system
    will load the section into memory when the program starts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VMA**: In contrast, the VMA is the address where the section is intended
    to be accessed during the program’s execution. This is the “runtime” address used
    by the system to refer to data or instructions in that section. For systems, particularly
    microcontrollers, that do not employ a **memory management unit** (**MMU**), the
    VMA usually matches the section’s physical memory address directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are LMA and VMA important?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The distinction between LMA and VMA allows for a flexible memory management
    approach where data can be stored in one location (such as flash memory) but run
    from another (such as SRAM). For example, initialized global and static variables
    (typically placed in the `.data` section) can be stored in flash memory but need
    to be copied to SRAM for faster access and to allow modification at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fully understand this, let’s consider the following snippet from a linker
    script generated by the STM32CubeIDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this script, the last line, `>SRAM AT> FLASH`, incorporates two important
    directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>SRAM` indicates that the output `.data` section is placed in the `SRAM` section
    of the memory during program execution (VMA).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AT> FLASH` specifies that although the section resides in SRAM when executed,
    it should initially be loaded into memory (`FLASH`. This is common for initialized
    data, which is stored in flash memory and then copied to SRAM at startup by the
    microcontroller’s initialization code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This detailed management of memory addresses highlights the critical role of
    LMA and VMA in maximizing the efficiency of resource-constrained microcontrollers.
    Through the effective use of LMA and VMA, we can ensure that even with limited
    memory resources, our microcontrollers operate reliably and efficiently, optimizing
    both storage and execution efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving to explore the other features of the linker script, let’s familiarize
    ourselves with some other commonly used directives.
  prefs: []
  type: TYPE_NORMAL
- en: Other commonly used directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some other commonly used directives include the `KEEP`, `ALIGN`, `PROVIDE`,
    `>region`, and `AT` directives. Let’s examine them.
  prefs: []
  type: TYPE_NORMAL
- en: The KEEP directive
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `KEEP` directive ensures that specified sections or symbols are not eliminated
    by the linker during the optimization process, even if they appear unused. This
    is crucial for interrupt vector tables and initialization functions that must
    be present in the final binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a usage example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are *keeping* the interrupt vector section. Next, let’s
    see the region placement directive.
  prefs: []
  type: TYPE_NORMAL
- en: The >region directive
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `(>region)` region placement directive tells the linker to place a particular
    section into a specific memory region. The available memory regions must be defined
    in the `MEMORY` directive block of the linker script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a usage example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are placing the `.data` section in the `SRAM` memory region.
  prefs: []
  type: TYPE_NORMAL
- en: The ALIGN directive
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `ALIGN` directive plays a crucial role in the linker script by adjusting
    the location counter to align with specified memory boundaries. **The location
    counter** tracks the current memory address allocated by the linker for placing
    sections or parts of the output file during linking.
  prefs: []
  type: TYPE_NORMAL
- en: '`.`) in linker scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: As the linker processes the script, it assigns memory addresses to code and
    data sections according to the script’s directives, with the location counter
    monitoring the progress. To ensure efficient memory access and adherence to hardware
    architecture requirements, sections and variables often need to be aligned to
    specific boundaries. The `ALIGN` directive allows us to achieve this by rounding
    up the location counter to the nearest address that matches the specified alignment,
    which must be a power of two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a usage example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are aligning the current location to a `4`-byte boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see the `PROVIDE` directive.
  prefs: []
  type: TYPE_NORMAL
- en: The PROVIDE directive
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `PROVIDE` directive allows us to define symbols that the linker will include
    in the output file if they are not already defined. This can be used to set default
    values for symbols that may be optionally overridden by other modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a usage example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are *providing* a default stack end address.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `AT` directive.
  prefs: []
  type: TYPE_NORMAL
- en: AT Directive
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `AT` directive specifies LMA for a section when it needs to be different
    from the section’s VMA. This is commonly used for sections that need to be loaded
    into a different memory area during initialization before being moved to their
    runtime location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a usage example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `.data` section is intended to reside in SRAM during the
    program’s execution. However, it is initially loaded from `FLASH`, as indicated
    by `AT> FLASH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will explore another key aspect of linker scripts:
    the expression of numerical constants.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding constants in linker scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing our linker script, we must keep in mind the interpretation of numerical
    prefixes and suffixes by the linker.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, let’s clarify how the linker perceives integers with specific prefixes.
    An integer prefixed with `0` is read as an octal number by the linker. On the
    other hand, an integer starting with `0x` is recognized as a hexadecimal value.
    This distinction is important for accurately defining memory addresses and sizes.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `K` and `M` suffixes introduces another layer of convenience,
    allowing us to denote large numbers succinctly. The `K` suffix multiplies the
    preceding number by `1024`, while `M` expands the number by 1,024 twice over.
    Therefore, `4K` translates to 4 times 1024, and `4M` expands to 4 times 1,024
    squared.
  prefs: []
  type: TYPE_NORMAL
- en: To put these principles into practice, let’s explore an example that showcases
    the versatility of these notations. Imagine you need to specify a memory size
    of 4K. You could straightforwardly use `4K`, or opt for its decimal equivalent,
    `4096`, which results from multiplying 1,024 by 4\. Alternatively, this quantity
    can be expressed in hexadecimal form as `0x1000`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 4.2* summarizes the key points to remember about using constants in
    linker scripts. It highlights the prefixes and suffixes that modify the base value,
    which offers a clear reference for interpreting and using these notations effectively
    in your linker script.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Notation** | **Meaning** | **Example** | **Equivalent** **Decimal** | **Hexadecimal**
    **Notation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | Octal prefix | `010` | 8 | - |'
  prefs: []
  type: TYPE_TB
- en: '| `0x` | Hexadecimal prefix | `0x10` | 16 | - |'
  prefs: []
  type: TYPE_TB
- en: '| `K` | Multiplies by 1,024 | `4K` | 4096 | `0x1000` |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | Multiplies by 1,024 twice (squared) | `4M` | 4194304 | `0x400000` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.2: Examples of linker script numerical prefixes and suffixes'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we shall learn about linker script symbols, further enhancing
    our understanding of linker scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Linker script symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linker symbols, also known simply as **symbols**, are fundamental elements
    in the process of converting source code into executable programs. At its core,
    a linker symbol comprises two essential components: a name and a value. These
    symbols are assigned integer values, representing memory addresses where variables,
    functions, or other program elements are stored in the microcontroller’s memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we learned that after the assembly stage, the source code is transformed
    into object files. These object files contain machine code and unresolved references
    to variables and functions. The linker’s primary task is to merge these object
    files, resolve these unresolved symbols, and generate a complete executable file
    ready for execution.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of linker symbols, the value assigned to a symbol represents
    the memory address where the corresponding variable or function resides.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example: X = 3500 means the memory address of X is 3500'
  prefs: []
  type: TYPE_NORMAL
- en: A symbol named `X` might be assigned a value of `3500`, indicating its memory
    address. It’s crucial to note that in contrast to the variable’s value in the
    source code, the `X` linker symbol represents its memory address.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Type** | **Value (Memory** **Address)** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `X` | Symbol | `3500` | Represents the memory address where an `X` variable
    is stored. |'
  prefs: []
  type: TYPE_TB
- en: '| `Y` | Symbol | `0x3000` | Represents the memory address where a `Y` variable
    is stored. |'
  prefs: []
  type: TYPE_TB
- en: '| `foo()` | Symbol | `0x4000` | Represents the memory address where a `foo()`
    function is located. |'
  prefs: []
  type: TYPE_TB
- en: '| `bar()` | Symbol | `0x5000` | Represents the memory address where a `bar()`
    function is located. |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | Variable | `3500` | Represents the value of a C variable named `x`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `y` | Variable | `4500` | Represents the value of a C variable named `y`.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.3: Comparison of linker symbols and C source code variables assignments'
  prefs: []
  type: TYPE_NORMAL
- en: Linker symbols can undergo various operations, such as those we use in C assignments.
    These operations include straightforward assignment (`=`), addition (`+=`), and
    subtraction (`-=`), among others.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Examples of linker symbol operations](img/B21914_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Examples of linker symbol operations'
  prefs: []
  type: TYPE_NORMAL
- en: During the linking process, a symbol table is created, mapping each symbol to
    its corresponding address in memory. This table serves as a crucial reference
    for the linker to resolve symbol references and ensure proper linking of program
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a scenario where we have a `main.c` file and at the top of this
    file; we declare a variable named `X`, assigning it a value of `568`. Additionally,
    within this file, there’s a function named `blink`. Inside the `blink` function,
    there are operations to turn on an LED, wait, and then turn it off. This is depicted
    in *Figure 4**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take this `main.c` file and pass it through the build process to
    generate the `main.o` object file. During this process, a symbol table is generated.
    Each symbol in this table is associated with an address.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the `X` symbol would be assigned an address of `0x20000000`, and
    similarly, the `blink` function would also be assigned its address. In the following
    figure, the `blink` function is assigned the `0x08000000` address.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, just like in the C programming language, each variable has its
    value. In the object file, each symbol has its value, which essentially represents
    the address of the corresponding variable or function in C.
  prefs: []
  type: TYPE_NORMAL
- en: So, when referring to `X` in the object file, it wouldn’t give us `568`; rather,
    it would provide the address of `X`. This process of assigning values to symbols
    and associating them with addresses constructs the symbol table.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Representation of functions and variables from the source file
    in the symbol table of the output object file](img/B21914_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Representation of functions and variables from the source file
    in the symbol table of the output object file'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we delved deep into linker scripts, highlighting key components
    and directives. We carefully explored each directive, providing practical usage
    examples. Additionally, we distinguished between the LMA and VMA and also emphasized
    their important roles in guiding the linker on how to place sections. In the next
    section, we will learn how to write our own linker script and startup file from
    scratch, equipping you with another important skill in bare-metal firmware development.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the linker script and startup file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a good understanding of linker scripts and their essential
    components, we’re prepared to write our own. However, before diving into writing
    the script, it’s crucial to revisit the memory map of the microcontroller and
    gain insight into the `positions` load memory for various sections within the
    object file.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the load memory of different sections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed earlier in this chapter, the output object file is structured into
    sections such as `.data`, `.rodata`, `.text`, and `.bss`. Together with the sections
    created by the assembler, we must define our own section to accommodate the vector
    table for `.isr_vector_tbl`.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these sections plays an important role in organizing the memory layout
    of the microcontroller, contributing to the functionality and efficiency of the
    final executable.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure* *4**.7* shows a zoomed-in view of the flash memory area, showing the
    required order for placing the different sections within the flash memory. Each
    section represents the combination of identical sections from all input files.
    For instance, the `.text` section depicted is a unified `.text` section, formed
    by merging all `.text` sections from the input files.'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram indicates that the placement must start with the `.isr_vector_tbl`
    section at the beginning of the flash memory. Following this, we must place the
    `.text` section, then the `.rodata` section, and finally, the `.data` section.
    The diagram does not show the placement of the `.bss` section, as we will place
    the `.bss` section directly in the SRAM. Additionally, during the startup code
    implementation, we must copy the content of the `.data` section from the flash
    memory to the SRAM.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: The flash memory area showing the order in which sections should
    be placed](img/B21914_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: The flash memory area showing the order in which sections should
    be placed'
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, however, let’s understand the concept of interrupts and the
    vector table.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupts and the vector table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interrupts are a fundamental concept in computing. They act as a powerful mechanism
    for managing how a computer or a microcontroller handles tasks and responds to
    external and internal events.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, an **interrupt** is a signal to the processor from a hardware device
    or an internal software condition that temporarily halts the current operations.
    This signal indicates that immediate attention is required. When the processor
    receives an interrupt, it pauses its current tasks, saves its state, and executes
    a function known as an ISR to address the interrupt. Upon completing the ISR,
    the processor resumes its previous tasks, ensuring that critical signals receive
    prompt and efficient handling.
  prefs: []
  type: TYPE_NORMAL
- en: '*What are the types* *of interrupts?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can broadly classify interrupts into two categories: hardware interrupts
    and software interrupts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware interrupts**: These originate from external devices, such as switches,
    network adapters, or any peripheral that needs to communicate with the processor.
    For example, pressing a push button may trigger a hardware interrupt that informs
    the processor to start a motor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software interrupts**: Unlike hardware interrupts, software interrupts are
    triggered by software instructions. These are used by programs to interrupt the
    current process flow and execute a specific routine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is the role of the interrupt* *vector table?*'
  prefs: []
  type: TYPE_NORMAL
- en: The interrupt vector table serves as an essential lookup table, guiding the
    processor to the correct ISR for each interrupt. An ISR is simply a function designed
    to address and manage the specific needs triggered by an interrupt. The table
    itself is **organized as an array of pointers**, with each pointer directing the
    system to the designated ISR for a given interrupt. Upon the occurrence of an
    interrupt, the system references this table to locate the exact memory address
    of the ISR required for handling the interrupt. This efficient mechanism enables
    the system to promptly respond to various events, such as external inputs, timer
    expirations, and changes in the internal state.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we are finally ready to write our linker script.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the linker script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our workspace folder, let’s make a new folder named `3_LinkerscriptAndStartup`.
    In this folder, create a file called `stm32_ls.ld` and make sure its extension
    is `.ld`. If you’re using Windows and it asks if you really want to change the
    file extension, click **Yes**. Then, right-click the file and open it with a basic
    text editor such as Notepad++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our objectives with the linker script can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the firmware’s entry point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailing the available memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the necessary heap and stack sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining output sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is our complete linker script, the contents of the `stm32_ls.ld` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break it down.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the firmware’s entry point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we learned earlier, the `ENTRY` directive specifies the entry point of the
    firmware, which is the first piece of code that gets executed when the firmware
    starts. In this case, the entry point is the function named `Reset_Handler`. We
    shall implement this function in the startup file.
  prefs: []
  type: TYPE_NORMAL
- en: Detailing the available memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our script specifies two memory regions: `FLASH` and `SRAM`. The `FLASH` memory,
    with read and execute permissions (`rx`), starts at the `0x08000000` address and
    has a length of `512K`. The SRAM memory, with read, write, and execute permissions
    (`rwx`), starts at the `0x20000000` address and has a length of `128K`.'
  prefs: []
  type: TYPE_NORMAL
- en: Symbol creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Over here, we create a symbol called `_estack` and we set it to the end of the
    `SRAM` memory region. We will use this symbol to initialize the stack pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The `SRAM` ensures that it starts at the maximum available address, utilizing
    the `SRAM` space efficiently for stack operations.
  prefs: []
  type: TYPE_NORMAL
- en: The next lines of code in our linker script specify the heap and stack sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the necessary heap and stack sizes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These lines define the maximum sizes for the heap (`0x200` bytes) and stack
    (`0x400` bytes). These sizes are important for dynamic memory allocation and function
    call management, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The next segment defines the output sections.
  prefs: []
  type: TYPE_NORMAL
- en: Defining output sections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will go through the output sections.
  prefs: []
  type: TYPE_NORMAL
- en: The .text output section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This segment of our linker script shows the `.text` output section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`. =` `ALIGN(4);`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive aligns the start of the `.text` section on a `4`-byte boundary.
    This enhances memory access efficiency, which is a critical consideration for
    processors fetching instructions in word-sized chunks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`*(.``isr_vector_tbl)` :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive pulls in all sections named `.isr_vector_tbl` from the input
    files into the current location in the `.``text` section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`*(.``text)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive pulls in all sections named `.text` from the input files into
    the current location in the `.``text` section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`*(.``rodata)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive pulls in all sections named `.rodata` from the input files into
    the current location in the `.``text` section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`. =` `ALIGN(4);`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, this line ensures that the end of the section is aligned to a `4`-byte
    boundary. Over here, we use it to align the end of a section, ensuring that the
    next section starts on an aligned boundary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`_etext = .;`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over here, we define a symbol called `_etext` at the current location. This
    symbol marks the end of the `.text` section. We will use this symbol as a pointer
    to the end of the `.text` section in our startup file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`}>``FLASH`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive specifies that the `.text` section should be placed in the `FLASH`
    memory segment as defined earlier in the `MEMORY` block of the linker script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This segment shows the `.data` output section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`=` `ALIGN(4);`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive aligns the start of the `.data` section on a `4`-byte boundary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`_sdata = .;`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over here, we create a symbol named `_sdata` to represent the start of the `.data`
    section by setting it to the current location counter. We will use this symbol
    as a pointer to the start of the `.data` section in our startup file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`*(.``data)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive pulls in all sections named `.data` from the input files into
    the current location in the `.``data` section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`. =` `ALIGN(4);`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This line ensures that the end of the section is aligned to a `4`-byte boundary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`_edata= .;`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to what we have done previously, we create a symbol named `_edata` to
    represent the end of the `.data` section by setting it to the current location
    counter. We will use this symbol in our startup file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`> SRAM` `AT> FLASH`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive specifies the LMA and the VMA of the `.``data` section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`> SRAM` indicates that the section should be located in SRAM, allowing read
    and write access at runtime.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`AT> FLASH` tells the linker that although the section is placed in `SRAM`
    for execution, its initial values should be stored in `FLASH`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This segment shows the `.bss` output section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is the final output section of our linker script.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned earlier, the `.bss` section holds uninitialized global and static
    variables that we will be initialized to zero in our startup file. This zero-initialization
    ensures that all variables in this section begin with a known state, contributing
    to our firmware’s stability and predictability.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other sections, we begin by aligning the section to a `4`-byte boundary
    for efficient memory access, and then we define the `_sbss` and `_ebss` symbols
    to mark the start and end of the section, respectively. These symbols facilitate
    the calculation of the section’s size and its initialization process. Finally,
    we place the section in the SRAM, emphasizing that, although it doesn’t occupy
    space in the binary file on disk, it requires runtime allocation in memory.
  prefs: []
  type: TYPE_NORMAL
- en: With our linker script finalized, we’ll move on to implementing the startup
    file. This shall be the focus of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the startup file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The startup file is essential for initializing the firmware and it performs
    several critical tasks to ensure the system operates correctly from the moment
    it is powered on.
  prefs: []
  type: TYPE_NORMAL
- en: 'These tasks include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing the vector table**: This involves defining the vector table
    that maps interrupts to their handlers, ensuring the system can respond to various
    events efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating interrupt handlers**: For each interrupt listed in the vector table,
    an interrupt handler must be implemented to define how the system responds to
    that particular event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reset_Handler`, as specified in the linker script, which acts as the initial
    entry point of the firmware. This function is executed immediately after reset
    and is responsible for setting up the environment for the main application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.data` section from `FLASH` to `SRAM`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bss` section to zero, ensuring that all uninitialized global and static variables
    start with a known state for reliable operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the current folder containing the linker script, create a file called `stm32f411_startup.c`
    and make sure its extension is `.c`. If you’re using Windows and it asks if you
    really want to change the file extension, click **Yes**. Then, right-click the
    file and open it with a basic text editor such as Notepad++.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze the complete startup code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is our complete startup code written in C, the contents of the
    `stm32f411_startup.c` file. In the following snippet, we are not showing all the
    function prototypes of all the interrupts in the vector table. The complete source
    code can be found in the resources accompanying the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break it down.
  prefs: []
  type: TYPE_NORMAL
- en: We start by declaring external symbols.
  prefs: []
  type: TYPE_NORMAL
- en: External symbol declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines declare the external symbols that we defined in the linker script.
    Each symbol represents an important memory address used during the startup process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_estack`: This is the initial top of the stack. This value is loaded into
    the main stack pointer register early in the startup process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_etext:` This marks the end of the executable code section and the beginning
    of the data sections stored in flash memory. We use this as a reference point
    for copying initialized data from `FLASH` to `SRAM`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_sdata` and `_edata` represent the start and end addresses of the initialized
    data section in SRAM, respectively. We use them to determine the size and destination
    for data copying from `FLASH` to `RAM`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_sbss` and `_ebss` mark the start and end of the uninitialized data section
    (BSS section) in SRAM. We use these symbols to clear this section, setting it
    to zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next in our snippet, we have the function prototypes and their attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Function prototypes and attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'At this part of the startup file, we declare the prototype for the `Reset_Handler`
    function, the application’s `main` function, and several interrupt handlers with
    specific attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__attribute__((weak, alias("Default_Handler"))):` This attribute makes each
    handler weakly linked and aliases it to a function named `Default_Handler`. It
    allows these handlers to be overridden by explicitly defined handlers with the
    same name elsewhere in the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the statement further to understand its significance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__attribute__`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use this keyword to tell the compiler that the declaration it’s applied to
    has certain properties that affect how it’s treated by the linker and, potentially,
    at runtime. Attributes can be used to control optimizations, code generation,
    alignment, and, relevant to our discussion, linkage characteristics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`weak`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring a function or variable as `weak` means that it does not prevent the
    linker from using another symbol of the same name with a stronger linkage. We
    use this to specify default implementations that can be overridden.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the context of our interrupt handlers, marking them as `weak` allows us to
    define default handlers in our startup file, which application-specific handlers
    can override without modifying the startup file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`alias("Default_Handler")`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This part of the attribute creates an alias for another symbol, in this case,
    `Default_Handler`. It means that the symbol (e.g., `NMI_Handler`) is not just
    weak, but it is also an alias for the `Default_Handler` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This means that when an interrupt occurs, and a specific handler (such as `NMI_Handler`)
    has not been defined elsewhere in the application with stronger linkage (non-weak),
    the program will use `Default_Handler` in its place. This ensures that all interrupts
    have a handler, preventing the system from crashing due to unhandled events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we have the vector table array.
  prefs: []
  type: TYPE_NORMAL
- en: Vector table definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This array defines the microcontroller’s interrupt vector table, placed in the
    `.isr_vector_tbl` section we defined in the linker script.
  prefs: []
  type: TYPE_NORMAL
- en: We set the `&_estack` symbol as the first element of the vector table to define
    the initial top of the stack in memory. In ARM Cortex microcontrollers, such as
    our STM32F411, the first word (32 bits) of the vector table must contain the initial
    value of the **main stack pointer** (**MSP**). Upon reset, the processor loads
    this value into the MSP register to set up the stack pointer correctly before
    executing any code.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we specify the address of `Reset_Handler`, then we proceed to
    list the addresses for `NMI_Handler` and other subsequent interrupt handlers in
    sequence. The precise placement of these handlers is crucial, as each must reside
    in a specific memory location to ensure correct functionality. This arrangement
    is detailed on *page 201* of the RM0383 document. Within the fully defined vector
    table in our `stm32f411_startup.c` file, you’ll notice that there are zeros strategically
    placed among the interrupt handler addresses. These zeros act as placeholders
    for the positions corresponding to interrupts not supported by our specific microcontroller
    variant (STM32F411). The ARM Cortex-M core architecture is designed to support
    a comprehensive set of interrupts, yet not all interrupts are implemented across
    every microcontroller variant. By inserting zeros for these unsupported interrupts
    in the vector table, we maintain the required alignment with the architecture’s
    specifications, ensuring the system operates correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the array declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`uint32_t vector_tbl[]`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This specifies that each element of the `vector_tbl` array is an unsigned 32-bit
    integer. We chose this type because addresses in ARM Cortex-M microcontrollers
    are 32 bits in length, and the vector table consists of memory addresses pointing
    to the start of ISR handlers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`__attribute__((section(".isr_vector_tbl")))`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This attribute instructs the linker to place the `vector_tbl` array in a specific
    section of the output file named `.isr_vector_tbl`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we have our default handler function.
  prefs: []
  type: TYPE_NORMAL
- en: Default dandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function serves as a universal fallback for any interrupt request for which
    a specific handler has not been implemented. Engaging in an infinite loop effectively
    prevents the program from proceeding into an undefined state following such an
    event.
  prefs: []
  type: TYPE_NORMAL
- en: It is linked to all interrupt handlers marked as `weak` and aliased to `Default_Handler`
    within the application. This strategy ensures a uniform and secure response throughout
    the system to any interrupt requests that lack a dedicated handler, thus upholding
    system stability and integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have our `Reset_Handler` function.
  prefs: []
  type: TYPE_NORMAL
- en: Reset handler implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The job of `Reset_Handler` is to prepare the system before executing the main
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the function, we start by calculating the sizes of the `.data` and `.``bss`
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the size of the `.data` section by subtracting the address of the
    start of the section (`_sdata`) from the address of the end (`_edata`). This size
    is used to copy initialized data from `FLASH` to `SRAM`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the size of the `.bss` section in a similar manner, using the start
    (`_sbss`) and end (`_ebss`) addresses. This size is used to zero out the `.bss`
    section in SRAM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, in the function, we initialize pointers for copying the `.``data` section:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a source pointer (`p_src_mem`) to the address where initialized data
    is stored in flash memory, marked by `_etext`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize a destination pointer (`p_dest_mem`) to the start of the `.data`
    section in SRAM (`_sdata`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we copy the `.data` section from `FLASH` to `SRAM`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `.data` section from `FLASH` to `SRAM` word (32-bit) by word. For each
    iteration, the content pointed to by `p_src_mem` is copied to the location pointed
    to by `p_dest_mem`, and then both pointers are incremented to the next word.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we initialize the pointer for the `.bss` section zeroing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We simply reset the destination pointer (`p_dest_mem`) to the start of the `.bss`
    section in SRAM (`_sbss`), preparing it for zeroing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then zero out the `.``bss` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This block zeroes out the `.bss` section in `SRAM` word by word. For each iteration,
    the location pointed to by `p_dest_mem` is set to `0`, and then `p_dest_mem` is
    incremented to the next word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call the `main()` function located in the `main.c` file of our
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After initializing the `.data` and `.bss` sections, this line calls the `main`
    function, transferring control to the main application code. This marks the end
    of the system initialization process and the beginning of the application execution.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed both our linker script and startup file, it is time
    to test our implementation by building the firmware using just our `main.c` source
    file, the `stm32_ls.ld` linker script, and the `stm32f411_startup.c` startup file.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our linker script and startup file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the command line, it’s important to ensure that our linker
    script and startup file are correctly placed. Let’s set up our project directory
    and add some modification to our `main.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`3_LinkerAndStartup` in your workspace.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`main.c` file from the previous project (`2_RegisterManipulation`), which includes
    the foundational application code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, locate `stm32_ls.ld` (linker script) and `stm32f411_startup.c`
    (startup file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste these files (`stm32_ls.ld, stm32f411_startup.c`, and `main.c`)
    into the `3_LinkerAndStartup` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`main.c` file from fast to slow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`main.c` file within the `3_LinkerAndStartup` folder and select the option
    to open it with a simple text editor, such as Notepad++.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LED_PIN`). Adjust the delay intervals within this section to change the LED’s
    blink rate from its current rapid pace to a slower one. The current one should
    look like this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the current code with the following snippet to toggle the state of
    PA5 at a slower rate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s access our new folder through the Command Prompt following the steps
    we learned in [*Chapter 3*](B21914_03.xhtml#_idTextAnchor080). My favorite method
    for Windows users is the context menu method:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `3_LinkerAndStartup` folder in Windows Explorer. Once there,
    hold down the *Shift* key, *right-click* in a space within the folder, and select
    `3_LinkerAndStartup` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Command Prompt, we start by compiling the `main.c` file, and we do this
    by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we execute our startup file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our `main.o` and `stm32f411_startup.o` object files are ready, we go ahead
    and link all object files (`*.o`) using our linker script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This process produces the `3_LinkerAndStartup.elf` executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we launch `openocd` to begin the uploading process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With OpenOCD running, the next step involves using the **GNU Debugger** (**GDB**)
    to upload the firmware to the microcontroller. Let’s access another Command Prompt
    window (as OpenOCD should keep running in the first one) and enter the following
    command to start the GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once GDB is open, we establish a connection to our microcontroller by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s reset and initialize the board as we learned in [*Chapter 3*](B21914_03.xhtml#_idTextAnchor080)
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we load the firmware onto the microcontroller using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully loading the firmware, we reset the board again with the
    same reset command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we resume the execution of the firmware on the microcontroller with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: There you have it; you should see the LED blinking at a slower rate, indicating
    the successful upload and execution of our new firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we deeply explored the core components of embedded bare-metal
    programming, focusing on the microcontroller’s memory model, writing linker scripts,
    and startup files. We began by exploring the STM32 microcontroller’s memory layout,
    emphasizing the importance of flash memory and SRAM for storing executable code
    and runtime data.
  prefs: []
  type: TYPE_NORMAL
- en: We then dedicated a significant portion of the chapter to constructing and understanding
    linker scripts. Through this, we understood these scripts’ critical role in the
    firmware build process by mapping the compiled firmware sections to the microcontroller’s
    specific memory regions to ensure the executable operates correctly. We learned
    about the various directives within a linker script, such as `MEMORY` and `SECTIONS`.
    These directives are crucial for defining the memory layout and specifying where
    and how program sections are placed in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Our discussion on linker scripts extended to the practicalities of defining
    memory regions, aligning sections, and managing section attributes for optimal
    memory utilization. We gave special attention to the LMA and VMA, which are essential
    for efficient program loading and execution.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to the startup file, we meticulously outlined the startup file’s
    role, covering the initialization of the vector table, setting up `Reset_Handler`,
    and preparing the system for the execution of the main application. We learned
    the procedures for copying the `.data` section from `FLASH` to `SRAM` and zeroing
    the `.bss` section, ensuring a predictable start for our firmware.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore build systems, highlighting the essential
    role of the `Make` tool. This knowledge will enable us to streamline our build
    process by automating it, instead of manually entering each command in the command
    line.
  prefs: []
  type: TYPE_NORMAL
