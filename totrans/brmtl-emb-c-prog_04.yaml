- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Developing the Linker Script and Startup File
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发链接脚本和启动文件
- en: 'In this chapter, we undertake an in-depth exploration of the core components
    of embedded **bare-metal programming**, focusing on three critical areas: the
    microcontroller memory model, the writing of the linker script, and the startup
    file.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了嵌入式**裸机编程**的核心组件，重点关注三个关键领域：微控制器内存模型、链接脚本的编写和启动文件。
- en: First, we’ll explore the microcontroller memory model to understand how memory
    is organized and utilized. This knowledge is important for accurately allocating
    program code and data sections within the microcontroller memory. Next, we’ll
    go through the intricacies of writing linker scripts. These scripts are essential
    for correctly mapping our program to the appropriate sections of the microcontroller’s
    memory, ensuring that the executable runs as intended.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨微控制器内存模型，以了解内存是如何组织和使用的。这些知识对于在微控制器内存中准确分配程序代码和数据部分非常重要。接下来，我们将深入了解编写链接脚本的技术细节。这些脚本对于正确地将我们的程序映射到微控制器内存的适当部分至关重要，确保可执行程序按预期运行。
- en: Finally, we will learn about the startup file and then proceed to write our
    own, focusing on initializing the vector table and configuring `Reset_Handler`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将学习启动文件，然后编写我们自己的启动文件，重点关注初始化向量表和配置`Reset_Handler`。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding the memory model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内存模型
- en: The linker scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接脚本
- en: Writing the linker script and startup file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写链接脚本和启动文件
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到：[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: Understanding the STM32 memory model
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解STM32内存模型
- en: 'While the STM32 memory map consists of various memory areas, our primary focus
    in developing the linker script and startup file revolves around two critical
    areas: **flash memory** and **static random access memory** (**SRAM**). These
    areas are of utmost importance because they are directly involved in program storage.
    In the initial parts of this section, we will learn about the characteristics
    of these memory areas and the distinct roles they play.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然STM32内存映射包括多个内存区域，但我们在开发链接脚本和启动文件时的主要焦点是两个关键区域：**闪存**和**静态随机存取存储器**（**SRAM**）。这些区域至关重要，因为它们直接参与程序存储。在本节的开头部分，我们将了解这些内存区域的特点以及它们所扮演的独特角色。
- en: '*Figure 4**.1* shows a section of the stm32f411 memory map, highlighting the
    flash memory and SRAM.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4**.1*显示了stm32f411内存映射的一部分，突出显示了闪存和SRAM。'
- en: '![Figure 4.1: A section of the STM32F11 memory map, highlighting the flash
    memory and SRAM areas](img/B21914_04_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：STM32F11内存映射的一部分，突出显示闪存和SRAM区域](img/B21914_04_1.jpg)'
- en: 'Figure 4.1: A section of the STM32F11 memory map, highlighting the flash memory
    and SRAM areas'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：STM32F11内存映射的一部分，突出显示闪存和SRAM区域
- en: Let’s start with flash memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从闪存内存开始。
- en: Flash memory
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闪存内存
- en: One of the primary advantages of flash memory is its non-volatile nature. This
    means that data stored in flash memory remains intact even when the power supply
    is disconnected. In STM32 microcontrollers (as well as other microcontrollers),
    flash memory is typically where the executable code is stored and is read-only
    during normal operation. Flash memory starts at the `0x08000000` address. However,
    its size varies depending on the specific STM32 microcontroller model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存内存的一个主要优点是其非易失性。这意味着即使断开电源，存储在闪存内存中的数据也会保持完整。在STM32微控制器（以及其他微控制器）中，闪存内存通常是存储可执行代码的地方，在正常操作期间是只读的。闪存内存从`0x08000000`地址开始。然而，其大小取决于具体的STM32微控制器型号。
- en: STM32 microcontrollers come in various series and models, offering a range of
    flash memory densities to accommodate different application requirements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: STM32微控制器有多种系列和型号，提供不同密度的闪存内存，以满足不同的应用需求。
- en: What is memory density?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是内存密度？
- en: '**Memory density** refers to the concentration of memory storage within a given
    physical space or component. Memory density is often expressed in terms of bits
    or bytes stored per unit of physical area, such as bits per square millimeter
    or bytes per square centimeter. It measures how densely or compactly data can
    be stored within that space. Higher memory density means that we can store more
    data than we can in a smaller physical space.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Memory size, on the other hand, refers to the total amount of memory (storage
    capacity) available in a given storage device. It is typically measured in units
    such as bytes, **kilobytes** (**KB**), **megabytes** (**MB**), **gigabytes** (**GB**),
    etc.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s talk about some operational nuances of flash memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Flash memory, including STM32 flash memory, has a limited number of program
    and erase cycles. Each time we write (program) or erase, it consumes one of these
    cycles. It is important to consider these limitations when designing applications
    that frequently write to or erase data from flash memory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: STM32 microcontrollers are known for their low power consumption, and this extends
    to their flash memory operations. Efficient power management ensures that the
    microcontroller can operate on minimal power while reading from or writing to
    flash memory, making STM32 devices suitable for battery-powered applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: To ensure data integrity, STM32 flash memory often includes built-in error correction
    mechanisms. These mechanisms help identify and correct errors that may occur during
    data storage and retrieval, enhancing the reliability of the stored firmware.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some key attributes of the STM32 flash memory:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-only nature**: Primarily used for storing program code'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x08000000`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variable size**: Dependent on the specific STM32 microcontroller model'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x08000004`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at the other primary memory areas relevant to writing our
    linker script and startup file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: SRAM
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SRAM** is a type of volatile memory, meaning it loses its contents when the
    power supply is disconnected. It is used in STM32 microcontrollers for temporary
    data storage during program execution. Unlike flash memory, which is used for
    long-term storage of program code, SRAM is designed for high-speed access and
    low latency, making it ideal for storing variables, intermediate data, and managing
    the stack during runtime.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Like flash memory, the STM32 microcontrollers feature varying sizes of SRAM,
    tailored to the needs of different applications. The size of the SRAM determines
    the amount of runtime data that can be handled and affects the overall performance
    of the microcontroller in handling complex tasks or multitasking. The SRAM in
    STM32 microcontrollers starts at the `0x20000000` address. Like flash memory,
    its size varies depending on the specific STM32 microcontroller model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key attributes of the STM32 SRAM:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**Read and write**: Variables and the stack are stored here'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x20000000`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variable size**: Dependent on the specific STM32 microcontroller model'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量大小**：取决于特定的STM32微控制器型号'
- en: Before moving on to introduce the linker script, let’s touch on one other memory
    area that is not relevant to the linker script, but is still relevant to our understanding
    of the memory layout of our microcontroller.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍链接脚本之前，让我们简要提及一个与链接脚本不相关，但对我们理解微控制器内存布局仍有意义的内存区域。
- en: Peripheral memory
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外围内存
- en: '**Peripheral memory** is dedicated to managing and interfacing with the microcontroller’s
    onboard peripherals. These peripherals include components such as timers, communication
    interfaces (UART, SPI, I2C), and **analog-to-digital converters** (**ADCs**).
    Peripheral memory is made up of registers that are used to configure and manage
    these peripherals.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**外围内存**专门用于管理和与微控制器板载外围设备接口。这些外围设备包括定时器、通信接口（UART、SPI、I2C）和**模数转换器**（**ADCs**）。外围内存由用于配置和管理这些外围设备的寄存器组成。'
- en: An important aspect of microcontroller architecture is the use of **memory-mapped
    input/output** (**I/O**). Memory-mapped I/O is a technique where peripheral registers
    are assigned specific addresses in the system’s memory space. This approach allows
    firmware to interact with hardware peripherals by reading from or writing to these
    memory addresses, just as it would with regular memory. The peripheral memory
    area of the STM32 memory map is the memory-mapped area for the peripheral registers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器架构的一个重要方面是使用**内存映射输入/输出**（**I/O**）。内存映射I/O是一种技术，其中外围寄存器被分配到系统内存空间中的特定地址。这种方法允许固件通过从或向这些内存地址读取或写入来与硬件外围设备交互，就像它与常规内存交互一样。STM32内存映射的外围内存区域是外围寄存器的内存映射区域。
- en: Now that we are familiar with the major memory areas, we are ready to learn
    about the linker script.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了主要内存区域，我们准备学习链接脚本。
- en: The linker script
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接脚本
- en: Linker scripts play an important role in the build process, especially in defining
    the memory layout and allocating various memory sections used by the firmware.
    They specify where different sections of the firmware, such as code, data, and
    uninitialized data, are to be placed in the microcontroller’s memory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 链接脚本在构建过程中扮演着重要的角色，尤其是在定义内存布局和分配固件使用的各种内存部分。它们指定固件的各个部分，如代码、数据和未初始化数据，应在微控制器内存中的位置。
- en: While linker scripts set up the structure and boundaries for these sections,
    it is important to note that they do not populate these sections with data. The
    actual process of initializing data with specific values is handled by the startup
    code, which runs when the microcontroller boots up. We provide these linker scripts
    to the linker to effectively guide the organization of memory during the linking
    phase.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然链接脚本设置了这些部分的架构和边界，但重要的是要注意，它们并不填充这些部分的数据。实际使用特定值初始化数据的处理由启动代码负责，该代码在微控制器启动时运行。我们向链接器提供这些链接脚本，以有效地指导链接阶段的内存组织。
- en: '![Figure 4.2: The build process with the linker highlighted](img/B21914_04_2.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：带有链接器高亮的构建过程](img/B21914_04_2.jpg)'
- en: 'Figure 4.2: The build process with the linker highlighted'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：带有链接器高亮的构建过程
- en: Understanding the linking process
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解链接过程
- en: In the build process, the linking of object files is an important step that
    transforms individual pieces of code into functional firmware. The assembler generates
    object files from source code, each containing code and data sections necessary
    for the firmware. However, these object files often have unresolved internal references
    to variables and functions, making them incomplete on their own. For instance,
    an object file may contain a reference to an `adc_value` variable that is defined
    elsewhere. It is the linker’s job to amalgamate these object files, systematically
    resolving all such unresolved symbols to create a cohesive output file. To fully
    appreciate the meticulous work of the linker, we have to understand the attributes
    assigned to each section by the linker.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，链接对象文件是一个重要的步骤，它将单个代码片段转换为功能固件。汇编器从源代码生成对象文件，每个对象文件都包含固件所需的代码和数据部分。然而，这些对象文件通常包含对变量和函数的未解决内部引用，使它们本身不完整。例如，一个对象文件可能包含对定义在其他地方的`adc_value`变量的引用。链接器的任务是合并这些对象文件，系统地解决所有这些未解决符号，以创建一个统一的输出文件。要完全欣赏链接器的细致工作，我们必须了解链接器为每个部分分配的属性。
- en: Section attributes and their implications
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分属性及其影响
- en: 'Each section within an object file is identified by a unique name and size,
    with specific attributes that dictate how they should be treated:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对象文件中的每个部分都通过一个唯一的名称和大小来识别，具有特定的属性，这些属性规定了应该如何处理它们：
- en: '**Loadable sections**: These sections contain content that must be loaded into
    memory at runtime. They are essential for the execution of the program and include
    executable code and initialized data.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可加载部分**：这些部分包含在运行时必须加载到内存中的内容。它们对于程序的执行至关重要，包括可执行代码和初始化数据。'
- en: '**Allocatable sections**: These sections do not carry content by themselves.
    Instead, they signal that a certain area of memory should be reserved, typically
    for uninitialized data that will be defined at runtime.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可分配部分**：这些部分本身不携带内容。相反，它们指示应该保留内存的某个区域，通常是为在运行时定义的未初始化数据。'
- en: '**Non-loadable, non-allocatable sections**: Often, a section that is neither
    loadable nor allocatable contains debugging information or metadata that helps
    in the development process but is not required for the program’s execution.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可加载、不可分配的部分**：通常，既不可加载也不可分配的部分包含调试信息或元数据，这些信息有助于开发过程，但不是程序执行所必需的。'
- en: 'A crucial aspect of the linking process is the determination of two types of
    addresses for each allocatable and loadable output section: the **virtual memory
    address** (**VMA**) and the **load memory** **address** (**LMA**).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 链接过程的一个关键方面是为每个可分配和可加载的输出部分确定两种类型的地址：**虚拟内存地址**（**VMA**）和**加载内存地址**（**LMA**）。
- en: 'These are the roles of these two addresses:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是这两个地址的作用：
- en: '**VMA**: This address represents where the section will reside in memory during
    the execution of the output file. It is the runtime address used by the system
    to access the section’s data or instructions.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VMA**：此地址表示在输出文件执行期间部分将在内存中的位置。它是系统用于访问部分数据或指令的运行时地址。'
- en: '**LMA**: Conversely, the LMA is the address where the section is physically
    loaded into memory.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LMA**：相反，LMA是部分在内存中物理加载的地址。'
- en: In most scenarios, the VMA and LMA are identical
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，VMA和LMA是相同的
- en: A notable exception occurs when a data section is initially loaded into flash
    memory but then copied to SRAM upon startup.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据部分最初被加载到闪存中，但在启动时被复制到SRAM时，会出现一个显著的例外。
- en: 'To provide a clearer and more comprehensive understanding of the latter stages
    of the build process, it’s essential to delve into another fundamental aspect
    of our discussion: the specific responsibilities and contributions of the locator
    within the build process.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地全面理解构建过程的后期阶段，深入探讨我们讨论的另一个基本方面是至关重要的：定位器在构建过程中的具体职责和贡献。
- en: Address relocation and the locator
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地址重定位和定位器
- en: The output file produced by the linker is not immediately suitable for use on
    a target microcontroller. This is because the addresses assigned to different
    sections during the linking process do not necessarily correspond to the actual
    memory layout of the target device. Therefore, these addresses must be relocated
    to match the target’s memory space accurately. This is the job of the locator.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器生成的输出文件并不立即适用于目标微控制器。这是因为链接过程中分配给不同部分的地址不一定与目标设备的实际内存布局相对应。因此，这些地址必须重新定位以准确匹配目标内存空间。这就是定位器的工作。
- en: '![Figure 4.3: The build process, highlighting the relationship between the
    relocatable file, the locator, and the final executable output](img/B21914_04_3.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：构建过程，突出可重定位文件、定位器和最终可执行输出之间的关系](img/B21914_04_3.jpg)'
- en: 'Figure 4.3: The build process, highlighting the relationship between the relocatable
    file, the locator, and the final executable output'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：构建过程，突出可重定位文件、定位器和最终可执行输出之间的关系
- en: In the GNU toolchain, the locator functionality is integrated into the linker,
    streamlining the process of address relocation. This capability ensures that the
    final executable is correctly mapped to the microcontroller’s memory, making it
    ready for execution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在GNU工具链中，定位器功能集成到链接器中，简化了地址重定位的过程。这种能力确保最终的可执行文件正确映射到微控制器的内存中，使其准备好执行。
- en: In this section, we examined the build process. From this, we observed that
    the process of linking object files in embedded systems development involves meticulous
    organization of code and data sections, symbol resolution, and address relocation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we shall explore the key components of the linker script
    in detail. This exploration will offer additional insights and deepen our understanding
    of the core elements discussed in this section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Key components of the linker script
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key components of a linker script include the **memory layout**, **section****definitions**,
    **options**, and **symbols**, each playing a unique role in ensuring that the
    firmware is correctly placed and executed within the microcontroller’s memory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Memory layout
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This part of the linker script specifies the various memory types available
    in the microcontroller, such as flash memory and SRAM. It includes their start
    addresses and sizes, for instance, flash starting at `0x08000000` or SRAM at `0x20000000`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Section definitions
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A critical aspect of the linker script is defining how and where different
    sections of the program are placed. The `.text` section, containing the program
    code, is usually positioned at the beginning of flash memory. Following this,
    the `.bss`) and `.data` sections are allocated in SRAM. The linker script also
    ensures proper alignment of these sections for efficient memory access and program
    execution:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '`.``text`:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.text` section holds the executable instructions of our program. It’s where
    the actual code that the processor executes resides.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.text` section varies based on the amount of code in your program. In STM32
    microcontrollers, it generally starts at a predefined memory address, often in
    the lower region of the flash memory. For example, `0x00000000` and then relocated
    to `0x08000000`.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.``bss`:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bss` section is used for uninitialized global and static variables. Variables
    in this section don’t have initial values when the program starts.'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.``data`:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.data` section contains initialized global and static variables. Unlike variables
    in `.bss`, these variables have initial values specified in our code.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.data` section are typically copied from flash memory to SRAM to allow faster
    access and modification.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management**: The process of copying these values from flash memory to SRAM
    is handled by the startup code, executed before the main function of our program.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.rodata`: This section is used for constant data, such as string literals
    and constant arrays. It’s read-only and usually stored in flash memory.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.heap` and `.stack` are sections used for dynamic memory allocation (`malloc`,
    `free`) and function call stacks, respectively. They are part of SRAM and are
    crucial for runtime memory management.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table summarizes the key sections and their placement in memory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '| **Section** | **Purpose** | **Placed in** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| `.``text` | Holds executable program instructions. | `FLASH` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| `.``bss` | Holds uninitialized global/static variables. | `SRAM` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| `.``data` | Holds initialized global/static variables with initial values.
    | `FLASH` (`SRAM` at runtime) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| `.``rodata` | Holds constant data (string literals, constant arrays). | `FLASH`
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1: Linker script sections and their placement in memory'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the characteristics of these sections is important for having
    a properly functioning executable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Options and symbols
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Options** in linker scripts are commands or directives that influence the
    behavior of the linker. A typical linker script includes directives for setting
    the entry point of the program and directives for defining the memory layout.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Symbols in linker scripts are identifiers that act as placeholders or references
    to specific memory locations, values, or addresses within the microcontroller’s
    memory space. Symbols can be used to represent the start or end addresses of memory
    sections or specific variables in the program. For example, a symbol might be
    defined to represent the beginning of the flash memory or the start of the SRAM
    region. We can also use symbols to define important constants or values that are
    used throughout the firmware (such as source code files). These might include
    hardware addresses, configuration values, or size limits. By using symbols, the
    code becomes more readable and maintainable, as these values can be changed in
    one place (the linker script), rather than in multiple locations throughout the
    code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the key components of linker scripts, we will
    proceed to learn about some of the essential directives within these scripts.
    Each directive in a linker script instructs the linker on how to process and organize
    the input object files into the final executable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Linker script directives
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learn about the essential directives of linker scripts.
    These directives dictate the memory layout and how various sections—code, data,
    and others—are allocated within the target microcontroller’s memory. We will explore
    the key directives, their functionality, and how they influence the overall structure
    and efficiency of the compiled firmware. Let’s start with the `MEMORY` directive.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Memory directive (MEMORY)
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MEMORY` directive delineates the microcontroller’s memory regions. Each
    defined block within the `MEMORY` section represents a distinct area of memory,
    characterized by its name, start address, and size. This directive allows us to
    define the memory layout of the target device, specifying different memory regions
    and their attributes. It plays an important role in guiding the linker on how
    to allocate sections of the program (code, data, etc.) across the microcontroller’s
    physical memory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Usage template
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The general syntax for the `MEMORY` directive is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`name`: An identifier we give to the memory region'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributes`: This specifies the access permissions for the region, such as
    read, write, and execute permissions'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORIGIN`: This defines the start address of the memory region'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LENGTH`: This specifies the size of the memory region'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage example
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider a microcontroller with flash memory for storing executable code and
    SRAM for data storage. A linker script might define these memory regions as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, two memory regions are defined: `FLASH` and `SRAM`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '`FLASH` is marked with read (`r`) and execute (`x`) permissions (`rx`), indicating
    that this region can store executable code but is not writable during program
    execution. It starts at the `0x08000000` address and extends for `256K` bytes.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SRAM` is given read (`r`), write (`w`), and execute (`x`) permissions (`rwx`),
    allowing it to store data and executable code that can be modified during runtime.
    It begins at the `0x20000000` address and extends for `64K` bytes.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `MEMORY` directive, with its comprehensive definition of memory regions
    and attributes, lays the foundation for efficient and effective memory management
    in firmware development. Before moving on to the next directive, let’s examine
    all the attributes that can be specified to detail the characteristics and permissions
    of the memory sections:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '`r`: This attribute allows memory to be read. It is important for sections
    of memory containing executable code or constants that the program needs to read
    during execution.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: This attribute permits data to be written to the memory. It is important
    for memory areas where the program stores data dynamically during execution.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: This attribute allows the execution of code from the specified memory
    region. It is typically assigned to flash memory where the program code resides.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw`: This is a combination of read and write permissions, allowing both operations
    in the specified memory region. It’s commonly used for sections such as SRAM where
    temporary data and variables are stored and modified.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rx`: This combines read and execute permissions. It’s often used for flash
    memory to indicate that the region contains executable code that the processor
    can read and execute.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rwx`: This attribute combines all three permissions, making the memory region
    fully accessible for reading, writing, and executing. This is less commonly used
    due to security and system stability considerations but might be applicable in
    certain development or debug scenarios.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`empty`: If no attribute is specified, the memory region does not grant any
    access permissions by default. This might be used in special cases where permissions
    are controlled or modified by other means within the firmware.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s examine the `ENTRY` directive.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The entry directive (ENTRY)
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This directive specifies the entry point of the program, which is the first
    piece of code to execute upon reset.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is a usage example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, `Reset_Handler` is designated as the entry point of the program,
    meaning, the first function to execute. In firmware development, `Reset_Handler`
    takes care of initializing the system and jumping to the main program.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `SECTIONS` directive.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The sections directive (SECTIONS)
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This directive defines the mapping and ordering of sections from input files
    into the output file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Usage example
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s see a template of it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The parameters are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '`output_section_name`: This is the name given to the output section being defined.
    Common names include `.text` for executable code, `.data` for initialized data,
    and `.bss` for uninitialized data.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`address`: This is optional and specifies the start address of the section
    in memory. This is often left to the linker to determine, based on the order of
    sections and memory regions defined in the script.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input_section_information`: This determines which input sections (from the
    compiled object files) should be included in this output section. Wildcards such
    as `*(.text)` can be used to include all `.text` sections from all input files.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>memory_region`: This assigns the section to a specific memory region defined
    in the `MEMORY` block of the linker script. We use this to tell the linker where
    in the target’s memory map this section should reside, for example, `FLASH` or
    `SRAM`.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[AT>load_address]`: This is optional and specifies the load address of the
    section. This is used in scenarios where the execution address differs from the
    load address.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ALIGN(expression)]`: This is optional and aligns the start of the section
    to an address that is a multiple of the value specified by `expression`. This
    is particularly useful for ensuring that sections begin at addresses that meet
    specific alignment requirements, which can enhance access speed and compatibility.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:phdr_expression]`: This is optional and associates the section with a program
    header. Program headers are part of the **Executable and Linkable Format** (**ELF**)
    file structure; they provide the system loader with information about how to load
    and run different segments of a program.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[=fill_expression]`: This is optional and specifies a byte value to fill gaps
    between sections or at the end of sections to reach a certain alignment. This
    can be useful for initializing memory regions to a known state.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage example
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s see an example of the `SECTIONS` directive in action:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we have the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '`SECTIONS`: This keyword begins the section of the linker script where output
    sections are defined. Output sections are areas of memory that hold the code and
    data from the input files being linked.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.text 0x08000000`: This line defines an output section named `.text` and sets
    its starting address to `0x08000000`. The `.text` section typically contains executable
    code.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ *(.text) }`: This line specifies what goes into the `.text` output section.
    The `*(.text)` syntax means all `.text` sections from all input files.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>FLASH`: This directive tells the linker to place the `.text` section in a
    memory region named `FLASH`. The `FLASH` region will be defined in the `MEMORY`
    directive block.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the importance of the `*(.text)` syntax, let’s examine the process
    of merging sections.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Sections merging
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we learned earlier, the assembler generates an object file for each source
    file, with each containing its `.text`, `.data`, `.bss`, and other sections. These
    sections from all object files are then merged by the linker into unified `.text`,
    `.data`, and `.bss` sections for the final executable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Consider a firmware project with two source files, `main.c` and `delay.c`. The
    assembly process yields `main.o` and `delay.o`, each with its own sections. The
    linker’s task is to consolidate these into a single set of sections for the final
    executable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The following figure depicts this process. Note that merging is *not* performed
    through an addition process; this is merely a visual aid to enhance your understanding.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: The merging process involving two source files: main.c and delay.c,
    resulting in the production of the final executable, final.elf](img/B21914_04_4.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: The merging process involving two source files: main.c and delay.c,
    resulting in the production of the final executable, final.elf'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore the purpose of the `AT >` directive. To do this, it is essential
    to revisit the concepts of the LMA and VMA.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at the LMA and VMA
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we learned earlier, each allocatable and loadable output section in a binary
    output file is associated with two types of addresses: the LMA and the VMA. These
    addresses are crucial for defining how and where a section of the binary is processed
    during the system’s startup and its subsequent runtime operations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**LMA**: This is the physical address in the binary image where the section
    is stored before program execution begins. It determines from where the system
    will load the section into memory when the program starts.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VMA**: In contrast, the VMA is the address where the section is intended
    to be accessed during the program’s execution. This is the “runtime” address used
    by the system to refer to data or instructions in that section. For systems, particularly
    microcontrollers, that do not employ a **memory management unit** (**MMU**), the
    VMA usually matches the section’s physical memory address directly.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are LMA and VMA important?
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The distinction between LMA and VMA allows for a flexible memory management
    approach where data can be stored in one location (such as flash memory) but run
    from another (such as SRAM). For example, initialized global and static variables
    (typically placed in the `.data` section) can be stored in flash memory but need
    to be copied to SRAM for faster access and to allow modification at runtime.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'To fully understand this, let’s consider the following snippet from a linker
    script generated by the STM32CubeIDE:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this script, the last line, `>SRAM AT> FLASH`, incorporates two important
    directives:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '`>SRAM` indicates that the output `.data` section is placed in the `SRAM` section
    of the memory during program execution (VMA).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AT> FLASH` specifies that although the section resides in SRAM when executed,
    it should initially be loaded into memory (`FLASH`. This is common for initialized
    data, which is stored in flash memory and then copied to SRAM at startup by the
    microcontroller’s initialization code.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This detailed management of memory addresses highlights the critical role of
    LMA and VMA in maximizing the efficiency of resource-constrained microcontrollers.
    Through the effective use of LMA and VMA, we can ensure that even with limited
    memory resources, our microcontrollers operate reliably and efficiently, optimizing
    both storage and execution efficiency.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Before moving to explore the other features of the linker script, let’s familiarize
    ourselves with some other commonly used directives.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Other commonly used directives
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some other commonly used directives include the `KEEP`, `ALIGN`, `PROVIDE`,
    `>region`, and `AT` directives. Let’s examine them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The KEEP directive
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `KEEP` directive ensures that specified sections or symbols are not eliminated
    by the linker during the optimization process, even if they appear unused. This
    is crucial for interrupt vector tables and initialization functions that must
    be present in the final binary.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is a usage example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we are *keeping* the interrupt vector section. Next, let’s
    see the region placement directive.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The >region directive
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `(>region)` region placement directive tells the linker to place a particular
    section into a specific memory region. The available memory regions must be defined
    in the `MEMORY` directive block of the linker script.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is a usage example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we are placing the `.data` section in the `SRAM` memory region.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The ALIGN directive
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `ALIGN` directive plays a crucial role in the linker script by adjusting
    the location counter to align with specified memory boundaries. **The location
    counter** tracks the current memory address allocated by the linker for placing
    sections or parts of the output file during linking.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`.`) in linker scripts.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: As the linker processes the script, it assigns memory addresses to code and
    data sections according to the script’s directives, with the location counter
    monitoring the progress. To ensure efficient memory access and adherence to hardware
    architecture requirements, sections and variables often need to be aligned to
    specific boundaries. The `ALIGN` directive allows us to achieve this by rounding
    up the location counter to the nearest address that matches the specified alignment,
    which must be a power of two.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is a usage example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we are aligning the current location to a `4`-byte boundary.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see the `PROVIDE` directive.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The PROVIDE directive
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `PROVIDE` directive allows us to define symbols that the linker will include
    in the output file if they are not already defined. This can be used to set default
    values for symbols that may be optionally overridden by other modules.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is a usage example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we are *providing* a default stack end address.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `AT` directive.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: AT Directive
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `AT` directive specifies LMA for a section when it needs to be different
    from the section’s VMA. This is commonly used for sections that need to be loaded
    into a different memory area during initialization before being moved to their
    runtime location.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage template:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is a usage example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, the `.data` section is intended to reside in SRAM during the
    program’s execution. However, it is initially loaded from `FLASH`, as indicated
    by `AT> FLASH`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will explore another key aspect of linker scripts:
    the expression of numerical constants.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Understanding constants in linker scripts
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing our linker script, we must keep in mind the interpretation of numerical
    prefixes and suffixes by the linker.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, let’s clarify how the linker perceives integers with specific prefixes.
    An integer prefixed with `0` is read as an octal number by the linker. On the
    other hand, an integer starting with `0x` is recognized as a hexadecimal value.
    This distinction is important for accurately defining memory addresses and sizes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `K` and `M` suffixes introduces another layer of convenience,
    allowing us to denote large numbers succinctly. The `K` suffix multiplies the
    preceding number by `1024`, while `M` expands the number by 1,024 twice over.
    Therefore, `4K` translates to 4 times 1024, and `4M` expands to 4 times 1,024
    squared.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: To put these principles into practice, let’s explore an example that showcases
    the versatility of these notations. Imagine you need to specify a memory size
    of 4K. You could straightforwardly use `4K`, or opt for its decimal equivalent,
    `4096`, which results from multiplying 1,024 by 4\. Alternatively, this quantity
    can be expressed in hexadecimal form as `0x1000`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 4.2* summarizes the key points to remember about using constants in
    linker scripts. It highlights the prefixes and suffixes that modify the base value,
    which offers a clear reference for interpreting and using these notations effectively
    in your linker script.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '| **Notation** | **Meaning** | **Example** | **Equivalent** **Decimal** | **Hexadecimal**
    **Notation** |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| `0` | Octal prefix | `010` | 8 | - |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| `0x` | Hexadecimal prefix | `0x10` | 16 | - |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| `K` | Multiplies by 1,024 | `4K` | 4096 | `0x1000` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| `M` | Multiplies by 1,024 twice (squared) | `4M` | 4194304 | `0x400000` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: 'Table 4.2: Examples of linker script numerical prefixes and suffixes'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we shall learn about linker script symbols, further enhancing
    our understanding of linker scripts.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Linker script symbols
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linker symbols, also known simply as **symbols**, are fundamental elements
    in the process of converting source code into executable programs. At its core,
    a linker symbol comprises two essential components: a name and a value. These
    symbols are assigned integer values, representing memory addresses where variables,
    functions, or other program elements are stored in the microcontroller’s memory.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we learned that after the assembly stage, the source code is transformed
    into object files. These object files contain machine code and unresolved references
    to variables and functions. The linker’s primary task is to merge these object
    files, resolve these unresolved symbols, and generate a complete executable file
    ready for execution.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In the context of linker symbols, the value assigned to a symbol represents
    the memory address where the corresponding variable or function resides.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'For example: X = 3500 means the memory address of X is 3500'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: A symbol named `X` might be assigned a value of `3500`, indicating its memory
    address. It’s crucial to note that in contrast to the variable’s value in the
    source code, the `X` linker symbol represents its memory address.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Type** | **Value (Memory** **Address)** | **Description** |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| `X` | Symbol | `3500` | Represents the memory address where an `X` variable
    is stored. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| `Y` | Symbol | `0x3000` | Represents the memory address where a `Y` variable
    is stored. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| `foo()` | Symbol | `0x4000` | Represents the memory address where a `foo()`
    function is located. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| `bar()` | Symbol | `0x5000` | Represents the memory address where a `bar()`
    function is located. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| `x` | Variable | `3500` | Represents the value of a C variable named `x`.
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| `y` | Variable | `4500` | Represents the value of a C variable named `y`.
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: 'Table 4.3: Comparison of linker symbols and C source code variables assignments'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Linker symbols can undergo various operations, such as those we use in C assignments.
    These operations include straightforward assignment (`=`), addition (`+=`), and
    subtraction (`-=`), among others.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Examples of linker symbol operations](img/B21914_04_5.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Examples of linker symbol operations'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: During the linking process, a symbol table is created, mapping each symbol to
    its corresponding address in memory. This table serves as a crucial reference
    for the linker to resolve symbol references and ensure proper linking of program
    components.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a scenario where we have a `main.c` file and at the top of this
    file; we declare a variable named `X`, assigning it a value of `568`. Additionally,
    within this file, there’s a function named `blink`. Inside the `blink` function,
    there are operations to turn on an LED, wait, and then turn it off. This is depicted
    in *Figure 4**.6*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take this `main.c` file and pass it through the build process to
    generate the `main.o` object file. During this process, a symbol table is generated.
    Each symbol in this table is associated with an address.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the `X` symbol would be assigned an address of `0x20000000`, and
    similarly, the `blink` function would also be assigned its address. In the following
    figure, the `blink` function is assigned the `0x08000000` address.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, just like in the C programming language, each variable has its
    value. In the object file, each symbol has its value, which essentially represents
    the address of the corresponding variable or function in C.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: So, when referring to `X` in the object file, it wouldn’t give us `568`; rather,
    it would provide the address of `X`. This process of assigning values to symbols
    and associating them with addresses constructs the symbol table.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Representation of functions and variables from the source file
    in the symbol table of the output object file](img/B21914_04_6.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Representation of functions and variables from the source file
    in the symbol table of the output object file'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we delved deep into linker scripts, highlighting key components
    and directives. We carefully explored each directive, providing practical usage
    examples. Additionally, we distinguished between the LMA and VMA and also emphasized
    their important roles in guiding the linker on how to place sections. In the next
    section, we will learn how to write our own linker script and startup file from
    scratch, equipping you with another important skill in bare-metal firmware development.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Writing the linker script and startup file
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a good understanding of linker scripts and their essential
    components, we’re prepared to write our own. However, before diving into writing
    the script, it’s crucial to revisit the memory map of the microcontroller and
    gain insight into the `positions` load memory for various sections within the
    object file.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the load memory of different sections
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed earlier in this chapter, the output object file is structured into
    sections such as `.data`, `.rodata`, `.text`, and `.bss`. Together with the sections
    created by the assembler, we must define our own section to accommodate the vector
    table for `.isr_vector_tbl`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Each of these sections plays an important role in organizing the memory layout
    of the microcontroller, contributing to the functionality and efficiency of the
    final executable.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure* *4**.7* shows a zoomed-in view of the flash memory area, showing the
    required order for placing the different sections within the flash memory. Each
    section represents the combination of identical sections from all input files.
    For instance, the `.text` section depicted is a unified `.text` section, formed
    by merging all `.text` sections from the input files.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The diagram indicates that the placement must start with the `.isr_vector_tbl`
    section at the beginning of the flash memory. Following this, we must place the
    `.text` section, then the `.rodata` section, and finally, the `.data` section.
    The diagram does not show the placement of the `.bss` section, as we will place
    the `.bss` section directly in the SRAM. Additionally, during the startup code
    implementation, we must copy the content of the `.data` section from the flash
    memory to the SRAM.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表明，放置必须从闪存开始的`.isr_vector_tbl`部分开始。随后，我们必须放置`.text`部分，然后是`.rodata`部分，最后是`.data`部分。该图没有显示`.bss`部分的放置，因为我们将在SRAM中直接放置`.bss`部分。此外，在启动代码实现过程中，我们必须将`.data`部分的内容从闪存复制到SRAM。
- en: '![Figure 4.7: The flash memory area showing the order in which sections should
    be placed](img/B21914_04_7.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：显示各部分放置顺序的闪存区域](img/B21914_04_7.jpg)'
- en: 'Figure 4.7: The flash memory area showing the order in which sections should
    be placed'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：显示各部分放置顺序的闪存区域
- en: Before we proceed, however, let’s understand the concept of interrupts and the
    vector table.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们先了解中断和中断向量表的概念。
- en: Interrupts and the vector table
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断和中断向量表
- en: Interrupts are a fundamental concept in computing. They act as a powerful mechanism
    for managing how a computer or a microcontroller handles tasks and responds to
    external and internal events.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 中断是计算中的基本概念。它们作为管理计算机或微控制器如何处理任务以及如何响应外部和内部事件的一种强大机制。
- en: At its core, an **interrupt** is a signal to the processor from a hardware device
    or an internal software condition that temporarily halts the current operations.
    This signal indicates that immediate attention is required. When the processor
    receives an interrupt, it pauses its current tasks, saves its state, and executes
    a function known as an ISR to address the interrupt. Upon completing the ISR,
    the processor resumes its previous tasks, ensuring that critical signals receive
    prompt and efficient handling.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，**中断**是硬件设备或内部软件条件向处理器发出的信号，该信号暂时中止当前操作。此信号表明需要立即关注。当处理器收到中断时，它会暂停当前任务，保存其状态，并执行一个称为ISR（中断服务例程）的功能来处理中断。完成ISR后，处理器恢复其先前任务，确保关键信号得到及时和有效的处理。
- en: '*What are the types* *of interrupts?*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*中断有哪些类型*？'
- en: 'We can broadly classify interrupts into two categories: hardware interrupts
    and software interrupts:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将中断大致分为两类：硬件中断和软件中断：
- en: '**Hardware interrupts**: These originate from external devices, such as switches,
    network adapters, or any peripheral that needs to communicate with the processor.
    For example, pressing a push button may trigger a hardware interrupt that informs
    the processor to start a motor.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件中断**：这些中断来源于外部设备，例如开关、网络适配器或任何需要与处理器通信的外围设备。例如，按下按钮可能会触发一个硬件中断，通知处理器启动电机。'
- en: '**Software interrupts**: Unlike hardware interrupts, software interrupts are
    triggered by software instructions. These are used by programs to interrupt the
    current process flow and execute a specific routine.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件中断**：与硬件中断不同，软件中断是由软件指令触发的。这些中断被程序用来中断当前进程流程并执行特定的例程。'
- en: '*What is the role of the interrupt* *vector table?*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*中断向量表的作用是什么*？'
- en: The interrupt vector table serves as an essential lookup table, guiding the
    processor to the correct ISR for each interrupt. An ISR is simply a function designed
    to address and manage the specific needs triggered by an interrupt. The table
    itself is **organized as an array of pointers**, with each pointer directing the
    system to the designated ISR for a given interrupt. Upon the occurrence of an
    interrupt, the system references this table to locate the exact memory address
    of the ISR required for handling the interrupt. This efficient mechanism enables
    the system to promptly respond to various events, such as external inputs, timer
    expirations, and changes in the internal state.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 中断向量表作为一个基本查找表，指导处理器找到每个中断的正确ISR。ISR只是一个设计用来处理和管理由中断触发的特定需求的函数。该表本身**组织为一个指针数组**，每个指针将系统指向给定中断的指定ISR。当发生中断时，系统引用此表以定位处理中断所需的ISR的确切内存地址。这种高效机制使系统能够迅速响应各种事件，例如外部输入、计时器超时和内部状态的变化。
- en: With this in mind, we are finally ready to write our linker script.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们终于准备好编写链接脚本了。
- en: Writing the linker script
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写链接脚本
- en: In our workspace folder, let’s make a new folder named `3_LinkerscriptAndStartup`.
    In this folder, create a file called `stm32_ls.ld` and make sure its extension
    is `.ld`. If you’re using Windows and it asks if you really want to change the
    file extension, click **Yes**. Then, right-click the file and open it with a basic
    text editor such as Notepad++.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Our objectives with the linker script can be summarized as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the firmware’s entry point
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailing the available memory
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the necessary heap and stack sizes
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining output sections
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is our complete linker script, the contents of the `stm32_ls.ld` file:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let’s break it down.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the firmware’s entry point
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we learned earlier, the `ENTRY` directive specifies the entry point of the
    firmware, which is the first piece of code that gets executed when the firmware
    starts. In this case, the entry point is the function named `Reset_Handler`. We
    shall implement this function in the startup file.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Detailing the available memory
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our script specifies two memory regions: `FLASH` and `SRAM`. The `FLASH` memory,
    with read and execute permissions (`rx`), starts at the `0x08000000` address and
    has a length of `512K`. The SRAM memory, with read, write, and execute permissions
    (`rwx`), starts at the `0x20000000` address and has a length of `128K`.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Symbol creation
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Over here, we create a symbol called `_estack` and we set it to the end of the
    `SRAM` memory region. We will use this symbol to initialize the stack pointer.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The `SRAM` ensures that it starts at the maximum available address, utilizing
    the `SRAM` space efficiently for stack operations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The next lines of code in our linker script specify the heap and stack sizes.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the necessary heap and stack sizes
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These lines define the maximum sizes for the heap (`0x200` bytes) and stack
    (`0x400` bytes). These sizes are important for dynamic memory allocation and function
    call management, respectively.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The next segment defines the output sections.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Defining output sections
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will go through the output sections.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The .text output section
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This segment of our linker script shows the `.text` output section:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s break it down:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '`. =` `ALIGN(4);`:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive aligns the start of the `.text` section on a `4`-byte boundary.
    This enhances memory access efficiency, which is a critical consideration for
    processors fetching instructions in word-sized chunks.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`*(.``isr_vector_tbl)` :'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive pulls in all sections named `.isr_vector_tbl` from the input
    files into the current location in the `.``text` section.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`*(.``text)`:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive pulls in all sections named `.text` from the input files into
    the current location in the `.``text` section.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`*(.``rodata)`:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive pulls in all sections named `.rodata` from the input files into
    the current location in the `.``text` section.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`. =` `ALIGN(4);`:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, this line ensures that the end of the section is aligned to a `4`-byte
    boundary. Over here, we use it to align the end of a section, ensuring that the
    next section starts on an aligned boundary.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`_etext = .;`:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over here, we define a symbol called `_etext` at the current location. This
    symbol marks the end of the `.text` section. We will use this symbol as a pointer
    to the end of the `.text` section in our startup file.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`}>``FLASH`:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive specifies that the `.text` section should be placed in the `FLASH`
    memory segment as defined earlier in the `MEMORY` block of the linker script.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This segment shows the `.data` output section:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s break it down:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '`=` `ALIGN(4);`:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive aligns the start of the `.data` section on a `4`-byte boundary.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`_sdata = .;`:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over here, we create a symbol named `_sdata` to represent the start of the `.data`
    section by setting it to the current location counter. We will use this symbol
    as a pointer to the start of the `.data` section in our startup file.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`*(.``data)`:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive pulls in all sections named `.data` from the input files into
    the current location in the `.``data` section.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`. =` `ALIGN(4);`:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This line ensures that the end of the section is aligned to a `4`-byte boundary.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`_edata= .;`:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to what we have done previously, we create a symbol named `_edata` to
    represent the end of the `.data` section by setting it to the current location
    counter. We will use this symbol in our startup file.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`> SRAM` `AT> FLASH`:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directive specifies the LMA and the VMA of the `.``data` section.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`> SRAM` indicates that the section should be located in SRAM, allowing read
    and write access at runtime.'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`AT> FLASH` tells the linker that although the section is placed in `SRAM`
    for execution, its initial values should be stored in `FLASH`.'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This segment shows the `.bss` output section:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the final output section of our linker script.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: As we learned earlier, the `.bss` section holds uninitialized global and static
    variables that we will be initialized to zero in our startup file. This zero-initialization
    ensures that all variables in this section begin with a known state, contributing
    to our firmware’s stability and predictability.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other sections, we begin by aligning the section to a `4`-byte boundary
    for efficient memory access, and then we define the `_sbss` and `_ebss` symbols
    to mark the start and end of the section, respectively. These symbols facilitate
    the calculation of the section’s size and its initialization process. Finally,
    we place the section in the SRAM, emphasizing that, although it doesn’t occupy
    space in the binary file on disk, it requires runtime allocation in memory.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: With our linker script finalized, we’ll move on to implementing the startup
    file. This shall be the focus of the next section.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Writing the startup file
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The startup file is essential for initializing the firmware and it performs
    several critical tasks to ensure the system operates correctly from the moment
    it is powered on.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'These tasks include the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing the vector table**: This involves defining the vector table
    that maps interrupts to their handlers, ensuring the system can respond to various
    events efficiently.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating interrupt handlers**: For each interrupt listed in the vector table,
    an interrupt handler must be implemented to define how the system responds to
    that particular event.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reset_Handler`, as specified in the linker script, which acts as the initial
    entry point of the firmware. This function is executed immediately after reset
    and is responsible for setting up the environment for the main application.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.data` section from `FLASH` to `SRAM`.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bss` section to zero, ensuring that all uninitialized global and static variables
    start with a known state for reliable operation.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the current folder containing the linker script, create a file called `stm32f411_startup.c`
    and make sure its extension is `.c`. If you’re using Windows and it asks if you
    really want to change the file extension, click **Yes**. Then, right-click the
    file and open it with a basic text editor such as Notepad++.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze the complete startup code.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is our complete startup code written in C, the contents of the
    `stm32f411_startup.c` file. In the following snippet, we are not showing all the
    function prototypes of all the interrupts in the vector table. The complete source
    code can be found in the resources accompanying the book:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let’s break it down.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: We start by declaring external symbols.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: External symbol declarations
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These lines declare the external symbols that we defined in the linker script.
    Each symbol represents an important memory address used during the startup process:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '`_estack`: This is the initial top of the stack. This value is loaded into
    the main stack pointer register early in the startup process.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_etext:` This marks the end of the executable code section and the beginning
    of the data sections stored in flash memory. We use this as a reference point
    for copying initialized data from `FLASH` to `SRAM`.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_sdata` and `_edata` represent the start and end addresses of the initialized
    data section in SRAM, respectively. We use them to determine the size and destination
    for data copying from `FLASH` to `RAM`.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_sbss` and `_ebss` mark the start and end of the uninitialized data section
    (BSS section) in SRAM. We use these symbols to clear this section, setting it
    to zero.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next in our snippet, we have the function prototypes and their attributes.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Function prototypes and attributes
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At this part of the startup file, we declare the prototype for the `Reset_Handler`
    function, the application’s `main` function, and several interrupt handlers with
    specific attributes:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '`__attribute__((weak, alias("Default_Handler"))):` This attribute makes each
    handler weakly linked and aliases it to a function named `Default_Handler`. It
    allows these handlers to be overridden by explicitly defined handlers with the
    same name elsewhere in the application.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`__attribute__((weak, alias("Default_Handler"))):` 这个属性使得每个处理程序具有弱链接，并将其别名为名为
    `Default_Handler` 的函数。它允许这些处理程序被显式定义的其他地方具有相同名称的处理程序覆盖。'
- en: 'Let’s break down the statement further to understand its significance:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步分解这个语句以了解其重要性：
- en: '`__attribute__`:'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__attribute__`:'
- en: We use this keyword to tell the compiler that the declaration it’s applied to
    has certain properties that affect how it’s treated by the linker and, potentially,
    at runtime. Attributes can be used to control optimizations, code generation,
    alignment, and, relevant to our discussion, linkage characteristics.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用这个关键字来告诉编译器，它应用到的声明具有某些属性，这些属性会影响链接器以及可能运行时对其的处理。属性可以用来控制优化、代码生成、对齐，以及与我们讨论相关，链接特性。
- en: '`weak`:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weak`:'
- en: Declaring a function or variable as `weak` means that it does not prevent the
    linker from using another symbol of the same name with a stronger linkage. We
    use this to specify default implementations that can be overridden.
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将函数或变量声明为 `weak` 意味着它不会阻止链接器使用具有相同名称的具有更强链接的另一个符号。我们使用此来指定可以覆盖的默认实现。
- en: In the context of our interrupt handlers, marking them as `weak` allows us to
    define default handlers in our startup file, which application-specific handlers
    can override without modifying the startup file.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的中断处理程序上下文中，将它们标记为 `weak` 允许我们在启动文件中定义默认处理程序，而应用特定的处理程序可以在不修改启动文件的情况下覆盖这些默认处理程序。
- en: '`alias("Default_Handler")`:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alias("Default_Handler")`:'
- en: This part of the attribute creates an alias for another symbol, in this case,
    `Default_Handler`. It means that the symbol (e.g., `NMI_Handler`) is not just
    weak, but it is also an alias for the `Default_Handler` function.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这部分属性为另一个符号创建了一个别名，在本例中为 `Default_Handler`。这意味着符号（例如，`NMI_Handler`）不仅具有弱链接，而且它也是
    `Default_Handler` 函数的别名。
- en: This means that when an interrupt occurs, and a specific handler (such as `NMI_Handler`)
    has not been defined elsewhere in the application with stronger linkage (non-weak),
    the program will use `Default_Handler` in its place. This ensures that all interrupts
    have a handler, preventing the system from crashing due to unhandled events.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着当发生中断，并且没有在其他地方（例如，`NMI_Handler`）定义具有更强链接（非弱链接）的特定处理程序时，程序将使用 `Default_Handler`
    来代替。这确保了所有中断都有一个处理程序，防止系统因未处理的事件而崩溃。
- en: Next, we have the vector table array.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有向量表数组。
- en: Vector table definition
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量表定义
- en: '[PRE28]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This array defines the microcontroller’s interrupt vector table, placed in the
    `.isr_vector_tbl` section we defined in the linker script.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组定义了微控制器的中断向量表，放置在我们定义在链接脚本中的 `.isr_vector_tbl` 部分。
- en: We set the `&_estack` symbol as the first element of the vector table to define
    the initial top of the stack in memory. In ARM Cortex microcontrollers, such as
    our STM32F411, the first word (32 bits) of the vector table must contain the initial
    value of the **main stack pointer** (**MSP**). Upon reset, the processor loads
    this value into the MSP register to set up the stack pointer correctly before
    executing any code.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `_estack` 符号设置为向量表的第一个元素，以定义内存中堆栈的初始顶部。在 ARM Cortex 微控制器中，例如我们的 STM32F411，向量表的第一字（32位）必须包含
    **主堆栈指针**（**MSP**）的初始值。在复位时，处理器将此值加载到 MSP 寄存器中，以便在执行任何代码之前正确设置堆栈指针。
- en: Following this, we specify the address of `Reset_Handler`, then we proceed to
    list the addresses for `NMI_Handler` and other subsequent interrupt handlers in
    sequence. The precise placement of these handlers is crucial, as each must reside
    in a specific memory location to ensure correct functionality. This arrangement
    is detailed on *page 201* of the RM0383 document. Within the fully defined vector
    table in our `stm32f411_startup.c` file, you’ll notice that there are zeros strategically
    placed among the interrupt handler addresses. These zeros act as placeholders
    for the positions corresponding to interrupts not supported by our specific microcontroller
    variant (STM32F411). The ARM Cortex-M core architecture is designed to support
    a comprehensive set of interrupts, yet not all interrupts are implemented across
    every microcontroller variant. By inserting zeros for these unsupported interrupts
    in the vector table, we maintain the required alignment with the architecture’s
    specifications, ensuring the system operates correctly.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the array declaration:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`uint32_t vector_tbl[]`:'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This specifies that each element of the `vector_tbl` array is an unsigned 32-bit
    integer. We chose this type because addresses in ARM Cortex-M microcontrollers
    are 32 bits in length, and the vector table consists of memory addresses pointing
    to the start of ISR handlers.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`__attribute__((section(".isr_vector_tbl")))`:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This attribute instructs the linker to place the `vector_tbl` array in a specific
    section of the output file named `.isr_vector_tbl`.
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we have our default handler function.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Default dandler
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function serves as a universal fallback for any interrupt request for which
    a specific handler has not been implemented. Engaging in an infinite loop effectively
    prevents the program from proceeding into an undefined state following such an
    event.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: It is linked to all interrupt handlers marked as `weak` and aliased to `Default_Handler`
    within the application. This strategy ensures a uniform and secure response throughout
    the system to any interrupt requests that lack a dedicated handler, thus upholding
    system stability and integrity.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have our `Reset_Handler` function.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Reset handler implementation
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The job of `Reset_Handler` is to prepare the system before executing the main
    application.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'In the function, we start by calculating the sizes of the `.data` and `.``bss`
    sections:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is a breakdown:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the size of the `.data` section by subtracting the address of the
    start of the section (`_sdata`) from the address of the end (`_edata`). This size
    is used to copy initialized data from `FLASH` to `SRAM`.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the size of the `.bss` section in a similar manner, using the start
    (`_sbss`) and end (`_ebss`) addresses. This size is used to zero out the `.bss`
    section in SRAM.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, in the function, we initialize pointers for copying the `.``data` section:'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the breakdown:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a source pointer (`p_src_mem`) to the address where initialized data
    is stored in flash memory, marked by `_etext`.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize a destination pointer (`p_dest_mem`) to the start of the `.data`
    section in SRAM (`_sdata`).
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we copy the `.data` section from `FLASH` to `SRAM`:'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The breakdown:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `.data` section from `FLASH` to `SRAM` word (32-bit) by word. For each
    iteration, the content pointed to by `p_src_mem` is copied to the location pointed
    to by `p_dest_mem`, and then both pointers are incremented to the next word.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we initialize the pointer for the `.bss` section zeroing:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We simply reset the destination pointer (`p_dest_mem`) to the start of the `.bss`
    section in SRAM (`_sbss`), preparing it for zeroing.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'We then zero out the `.``bss` section:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This block zeroes out the `.bss` section in `SRAM` word by word. For each iteration,
    the location pointed to by `p_dest_mem` is set to `0`, and then `p_dest_mem` is
    incremented to the next word.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call the `main()` function located in the `main.c` file of our
    source code:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After initializing the `.data` and `.bss` sections, this line calls the `main`
    function, transferring control to the main application code. This marks the end
    of the system initialization process and the beginning of the application execution.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed both our linker script and startup file, it is time
    to test our implementation by building the firmware using just our `main.c` source
    file, the `stm32_ls.ld` linker script, and the `stm32f411_startup.c` startup file.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Testing our linker script and startup file
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the command line, it’s important to ensure that our linker
    script and startup file are correctly placed. Let’s set up our project directory
    and add some modification to our `main.c` file:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '`3_LinkerAndStartup` in your workspace.'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`main.c` file from the previous project (`2_RegisterManipulation`), which includes
    the foundational application code.'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, locate `stm32_ls.ld` (linker script) and `stm32f411_startup.c`
    (startup file).
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste these files (`stm32_ls.ld, stm32f411_startup.c`, and `main.c`)
    into the `3_LinkerAndStartup` folder.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`main.c` file from fast to slow:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`main.c` file within the `3_LinkerAndStartup` folder and select the option
    to open it with a simple text editor, such as Notepad++.'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LED_PIN`). Adjust the delay intervals within this section to change the LED’s
    blink rate from its current rapid pace to a slower one. The current one should
    look like this:'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Replace the current code with the following snippet to toggle the state of
    PA5 at a slower rate:'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let’s access our new folder through the Command Prompt following the steps
    we learned in [*Chapter 3*](B21914_03.xhtml#_idTextAnchor080). My favorite method
    for Windows users is the context menu method:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `3_LinkerAndStartup` folder in Windows Explorer. Once there,
    hold down the *Shift* key, *right-click* in a space within the folder, and select
    `3_LinkerAndStartup` folder.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 资源管理器中导航到 `3_LinkerAndStartup` 文件夹。一旦到达那里，按住 *Shift* 键，在文件夹内的空白处 *右键单击*，然后选择
    `3_LinkerAndStartup` 文件夹。
- en: 'In the Command Prompt, we start by compiling the `main.c` file, and we do this
    by executing the following:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符中，我们首先编译 `main.c` 文件，我们通过执行以下命令来完成：
- en: '[PRE40]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we execute our startup file:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行启动文件：
- en: '[PRE41]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once our `main.o` and `stm32f411_startup.o` object files are ready, we go ahead
    and link all object files (`*.o`) using our linker script:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的 `main.o` 和 `stm32f411_startup.o` 对象文件准备就绪，我们就使用我们的链接脚本链接所有对象文件 (`*.o`)：
- en: '[PRE42]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This process produces the `3_LinkerAndStartup.elf` executable.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程生成了 `3_LinkerAndStartup.elf` 可执行文件。
- en: 'Next, we launch `openocd` to begin the uploading process:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们启动 `openocd` 以开始上传过程：
- en: '[PRE43]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With OpenOCD running, the next step involves using the **GNU Debugger** (**GDB**)
    to upload the firmware to the microcontroller. Let’s access another Command Prompt
    window (as OpenOCD should keep running in the first one) and enter the following
    command to start the GDB:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 OpenOCD 的运行，下一步涉及使用 **GNU 调试器** (**GDB**) 将固件上传到微控制器。让我们打开另一个命令提示符窗口（因为 OpenOCD
    应该在第一个窗口中继续运行）并输入以下命令以启动 GDB：
- en: '[PRE44]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once GDB is open, we establish a connection to our microcontroller by running:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 GDB 打开，我们通过运行以下命令来与我们的微控制器建立连接：
- en: '[PRE45]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s reset and initialize the board as we learned in [*Chapter 3*](B21914_03.xhtml#_idTextAnchor080)
    using the following command:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令重置和初始化板子，就像我们在 [*第 3 章*](B21914_03.xhtml#_idTextAnchor080) 中学习的那样：
- en: '[PRE46]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we load the firmware onto the microcontroller using the following command:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下命令将固件加载到微控制器上：
- en: '[PRE47]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After successfully loading the firmware, we reset the board again with the
    same reset command:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 成功加载固件后，我们再次使用相同的复位命令来重置板子：
- en: '[PRE48]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we resume the execution of the firmware on the microcontroller with
    the following:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下命令在微控制器上恢复固件的执行：
- en: '[PRE49]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There you have it; you should see the LED blinking at a slower rate, indicating
    the successful upload and execution of our new firmware.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；你应该会看到 LED 以较慢的速度闪烁，这表明新固件的成功上传和执行。
- en: Summary
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we deeply explored the core components of embedded bare-metal
    programming, focusing on the microcontroller’s memory model, writing linker scripts,
    and startup files. We began by exploring the STM32 microcontroller’s memory layout,
    emphasizing the importance of flash memory and SRAM for storing executable code
    and runtime data.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了嵌入式裸机编程的核心组件，重点关注微控制器的内存模型、编写链接脚本和启动文件。我们首先探索了 STM32 微控制器的内存布局，强调了闪存和
    SRAM 在存储可执行代码和运行时数据方面的重要性。
- en: We then dedicated a significant portion of the chapter to constructing and understanding
    linker scripts. Through this, we understood these scripts’ critical role in the
    firmware build process by mapping the compiled firmware sections to the microcontroller’s
    specific memory regions to ensure the executable operates correctly. We learned
    about the various directives within a linker script, such as `MEMORY` and `SECTIONS`.
    These directives are crucial for defining the memory layout and specifying where
    and how program sections are placed in memory.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节中投入了相当大的篇幅来构建和理解链接脚本。通过这个过程，我们理解了这些脚本在固件构建过程中的关键作用，通过将编译后的固件部分映射到微控制器的特定内存区域，以确保可执行程序正确运行。我们学习了链接脚本中的各种指令，例如
    `MEMORY` 和 `SECTIONS`。这些指令对于定义内存布局和指定程序部分在内存中的放置位置和方式至关重要。
- en: Our discussion on linker scripts extended to the practicalities of defining
    memory regions, aligning sections, and managing section attributes for optimal
    memory utilization. We gave special attention to the LMA and VMA, which are essential
    for efficient program loading and execution.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于链接脚本的讨论扩展到了定义内存区域、对齐部分和管理部分属性以实现最佳内存利用的实际问题。我们特别关注 LMA 和 VMA，这对于高效的程序加载和执行至关重要。
- en: Transitioning to the startup file, we meticulously outlined the startup file’s
    role, covering the initialization of the vector table, setting up `Reset_Handler`,
    and preparing the system for the execution of the main application. We learned
    the procedures for copying the `.data` section from `FLASH` to `SRAM` and zeroing
    the `.bss` section, ensuring a predictable start for our firmware.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 转到启动文件部分，我们详细阐述了启动文件的作用，包括初始化向量表、设置`Reset_Handler`以及为主应用程序的执行准备系统。我们学习了将`.data`部分从`FLASH`复制到`SRAM`以及清零`.bss`部分的步骤，确保我们的固件有一个可预测的启动。
- en: In the next chapter, we will explore build systems, highlighting the essential
    role of the `Make` tool. This knowledge will enable us to streamline our build
    process by automating it, instead of manually entering each command in the command
    line.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨构建系统，突出`Make`工具的至关重要作用。这一知识将使我们能够通过自动化构建过程来简化我们的构建流程，而不是手动在命令行中输入每个命令。
