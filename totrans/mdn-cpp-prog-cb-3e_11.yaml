- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Exploring Testing Frameworks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索测试框架
- en: Testing the code is an important part of software development. Although there
    is no support for testing in the C++ standard, there are a large variety of frameworks
    for unit testing C++ code. The purpose of this chapter is to get you started with
    several modern and widely used testing frameworks that enable you to write portable
    testing code. The frameworks that will be covered in this chapter are **Boost.Test**,
    **Google Test**, and **Catch2**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码是软件开发的重要部分。尽管 C++ 标准中没有对测试的支持，但存在大量用于单元测试 C++ 代码的框架。本章的目的是让您开始使用几个现代且广泛使用的测试框架，这些框架使您能够编写可移植的测试代码。本章将涵盖的框架是
    **Boost.Test**、**Google Test** 和 **Catch2**。
- en: 'This chapter includes the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下食谱：
- en: Getting started with Boost.Test
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Boost.Test
- en: Writing and invoking tests with Boost.Test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Boost.Test 编写和调用测试
- en: Asserting with Boost.Test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Boost.Test 进行断言
- en: Using test fixtures with Boost.Test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Boost.Test 的测试夹具
- en: Controlling output with Boost.Test
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Boost.Test 控制输出
- en: Getting started with Google Test
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Google Test
- en: Writing and invoking tests with Google Test
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google Test 编写和调用测试
- en: Asserting with Google Test
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google Test 进行断言
- en: Using test fixtures with Google Test
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google Test 的测试夹具
- en: Controlling output with Google Test
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google Test 控制输出
- en: Getting started with Catch2
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Catch2
- en: Writing and invoking tests with Catch2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Catch2 编写和调用测试
- en: Asserting with Catch2
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Catch2 进行断言
- en: Controlling output with Catch2
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Catch2 控制输出
- en: 'These three frameworks were chosen due to their wide use, rich capabilities,
    the ease with which they can be used to write and execute tests, their extensibility,
    and their customization. The following table shows a short comparison of the features
    of these three libraries:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个框架被选择是因为它们广泛的使用、丰富的功能、易于编写和执行测试、可扩展性和可定制性。以下表格展示了这三个库功能的简要比较：
- en: '| **Feature** | **Boost.Test** | **Google Test** | **Catch2 (v3)** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **Boost.Test** | **Google Test** | **Catch2 (v3)** |'
- en: '| Easy to install | Yes | Yes | Yes |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 容易安装 | 是 | 是 | 是 |'
- en: '| Header-only | Yes | No | No |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 仅头文件 | 是 | 否 | 否 |'
- en: '| Compiled library | Yes | Yes | Yes |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 编译库 | 是 | 是 | 是 |'
- en: '| Easy to write tests | Yes | Yes | Yes |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 容易编写测试 | 是 | 是 | 是 |'
- en: '| Automatic test registration | Yes | Yes | Yes |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 自动测试注册 | 是 | 是 | 是 |'
- en: '| Supports test suites | Yes | Yes | No (indirectly with tags) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 支持测试套件 | 是 | 是 | 否（间接通过标签）|'
- en: '| Supports fixtures | Yes (setup/teardown) | Yes (setup/teardown) | Yes (multiple
    ways) |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 支持夹具 | 是（设置/清理）| 是（设置/清理）| 是（多种方式）|'
- en: '| Rich set of asserts | Yes | Yes | Yes |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 丰富的断言集 | 是 | 是 | 是 |'
- en: '| Non-fatal asserts | Yes | Yes | Yes |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 非致命断言 | 是 | 是 | 是 |'
- en: '| Multiple output formats | Yes (includes HRF, XML) | Yes (includes HRF, XML)
    | Yes (includes HRF, XML) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 多种输出格式 | 是（包括 HRF、XML）| 是（包括 HRF、XML）| 是（包括 HRF、XML）|'
- en: '| Filtering of test execution | Yes | Yes | Yes |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 测试执行过滤 | 是 | 是 | 是 |'
- en: '| License | Boost | Apache 2.0 | Boost |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 许可证 | Boost | Apache 2.0 | Boost |'
- en: 'Table 11.1: Comparison of features for Boost.Test, Google Test, and Catch2'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1：Boost.Test、Google Test 和 Catch2 功能比较
- en: All these features will be discussed in detail for each framework. This chapter
    has a symmetric structure, with 4 5 recipes dedicated to each testing framework.
    The first framework to look at is Boost.Test.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能将在每个框架的详细讨论中介绍。本章具有对称结构，有 4 个 5 个食谱专门针对每个测试框架。首先考虑的框架是 Boost.Test。
- en: Getting started with Boost.Test
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Boost.Test
- en: '**Boost.Test** is one of the oldest and most popular C++ testing frameworks.
    It provides an easy-to-use set of APIs for writing tests and organizing them into
    test cases and test suites. It has good support for asserting, exception handling,
    fixtures, and other important features required for a testing framework.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Boost.Test** 是最古老且最受欢迎的 C++ 测试框架之一。它提供了一套易于使用的 API，用于编写测试并将它们组织成测试用例和测试套件。它对断言、异常处理、夹具和其他测试框架所需的重要功能提供了良好的支持。'
- en: Throughout the next few recipes, we will explore the most important features
    it has that enable you to write unit tests. In this recipe, we will see how to
    install the framework and create a simple test project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个食谱中，我们将探索它最重要的功能，这些功能使您能够编写单元测试。在这个食谱中，我们将看到如何安装框架并创建一个简单的测试项目。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The Boost.Test framework has a macro-based API. Although you only need to use
    the supplied macros for writing tests, a good understanding of macros is recommended
    if you want to use the framework well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Test 框架有一个基于宏的 API。虽然你只需要使用提供的宏来编写测试，但如果想很好地使用该框架，建议你了解宏。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In order to set up your environment to use Boost.Test, do the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置你的环境以使用 Boost.Test，请执行以下操作：
- en: Download the latest version of the Boost library from [http://www.boost.org/](http://www.boost.org/).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [http://www.boost.org/](http://www.boost.org/) 下载最新的 Boost 库版本。
- en: Unzip the content of the archive.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压存档的内容。
- en: Build the library using the provided tools and scripts in order to use either
    the static or shared library variant. This step is not necessary if you plan to
    use the header-only version of the library.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的工具和脚本构建库，以便使用静态库或共享库变体。如果你计划使用库的头文件版本，这一步是不必要的。
- en: 'On Linux systems, the library can also be installed using package management
    tools. For instance, on Ubuntu, you can use **app-get** to install the libboost-test-dev
    package containing the Boost.Test library as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统上，也可以使用包管理工具安装库。例如，在 Ubuntu 上，你可以使用 **app-get** 安装包含 Boost.Test 库的
    `libboost-test-dev` 包，如下所示：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is recommended that you consult the online documentation of the library for
    installation steps on various systems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你查阅库的在线文档，了解在不同系统上的安装步骤。
- en: 'To create your first test program using the header-only variant of the Boost.Test
    library, do the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Boost.Test 库的头文件版本创建你的第一个测试程序，请执行以下操作：
- en: Create a new, empty C++ project.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的、空的 C++ 项目。
- en: Do the necessary setup specific to the development environment you are using
    to make the Boost `main` folder available to the project for including header
    files.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你使用的开发环境进行必要的设置，以便将 Boost 的 `main` 文件夹对项目可用，以便包含头文件。
- en: 'Add a new source file to the project with the following content:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新的源文件，内容如下：
- en: '[PRE1]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you want to link against the shared library version, then also define the
    `BOOST_TEST_DYN_LINK` macro.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要链接到共享库版本，那么还需要定义 `BOOST_TEST_DYN_LINK` 宏。
- en: Build and run the project.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目。
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Boost.Test library can be downloaded, along with other Boost libraries,
    from [http://www.boost.org/](http://www.boost.org/). In this edition of the book,
    I used version 1.83, but the features discussed in these recipes will probably
    be available for many future versions. The `Test` library comes in three variants:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Test 库可以与其它 Boost 库一起从 [http://www.boost.org/](http://www.boost.org/)
    下载。在这本书的这一版中，我使用了 1.83 版本，但讨论的这些功能可能适用于许多未来的版本。`Test` 库有三个变体：
- en: '**Single header**: This enables you to write test programs without building
    the library; you just need to include a single header. Its limitation is that
    you can only have a single translation unit for the module; however, you can still
    split the module into multiple header files so that you can separate different
    test suites into different files.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单个头文件**：这使你能够在不构建库的情况下编写测试程序；你只需要包含一个头文件。它的限制是，你只能为模块有一个翻译单元；然而，你仍然可以将模块分割成多个头文件，以便将不同的测试套件分开到不同的文件中。'
- en: '**Static library**: This enables you to split a module across different translation
    units, but the library needs to be built first as a static library.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态库**：这使你能够将模块分割到不同的翻译单元中，但库需要首先作为一个静态库来构建。'
- en: '**Shared library**: This enables the same scenario as that of the static library.
    However, it has the advantage that, for programs with many test modules, this
    library is linked only once, and not once for each module, resulting in a smaller
    binary size. However, in this case, the shared library must be available at runtime.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享库**：这提供了与静态库相同的场景。然而，它有一个优点，即对于具有许多测试模块的程序，这个库只需链接一次，而不是每个模块都链接一次，从而减小了二进制文件的大小。但是，在这种情况下，共享库必须在运行时可用。'
- en: For simplicity, we will use the single-header variant in this book. In the case
    of static and shared library variants, you’d need to build the library. The downloaded
    archive contains scripts for building the library. However, the exact steps vary,
    depending on the platform and the compiler; they will not be covered here but
    are available online.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将在这本书中使用单个头文件变体。在静态库和共享库变体的情况下，你需要构建库。下载的存档包含构建库的脚本。然而，具体的步骤取决于平台和编译器；它们将不会在此处介绍，但可以在网上找到。
- en: 'There are several terms and concepts that you need to understand in order to
    use the library:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个库，你需要理解几个术语和概念：
- en: '**Test module** is a program that performs tests. There are two types of modules:
    **single-file** (when you use the single-header variant) and **multifile** (when
    you use either the static or shared variant).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试模块**是一个执行测试的程序。有两种类型的模块：**单文件**（当你使用单头文件变体时）和**多文件**（当你使用静态或共享变体时）。'
- en: '**Test assertion** is a condition that is checked by a test module.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试断言**是测试模块检查的条件。'
- en: '**Test case** is a group of one or more test assertions that is independently
    executed and monitored by a test module so that if it fails or leaks uncaught
    exceptions, the execution of other tests will not be stopped.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例**是一组一个或多个测试断言，它由测试模块独立执行和监控，以便如果它失败或泄漏未捕获的异常，其他测试的执行将不会停止。'
- en: '**Test suite** is a collection of one or more test cases or test suites.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件**是一组一个或多个测试用例或测试套件。'
- en: '**Test unit** is either a test case or a test suite.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试单元**是一个测试用例或测试套件。'
- en: '**Test tree** is a hierarchical structure of test units. In this structure,
    test cases are leaves and test suites are non-leaves.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试树**是测试单元的分层结构。在这个结构中，测试用例是叶子节点，测试套件是非叶子节点。'
- en: '**Test runner** is a component that, given a test tree, performs the necessary
    initialization, execution of tests, and results reporting.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试执行器**是一个组件，给定一个测试树，执行必要的初始化、测试执行和结果报告。'
- en: '**Test report** is the report produced by the test runner from executing the
    tests.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试报告**是测试执行器从执行测试产生的报告。'
- en: '**Test log** is the recording of all the events that occur during the execution
    of the test module.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试日志**是记录测试模块执行期间发生的所有事件的记录。'
- en: '**Test setup** is the part of the test module responsible for the initialization
    of the framework, construction of the test tree, and individual test case setups.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试设置**是负责初始化框架、构建测试树和单个测试用例设置的测试模块的一部分。'
- en: '**Test cleanup** is a part of the test module responsible for cleanup operations.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试清理**是负责清理操作的测试模块的一部分。'
- en: '**Test fixture** is a pair of setup and cleanup operations that are invoked
    for multiple test units in order to avoid repetitive code.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试夹具**是一对设置和清理操作，用于多个测试单元以避免重复代码。'
- en: 'With these concepts defined, it is possible to explain the sample code listed
    earlier:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些概念之后，就可以解释前面列出的示例代码：
- en: '`#define BOOST_TEST_MODULE My first test module` defines a stub for module
    initialization and sets a name for the main test suite. This must be defined before
    you include any library header.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#define BOOST_TEST_MODULE My first test module`定义了一个模块初始化的占位符并为主测试套件设置了一个名称。这必须在包含任何库头文件之前定义。'
- en: '`#include <boost/test/included/unit_test.hpp>` includes the single-header library,
    which includes all the other necessary headers.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#include <boost/test/included/unit_test.hpp>`包含单头文件库，该库包含所有其他必要的头文件。'
- en: '`BOOST_AUTO_TEST_CASE(first_test_function)` declares a test case without parameters
    (`first_test_function`) and automatically registers it to be included in the test
    tree as part of the enclosing test suite. In this example, the test suite is the
    main test suite defined by `BOOST_TEST_MODULE`.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BOOST_AUTO_TEST_CASE(first_test_function)`声明一个无参数的测试用例（`first_test_function`）并将其自动注册为包含在测试树中，作为封装测试套件的一部分。在这个例子中，测试套件是由`BOOST_TEST_MODULE`定义的主测试套件。'
- en: '`BOOST_TEST(true);` performs a test assertion.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BOOST_TEST(true);`执行一个测试断言。'
- en: 'The output of executing this test module is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此测试模块的输出如下：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There’s more...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you don’t want the library to generate the `main()` function but want to
    write it yourself, then you need to define a couple more macros – `BOOST_TEST_NO_MAIN`
    and `BOOST_TEST_ALTERNATIVE_INIT_API` – before you include any of the library
    headers. Then, in the `main()` function that you supply, invoke the default test
    runner called `unit_test_main()` by providing the default initialization function
    called `init_unit_test()` as an argument, as shown in the following code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想库生成`main()`函数但想自己编写，那么在包含任何库头文件之前，你需要定义几个额外的宏 - `BOOST_TEST_NO_MAIN`和`BOOST_TEST_ALTERNATIVE_INIT_API`。然后，在你提供的`main()`函数中，通过提供默认的初始化函数`init_unit_test()`作为参数，调用默认的测试执行器`unit_test_main()`，如下代码片段所示：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is also possible to customize the initialization function of the test runner.
    In this case, you must remove the definition of the `BOOST_TEST_MODULE` macro
    and instead write an initialization function that takes no arguments and returns
    a `bool` value:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以自定义测试运行器的初始化函数。在这种情况下，必须删除 `BOOST_TEST_MODULE` 宏的定义，并编写一个不接受任何参数并返回 `bool`
    值的初始化函数：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is possible to customize the initialization function without writing the
    `main()` function yourself. In this case, the `BOOST_TEST_NO_MAIN` macro should
    not be defined and the initialization function should be called `init_unit_test()`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可以自定义初始化函数，而不必自己编写 `main()` 函数。在这种情况下，不应定义 `BOOST_TEST_NO_MAIN` 宏，并且初始化函数应命名为
    `init_unit_test()`。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing and invoking tests with Boost.Test*, to see how to create test suites
    and test cases using the single-header version of the Boost.Test library, as well
    as how to run tests'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Boost.Test 编写和调用测试*，以了解如何使用 Boost.Test 库的单头版本创建测试套件和测试用例，以及如何运行测试'
- en: Writing and invoking tests with Boost.Test
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Boost.Test 编写和调用测试
- en: The library provides both an automatic and manual way of registering test cases
    and test suites to be executed by the test runner. Automatic registration is the
    simplest way because it enables you to construct a test tree just by declaring
    test units. In this recipe, we will see how to create test suites and test cases
    using the single-header version of the library, as well as how to run tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 库提供了自动和手动两种方式来注册测试用例和测试套件，以便测试运行器执行。自动注册是最简单的方式，因为它允许你仅通过声明测试单元来构建测试树。在本食谱中，我们将了解如何使用库的单头版本创建测试套件和测试用例，以及如何运行测试。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To exemplify the creation of test suites and test cases, we will use the following
    class, which represents a three-dimensional point. This implementation contains
    methods for accessing the properties of a point, comparison operators, a stream
    output operator, and a method for modifying the position of a point:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明测试套件和测试用例的创建，我们将使用以下类，它代表一个三维点。此实现包含访问点属性的方法、比较运算符、流输出运算符以及修改点位置的方法：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before you go any further, notice that the test cases in this recipe contain
    erroneous tests on purpose so that they produce failures.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意，本食谱中的测试用例故意包含错误测试，以便它们产生失败。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following macros to create test units:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下宏来创建测试单元：
- en: 'To create a test suite, use `BOOST_AUTO_TEST_SUITE(name)` and `BOOST_AUTO_TEST_SUITE_END()`:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建测试套件，使用 `BOOST_AUTO_TEST_SUITE(name)` 和 `BOOST_AUTO_TEST_SUITE_END()`：
- en: '[PRE6]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To create a test case, use `BOOST_AUTO_TEST_CASE(name)`. Test cases are defined
    between `BOOST_AUTO_TEST_SUITE(name)` and `BOOST_AUTO_TEST_SUITE_END()`, as shown
    in the following code snippet:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建测试用例，使用 `BOOST_AUTO_TEST_CASE(name)`。测试用例定义在 `BOOST_AUTO_TEST_SUITE(name)`
    和 `BOOST_AUTO_TEST_SUITE_END()` 之间，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To create a nested test suite, define a test suite inside another test suite:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建嵌套测试套件，在另一个测试套件内部定义一个测试套件：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To add decorators to a test unit, add an additional parameter to the test unit’s
    macros. Decorators could include description, label, precondition, dependency,
    fixture, and so on. Refer to the following code snippet, which illustrates this:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向测试单元添加装饰器，向测试单元的宏添加一个额外的参数。装饰器可以包括描述、标签、先决条件、依赖项、固定装置等。请参考以下代码片段，它说明了这一点：
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To execute the tests, do the following (notice that the command line is Windows-specific,
    but it should be trivial to replace that with the one specific to Linux or macOS):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行测试，执行以下操作（请注意，命令行是针对 Windows 的，但应该很容易替换为针对 Linux 或 macOS 的命令行）：
- en: 'To execute the entire test tree, run the program (the test module) without
    any parameters:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行整个测试树，不带任何参数运行程序（测试模块）：
- en: '[PRE10]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To execute a single test suite, run the program with the argument `run_test`,
    specifying the path of the test suite:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行单个测试套件，使用参数 `run_test` 运行程序，指定测试套件的路径：
- en: '[PRE11]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To execute a single test case, run the program with the argument `run_test`,
    specifying the path of the test case:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行单个测试用例，使用参数 `run_test` 运行程序，指定测试用例的路径：
- en: '[PRE12]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To execute a collection of test suites and test cases defined under the same
    label, run the program with the argument `run_test`, specifying the label name
    prefixed with `@`:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行在相同标签下定义的多个测试套件和测试用例，使用参数 `run_test` 运行程序，指定以 `@` 为前缀的标签名称：
- en: '[PRE13]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A test tree is a hierarchy of test cases and test suites, which also includes
    the fixtures and additional dependencies. A test suite can contain one or more
    test cases and other nested test suites as well. Test suites are similar to namespaces
    in the sense that they can be stopped and restarted multiple times in the same
    file or in different files. Automatic registration of test suites is done with
    the macros `BOOST_AUTO_TEST_SUITE`, which requires a name, and `BOOST_AUTO_TEST_SUITE_END`.
    Automatic registration of test cases is done with `BOOST_AUTO_TEST_CASE`. Test
    units (whether they’re cases or suites) become members of the closest test suite.
    Test units defined at the file scope level become members of the master test suite
    - the implicit test suite created with the `BOOST_TEST_MODULE` declaration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 测试树是一系列测试用例和测试套件的层次结构，还包括了固定装置和额外的依赖项。测试套件可以包含一个或多个测试用例以及其他嵌套的测试套件。在相同文件或不同文件中，测试套件可以多次停止和重新启动，类似于命名空间。测试套件的自动注册使用宏`BOOST_AUTO_TEST_SUITE`，它需要一个名称，以及`BOOST_AUTO_TEST_SUITE_END`。测试用例的自动注册使用`BOOST_AUTO_TEST_CASE`。测试单元（无论是用例还是套件）成为最近测试套件的成员。在文件作用域级别定义的测试单元成为主测试套件的成员——由`BOOST_TEST_MODULE`声明创建的隐式测试套件。
- en: 'Both test suites and test cases can be decorated with a series of attributes
    that affect how test units will be processed during the execution of the test
    module. The currently supported decorators are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件和测试用例都可以用一系列属性装饰，这些属性会影响测试模块执行期间如何处理测试单元。目前支持的装饰器如下：
- en: '`depends_on`: This indicates a dependency between the current test unit and
    a designated test unit.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on`: 这表示当前测试单元与指定测试单元之间的依赖关系。'
- en: '`description`: This provides a semantic description of a test unit.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 这提供了测试单元的语义描述。'
- en: '`enabled` / `disabled`: These set the default run status of a test unit to
    either `true` or `false`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled` / `disabled`: 这些将测试单元的默认运行状态设置为`true`或`false`。'
- en: '`enable_if<bool>`: This sets the default run status of a test unit to either
    `true` or `false`, depending on the evaluation of a compile-time expression.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable_if<bool>`: 这根据编译时表达式的评估结果，将测试单元的默认运行状态设置为`true`或`false`。'
- en: '`expected_failures`: This indicates the expected failures for a test unit.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expected_failures`: 这表示测试单元的预期失败情况。'
- en: '`fixture`: This specifies a pair of functions (startup and cleanup) to be called
    before and after the execution of a test unit.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixture`: 这指定了一对函数（启动和清理），在执行测试单元之前和之后调用。'
- en: '`label`: With this, you can associate a test unit with a label. The same label
    can be used for multiple test units, and a test unit can have multiple labels.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`: 使用这个，你可以将测试单元与一个标签关联起来。相同的标签可以用于多个测试单元，并且一个测试单元可以有多个标签。'
- en: '`precondition`: This associates a predicate with a test unit, which is used
    at runtime to determine the run status of the test unit.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precondition`: 这将一个谓词与测试单元关联起来，在运行时用于确定测试单元的运行状态。'
- en: '`timeout`: Specifies a timeout for a unit test, in wall-clock time. If the
    test lasts longer than the specified timeout, the test fails.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`: 指定单元测试的超时时间，以墙钟时间为准。如果测试持续时间超过指定的超时时间，则测试失败。'
- en: '`tolerance`: This decorator specifies the default comparison tolerance for
    the floating-point type FTP in the decorated test unit.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tolerance`: 这个装饰器指定了装饰测试单元中FTP浮点类型的默认比较容差。'
- en: If the execution of a test case results in an unhandled exception, the framework
    will catch the exception and terminate the execution of the test case with a failure.
    However, the framework provides several macros to test whether a particular piece
    of code raises, or does not raise, exceptions. For more information, see the next
    recipe, *Asserting with Boost.Test*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试用例的执行导致未处理的异常，框架将捕获该异常并以失败状态终止测试用例的执行。然而，框架提供了几个宏来测试特定的代码是否引发或未引发异常。有关更多信息，请参阅下一道菜谱，*使用Boost.Test进行断言*。
- en: The test units that compose the module’s test tree can be executed entirely
    or partially. In both cases, to execute the test units, execute the (binary) program,
    which represents the test module. To execute only some of the test units, use
    the `--run_test` command-line option (or `--t` if you want to use a shorter name).
    This option allows you to filter the test units and specify either a path or a
    label. A path consists of a sequence of test suite and/or test case names, such
    as `test_construction` or `test_operations`/`test_methods`/`test_offset`. A label
    is a name defined with the `label` decorator and is prefixed with `@` for the
    `run_test` parameter. This parameter is repeatable, which means you can specify
    multiple filters on it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 组成模块测试树的测试单元可以完全或部分执行。在两种情况下，要执行测试单元，请执行（二进制）程序，该程序代表测试模块。要仅执行某些测试单元，请使用`--run_test`命令行选项（或`--t`如果您想使用更短的名字）。此选项允许您过滤测试单元并指定路径或标签。路径是一系列测试套件和/或测试用例名称的序列，例如`test_construction`或`test_operations`/`test_methods`/`test_offset`。标签是与`label`装饰器定义的名称，并在`run_test`参数前加`@`。此参数是可重复的，这意味着您可以在其上指定多个过滤器。
- en: See also
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Getting started with Boost.Test*, to learn how to install the Boost.Test framework
    and how to create a simple test project'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始使用Boost.Test*，了解如何安装Boost.Test框架以及如何创建一个简单的测试项目'
- en: '*Asserting with Boost.Test*, to explore the rich set of assertion macros from
    the Boost.Test library'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Boost.Test进行断言*，探索Boost.Test库中的丰富断言宏集'
- en: Asserting with Boost.Test
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost.Test进行断言
- en: A test case contains one or more tests. The Boost.Test library provides a series
    of APIs in the form of macros to write tests. In the previous recipe, you learned
    a bit about the `BOOST_TEST` macro, which is the most important and widely used
    macro in the library. In this recipe, we will discuss how the `BOOST_TEST` macro
    can be used in further detail.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例包含一个或多个测试。Boost.Test库提供了一系列以宏形式存在的API来编写测试。在前面的配方中，您已经了解了一些关于`BOOST_TEST`宏的内容，这是库中最重要且最广泛使用的宏。在本配方中，我们将更详细地讨论如何使用`BOOST_TEST`宏。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You should now be familiar with writing test suites and test cases, a topic
    we covered in the previous recipe.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该熟悉编写测试套件和测试用例，这是我们前面讨论的主题。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following list shows some of the most commonly used APIs for performing
    tests:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了执行测试的一些最常用API：
- en: '`BOOST_TEST`, in its plain form, is used for most tests:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_TEST`以其纯形式用于大多数测试：'
- en: '[PRE14]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`BOOST_TEST`, along with the `tolerance()` manipulator, is used to indicate
    the tolerance of floating-point comparisons:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_TEST`，与`tolerance()`操作符一起使用，用于指示浮点数比较的容差：'
- en: '[PRE15]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`BOOST_TEST`, along with the `per_element()` manipulator, is used to perform
    an element-wise comparison of containers (even of different types):'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_TEST`，与`per_element()`操作符一起使用，用于执行容器（即使是不同类型）的元素级比较：'
- en: '[PRE16]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`BOOST_TEST`, along with the ternary operator and compound statements using
    the logical `||` or `&&`, requires an extra set of parentheses:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_TEST`，与三元运算符和逻辑`||`或`&&`的复合语句一起使用时，需要额外的括号：'
- en: '[PRE17]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`BOOST_ERROR` is used to unconditionally fail a test and produce a message
    in the report. This is equivalent to `BOOST_TEST(false, message)`:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_ERROR`用于无条件失败测试并在报告中生成消息。这相当于`BOOST_TEST(false, message)`：'
- en: '[PRE18]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`BOOST_TEST_WARN` is used to produce a warning in the report in case a test
    is failing, without increasing the number of encountered errors and stopping the
    execution of the test case:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_TEST_WARN`用于在测试失败时在报告中生成警告，而不会增加遇到的错误数量并停止测试用例的执行：'
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`BOOST_TEST_REQUIRE` is used to ensure that test case pre-conditions are met;
    the execution of the test case is stopped otherwise:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_TEST_REQUIRE`用于确保测试用例的先决条件得到满足；否则，将停止测试用例的执行：'
- en: '[PRE20]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`BOOST_FAIL` is used to unconditionally stop the execution of the test case,
    increase the number of encountered errors, and produce a message in the report.
    This is equivalent to `BOOST_TEST_REQUIRE(false, message)`:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_FAIL`用于无条件停止测试用例的执行，增加遇到的错误数量，并在报告中生成消息。这相当于`BOOST_TEST_REQUIRE(false,
    message)`：'
- en: '[PRE21]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`BOOST_IS_DEFINED` is used to check whether a particular preprocessor symbol
    is defined at runtime. It is used together with `BOOST_TEST` to perform validation
    and logging:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_IS_DEFINED`用于检查在运行时是否定义了特定的预处理器符号。它与`BOOST_TEST`一起用于执行验证和记录：'
- en: '[PRE22]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The library defines a variety of macros and manipulators for performing test
    assertions. The most commonly used one is `BOOST_TEST`. This macro simply evaluates
    an expression; if it fails, it increases the error count but continues the execution
    of the test case. It has three variants actually:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该库定义了各种宏和操作符，用于执行测试断言。最常用的是 `BOOST_TEST`。此宏简单地评估一个表达式；如果失败，它会增加错误计数但继续执行测试用例。实际上它有三个变体：
- en: '`BOOST_TEST_CHECK` is the same as `BOOST_TEST` and is used to perform checks,
    as described in the previous section.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_TEST_CHECK` 与 `BOOST_TEST` 相同，用于执行检查，如前文所述。'
- en: '`BOOST_TEST_WARN` is used for assertions meant to provide information, without
    increasing the error count and stopping the execution of the test case.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_TEST_WARN` 用于旨在提供信息的断言，而不会增加错误计数并停止测试用例的执行。'
- en: '`BOOST_TEST_REQUIRE` is intended to ensure that pre-conditions that are required
    for test cases to continue execution are met. Upon failure, this macro increases
    the error count and stops the execution of the test case.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_TEST_REQUIRE` 的目的是确保测试用例继续执行所需的先决条件得到满足。如果失败，此宏会增加错误计数并停止测试用例的执行。'
- en: The general form of the test macro is `BOOST_TEST(statement)`. This macro provides
    rich and flexible reporting capabilities. By default, it shows not only the statement
    but also the value of the operands, to enable quick identification of the failure’s
    cause.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试宏的一般形式是 `BOOST_TEST(statement)`。此宏提供了丰富和灵活的报告功能。默认情况下，它不仅显示语句，还显示操作数的值，以便快速识别失败的原因。
- en: 'However, the user could provide an alternative failure description; in this
    scenario, the message is logged in the test report:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户可以提供替代的失败描述；在这种情况下，消息将记录在测试报告中：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This macro also allows you to control the comparison process with special support
    for the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏还允许您通过特殊支持来控制比较过程：
- en: The first is a floating-point comparison, where tolerance can be defined to
    test equality.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是浮点数比较，可以定义容差来测试相等性。
- en: 'Secondly, it supports a container’s comparison using several methods: default
    comparison (using the overloaded operator ==), per-element comparison, and lexicographic
    comparison (using the lexicographical order). Per-element comparison enables the
    comparison of different types of containers (such as vector and list) in the order
    given by the forward iterators of the container; it also takes into account the
    size of the container (meaning that it first tests the sizes and, only if they
    are equal, continues with the comparison of the elements).'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，它支持使用多种方法对容器进行比较：默认比较（使用重载的运算符 `==`）、逐元素比较和字典序比较（使用字典序）。逐元素比较允许按容器的前向迭代器顺序比较不同类型的容器（如
    vector 和 list），同时考虑容器的尺寸（这意味着它首先测试尺寸，只有当它们相等时，才会继续比较元素）。
- en: Lastly, it supports bitwise comparison of the operands. Upon failure, the framework
    reports the index of the bit where the comparison failed.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它支持操作数的位比较。如果失败，框架会报告比较失败的位索引。
- en: 'The `BOOST_TEST` macro does have some limitations. It cannot be used with compound
    statements that use a comma, because such statements would be intercepted and
    handled by the preprocessor or the ternary operator, and compound statements using
    the logical operators `||` and `&&`. The latter cases have a workaround: a second
    pair of parentheses, as in `BOOST_TEST((statement))`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_TEST` 宏确实有一些限制。它不能与使用逗号分隔的复合语句一起使用，因为此类语句会被预处理器或三元运算符拦截和处理，以及使用逻辑运算符
    `||` 和 `&&` 的复合语句。后者的解决方案是使用另一对括号，如 `BOOST_TEST((statement))`。'
- en: 'Several macros are available for testing whether a particular exception is
    raised during the evaluation of an expression. In the following list, `<level>`
    is either `CHECK`, `WARN`, or `REQUIRE`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个宏可用于测试在表达式评估过程中是否抛出了特定异常。在以下列表中，`<level>` 可以是 `CHECK`、`WARN` 或 `REQUIRE`：
- en: '`BOOST_<level>_NO_THROW(expr)` checks whether an exception is raised from the
    `expr` expression. Any exception raised during the evaluation of `expr` is caught
    by this assertion and is not propagated to the test body. If any exception occurs,
    the assertion fails.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_<level>_NO_THROW(expr)` 检查 `expr` 表达式是否抛出异常。在 `expr` 的评估过程中抛出的任何异常都会被此断言捕获，并且不会传播到测试主体。如果发生任何异常，断言将失败。'
- en: '`BOOST_<level>_THROW(expr, exception_type)` checks whether an exception of
    `exception_type` is raised from the `expr` expression. If the expression `expr`
    does not raise any exception, then the assertion fails. Exceptions of types other
    than `exception_type` are not caught by this assertion and can be propagated to
    the test body. Uncaught exceptions in a test case are caught by the execution
    monitor, but they result in failed test cases.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_<level>_THROW(expr, exception_type)` 检查是否从 `expr` 表达式引发了 `exception_type`
    类型的异常。如果表达式 `expr` 没有引发任何异常，则断言失败。除了 `exception_type` 类型之外的异常不会被此断言捕获，并且可以传播到测试主体。测试用例中的未捕获异常会被执行监视器捕获，但它们会导致测试用例失败。'
- en: '`BOOST_<level>_EXCEPTION(expr, exception_type, predicate)` checks whether an
    exception of `exception_type` is raised from the `expr` expression. If so, it
    passes the expression to the predicate for further examination. If no exception
    is raised or an exception of a type different than `exception_type` is raised,
    then the assertion behaves like `BOOST_<level>_THROW`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_<level>_EXCEPTION(expr, exception_type, predicate)` 检查是否从 `expr` 表达式引发了
    `exception_type` 类型的异常。如果是这样，它将表达式传递给谓词以进行进一步检查。如果没有引发异常或引发了不同于 `exception_type`
    类型的异常，则断言的行为类似于 `BOOST_<level>_THROW`。'
- en: This recipe discussed only the most common APIs for testing and their typical
    usage. However, the library provides many more APIs. For further reference, check
    the online documentation. For version 1.83, refer to [https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱仅讨论了测试中最常见的 API 及其典型用法。然而，库提供了许多其他 API。有关进一步参考，请查阅在线文档。对于版本 1.83，请参阅 [https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html)。
- en: See also
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing and invoking tests with Boost.Test*, to see how to create test suites
    and test cases using the single-header version of the Boost.Test library, as well
    as how to run tests'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Boost.Test 编写和调用测试*，以了解如何使用 Boost.Test 库的单头版本创建测试套件和测试用例，以及如何运行测试'
- en: Using fixtures in Boost.Test
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Boost.Test 中使用夹具
- en: The larger a test module is and the more similar the test cases are, the more
    likely it is to have test cases that require the same setup, cleanup, and maybe
    the same data. A component that contains these is called a **test fixture** or
    **test context**. Fixtures are important to establish a well-defined environment
    for running tests so that the results are repeatable. Examples can include copying
    a specific set of files to some location before executing the tests and deleting
    them after, or loading data from a particular data source.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模块越大，测试用例越相似，就越有可能有需要相同设置、清理和可能相同数据的测试用例。包含这些的组件称为**测试夹具**或**测试上下文**。夹具对于建立运行测试的良好定义的环境非常重要，以便结果可重复。示例可以包括在执行测试之前将一组特定文件复制到某个位置，并在测试之后删除它们，或者从特定的数据源加载数据。
- en: Boost.Test provides several ways to define test fixtures for a test case, test
    suite, or module (globally). In this recipe, we will look at how fixtures work.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Test 为测试用例、测试套件或模块（全局）提供了定义测试夹具的几种方法。在本菜谱中，我们将探讨夹具的工作原理。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The examples in this recipe use the following classes and functions for specifying
    test unit fixtures:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中的示例使用以下类和函数来指定测试单元夹具：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first two are classes whose constructors represent the setup function and
    the destructors represent the teardown function. At the end of the sample, there
    is a pair of functions, `fixture_setup()` and `fixture_cleanup()`, that represent
    functions for a test’s setup and cleanup.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个是类，其构造函数表示设置函数，析构函数表示清理函数。在示例末尾有一对函数，`fixture_setup()` 和 `fixture_cleanup()`，它们表示测试的设置和清理函数。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following methods to define test fixtures for one or multiple test
    units:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法定义一个或多个测试单元的测试夹具：
- en: 'To define a fixture for a particular test case, use the `BOOST_FIXTURE_TEST_CASE`
    macro:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要为特定的测试用例定义夹具，请使用 `BOOST_FIXTURE_TEST_CASE` 宏：
- en: '[PRE25]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To define a fixture for all the test cases in a test suite, use `BOOST_FIXTURE_TEST_SUITE`:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要为测试套件中的所有测试用例定义一个夹具，请使用 `BOOST_FIXTURE_TEST_SUITE`:'
- en: '[PRE26]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To define a fixture for all the test units in a test suite, except for one
    or several test units, use `BOOST_FIXTURE_TEST_SUITE`. You can overwrite it to
    a particular test unit with `BOOST_FIXTURE_TEST_CASE` for a test case and `BOOST_FIXTURE_TEST_SUITE`
    for a nested test suite:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要为测试套件中的所有测试单元定义固定装置（除了一个或多个测试单元），请使用`BOOST_FIXTURE_TEST_SUITE`。您可以使用`BOOST_FIXTURE_TEST_CASE`覆盖特定测试用例，对于嵌套测试套件使用`BOOST_FIXTURE_TEST_SUITE`：
- en: '[PRE27]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To define more than a single fixture for a test case or test suite, use `boost::unit_test::fixture`
    with the `BOOST_AUTO_TEST_SUITE` and `BOOST_AUTO_TEST_CASE` macros:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要为测试用例或测试套件定义多个固定装置，请使用带有`BOOST_AUTO_TEST_SUITE`和`BOOST_AUTO_TEST_CASE`宏的`boost::unit_test::fixture`：
- en: '[PRE28]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To use free functions as setup and teardown operations in the case of a fixture,
    use `boost::unit_test::fixture`:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在固定装置的情况下，要使用自由函数作为设置和拆卸操作，请使用`boost::unit_test::fixture`：
- en: '[PRE29]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To define a fixture for the module, use `BOOST_GLOBAL_FIXTURE`:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要为模块定义固定装置，请使用`BOOST_GLOBAL_FIXTURE`：
- en: '[PRE30]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The library supports a couple of fixture models:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该库支持几种固定装置模型：
- en: A **class model**, where the constructor acts as the setup function and the
    destructor as the cleanup function. An extended model allows the constructor to
    have one parameter. In the preceding example, `standard_fixture` implemented the
    first model and `extended_fixture` implemented the second model.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类模型**，其中构造函数充当设置函数，析构函数充当清理函数。扩展模型允许构造函数有一个参数。在前面的例子中，`standard_fixture`实现了第一种模型，而`extended_fixture`实现了第二种模型。'
- en: 'A **pair of free functions**: one that defines the setup and the other, which
    is optional, that implements the cleanup code. In the preceding example, we came
    across these when discussing `fixture_setup()` and `fixture_cleanup()`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对**自由函数**：一个定义设置，另一个是可选的，实现清理代码。在前面的例子中，我们在讨论`fixture_setup()`和`fixture_cleanup()`时遇到了这些。
- en: Fixtures implemented as classes can also have data members, and these members
    are made available to the test unit. If a fixture is defined for a test suite,
    it is available implicitly to all the test units that are grouped under this test
    suite. However, it is possible that test units contained in such a test suite
    could redefine the fixture. In this case, the fixture defined in the closest scope
    is the one available to the test unit.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将作为类实现的固定装置也可以有数据成员，并且这些成员对测试单元可用。如果为测试套件定义了固定装置，则它对该测试套件下所有分组测试单元隐式可用。然而，可能存在这种情况，即包含在这样一个测试套件中的测试单元可以重新定义固定装置。在这种情况下，定义在最近作用域中的固定装置是对测试单元可用的。
- en: It is possible to define multiple fixtures for a test unit. However, this is
    done with the `boost::unit_test::fixture()` decorator, not with macros. The test
    suite and test case are defined, in this case, with the `BOOST_TEST_SUITE`/`BOOST_AUTO_TEST_SUITE`
    and `BOOST_TEST_CASE`/`BOOST_AUTO_TEST_CASE` macros. Multiple `fixture()` decorators
    can be composed together with `operator *`, as seen in the previous section. The
    purpose of this decorator is to define a setup and a teardown function to be called
    before and after the execution of the test unit. It comes in several forms, either
    with a pair of functions or with a class where the constructor and destructor
    play the role of the setup/teardown functions. A drawback, or perhaps misleading
    part, of using the fixture decorator with a class that contains member data is
    that these members will not be available for the test units.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为测试单元定义多个固定装置。然而，这是通过`boost::unit_test::fixture()`装饰器完成的，而不是通过宏。在这种情况下，测试套件和测试用例是通过`BOOST_TEST_SUITE`/`BOOST_AUTO_TEST_SUITE`和`BOOST_TEST_CASE`/`BOOST_AUTO_TEST_CASE`宏定义的。多个`fixture()`装饰器可以通过`operator
    *`组合在一起，如前所述。此装饰器的目的是定义在测试单元执行前后要调用的设置和拆卸函数。它有几种形式，可以是成对的函数，也可以是类，其中构造函数和析构函数充当设置/拆卸函数。使用包含成员数据的类作为固定装置装饰器的缺点或可能是误导性的一部分是，这些成员将不可用于测试单元。
- en: A new fixture object is constructed for each test case when it is executed,
    and the object is destroyed at the end of the test case.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每当执行测试用例时，都会为每个测试用例构造一个新的固定装置对象，并在测试用例结束时销毁该对象。
- en: The fixture state is not shared among different test cases. Therefore, the constructor
    and destructor are called once for each test case. You must make sure these special
    functions do not contain code that is supposed to be executed only once per module.
    If this is the case, you should set a global fixture for the entire module.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 固定状态不会在不同测试用例之间共享。因此，构造函数和析构函数会为每个测试用例调用一次。你必须确保这些特殊函数不包含仅应在每个模块中执行一次的代码。如果是这种情况，你应该为整个模块设置一个全局固定点。
- en: 'A global fixture uses the generic test class model (the model with the default
    constructor); you can define any number of global fixtures (allowing you to organize
    setup and cleanup by category, if necessary). Global fixtures are defined with
    the `BOOST_GLOBAL_FIXTURE` macro, and they have to be defined at the test file
    scope (not inside any test unit). Their purpose is to define setup and teardown
    functions, represented by the constructor and destructor of a class. If the class
    also defines other members, such as data, these are not available in the test
    units:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 全局固定点使用通用测试类模型（具有默认构造函数的模型）；你可以定义任意数量的全局固定点（如果需要，允许你按类别组织设置和清理）。全局固定点使用 `BOOST_GLOBAL_FIXTURE`
    宏定义，并且必须在测试文件作用域内定义（不在任何测试单元内部）。它们的作用是定义设置和清理函数，由类的构造函数和析构函数表示。如果类还定义了其他成员，例如数据，这些成员在测试单元中不可用：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Writing and invoking tests with Boost.Test*, to see how to create test suites
    and test cases using the single-header version of the Boost.Test library, as well
    as how to run tests'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Boost.Test编写和调用测试*，了解如何使用Boost.Test库的单头版本创建测试套件和测试用例，以及如何运行测试'
- en: Controlling output with Boost.Test
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost.Test控制输出
- en: 'The framework provides us with the ability to customize what is shown in the
    test log and test report and then format the results. Currently, there are two
    that are supported: a **human-readable format** (or **HRF**) and XML (also with
    a JUNIT format for the test log). However, it is possible to create and add your
    own format.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 框架为我们提供了自定义测试日志和测试报告中显示内容的能力，然后格式化结果。目前，支持两种格式：一种是人可读格式（或HRF）和XML（测试日志还有JUNIT格式）。然而，你可以创建并添加自己的格式。
- en: A human-readable format is any form of encoding data that can be naturally read
    by humans. Text, whether encoded as ASCII or Unicode, is used for this purpose.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 人可读格式是指任何可以由人类自然读取的数据编码形式。用于此目的的文本，无论是以ASCII还是Unicode编码，都用于此目的。
- en: The configuration of what is shown in the output can be done both at runtime,
    through command-line switches, and at compile time, through various APIs. During
    the execution of the tests, the framework collects all the events in a log. At
    the end, it produces a report that represents a summary of the execution with
    different levels of detail. In the case of a failure, the report contains detailed
    information about the location and the cause, including actual and expected values.
    This helps developers quickly identify the error. In this recipe, we will see
    how to control what is written in the log and the report and in which format;
    we do this using the command-line options at runtime.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中显示的配置可以在运行时通过命令行开关进行，也可以在编译时通过各种 API 进行。在测试执行期间，框架会收集日志中的所有事件。最后，它生成一个报告，该报告以不同级别的详细程度表示执行摘要。在失败的情况下，报告包含有关位置和原因的详细信息，包括实际值和预期值。这有助于开发者快速识别错误。在本菜谱中，我们将了解如何控制日志和报告中写入的内容以及格式；我们使用运行时的命令行选项来完成此操作。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the examples presented in this recipe, we will use the following test module:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中展示的示例中，我们将使用以下测试模块：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The next section presents how to control the test log and the test report’s
    output through command-line options.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将展示如何通过命令行选项控制测试日志和测试报告的输出。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To control the test log’s output, do the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制测试日志的输出，请执行以下操作：
- en: Use either the `--log_format=<format>` or `-f <format>` command-line option
    to specify the log format. The possible formats are `HRF` (the default value),
    `XML`, and `JUNIT`.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `--log_format=<format>` 或 `-f <format>` 命令行选项来指定日志格式。可能的格式有 `HRF`（默认值）、`XML`
    和 `JUNIT`。
- en: Use either the `--log_level=<level>` or `-l <level>` command-line option to
    specify the log level. The possible log levels include `error` (default for HRF
    and XML), `warning`, `all`, and `success` (the default for JUNIT).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `--log_level=<level>` 或 `-l <level>` 命令行选项来指定日志级别。可能的日志级别包括 `error`（HRF 和
    XML 的默认值）、`warning`、`all` 和 `success`（JUNIT 的默认值）。
- en: Use either the `--log_sink=<stream or file name>` or `-k <stream or file name>`
    command-line option to specify the location where the framework should write the
    test log. The possible options are `stdout` (default for HRF and XML), `stderr`,
    or an arbitrary filename (default for JUNIT).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--log_sink=<stream or file name>`或`-k <stream or file name>`命令行选项来指定框架应写入测试日志的位置。可能的选项是`stdout`（HRF和XML的默认值）、`stderr`或任意文件名（JUNIT的默认值）。
- en: 'To control the test report’s output, do the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制测试报告的输出，请执行以下操作：
- en: Use either the `--report_format=<format>` or `-m <format>` command-line option
    to specify the report format. The possible formats are `HRF` (the default value)
    and `XML`.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--report_format=<format>`或`-m <format>`命令行选项来指定报告格式。可能的格式是`HRF`（默认值）和`XML`。
- en: Use either the `--report_level=<format>` or `-r <format>` command-line option
    to specify the report level. The possible formats are `confirm` (the default value),
    `no` (for no report), `short`, and `detailed`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--report_level=<format>`或`-r <format>`命令行选项来指定报告级别。可能的格式是`confirm`（默认值）、`no`（无报告）、`short`和`detailed`。
- en: Use either the `--report_sink=<stream or file name>` or `-e <stream or file
    name>` command-line option to specify the location where the framework should
    write the report log. The possible options are `stderr` (the default value), `stdout`,
    or an arbitrary filename.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--report_sink=<stream or file name>`或`-e <stream or file name>`命令行选项来指定框架应写入报告日志的位置。可能的选项是`stderr`（默认值）、`stdout`或任意文件名。
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you run the test module from a console/terminal, you see both the test
    log and test report, with the test report following the test log. For the test
    module shown earlier, the default output is as follows. The first three lines
    represent the test log, while the last line represents the test report:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从控制台/终端运行测试模块时，您将看到测试日志和测试报告，测试报告紧随测试日志之后。对于前面显示的测试模块，默认输出如下。前三条线代表测试日志，而最后一条线代表测试报告：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The content of both the test log and test report can be made available in several
    formats. The default is HRF; however, the framework also supports XML, and for
    the test log, the JUNIT format. This is a format intended for automated tools,
    such as continuous build or integration tools. Apart from these options, you can
    implement your own format for the test log by implementing your own class derived
    from `boost::unit_test::unit_test_log_formatter`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 测试日志和测试报告的内容可以以多种格式提供。默认是HRF；然而，框架也支持XML，对于测试日志，支持JUNIT格式。这是一个为自动化工具设计的格式，例如持续构建或集成工具。除了这些选项之外，您可以通过实现自己的从`boost::unit_test::unit_test_log_formatter`派生的类来自定义测试日志的格式。
- en: 'The following example shows how to format the test log (the first example)
    and the test report (the second example) using XML (each highlighted in bold):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用XML格式化测试日志（第一个示例）和测试报告（第二个示例）（每个都加粗）：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The log or report level represents the verbosity of the output. The possible
    values of the verbosity level of a log are shown in the following table, ordered
    from the lowest to the highest level. A higher level in the table includes all
    the messages of the levels above it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 日志或报告级别表示输出的详细程度。以下表格显示了日志详细程度的可能值，按从低到高的顺序排列。表中的较高级别包括所有高于它的级别的消息：
- en: '| **Level** | **Messages that are reported** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **报告的消息**|'
- en: '| `nothing` | Nothing is logged. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `nothing` | 没有日志记录。|'
- en: '| `fatal_error` | System or user fatal errors and all the messages describing
    failed assertions at the `REQUIRE` level (such as `BOOST_TEST_REQUIRE` and `BOOST_REQUIRE_`).
    |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `fatal_error` | 系统或用户致命错误以及所有在`REQUIRE`级别描述失败的断言的消息（例如`BOOST_TEST_REQUIRE`和`BOOST_REQUIRE_`）。|'
- en: '| `system_error` | System non-fatal errors. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `system_error` | 系统非致命错误。|'
- en: '| `cpp_exception` | Uncaught C++ exceptions. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `cpp_exception` | 未捕获的C++异常。|'
- en: '| `error` | Failed assertion at the `CHECK` level (`BOOST_TEST` and `BOOST_CHECK_`).
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `error` | `CHECK`级别失败的断言（`BOOST_TEST`和`BOOST_CHECK_`）。|'
- en: '| `warning` | Failed assertion at the `WARN` level (`BOOST_TEST_WARN` and `BOOST_WARN_`).
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `warning` | `WARN`级别失败的断言（`BOOST_TEST_WARN`和`BOOST_WARN_`）。|'
- en: '| `message` | Messages generated by `BOOST_TEST_MESSAGE`. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `message` | 由`BOOST_TEST_MESSAGE`生成的消息。|'
- en: '| `test_suite` | Notification at the start and finish states of each test unit.
    |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `test_suite` | 每个测试单元的开始和结束状态的通知。|'
- en: '| `all` / `success` | All the messages, including passed assertions. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `all` / `success` | 所有消息，包括通过断言。|'
- en: 'Table 11.2: Possible values for the verbosity level of logs'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2：日志详细程度的可能值
- en: 'The available formats of the test report are described in the following table:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 测试报告的可用格式在以下表格中描述：
- en: '| **Level** | **Description** |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **描述** |'
- en: '| `no` | No report is produced. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `no` | 不生成报告。|'
- en: '| `confirm` | **Passing test**:*** No errors detected.**Skipped test**:***
    The <name> test suite was skipped; see the standard output for details.**Aborted
    test**:*** The <name> test suite was aborted; see the standard output for details.**Failed
    test without failed assertions**:*** Errors were detected in the <name> test suite;
    see the standard output for details.**Failed test**:*** N failures are detected
    in the <name> test suite.**Failed test with some failures expected**:*** N failures
    are detected (M failures are expected) in the <name> test suite. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `confirm` | **通过测试**：*** 未检测到错误。**跳过测试**：*** `<name>` 测试套件被跳过；请参阅标准输出以获取详细信息。**中止测试**：***
    `<name>` 测试套件被中止；请参阅标准输出以获取详细信息。**无失败断言的失败测试**：*** 在 `<name>` 测试套件中检测到错误；请参阅标准输出以获取详细信息。**失败测试**：***
    在 `<name>` 测试套件中检测到 N 个失败。**预期失败的失败测试**：*** 在 `<name>` 测试套件中检测到 N 个失败（预期 M 个失败）|'
- en: '| `detailed` | Results are reported in a hierarchical fashion (each test unit
    is reported as part of the parent test unit), but only relevant information appears.
    Test cases that do not have failing assertions do not produce entries in the report.The
    test case/suite <name> has passed/was skipped/was aborted/has failed with:N assertions
    out of M passedN assertions out of M failedN warnings out of M failedX failures
    expected |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `detailed` | 结果以分层方式报告（每个测试单元作为父测试单元的一部分进行报告），但只显示相关信息。没有失败断言的测试用例不会在报告中产生条目。测试用例/套件
    `<name>` 已通过/被跳过/被中止/失败，有 N 个断言中的 M 个通过/N 个断言中的 M 个失败/N 个警告中的 M 个失败/X 个预期的失败 |'
- en: '| `short` | Similar to `detailed`, but this reports information only to the
    master test suite. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 与 `detailed` 类似，但只向主测试套件报告信息。|'
- en: 'Table 11.3: Available formats for a test report'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.3：测试报告的可用格式
- en: The standard output stream (`stdout`) is the default location where the test
    log is written, and the standard error stream (`stderr`) is the default location
    of the test report. However, both the test log and test report can be redirected
    to another stream or file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输出流 (`stdout`) 是测试日志的默认写入位置，标准错误流 (`stderr`) 是测试报告的默认位置。然而，测试日志和测试报告都可以重定向到另一个流或文件。
- en: In addition to these options, it is possible to specify a separate file for
    reporting memory leaks using the `--report_memory_leaks_to=<file name>` command-line
    option. If this option is not present and memory leaks are detected, they are
    reported to the standard error stream.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些选项之外，还可以使用 `--report_memory_leaks_to=<文件名>` 命令行选项指定一个单独的文件来报告内存泄漏。如果此选项不存在且检测到内存泄漏，它们将被报告到标准错误流。
- en: There’s more...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: In addition to the options discussed in this recipe, the framework provides
    additional compile-time APIs for controlling the output. For a comprehensive description
    of these APIs, as well as the features described in this recipe, check the framework
    documentation at [https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本配方中讨论的选项之外，框架还提供了额外的编译时 API 来控制输出。有关这些 API 的全面描述以及本配方中描述的功能，请查看框架文档[https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html](https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html)。
- en: See also
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing and invoking tests with Boost.Test*, to see how to create test suites
    and test cases using the single-header version of the Boost.Test library, as well
    as how to run tests'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Boost.Test 编写和调用测试*，以了解如何使用 Boost.Test 库的单头版本创建测试套件和测试用例，以及如何运行测试'
- en: '*Asserting with Boost.Test*, to explore the rich set of assertion macros from
    the Boost.Test library'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Boost.Test 进行断言*，以探索 Boost.Test 库中丰富的断言宏集'
- en: Getting started with Google Test
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Google Test
- en: '**Google Test** is one of the most widely used testing frameworks for C++.
    The **Chromium** projects and the **LLVM** compiler are among the projects that
    are using it for unit testing. Google Test enables developers to write unit tests
    on multiple platforms using multiple compilers. Google Test is a portable, lightweight
    framework that has a simple yet comprehensive API for writing tests using asserts;
    here, tests are grouped into test suites and test suites into test programs.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Test** 是 C++ 中最广泛使用的测试框架之一。**Chromium** 项目和 **LLVM** 编译器是使用它进行单元测试的项目之一。Google
    Test 允许开发者使用多个编译器在多个平台上编写单元测试。Google Test 是一个便携、轻量级的框架，它提供了一个简单而全面的 API，用于使用断言编写测试；在这里，测试被分组为测试套件，测试套件被分组为测试程序。'
- en: The framework provides useful features, such as repeating a test a number of
    times and breaking a test to invoke the debugger at the first failure. Its assertions
    work regardless of whether exceptions are enabled or not. The next recipe will
    cover the most important features of the framework. This recipe will show you
    how to install the framework and set up your first testing project.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 框架提供了有用的功能，例如重复执行测试多次，并在第一次失败时中断测试以调用调试器。其断言在启用或禁用异常的情况下都能正常工作。下一道菜将涵盖框架的最重要功能。这道菜将向您展示如何安装框架并设置您的第一个测试项目。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The Google Test framework, just like Boost.Test, has a macro-based API. Although
    you only need to use the supplied macros for writing tests, a good understanding
    of macros is recommended in order to use the framework well.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 框架，就像 Boost.Test 一样，有一个基于宏的 API。尽管您只需要使用提供的宏来编写测试，但为了更好地使用框架，建议您了解宏。
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to set up your environment to use Google Test, do the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置您的环境以使用 Google Test，请执行以下操作：
- en: Clone or download the Git repository from [https://github.com/google/googletest](https://github.com/google/googletest).
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/google/googletest](https://github.com/google/googletest)
    克隆或下载 Git 仓库。
- en: If you selected to download it, once you’ve done so, unzip the content of the
    archive.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您选择下载，下载完成后，请解压存档内容。
- en: Build the framework using the provided build scripts.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的构建脚本来构建框架。
- en: 'To create your first test program using Google Test, do the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Google Test 创建您的第一个测试程序，请执行以下操作：
- en: Create a new empty C++ project.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空 C++ 项目。
- en: Do the necessary setup specific to the development environment you are using
    to make the framework’s headers folder (called `include`) available to the project
    for including header files.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您使用的开发环境进行必要的设置，以便将框架的头文件目录（称为 `include`）提供给项目以便包含头文件。
- en: Link the project to the `gtest` shared library.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目链接到 `gtest` 共享库。
- en: 'Add a new source file to the project with the following content:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个包含以下内容的源文件：
- en: '[PRE35]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Build and run the project.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目。
- en: How it works...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Google Test framework provides a simple and easy-to-use set of macros for
    creating tests and writing assertions. The structure of the test is also simplified
    compared to other testing frameworks, such as Boost.Test. Tests are grouped into
    test suites and test suites into test programs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 框架提供了一套简单易用的宏，用于创建测试和编写断言。与 Boost.Test 等其他测试框架相比，测试的结构也得到了简化。测试被分组为测试套件，测试套件被分组为测试程序。
- en: It is important to mention several aspects related to terminology. Traditionally,
    Google Test did not use the term **test suite**. A **test case** in Google Test
    was basically a test suite and equivalent to the test suites in Boost.Test. On
    the other hand, a **test function** was equivalent to a test case. Because this
    has led to confusion, Google Test has adhered to the common terminology, used
    by the **International Software Testing Qualifications Board** (**ISTQB**), of
    test cases and test suites and has started to replace this throughout its code
    and documentation. In this book, we will use these terms.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 提及与术语相关的一些方面是很重要的。传统上，Google Test 并未使用 **测试套件** 这一术语。在 Google Test 中，**测试用例**基本上是一个测试套件，与
    Boost.Test 中的测试套件相当。另一方面，**测试函数**相当于一个测试用例。由于这导致了混淆，Google Test 已经遵循了由 **国际软件测试资格认证委员会**（**ISTQB**）使用的通用术语，即测试用例和测试套件，并开始在其代码和文档中替换这些术语。在这本书中，我们将使用这些术语。
- en: The framework provides a rich set of assertions, both fatal and non-fatal, great
    support for exception handling, and the ability to customize the way tests are
    executed and how the output should be generated. However, unlike with the Boost.Test
    library, the test suites in Google Test cannot contain other test suites, but
    only test functions.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架提供了一套丰富的断言，包括致命和非致命断言，对异常处理提供了极大的支持，并且能够自定义测试执行方式和输出生成方式。然而，与Boost.Test库不同，Google
    Test中的测试套件不能包含其他测试套件，只能包含测试函数。
- en: 'Documentation for the framework is available on the project’s page at GitHub.
    For this edition of this book, I used Google Test framework version 1.14, but
    the code presented here works with previous versions of the framework and is expected
    to also work with future versions of the framework. The sample code shown in the
    *How to do it…* section contains the following parts:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的文档可在GitHub项目的页面上找到。对于本书的这一版，我使用了Google Test框架版本1.14，但这里展示的代码与框架的先前版本兼容，并预期与框架的未来版本也兼容。*如何做…*
    部分中展示的示例代码包含以下部分：
- en: '`#include <gtest/gtest.h>` includes the main header of the framework.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#include <gtest/gtest.h>` 包含框架的主要头文件。'
- en: '`TEST(FirstTestSuite, FirstTest)` declares a test called `FirstTest` as part
    of a test suite called `FirstTestSuite`. These names must be valid C++ identifiers
    but are not allowed to contain underscores. The actual name of a test function
    is composed through concatenation with an underscore from the name of the test
    suite and the test name. For our example, the name is `FirstTestSuite_FirstTest`.
    Tests from different test suites may have the same individual name. A test function
    has no arguments and returns `void`. Multiple tests can be grouped with the same
    test suite.'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TEST(FirstTestSuite, FirstTest)` 声明一个名为 `FirstTest` 的测试，作为名为 `FirstTestSuite`
    的测试套件的一部分。这些名称必须是有效的C++标识符，但不允许包含下划线。测试函数的实际名称是通过将测试套件的名称和测试名称连接起来，并在其中添加一个下划线来组成的。在我们的例子中，名称是
    `FirstTestSuite_FirstTest`。来自不同测试套件的测试可能具有相同的单个名称。测试函数没有参数，并返回 `void`。可以将多个测试组合到同一个测试套件中。'
- en: '`ASSERT_TRUE(a > 0);` is an assertion macro that yields a fatal error and returns
    from the current function in case the condition evaluates to `false`. The framework
    defines many more assertion macros, which we will see in the *Asserting with Google
    Test* recipe.'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ASSERT_TRUE(a > 0);` 是一个断言宏，当条件评估为 `false` 时会产生致命错误，并从当前函数返回。框架定义了许多其他断言宏，我们将在
    *使用Google Test进行断言* 菜单中看到。'
- en: '`testing::InitGoogleTest(&argc, argv);` initializes the framework and must
    be called before `RUN_ALL_TESTS()`.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`testing::InitGoogleTest(&argc, argv);` 初始化框架，必须在调用 `RUN_ALL_TESTS()` 之前执行。'
- en: '`return RUN_ALL_TESTS();` automatically detects and calls all the tests defined
    with either the `TEST()` or `TEST_F()` macro. The return value returned from the
    macro is used as the return value of the `main()` function. This is important
    because the automated testing service determines the result of a test program
    according to the value returned from the `main()` function, not the output printed
    to the `stdout` or `stderr` streams. The `RUN_ALL_TESTS()` macro must be called
    only once; calling it multiple times is not supported because it conflicts with
    some advanced features of the framework.'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`return RUN_ALL_TESTS();` 自动检测并调用使用 `TEST()` 或 `TEST_F()` 宏定义的所有测试。宏返回的值用作
    `main()` 函数的返回值。这很重要，因为自动化测试服务根据 `main()` 函数返回的值来确定测试程序的结果，而不是打印到 `stdout` 或 `stderr`
    流的输出。`RUN_ALL_TESTS()` 宏只能调用一次；多次调用不支持，因为它与框架的一些高级功能冲突。'
- en: 'Executing this test program will provide the following result:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此测试程序将提供以下结果：
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For many test programs, the content of the `main()` function is identical to
    the one shown in this recipe, in the example from the *How to do it...* section.
    To avoid writing such a `main()` function, the framework provides a basic implementation
    that you can use by linking your program with the `gtest_main` shared library.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多测试程序，`main()` 函数的内容与 *如何做…* 部分中显示的示例相同。为了避免编写这样的 `main()` 函数，框架提供了一个基本实现，您可以通过将程序与
    `gtest_main` 共享库链接来使用它。
- en: There’s more...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The Google Test framework can also be used with other testing frameworks. You
    can write tests using another testing framework, such as Boost.Test or CppUnit,
    and use the Google Test assertion macros. To do so, set the `throw_on_failure`
    flag, either from the code or command line, with the `--gtest_throw_on_failure`
    argument. Alternatively, use the `GTEST_THROW_ON_FAILURE` environment variable
    and initialize the framework, as shown in the following code snippet:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 框架也可以与其他测试框架一起使用。你可以使用其他测试框架，如 Boost.Test 或 CppUnit，来编写测试，并使用 Google
    Test 断言宏。为此，使用 `--gtest_throw_on_failure` 参数从代码或命令行设置 `throw_on_failure` 标志。或者，使用
    `GTEST_THROW_ON_FAILURE` 环境变量并初始化框架，如下面的代码片段所示：
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When you enable the `throw_on_failure` option, assertions that fail will print
    an error message and throw an exception, which will be caught by the host testing
    framework and treated as a failure. If exceptions are not enabled, then a failed
    Google Test assertion will tell your program to exit with a non-zero code, which
    again will be treated as a failure by the host testing framework.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启用 `throw_on_failure` 选项时，失败的断言将打印错误消息并抛出异常，该异常将被宿主测试框架捕获并视为失败。如果未启用异常，则失败的
    Google Test 断言将告诉你的程序以非零代码退出，这同样会被宿主测试框架视为失败。
- en: See also
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing and invoking tests with Google Test*, to see how to create tests and
    test suites using the Google Test library, as well as how to run tests'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Google Test 编写和调用测试*，以了解如何使用 Google Test 库创建测试和测试套件，以及如何运行测试'
- en: '*Asserting with Google Test*, to explore the various assertion macros from
    the Google Test library'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Google Test 进行断言*，以探索 Google Test 库中的各种断言宏'
- en: Writing and invoking tests with Google Test
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Test 编写和调用测试
- en: In the previous recipe, we had a glimpse of what it takes to write simple tests
    with the Google Test framework. Multiple tests can be grouped into a test suite
    and one or more test suites grouped into a test program. In this recipe, we will
    see how to create and run tests.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们瞥见了使用 Google Test 框架编写简单测试需要什么。多个测试可以组合成一个测试套件，一个或多个测试套件可以组合成一个测试程序。在这个菜谱中，我们将看到如何创建和运行测试。
- en: Getting ready
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For the sample code in this recipe, we’ll use the `point3d` class we discussed
    in the *Writing and invoking tests with Boost.Test* recipe.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱中的示例代码，我们将使用在 *使用 Boost.Test 编写和调用测试* 菜谱中讨论的 `point3d` 类。
- en: How to do it...
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Use the following macros to create tests:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下宏来创建测试：
- en: '`TEST(TestSuiteName, TestName)` defines a test called `TestName` as part of
    a test suite called `TestSuiteName`:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEST(TestSuiteName, TestName)` 定义了一个名为 `TestName` 的测试，作为名为 `TestSuiteName`
    的测试套件的一部分：'
- en: '[PRE38]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`TEST_F(TestSuiteWithFixture, TestName)` defines a test called `TestName` as
    part of a test suite, using a fixture called `TestSuiteWithFixture`. You’ll find
    details about how this works in the *Using test fixtures with Google Test* recipe.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEST_F(TestSuiteWithFixture, TestName)` 定义了一个名为 `TestName` 的测试，作为使用 `TestSuiteWithFixture`
    固定装置的测试套件的一部分。你可以在 *使用 Google Test 的测试固定装置* 菜谱中找到关于它是如何工作的详细信息。'
- en: 'To execute the tests, do the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行测试，请执行以下操作：
- en: Use the `RUN_ALL_TESTS()` macro to run all the tests defined in the test program.
    This must be called only once from the `main()` function after the framework has
    been initialized.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `RUN_ALL_TESTS()` 宏来运行测试程序中定义的所有测试。这必须在框架初始化后从 `main()` 函数中只调用一次。
- en: Use the `--gtest_filter=<filter>` command-line option to filter the tests to
    run.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `--gtest_filter=<filter>` 命令行选项来过滤要运行的测试。
- en: Use the `--gtest_repeat=<count>` command-line option to repeat the selected
    tests the specified number of times.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `--gtest_repeat=<count>` 命令行选项来重复执行所选测试指定的次数。
- en: Use the `--gtest_break_on_failure` command-line option to attach the debugger
    to debug the test program when the first test fails.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `--gtest_break_on_failure` 命令行选项，当第一个测试失败时，将调试器附加到测试程序进行调试。
- en: How it works...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are several macros available for defining tests (as part of a test case).
    The most common ones are `TEST` and `TEST_F`. The latter is used with fixtures,
    which will be discussed in detail in the *Using test fixtures with Google Test*
    recipe. Other macros for defining tests are `TYPED_TEST` for writing typed tests
    and `TYPED_TEST_P` for writing type-parameterized tests. However, these are more
    advanced topics and are beyond the scope of this book. The `TEST` and `TEST_F`
    macros take two arguments: the first is the name of the test suite and the second
    is the name of the test. These two arguments form the full name of a test, and
    they must be valid C++ identifiers; they should not contain underscores, though.
    Different test suites can contain tests with the same name (because the full name
    is still unique). Both macros automatically register the tests with the framework;
    therefore, no explicit input is required from the user to do this.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于定义测试的宏有几个（作为测试用例的一部分）。最常见的是 `TEST` 和 `TEST_F`。后者与 fixtures 一起使用，将在 *使用 Google
    Test 的测试 fixtures* 菜单中详细讨论。用于定义测试的其他宏包括 `TYPED_TEST` 用于编写类型测试和 `TYPED_TEST_P`
    用于编写类型参数化测试。然而，这些是更高级的主题，超出了本书的范围。`TEST` 和 `TEST_F` 宏接受两个参数：第一个是测试套件名称，第二个是测试名称。这两个参数形成测试的完整名称，并且它们必须是有效的
    C++ 标识符；它们不应该包含下划线。不同的测试套件可以包含具有相同名称的测试（因为完整名称仍然是唯一的）。这两个宏都会自动将测试注册到框架中；因此，用户不需要显式输入来完成此操作。
- en: A test can either fail or succeed. A test fails if an assertion fails or an
    uncaught exception occurs. Except for these two instances, the test always succeeds.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以失败或成功。如果断言失败或发生未捕获的异常，则测试失败。除了这两种情况外，测试总是成功的。
- en: 'To invoke the test, call `RUN_ALL_TESTS()`. However, you can do this only once
    in a test program and only after the framework has been initialized with a call
    to `testing::InitGoogleTest()`. This macro runs all the tests in the test program.
    However, it is possible that you select only some tests to run. You can do this
    either by setting up an environment variable called `GTEST_FILTER` with the appropriate
    filter or by passing the filter as a command-line argument with the `--gtest_filter`
    flag. If either of these two are present, the framework only runs the tests whose
    full name matches the filter. The filter may include wildcards: `*` to match any
    string and the `?` symbol to match any character. Negative patterns (what should
    be omitted) are introduced with a hyphen (`-`). The following are examples of
    filters:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用测试，请调用 `RUN_ALL_TESTS()`。然而，你只能在测试程序中调用一次，并且只能在调用 `testing::InitGoogleTest()`
    初始化框架之后进行。此宏会运行测试程序中的所有测试。然而，你可能只想运行一些测试。你可以通过设置名为 `GTEST_FILTER` 的环境变量并使用适当的过滤器，或者通过使用
    `--gtest_filter` 标志将过滤器作为命令行参数来做到这一点。如果这两个中的任何一个存在，框架只会运行名称与过滤器完全匹配的测试。过滤器可以包含通配符：`*`
    匹配任何字符串，`?` 符号匹配任何字符。使用连字符（`-`）引入负模式（应该省略的内容）。以下是一些过滤器的示例：
- en: '| **Filter** | **Description** |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| **过滤器** | **描述** |'
- en: '| `--gtest_filter=*` | Run all the tests |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `--gtest_filter=*` | 运行所有测试 |'
- en: '| `--gtest_filter=TestConstruction.*` | Run all the tests from the test suite
    called `TestConstruction` |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `--gtest_filter=TestConstruction.*` | 运行名为 `TestConstruction` 的测试套件中的所有测试
    |'
- en: '| `--gtest_filter=TestOperations.*-TestOperations.TestLess` | Run all the tests
    from the test suite called `TestOperations`, except for a test called `TestLess`
    |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `--gtest_filter=TestOperations.*-TestOperations.TestLess` | 运行名为 `TestOperations`
    的测试套件中的所有测试，除了名为 `TestLess` 的测试 |'
- en: '| `--gtest_filter=*Operations*:*Construction*` | Run all the tests whose full
    names contain either `Operations` or `Construction` |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `--gtest_filter=*Operations*:*Construction*` | 运行所有名称中包含 `Operations` 或 `Construction`
    的测试 |'
- en: '| `--gtest_filter=Test?` | Run all tests whose names have 5 characters and
    start with `Test`, such as `TestA`, `Test0`, or `Test_`. |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `--gtest_filter=Test?` | 运行所有名称有 5 个字符且以 `Test` 开头的测试，例如 `TestA`、`Test0`
    或 `Test_`。 |'
- en: '| `--gtest_filter=Test??` | Run all tests whose names have 6 characters and
    start with `Test`, such as `TestAB`, `Test00`, or `Test_Z`. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `--gtest_filter=Test??` | 运行所有名称有 6 个字符且以 `Test` 开头的测试，例如 `TestAB`、`Test00`
    或 `Test_Z`。 |'
- en: 'Table 11.4: Examples of filters'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.4：过滤器示例
- en: 'The following listing is the output of a test program containing the tests
    shown earlier when invoked with the command-line argument `--gtest_filter=TestConstruction.*-TestConstruction.TestConstructor`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是使用命令行参数 `--gtest_filter=TestConstruction.*-TestConstruction.TestConstructor`
    调用包含前面显示的测试的测试程序时的输出：
- en: '[PRE39]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It is possible for you to disable some of the tests by prefixing either the
    name of a test with `DISABLED_` or the name of a test suite with the same identifier,
    in which case all the tests in the test suite will be disabled. This is exemplified
    here:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在测试名称前加上 `DISABLED_` 或在具有相同标识符的测试套件名称前加上前缀来禁用一些测试。在这种情况下，测试套件中的所有测试都将被禁用。以下是一个示例：
- en: '[PRE40]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: None of these tests will be executed. However, you will receive a report in
    the output stating that you have a number of disabled tests.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试都不会被执行。然而，你将在输出中收到一份报告，说明你有多个禁用的测试。
- en: Keep in mind that this feature is only meant for temporarily disabling tests.
    This is useful when you need to perform some code changes that make tests fail
    and you don’t have time to fix them right away. Therefore, this feature should
    be used judiciously.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此功能仅用于临时禁用测试。当你需要执行一些会导致测试失败的代码更改，而你又没有时间立即修复它们时，这很有用。因此，应谨慎使用此功能。
- en: See also
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Getting started with Google Test*, to learn how to install the Google Test
    framework and how to create a simple test project'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Test 入门*，了解如何安装 Google Test 框架以及如何创建一个简单的测试项目'
- en: '*Asserting with Google Test*, to explore the various assertion macros from
    the Google Test library'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Google Test 进行断言*，探索 Google Test 库中的各种断言宏'
- en: '*Using test fixtures with Google Test*, to learn how to define test fixtures
    when using the Google Test library'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Google Test 的测试夹具*，了解如何在使用 Google Test 库时定义测试夹具'
- en: Asserting with Google Test
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Test 进行断言
- en: The Google Test framework provides a rich set of both fatal and non-fatal assertion
    macros, which resemble function calls, to verify the tested code. When these assertions
    fail, the framework displays the source file, line number, and relevant error
    message (including custom error messages) to help developers quickly identify
    the failed code. We have already seen some simple examples of how to use the `ASSERT_TRUE`
    macro; in this recipe, we will look at other available macros.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 框架提供了一套丰富的致命和非致命断言宏，它们类似于函数调用，用于验证测试代码。当这些断言失败时，框架会显示源文件、行号以及相关的错误信息（包括自定义错误信息），以帮助开发者快速识别失败的代码。我们已看到一些使用
    `ASSERT_TRUE` 宏的简单示例；在本食谱中，我们将探讨其他可用的宏。
- en: How to do it...
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following macros to verify the tested code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下宏来验证测试代码：
- en: 'Use `ASSERT_TRUE(condition)` or `EXPECT_TRUE(condition)` to check whether the
    condition is `true`, and `ASSERT_FALSE(condition)` or `EXPECT_FALSE(condition)`
    to check whether the condition is `false`, as shown in the following code:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ASSERT_TRUE(condition)` 或 `EXPECT_TRUE(condition)` 来检查条件是否为 `true`，以及使用
    `ASSERT_FALSE(condition)` 或 `EXPECT_FALSE(condition)` 来检查条件是否为 `false`，以下代码展示了这一用法：
- en: '[PRE41]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Use `ASSERT_XX(val1, val2)` or `EXPECT_XX(val1, val2)` to compare two values,
    where `XX` is one of the following: `EQ(val1 == val2)`, `NE(val1 != val2)`, `LT(val1
    < val2)`, `LE(val1 <= val2)`, `GT(val1 > val2)`, or `GE(val1 >= val2)`. This is
    illustrated in the following code:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ASSERT_XX(val1, val2)` 或 `EXPECT_XX(val1, val2)` 来比较两个值，其中 `XX` 是以下之一：`EQ(val1
    == val2)`、`NE(val1 != val2)`、`LT(val1 < val2)`、`LE(val1 <= val2)`、`GT(val1 > val2)`
    或 `GE(val1 >= val2)`。以下代码展示了这一用法：
- en: '[PRE42]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use `ASSERT_STRXX(str1, str2)` or `EXPECT_STRXX(str1, str2)` to compare two
    null-terminated strings, where `XX` is one of the following: `EQ` (the strings
    have the same content), `NE` (the strings don’t have the same content), `CASEEQ`
    (the strings have the same content with the case ignored), and `CASENE` (the strings
    don’t have the same content with the case ignored). This is illustrated in the
    following code snippet:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ASSERT_STRXX(str1, str2)` 或 `EXPECT_STRXX(str1, str2)` 来比较两个以 null 结尾的字符串，其中
    `XX` 是以下之一：`EQ`（字符串内容相同）、`NE`（字符串内容不同）、`CASEEQ`（忽略大小写时字符串内容相同）和 `CASENE`（忽略大小写时字符串内容不同）。以下代码片段展示了这一用法：
- en: '[PRE43]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Use `ASSERT_FLOAT_EQ(val1, val2)` or `EXPECT_FLOAT_EQ(val1, val2)` to check
    whether two `float` values are almost equal, and `ASSERT_DOUBLE_EQ(val1, val2)`
    or `EXPECT_DOUBLE_EQ(val1, val2)` to check whether two `double` values are almost
    equal; they should differ by at most 4 **ULP** (**units in the last place**).
    Use `ASSERT_NEAR(val1, val2, abserr)` to check whether the difference between
    the two values is not greater than the specified absolute value:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ASSERT_FLOAT_EQ(val1, val2)` 或 `EXPECT_FLOAT_EQ(val1, val2)` 来检查两个 `float`
    值是否几乎相等，以及使用 `ASSERT_DOUBLE_EQ(val1, val2)` 或 `EXPECT_DOUBLE_EQ(val1, val2)` 来检查两个
    `double` 值是否几乎相等；它们之间的差异不应超过 4 **ULP**（**最后一位单位**）。使用 `ASSERT_NEAR(val1, val2,
    abserr)` 来检查两个值之间的差异是否不大于指定的绝对值：
- en: '[PRE44]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Use `ASSERT_THROW(statement, exception_type)` or `EXPECT_THROW(statement, exception_type)`
    to check whether the statement throws an exception of the specified type, `ASSERT_ANY_THROW(statement)`
    or `EXPECT_ANY_THROW(statement)` to check whether the statement throws an exception
    of any type, and `ASSERT_NO_THROW(statement)` or `EXPECT_NO_THROW(statement)`
    to check whether the statement throws any exception:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ASSERT_THROW(statement, exception_type)`或`EXPECT_THROW(statement, exception_type)`来检查语句是否抛出指定类型的异常，使用`ASSERT_ANY_THROW(statement)`或`EXPECT_ANY_THROW(statement)`来检查语句是否抛出任何类型的异常，以及使用`ASSERT_NO_THROW(statement)`或`EXPECT_NO_THROW(statement)`来检查语句是否抛出任何异常：
- en: '[PRE45]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Use `ASSERT_PRED1(pred, val)` or `EXPECT_PRED1(pred, val)` to check whether
    `pred(val)` returns `true`, `ASSERT_PRED2(pred, val1, val2)` or `EXPECT_PRED2(pred,
    val1, val2)` to check whether `pred(val1, val2)` returns `true`, and so on; use
    this for *n*-ary predicate functions or functors:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ASSERT_PRED1(pred, val)`或`EXPECT_PRED1(pred, val)`来检查`pred(val)`是否返回`true`，使用`ASSERT_PRED2(pred,
    val1, val2)`或`EXPECT_PRED2(pred, val1, val2)`来检查`pred(val1, val2)`是否返回`true`，依此类推；用于*n*-元谓词函数或函数对象：
- en: '[PRE46]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Use `ASSERT_HRESULT_SUCCEEDED(expr)` or `EXPECT_HRESULT_SUCCEEDED(expr)` to
    check whether `expr` is a success `HRESULT`, and `ASSERT_HRESULT_FAILED(expr)`
    or `EXPECT_HRESULT_FAILED(expr)` to check whether `expr` is a failure `HRESULT`.
    These assertions are intended to be used on Windows.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ASSERT_HRESULT_SUCCEEDED(expr)`或`EXPECT_HRESULT_SUCCEEDED(expr)`来检查`expr`是否是成功的`HRESULT`，以及使用`ASSERT_HRESULT_FAILED(expr)`或`EXPECT_HRESULT_FAILED(expr)`来检查`expr`是否是失败的`HRESULT`。这些断言旨在在Windows上使用。
- en: 'Use `FAIL()` to generate a fatal failure and `ADD_FAILURE()` or `ADD_FAILURE_AT(filename,
    line)` to generate non-fatal failures:'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FAIL()`生成致命错误，使用`ADD_FAILURE()`或`ADD_FAILURE_AT(filename, line)`生成非致命错误：
- en: '[PRE47]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'All these asserts are available in two versions:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些断言都有两种版本：
- en: '`ASSERT_*`: This generates fatal failures, preventing further execution of
    the current test function.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASSERT_*`：这会生成致命错误，阻止当前测试函数的进一步执行。'
- en: '`EXPECT_*`: This generates non-fatal failures, which means that the execution
    of the test function continues, even if the assertion fails.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPECT_*`：这会生成非致命错误，这意味着即使断言失败，测试函数的执行也会继续。'
- en: Use the `EXPECT_*` assertion if not meeting the condition is not a critical
    error or if you want the test function to continue, in order to get as many error
    messages as possible. In other cases, use the `ASSERT_*` version of the test assertions.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不满足条件不是严重错误，或者您希望测试函数继续执行以获取尽可能多的错误信息，请使用`EXPECT_*`断言。在其他情况下，请使用测试断言的`ASSERT_*`版本。
- en: You will find details about the assertions presented here in the framework’s
    online documentation, which is available on GitHub at [https://github.com/google/googletest](https://github.com/google/googletest);
    this is where the project is located. A special note on floating-point comparison
    is, however, necessary. Due to round-offs (fractional parts cannot be represented
    as a finite sum of the inverse powers of two), floating-point values do not match
    exactly. Therefore, a comparison should be done within a relative error bound.
    The macros `ASSERT_EQ`/`EXPECT_EQ` are not suitable for comparing floating points,
    and the framework provides another set of assertions. `ASSERT_FLOAT_EQ`/`ASSERT_DOUBLE_EQ`
    and `EXPECT_FLOAT_EQ`/`EXPECT_DOUBLE_EQ` perform a comparison with a default error
    of 4 ULP.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在框架的在线文档中找到这里展示的断言的详细信息，该文档可在GitHub上找到：[https://github.com/google/googletest](https://github.com/google/googletest)；这是项目所在的位置。然而，关于浮点数比较有一个特别的注意事项。由于舍入误差（分数部分不能表示为二的反幂的有限和），浮点数值不会完全匹配。因此，比较应该在相对误差范围内进行。宏`ASSERT_EQ`/`EXPECT_EQ`不适用于比较浮点数，框架提供了一套其他的断言。`ASSERT_FLOAT_EQ`/`ASSERT_DOUBLE_EQ`和`EXPECT_FLOAT_EQ`/`EXPECT_DOUBLE_EQ`使用默认误差为4
    ULP进行比较。
- en: 'ULP is a unit of measurement for the spacing between floating-point numbers,
    that is, the value the least significant digit represents if it is 1\. For more
    information on this, read the *Comparing Floating Point Numbers, 2012 Edition*
    article by Bruce Dawson: [https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ULP是浮点数之间间隔的度量单位，即如果它是1，则表示最不显著数字的值。有关更多信息，请阅读Bruce Dawson撰写的*比较浮点数，2012年版*文章：[https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/)。
- en: See also
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing and invoking tests with Google Test*, to see how to create tests and
    test suites using the Google Test library, as well as how to run tests'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Google Test 编写和调用测试*，了解如何使用 Google Test 库创建测试和测试套件，以及如何运行测试'
- en: Using test fixtures with Google Test
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Test 的测试用例
- en: The framework provides support for using fixtures as reusable components for
    all the tests that are part of a test suite. It also provides support for setting
    up the global environment in which the tests will run. In this recipe, you will
    find stepwise instructions on how to define and use test fixtures, as well as
    to set up the test environment.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 框架提供了支持，将测试用例作为可重用组件用于测试套件中的所有测试。它还提供了支持，用于设置测试将运行的全球环境。在本食谱中，您将找到逐步说明如何定义和使用测试用例，以及如何设置测试环境。
- en: Getting ready
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should now be familiar with writing and invoking tests using the Google
    Test framework, a topic that was covered earlier in this chapter, specifically
    in the *Writing and invoking tests with Google Test* recipe.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该熟悉使用 Google Test 框架编写和调用测试，这是在本章前面提到的主题，特别是在 *使用 Google Test 编写和调用测试* 食谱中。
- en: How to do it...
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create and use a test fixture, do the following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和使用测试用例，请执行以下操作：
- en: 'Create a class derived from the `testing::Test` class:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 `testing::Test` 类派生的类：
- en: '[PRE48]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Use the constructor to initialize the fixture and the destructor to clean it
    up:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用构造函数来初始化测试用例，并使用析构函数来清理它：
- en: '[PRE49]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Alternatively, you can override the virtual methods `SetUp()` and `TearDown()`
    for the same purpose.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您也可以重写虚拟方法 `SetUp()` 和 `TearDown()` 以达到相同的目的。
- en: 'Add member data and functions to the class to make them available to the tests:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加成员数据和函数，以便它们对测试可用：
- en: '[PRE50]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Use the `TEST_F` macro to define tests using fixtures, and specify the fixture
    class name as the test suite name:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `TEST_F` 宏定义使用测试用例的测试，并将测试用例类名指定为测试套件名称：
- en: '[PRE51]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To customize the setup of the environment for running tests, do the following:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要自定义运行测试的环境设置，请执行以下操作：
- en: 'Create a class derived from `testing::Environment`:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 `testing::Environment` 派生的类：
- en: '[PRE52]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Override the virtual methods `SetUp()` and `TearDown()` to perform setup and
    cleanup operations:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写虚拟方法 `SetUp()` 和 `TearDown()` 以执行设置和清理操作：
- en: '[PRE53]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Register the environment with a call to `testing::AddGlobalTestEnvironment()`
    before calling `RUN_ALL_TESTS()`:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `RUN_ALL_TESTS()` 之前，通过调用 `testing::AddGlobalTestEnvironment()` 来注册环境：
- en: '[PRE54]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Text fixtures enable users to share data configurations between multiple tests.
    Fixture objects are not shared between tests. A different fixture object is created
    for each test that is associated with the text function. The following operations
    are performed by the framework for each test coming from a fixture:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 文本测试用例允许用户在多个测试之间共享数据配置。测试用例对象在测试之间不共享。对于与文本函数关联的每个测试，都会创建不同的测试用例对象。框架为来自测试用例的每个测试执行以下操作：
- en: Create a new fixture object.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的测试用例对象。
- en: Call its `SetUp()` virtual method.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用其 `SetUp()` 虚拟方法。
- en: Run the test.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: Call the fixture’s `TearDown()` virtual method.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用测试用例的 `TearDown()` 虚拟方法。
- en: Destroy the fixture object.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁测试用例对象。
- en: 'You can set up and clean the fixture objects in two ways: by using the constructor
    and destructor, or by using the `SetUp()` and `TearDown()` virtual methods. In
    most cases, the former way is preferred. The use of virtual methods is suitable
    in several cases, though:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两种方式设置和清理测试用例对象：使用构造函数和析构函数，或者使用 `SetUp()` 和 `TearDown()` 虚拟方法。在大多数情况下，前者是首选的方法。虚拟方法的使用适用于几种情况：
- en: When the teardown operation throws an exception, as exceptions are not allowed
    to leave destructors.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当清理操作抛出异常时，因为不允许异常离开析构函数。
- en: If you are required to use assertion macros during cleanup and you use the `--gtest_throw_on_failure`
    flag, which determines the macros to be thrown upon a failure occurring.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在清理过程中需要使用断言宏，并且使用了 `--gtest_throw_on_failure` 标志，该标志用于确定在发生失败时抛出的宏。
- en: If you need to call virtual methods (which might be overridden in a derived
    class), as virtual calls should not be invoked from the constructor or destructor.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要调用虚拟方法（这些方法可能在派生类中被重写），因为虚拟调用不应从构造函数或析构函数中调用。
- en: Tests that use fixtures must be defined using the `TEST_F` macro (where `_F`
    stands for fixture). Trying to declare them using the `TEST` macro will generate
    compiler errors.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用测试用例的测试必须使用 `TEST_F` 宏（其中 `_F` 代表测试用例）。尝试使用 `TEST` 宏声明它们将生成编译器错误。
- en: 'The environments in which tests are run can also be customized. The mechanism
    is similar to test fixtures: you derive from the base `testing::Environment` class
    and override the `SetUp()` and `TearDown()` virtual functions. Instances of these
    derived environment classes must be registered with the framework with a call
    to `testing::AddGlobalTestEnvironment()`; however, this has to be done before
    you run the tests. You can register as many instances as you want, in which case
    the `SetUp()` method is called for the objects in the order they were registered
    and the `TearDown()` method is called in reverse order. You must pass dynamically
    instantiated objects to this function. The framework takes ownership of the objects
    and deletes them before the program terminates; therefore, do not delete them
    yourself.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试的环境也可以进行定制。机制类似于测试夹具：您从基类 `testing::Environment` 派生，并重写 `SetUp()` 和 `TearDown()`
    虚拟函数。这些派生环境类的实例必须通过调用 `testing::AddGlobalTestEnvironment()` 在框架中进行注册；然而，这必须在运行测试之前完成。您可以注册任意多个实例，在这种情况下，`SetUp()`
    方法将按注册顺序调用对象，而 `TearDown()` 方法将按相反的顺序调用。您必须将动态实例化的对象传递给此函数。框架将接管对象，并在程序终止前删除它们；因此，请不要自行删除。
- en: Environment objects are not available to the tests, nor intended to provide
    data to the tests. Their purpose is to customize the global environment for running
    the tests.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 环境对象对测试不可用，也不打算为测试提供数据。它们的目的在于为运行测试定制全局环境。
- en: See also
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing and invoking tests with Google Test*, to see how to create tests and
    test suites using the Google Test library, as well as how to run tests'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google Test 编写和调用测试，了解如何使用 Google Test 库创建测试和测试套件，以及如何运行测试
- en: Controlling output with Google Test
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google Test 控制输出
- en: By default, the output of a Google Test program goes to the standard stream,
    printed in a human-readable format. The framework provides several options for
    customizing the output, including printing XML to a disk file in a JUNIT-based
    format. This recipe will explore the options available to control the output.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Google Test 程序的输出流向标准流，以可读的格式打印。框架提供了几个选项来自定义输出，包括以基于 JUNIT 的格式将 XML 打印到磁盘文件。本菜谱将探讨可用于控制输出的选项。
- en: Getting ready
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the purpose of this recipe, let’s consider the following test program:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本菜谱的目的，让我们考虑以下测试程序：
- en: '[PRE55]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Its output is as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出如下：
- en: '[PRE56]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We will use this simple testing program to demonstrate the various options we
    can use to control the program’s output, which are exemplified in the following
    section.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个简单的测试程序来演示我们可以用来控制程序输出的各种选项，这些选项在以下部分中进行了示例。
- en: How to do it...
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To control the output of a test program, you can:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制测试程序的输出，您可以：
- en: 'Use the `--gtest_output` command-line option or the `GTEST_OUTPUT` environment
    variable with the `xml:filepath` string to specify the location of a file where
    the XML report is to be written:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `--gtest_output` 命令行选项或带有 `xml:filepath` 字符串的 `GTEST_OUTPUT` 环境变量来指定要写入 XML
    报告的文件位置：
- en: '[PRE57]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use the `--gtest_color` command-line option or the `GTEST_COLOR` environment
    variable and specify either `auto`, `yes`, or `no` to indicate whether the report
    should be printed to a terminal using colors or not:'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `--gtest_color` 命令行选项或 `GTEST_COLOR` 环境变量，并指定 `auto`、`yes` 或 `no` 以指示报告是否应使用颜色打印到终端：
- en: '[PRE58]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use the `--gtest_print_time` command-line option or the `GTEST_PRINT_TIME`
    environment variable with the value `0` to suppress the printing time each test
    takes to execute:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `--gtest_print_time` 命令行选项或带有值 `0` 的 `GTEST_PRINT_TIME` 环境变量来抑制打印每个测试执行所需的时间：
- en: '[PRE59]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Generating a report in an XML format does not affect the human-readable report
    printed to the terminal. The output path can indicate either a file, a directory
    (in which case a file with the name of the executable is created – if it already
    exists from a previous run, it creates a file with a new name by suffixing it
    with a number), or nothing, in which case the report is written to a file called
    `test_detail.xml` in the current directory.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 以 XML 格式生成报告不会影响打印到终端的易读报告。输出路径可以指示文件、目录（在这种情况下，将创建一个以可执行文件命名的文件 - 如果之前运行已存在，则通过在后面添加数字创建一个新名称的文件），或者无，在这种情况下，报告将写入当前目录中名为
    `test_detail.xml` 的文件。
- en: 'The XML report format is based on the JUNITReport Ant task and contains the
    following main elements:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: XML 报告格式基于 JUNITReport Ant 任务，并包含以下主要元素：
- en: '`<testsuites>`: This is the root element and it corresponds to the entire test
    program.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<testsuites>`：这是根元素，对应整个测试程序。'
- en: '`<testsuite>`: This corresponds to a test suite.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<testsuite>`：这对应于一个测试套件。'
- en: '`<testcase>`: This corresponds to a test function, as Google Test functions
    are equivalent to test cases in other frameworks.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<testcase>`：这对应于一个测试函数，因为 Google Test 函数在其他框架中相当于测试用例。'
- en: By default, the framework reports the time it takes for each test to execute.
    This feature can be suppressed using the `--gtest_print_time` command-line option
    or the `GTEST_PRINT_TIME` environment variable, as shown earlier.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，框架会报告每个测试执行所需的时间。可以使用 `--gtest_print_time` 命令行选项或 `GTEST_PRINT_TIME` 环境变量来抑制此功能，如前所述。
- en: See also
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing and invoking tests with Google Test*, to see how to create tests and
    test suites using the Google Test library, as well as how to run tests'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Google Test 编写和调用测试*，查看如何使用 Google Test 库创建测试和测试套件，以及如何运行测试'
- en: '*Using test fixtures with Google Test*, to learn how to define test fixtures
    when using the Google Test library'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Google Test 的测试夹具*，学习如何在使用 Google Test 库时定义测试夹具'
- en: Getting started with Catch2
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Catch2
- en: '**Catch2** is a multiparadigm testing framework for C++ and Objective-C. The
    name Catch2 follows on from Catch, the first version of the framework, which stands
    for **C++ Automated Test Cases in Headers**. It enables developers to write tests
    using either the traditional style of test functions grouped in test cases or
    the **behavior-driven development**(**BDD**) style with *given-when-then* sections.
    Tests are self-registered and the framework provides several assertion macros;
    out of these, two are used the most: one fatal (namely, `REQUIRE`) and one non-fatal
    (namely, `CHECK`). They perform expression decomposition of both the left-hand
    and right-hand side values, which are logged in case of failure. Unlike its first
    version, Catch2 no longer supports C++03\. The current version of Catch2 is v3,
    which has some significant changes when compared to Catch2 v2, such as the library
    is no longer a single-header library but works as a regular library (that needs
    to be compiled), and requires a C++14 compiler.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**Catch2** 是一个用于 C++ 和 Objective-C 的多范式测试框架。Catch2 的名字沿袭自 Catch，这是框架的第一个版本，代表
    **C++ Automated Test Cases in Headers**。它允许开发者使用传统的测试函数分组在测试用例中的风格或带有 *given-when-then*
    部分的 **行为驱动开发**(**BDD**) 风格来编写测试。测试是自动注册的，并且框架提供了几个断言宏；在这些宏中，使用得最多的是两个：一个是致命的（即，`REQUIRE`）和一个非致命的（即，`CHECK`）。它们对左右两边的表达式进行分解，并在失败时记录。与第一个版本不同，Catch2
    不再支持 C++03。Catch2 的当前版本是 v3，与 Catch2 v2 相比有一些重大变化，例如，库不再是单头库，而是作为一个常规库（需要编译）工作，并需要一个
    C++14 编译器。'
- en: For the remaining recipes of this chapter, we will learn how to write unit tests
    using Catch2 version 3.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余的食谱中，我们将学习如何使用 Catch2 版本 3 编写单元测试。
- en: Getting ready
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The Catch2 test framework has a macro-based API. Although you only need to use
    the supplied macros for writing tests, a good understanding of macros is recommended
    if you want to use the framework well.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Catch2 测试框架有一个基于宏的 API。虽然你只需要使用提供的宏来编写测试，但如果想更好地使用该框架，建议对宏有一个良好的理解。
- en: How to do it...
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to set up your environment to use the Catch2 testing framework, do
    the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置你的环境以使用 Catch2 测试框架，请执行以下操作：
- en: Clone or download the Git repository from [https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2).
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2) 克隆或下载
    Git 仓库。
- en: Once you’ve downloaded the repository, unzip the content of the archive.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载仓库后，解压缩存档内容。
- en: 'To use the v3 version of Catch 2, you have two options:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Catch 2 的 v3 版本，你有两种选择：
- en: Use library merged (amalgamated) header and source files in your test project.
    These files are called `catch_amalgamated.hpp` and `catch_amalgamated.cpp`. They
    are located in the `extras` folder of the Catch2 library, and you can copy them
    into your test project if you want. The advantage of this is that you don’t have
    to deal with CMake scripts, at the expense of increased build times.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的测试项目中使用合并（混合）的库和源文件。这些文件被称为 `catch_amalgamated.hpp` 和 `catch_amalgamated.cpp`。它们位于
    Catch2 库的 `extras` 文件夹中，如果你想的话，可以将它们复制到你的测试项目中。这样做的好处是，你不必处理 CMake 脚本，但代价是增加了构建时间。
- en: Use CMake to add Catch2 as a static library for your project.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CMake 将 Catch2 添加为你的项目的静态库。
- en: 'To create your first test program using Catch2 and its amalgamated files, do
    the following:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Catch2 和其合并文件创建您的第一个测试程序，请执行以下操作：
- en: Create a new empty C++ project.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空 C++ 项目。
- en: Copy the `catch_amalgamated.hpp` and `catch_amalgamated.cpp` files from the
    `extras` folder of the Catch2 library to your test project.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Catch2 库的 `extras` 文件夹中的 `catch_amalgamated.hpp` 和 `catch_amalgamated.cpp`
    文件复制到您的测试项目中。
- en: Add the `catch_amalgamated.cpp` source file to your project, to be compiled
    along with your other source files (containing tests).
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `catch_amalgamated.cpp` 源文件添加到您的项目中，与其他源文件（包含测试）一起编译。
- en: 'Add a new source file to the project with the following content:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新源文件，内容如下：
- en: '[PRE60]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Build and run the project.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目。
- en: 'To create your first test program with Catch2 using the CMake integration,
    do the following:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 CMake 集成创建您的第一个 Catch2 测试程序，请执行以下操作：
- en: Open a console/command prompt and change the directory to the location of the
    cloned/unzipped Catch2 files.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台/命令提示符，并将目录更改为克隆/解压缩的 Catch2 文件的位置。
- en: 'Build the library using the commands shown below. On a Unix system, run:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建库。在 Unix 系统上运行：
- en: '[PRE61]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'On a Windows system, execute the following commands from a command prompt running
    with administrative privileges:'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Windows 系统上，从具有管理员权限的命令提示符中执行以下命令：
- en: '[PRE62]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Create a new folder (called `Test`) for a C++ testing project.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 C++ 测试项目创建一个新的文件夹（称为 `Test`）。
- en: 'Add a new source file (called `main.cpp`) to this folder with the following
    content:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向此文件夹添加一个新源文件（称为 `main.cpp`），内容如下：
- en: '[PRE63]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add a new `CMakeLists.txt` CMake file to the `Test` folder with the following
    content:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Test` 文件夹中添加一个新的 `CMakeLists.txt` CMake 文件，内容如下：
- en: '[PRE64]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Run `cmake.exe` to generate/build your project.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `cmake.exe` 以生成/构建您的项目。
- en: There are different ways to set up your project using CMake. In this recipe,
    I provided a minimal example that works, which you can also find with the source
    files from the GitHub repo. Readers experienced with CMake may find better approaches
    than the one provided here. You can learn more about CMake from online resources.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CMake 设置项目有多种方式。在这个菜谱中，我提供了一个最小示例，它有效，您也可以在 GitHub 仓库的源文件中找到它。熟悉 CMake 的读者可能会找到比这里提供的方法更好的方法。您可以从在线资源中了解更多关于
    CMake 的信息。
- en: How it works...
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Catch2 enables developers to write test cases as self-registered functions;
    it can even provide a default implementation for the `main()` function so that
    you can focus on testing code and writing less setup code. Test cases are divided
    into sections that are run in isolation. The framework does not adhere to the
    style of the **setup-test-teardown** architecture. Instead, the test case sections
    (or rather the innermost ones, since sections can be nested) are the units of
    testing that are executed, along with their enclosing sections. This makes the
    need for fixtures obsolete because data and setup and teardown code can be reused
    on multiple levels.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: Catch2 允许开发者将测试用例编写为自注册函数；它甚至可以提供 `main()` 函数的默认实现，这样您就可以专注于测试代码并编写更少的设置代码。测试用例被划分为单独运行的章节。该框架不遵循
    **setup-test-teardown** 架构的风格。相反，测试用例部分（或者更确切地说，最内层的部分，因为部分可以嵌套）是执行的单位，以及它们的封装部分。这使得固定装置变得不再需要，因为数据和设置以及拆卸代码可以在多个级别上重用。
- en: Test cases and sections are identified using strings, not identifiers (as in
    most testing frameworks). Test cases can also be tagged so that tests can be executed
    or listed based on tags. Test results are printed in a textual human-readable
    format; however, they can also be exported to XML, using either a Catch2-specific
    schema or a JUNIT ANT schema for easy integration with continuous delivery systems.
    The execution of the tests can be parameterized to break upon failure (on Windows
    and macOS) so that you can attach a debugger and inspect the program.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例和部分使用字符串标识，而不是标识符（如大多数测试框架中那样）。测试用例也可以被标记，以便可以根据标记执行或列出测试。测试结果以文本可读格式打印；然而，它们也可以导出为
    XML 格式，使用 Catch2 特定的模式或 JUNIT ANT 模式，以便轻松集成到持续交付系统中。测试的执行可以参数化，在失败时中断（在 Windows
    和 macOS 上），这样您就可以附加调试器并检查程序。
- en: 'The framework is easy to install and use. There are two alternatives, as seen
    in the *How to do it…* section:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架易于安装和使用。正如在 *如何做…* 部分中看到的那样，有两种替代方案：
- en: Using the amalgamated files `catch_amalgamated.hpp` and `catch_amalgamated_cpp`.
    These are a merging of all the header and source files. The advantage of using
    them is that you do not have to worry about building the Catch2 library. You only
    have to copy these files to your desired location (typically inside your project),
    include the `catch_amalgamated`.hpp header in your files that contain tests, and
    build `catch_amalgamated.cpp` alongside the rest of your source files. The disadvantage
    of using this approach is increased build times.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用合并的文件 `catch_amalgamated.hpp` 和 `catch_amalgamated_cpp`。这些是所有头文件和源文件的合并。使用它们的优点是，你不必担心构建
    Catch2 库。你只需要将这些文件复制到你的目标位置（通常在项目内部），在你的包含测试的文件中包含 `catch_amalgamated.hpp` 头文件，并与其他源文件一起构建
    `catch_amalgamated.cpp`。使用这种方法的不利之处是增加了构建时间。
- en: Using Catch2 as a static library. This requires you to build the library before
    using it. You can either add the header and `lib` files explicitly to your project,
    or you can use CMake for this purpose. This approach provides the advantage of
    reduced build times.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Catch2 作为静态库使用。这要求你在使用之前构建库。你可以明确地将头文件和 `lib` 文件添加到你的项目中，或者你可以使用 CMake 来完成这个任务。这种方法的优势是减少了构建时间。
- en: 'The sample code shown in the previous section has the following parts:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中展示的示例代码有以下部分：
- en: '`#include "catch_amalgamated.hpp"` includes the amalgamated header of the library
    that is a merging of all the library headers. On the other hand, if you’re using
    the build version, you only need to include the particular headers that you need,
    such as `<catch2/catch_test_macros.hpp>`. You can include `<cathc2/catch_all.hpp>`
    but this will include all the library headers, which is not advisable. In general,
    you should only include the headers that you need.'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#include "catch_amalgamated.hpp"` 包含了库的合并头文件，这是一个所有库头文件的合并。另一方面，如果你使用的是构建版本，你只需要包含你需要的特定头文件，例如
    `<catch2/catch_test_macros.hpp>`。你可以包含 `<cathc2/catch_all.hpp>`，但这将包含所有库头文件，这并不建议。一般来说，你应该只包含你需要的头文件。'
- en: '`TEST_CASE("first_test_case", "[learn][catch]")` defines a test case called
    `first_test_case`, which has two associated tags: `learn` and `catch`. Tags are
    used to select either running or just listing test cases. Multiple test cases
    can be tagged with the same tags.'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TEST_CASE("first_test_case", "[learn][catch]")` 定义了一个名为 `first_test_case`
    的测试用例，它有两个关联的标签：`learn` 和 `catch`。标签用于选择运行或仅列出测试用例。多个测试用例可以带有相同的标签。'
- en: '`SECTION("first_test_function")` defines a section, that is, a test function,
    called `first_test_function`, as part of the outer test case.'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SECTION("first_test_function")` 定义了一个部分，即一个测试函数，称为 `first_test_function`，作为外部测试用例的一部分。'
- en: '`REQUIRE(i == 42);` is an assertion that tells the test to fail if the condition
    is not satisfied.'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`REQUIRE(i == 42);` 是一个断言，告诉测试如果条件不满足则测试失败。'
- en: 'The output of running this program is as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序的结果如下：
- en: '[PRE65]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: There’s more...
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As mentioned previously, the framework enables us to write tests using the
    BDD style with *give-when-then* sections. This was made possible using several
    aliases: `SCENARIO` for `TEST_CASE` and `GIVE`, `WHEN`, `AND_WHEN`, `THEN`, and
    `AND_THEN` for `SECTION`. Using this style, we can rewrite the test shown earlier,
    as follows:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，该框架使我们能够使用带有 *给-当-然后* 部分的 BDD 风格编写测试。这是通过使用几个别名实现的：`SCENARIO` 对应于 `TEST_CASE`
    和 `GIVE`、`WHEN`、`AND_WHEN`、`THEN` 和 `AND_THEN` 对应于 `SECTION`。使用这种风格，我们可以重写前面展示的测试，如下所示：
- en: '[PRE66]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When executed successfully, the program prints the following output:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序成功执行时，它将打印以下输出：
- en: '[PRE67]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'However, upon failure (let’s suppose we got the wrong condition: `i == 0`),
    the expression that failed, as well as the values on the left-hand and right-hand
    sides, are printed in the output, as shown in the following snippet:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在失败的情况下（假设我们得到了错误的条件：`i == 0`），失败的表达式以及左右两侧的值将在输出中打印出来，如下面的代码片段所示：
- en: '[PRE68]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The output presented here, as well as in other snippets throughout the following
    recipes, has been slightly trimmed or compressed from the actual console output
    to make it easier to list within the pages of this book.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的输出，以及在下述食谱中的其他代码片段，已经从实际的控制台输出中略微裁剪或压缩，以便更容易地在本书的页面中列出。
- en: See also
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing and invoking tests with Catch2*, to see how to create tests with the
    Catch2 library, either using the traditional style based on test cases or the
    BDD style with scenarios, as well as how to run tests'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Catch2 编写和调用测试*，以了解如何使用 Catch2 库创建测试，无论是基于测试用例的传统风格还是基于场景的 BDD 风格，以及如何运行测试'
- en: '*Asserting with Catch2*, to explore the various assertion macros from the Catch2
    library'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *Catch2* 进行断言，以探索 Catch2 库中的各种断言宏
- en: Writing and invoking tests with Catch2
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Catch2 编写和调用测试
- en: The Catch2 framework enables you to write tests using either the traditional
    style of test cases and test functions or the BDD style with scenarios and *given-when-then*
    sections. Tests are defined as separate sections of a test case and can be nested
    as deep as you want. Whichever style you prefer, tests are defined with only two
    base macros. This recipe will show what these macros are and how they work.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: Catch2 框架允许你使用传统的测试用例和测试函数风格或带有场景和 *given-when-then* 部分的 BDD 风格来编写测试。测试被定义为测试用例的独立部分，可以嵌套到你想要的深度。无论你更喜欢哪种风格，测试都只使用两个基本宏来定义。这个配方将展示这些宏是什么以及它们是如何工作的。
- en: How to do it...
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To write tests using the traditional style, with test cases and test functions,
    do this:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用传统的测试用例和测试函数风格编写测试，请这样做：
- en: 'Use the `TEST_CASE` macro to define a test case with a name (as a string),
    and optionally, a list of its associated tags:'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `TEST_CASE` 宏定义一个带有名称（作为字符串）的测试用例，可选地，一个与其关联的标签列表：
- en: '[PRE69]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Use the `SECTION` macro to define a test function inside a test case, with
    the name as a string:'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SECTION` 宏在测试用例内部定义一个测试函数，名称作为字符串：
- en: '[PRE70]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Define nested sections if you want to reuse the setup and teardown code or
    organize your tests in a hierarchical structure:'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想重用设置和清理代码或以分层结构组织测试，请定义嵌套部分：
- en: '[PRE71]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To write tests using the BDD style, do this:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 BDD 风格编写测试，请这样做：
- en: 'Define scenarios using the `SCENARIO` macro, specifying a name for it:'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SCENARIO` 宏定义场景，指定其名称：
- en: '[PRE72]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Define nested sections inside the scenario using the `GIVEN`, `WHEN`, and `THEN`
    macros, specifying a name for each of them:'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景内部使用 `GIVEN`、`WHEN` 和 `THEN` 宏定义嵌套部分，为每个部分指定一个名称：
- en: '[PRE73]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To execute the tests, do the following:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行测试，请执行以下操作：
- en: To execute all the tests from your program (except hidden ones), run the test
    program without any command-line arguments (from the ones described in the following
    code).
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行程序中的所有测试（除了隐藏的测试），运行测试程序而不带任何命令行参数（如下述代码中描述的）。
- en: 'To execute only a specific set of test cases, provide a filter as a command-line
    argument. This can contain test case names, wildcards, tag names, and tag expressions:'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行特定的一组测试用例，提供一个过滤器作为命令行参数。这可以包含测试用例名称、通配符、标签名称和标签表达式：
- en: '[PRE74]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To execute only a particular section (or set of sections), use the command-line
    argument `--section` or `-c` with the section name (can be used multiple times
    for multiple sections):'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行特定的部分（或一系列部分），使用带有部分名称的命令行参数 `--section` 或 `-c`（可以多次使用以执行多个部分）：
- en: '[PRE75]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To specify the order in which test cases should be run, use the command-line
    argument `--order` with one of the following values: `decl` (for the order of
    declaration), `lex` (for lexicographic ordering by name), or `rand` (for a random
    order determined with `std::random_shuffle()`). Here’s an illustration of this:'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指定测试用例应运行的顺序，使用命令行参数 `--order` 并选择以下值之一：`decl`（声明顺序），`lex`（按名称的字典顺序），或 `rand`（使用
    `std::random_shuffle()` 确定的随机顺序）。以下是一个示例：
- en: '[PRE76]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works...
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Test cases are self-registered and do not require any additional work from the
    developer to set the test program, other than defining the test cases and test
    functions. Test functions are defined as sections of test cases (using the `SECTION`
    macro), and they can be nested.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例会自动注册，不需要开发人员做任何额外工作来设置测试程序，除了定义测试用例和测试函数。测试函数定义为测试用例的部分（使用 `SECTION` 宏），并且可以嵌套。
- en: There is no limit to the depth of section nesting. Test cases and test functions,
    which, from here on, will be referred to as sections, form a tree structure, with
    the test cases on the root nodes and the most inner sections as leaves. When the
    test program runs, it is the leaf sections that are executed. Each leaf section
    is executed in isolation from the other leaf sections. However, the execution
    path starts at the root test case and continues downward, toward the innermost
    section. All of the code that’s encountered on the path is executed entirely for
    each run. This means that when multiple sections share common code (from a parent
    section or the test case), the same code is executed once for each section, without
    any data being shared between executions. This has the effect that it eliminates
    the need for a special fixture approach on the one hand. On the other hand, it
    enables multiple fixtures for each section (everything that is encountered up
    in the path), a feature that many testing frameworks lack.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 节的嵌套深度没有限制。测试用例和测试函数（从现在起将被称为节），形成一个树状结构，测试用例位于根节点，最内层的节作为叶子。当测试程序运行时，执行的是叶子节。每个叶子节都是独立于其他叶子节执行的。然而，执行路径从根测试用例开始，向下继续，直到最内层的节。路径上遇到的所有代码在每次运行时都会完全执行。这意味着当多个节共享公共代码（来自父节或测试用例）时，相同的代码为每个节执行一次，执行之间不共享任何数据。这在一方面消除了对特殊夹具方法的需求。另一方面，它为每个节（路径上遇到的所有内容）提供了多个夹具，这是许多测试框架所缺少的功能。
- en: 'The BDD style of writing test cases is powered by the same two macros, namely,
    `TEST_CASE` and `SECTION`, and the ability to test sections. In fact, the macro
    `SCENARIO` is a redefinition of `TEST_CASE`, and `GIVEN`, `WHEN`, `AND_WHEN`,
    `THEN`, and `AND_THEN` are redefinitions of `SECTION`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试用例的BDD风格由相同的两个宏提供支持，即`TEST_CASE`和`SECTION`，以及测试节的能力。实际上，宏`SCENARIO`是对`TEST_CASE`的重定义，而`GIVEN`、`WHEN`、`AND_WHEN`、`THEN`和`AND_THEN`是对`SECTION`的重定义：
- en: '[PRE77]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: When you execute a test program, all defined tests are run. This, however, excludes
    hidden tests, which are specified either using a name that starts with `./` or
    a tag that starts with a period. It is possible to force the running of hidden
    tests too by providing the command-line argument `[.]` or `[hide]`.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行测试程序时，所有定义的测试都会运行。然而，这排除了隐藏的测试，这些测试要么使用以`./`开头的名称指定，要么使用以点开头的标签指定。也可以通过提供命令行参数`[.]`或`[hide]`来强制运行隐藏的测试。
- en: 'It is possible to filter the test cases to execute. This can be done using
    either the name or the tags. The following table displays some of the possible
    options:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对要执行的测试用例进行过滤。这可以通过名称或标签来完成。以下表格显示了其中的一些可能选项：
- en: '| **Argument** | **Description** |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| `"test construction"` | The test case called `test construction` |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| `"测试构建"` | 被称为`test construction`的测试用例 |'
- en: '| `test*` | All test cases that start with `test` |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| `test*` | 所有以`test`开头的测试用例 |'
- en: '| `~"test construction"` | All test cases, except the one called `test construction`
    |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| `~"测试构建"` | 除了被称为`test construction`的测试用例之外的所有测试用例 |'
- en: '| `~*equal*` | All test cases, except those that contain the word `equal` |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| `~*equal*` | 所有不包含单词`equal`的测试用例 |'
- en: '| `a* ~ab* abc` | All tests that start with `a`, except those that start with
    `ab`, except `abc`, which is included |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| `a* ~ab* abc` | 所有以`a`开头的测试，除了以`ab`开头的，除了`abc`（包含在内） |'
- en: '| `[modify]` | All test cases tagged with `[modify]` |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| `[修改]` | 所有带有标签`[修改]`的测试用例 |'
- en: '| `[modify],[compare][op]` | All test cases that are tagged with either `[modify]`
    or both `[compare]` and `[op]` |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| `[修改],[比较][操作]` | 所有带有标签`[修改]`或同时带有`[比较]`和`[操作]`的测试用例 |'
- en: '| `-#sourcefile` | All tests from the `sourcefile.cpp` file |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| `-#sourcefile` | 来自`sourcefile.cpp`文件的全部测试 |'
- en: 'Table 11.5: Examples of filters for the test cases to be executed'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.5：将要执行的测试用例的过滤器示例
- en: The execution of particular test functions is also possible by specifying one
    or more section names with the command-line argument `--section` or `-c`. However,
    wildcards are not supported for this option. If you specify a section to run,
    be aware that the entire test path from the root test case to the selected section
    will be executed. Moreover, if you do not specify a test case or a set of test
    cases first, then all the test cases will be executed, though only the matching
    sections within them.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定命令行参数 `--section` 或 `-c` 中的一个或多个部分名称，也可以执行特定的测试函数。但是，此选项不支持通配符。如果你指定要运行的部分，请注意，将从根测试用例到所选部分的整个测试路径都将执行。此外，如果你首先没有指定测试用例或一组测试用例，则将执行所有测试用例，尽管只有它们中匹配的部分。
- en: See also
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Getting started with Catch2*, to learn how to install the Catch2 framework
    and how to create a simple test project'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始使用 Catch2*，学习如何安装 Catch2 框架以及如何创建一个简单的测试项目'
- en: '*Asserting with Catch2*, to explore the various assertion macros from the Catch2
    library'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Catch2 断言*，以探索 Catch2 库中的各种断言宏'
- en: Asserting with Catch2
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Catch2 断言
- en: 'Unlike other testing frameworks, Catch2 does not provide a large set of assertion
    macros. It has two main macros: `REQUIRE`, which produces a fatal error, stopping
    the execution of the test case upon failure, and `CHECK`, which produces a non-fatal
    error upon failure, continuing the execution of the test case. Several additional
    macros are defined; in this recipe, we will see how to put them to work.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他测试框架不同，Catch2 不提供大量断言宏。它有两个主要的宏：`REQUIRE`，在失败时产生致命错误，停止测试用例的执行，和 `CHECK`，在失败时产生非致命错误，继续测试用例的执行。还定义了几个附加的宏；在本食谱中，我们将看到如何使用它们。
- en: Getting ready
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should now be familiar with writing test cases and test functions using
    Catch2, a topic we covered in the previous recipe, *Writing and invoking tests
    with Catch2*.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该熟悉使用 Catch2 编写测试用例和测试函数，这是我们之前在 *使用 Catch2 编写和调用测试* 这一食谱中讨论的主题。
- en: How to do it...
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following list contains the available options for asserting with the Catch2
    framework:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含使用 Catch2 框架进行断言的可用选项：
- en: 'Use `CHECK(expr)` to check whether `expr` evaluates to `true`, continuing the
    execution in case of failure, and `REQUIRE(expr)` to make sure that `expr` evaluates
    to `true`, stopping the execution of the test in case of failure:'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CHECK(expr)` 来检查 `expr` 是否评估为 `true`，在失败时继续执行，并使用 `REQUIRE(expr)` 来确保 `expr`
    评估为 `true`，在失败时停止测试的执行：
- en: '[PRE78]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Use `CHECK_FALSE(expr)` and `REQUIRE_FALSE(expr)` to make sure that `expr`
    evaluates to `false` and produces either a non-fatal or fatal error in case of
    failure:'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CHECK_FALSE(expr)` 和 `REQUIRE_FALSE(expr)` 来确保 `expr` 评估为 `false`，并在失败时产生非致命或致命错误：
- en: '[PRE79]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Use floating-point matchers, `WithinAbs`, `WithinRel`, and `WithinUPL`, to
    compare floating-point numbers (this is preferred over the obsolete `Approx` class):'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浮点数匹配器 `WithinAbs`、`WithinRel` 和 `WithinUPL` 来比较浮点数（这比过时的 `Approx` 类更受欢迎）：
- en: '[PRE80]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Use `CHECK_NOTHROW(expr)`/`REQUIRE_NOTHROW(expr)` to verify that `expr` does
    not throw any error, `CHECK_THROWS(expr)`/`REQUIRE_THROWS(expr)` to verify that
    `expr` does throw an error of any type, `CHECK_THROWS_AS(expr, exctype)`/`REQUIRE_THROWS_AS(expr,
    exctype)` to verify that `expr` throws an exception of the type `exctype`, or
    `CHECK_THROWS_WITH(expression, string or string matcher)`/`REQUIRE_THROWS_WITH(expression,
    string or string matcher)` to verify that `expr` throws an expression whose description
    matches the specified string:'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CHECK_NOTHROW(expr)`/`REQUIRE_NOTHROW(expr)` 来验证 `expr` 不抛出任何错误，`CHECK_THROWS(expr)`/`REQUIRE_THROWS(expr)`
    来验证 `expr` 抛出任何类型的错误，`CHECK_THROWS_AS(expr, exctype)`/`REQUIRE_THROWS_AS(expr,
    exctype)` 来验证 `expr` 抛出类型为 `exctype` 的异常，或者 `CHECK_THROWS_WITH(expression, string
    or string matcher)`/`REQUIRE_THROWS_WITH(expression, string or string matcher)`
    来验证 `expr` 抛出的异常描述与指定的字符串匹配：
- en: '[PRE81]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Use `CHECK_THAT(value, matcher expression)`/`REQUIRE_THAT(expr, matcher expression)`
    to check whether the given matcher expression evaluates to `true` for the specified
    value:'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CHECK_THAT(value, matcher expression)`/`REQUIRE_THAT(expr, matcher expression)`
    来检查给定的匹配器表达式是否对指定的值评估为 `true`：
- en: '[PRE82]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Use `FAIL(message)` to report `message` and fail the test case, `WARN(message)`
    to log the message without stopping the execution of the test case, and `INFO(message)`
    to log the message to a buffer and only report it with the next assertion that
    would fail.
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `FAIL(message)` 来报告 `message` 并使测试用例失败，`WARN(message)` 来记录消息而不停止测试用例的执行，以及
    `INFO(message)` 来将消息记录到缓冲区，并且只在下一个会失败的断言中报告它。
- en: How it works...
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `REQUIRE`/`CATCH` family of macros decompose the expression into its left-
    and right-hand side terms and, upon failure, report the location of the failure
    (source file and line), the expression, and the values on the left- and right-hand
    sides:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`REQUIRE`/`CATCH` 宏系列将表达式分解为其左右两侧的项，并在失败时报告失败的位置（源文件和行）、表达式以及左右两侧的值：'
- en: '[PRE83]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'However, these macros do not support complex expressions composed using logical
    operators, such as `&&` and `||`. The following example is an error:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些宏不支持使用逻辑运算符（如 `&&` 和 `||`）组成的复杂表达式。以下示例是错误的：
- en: '[PRE84]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The solution for this is to create a variable to hold the result of the expression
    evaluation and use it in the assertion macros. In this case, however, the ability
    to print the expansion of the elements of the expression is lost:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是创建一个变量来保存表达式评估的结果，并在断言宏中使用它。然而，在这种情况下，打印表达式元素展开的能力丢失了：
- en: '[PRE85]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'An alternative is to use another set of parentheses. However, this too stops
    the decomposition from working:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用另一组括号。然而，这也阻止了分解工作：
- en: '[PRE86]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Two sets of assertions, namely `CHECK_THAT`/`REQUIRE_THAT` and `CHECK_THROWS_WITH`/`REQUIRE_THROWS_WITH`,
    work with matchers. Matchers are extensible and composable components that perform
    value matching. The framework provides several matchers, including for:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 两套断言，即 `CHECK_THAT`/`REQUIRE_THAT` 和 `CHECK_THROWS_WITH`/`REQUIRE_THROWS_WITH`，与匹配器一起工作。匹配器是可扩展和可组合的组件，用于执行值匹配。框架提供了几个匹配器，包括：
- en: 'Strings: `StartsWith`, `EndsWith`, `ContainsSubstring`, `Equals`, and `Matches`'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：`StartsWith`、`EndsWith`、`ContainsSubstring`、`Equals` 和 `Matches`
- en: '`std::vector`: `Contains`, `VectorContains`, `Equals`, `UnorderedEquals`, and
    `Approx`'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`：`Contains`、`VectorContains`、`Equals`、`UnorderedEquals` 和 `Approx`'
- en: 'Floating-point values: `WithinAbs`, `WithinULP`, `WithinRel`, and `IsNaN`'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点值：`WithinAbs`、`WithinULP`、`WithinRel` 和 `IsNaN`
- en: 'Range-like types (included from version 3.0.1): `IsEmpty`, `SizeIs`, `Contains`,
    `AllMatch`, `AnyMatch`, `NoneMatch`, `AllTrue`, `AnyTrue`, `NoneTrue`, `RangeEquals`,
    `UnorderedRangeEquals`'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于范围类型（从版本 3.0.1 开始包含）：`IsEmpty`、`SizeIs`、`Contains`、`AllMatch`、`AnyMatch`、`NoneMatch`、`AllTrue`、`AnyTrue`、`NoneTrue`、`RangeEquals`、`UnorderedRangeEquals`
- en: 'Exceptions: `Message` and `MessageMatches`'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常：`Message` 和 `MessageMatches`
- en: The difference between `Contains()` and `VectorContains()` is that `Contains()`
    searches for a vector in another vector and `VectorContains()` searches for a
    single element inside a vector.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contains()` 和 `VectorContains()` 之间的区别在于 `Contains()` 在另一个向量中搜索一个向量，而 `VectorContains()`
    在向量内部搜索单个元素。'
- en: 'As mentioned in the previous list, there are several matchers that target floating-point
    numbers. These matchers are:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有几个匹配器针对浮点数。这些匹配器包括：
- en: '`WithinAbs()`: Creates a matcher that accepts a floating-point number that
    is less than or equal to a target number with a specified margin (a percentage
    given as a number between 0 and 1):'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithinAbs()`：创建一个接受小于或等于目标数且具有指定边缘（0 到 1 之间的数字表示的百分比）的浮点数的匹配器：'
- en: '[PRE87]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`WithinRel()`: Creates a matcher that accepts a floating-point number that
    is approximatively equal to a target with a given tolerance:'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithinRel()`：创建一个接受近似等于目标值且具有给定容忍度的浮点数的匹配器：'
- en: '[PRE88]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`WithinULP()`: Creates a matcher that accepts a floating-point number that
    is no more than the given ULP away from the target:'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithinULP()`：创建一个接受目标值不超过给定 ULP 的浮点数的匹配器：'
- en: '[PRE89]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'These matchers can also be combined together, as exemplified below:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这些匹配器也可以组合在一起，如下所示：
- en: '[PRE90]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: An obsolete way of comparing floating-point numbers is represented by the class
    called `Approx`, in the `Catch` namespace. This class overloads the equality/inequality
    and comparison operators with values through which a `double` value can be constructed.
    The margin by which the two values can either differ or be considered equal can
    be specified as a percentage of the given value. This is set using the member
    function `epsilon()`. The value must be between 0 and 1 (for example, the value
    of 0.05 is 5 percent). The default value of epsilon is set to `std::numeric_limits<float>::epsilon()*100`.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 一个过时的比较浮点数的方法由名为 `Approx` 的类表示，位于 `Catch` 命名空间中。这个类通过值重载了相等/不等和比较运算符，通过这些值可以构造一个
    `double` 值。两个值可以相差的边缘或被认为是相等的边缘可以指定为给定值的百分比。这可以通过成员函数 `epsilon()` 来设置。值必须在 0 和
    1 之间（例如，0.05 的值是 5%）。epsilon 的默认值设置为 `std::numeric_limits<float>::epsilon()*100`。
- en: 'You can create your own matchers, either to extend the existing framework capabilities
    or to work with your own types. There are two ways to create custom matches: the
    old v2 way, and the new v3 way.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建自己的匹配器，无论是为了扩展现有框架的功能还是为了与您自己的类型一起工作。创建自定义匹配器有两种方式：旧版 v2 方式和新版 v3 方式。
- en: 'To create a custom matcher the old way, there are two things that are necessary:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 要以旧方式创建自定义匹配器，有两个必要条件：
- en: 'A matcher class derived from `Catch::MatcherBase<T>`, where `T` is the type
    being compared. There are two virtual functions that must be overridden: `match()`,
    which takes a value to match and returns a Boolean indicating whether the match
    was successful, and `describe()`, which takes no arguments but returns a string
    describing the matcher.'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Catch::MatcherBase<T>` 派生出的匹配器类，其中 `T` 是正在比较的类型。必须重写两个虚拟函数：`match()`，它接受一个要匹配的值并返回一个布尔值，指示匹配是否成功，以及
    `describe()`，它不接受任何参数但返回一个描述匹配器的字符串。
- en: A builder function that is called from the test code.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从测试代码中调用的构建函数。
- en: 'The following example defines a matcher for the `point3d` class, which we have
    seen throughout this chapter, to check whether a given 3D point lies on a line
    in the three-dimensional space:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了一个匹配器，用于 `point3d` 类，这是我们在本章中看到过的，以检查给定的三维点是否位于三维空间中的一条直线上：
- en: '[PRE91]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'To create a custom matcher the new way, you need the following:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 要以新方式创建自定义匹配器，您需要以下内容：
- en: 'A matcher class derived from `Catch::Matchers::MatcherGenericBase`. This class
    has to implement two methods: `bool match(…) const`, which performs the matching,
    and an overriding of the virtual function `string describe() const`, which takes
    no arguments but returns a string describing the matcher. Although these are very
    similar to the functions used in the old style, there is a key difference: the
    `match()` function has no requirements on the way its argument is passed. This
    means it can take an argument by value or mutating reference. In addition, it
    can also be a function template. The advantage is that it enables writing more
    complex matchers, such as matchers that can compare range-like types.'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Catch::Matchers::MatcherGenericBase` 派生出的匹配器类。这个类必须实现两个方法：`bool match(…)
    const`，它执行匹配，以及重写虚拟函数 `string describe() const`，它不接受任何参数但返回一个描述匹配器的字符串。尽管这些与旧式风格中使用的函数非常相似，但有一个关键区别：`match()`
    函数对其参数的传递方式没有要求。这意味着它可以按值传递或通过可变引用传递参数。此外，它还可以是一个函数模板。优点是它使得编写更复杂的匹配器成为可能，例如可以比较类似范围的类型。
- en: A builder function that is called from the test code.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从测试代码中调用的构建函数。
- en: 'The same matcher that compares `point3d` values written in the new style looks
    as follows:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 以新风格编写的比较 `point3d` 值的相同匹配器如下所示：
- en: '[PRE92]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The following test case contains an example of how to use this custom matcher:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试用例包含了一个如何使用此自定义匹配器的示例：
- en: '[PRE93]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This test ensures that the point `{2,2,2}` lies on the line defined by the points
    `{0,0,0}` and `{3,3,3}` by using the `IsOnTheLine()` custom matcher implemented
    previously.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试确保点 `{2,2,2}` 位于由点 `{0,0,0}` 和 `{3,3,3}` 定义的直线上，使用了之前实现的 `IsOnTheLine()`
    自定义匹配器。
- en: See also
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing and invoking tests with Catch2*, to see how to create tests with the
    Catch2 library, either using the traditional style based on test cases or the
    BDD style with scenarios, as well as how to run tests'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Catch2 编写和调用测试*，了解如何使用 Catch2 库创建测试，无论是使用基于测试用例的传统风格还是基于场景的 BDD 风格，以及如何运行测试'
- en: Controlling output with Catch2
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Catch2 控制输出
- en: As with other testing frameworks discussed in this book, Catch2 reports the
    results of a test program’s execution in a human-readable format to the `stdout`
    standard stream. Additional options are supported, such as reporting using XML
    format or writing to a file. In this recipe, we will look at the main options
    available for controlling the output when using Catch2.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中讨论的其他测试框架一样，Catch2 以人类可读的格式将测试程序执行的结果报告到 `stdout` 标准流。支持额外的选项，例如使用 XML 格式报告或写入文件。在本食谱中，我们将查看使用
    Catch2 控制输出的主要选项。
- en: Getting ready
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To exemplify the way the test program’s execution output could be modified,
    use the following test cases:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明测试程序执行输出可能如何修改，请使用以下测试用例：
- en: '[PRE94]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output of running these two test cases is as follows:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这两个测试用例的输出如下：
- en: '[PRE95]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In the following section, we’ll explore some of the various options for controlling
    the output of a Catch2 test program.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨控制 Catch2 测试程序输出的各种选项。
- en: How to do it…
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To control the output of a test program when using Catch2, you can:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制使用 Catch2 时测试程序的输出，你可以：
- en: 'Use the command-line argument `-r` or `--reporter <reporter>` to specify the
    reporter used to format and structure the results. The default options supplied
    with the framework are `console`, `compact`, `xml`, and `junit`:'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行参数 `-r` 或 `--reporter <reporter>` 来指定用于格式化和结构化结果的报告器。框架提供的默认选项是 `console`、`compact`、`xml`
    和 `junit`：
- en: '[PRE96]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Use the command-line argument `-s` or `--success` to display the results of
    successful test cases too:'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行参数 `-s` 或 `--success` 来显示成功测试用例的结果：
- en: '[PRE97]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Use the command-line argument `-o` or `--out <filename>` to send all of the
    output to a file instead of the standard stream:'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行参数 `-o` 或 `--out <filename>` 将所有输出发送到文件而不是标准流：
- en: '[PRE98]'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Use the command-line argument `-d` or `--durations <yes/no>` to display the
    time that it takes each test case to execute:'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行参数 `-d` 或 `--durations <yes/no>` 来显示每个测试用例执行所需的时间：
- en: '[PRE99]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How it works...
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Apart from the human-readable format used, by default, for reporting the results
    of the test program execution, the Catch2 framework supports two XML formats:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认用于报告测试程序执行结果的易读格式外，Catch2 框架还支持两种 XML 格式：
- en: A Catch2-specific XML format (specified with `-r xml`)
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种特定的 Catch2 XML 格式（通过 `-r xml` 指定）
- en: A JUNIT-like XML format, following the structure of the JUNIT ANT task (specified
    with `-r junit`)
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种类似于 JUNIT 的 XML 格式，遵循 JUNIT ANT 任务的结构（通过 `-r junit` 指定）
- en: The former reporter streams the XML content as unit tests are executed and results
    are available. It can be used as input to an XSLT transformation to generate an
    HTML report for the instance. The latter reporter needs to gather all of the program
    execution data in order to structure the report before printing it. The JUNIT
    XML format is useful for being consumed by third-party tools, such as a continuous
    integration server.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 前者报告器在单元测试执行和结果可用时流式传输 XML 内容，可以用作 XSLT 转换的输入以生成实例的 HTML 报告。后者报告器需要在打印报告之前收集程序的所有执行数据。JUNIT
    XML 格式对于被第三方工具（如持续集成服务器）消费很有用。
- en: 'Several additional reporters are provided in standalone headers. They need
    to be included in the source code of the test program (all the headers of the
    additional reporters have the name format as `catch_reporter_*.hpp`). These additional
    available reporters are:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在独立头文件中提供了几个额外的报告器。它们需要包含在测试程序的源代码中（所有额外报告器的名称格式为 `catch_reporter_*.hpp`）。这些额外的可用报告器包括：
- en: '**TeamCity** reporter (specified with `-r teamcity`), which writes TeamCity
    service messages to the standard output stream. It is suitable only for integration
    with TeamCity. It is a streamed reporter; data is written as it is available.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TeamCity** 报告器（通过 `-r teamcity` 指定），它将 TeamCity 服务消息写入标准输出流。它仅适用于与 TeamCity
    集成。它是一个流式报告器；数据在可用时即被写入。'
- en: '**Automake** reporter (specified with `-r automake`), which writes the meta
    tags expected by `automake` via `make check`.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Automake** 报告器（通过 `-r automake` 指定），它通过 `make check` 写入 `automake` 所期望的元标签。'
- en: '**Test Anything Protocol** (or **TAP**, for short) reporter (specified with
    `-r tap`).'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Test Anything Protocol**（或简称 **TAP**）报告器（通过 `-r tap` 指定）。'
- en: '**SonarQube** reporter (specified with `-r sonarqube`), which writes using
    the SonarQube generic test data XML format.'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SonarQube** 报告器（通过 `-r sonarqube` 指定），它使用 SonarQube 通用测试数据 XML 格式进行写入。'
- en: 'The following example shows how to include the TeamCity header file in order
    to produce the report using the TeamCity reporter:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何包含 TeamCity 头文件以使用 TeamCity 报告器生成报告：
- en: '[PRE100]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The default target of the test report is the standard stream `stdout` (even
    data written explicitly to `stderr` ends up being redirected to `stdout`). However,
    it is possible that the output is written to a file instead. These formatting
    options can be combined. Take a look at the following command:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 测试报告的默认目标是标准流 `stdout`（即使明确写入 `stderr` 的数据最终也会被重定向到 `stdout`）。然而，输出也可能被写入到文件中。这些格式化选项可以组合使用。请看以下命令：
- en: '[PRE101]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This command specifies that the report should use the JUNIT XML format and be
    saved to a file called `test_report.xml`.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令指定报告应使用 JUNIT XML 格式，并保存到名为 `test_report.xml` 的文件中。
- en: See also
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Getting started with Catch2*, to learn how to install the Catch2 framework
    and how to create a simple test project'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始使用 Catch2*，了解如何安装 Catch2 框架以及如何创建一个简单的测试项目'
- en: '*Writing and invoking tests with Catch2*, to see how to create tests with the
    Catch2 library, either using the traditional style based on test cases or the
    BDD style with scenarios, as well as how to run tests'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Catch2 编写和调用测试*，了解如何使用 Catch2 库创建测试，无论是基于测试用例的传统风格还是基于场景的 BDD 风格，以及如何运行测试'
- en: Learn more on Discord
  id: totrans-617
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_11.xhtml)'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_11.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
