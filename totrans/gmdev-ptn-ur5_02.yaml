- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: “Hello Patterns”
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “Hello Patterns”
- en: This chapter will focus on the principles that underpin all good code. Design
    patterns are an extension of these principles, so it is important to walk before
    you run. Once the basics have been covered, we’ll look at some bad Blueprint code
    so that we can understand the process of fixing it, which we will do by following
    some step-by-step guides.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于支撑所有良好代码的原则。设计模式是这些原则的扩展，因此，在跑之前先走一步是很重要的。一旦基础知识已经掌握，我们将查看一些不良的蓝图代码，以便我们能够理解修复过程，我们将通过遵循一些逐步指南来完成这项工作。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: S.O.L.I.D. principles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S.O.L.I.D. 原则
- en: Exploring solutions to common problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索常见问题的解决方案
- en: The trade-off
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权衡
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need a blank UE5 project open and ready. There's
    no need for C++ right now; we’ll be focusing on Blueprint code for simplicity.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要一个空白UE5项目已打开并准备就绪。目前不需要C++；我们将专注于蓝图代码以保持简单。
- en: The files for this project can be found in the `chapter2` branch on GitHub at
    [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter02](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter02)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的文件可以在GitHub的`chapter2`分支上找到，网址为[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter02](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter02)
- en: 'If you’ve not created a blank UE5 project before, the following steps will
    take you through creating a simple Blueprint project, which is all we need for
    this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有创建过空白UE5项目，以下步骤将指导你创建一个简单的蓝图项目，这正是我们本章所需要的：
- en: Click the **Launch** button in the top right of the **Epic Launcher** | **Unreal
    Engine** | **Library** tab, where we installed the engine in the first chapter.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Epic Launcher** | **Unreal Engine** | **Library**标签页右上角的**启动**按钮，这是我们第一章节中安装引擎的位置。
- en: Select **Games** on the left side of the **Unreal** **Project Browser**.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Unreal** **项目浏览器**的左侧选择**游戏**。
- en: Select **Blank** from the main section, and toggle **Starter Content** off.
    This will prevent Unreal from adding a bunch of unrequired assets to the project.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主部分中选择**空白**，并关闭**起始内容**。这将防止Unreal向项目中添加大量不必要的资产。
- en: 'Choose a sensible location (the default is fine) and set the project name as
    `HelloPatterns`:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个合理的位置（默认位置即可）并将项目名称设置为`HelloPatterns`：
- en: '![Figure 2.1 – The Unreal Project Browser with a new, blank games project set
    up for creation](img/Figure_02.01_B18297.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 设置用于创建的新、空白游戏项目的Unreal项目浏览器](img/Figure_02.01_B18297.jpg)'
- en: Figure 2.1 – The Unreal Project Browser with a new, blank games project set
    up for creation
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 设置用于创建的新、空白游戏项目的Unreal项目浏览器
- en: Click **Create**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**。
- en: Now you have your project set up, you are ready for the interactive part of
    this chapter, but first, let’s discuss what we mean when we say *good code*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的项目已经设置好了，你就可以准备本章的交互部分了，但首先，让我们讨论一下当我们说**良好代码**时我们指的是什么。
- en: S.O.L.I.D. principles
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: S.O.L.I.D. 原则
- en: To understand why design patterns work, we need to understand the principles
    that underpin good code. Let’s run a whistle-stop tour through most people’s first
    experience with code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解设计模式为什么有效，我们需要了解支撑良好代码的原则。让我们快速浏览一下大多数人第一次接触代码的经历。
- en: The universal *Hello World* program and the beginner exercises that follow are
    all made up of linear code. Linear code executes each line sequentially through
    a single file in which the whole program is written. Loops, selections, and statements
    make up literally everything.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通用**Hello World**程序以及随后的初学者练习都是由线性代码组成的。线性代码通过单个文件按顺序执行每一行，其中整个程序被编写。循环、选择和语句实际上构成了所有内容。
- en: 'As each program gets larger, the code becomes unsustainable. The solution is
    object orientation. **Object-oriented programming** (**OOP**) adds a lot, primarily
    classes and objects, as the name would suggest. With OOP’s added complexity, it
    becomes quite easy to accidentally build in fundamental issues with systems that
    make it impossible to expand them. Having a set of rules to follow greatly simplifies
    the process of building code that works for you and the next person to maintain
    it. These rules take the form of the **S.O.L.I.D.** principles, which are defined
    here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个程序变得越来越大，代码变得难以维护。解决方案是面向对象。**面向对象编程**（**OOP**）增加了许多内容，主要是类和对象，正如其名称所暗示的。随着OOP的复杂性增加，很容易不小心构建进系统中的基本问题，使得系统无法扩展。遵循一套规则可以极大地简化构建适用于你和下一个维护者的代码的过程。这些规则以
    **S.O.L.I.D.** 原则的形式出现，在此定义如下：
- en: S – **Single responsibility**
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S – **单一职责**
- en: O – **Open-closed**
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O – **开闭原则**
- en: L – **Liskov substitution**
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L – **里氏替换**
- en: I – **Interface segregation**
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I – **接口隔离**
- en: D – **Dependency inversion**
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D – **依赖倒置**
- en: Single responsibility
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责
- en: 'In *Agile Software Development: Principles, Patterns, and Practices*, Robert
    C. Martin said the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在《敏捷软件开发：原则、模式和最佳实践》一书中，罗伯特·C·马丁说以下内容：
- en: A class should have one and only one reason to change, meaning that a class
    should have only one job.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类应该只有一个改变的理由，这意味着一个类应该只有一个职责。
- en: Each class should *do what it says on the tin*—or, in this case, the class name.
    If you were hiring a plumber, you wouldn’t expect that plumber to also recite
    *Hamlet* while fixing the pipes. The same is true for code; if you have a math
    library class, you expect it to take numbers in and return the results after performing
    some equations. What you don’t expect is for it to use these numbers as a seed
    to generate an image, which it sets as your desktop background. Granted, this
    is an extreme case that may even be considered a virus, but the point stands.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都应该 *名副其实*——或者，在这个案例中，就是类的名称。如果你雇佣一个水管工，你不希望这个水管工在修理管道的同时还背诵 *哈姆雷特*。对于代码来说，同样的道理；如果你有一个数学库类，你期望它接收数字并执行一些方程后返回结果。你不会期望它使用这些数字作为种子来生成一个图像，并将其设置为你的桌面背景。当然，这是一个极端的例子，甚至可能被认为是病毒，但这个观点是成立的。
- en: Writing a class that does what is expected by its name helps when working in
    a team. Games can become quite large with many interconnected systems, and if
    a developer can understand what a class is responsible for and how to operate
    it, from just function and class names, then time is saved. Implementation can
    be as simple as consistent naming conventions combined with compartmentalized
    functionality. For instance, a function called `AddItem(ItemType type, int amount)`
    on an inventory component in the object used for our player probably adds an amount
    of an item to the inventory of the player. You don’t need to open the function
    to see what it does due to this clear naming.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个符合其名称所期望的类，有助于团队协作。游戏可以变得非常大，有许多相互连接的系统，如果开发者能够仅从函数和类名中理解一个类的职责以及如何操作它，那么就可以节省时间。实现可以简单到一致的命名约定与模块化功能相结合。例如，在用于我们玩家的对象中的库存组件上，名为
    `AddItem(ItemType type, int amount)` 的函数可能向玩家的库存中添加一定数量的物品。由于命名清晰，你不需要打开函数就能知道它做什么。
- en: Open-closed
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开闭原则
- en: 'In *Agile Software Development: Principles, patterns, and practices*, Robert
    C. Martin said:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在《敏捷软件开发：原则、模式和最佳实践》一书中，罗伯特·C·马丁说：
- en: Objects or entities should be open for extension but closed for modification.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对象或实体应该易于扩展，但不易于修改。
- en: 'New functionality should be easy to create, without needing to modify the existing
    code. It is easy to see this in action through something like a save system. If
    you want to port your game to multiple platforms, then it would make sense to
    have a different `save` method for each. To start with, there are two target platforms
    (PC and Xbox); the save system might look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能应该易于创建，无需修改现有代码。通过类似保存系统这样的例子，我们可以很容易地看到这一点。如果你想要将你的游戏移植到多个平台，那么为每个平台拥有不同的
    `save` 方法是有意义的。起初，有两个目标平台（PC和Xbox）；保存系统可能看起来是这样的：
- en: Example SaveClass.cpp
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 SaveClass.cpp
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Somewhere down the line, you decide to extend the system to also work on PlayStation.
    This is another platform to handle. The modification seems easy—just add a new
    case to the ever-expanding statement. Therein lies the problem; the more platforms
    we support, the longer this will get, and the more time and memory the function
    will occupy:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你决定扩展系统以使其也能在 PlayStation 上工作。这是另一个需要处理的平台。修改看起来很简单——只需在不断扩展的语句中添加一个新的情况。问题就在这里；我们支持的平台越多，这个列表就越长，函数将占用更多的时间和内存：
- en: Example SaveClass.cpp
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SaveClass.cpp 的示例
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The solution is to spin the `save` function into an abstract function with
    an overriding child class function for each platform shown in *Figure 2**.2*.
    This not only means new platforms can be added with a new child class but also,
    we don’t have to instantiate versions of the save system we will never use, saving
    memory:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将`save`函数旋转为一个抽象函数，并为每个平台在图 2.2 中显示的每个平台提供一个覆盖的子类函数。这不仅意味着可以通过添加一个新的子类来添加新的平台，而且我们也不必实例化我们将永远不会使用的保存系统版本，从而节省内存：
- en: "![Figure 2.2 – UML diagram showing inheritance of a \uFEFFSaveClass\uFEFF instance\
    \ with the open-closed principle applied](img/Figure_02.02_B18297.jpg)"
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 应用开放-封闭原则的 SaveClass 实例的 UML 图](img/Figure_02.02_B18297.jpg)'
- en: Figure 2.2 – UML diagram showing inheritance of a SaveClass instance with the
    open-closed principle applied
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 应用开放-封闭原则的 SaveClass 实例的 UML 图
- en: Next, we will look at Liskov substitution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨 Liskov 替换。
- en: Liskov substitution
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Liskov 替换
- en: 'In *Agile Software Development: Principles, Patterns, and Practices*, Robert
    C. Martin said the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在《敏捷软件开发：原则、模式和惯例》一书中，Robert C. Martin 指出以下内容：
- en: Let q(x) be a property provable about objects of x of type T. Then q(y) should
    be provable for objects y of type S where S is a subtype of T.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 设 q(x) 为关于类型 T 的 x 的对象的可证明属性。那么，对于类型 S 的对象 y（其中 S 是 T 的子类型），q(y) 应该是可证明的。
- en: 'Essentially, if there is a child class in use within your code, you should
    be able to swap it out for any of its siblings without modifying the structure
    of the calling code or using variables for unintended purposes. In the previous
    example, we turned a save system into a parent-child structure. If we were to
    add cloud saving, we would no longer have a file path to send data to and instead,
    we would use an IP address. Well, we could make this work by just piping the IP
    address through the file path argument as shown in the following exerpt but this
    is a violation of our naming convention. Undoubtedly, someone down the line will
    need to use this function and won’t understand what they need to do. Plus, any
    data not in the requested type will have to be converted by the calling object,
    sent, and then parsed inside the child implementation, which wastes time:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，如果在你的代码中使用了一个子类，你应该能够将其替换为其任何兄弟类，而无需修改调用代码的结构或使用变量进行不期望的目的。在先前的例子中，我们将保存系统转换成了一个父子结构。如果我们添加云保存，我们就不再有发送数据的文件路径，而是使用
    IP 地址。嗯，我们可以通过将 IP 地址通过文件路径参数传递来实现这一点，如以下摘录所示，但这违反了我们的命名约定。毫无疑问，将来会有某人需要使用这个函数，却不会理解他们需要做什么。此外，任何不在请求类型中的数据都必须由调用对象转换，发送，然后在子实现中解析，这浪费了时间：
- en: Excerpt from a program calling a save system
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 调用保存系统的程序摘录
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The fix for this principle is to make the variable that may change a member
    of the child class. That way, initialization functions can deal with making sure
    the correct data is asked for, and we can easily swap out `save` objects as needed.
    This also means the abstract functionality from the parent can be called the same
    way wherever it is used, making for easier maintenance as systems grow:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个原则的方法是将可能变化的变量设为子类的一个成员。这样，初始化函数可以处理确保请求正确的数据，并且我们可以根据需要轻松地替换`save`对象。这也意味着父类中的抽象功能可以在任何使用的地方以相同的方式调用，使得随着系统的增长维护变得更加容易：
- en: "![Figure 2.3 – UML diagram showing inheritance of\uFEFF SaveClass\uFEFF with\
    \ Liskov substitution principle applied](img/Figure_02.03_B18297.jpg)"
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 应用 Liskov 替换原则的 SaveClass 继承的 UML 图](img/Figure_02.03_B18297.jpg)'
- en: Figure 2.3 – UML diagram showing inheritance of SaveClass with Liskov substitution
    principle applied
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 应用 Liskov 替换原则的 SaveClass 继承的 UML 图
- en: 'So, if we apply the Liskov substitution to our code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将 Liskov 替换原则应用到我们的代码中：
- en: Excerpt from a program calling the better save system
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 调用更好的保存系统的程序摘录
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the calls become the same format and are therefore substitutable
    and satisfy the principle.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调用格式相同，因此可以互换并满足原则。
- en: Interface segregation
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口分离
- en: 'In *Agile Software Development: Principles, Patterns, and Practices*, Robert
    C. Martin said the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在《敏捷软件开发：原则、模式和实践》一书中，Robert C. Martin 指出以下内容：
- en: A client should never be forced to implement an interface that it doesn’t use,
    or clients shouldn’t be forced to depend on methods they do not use.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端不应被强制实现它不使用的接口，或者客户端不应被强制依赖于它们不使用的方法。
- en: If the parent defines an abstract function, the child must override it. This
    causes issues when implementing an abstract function for some of the child classes
    as the other children that don’t need that functionality must override to immediately
    nullify it. The solution can either be to extend the inheritance so that there
    is another layer for the classes in need of this extra functionality or to create
    an interface (only available in multi-inheritance languages) that adds the functionality
    to certain subclasses.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父类定义了一个抽象函数，子类必须重写它。当为某些子类实现抽象函数时，这会导致问题，因为其他不需要该功能的子类必须重写以立即将其置为空。解决方案可以是扩展继承，为需要此额外功能的类提供另一层，或者创建一个接口（仅在多继承语言中可用），将功能添加到某些子类中。
- en: 'Going back to the save system, if you need to get account authorization before
    saving on Xbox and PlayStation, then this can be done via inheritance. A new sub-class
    of `Save` can be made, which declares an abstract function for getting authorization.
    This then becomes the parent for each save system that needs the function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回到保存系统，如果您需要在 Xbox 和 PlayStation 上保存之前获取账户授权，则可以通过继承来完成。可以创建一个新的 `Save` 子类，它声明了一个获取授权的抽象函数。然后它成为需要该函数的每个保存系统的父类：
- en: "![Figure 2.4 – UML diagram showing \uFEFFSaveClass\uFEFF inheritance with interface\
    \ segregation applied through pure inheritance](img/Figure_02.04_B18297.jpg)"
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.4 – UML 图显示 SaveClass 通过纯继承应用接口分离的继承](img/Figure_02.04_B18297.jpg)'
- en: Figure 2.4 – UML diagram showing SaveClass inheritance with interface segregation
    applied through pure inheritance
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.4 – UML 图显示 SaveClass 通过纯继承应用接口分离的继承
- en: 'So, if we apply the concept of interface segregation to our code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将接口分离的概念应用到我们的代码中：
- en: Excerpt from a program that checks authentication before saving
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 检查保存前认证的程序摘录
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Technically, the structure shown in *Figure 2**.4* will violate the previous
    Liskov substitution principle as sub-classes that don’t inherit from the middle
    *interface* layer can’t be substituted into the pattern. Deciding which principle
    is more important is part of the skill of designing code and is usually learned
    with practice.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，*Figure 2**.4* 中显示的结构将违反之前的 Liskov 替换原则，因为不继承自中间 *接口* 层的子类不能被替换到模式中。决定哪个原则更重要是设计代码的技能的一部分，通常是通过实践学到的。
- en: 'Although this inheritance structure does satisfy the **interface segregation**
    principle, it does end up getting quite messy with lots of segregated behaviors.
    There is another way. Applying the first principle of single responsibility to
    this tree, we remove each segregated behavior into its own class. Objects of this
    can then be created and injected into the save system where needed. The result
    is more independent classes, but cleaner, smaller inheritance structures. This
    is what is known as using **class composition** to solve a structure problem:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种继承结构确实满足了**接口分离**原则，但它最终会变得相当混乱，有很多分离的行为。还有另一种方法。将单一责任原则的第一条应用到这个树中，我们将每个分离的行为移入其自己的类。然后可以在需要的地方创建此类对象并将其注入保存系统中。结果是更多独立的类，但结构更清晰、更小。这就是使用**类组合**来解决结构问题的方法：
- en: "![Figure 2.5 – UML diagram showing \uFEFFSaveClass\uFEFF alongside \uFEFFAuth\uFEFF\
    \ hierarchy](img/Figure_02.05_B18297.jpg)"
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.5 – UML 图显示 SaveClass 与 Auth 层次结构](img/Figure_02.05_B18297.jpg)'
- en: Figure 2.5 – UML diagram showing SaveClass alongside Auth hierarchy
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.5 – UML 图显示 SaveClass 与 Auth 层次结构
- en: 'So, if we apply class composition to our code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将类组合应用到我们的代码中：
- en: Excerpt of a program that implements Figure 2.5
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.5 的程序摘录
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `SaveSomeData` function would then check the authorized status of the `Auth`
    type object as it needs to.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`SaveSomeData` 函数将检查 `Auth` 类型对象的授权状态，因为它需要这样做。'
- en: Dependency inversion
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置
- en: 'In *Agile Software Development: Principles, Patterns, and Practices*, Robert
    C. Martin said the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *敏捷软件开发：原则、模式和实务* 一书中，Robert C. Martin 指出：
- en: Entities must depend on abstractions, not on concretions. It states that the
    high-level module must not depend on the low-level modules, but they should depend
    on abstractions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实体必须依赖于抽象，而不是具体化。它指出，高级模块不应依赖于低级模块，而它们应该依赖于抽象。
- en: This pattern is the most useful for UE5\. Simply put, if you inject a reference
    to a class somewhere, it really should be the highest-level abstract parent that
    still has the functionality you need. Easy examples would be in a PlayerController,
    where you don’t reference a specific pawn sub-class but, instead, the idea of
    a pawn. Better than that, you could reference the interface for the functionality
    you need; this will prevent long cast chains to filter for the type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在 UE5 中非常有用。简单来说，如果你在某个地方注入一个类的引用，它实际上应该是具有所需功能的最高级抽象父类。在 PlayerController
    中，你不会引用特定的 pawn 子类，而是引用 pawn 的概念。更好的是，你可以引用所需功能的接口；这将防止进行长的类型过滤转换链。
- en: 'In the save example, the injection of the account authorizer is a concretion
    that assumes every `save` module will authorize in the same way. In reality, it
    would be much more appropriate to inject an `Authorizer` parent that only contains
    the authorized status. When creating an object to inject, we then create it as
    the correct sub-class and call its `Authorize` function, which is free to then
    operate as it needs to. You can even reuse this structure for authorization of
    other things elsewhere too:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存示例中，注入账户授权者是一个具体化，它假设每个 `save` 模块将以相同的方式进行授权。实际上，注入一个只包含授权状态的 `Authorizer`
    父类会更为合适。在创建要注入的对象时，我们将其创建为正确的子类并调用其 `Authorize` 函数，该函数可以自由地按需操作。你甚至可以将这种结构用于其他地方的授权：
- en: "![Figure 2.6 – UML diagram showing \uFEFFSaveClass\uFEFF alongside \uFEFFAuth\uFEFF\
    \ hierarchy](img/Figure_02.06_B18297.jpg)"
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.6 – UML 图显示 SaveClass 与 Auth 层次结构](img/Figure_02.06_B18297.jpg)'
- en: Figure 2.6 – UML diagram showing SaveClass alongside Auth hierarchy
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.6 – UML 图显示 SaveClass 与 Auth 层次结构
- en: 'So, if we apply dependency inversion to our code, it would look like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们对我们的代码应用依赖倒置，它将看起来像：
- en: Excerpt of a program that implements Figure 2.6
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.6 的程序摘录
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That’s a lot of theory to have gone through, but with it, we can make tangible
    improvements to dire systems. These improvements should shore up the foundations
    of our code, setting it up to receive the more structure-heavy patterns we will
    be using later in this book.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 经历了这么多理论，但有了它，我们可以对糟糕的系统进行实际的改进。这些改进应该巩固我们代码的基础，为我们在本书后面使用更结构化的模式做好准备。
- en: The next section will guide you through an average beginner developer’s process
    of creating a project and getting something working quickly so that you can then
    apply what you have learned to see a tangible improvement.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将指导你通过一个普通初学者的流程来创建项目并快速使其工作，这样你就可以将所学应用到实践中，看到实际的改进。
- en: Exploring solutions to common problems
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索常见问题的解决方案
- en: We are going to explore a series of examples of Blueprint scripts where the
    intended result has been achieved but causes issues simply due to the approach
    taken. We will then offer an improved approach, which makes the Blueprint more
    performant, tidier, more reusable, or easier to expand at a later point in development.
    The purpose of this section is to help you begin to recognize potential areas
    for improvement within your own code, regardless of whether you are working in
    Blueprint or C++.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索一系列蓝图脚本的示例，其中预期的结果已经实现，但由于采用的方法而引发问题。然后我们将提供一种改进的方法，这使得蓝图更高效、更整洁、更可重用，或更容易在开发后期进行扩展。本节的目的在于帮助你开始识别你自己的代码中潜在的改进区域，无论你是工作在蓝图还是
    C++ 中。
- en: Important note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Everything we are about to look at in this section is bad code to prove a point.
    Even the fixes that follow are not perfect, but it has been written for the purpose
    of education and so is simplified somewhat.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将要查看的一切都是糟糕的代码，以证明一个观点。即使是接下来的修复也不是完美的，但它是为了教育目的而编写的，因此有所简化。
- en: For this section, you will need an empty project that you may have already created
    at the beginning of the chapter and the `content` folder from the `chapter2` branch
    of the GitHub link provided at the start of the chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，你需要一个空的项目，你可能在章节开头就已经创建了这个项目，以及来自章节开头提供的 GitHub 链接的 `chapter2` 分支中的 `content`
    文件夹。
- en: If you’ve not used GitHub before, click the `.zip` folder that you can then
    extract into your new project folder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过 GitHub，请点击 `.zip` 文件，然后将其提取到你的新项目文件夹中。
- en: Place the `HelloPatterns` folder from `.zip` file directly into your content
    directory; this will provide you with some examples of bad practises that we will
    first review before explaining how to fix them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `.zip` 文件中的 `HelloPatterns` 文件夹直接放入你的内容目录中；这将为你提供一些我们将首先回顾的坏习惯示例，然后解释如何修复它们。
- en: To fix the problems, first, duplicate each of the Blueprint assets and change
    the suffix from `_Bad` to `_Better`. This will ensure you can look back and see
    the differences between where we start and where we finish when reworking these
    Blueprints.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这些问题，首先，复制每个蓝图资产，并将后缀从 `_Bad` 更改为 `_Better`。这将确保你可以在重新工作这些蓝图时回顾我们开始和结束时的差异。
- en: To start fixing these Blueprints, you will need to open them by double-clicking
    on them in the **Content Browser**. Once open, navigate to the **Event Graph**
    tab where you will find the examples we’ve covered. Follow the steps under each
    of the **Solution** headings to improve the Blueprints.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始修复这些蓝图，你需要通过在 **内容浏览器** 中双击它们来打开它们。一旦打开，导航到 **事件图** 选项卡，在那里你会找到我们覆盖的示例。按照每个
    **解决方案** 下面的步骤来改进蓝图。
- en: The moving box problem
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动盒子问题
- en: The first example we’re going to look at is a simple moving box (a static mesh
    component) that slides from a start location (relative `0`,`0`,`50`) to an end
    location (relative `200`,`0`,`50)`. Both locations have been stored as vector
    variables within the Blueprint and their defaults set, as mentioned.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个示例是一个简单的移动盒子（静态网格组件），它从起始位置（相对 `0`,`0`,`50`）滑动到结束位置（相对 `200`,`0`,`50`)。这两个位置都已经在蓝图中被存储为向量变量，并且已经设置了默认值，如前所述。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we are using relative location, a vector variable that defines the location
    of an entity based on the location of its parent. A relative location of (0,0,50)
    on a component whose parent actor is positioned at (0,0,0) in the world would
    also be (0,0,50) in the world. However, if the parent actor were to move to (10,10,0),
    the component’s world location would be (10,10,50) as the world and relative locations
    are combined to provide a world location for the component.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用相对位置，这是一个基于父实体位置的向量变量。如果一个组件的父演员在世界中的位置是 (0,0,0)，那么在组件上的相对位置 (0,0,50)
    也会在世界中是 (0,0,50)。然而，如果父演员移动到 (10,10,0)，组件的世界位置将是 (10,10,50)，因为世界位置和相对位置结合为组件提供世界位置。
- en: 'The Blueprint code to move the box has two logic chains selected via a branch
    node (Blueprint’s version of an `if` statement) using `Update` loop). One logic
    chain is used to move the box forward, from start to end, and the other is used
    to move it back. The decision of which to use is controlled by the **Forward**
    Boolean variable:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 移动盒子的蓝图代码有两个逻辑链通过分支节点（蓝图中的 `if` 语句版本）使用 `Update` 循环）选择。一个逻辑链用于将盒子向前移动，从起点到终点，另一个用于将其向后移动。使用哪个由
    **Forward** 布尔变量控制：
- en: '![Figure 2.7 – The Event Tick Branch for selecting which direction to move](img/Figure_02.07_B18297.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 选择移动方向的“事件计时分支”](img/Figure_02.07_B18297.jpg)'
- en: Figure 2.7 – The Event Tick Branch for selecting which direction to move
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 选择移动方向的“事件计时分支”
- en: The *move forward* logic chain adds 1 cm to the *x* coordinate of the box’s
    relative location and updates the position of the box, relative to the actor using
    a **Set Relative** **Location** node.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: “向前移动”逻辑链通过使用 **Set Relative Location** 节点将 1 厘米添加到盒子的相对位置 **x** 坐标，并更新相对于演员的位置。
- en: 'A check then takes place, comparing the current relative location to the end
    point with a 0.0 error tolerance. If the locations are equal, then **Forward**
    is set to **False**, which means on the next tick, the branch will select the
    reverse logic change:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进行一次检查，比较当前相对位置和终点，误差容忍度为 0.0。如果位置相等，则 **Forward** 被设置为 **False**，这意味着在下一次计时，分支将选择反向逻辑更改：
- en: '![Figure 2.8 – The move forward logic chain for the moving box](img/Figure_02.08_B18297.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 移动盒子的向前移动逻辑链](img/Figure_02.08_B18297.jpg)'
- en: Figure 2.8 – The move forward logic chain for the moving box
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 移动盒子的向前移动逻辑链
- en: 'The *move backward* logic chain subtracts 1 cm from the *x* coordinate of the
    box’s relative location and updates the position in the same way. The difference
    here is that the check compares the relative location to the end point and, when
    they are equal, sets **Forward** to **True**, flicking the branch to the *move
    forward* logic on the next tick. This repeats indefinitely or until the actor
    is destroyed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*向后移动*逻辑链从盒子的相对位置*x*坐标中减去1厘米，并以相同的方式更新位置。这里的区别在于，检查将相对位置与终点进行比较，当它们相等时，将**前进**设置为**True**，在下一个tick上切换分支到*向前移动*逻辑。这会无限重复，或者直到actor被销毁：'
- en: '![Figure 2.9 – The move backward logic chain for moving the box](img/Figure_02.09_B18297.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 移动盒子的向后移动逻辑链](img/Figure_02.09_B18297.jpg)'
- en: Figure 2.9 – The move backward logic chain for moving the box
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 移动盒子的向后移动逻辑链
- en: The issue we have here is we are checking on every tick if the box has arrived
    at its destination. Doing the comparison on one box may not cause many issues,
    but if you are moving a lot of items in a scene, this sort of innocent calculation
    is a waste of resources, something we are keen to avoid.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里遇到的问题是我们在每个tick上检查盒子是否到达了目的地。对一个盒子进行这种比较可能不会引起很多问题，但如果你在一个场景中移动很多项目，这种无辜的计算就是资源的浪费，这是我们极力避免的。
- en: Solution to the moving box problem
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动盒子的解决方案
- en: 'Let’s take a look at building a better approach using a timeline:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用时间线构建一个更好的方法：
- en: Begin by deleting all of the nodes in the **Event Graph**, except for the **Set
    Relative Location** and **Static Mesh** **Box** nodes.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先删除**事件图**中的所有节点，除了**设置相对位置**和**静态网格****盒子**节点。
- en: 'Start by adding a custom event node by right-clicking on the graph, typing
    `custom event`, and pressing *Enter*. You can select the **Add Custom Event…**
    option at any point; typing more of the name will simply help reduce the options
    available, hopefully speeding things up:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先通过在图上右键单击，输入`custom event`并按*Enter*键添加一个自定义事件节点。你可以在任何时候选择**添加自定义事件…**选项；输入更多名称将简单地帮助减少可用的选项，希望这样可以加快速度：
- en: '![ Figure 2.10 – Node creation in the Event Graph with custom event filtered](img/Figure_02.10_B18297.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 使用自定义事件过滤在事件图中创建节点](img/Figure_02.10_B18297.jpg)'
- en: Figure 2.10 – Node creation in the Event Graph with custom event filtered
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 使用自定义事件过滤在事件图中创建节点
- en: 'Call the custom event `PingPongMovement`—this is intended at this point to
    be quite literal as that’s what we are coding:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自定义事件命名为`PingPongMovement`——在这个阶段，它应该是相当字面的，因为这就是我们正在编写的代码：
- en: "![ Figure 2.11 – A custom event node for \uFEFFPingPongMovement\uFEFF](img/Figure_02.11_B18297.jpg)"
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 用于PingPongMovement的自定义事件节点](img/Figure_02.11_B18297.jpg)'
- en: Figure 2.11 – A custom event node for PingPongMovement
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 用于PingPongMovement的自定义事件节点
- en: 'Drag out of the `add timeline`, select `T_MoveBox` when prompted. This will
    give you a timeline node, a special type of node that contains one or more graphs
    that can be used to provide values for other nodes that are called during the
    timeline node’s **Update** chain:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`添加时间线`拖出，当提示时选择`T_MoveBox`。这将为你提供一个时间线节点，这是一种特殊的节点类型，它包含一个或多个可以用于在时间线节点**更新**链中调用其他节点的值的图：
- en: '![Figure 2.12 – A timeline node, named T_MoveBox](img/Figure_02.12_B18297.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 一个名为T_MoveBox的时间线节点](img/Figure_02.12_B18297.jpg)'
- en: Figure 2.12 – A timeline node, named T_MoveBox
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 一个名为T_MoveBox的时间线节点
- en: 'Double-click the **T_MoveBox** node; this will open a new tab to allow us to
    create and edit the graphs in this timeline. Note that the length of the timeline,
    shown at the top of the tab, is 5.0 seconds. This means the timeline will execute
    its update chain for a duration of 5.0 seconds from when it is first called:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**T_MoveBox**节点；这将打开一个新标签页，允许我们创建和编辑此时间线中的图。注意，标签页顶部的**时间线长度**为5.0秒。这意味着时间线将从第一次调用时执行其更新链5.0秒：
- en: '![ Figure 2.13 – An empty timeline tab with default settings](img/Figure_02.13_B18297.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – 默认设置下的空时间线标签页](img/Figure_02.13_B18297.jpg)'
- en: Figure 2.13 – An empty timeline tab with default settings
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 默认设置下的空时间线标签页
- en: Click the **+Track** button and choose **Add** **Float Track**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+Track**按钮，选择**添加****浮点轨道**。
- en: 'Name the track `MovementAlpha`. This will add a float track graph and float
    value output to the timeline node:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将轨道命名为`MovementAlpha`。这将向时间线节点添加一个浮点轨道图和浮点值输出：
- en: '![Figure 2.14 – A float track added to the timeline](img/Figure_02.14_B18297.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – A float track added to the timeline
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the float graph and select **Add Key to CurveFloat_0**; repeat
    this to create a second key.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the first key and, using the `0.0` into both variables.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the second key and set `5.0` and `1.0`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.15 – The MovementAlpha track with linear graph](img/Figure_02.15_B18297.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – The MovementAlpha track with linear graph
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the `MovementAlpha` curve based on the current time of the timeline:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.16 – The timeline node, now with the Movement Alpha float pin](img/Figure_02.16_B18297.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – The timeline node, now with the Movement Alpha float pin
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Position and connect the **Set Relative Location** and **Static Mesh Box** nodes
    from the old solution to the **Update** output pin from the timeline.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the `lerp` to create a **Lerp (Vector)** node. This setup allows us
    to interpolate between two vectors, to control where our box moves, relative to
    the object’s location.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the **Start Point** variable from the left side of the **Blueprint
    Editor** window onto the **A** pin of the **Lerp (Vector)** node. The **A** pin
    is the start value for the lerp.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the **End Point** variable onto the **B** pin of the **Lerp (Vector)**
    node. The **B** pin is the end value for the lerp.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the **Alpha** pin of the **Lerp (Vector)** node to the **Movement Alpha**
    pin of the timeline node:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.17 – The update logic of the timeline completed](img/Figure_02.17_B18297.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – The update logic of the timeline completed
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the update logic is complete, we need to set our Blueprint up to start
    the timeline. To do this, proceed as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Event BeginPlay` node. This is a built-in event that is
    called when an actor is created (either at the beginning of the game or when spawned
    by another function).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag out of the `Ping Pong Movement`; you should now see a **Ping Pong Movement**
    option under the **Call Function** rollout—select it. This will create a call
    to our custom event:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Ping Pong Movement being called from the Event BeginPlay event](img/Figure_02.18_B18297.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Ping Pong Movement being called from the Event BeginPlay event
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'This will now move the box from the start location to the end location in relative
    space; give it a test by placing the `BP_MovingBox_Better` Blueprint from the
    **Content Browser** into the world and clicking the *Play* button above the viewport:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Play in Editor controls from the main Unreal Engine Editor
    user interface](img/Figure_02.19_B18297.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – Play in Editor controls from the main Unreal Engine Editor user
    interface
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to set the Blueprint up so that the box moves back to the start
    location once it has reached the end location and loops indefinitely. To do this,
    proceed as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Detach the **Ping Pong Movement** custom event node from the timeline node by
    holding *Alt* on the keyboard and clicking either end of the connection.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在键盘上按住**Alt**键并点击连接的任一端，从时间线节点断开**Ping Pong Movement**自定义事件节点。
- en: Drag from the `Flip Flop` node. This node swaps between exec pins **A** and
    **B** each time it is entered. The node always starts with **A** for its first
    run. The **bool** pin can be used to inform other logic, but we won’t need that
    for this solution.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**翻转器**节点拖动。每次进入该节点时，该节点会在执行引脚**A**和**B**之间切换。节点总是以**A**作为其第一次运行的起始。可以使用**bool**引脚来通知其他逻辑，但在这个解决方案中我们不需要它。
- en: Connect the **A** pin of the **Flip Flop** node to the **Play from Start** pin
    of the **T_MoveBox** timeline node.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**翻转器**节点的**A**引脚连接到**T_MoveBox**时间线节点的**从开始播放**引脚。
- en: 'Connect the **B** pin of the **Flip Flop** node to the **Reverse from End**
    pin of the **T_MoveBox** timeline node:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**翻转器**节点的**B**引脚连接到**T_MoveBox**时间线节点的**从结束反转**引脚：
- en: '![Figure 2.20 – Flip Flop node and timeline](img/Figure_02.20_B18297.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图2.20 – 翻转器节点和时间线](img/Figure_02.20_B18297.jpg)'
- en: Figure 2.20 – Flip Flop node and timeline
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 – 翻转器节点和时间线
- en: 'Lastly, connect the **Finished** pin of the timeline node to a **Ping Pong
    Movement** function call node (either the existing one or a new one), which will
    restart the process every time it finishes:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将时间线节点的**完成**引脚连接到一个**Ping Pong Movement**函数调用节点（现有的或新的），每次它完成时都会重新启动该过程：
- en: '![Figure 2.21 – The improved Blueprint for the moving box, laid out for readability
    in the editor](img/Figure_02.21_B18297.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图2.21 – 移动盒子的改进蓝图，在编辑器中布局以提高可读性](img/Figure_02.21_B18297.jpg)'
- en: Figure 2.21 – The improved Blueprint for the moving box, laid out for readability
    in the editor
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 – 移动盒子的改进蓝图，在编辑器中布局以提高可读性
- en: Now, try pressing the *Play* button in the editor (the *Play* button above the
    viewport) again. You should now see that the box moves in one direction and then
    the other, over and over.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试再次在编辑器中按下**播放**按钮（视口上方的**播放**按钮）。你应该现在看到盒子在一个方向上移动，然后又回到另一个方向，反复进行。
- en: This approach offers a more performant solution due to not requiring the comparison.
    The update logic is still constantly running, in the same way as the tick approach
    was for the **Set Relative Location** node, but because the timeline controls
    when the direction change occurs, we no longer need to do any comparisons of vector
    locations after every move.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法由于不需要比较，因此提供了更高效的解决方案。更新逻辑仍然持续运行，就像**设置相对位置**节点在tick方法中运行一样，但由于时间线控制方向变化发生的时间，我们不再需要在每次移动后进行任何向量位置的比较。
- en: The timeline can also afford us more control over situations when we want to
    move things. The current setup features linear movement controlled by the linear
    curve. Changing the key types to automatic (right-click the key) or adding additional
    keys can provide more interesting movements and allow you to incorporate considerations
    such as the principles of animation into your moving objects, something that is
    very difficult to do without using a curve.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线还可以让我们在想要移动物体时拥有更多的控制。当前的设置具有由线性曲线控制的线性运动。将关键类型更改为自动（右键单击关键点）或添加额外的关键点可以提供更有趣的运动，并允许你将动画原理等考虑因素纳入你的移动对象中，这是在不使用曲线的情况下非常难以做到的。
- en: The rotating box problem
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转盒子问题
- en: 'The second example we’re going to look at is a simple rotating box. The Blueprint
    actor contains the same static mesh component, but this time it’s set up to spin
    in place 2 degrees of rotation on each tick:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第二个示例是一个简单的旋转盒子。蓝图演员包含相同的静态网格组件，但这次它被设置为在每次tick时原地旋转2度：
- en: '![Figure 2.22 – The rotating box Blueprint code](img/Figure_02.22_B18297.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图2.22 – 旋转盒子的蓝图代码](img/Figure_02.22_B18297.jpg)'
- en: Figure 2.22 – The rotating box Blueprint code
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 – 旋转盒子的蓝图代码
- en: 'The Blueprint code also does a check for when the rotation of the box gets
    to 360 degrees or above and minuses 360 from the rotation value, to ensure that
    we keep the rotation value from spiraling out of control as the game plays:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图代码还检查当盒子的旋转达到360度或以上时，从旋转值中减去360度，以确保在游戏进行时旋转值不会失控螺旋：
- en: '![Figure 2.23 – The check to maintain rotations between 0 and 360 degrees](img/Figure_02.23_B18297.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图2.23 – 维持0到360度之间旋转的检查](img/Figure_02.23_B18297.jpg)'
- en: Figure 2.23 – The check to maintain rotations between 0 and 360 degrees
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 – 维持0到360度之间旋转的检查
- en: The check that’s been put in place is relatively sensible, and if it were part
    of a single rotation or working with a character rotation within an animation
    Blueprint, then it would be ideal.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this implementation is that we are once again working on tick
    and doing checks that will become more cumbersome with every additional rotating
    box.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Solution to the rotating box problem
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the rotating box, the solution is to use a pre-existing solution. Instead
    of coding differently, we can use a component that is provided as part of UE5
    to achieve the desired result. Follow the next steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, delete all of the logic from the **Event Graph**, it is not required.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Components** tab, click the **Add** button and search for a **Rotating**
    **Movement** component:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.24 – Rotating Movement component selected in the Add components
    list](img/Figure_02.24_B18297.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Figure 2.24 – Rotating Movement component selected in the Add components list
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Create a new variable by clicking the **+** in the **Variables** rollout of
    the **My** **Blueprint** tab.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the variable `Rotation Rate` and set the type to `Rotator` by clicking
    on the current type (typically **Boolean** if you are working with a new Blueprint)
    and selecting **Rotator** from the list.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the variable **Instance Editable** by clicking the *eye* icon to the right
    of the variable type—this will allow the user to set the rotation rate of each
    box in the scene.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the Blueprint and set the default value of the `0,0,180`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.25 – Resulting variables list in the My Blueprint tab](img/Figure_02.25_B18297.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: Figure 2.25 – Resulting variables list in the My Blueprint tab
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Set Rotation Rate` node. Connect the **Rotation Rate** variable you
    just created to the **Rotation** **Rate** pin:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.26 – Construction script logic, setting the Rotating Movement component’s
    Rotation Rate using the created variable](img/Figure_02.26_B18297.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Figure 2.26 – Construction script logic, setting the Rotating Movement component’s
    Rotation Rate using the created variable
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Now, when placing `BP_RotatingBox_Better` into the world, you will be able to
    set the **Rotation Rate** value in the **Defaults** section of the **Detail**
    panel. Try placing multiple boxes and setting different values. When you press
    the *Play* button in **Editor**, you should see the boxes rotating as desired.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: This solution offers a more performant approach again due to its lack of reliance
    on **Event Tick** as well as the removal of the comparison checking when the rotation
    exceeds 360 degrees in order to maintain values inside the 0-360 range.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of this approach is that we now have an **Instance Editable**
    variable for rotation rate, which offers much more control and customization to
    the user, allowing each box to have its own rotation rate. The variable also allows
    us to spin the box on all three axes, whereas the original approach only rotated
    the box around the *z* (yaw) axis.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The cascading cast chain problem
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 级联铸链问题
- en: This example is something we see quite regularly with new developers when communicating
    between different Blueprint classes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是我们经常在新开发者之间通信时看到的情况。
- en: 'The implementation here is for a game where a player character could be carrying
    one of three weapons: a pistol, shotgun, or rifle. Casts have been used to identify
    the class of the carried weapon, and when the cast returns true, each weapon’s
    fire event is called:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的实现是为了一个游戏，玩家角色可能携带三把武器中的一把：手枪、霰弹枪或步枪。铸被用来识别携带武器的类，当铸返回 true 时，会调用每个武器的射击事件：
- en: '![Figure 2.27 – A cascading cast chain in the Blueprint in the CH_Example_Bad
    asset](img/Figure_02.27_B18297.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.27 – CH_Example_Bad 资产中蓝图中的级联铸链](img/Figure_02.27_B18297.jpg)'
- en: Figure 2.27 – A cascading cast chain in the Blueprint in the CH_Example_Bad
    asset
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27 – CH_Example_Bad 资产中蓝图中的级联铸链
- en: There are a few issues here. Firstly, it is the nature of the cast node in Unreal.
    While fine for prototyping, casts carry a resource impact where each actor we
    attempt to cast to gets loaded as part of the actor. So, in this case, all three
    weapons are included with the character in order to be able to check if the **Carried
    Weapon** child actor matches their classes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个问题。首先，这是 Unreal 中铸节点（cast node）的特性。虽然对于原型设计来说很好，但铸操作会带来资源影响，其中我们尝试铸到的每个演员都会作为演员的一部分被加载。因此，在这种情况下，所有三把武器都包含在角色中，以便能够检查**携带武器**子演员是否与它们的类匹配。
- en: You can see the effect of casts on memory by checking the size map of any actor.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查任何演员的大小图来查看铸对内存的影响。
- en: 'To do this, proceed as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请按照以下步骤操作：
- en: Select the **Actor** Blueprint in the **Content Browser**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**中选择**演员**蓝图。
- en: Right-click and select **Size Map…**.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择**大小图…**。
- en: 'This will open a popup that will show the size (in memory) of the chosen actor:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个弹出窗口，显示所选演员的大小（内存中）：
- en: '![Figure 2.28 – Size map of the character Blueprint class with a cascading
    cast chain](img/Figure_02.28_B18297.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.28 – 具有级联铸链的角色蓝图类的大小图](img/Figure_02.28_B18297.jpg)'
- en: Figure 2.28 – Size map of the character Blueprint class with a cascading cast
    chain
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.28 – 具有级联铸链的角色蓝图类的大小图
- en: 'The resulting Blueprint (which only has the basic character class elements
    and the cast chain) is 149.9 kB, compared to the 56.1 kB of a standard character
    with just the child actor set as a pistol. This could be made smaller, further
    optimizing the Blueprint’s memory impact, by setting the default class of the
    child actor to be actor, but this isn’t necessary to prove the point we are trying
    to make; casting causes unnecessary memory issues:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的蓝图（仅包含基本角色类元素和铸链）大小为 149.9 kB，而一个标准角色（仅将子演员设置为手枪）的大小为 56.1 kB。通过将子演员的默认类设置为演员，可以进一步减小大小，从而优化蓝图对内存的影响，但这并不是证明我们试图证明的观点所必需的；铸操作会导致不必要的内存问题：
- en: '![Figure 2.29 – Size map of a character Blueprint class with just a child actor
    component](img/Figure_02.29_B18297.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.29 – 具有仅一个子演员组件的角色蓝图类的大小图](img/Figure_02.29_B18297.jpg)'
- en: Figure 2.29 – Size map of a character Blueprint class with just a child actor
    component
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29 – 具有仅一个子演员组件的角色蓝图类的大小图
- en: In both examples shown previously, the `Wpn_Pistol` class is just an empty actor
    with a custom event that would, in an eventual game, fire the weapon; however
    the class currently only contains a `Fire`. If you consider adding meshes, textures,
    particle systems, and audio components, the potential size of a character with
    a cascading cast chain becomes exponentially larger than it needs to be.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面显示的这两个例子中，`Wpn_Pistol` 类只是一个带有自定义事件（在最终游戏中将射击武器）的空演员；然而，该类目前只包含一个 `Fire`。如果您考虑添加网格、纹理、粒子系统和音频组件，具有级联铸链的角色潜在的大小将比实际需要的大得多。
- en: The second issue is the processing time of casting and waiting for failure before
    casting to the next weapon class and potentially waiting for that to fail. While
    we are talking milliseconds, it all adds up, especially if there are multiple
    characters and/or your non-player characters use the same character Blueprint.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是铸操作的处理时间以及铸到下一个武器类之前的等待失败时间。虽然我们谈论的是毫秒，但所有这些都会累积起来，尤其是如果有多个角色，或者你的非玩家角色使用相同的角色蓝图。
- en: The final issue with the cascading cast chain is the inflexibility (or extra
    work) that this approach provides. With the current setup, only the three weapons
    included in the chain can ever be used by the character. To expand the number
    of available weapons (as the project progresses or as part of a post-release piece
    of downloadable content), more casts will need to be added to the chain, multiplying
    the effects of the two aforementioned issues as well as being generally time-consuming
    to add them, particularly if there is any other logic required as part of the
    chain such as ammo management and cooldowns.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 递归转换链的最后一个问题是这种方法的灵活性（或额外的工作）。在当前设置中，只有链中包含的三种武器可以被角色使用。为了增加可用武器的数量（随着项目的进展或作为发布后的可下载内容的一部分），需要在链中添加更多的转换，这将放大上述两个问题的效果，并且添加它们通常很耗时，尤其是如果链中需要任何其他逻辑，如弹药管理和冷却时间。
- en: If you want to see the current setup’s output, then open the `TestLevel` map
    from the `TestFiles` directory, click *Play*, and then click the left mouse button;
    you will see a print in the top-left corner of the screen related to each weapon.
    Pressing the *1*, *2*, and *3* keys on your keyboard will swap between different
    weapon classes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看当前设置的输出，那么从 `TestFiles` 目录打开 `TestLevel` 地图，点击 *播放*，然后点击鼠标左键；你将在屏幕的左上角看到与每个武器相关的打印信息。按下键盘上的
    *1*、*2* 和 *3* 键将在不同的武器类之间切换。
- en: Let’s take a look at the solution to this problem.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个问题的解决方案。
- en: Solution to the cascading chain problem
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决递归链问题的方案
- en: There are two potential solutions to the problem; the first is to use a parent
    and child class approach, casting to the parent class, which will allow **Event
    Fire** to be called on all of the children. As this still uses a cast, the parent
    class will still be included in the character, inflating the memory usage.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，有两种潜在的解决方案；第一种是使用父类和子类方法，转换到父类，这将允许在所有子类上调用**事件 Fire**。由于这仍然使用转换，父类仍然包含在角色中，增加了内存使用量。
- en: The second solution, which we are going to implement, is using an interface.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个解决方案，我们将要实施的是使用一个接口。
- en: Interfaces allow two actors to communicate, without the need to identify the
    class type of the target actor.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接口允许两个演员进行通信，而无需识别目标演员的类类型。
- en: Blueprint interfaces can be called from any Blueprint graph using an actor reference
    (which is the highest step of the class hierarchy). The receiving actor is required
    to implement the interface to define how it will respond to the interface event
    call.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图接口可以通过任何蓝图图使用演员引用（这是类层次结构中的最高级别）来调用。接收演员需要实现接口以定义它将如何响应接口事件调用。
- en: 'In building this solution, we will create a simple Blueprint interface, add
    it to all of the weapons, and call it from the character, simply referencing the
    weapon as an actor class, negating the need for casting. Proceed as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这个解决方案时，我们将创建一个简单的蓝图接口，将其添加到所有武器中，并从角色中调用它，简单地将武器作为演员类引用，从而消除了类型转换的需要。按照以下步骤进行：
- en: Firstly, create a Blueprint interface by right-clicking in the `BI_Weapon`.
    We use the prefix `BI` to label this as a Blueprint interface.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过在`BI_Weapon`中右键单击来创建一个蓝图接口。我们使用前缀`BI`来标记这是一个蓝图接口。
- en: Open the `Fire`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Fire`。
- en: 'Open `BI_Weapon`. Clicking it will add the **BI Weapon** interface to the **Implemented**
    **Interfaces** list:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `BI_Weapon`。点击它将**BI 武器**接口添加到**实现**的**接口**列表中：
- en: '![Figure 2.30 – BI Weapon in the Implemented Interfaces list](img/Figure_02.30_B18297.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.30 – 实现接口列表中的 BI 武器](img/Figure_02.30_B18297.jpg)'
- en: Figure 2.30 – BI Weapon in the Implemented Interfaces list
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.30 – 实现接口列表中的 BI 武器
- en: 'This will now have added a **Fire** function under the **Interfaces** rollout
    in the **My Blueprint** tab. Double-click it; this will create an **Event Fire**
    interface event:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在“我的蓝图”选项卡下的“接口”卷展栏中已经添加了一个**Fire**函数。双击它；这将创建一个**事件 Fire**接口事件：
- en: '![Figure 2.31 – The Event Fire interface event, denoted by the interface icon
    over the top-right corner](img/Figure_02.31_B18297.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.31 – 事件 Fire 接口事件，由右上角的接口图标表示](img/Figure_02.31_B18297.jpg)'
- en: Figure 2.31 – The Event Fire interface event, denoted by the interface icon
    over the top-right corner
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.31 – 事件 Fire 接口事件，由右上角的接口图标表示
- en: Drag out from the `Print String` node, then replace `Pistol –` `Interface Fire`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Print String` 节点拖出，然后替换为 `Pistol –` `Interface Fire`。
- en: Repeat *steps 3 to 5* on both the **Wpn_Rifle** and **Wpn_Shotgun** assets,
    changing the **Print String** node to include the name of each weapon.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Wpn_Rifle**和**Wpn_Shotgun**资产上重复*步骤3到5*，将**打印字符串**节点更改为包含每件武器的名称。
- en: Duplicate the **CH_Example_Bad** asset and rename it **CH_Example_Better**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**CH_Example_Bad**资产并将其重命名为**CH_Example_Better**。
- en: Open **CH_Example_Better** and delete all of the nodes from the **InputAction
    PrimaryAction** logic flow, except for the **Carried Weapon** and **Target Child**
    **Actor** nodes.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**CH_Example_Better**并从**InputAction PrimaryAction**逻辑流程中删除所有节点，除了**携带武器**和**目标子****演员**节点。
- en: 'Drag from the `Fire (Message)`; this will create a **Fire** interface event
    call, which will be called on whichever class is currently set as the **Carried**
    **Weapon** class:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Fire (Message)`拖动；这将创建一个**Fire**接口事件调用，它将在当前设置为**携带****武器**类的任何类上被调用：
- en: '![Figure 2.32 – The resulting InputAction PrimaryAction Blueprint logic with
    the interface call](img/Figure_02.32_B18297.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图2.32 – 使用接口调用的结果InputAction PrimaryAction蓝图逻辑](img/Figure_02.32_B18297.jpg)'
- en: Figure 2.32 – The resulting InputAction PrimaryAction Blueprint logic with the
    interface call
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.32 – 使用接口调用的结果InputAction PrimaryAction蓝图逻辑
- en: In order to test this approach, we need to swap the `TestLevel` map to the better
    example we’ve just created.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这种方法，我们需要将`TestLevel`映射交换到我们刚刚创建的更好的例子上。
- en: Open `GM_Test` from the `TestFiles` directory in the **Content Browser**.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**内容浏览器**中的`TestFiles`目录打开`GM_Test`。
- en: Change the **Default Pawn Class** dropdown to **CH_Example_Better**.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**默认Pawn类**下拉菜单更改为**CH_Example_Better**。
- en: Now, when you play the level and click the left mouse button, you will see the
    new interface prints.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你玩这个关卡并点击左鼠标按钮时，你会看到新的接口打印出来。
- en: The outcome we have achieved is essentially the same as before; however, the
    code used to achieve it is tidier, faster, uses less memory, and is infinitely
    expandable by avoiding casts and using the interface.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所取得的结果基本上与之前相同；然而，实现它的代码更整洁、更快、使用更少的内存，并且通过避免强制转换并使用接口而无限可扩展。
- en: The trade-off
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权衡
- en: With any implementation of a pattern or fix, there is a trade-off between what
    you gain and what it costs, and it’s important to consider the long-term effects
    when implementing patterns.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何模式的实现或修复中，你获得的东西和它所付出的代价之间有一个权衡，在实现模式时考虑长期影响是很重要的。
- en: In many of the cases we are exploring, the gain is simplicity, readability,
    or a reduction in memory footprint, which should help your game to run smoothly.
    These are all key elements worth maintaining a good code base for. The cost is
    often time. Some patterns may take longer to implement, and, in some cases, having
    to refactor code to work in a specific way can use up valuable time.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索的大多数情况下，收益是简单性、可读性或内存足迹的减少，这应该有助于你的游戏顺利运行。这些都是值得维护良好代码库的关键元素。代价通常是时间。某些模式可能需要更长的时间来实现，在某些情况下，为了以特定方式重构代码可能会消耗宝贵的时间。
- en: The long-term effects, however, outweigh the initial time cost as the time saved
    later in development to build on top of or into existing systems will prove beneficial
    later in your game’s development cycle.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，长期效果超过了初始时间成本，因为后来在开发过程中节省的时间用于构建在现有系统之上或之内将证明在游戏开发周期后期是有益的。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the S.O.L.I.D. principles that underpin good code,
    exploring specific examples and how, as they expand in complexity, we need to
    consider these principles to keep the code functioning. These principles are widely
    recognized across the game development industry, and so understanding them will
    not only help improve code efficiency and readability but also allow smooth communication
    with co-developers on larger projects.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了支撑良好代码的S.O.L.I.D.原则，探讨了具体示例以及随着复杂性的增加，我们需要考虑这些原则以保持代码的功能。这些原则在游戏开发行业中得到了广泛认可，因此理解它们不仅有助于提高代码效率和可读性，还允许在大型项目中与共同开发者进行顺畅的沟通。
- en: We also explored a series of common problems that new Unreal Engine users encounter
    and the solutions to them, looking specifically at a series of common tasks such
    as moving items and managing a selection of weapons on a character. The solutions,
    while specific, offer insights into how easily a developer can find themselves
    with large, lumbering Blueprints that can be solved by utilizing built-in systems
    and tools.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探索了一系列新用户在使用虚幻引擎时遇到的问题及其解决方案，具体关注了一系列常见任务，例如移动物品和管理角色上的武器选择。虽然这些解决方案是具体的，但它们提供了开发者如何轻易地发现自己陷入大型、笨重的蓝图中的见解，这些蓝图可以通过利用内置系统和工具来解决。
- en: In the next chapter we will be taking these principles of clean code and seeing
    how Epic Games have applied them through the engine when we look at some of the
    patterns they have built for us. The utility of the engine as it were. These patterns
    will include double buffer, flyweight and spatial partitioning.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨这些清洁代码的原则，并查看艺电（Epic Games）是如何通过引擎将这些原则应用到他们为我们构建的一些模式中的。从某种意义上说，这是引擎的实用性。这些模式将包括双缓冲、享元和空间划分。
