- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “Hello Patterns”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on the principles that underpin all good code. Design
    patterns are an extension of these principles, so it is important to walk before
    you run. Once the basics have been covered, we’ll look at some bad Blueprint code
    so that we can understand the process of fixing it, which we will do by following
    some step-by-step guides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: S.O.L.I.D. principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring solutions to common problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trade-off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need a blank UE5 project open and ready. There's
    no need for C++ right now; we’ll be focusing on Blueprint code for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: The files for this project can be found in the `chapter2` branch on GitHub at
    [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter02](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter02)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve not created a blank UE5 project before, the following steps will
    take you through creating a simple Blueprint project, which is all we need for
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Launch** button in the top right of the **Epic Launcher** | **Unreal
    Engine** | **Library** tab, where we installed the engine in the first chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Games** on the left side of the **Unreal** **Project Browser**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Blank** from the main section, and toggle **Starter Content** off.
    This will prevent Unreal from adding a bunch of unrequired assets to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose a sensible location (the default is fine) and set the project name as
    `HelloPatterns`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The Unreal Project Browser with a new, blank games project set
    up for creation](img/Figure_02.01_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The Unreal Project Browser with a new, blank games project set
    up for creation
  prefs: []
  type: TYPE_NORMAL
- en: Click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you have your project set up, you are ready for the interactive part of
    this chapter, but first, let’s discuss what we mean when we say *good code*.
  prefs: []
  type: TYPE_NORMAL
- en: S.O.L.I.D. principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand why design patterns work, we need to understand the principles
    that underpin good code. Let’s run a whistle-stop tour through most people’s first
    experience with code.
  prefs: []
  type: TYPE_NORMAL
- en: The universal *Hello World* program and the beginner exercises that follow are
    all made up of linear code. Linear code executes each line sequentially through
    a single file in which the whole program is written. Loops, selections, and statements
    make up literally everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'As each program gets larger, the code becomes unsustainable. The solution is
    object orientation. **Object-oriented programming** (**OOP**) adds a lot, primarily
    classes and objects, as the name would suggest. With OOP’s added complexity, it
    becomes quite easy to accidentally build in fundamental issues with systems that
    make it impossible to expand them. Having a set of rules to follow greatly simplifies
    the process of building code that works for you and the next person to maintain
    it. These rules take the form of the **S.O.L.I.D.** principles, which are defined
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: S – **Single responsibility**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: O – **Open-closed**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: L – **Liskov substitution**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I – **Interface segregation**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D – **Dependency inversion**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single responsibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Agile Software Development: Principles, Patterns, and Practices*, Robert
    C. Martin said the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A class should have one and only one reason to change, meaning that a class
    should have only one job.
  prefs: []
  type: TYPE_NORMAL
- en: Each class should *do what it says on the tin*—or, in this case, the class name.
    If you were hiring a plumber, you wouldn’t expect that plumber to also recite
    *Hamlet* while fixing the pipes. The same is true for code; if you have a math
    library class, you expect it to take numbers in and return the results after performing
    some equations. What you don’t expect is for it to use these numbers as a seed
    to generate an image, which it sets as your desktop background. Granted, this
    is an extreme case that may even be considered a virus, but the point stands.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a class that does what is expected by its name helps when working in
    a team. Games can become quite large with many interconnected systems, and if
    a developer can understand what a class is responsible for and how to operate
    it, from just function and class names, then time is saved. Implementation can
    be as simple as consistent naming conventions combined with compartmentalized
    functionality. For instance, a function called `AddItem(ItemType type, int amount)`
    on an inventory component in the object used for our player probably adds an amount
    of an item to the inventory of the player. You don’t need to open the function
    to see what it does due to this clear naming.
  prefs: []
  type: TYPE_NORMAL
- en: Open-closed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Agile Software Development: Principles, patterns, and practices*, Robert
    C. Martin said:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects or entities should be open for extension but closed for modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'New functionality should be easy to create, without needing to modify the existing
    code. It is easy to see this in action through something like a save system. If
    you want to port your game to multiple platforms, then it would make sense to
    have a different `save` method for each. To start with, there are two target platforms
    (PC and Xbox); the save system might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Example SaveClass.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Somewhere down the line, you decide to extend the system to also work on PlayStation.
    This is another platform to handle. The modification seems easy—just add a new
    case to the ever-expanding statement. Therein lies the problem; the more platforms
    we support, the longer this will get, and the more time and memory the function
    will occupy:'
  prefs: []
  type: TYPE_NORMAL
- en: Example SaveClass.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is to spin the `save` function into an abstract function with
    an overriding child class function for each platform shown in *Figure 2**.2*.
    This not only means new platforms can be added with a new child class but also,
    we don’t have to instantiate versions of the save system we will never use, saving
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.2 – UML diagram showing inheritance of a \uFEFFSaveClass\uFEFF instance\
    \ with the open-closed principle applied](img/Figure_02.02_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – UML diagram showing inheritance of a SaveClass instance with the
    open-closed principle applied
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at Liskov substitution.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Agile Software Development: Principles, Patterns, and Practices*, Robert
    C. Martin said the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Let q(x) be a property provable about objects of x of type T. Then q(y) should
    be provable for objects y of type S where S is a subtype of T.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, if there is a child class in use within your code, you should
    be able to swap it out for any of its siblings without modifying the structure
    of the calling code or using variables for unintended purposes. In the previous
    example, we turned a save system into a parent-child structure. If we were to
    add cloud saving, we would no longer have a file path to send data to and instead,
    we would use an IP address. Well, we could make this work by just piping the IP
    address through the file path argument as shown in the following exerpt but this
    is a violation of our naming convention. Undoubtedly, someone down the line will
    need to use this function and won’t understand what they need to do. Plus, any
    data not in the requested type will have to be converted by the calling object,
    sent, and then parsed inside the child implementation, which wastes time:'
  prefs: []
  type: TYPE_NORMAL
- en: Excerpt from a program calling a save system
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix for this principle is to make the variable that may change a member
    of the child class. That way, initialization functions can deal with making sure
    the correct data is asked for, and we can easily swap out `save` objects as needed.
    This also means the abstract functionality from the parent can be called the same
    way wherever it is used, making for easier maintenance as systems grow:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.3 – UML diagram showing inheritance of\uFEFF SaveClass\uFEFF with\
    \ Liskov substitution principle applied](img/Figure_02.03_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – UML diagram showing inheritance of SaveClass with Liskov substitution
    principle applied
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we apply the Liskov substitution to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Excerpt from a program calling the better save system
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the calls become the same format and are therefore substitutable
    and satisfy the principle.
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Agile Software Development: Principles, Patterns, and Practices*, Robert
    C. Martin said the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A client should never be forced to implement an interface that it doesn’t use,
    or clients shouldn’t be forced to depend on methods they do not use.
  prefs: []
  type: TYPE_NORMAL
- en: If the parent defines an abstract function, the child must override it. This
    causes issues when implementing an abstract function for some of the child classes
    as the other children that don’t need that functionality must override to immediately
    nullify it. The solution can either be to extend the inheritance so that there
    is another layer for the classes in need of this extra functionality or to create
    an interface (only available in multi-inheritance languages) that adds the functionality
    to certain subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the save system, if you need to get account authorization before
    saving on Xbox and PlayStation, then this can be done via inheritance. A new sub-class
    of `Save` can be made, which declares an abstract function for getting authorization.
    This then becomes the parent for each save system that needs the function:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.4 – UML diagram showing \uFEFFSaveClass\uFEFF inheritance with interface\
    \ segregation applied through pure inheritance](img/Figure_02.04_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – UML diagram showing SaveClass inheritance with interface segregation
    applied through pure inheritance
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we apply the concept of interface segregation to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Excerpt from a program that checks authentication before saving
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Technically, the structure shown in *Figure 2**.4* will violate the previous
    Liskov substitution principle as sub-classes that don’t inherit from the middle
    *interface* layer can’t be substituted into the pattern. Deciding which principle
    is more important is part of the skill of designing code and is usually learned
    with practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this inheritance structure does satisfy the **interface segregation**
    principle, it does end up getting quite messy with lots of segregated behaviors.
    There is another way. Applying the first principle of single responsibility to
    this tree, we remove each segregated behavior into its own class. Objects of this
    can then be created and injected into the save system where needed. The result
    is more independent classes, but cleaner, smaller inheritance structures. This
    is what is known as using **class composition** to solve a structure problem:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.5 – UML diagram showing \uFEFFSaveClass\uFEFF alongside \uFEFFAuth\uFEFF\
    \ hierarchy](img/Figure_02.05_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – UML diagram showing SaveClass alongside Auth hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we apply class composition to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Excerpt of a program that implements Figure 2.5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `SaveSomeData` function would then check the authorized status of the `Auth`
    type object as it needs to.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Agile Software Development: Principles, Patterns, and Practices*, Robert
    C. Martin said the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Entities must depend on abstractions, not on concretions. It states that the
    high-level module must not depend on the low-level modules, but they should depend
    on abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is the most useful for UE5\. Simply put, if you inject a reference
    to a class somewhere, it really should be the highest-level abstract parent that
    still has the functionality you need. Easy examples would be in a PlayerController,
    where you don’t reference a specific pawn sub-class but, instead, the idea of
    a pawn. Better than that, you could reference the interface for the functionality
    you need; this will prevent long cast chains to filter for the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the save example, the injection of the account authorizer is a concretion
    that assumes every `save` module will authorize in the same way. In reality, it
    would be much more appropriate to inject an `Authorizer` parent that only contains
    the authorized status. When creating an object to inject, we then create it as
    the correct sub-class and call its `Authorize` function, which is free to then
    operate as it needs to. You can even reuse this structure for authorization of
    other things elsewhere too:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.6 – UML diagram showing \uFEFFSaveClass\uFEFF alongside \uFEFFAuth\uFEFF\
    \ hierarchy](img/Figure_02.06_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – UML diagram showing SaveClass alongside Auth hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we apply dependency inversion to our code, it would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: Excerpt of a program that implements Figure 2.6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That’s a lot of theory to have gone through, but with it, we can make tangible
    improvements to dire systems. These improvements should shore up the foundations
    of our code, setting it up to receive the more structure-heavy patterns we will
    be using later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will guide you through an average beginner developer’s process
    of creating a project and getting something working quickly so that you can then
    apply what you have learned to see a tangible improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring solutions to common problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to explore a series of examples of Blueprint scripts where the
    intended result has been achieved but causes issues simply due to the approach
    taken. We will then offer an improved approach, which makes the Blueprint more
    performant, tidier, more reusable, or easier to expand at a later point in development.
    The purpose of this section is to help you begin to recognize potential areas
    for improvement within your own code, regardless of whether you are working in
    Blueprint or C++.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Everything we are about to look at in this section is bad code to prove a point.
    Even the fixes that follow are not perfect, but it has been written for the purpose
    of education and so is simplified somewhat.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, you will need an empty project that you may have already created
    at the beginning of the chapter and the `content` folder from the `chapter2` branch
    of the GitHub link provided at the start of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve not used GitHub before, click the `.zip` folder that you can then
    extract into your new project folder.
  prefs: []
  type: TYPE_NORMAL
- en: Place the `HelloPatterns` folder from `.zip` file directly into your content
    directory; this will provide you with some examples of bad practises that we will
    first review before explaining how to fix them.
  prefs: []
  type: TYPE_NORMAL
- en: To fix the problems, first, duplicate each of the Blueprint assets and change
    the suffix from `_Bad` to `_Better`. This will ensure you can look back and see
    the differences between where we start and where we finish when reworking these
    Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: To start fixing these Blueprints, you will need to open them by double-clicking
    on them in the **Content Browser**. Once open, navigate to the **Event Graph**
    tab where you will find the examples we’ve covered. Follow the steps under each
    of the **Solution** headings to improve the Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: The moving box problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first example we’re going to look at is a simple moving box (a static mesh
    component) that slides from a start location (relative `0`,`0`,`50`) to an end
    location (relative `200`,`0`,`50)`. Both locations have been stored as vector
    variables within the Blueprint and their defaults set, as mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are using relative location, a vector variable that defines the location
    of an entity based on the location of its parent. A relative location of (0,0,50)
    on a component whose parent actor is positioned at (0,0,0) in the world would
    also be (0,0,50) in the world. However, if the parent actor were to move to (10,10,0),
    the component’s world location would be (10,10,50) as the world and relative locations
    are combined to provide a world location for the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Blueprint code to move the box has two logic chains selected via a branch
    node (Blueprint’s version of an `if` statement) using `Update` loop). One logic
    chain is used to move the box forward, from start to end, and the other is used
    to move it back. The decision of which to use is controlled by the **Forward**
    Boolean variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – The Event Tick Branch for selecting which direction to move](img/Figure_02.07_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – The Event Tick Branch for selecting which direction to move
  prefs: []
  type: TYPE_NORMAL
- en: The *move forward* logic chain adds 1 cm to the *x* coordinate of the box’s
    relative location and updates the position of the box, relative to the actor using
    a **Set Relative** **Location** node.
  prefs: []
  type: TYPE_NORMAL
- en: 'A check then takes place, comparing the current relative location to the end
    point with a 0.0 error tolerance. If the locations are equal, then **Forward**
    is set to **False**, which means on the next tick, the branch will select the
    reverse logic change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The move forward logic chain for the moving box](img/Figure_02.08_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – The move forward logic chain for the moving box
  prefs: []
  type: TYPE_NORMAL
- en: 'The *move backward* logic chain subtracts 1 cm from the *x* coordinate of the
    box’s relative location and updates the position in the same way. The difference
    here is that the check compares the relative location to the end point and, when
    they are equal, sets **Forward** to **True**, flicking the branch to the *move
    forward* logic on the next tick. This repeats indefinitely or until the actor
    is destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – The move backward logic chain for moving the box](img/Figure_02.09_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – The move backward logic chain for moving the box
  prefs: []
  type: TYPE_NORMAL
- en: The issue we have here is we are checking on every tick if the box has arrived
    at its destination. Doing the comparison on one box may not cause many issues,
    but if you are moving a lot of items in a scene, this sort of innocent calculation
    is a waste of resources, something we are keen to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Solution to the moving box problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at building a better approach using a timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin by deleting all of the nodes in the **Event Graph**, except for the **Set
    Relative Location** and **Static Mesh** **Box** nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by adding a custom event node by right-clicking on the graph, typing
    `custom event`, and pressing *Enter*. You can select the **Add Custom Event…**
    option at any point; typing more of the name will simply help reduce the options
    available, hopefully speeding things up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![ Figure 2.10 – Node creation in the Event Graph with custom event filtered](img/Figure_02.10_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Node creation in the Event Graph with custom event filtered
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the custom event `PingPongMovement`—this is intended at this point to
    be quite literal as that’s what we are coding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![ Figure 2.11 – A custom event node for \uFEFFPingPongMovement\uFEFF](img/Figure_02.11_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – A custom event node for PingPongMovement
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag out of the `add timeline`, select `T_MoveBox` when prompted. This will
    give you a timeline node, a special type of node that contains one or more graphs
    that can be used to provide values for other nodes that are called during the
    timeline node’s **Update** chain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.12 – A timeline node, named T_MoveBox](img/Figure_02.12_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – A timeline node, named T_MoveBox
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click the **T_MoveBox** node; this will open a new tab to allow us to
    create and edit the graphs in this timeline. Note that the length of the timeline,
    shown at the top of the tab, is 5.0 seconds. This means the timeline will execute
    its update chain for a duration of 5.0 seconds from when it is first called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![ Figure 2.13 – An empty timeline tab with default settings](img/Figure_02.13_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – An empty timeline tab with default settings
  prefs: []
  type: TYPE_NORMAL
- en: Click the **+Track** button and choose **Add** **Float Track**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the track `MovementAlpha`. This will add a float track graph and float
    value output to the timeline node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.14 – A float track added to the timeline](img/Figure_02.14_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – A float track added to the timeline
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the float graph and select **Add Key to CurveFloat_0**; repeat
    this to create a second key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the first key and, using the `0.0` into both variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the second key and set `5.0` and `1.0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.15 – The MovementAlpha track with linear graph](img/Figure_02.15_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – The MovementAlpha track with linear graph
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the `MovementAlpha` curve based on the current time of the timeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.16 – The timeline node, now with the Movement Alpha float pin](img/Figure_02.16_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – The timeline node, now with the Movement Alpha float pin
  prefs: []
  type: TYPE_NORMAL
- en: Position and connect the **Set Relative Location** and **Static Mesh Box** nodes
    from the old solution to the **Update** output pin from the timeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the `lerp` to create a **Lerp (Vector)** node. This setup allows us
    to interpolate between two vectors, to control where our box moves, relative to
    the object’s location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the **Start Point** variable from the left side of the **Blueprint
    Editor** window onto the **A** pin of the **Lerp (Vector)** node. The **A** pin
    is the start value for the lerp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the **End Point** variable onto the **B** pin of the **Lerp (Vector)**
    node. The **B** pin is the end value for the lerp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the **Alpha** pin of the **Lerp (Vector)** node to the **Movement Alpha**
    pin of the timeline node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.17 – The update logic of the timeline completed](img/Figure_02.17_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – The update logic of the timeline completed
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the update logic is complete, we need to set our Blueprint up to start
    the timeline. To do this, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Event BeginPlay` node. This is a built-in event that is
    called when an actor is created (either at the beginning of the game or when spawned
    by another function).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag out of the `Ping Pong Movement`; you should now see a **Ping Pong Movement**
    option under the **Call Function** rollout—select it. This will create a call
    to our custom event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Ping Pong Movement being called from the Event BeginPlay event](img/Figure_02.18_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Ping Pong Movement being called from the Event BeginPlay event
  prefs: []
  type: TYPE_NORMAL
- en: 'This will now move the box from the start location to the end location in relative
    space; give it a test by placing the `BP_MovingBox_Better` Blueprint from the
    **Content Browser** into the world and clicking the *Play* button above the viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Play in Editor controls from the main Unreal Engine Editor
    user interface](img/Figure_02.19_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – Play in Editor controls from the main Unreal Engine Editor user
    interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to set the Blueprint up so that the box moves back to the start
    location once it has reached the end location and loops indefinitely. To do this,
    proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Detach the **Ping Pong Movement** custom event node from the timeline node by
    holding *Alt* on the keyboard and clicking either end of the connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the `Flip Flop` node. This node swaps between exec pins **A** and
    **B** each time it is entered. The node always starts with **A** for its first
    run. The **bool** pin can be used to inform other logic, but we won’t need that
    for this solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **A** pin of the **Flip Flop** node to the **Play from Start** pin
    of the **T_MoveBox** timeline node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the **B** pin of the **Flip Flop** node to the **Reverse from End**
    pin of the **T_MoveBox** timeline node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Flip Flop node and timeline](img/Figure_02.20_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – Flip Flop node and timeline
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, connect the **Finished** pin of the timeline node to a **Ping Pong
    Movement** function call node (either the existing one or a new one), which will
    restart the process every time it finishes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.21 – The improved Blueprint for the moving box, laid out for readability
    in the editor](img/Figure_02.21_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 – The improved Blueprint for the moving box, laid out for readability
    in the editor
  prefs: []
  type: TYPE_NORMAL
- en: Now, try pressing the *Play* button in the editor (the *Play* button above the
    viewport) again. You should now see that the box moves in one direction and then
    the other, over and over.
  prefs: []
  type: TYPE_NORMAL
- en: This approach offers a more performant solution due to not requiring the comparison.
    The update logic is still constantly running, in the same way as the tick approach
    was for the **Set Relative Location** node, but because the timeline controls
    when the direction change occurs, we no longer need to do any comparisons of vector
    locations after every move.
  prefs: []
  type: TYPE_NORMAL
- en: The timeline can also afford us more control over situations when we want to
    move things. The current setup features linear movement controlled by the linear
    curve. Changing the key types to automatic (right-click the key) or adding additional
    keys can provide more interesting movements and allow you to incorporate considerations
    such as the principles of animation into your moving objects, something that is
    very difficult to do without using a curve.
  prefs: []
  type: TYPE_NORMAL
- en: The rotating box problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second example we’re going to look at is a simple rotating box. The Blueprint
    actor contains the same static mesh component, but this time it’s set up to spin
    in place 2 degrees of rotation on each tick:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – The rotating box Blueprint code](img/Figure_02.22_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.22 – The rotating box Blueprint code
  prefs: []
  type: TYPE_NORMAL
- en: 'The Blueprint code also does a check for when the rotation of the box gets
    to 360 degrees or above and minuses 360 from the rotation value, to ensure that
    we keep the rotation value from spiraling out of control as the game plays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – The check to maintain rotations between 0 and 360 degrees](img/Figure_02.23_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.23 – The check to maintain rotations between 0 and 360 degrees
  prefs: []
  type: TYPE_NORMAL
- en: The check that’s been put in place is relatively sensible, and if it were part
    of a single rotation or working with a character rotation within an animation
    Blueprint, then it would be ideal.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this implementation is that we are once again working on tick
    and doing checks that will become more cumbersome with every additional rotating
    box.
  prefs: []
  type: TYPE_NORMAL
- en: Solution to the rotating box problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the rotating box, the solution is to use a pre-existing solution. Instead
    of coding differently, we can use a component that is provided as part of UE5
    to achieve the desired result. Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, delete all of the logic from the **Event Graph**, it is not required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Components** tab, click the **Add** button and search for a **Rotating**
    **Movement** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.24 – Rotating Movement component selected in the Add components
    list](img/Figure_02.24_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.24 – Rotating Movement component selected in the Add components list
  prefs: []
  type: TYPE_NORMAL
- en: Create a new variable by clicking the **+** in the **Variables** rollout of
    the **My** **Blueprint** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the variable `Rotation Rate` and set the type to `Rotator` by clicking
    on the current type (typically **Boolean** if you are working with a new Blueprint)
    and selecting **Rotator** from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the variable **Instance Editable** by clicking the *eye* icon to the right
    of the variable type—this will allow the user to set the rotation rate of each
    box in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the Blueprint and set the default value of the `0,0,180`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.25 – Resulting variables list in the My Blueprint tab](img/Figure_02.25_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.25 – Resulting variables list in the My Blueprint tab
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Set Rotation Rate` node. Connect the **Rotation Rate** variable you
    just created to the **Rotation** **Rate** pin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.26 – Construction script logic, setting the Rotating Movement component’s
    Rotation Rate using the created variable](img/Figure_02.26_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.26 – Construction script logic, setting the Rotating Movement component’s
    Rotation Rate using the created variable
  prefs: []
  type: TYPE_NORMAL
- en: Now, when placing `BP_RotatingBox_Better` into the world, you will be able to
    set the **Rotation Rate** value in the **Defaults** section of the **Detail**
    panel. Try placing multiple boxes and setting different values. When you press
    the *Play* button in **Editor**, you should see the boxes rotating as desired.
  prefs: []
  type: TYPE_NORMAL
- en: This solution offers a more performant approach again due to its lack of reliance
    on **Event Tick** as well as the removal of the comparison checking when the rotation
    exceeds 360 degrees in order to maintain values inside the 0-360 range.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of this approach is that we now have an **Instance Editable**
    variable for rotation rate, which offers much more control and customization to
    the user, allowing each box to have its own rotation rate. The variable also allows
    us to spin the box on all three axes, whereas the original approach only rotated
    the box around the *z* (yaw) axis.
  prefs: []
  type: TYPE_NORMAL
- en: The cascading cast chain problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example is something we see quite regularly with new developers when communicating
    between different Blueprint classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation here is for a game where a player character could be carrying
    one of three weapons: a pistol, shotgun, or rifle. Casts have been used to identify
    the class of the carried weapon, and when the cast returns true, each weapon’s
    fire event is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27 – A cascading cast chain in the Blueprint in the CH_Example_Bad
    asset](img/Figure_02.27_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.27 – A cascading cast chain in the Blueprint in the CH_Example_Bad
    asset
  prefs: []
  type: TYPE_NORMAL
- en: There are a few issues here. Firstly, it is the nature of the cast node in Unreal.
    While fine for prototyping, casts carry a resource impact where each actor we
    attempt to cast to gets loaded as part of the actor. So, in this case, all three
    weapons are included with the character in order to be able to check if the **Carried
    Weapon** child actor matches their classes.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the effect of casts on memory by checking the size map of any actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Actor** Blueprint in the **Content Browser**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and select **Size Map…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will open a popup that will show the size (in memory) of the chosen actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28 – Size map of the character Blueprint class with a cascading
    cast chain](img/Figure_02.28_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.28 – Size map of the character Blueprint class with a cascading cast
    chain
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting Blueprint (which only has the basic character class elements
    and the cast chain) is 149.9 kB, compared to the 56.1 kB of a standard character
    with just the child actor set as a pistol. This could be made smaller, further
    optimizing the Blueprint’s memory impact, by setting the default class of the
    child actor to be actor, but this isn’t necessary to prove the point we are trying
    to make; casting causes unnecessary memory issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.29 – Size map of a character Blueprint class with just a child actor
    component](img/Figure_02.29_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.29 – Size map of a character Blueprint class with just a child actor
    component
  prefs: []
  type: TYPE_NORMAL
- en: In both examples shown previously, the `Wpn_Pistol` class is just an empty actor
    with a custom event that would, in an eventual game, fire the weapon; however
    the class currently only contains a `Fire`. If you consider adding meshes, textures,
    particle systems, and audio components, the potential size of a character with
    a cascading cast chain becomes exponentially larger than it needs to be.
  prefs: []
  type: TYPE_NORMAL
- en: The second issue is the processing time of casting and waiting for failure before
    casting to the next weapon class and potentially waiting for that to fail. While
    we are talking milliseconds, it all adds up, especially if there are multiple
    characters and/or your non-player characters use the same character Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: The final issue with the cascading cast chain is the inflexibility (or extra
    work) that this approach provides. With the current setup, only the three weapons
    included in the chain can ever be used by the character. To expand the number
    of available weapons (as the project progresses or as part of a post-release piece
    of downloadable content), more casts will need to be added to the chain, multiplying
    the effects of the two aforementioned issues as well as being generally time-consuming
    to add them, particularly if there is any other logic required as part of the
    chain such as ammo management and cooldowns.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the current setup’s output, then open the `TestLevel` map
    from the `TestFiles` directory, click *Play*, and then click the left mouse button;
    you will see a print in the top-left corner of the screen related to each weapon.
    Pressing the *1*, *2*, and *3* keys on your keyboard will swap between different
    weapon classes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Solution to the cascading chain problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two potential solutions to the problem; the first is to use a parent
    and child class approach, casting to the parent class, which will allow **Event
    Fire** to be called on all of the children. As this still uses a cast, the parent
    class will still be included in the character, inflating the memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: The second solution, which we are going to implement, is using an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces allow two actors to communicate, without the need to identify the
    class type of the target actor.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint interfaces can be called from any Blueprint graph using an actor reference
    (which is the highest step of the class hierarchy). The receiving actor is required
    to implement the interface to define how it will respond to the interface event
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'In building this solution, we will create a simple Blueprint interface, add
    it to all of the weapons, and call it from the character, simply referencing the
    weapon as an actor class, negating the need for casting. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, create a Blueprint interface by right-clicking in the `BI_Weapon`.
    We use the prefix `BI` to label this as a Blueprint interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Fire`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `BI_Weapon`. Clicking it will add the **BI Weapon** interface to the **Implemented**
    **Interfaces** list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.30 – BI Weapon in the Implemented Interfaces list](img/Figure_02.30_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.30 – BI Weapon in the Implemented Interfaces list
  prefs: []
  type: TYPE_NORMAL
- en: 'This will now have added a **Fire** function under the **Interfaces** rollout
    in the **My Blueprint** tab. Double-click it; this will create an **Event Fire**
    interface event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.31 – The Event Fire interface event, denoted by the interface icon
    over the top-right corner](img/Figure_02.31_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.31 – The Event Fire interface event, denoted by the interface icon
    over the top-right corner
  prefs: []
  type: TYPE_NORMAL
- en: Drag out from the `Print String` node, then replace `Pistol –` `Interface Fire`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 3 to 5* on both the **Wpn_Rifle** and **Wpn_Shotgun** assets,
    changing the **Print String** node to include the name of each weapon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the **CH_Example_Bad** asset and rename it **CH_Example_Better**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **CH_Example_Better** and delete all of the nodes from the **InputAction
    PrimaryAction** logic flow, except for the **Carried Weapon** and **Target Child**
    **Actor** nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag from the `Fire (Message)`; this will create a **Fire** interface event
    call, which will be called on whichever class is currently set as the **Carried**
    **Weapon** class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.32 – The resulting InputAction PrimaryAction Blueprint logic with
    the interface call](img/Figure_02.32_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.32 – The resulting InputAction PrimaryAction Blueprint logic with the
    interface call
  prefs: []
  type: TYPE_NORMAL
- en: In order to test this approach, we need to swap the `TestLevel` map to the better
    example we’ve just created.
  prefs: []
  type: TYPE_NORMAL
- en: Open `GM_Test` from the `TestFiles` directory in the **Content Browser**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Default Pawn Class** dropdown to **CH_Example_Better**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when you play the level and click the left mouse button, you will see the
    new interface prints.
  prefs: []
  type: TYPE_NORMAL
- en: The outcome we have achieved is essentially the same as before; however, the
    code used to achieve it is tidier, faster, uses less memory, and is infinitely
    expandable by avoiding casts and using the interface.
  prefs: []
  type: TYPE_NORMAL
- en: The trade-off
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With any implementation of a pattern or fix, there is a trade-off between what
    you gain and what it costs, and it’s important to consider the long-term effects
    when implementing patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In many of the cases we are exploring, the gain is simplicity, readability,
    or a reduction in memory footprint, which should help your game to run smoothly.
    These are all key elements worth maintaining a good code base for. The cost is
    often time. Some patterns may take longer to implement, and, in some cases, having
    to refactor code to work in a specific way can use up valuable time.
  prefs: []
  type: TYPE_NORMAL
- en: The long-term effects, however, outweigh the initial time cost as the time saved
    later in development to build on top of or into existing systems will prove beneficial
    later in your game’s development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the S.O.L.I.D. principles that underpin good code,
    exploring specific examples and how, as they expand in complexity, we need to
    consider these principles to keep the code functioning. These principles are widely
    recognized across the game development industry, and so understanding them will
    not only help improve code efficiency and readability but also allow smooth communication
    with co-developers on larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored a series of common problems that new Unreal Engine users encounter
    and the solutions to them, looking specifically at a series of common tasks such
    as moving items and managing a selection of weapons on a character. The solutions,
    while specific, offer insights into how easily a developer can find themselves
    with large, lumbering Blueprints that can be solved by utilizing built-in systems
    and tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will be taking these principles of clean code and seeing
    how Epic Games have applied them through the engine when we look at some of the
    patterns they have built for us. The utility of the engine as it were. These patterns
    will include double buffer, flyweight and spatial partitioning.
  prefs: []
  type: TYPE_NORMAL
