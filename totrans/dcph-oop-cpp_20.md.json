["```cpp\n#ifndef _PERSON_H  // preprocessor directives to avoid \n#define _PERSON_H  // multiple inclusion of header\nusing std::string;\nclass Person\n{\nprivate:\n    string firstName, lastName, title;\n    char middleInitial = '\\0';   // in-class initialization\nprotected:\n    void ModifyTitle(const string &);\npublic:\n    Person() = default;   // default constructor\n    Person(const string &, const string &, char, \n           const string &);  // alternate constructor\n    // prototype not needed for default copy constructor\n    // Person(const Person &) = default;  // copy ctor\n    virtual ~Person() = default;  // virtual destructor\n    const string &GetFirstName() const \n        { return firstName; }\n    const string &GetLastName() const { return lastName; }\n    const string &GetTitle() const { return title; }\n    char GetMiddleInitial() const { return middleInitial; }\n    virtual void Print() const;\n    virtual void IsA() const;\n    virtual void Greeting(const string &) const;\n    Person &operator=(const Person &);  // overloaded op =\n};\n#endif\n```", "```cpp\n#include <iostream>  // also incl. other relevant libraries\n#include \"Person.h\"  // include the header file\nusing std::cout;     // preferred to: using namespace std;\nusing std::endl; \nusing std::string;\n// Include all the non-inline Person member functions\n// The alt. constructor is one example of many in the file\nPerson::Person(const string &fn, const string &ln, char mi,\n             const string &t): firstName(fn), lastName(ln),\n                               middleInitial(mi), title(t)\n{\n   // dynamically alloc. memory for any ptr data mbrs here\n}\n```", "```cpp\n#ifndef _PERSON_H    // Person.h header file definition\n#define _PERSON_H\nclass Person\n{\nprivate:\n    class PersonImpl;  // forward declaration nested class\n    PersonImpl *pImpl = nullptr; // ptr to implementation \n                                 // of class\nprotected:\n    void ModifyTitle(const string &);\npublic:\n    Person();   // default constructor\n    Person(const string &, const string &, char, \n           const string &);\n    Person(const Person &);  // copy const. will be defined\n    virtual ~Person();  // virtual destructor\n    const string &GetFirstName() const; // no longer inline\n    const string &GetLastName() const; \n    const string &GetTitle() const; \n    char GetMiddleInitial() const; \n    virtual void Print() const;\n    virtual void IsA() const;\n    virtual void Greeting(const string &) const;\n    Person &operator=(const Person &);  // overloaded =\n};\n#endif\n```", "```cpp\n// PersonImpl.cpp source code file includes nested class\n// Nested class definition supports implementation\nclass Person::PersonImpl\n{\nprivate:\n    string firstName, lastName, title;\n    char middleInitial = '\\0';  // in-class initialization\npublic:\n    PersonImpl() = default;   // default constructor\n    PersonImpl(const string &, const string &, char, \n               const string &);\n    // Default copy ctor does not need to be prototyped\n    // PersonImpl(const PersonImpl &) = default;  \n    virtual ~PersonImpl() = default;  // virtual destructor\n    const string &GetFirstName() const \n        { return firstName; }\n    const string &GetLastName() const { return lastName; }\n    const string &GetTitle() const { return title; }\n    char GetMiddleInitial() const { return middleInitial; }\n    void ModifyTitle(const string &);\n    virtual void Print() const;\n    virtual void IsA() const { cout << \"Person\" << endl; }\n    virtual void Greeting(const string &msg) const\n        { cout << msg << endl; }\n    PersonImpl &operator=(const PersonImpl &); \n};\n```", "```cpp\n// File: PersonImpl.cpp - See online code for full methods \n// Nested class member functions. \n// Notice that the class name is Outer::Inner class\n// Notice that we are using the system-supplied definitions\n// for default constructor, copy constructor and destructor\n// alternate constructor\nPerson::PersonImpl::PersonImpl(const string &fn, \n             const string &ln, char mi, const string &t): \n             firstName(fn), lastName(ln), \n             middleInitial(mi), title(t)   \n{\n}\nvoid Person::PersonImpl::ModifyTitle(const string &newTitle)\n{   \n    title = newTitle;\n}\nvoid Person::PersonImpl::Print() const\n{   // Print each data member as usual\n}\n// Note: same as default op=, but it is good to review what \n// is involved in implementing op= for upcoming discussion\nPerson::PersonImpl &Person::PersonImpl::operator=\n                             (const PersonImpl &p)\n{  \n    if (this != &p)  // check for self-assignment\n    {\n        firstName = p.firstName;\n        lastName = p.lastName;\n        middleInitial = p.middleInitial;\n        title = p.title;\n   }\n   return *this;  // allow for cascaded assignments\n}\n```", "```cpp\n// Person member functions – also in PersonImpl.cpp\nPerson::Person(): pImpl(new PersonImpl())\n{ // As shown, this is the complete member fn. definition\n}\nPerson::Person(const string &fn, const string &ln, char mi,\n               const string &t): \n               pImpl(new PersonImpl(fn, ln, mi, t))\n{ // As shown, this is the complete member fn. definition\n}  \nPerson::Person(const Person &p): \n               pImpl(new PersonImpl(*(p.pImpl)))\n{  // This is the complete copy constructor definition\n}  // No Person data members to copy from 'p' except deep\n   // copy of *(p.pImpl) to data member pImpl\nPerson::~Person()\n{\n    delete pImpl;   // delete associated implementation\n}\nvoid Person::ModifyTitle(const string &newTitle)\n{   // delegate request to the implementation \n    pImpl->ModifyTitle(newTitle);  \n}\nconst string &Person::GetFirstName() const\n{   // no longer inline in Person; \n    // non-inline method further hides implementation\n    return pImpl->GetFirstName();\n}\n// Note: methods GetLastName(), GetTitle(), and  \n// GetMiddleInitial() are implemented similar to\n// GetFirstName(). See online code\nvoid Person::Print() const\n{\n    pImpl->Print();   // delegate to implementation\n}                     // (same named member function)\n// Note: methods IsA() and Greeting() are implemented \n// similarly to Print() – using delegation. See online code\nPerson &Person::operator=(const Person &p)\n{  // delegate op= to implementation portion\n   pImpl->operator=(*(p.pImpl)); // call op= on impl. piece\n   return *this;  // allow for cascaded assignments\n}\n```", "```cpp\n#include <iostream>\n#include \"Person.h\"\nusing std::cout;  // preferred to: using namespace std;\nusing std::endl;\nconstexpr int MAX = 3;\nint main()\n{\n    Person *people[MAX] = { }; // initialized to nullptrs\n    people[0] = new Person(\"Elle\", \"LeBrun\", 'R',\"Ms.\");\n    people[1] = new Person(\"Zack\", \"Moon\", 'R', \"Dr.\");\n    people[2] = new Person(\"Gabby\", \"Doone\", 'A', \"Dr.\");\n    for (auto *individual : people)\n       individual->Print();\n    for (auto *individual : people)\n       delete individual;\n    return 0;\n}\n```", "```cpp\nMs. Elle R. LeBrun\nDr. Zack R. Moon\nDr. Gabby A. Doone\n```", "```cpp\n#include <iostream>\n#include \"Person.h\"\nusing std::cout;   // preferred to: using namespace std;\nusing std::endl;\ntemplate <class Type>\nclass SmartPointer\n{\nprivate:\n    Type *pointer = nullptr;  // in-class initialization\npublic:\n    // Below ctor also handles default construction \n    SmartPointer(Type *ptr = nullptr): pointer(ptr) { }\n    virtual ~SmartPointer();  // allow specialized SmrtPtrs\n    Type *operator->() { return pointer; }\n    Type &operator*() { return *pointer; }\n};\nSmartPointer::~SmartPointer()\n{\n    delete pointer;\n    cout << \"SmartPtr Destructor\" << endl;\n}\nint main()\n{\n    SmartPointer<int> p1(new int());\n    SmartPointer<Person> pers1(new Person(\"Renee\",\n                               \"Alexander\", 'K', \"Dr.\"));\n    *p1 = 100;\n    cout << *p1 << endl;\n    (*pers1).Print();   // or use: pers1->Print();\n    return 0;\n}\n```", "```cpp\n100\nDr. Renee K. Alexander\nSmartPtr Destructor\nSmartPtr Destructor\n```", "```cpp\n#include <iostream>\n#include <memory>\n#include \"Person.h\"\nusing std::cout;   // preferred to: using namespace std;\nusing std::endl;\nusing std::unique_ptr;\nint main()\n{\n    unique_ptr<int> p1(new int());\n    unique_ptr<Person> pers1(new Person(\"Renee\", \n                             \"Alexander\", 'K', \"Dr.\"));\n    *p1 = 100;\n    cout << *p1 << endl;\n    (*pers1).Print();   // or use: pers1->Print();\n    return 0;\n}\n```", "```cpp\n#ifndef _PERSON_H    // Person.h header file definition\n#define _PERSON_H\n#include <memory>\nclass Person\n{\nprivate:\n    class PersonImpl;  // forward declaration nested class\n    std::unique_ptr<PersonImpl> pImpl; //unique ptr to impl\nprotected:\n    void ModifyTitle(const string &);\npublic:\n    Person();   // default constructor\n    Person(const string &, const string &, char, \n           const string &);\n    Person(const Person &);  // copy constructor\n    virtual ~Person();  // virtual destructor\n    const string &GetFirstName() const; // no longer inline\n    const string &GetLastName() const; \n    const string &GetTitle() const; \n    char GetMiddleInitial() const; \n    virtual void Print() const;\n    virtual void IsA() const;\n    virtual void Greeting(const string &) const;\n    Person &operator=(const Person &);  // overloaded =\n};\n#endif\n```", "```cpp\n// Source file PersonImpl.cpp\n// Person destructor no longer needs to delete pImpl member\n// and hence can simply be the default destructor!\n// Note: prototyped with virtual in header file.\nPerson::~Person() = default;\n// unique_pointer pImpl will delete its own resources\n```"]