- en: '*Appendix*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*附录*'
- en: About
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于
- en: This section is included to assist the students to perform the activities in
    the book. It includes detailed steps that are to be performed by the students
    to achieve the objectives of the activities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含帮助学生执行书中活动的概念。它包括学生为实现活动目标必须执行的详细步骤。
- en: 'Lesson 1: Getting Started'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1课：入门
- en: 'Activity 1: Find the Factors of 7 between 1 and 100 Using a while Loop'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动一：使用 `while` 循环在1到100之间找到7的因子
- en: 'Import all the required header files before the `main` function:'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数之前导入所有必需的头文件：
- en: '[PRE0]'
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the `main` function, create a variable `i` of type `unsigned`, and initialize
    its value as `1`:'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部，创建一个类型为 `unsigned` 的变量 `i`，并将其值初始化为 `1`：
- en: '[PRE1]'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, use the `while` loop adding the logic where the value of `i` should be
    less than `100`:'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `while` 循环添加逻辑，其中 `i` 的值应小于 `100`：
- en: '[PRE2]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the scope of the `while` loop, use the if statement with the following logic:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `while` 循环的作用域内，使用以下逻辑的 `if` 语句：
- en: '[PRE3]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Increase the value of the `i` variable to iterate through the `while` loop
    to validate the condition:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `i` 变量的值增加以迭代 `while` 循环以验证条件：
- en: '[PRE4]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the program is as follows:'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE5]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Activity 2: Define a Bi-Dimensional Array and Initialize Its Elements'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动二：定义一个二维数组并初始化其元素
- en: 'After creating a C++ file, include the following header file at the start of
    the program:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 C++ 文件后，在程序开始处包含以下头文件：
- en: '[PRE6]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, in the `main` function, create a bi-directional array named `foo` of type
    integer, with three rows and three columns, as shown here:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `main` 函数中，创建一个名为 `foo` 的双向数组，类型为整数，具有三行三列，如下所示：
- en: '[PRE7]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will use the concept of a nested `for` loop to iterate through each
    index entry of the `foo` array:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用嵌套 `for` 循环的概念来迭代 `foo` 数组的每个索引条目：
- en: '[PRE8]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the second `for` loop, add the following statement:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个 `for` 循环中，添加以下语句：
- en: '[PRE9]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, iterate over the array again to print its values:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，再次迭代数组以打印其值：
- en: '[PRE10]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lesson 2: Functions'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2课：函数
- en: 'Activity 3: Calculating if a Person is Eligible to Vote or Not'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动三：计算一个人是否有资格投票或不
- en: 'Include the header file in the program to print the output as shown here:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序中包含头文件以打印如下所示的输出：
- en: '[PRE12]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, create a function named `byreference_age_in_5_years` and the `if` loop
    with the following condition to print the message:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `byreference_age_in_5_years` 的函数，并使用以下条件编写 `if` 循环以打印消息：
- en: '[PRE13]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the `else` block to provide another condition if the age of the user is
    less than 18 years:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `else` 块以提供另一个条件，如果用户的年龄小于18岁：
- en: '[PRE14]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `main` function, create a variable of type integer and pass it as a
    reference in the `byreference_age_in_5_years` function as shown:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，创建一个类型为整数的变量，并将其作为引用传递给 `byreference_age_in_5_years` 函数，如下所示：
- en: '[PRE15]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Activity 4: Apply the Understanding of Passing by Reference or Value in Functions'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动四：在函数中应用通过引用或值传递的理解
- en: 'After adding all the required header files, create the first function of type
    integer as shown here:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加所有必需的头文件后，创建第一个类型为整数的函数，如下所示：
- en: '[PRE16]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Take by value, return by value, since the types are small in memory and there
    is no reason to use references.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 采用值传递，返回值传递，因为类型在内存中较小，没有使用引用的理由。
- en: 'The second function should be written as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个函数应编写如下：
- en: '[PRE17]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Activity 5: Organizing Functions in Namespaces'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动五：在命名空间中组织函数
- en: 'Include the required header file and namespace to print the required output:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含所需的头文件和命名空间以打印所需的输出：
- en: '[PRE18]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, create a namespace named `LamborghiniCar` with the following `output`
    function:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `LamborghiniCar` 的命名空间，并使用以下 `output` 函数：
- en: '[PRE19]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create another namespace named `PorscheCar` and add an `output` function as
    shown:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `PorscheCar` 的命名空间，并添加一个 `output` 函数，如下所示：
- en: '[PRE20]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the main function, create a variable named `magicNumber` of type integer
    to accept the input from the user:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，创建一个名为 `magicNumber` 的类型为整数的变量以接受用户的输入：
- en: '[PRE21]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following conditional `if`…`else`-`if`…`else` statement to complete
    the program:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下条件 `if`…`else`-`if`…`else` 语句以完成程序：
- en: '[PRE22]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Activity 6: Writing a Math Library for use in a 3D Game'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动六：编写用于3D游戏的数学库
- en: 'Add the required header files at the start of the program (`mathlib.h` file
    is provided):'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序开始处添加所需的头文件（提供 `mathlib.h` 文件）：
- en: '[PRE23]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a global `const` variable of type `float` as shown here:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个全局 `const` 变量，类型为 `float`，如下所示：
- en: '[PRE24]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `main` function, create two arrays of type `float` and assign the following
    values:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，创建两个类型为 `float` 的数组，并分配以下值：
- en: '[PRE25]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, create a variable named `enemy_distance` of type `float` and use the distance
    function to assign the value after calculating it:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `enemy_distance` 的 `float` 类型的变量，并使用距离函数在计算后赋值：
- en: '[PRE26]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using the `circumference` function of `mathlib.h`, calculate and assign the
    enemy visual radius to `view_circumference_for_enemy` of type `float`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `mathlib.h` 中的 `circumference` 函数，计算并分配敌人可视半径到 `view_circumference_for_enemy`
    的 `float` 类型：
- en: '[PRE27]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a variable named `total_distance` of type `float` and assign the distance
    difference between the two enemies as shown in the following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `total_distance` 的 `float` 类型的变量，并将两个敌人之间的距离差赋值，如下代码所示：
- en: '[PRE28]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Print the output using the following print statement:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下打印语句打印输出：
- en: '[PRE29]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lesson 3: Classes'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 课：类
- en: 'Activity 7: Information Hiding Through Getters and Setters'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 7：通过获取器和设置器实现信息隐藏
- en: 'Define a class named `Coordinates` with its members under a `private` access
    specifier:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `Coordinates` 的类，其成员在 `private` 访问修饰符下：
- en: '[PRE30]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the four operations as specified above and make them publicly accessible
    by preceding their declaration with the `public` access specifier. The setters
    (`set_latitude` and `set_longitude`) should take an `int` as a parameter and return
    `void`, while the getters do not take any parameter and return a `float`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加上述指定的四个操作，并通过在它们的声明前加上 `public` 访问修饰符使它们公开可访问。设置器（`set_latitude` 和 `set_longitude`）应接受一个
    `int` 参数并返回 `void`，而获取器不接收任何参数并返回一个 `float`：
- en: '[PRE31]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The four methods should now be implemented. The setters assign the given value
    to the corresponding members they are supposed to set; the getters return the
    values that are stored.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应该实现四个方法。设置器将给定的值赋给它们应该设置的相应成员；获取器返回存储的值。
- en: '[PRE32]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An example is as follows:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE33]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Activity 8: Representing Positions in a 2D Map'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 8：在 2D 地图上表示位置
- en: 'The first step is to create a class named `Coordinates` containing the coordinates
    as data members. These are two floating-point values, `_latitude` and `_longitude`,
    which identify the coordinates on a geographic coordinate system. Additionally,
    these data members are initialized with a `private` access specifier:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个名为 `Coordinates` 的类，其中包含坐标作为数据成员。这些是两个浮点值，`_latitude` 和 `_longitude`，它们标识地理坐标系统上的坐标。此外，这些数据成员使用
    `private` 访问修饰符初始化：
- en: '[PRE34]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, the class is extended with a `public` constructor which takes two arguments
    used to initialize the data members of the class:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过一个接受两个参数的 `public` 构造函数扩展该类，这两个参数用于初始化类的数据成员：
- en: '[PRE35]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can also add getters as seen previously to access the class members. An
    example is as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以添加之前看到的获取器来访问类成员。以下是一个示例：
- en: '[PRE36]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Activity 9: Storing Multiple Coordinates of Different Positions in the Map'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 9：在地图中存储不同位置的多组坐标
- en: Using the RAII programming idiom, write a class that manages memory allocation
    and deletion of an array of `int`. The class has an array of integers as member
    data, which will be used to store the values.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 RAII 编程习惯，编写一个管理数组内存分配和删除的类。该类有一个整数数组作为成员数据，将用于存储值。
- en: The constructor takes the size of the array as a parameter.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数接受数组的大小作为参数。
- en: The constructor also takes care of allocating memory, which is used to store
    the coordinates.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数还负责分配内存，用于存储坐标。
- en: Finally, define a destructor and make sure to free the previously allocated
    array in its implementation.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义一个析构函数，并确保在其实现中释放之前分配的数组。
- en: 'We can add print statements to visualize what is happening:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以添加打印语句来可视化正在发生的事情：
- en: '[PRE37]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can use our `managed_array` class as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用我们的 `managed_array` 类如下：
- en: '[PRE38]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output will be as follows:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE39]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Activity 10: The AppleTree Class, which Creates an Apple Instance'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 10：创建苹果实例的 AppleTree 类
- en: 'First, we need to create a class with a `private` constructor. In this way,
    the object cannot be constructed, because the constructor is not publicly accessible:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个具有 `private` 构造函数的类。这样，对象就不能被构造，因为构造函数不是公开可访问的：
- en: '[PRE40]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `AppleTree` class is defined and contains a method called `createFruit`
    that is in charge of creating an `Apple` and returning it:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AppleTree` 类被定义，并包含一个名为 `createFruit` 的方法，该方法负责创建一个 `Apple` 并返回它：'
- en: '[PRE41]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we compile this code, we will get an error. At this point, the `Apple` constructor
    is `private`, so the `AppleTree` class cannot access it. We need to declare the
    `AppleTree` class as a `friend` of `Apple` to allow `AppleTree` to access the
    `private` methods of `Apple`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们编译此代码，我们将得到一个错误。在此点，`Apple` 构造函数是 `private` 的，因此 `AppleTree` 类无法访问它。我们需要将
    `AppleTree` 类声明为 `Apple` 的 `friend`，以便允许 `AppleTree` 访问 `Apple` 的 `private` 方法：
- en: '[PRE42]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Apple` object can now be constructed using the following code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以使用以下代码构造 `Apple` 对象：
- en: '[PRE43]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This prints the following:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE44]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Activity 11: Ordering Point Objects'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 11：对点对象进行排序
- en: 'We need to add an overload for the `<` operator to the `Point` class that we
    have previously defined. This takes another object of type `Point` as an argument
    and returns a Boolean indicating whether the object is less than the one provided
    as the parameter, using the previous definition for how to compare the two points:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为之前定义的 `Point` 类添加一个 `<` 操作符的重载。这个重载接受另一个类型为 `Point` 的对象作为参数，并返回一个布尔值，指示该对象是否小于作为参数提供的对象，使用之前定义的比较两个点的方法：
- en: '[PRE45]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At this point, we are able to compare the two `Point` objects:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们能够比较两个 `Point` 对象：
- en: '[PRE46]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Since in our example `p_1.x` is initialized to `1` and `p_2.x` to `2`, the result
    of the comparison will be `true`, which indicates that `p_1` comes earlier than
    `p_2` in the order.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于在我们的示例中 `p_1.x` 被初始化为 `1`，而 `p_2.x` 被初始化为 `2`，比较的结果将是 `true`，这表明在顺序中 `p_1`
    比 `p_2` 更早。
- en: 'Activity 12: Implementing Functors'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 12：实现仿函数
- en: 'Define a class constituted by a `private` data member of type `int` and add
    a constructor to initialize it:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个由类型为 `int` 的 `private` 数据成员构成的类，并添加一个构造函数来初始化它：
- en: '[PRE47]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Extend it with the call operator `operator()` which takes an `int` as a parameter
    and returns an `int`. The implementation in the function body should return the
    addition of the previously defined `x` value and the parameter of the function
    named `y`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用操作符 `operator()` 扩展它，它接受一个 `int` 作为参数并返回一个 `int`。在函数体内的实现应该返回先前定义的 `x` 值与函数参数
    `y` 的和：
- en: '[PRE48]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Instantiate an object of the class just defined and invoke the call operator:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个刚刚定义的类的对象并调用调用操作符：
- en: '[PRE49]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output will be as follows:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE50]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lesson 04: Generic Programming and Templates'
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第04课：泛型编程和模板
- en: 'Activity 13: Read Objects from a Connection'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 13：从连接中读取对象
- en: 'We start by including the headers of the files that provided the connection
    and the user account object:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先包含提供连接和用户账户对象的文件头：
- en: '[PRE51]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can then start to write the `writeObjectToConnection` function. Declare
    a template which takes two `typename` parameters: an `Object` and a `Connection`.
    Call the `static` method `serialize()` on the object to get the `std::array` representing
    the object, then call `writeNext()` on the connection to write the data to it:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以开始编写 `writeObjectToConnection` 函数。声明一个模板，它接受两个 `typename` 参数：一个 `Object`
    和一个 `Connection`。在对象上调用 `static` 方法 `serialize()` 以获取表示对象的 `std::array`，然后调用连接上的
    `writeNext()` 将数据写入它：
- en: '[PRE52]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can then write `readObjectFromConnection`. Declare a template taking the
    same two parameters as before: an `Object` and a `Connection`. Inside, we call
    the connection `readNext()` to get the data stored inside the connection, then
    we call the `static` method on the object type `deserialize()` to get an instance
    of the object and return it:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以编写 `readObjectFromConnection`。声明一个模板，它接受与之前相同的两个参数：一个 `Object` 和一个 `Connection`。在内部，我们调用连接的
    `readNext()` 来获取存储在连接中的数据，然后我们调用对象类型的 `static` 方法 `deserialize()` 来获取对象的实例并返回它：
- en: '[PRE53]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, in the `main` function, we can call the functions we created to serialize
    objects. Both with `TcpConnection`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `main` 函数中，我们可以调用我们创建的序列化对象函数。无论是使用 `TcpConnection`：
- en: '[PRE54]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And with `UdpConnection`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还是使用 `UdpConnection`：
- en: '[PRE55]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output of the program is as follows:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE56]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Activity 14: UserAccount to Support Multiple Currencies'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 14：支持多种货币的用户账户
- en: 'We start by including the file defining the currencies:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先包含定义货币的文件：
- en: '[PRE57]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We then declare the template class `Account`. It should take a template parameter:
    `Currency`. We store the current balance of the account inside a data member of
    type `Currency`. We also provide a method in order to extract the current value
    of the balance:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后声明了一个模板类 `Account`。它应该接受一个模板参数：`Currency`。我们将账户的当前余额存储在类型为 `Currency` 的数据成员中。我们还提供了一个方法来提取当前余额的值：
- en: '[PRE58]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we create the method `addToBalance`. It should be a template with one
    type parameter, the other currency. The method takes a value of `OtherCurrency`
    and converts it to the value of the currency of the current account with the `to()`
    function, specifying to which currency the value should be converted to. It then
    adds it to the balance:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为 `addToBalance` 的方法。它应该是一个带有单个类型参数的模板，即其他货币。该方法接受一个 `OtherCurrency`
    类型的值，并使用 `to()` 函数将其转换为当前账户货币的值，指定要将值转换为哪种货币。然后将其添加到余额中：
- en: '[PRE59]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we can try to call our class in the `main` function with some data:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在 `main` 函数中使用一些数据来尝试调用我们的类：
- en: '[PRE60]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output of the program is:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE61]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Activity 15: Write a Matrix Class for Mathematical Operations in a Game'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 15：为游戏中的数学运算编写一个矩阵类
- en: 'We start by defining a `Matrix` class which takes three template parameters:
    one type and the two dimensions of the `Matrix` class. The dimensions are of type
    `int`. Internally, we create a `std::array` with the size of the number of rows
    times the number of columns, in order to have enough space for all elements of
    the matrix. We add a constructor to initialize the array to *empty*, and a constructor
    to provide a list of values:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个 `Matrix` 类，它接受三个模板参数：一个类型和 `Matrix` 类的两个维度。维度是 `int` 类型。内部，我们创建一个大小为行数乘以列数的
    `std::array`，以便为矩阵的所有元素提供足够的空间。我们添加了一个构造函数来初始化数组为 *空*，以及一个构造函数来提供值列表：
- en: '[PRE62]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We add a method `get()` to the class to return a reference to the element `T`.
    The method needs to take the row and column we want to access.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在类中添加了一个 `get()` 方法来返回对元素 `T` 的引用。该方法需要接受我们想要访问的行和列。
- en: 'We make sure that the requested indexes are inside the bounds of the matrix,
    otherwise we call `std::abort()`. In the array, we first store all the elements
    of the first row, then all the elements of the second row, and so on. When we
    want to access the elements of the *nth* row, we need to skip all the elements
    of the previous rows, which are going to be the number of elements per row (so
    the number of columns) times the previous rows, resulting in the following method:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确保请求的索引在矩阵的范围内，否则我们调用 `std::abort()`。在数组中，我们首先存储第一行的所有元素，然后存储第二行的所有元素，依此类推。当我们想要访问第
    *n* 行的元素时，我们需要跳过之前行的所有元素，这些元素是每行的元素数量（即列数）乘以之前的行数，结果如下所示的方法：
- en: '[PRE63]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'For convenience, we define a function to print the class as well. We print
    all the elements in the columns separated by spaces, with one column per line:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便起见，我们定义了一个打印类的函数。我们按列分隔所有元素，每列一行打印：
- en: '[PRE64]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the `main` function, we can now use the functions we have defined:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们现在可以使用我们定义的函数：
- en: '[PRE65]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output is as follows:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE66]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**Solution bonus step**:'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解决方案奖励步骤**：'
- en: We can add a new method, `multiply`, which takes a `std::array` of type `T`
    with the length of `C` by `const` reference, since we are not modifying it.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以添加一个新的方法 `multiply`，它接受一个长度为 `C` 的 `std::array` 类型的 `T`，以 `const` 引用方式，因为我们没有修改它。
- en: The function returns an array of the same type, but length `R`.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数返回一个类型相同但长度为 `R` 的数组。
- en: 'We follow the definition of matrix-vector multiplication to compute the result:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遵循矩阵-向量乘法的定义来计算结果：
- en: '[PRE67]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can now extend our `main` function to call the `multiply` function:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以扩展 `main` 函数来调用 `multiply` 函数：
- en: '[PRE68]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output is as follows:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE69]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Activity 16: Make the Matrix Class Easier to Use'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 16：使矩阵类更容易使用
- en: 'We start by importing `<functional>` in order to have access to `std::multiplies`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入 `<functional>` 以便访问 `std::multiplies`：
- en: '[PRE70]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We then change the order of the template parameters in the class `template`,
    so that the size parameters come first. We also add a new template parameter,
    `Multiply`, which is the type we will use for computing the multiplication between
    the elements in the `vector` by default, and we store an instance of it in the
    class:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将类 `template` 中的模板参数顺序改变，使得大小参数排在前面。我们还添加了一个新的模板参数 `Multiply`，这是我们默认用于在
    `vector` 元素之间进行乘法运算的类型，并将其实例存储在类中：
- en: '[PRE71]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `get()` function remains the same as the previous activity.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`get()` 函数与上一个活动保持相同。'
- en: We now need to make sure that the `Multiply` method uses the `Multiply` type
    provided by the user to perform the multiplication.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要确保 `Multiply` 方法使用用户提供的 `Multiply` 类型来执行乘法。
- en: 'To do so, we need to make sure to call `multiplier(operand1, operand2)` instead
    of `operand1 * operand2`, so that we use the instance we stored inside the class:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要确保调用`multiplier(operand1, operand2)`而不是`operand1 * operand2`，这样我们就能使用类内部存储的实例：
- en: '[PRE72]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can now add an example of how we can use the class:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以添加一个示例，说明我们如何使用这个类：
- en: '[PRE73]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is as follows:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE74]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Activity 17: Ensure Users are Logged in When Performing Actions on the Account'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十七：确保在执行账户操作时用户已登录
- en: 'We first declare a template function which takes two type parameters: an `Action`
    and a `Parameter` type.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明一个模板函数，它接受两个类型参数：一个`Action`类型和一个`Parameter`类型。
- en: 'The function should take the user identification, the action and the parameter.
    The parameter should be accepted as a forwarding reference. As a first step, it
    should check if the user is logged in, by calling the `isLoggenIn()` function.
    If the user is logged in, it should call the `getUserCart()` function, then call
    the action passing the cart and forwarding the parameter:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数应该接受用户标识、操作和参数。参数应该作为转发引用接受。作为第一步，它应该通过调用`isLoggenIn()`函数检查用户是否已登录。如果用户已登录，它应该调用`getUserCart()`函数，然后调用操作，传递购物车和转发参数：
- en: '[PRE75]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can test how `execute_on_user_cart` works by calling it in the `main` function:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在`main`函数中调用它来测试`execute_on_user_cart`的工作方式：
- en: '[PRE76]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output is as follows:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE77]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Activity 18: Safely Perform Operations on User Cart with an Arbitrary Number
    of Parameters'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十八：使用任意数量的参数安全地执行用户购物车操作
- en: We need to expand the previous activity to accept any number of parameters with
    any kind of ref-ness and pass it to the action provided. To do so, we need to
    create a `variadic` template.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要扩展先前的活动以接受任何类型的引用和任意数量的参数，并将其传递给提供的操作。为此，我们需要创建一个`可变参数`模板。
- en: Declare a `template` function that takes an action and a `variadic` number of
    parameters as template parameters. The function parameters should be the user
    action, the action to perform, and the expanded template parameter `pack`, making
    sure that the parameters are accepted as forwarding references.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个模板函数，它接受一个操作和一个`可变参数`数量的模板参数。函数参数应该是用户操作、要执行的操作以及扩展的模板参数`pack`，确保参数作为转发引用被接受。
- en: 'Inside the function, we perform the same checks as before, but now we expand
    the parameters when we forward them to the action:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，我们执行与之前相同的检查，但现在我们在将参数转发到操作时扩展它们：
- en: '[PRE78]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let’s test the new function in our `main` function:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`main`函数中测试这个新函数：
- en: '[PRE79]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output is as follows:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE80]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Lesson 5: Standard Library Containers and Algorithms'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课五：标准库容器和算法
- en: 'Activity 19: Storing User Accounts'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十九：存储用户账户
- en: 'First, we include the header files for the `array` class and input/output operations
    with the required namespace:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含`array`类和输入/输出操作的必要头文件以及所需的命名空间：
- en: '[PRE81]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'An array of ten elements of type `int` is declared:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明了一个包含十个`int`类型元素的数组：
- en: '[PRE82]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Initially, the values of the elements are undefined since it is an array of
    the fundamental data type `int`. The array is initialized using a `for` loop,
    where each element is initialized with its index. The operator `size()` is used
    to evaluate the size of the array and the subscript operator `[ ]` is used to
    access every position of the array:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，元素的值是未定义的，因为它是一个基本数据类型`int`的数组。数组使用`for`循环初始化，其中每个元素使用其索引初始化。使用`size()`运算符来评估数组的大小，使用下标运算符`[
    ]`来访问数组的每个位置：
- en: '[PRE83]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We now want to update the value for the first and last user. We can use `front()`
    and `back()` to access the accounts of these users:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要更新第一个和最后一个用户的值。我们可以使用`front()`和`back()`来访问这些用户的账户：
- en: '[PRE84]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We would like to store the account balance of an arbitrary number of users.
    We then want to add 100 users to the account list, with a balance of 500.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望存储任意数量用户的账户余额。然后我们想要向账户列表中添加100个用户，每个用户的余额为500。
- en: 'We can use `vector` to store an arbitrary number of users. It is defined in
    the `<vector>` header:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`vector`存储任意数量的用户。它在`<vector>`头文件中定义：
- en: '[PRE85]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, we declare a vector of type `int`. Optionally, we reserve enough memory
    to store the 100 users’ account by calling `reserve(100)` to avoid memory reallocation:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明了一个`int`类型的`vector`。可选地，我们可以通过调用`reserve(100)`预留足够的内存来存储100个用户的账户，以避免内存重新分配：
- en: '[PRE86]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, we modify the `for` loop to add the balance for the users at the end
    of the accounts vector:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们修改`for`循环，在账户向量末尾添加用户的余额：
- en: '[PRE87]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Activity 20: Retrieving a User’s Balance from their Given Username'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动20：根据给定的用户名检索用户的余额
- en: 'Include the header file for the `map` class and the header for `string`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 `map` 类的头文件和 `string` 的头文件：
- en: '[PRE88]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Create a map with the key being `std::string` and the value `int`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个键为 `std::string`，值为 `int` 的映射：
- en: '[PRE89]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Insert the balances of the users inside `map` by using `insert` and `std::make_pair`.
    The first argument is the key, the second one is the value:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `insert` 和 `std::make_pair` 将用户的余额插入到 `map` 中。第一个参数是键，第二个参数是值：
- en: '[PRE90]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Use the `find` function providing the name of the user to find the position
    of the account in the map. Compare it with `end()` to check whether a position
    was found:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `find` 函数提供用户名以找到账户在映射中的位置。将其与 `end()` 进行比较以检查是否找到了位置：
- en: '[PRE91]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, look for the account of `Alice`. We know `Alice` has an account, so there
    is no need to check whether we found a valid position. We can print the value
    of the account using `->second`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，寻找 `Alice` 的账户。我们知道 `Alice` 有账户，所以没有必要检查我们是否找到了有效的位置。我们可以使用 `->second` 打印账户的值：
- en: '[PRE92]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Activity 21: Processing User Registration in Order'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动21：按顺序处理用户注册
- en: 'First, we include the header file for the `stack` class:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，包括 `stack` 类的头文件：
- en: '[PRE93]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Create a `stack` providing the type to `store`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个提供 `store` 类型的 `stack`：
- en: '[PRE94]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We start by storing the form inside the `stack` when the user registers. In
    the body of the `storeRegistrationForm` function, push the element into the queue:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在用户注册时开始将表单存储在 `stack` 中。在 `storeRegistrationForm` 函数的主体中，将元素推入队列：
- en: '[PRE95]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, inside `endOfDayRegistrationProcessing`, we get all the elements inside
    the `stack` and then process them. Use the `top()` method to access the top element
    in the `stack` and `pop()` to remove the top element. We stop getting and removing
    the first element when no element is left:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `endOfDayRegistrationProcessing` 内部，我们获取 `stack` 中的所有元素，然后处理它们。使用 `top()`
    方法访问 `stack` 中的顶部元素，并使用 `pop()` 移除顶部元素。当我们没有元素时停止获取和移除第一个元素：
- en: '[PRE96]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Finally, we call our functions with some test data:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用一些测试数据调用我们的函数：
- en: '[PRE97]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Activity 22: Airport System Management'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动22：机场系统管理
- en: 'We start by creating the class for `Airplane`. Make sure to first include the
    header for `variant`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建 `Airplane` 类。确保首先包含 `variant` 的头文件：
- en: '[PRE98]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, create the class with a constructor that sets the current state of the
    airplane to `AtGate`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个具有构造函数的类，该构造函数将飞机的当前状态设置为 `AtGate`：
- en: '[PRE99]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Now, implement the `startTaxi()` method. First, check the current state of the
    airplane with `std::holds_alternative<>()`, and if the airplane is not in the
    correct state, write an error message and return.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现 `startTaxi()` 方法。首先，使用 `std::holds_alternative<>()` 检查飞机的当前状态，如果飞机不在正确的状态，则写入错误信息并返回。
- en: 'If the airplane is in the correct state, change the state to taxi by assigning
    it to the `variant`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果飞机处于正确的状态，则将状态更改为 taxi，通过将其分配给 `variant`：
- en: '[PRE100]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We repeat the same process for the `takeOff()` method:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对 `takeOff()` 方法重复相同的过程：
- en: '[PRE101]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We can now start looking at the `currentStatus()` method. Since we want to perform
    an operation for each of the states in the `variant`, we can use a visitor.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以开始查看 `currentStatus()` 方法。由于我们想要对 `variant` 中的每个状态执行操作，我们可以使用访问者。
- en: 'Outside the `Airplane` class, create a class that has a method `operator()`
    for each of the types in the airplane state. Inside the method, print the information
    of the state. Remember to make the methods public:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Airplane` 类外部，创建一个具有为飞机状态中的每个类型提供 `operator()` 方法的类。在方法内部，打印状态信息。请记住使这些方法为公共：
- en: '[PRE102]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, create the `currentStatus()` method and call the visitor on the state
    using `std::visit`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建 `currentStatus()` 方法并使用 `std::visit` 在状态上调用访问者：
- en: '[PRE103]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We can now try to call the functions of `Airplane` from the `main` function:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以尝试从 `main` 函数中调用 `Airplane` 的函数：
- en: '[PRE104]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Lesson 6: Object-Oriented Programming'
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6课：面向对象编程
- en: 'Activity 23: Creating Game Characters'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动23：创建游戏角色
- en: 'Create a `Character` class that has a `public` method `moveTo` that prints
    `Moved to position`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有 `public` 方法 `moveTo` 的 `Character` 类，该方法打印 `Moved to position`：
- en: '[PRE105]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Create a `struct` named `Position`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Position` 的 `struct`：
- en: '[PRE106]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Create two classes `Hero` and `Enemy` that are derived from the class `Character`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个从 `Character` 类派生的类 `Hero` 和 `Enemy`：
- en: '[PRE107]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create a class `Spell` with the constructor that prints the name of the person
    casting the spell:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有打印施展法术的人名的构造函数的 `Spell` 类：
- en: '[PRE108]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The class `Hero` should have a public method to cast a spell. Use the value
    from the `Spell` class:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `Hero` 应该有一个公共方法来施展法术。使用 `Spell` 类的值：
- en: '[PRE109]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The class `Enemy` should have a public method to swing a sword which prints
    `Swinging sword`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `Enemy` 应该有一个公共方法来挥舞剑，打印 `Swinging sword`：
- en: '[PRE110]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Implement the `main` method that calls these methods in various classes:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现调用这些方法的各种类的 `main` 方法：
- en: '[PRE111]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Activity 24: Calculating Employee Salaries'
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 24：计算员工工资
- en: 'We can create a class `Employee` with two virtual methods, `getBaseSalary`
    and `getBonus`, since we want to change those methods based on the type of employee:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个具有两个虚拟方法 `getBaseSalary` 和 `getBonus` 的 `Employee` 类，因为我们希望根据员工类型更改这些方法：
- en: '[PRE112]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We also define a method, `getTotalComp`, which does not need to be virtual,
    but will call the two virtual methods:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了一个方法 `getTotalComp`，它不需要是虚拟的，但会调用两个虚拟方法：
- en: '[PRE113]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We then derive a `Manager` class from it, overriding the method for computing
    the bonus. We might also want to override `getBaseSalary` if we want to give a
    different base salary to managers:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从它派生出 `Manager` 类，重写计算奖金的方法。我们可能还希望重写 `getBaseSalary`，如果我们想给经理提供不同的基本工资：
- en: '[PRE114]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Create a class `Department` as shown:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Department` 类，如下所示：
- en: '[PRE115]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now, in the `main` function, call the `Department`, `Employee`, and `Manager`
    classes as shown:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `main` 函数中，按照如下所示调用 `Department`、`Employee` 和 `Manager` 类：
- en: '[PRE116]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Activity 25: Retrieving User Information'
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 25：检索用户信息
- en: 'We have to write the code that can be independent of where the data is coming
    from. So, we create an interface `UserProfileStorage` for retrieving the `CustomerProfile`
    from a `UserId`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须编写可以独立于数据来源的代码。因此，我们创建了一个接口 `UserProfileStorage`，用于从 `UserId` 检索 `CustomerProfile`：
- en: '[PRE117]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Now, write the `UserProfileCache` class that inherits from `UserProfileStorage`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写继承自 `UserProfileStorage` 的 `UserProfileCache` 类：
- en: '[PRE118]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'In the `main` function, call the `UserProfileCache` class and `exampleOfUsage`
    function as shown:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，按照如下所示调用 `UserProfileCache` 类和 `exampleOfUsage` 函数：
- en: '[PRE119]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Activity 26: Creating a Factory for UserProfileStorage'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 26：创建 UserProfileStorage 工厂
- en: 'Write the following code that needs the `UserProfileStorage` class, as shown.
    To allow that, we provide a factory class, which has a method `create` that provides
    an instance of `UserProfileStorage`. Write this class making sure that the user
    does not have to manage the memory for the interface manually:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下需要 `UserProfileStorage` 类的代码，如下所示。为了实现这一点，我们提供了一个工厂类，它有一个 `create` 方法，提供
    `UserProfileStorage` 的实例。编写这个类时，确保用户不需要手动管理接口的内存：
- en: '[PRE120]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We want the `UserProfileStorageFactory` class to return a `unique_ptr` so that
    it manages the lifetime of the interface:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望 `UserProfileStorageFactory` 类返回一个 `unique_ptr`，以便它管理接口的生存期：
- en: '[PRE121]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now, in the `main` function, call the `UserProfileStorageFactory` class as
    shown:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `main` 函数中，按照如下所示调用 `UserProfileStorageFactory` 类：
- en: '[PRE122]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Activity 27: Using a Database Connection for Multiple Operations'
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 27：使用数据库连接进行多项操作
- en: 'First, create a `DatabaseConnection` class that can be used in parallel. We
    want to reuse it as much as possible, and we know we can use `std::async` to start
    a new parallel task:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个可以在并行中使用 `DatabaseConnection` 类。我们希望尽可能多地重用它，我们知道我们可以使用 `std::async`
    来启动一个新的并行任务：
- en: '[PRE123]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Assuming there are two functions `updateOrderList(DatabaseConnection&)` and
    `scheduleOrderProcessing(DatabaseConnection&)`, write a function that creates
    a `DatabaseConnection` and gives it to the two parallel tasks. (Note that we don’t
    know which task finishes first):'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设有两个函数 `updateOrderList(DatabaseConnection&)` 和 `scheduleOrderProcessing(DatabaseConnection&)`，编写一个函数来创建
    `DatabaseConnection` 并将其传递给两个并行任务。（注意，我们不知道哪个任务先完成）：
- en: '[PRE124]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: You must understand when and how to create a `shared_ptr`. You can also use
    the following code to write the `shared_ptr` correctly.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须理解何时以及如何创建 `shared_ptr`。你也可以使用以下代码来正确编写 `shared_ptr`。
- en: '[PRE125]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: There are several users of the connection, and we do not know which one is the
    owner, since the connection needs to stay alive as long as anyone is using it.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有多个用户使用这个连接，我们不知道哪个是所有者，因为只要有人使用它，连接就需要保持活跃。
- en: 'To model this, we use a `shared_ptr`. Remember that we need a copy of the `shared_ptr`
    to exist in order for the connection to remain valid:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了模拟这种情况，我们使用 `shared_ptr`。记住，为了使连接保持有效，我们需要一个 `shared_ptr` 的副本：
- en: '[PRE126]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Create the `main` function as follows:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main` 函数如下：
- en: '[PRE127]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
