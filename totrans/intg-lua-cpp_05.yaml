- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Lua Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue to improve our Lua executor to work with tables.
    Many of the mechanisms are extensions of the learnings from the previous chapter.
    You will also learn about **object-oriented programming** (**OOP**) in Lua and
    how to call Lua object methods. In all, Lua objects are Lua tables by nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Lua table entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Lua arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP in Lua
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Lua table functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You can access the source code for this chapter at [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter05](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter05).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can understand and execute the code in the `begin` folder from the preceding
    GitHub link. If you haven’t already done so, please try to do the exercises in
    the previous chapter on your own, or at least understand the solutions in the
    `begin` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can understand the `Makefile` located in GitHub and can build the projects.
    Alternatively, you can use your own way to build the source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Lua table entries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **table entry** is the key-value pair for a table element. Lua table keys
    can be of many data types – for example, of function type. For practical reasons,
    especially when integrating with C++, we only consider string keys and integer
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `script.lua`, add a simple table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`position` is indexed by strings. We will learn how to read from and write
    to it in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting a table entry value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, in C++ code, we have only used one piece of information to locate
    a value in Lua. Consider how we implemented `LuaExecutor::getGlobal` and `LuaExecutor::call`.
    To locate a global variable or to call a function, we pass the name of the variable
    or the function to a Lua library method.
  prefs: []
  type: TYPE_NORMAL
- en: To work with a table entry, we would need two pieces of information – the table
    and the table entry key. First, we need to locate the table; after that, we can
    use the entry key to work on the entry value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Lua library method to get an entry value is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait! We analyzed that we would need two pieces of information to locate a
    table entry, no? How is it possible that `lua_gettable` only takes one meaningful
    argument, `index`, besides the Lua state, `L`? Remember the Lua stack? The top
    of the stack is commonly used to pass additional information. To quote the Lua
    reference manual, `lua_gettable` does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pushes onto the stack the value* `t[k]`*, where* `t` *is the value at the
    given* `index` *and* `k` *is the value on the top of the stack. This function
    pops the key from the stack, pushing the resulting value in its place. (*[https://www.lua.org/manual/5.4/manual.xhtml#lua_gettable](https://www.lua.org/manual/5.4/manual.xhtml#lua_gettable)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As explained, the two keys are both located in the Lua stack. As seen in *Figure
    5**.1*, before the call, the table entry key must be at the top of the stack,
    while the table can be in any other position in the stack. This is a Lua design
    decision. Since you may work on the same table from time to time, you can keep
    the table reference somewhere in the stack to avoid repeatedly pushing it onto
    the stack for each access:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – lua_gettable](img/B20927_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – lua_gettable
  prefs: []
  type: TYPE_NORMAL
- en: 'After understanding the mechanism, it’s time to make a design decision. How
    should we implement the table access in C++? Here are some possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: We can push the table onto the stack and keep it there. For example, if we are
    working with a complex table, we can implement a C++ class to load the table at
    the bottom of the stack and have the C++ object work exclusively with the table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can push the table onto the stack whenever we need to and pop it immediately
    after it’s no longer needed. This works well if the C++ class is working with
    many Lua values and it is not a performance concern to push the Lua table each
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we are implementing a general Lua executor, we will choose the latter
    option. In `LuaExecutor.h`, declare the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes the table name and the table entry key name and returns a `LuaValue`
    instance. We are only concerned about the string-type key at the moment. In `LuaExecutor.cc`,
    implement it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is doing the following things to get a table entry value:'
  prefs: []
  type: TYPE_NORMAL
- en: It pushes the table reference onto the top of the stack with `lua_getglobal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pushes the table entry key onto the top of the stack with `lua_pushstring`.
    Now, the table is the second from the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It calls `lua_gettable` to pop the entry key and push the entry value. Now,
    the entry value is at the top of the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pops the top of the stack as a `LuaValue` with `LuaExecutor::popValue`. Now,
    the top of the stack is again the table reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pops the table with `lua_pop`, as it’s no longer needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns the table entry value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this implementation, we limit ourselves to only working with tables in the
    global scope. This is because we are implementing a general Lua executor. For
    special use cases, you can implement specific C++ classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how to set a table entry value.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a table entry value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Lua library function to set a table entry value is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And the quote from the Lua reference manual explains it well:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Does the equivalent to* `t[k] = v`*, where* `t` *is the value at the given
    index*, `v` *is the value on the top of the stack, and* `k` *is the value just
    below the top. Pops both the key and the value from the stack. (*[https://www.lua.org/manual/5.4/manual.xhtml#lua_settable](https://www.lua.org/manual/5.4/manual.xhtml#lua_settable)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be seen in *Figure 5**.2*. Now, we need to push both the entry key
    and the entry value onto the Lua stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – lua_settable](img/B20927_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – lua_settable
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LuaExecutor.h`, add the function declaration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are passing the value as a `LuaValue`. In `LuaExecutor.cc`, implement it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is explained in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It pushes the table reference onto the top of the stack with `lua_getglobal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pushes the table entry key onto the stack with `lua_pushstring`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pushes the table entry value onto the stack with `LuaExecutor::pushValue`.
    Now, the table reference is the third from the top of the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sets the table entry with `lua_settable`. This also pops the top two items
    from the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pops the table with `lua_pop`. The table is pushed onto the stack in *step
    1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let’s test our implementations so far.
  prefs: []
  type: TYPE_NORMAL
- en: Testing table operations with string keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `main.cpp`, add the following helper function to print out a `position`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`dumpPosition` calls `LuaExecutor::getTable`, which we have just implemented,
    to get and print the `x` field and the `y` field. In `main()`, change the test
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This first prints a `position` table, then changes `position.x` to `3` and
    `position.y` to `4` and prints the table again. If you have done everything correctly,
    you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s learn how to work with integer types of table keys.
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember?
  prefs: []
  type: TYPE_NORMAL
- en: If a Lua table uses integer keys exclusively, what else can the table be called?
  prefs: []
  type: TYPE_NORMAL
- en: Working with Lua arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yes – a Lua table with only integer keys is called an array or a sequence.
    In `script.lua`, add the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From the C++ side, compared with string keys, the only difference is the data
    type of the keys. It’s straightforward to overload the `getTable` and `setTable`
    functions by using integer keys. In `LuaExecutor.h`, add the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`index` is the Lua array index – starting from 1\. Do not confuse this with
    the Lua stack index. In the Lua executor’s public APIs, there should be no mention
    of the Lua stack or Lua state.'
  prefs: []
  type: TYPE_NORMAL
- en: One way to implement them is to copy the string key version, and instead of
    calling `lua_pushstring(L, key.c_str())`, call `lua_pushinteger(L, index)`. This
    will work. But what’s the point of repeating ourselves if this is what we would
    do? Is there another trick?
  prefs: []
  type: TYPE_NORMAL
- en: Using array index optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lua puts lots of emphasis on speed. Because an array is a common form of a
    Lua table, the Lua library provides special functions to work with arrays, as
    seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These functions accept two pieces of information. The `index` argument is the
    position of the table in the Lua stack. The `key` argument is the array index,
    as it is also the table entry key. Compared with using `lua_gettable` and `lua_settable`,
    you no longer need to push the table entry key onto the stack. `lua_seti` expects
    the value to be at the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s implement the `getTable` function for arrays. In `LuaExecutor.cc`,
    add the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It gets the table from a global variable and pushes its reference onto the top
    of the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It calls `lua_geti` with the specified array index. The Lua library will push
    the value onto the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pops the value as a `LuaValue` with `LuaExecutor::popValue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pops the table reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This does not need to push the array index onto the stack at all. Similarly,
    implement the `setTable` function for arrays. In `LuaExecutor.cc`, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It gets the table from a global variable and pushes its reference onto the top
    of the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pushes the value for the `index` array position with `LuaExecutor::pushValue`.
    Now, the table reference is second from the top of the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It calls `lua_seti` to set the array position value. It also pops the value
    from the stack. Now, the table reference is again at the top of the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pops the table reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let’s test this.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the array index optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `main.cpp`, add another helper function to print a `seq` Lua array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses `LuaExecutor::getTable` with integer keys. Replace the test code
    in `main()` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes the `seq` array to `{ 3, 9, 27 }`. If you have done everything
    correctly, you should see the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Well done, Lua, for the optimization. And well done, yourself, for making it
    this far. But how about string keys? In real-world scenarios, more often than
    not, a Lua table is not an array.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting string keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we first learned to use a string key to access the Lua table, we chose
    the longer journey to push the key onto the stack. This is because it is a general
    mechanism, and once learned, you can change to use another data type as table
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is fair to expect an optimization for string keys as well. Here are the
    Lua library functions for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These functions work similarly to `lua_geti` and `lua_seti`. `lua_getfield`
    also returns the type of the table entry value. At the end of this chapter, you
    will get homework to rewrite `LuaExecutor` with them. You can also choose to do
    it right now.
  prefs: []
  type: TYPE_NORMAL
- en: Before learning how to call a function from a Lua table, let’s write a Lua class.
    Lua tables with functions are more like C++ objects.
  prefs: []
  type: TYPE_NORMAL
- en: OOP in Lua
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP in Lua is different than that in C++. In C++, you define a class and create
    instances of the class. The classes defined are unique types at the language level.
  prefs: []
  type: TYPE_NORMAL
- en: In Lua, there is no native class concept. OOP in Lua is prototype-based. This
    is more like JavaScript if you are familiar with it. For a Lua table, if an entry
    is not present, you can instruct Lua to check another table for it, which acts
    as the prototype for the table you are explicitly referencing.
  prefs: []
  type: TYPE_NORMAL
- en: For ease of understanding, it’s fine to call this prototype table the “class”
    and the table the “object”. Or, you can call the relationship “inheritance.” Although
    prototype and class are two different **object-oriented** (**OO**) methodologies,
    sometimes people use the two terms interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a class that we will use to learn how to call Lua table functions.
    Suppose we want to keep a list of places we want to go and note whether we have
    visited them. In `script.lua`, define a table to be used as the prototype as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We defined a table named `Destinations`. It contains a map named `places` to
    track locations and keep a tab on whether or not they were visited. The key will
    be the places we want to go, and the value will be *Booleans*. We will define
    table functions after we have explained how we can use **metatables** to achieve
    OO behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Using Lua metatables to achieve inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `Destinations` is first of all a plain table, by default you can modify
    its `places` entry. How can we prevent users from using it directly? Probably
    you already know or have guessed. We need to set a Lua metatable. We can use `setmetatable`
    to overwrite some operations on the tables. This is comparable to operator overloading
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we set the `__newindex` `Destinations.places` to a function that
    does nothing but print an error message. `__newindex` is called when we assign
    to an absent table key. This is similar to overloading the C++ subscript operator.
    We could go to more extremes, but it’s fine with this simple limitation to show
    an attitude.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an `__index` metamethod we can provide that is used to access
    absent table keys. This is how we can achieve inheritance behavior. Suppose that
    we have a table named `dst` that uses `Destinations` as its prototype. When we
    call `dst.wish()` to add a city to the wish list, what Lua is really doing is
    first looking up the function via `dst["wish"]`. Since `dst` does not have a `wish`
    method, Lua calls the `__index` metamethod, in which we can call the `wish` method
    in the `Destinations` table. This is how `Destinations` acts as the prototype
    for `dst`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see it in action, in `script.lua`, add a constructor for `Destinations`
    to create new instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new` method involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a new `obj` local table with an entry named `places`, matching the
    prototype table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sets `obj`’s `__index` metamethod as the `Destination` table. This is another
    syntax sugar that you can use to set a table as the metamethod. Then, Lua will
    redirect the lookup for absent keys to the prototype table directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It assigns the newly created object to a global variable if `global_name` is
    provided. Global variables are held in the unique table, `_G`. If we used the
    code purely in Lua, we wouldn’t need this step. This is to make the new object
    easily accessible in C++.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns the new object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: More about design decisions
  prefs: []
  type: TYPE_NORMAL
- en: 'We provided an option to set a global variable in an object creator. This is
    a bit unusual and can be considered to cause a side effect from a constructor.
    You should not blindly copy this paradigm. Consider the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to create a Lua executor, do something, and then let it go. This is
    like invoking a shell command. Most examples in this book use Lua in this way.
    There is little chance of abusing the global scope. So, assigning the object to
    a global variable is convenient and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: You need to work with a Lua executor heavily for many things. Then, you can
    implement a special C++ function to create and keep the table in the stack, and
    another function to remove it later.
  prefs: []
  type: TYPE_NORMAL
- en: You need to work with a table object exclusively. You might create it in C++’s
    constructor and keep the table at the bottom of the Lua stack, as pointed out
    earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Better yet, do not use Lua tables at all. In this book, we need to learn how
    to integrate Lua tables with C++ so that you can do very complex interactions
    when you need to. But maybe you could divide the C++ domain and the Lua domain
    more cleanly, and they only send each other simple instructions and results.
  prefs: []
  type: TYPE_NORMAL
- en: With object construction sorted out, we can implement its member functions to
    make `Destinations` complete.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Lua class member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a fully functional destination wish list, we need methods to add a place
    to the wish list. Mark a place visited and check the status of the wish list.
    Let’s define the wish list modifying functions first. In `script.lua`, add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `wish` function takes a variable number of arguments, adds them to the `places`
    map as keys, and sets their values as `false` to indicate an unvisited state.
    The `went` function is similar and marks its arguments as visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'The colon operator (`:`) is a syntax sugar to pass the table as the `self`
    parameter to the function. For example, our declaration of the `wish` function
    is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, `self` will be the table referenced to call the `wish` method. This `self`
    argument is how most OOP languages work. C++ hides it from you and passes a `this`
    pointer to the compiled member methods. Python needs `self` as the first argument
    explicitly in member function definitions, with no syntax sugar available. But
    when calling the Python member functions, you do not need to pass `self` explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, implement the wish list query functions in `script.lua` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These functions list visited places and unvisited places respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can test the `Destinations` class in a Lua interpreter to make sure it
    is implemented correctly before using it in C++. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can add some cities to the wish list, mark one as visited, and print out
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: With a Lua class ready, we can learn how to call Lua table functions from C++.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Lua table functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our Lua executor, we want to call table functions with the same level of
    support as calling global functions. Similar to `call` and `vcall`, we can define
    two functions named `tcall` and `vtcall` that call table functions and return
    a single value and a list of values respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add two more pieces of information to the new C++ member functions
    – namely, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The table name, which is obvious
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether we should pass the `self` argument to the table function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More on the latter point:'
  prefs: []
  type: TYPE_NORMAL
- en: When the table function does not refer `self` and is used like C++ static member
    functions, we do not need to pass `self`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the table function refers `self` and is used like C++ member functions,
    we need to pass `self`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s implement the code to reinforce what we have just talked about.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing table function support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `LuaExecutor.h`, add the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`table` is the table name. `function` is the function name, which is a key
    in the table. `shouldPassSelf` denotes whether we should pass the table as the
    first argument to the table function. `params` is a list of function arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s code the `tcall` function in `LuaExecutor.h` as follows; note that
    the parameter list has been omitted to save space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous listing, it’s doing six steps separated by newlines, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It gets a global table and pushes it onto the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pushes the table function onto the stack. We are using the `lua_getfield`
    shortcut.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pushes the table reference onto the stack again, if `shouldPassSelf` is `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pushes the remaining function arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It calls the table function. Pay attention to the number of parameters passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pops the table function result, pops the table reference pushed in *step
    1*, and returns the function result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have done your homework for the previous chapter, you can insert `dumpStack();`
    at the newlines and see how the Lua stack changes.
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment to digest the `vcall` implementation. And now, you need to implement
    `vtcall` on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Tips
  prefs: []
  type: TYPE_NORMAL
- en: Reference `vcall` and `tcall`. Pay special attention to getting the count of
    returned values and where you should put `int stackSz =` `lua_gettop(L);`.
  prefs: []
  type: TYPE_NORMAL
- en: You can test if you have implemented `vtcall` correctly with the test code that
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will work with the Lua `Destinations` class in C++. In `main.cpp`, replace
    the test code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is doing the same thing as when we tested `Destinations` in the interactive
    Lua interpreter. An explanation for this is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates an instance of the class and stores the object in the `dst` global
    variable. In the `lua->tcall` invocation we set `shouldPassSelf` as `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It adds three cities to the wish list of `dst`. From now on, we are working
    with `dst` and are passing the instance as a `self` argument to the table functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It marks `Paris` as `visited`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It gets a list of visited cities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It gets a list of unvisited cities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines to print the `visited` and `unvisited` lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the code. If you have done everything correctly, you should
    see an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have implemented in C++ a mechanism to call Lua table functions.
    This is by far the most complex logic we have learned!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to work with Lua tables in C++. We also touched
    on OOP in Lua and how it differs from that in C++.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored some design decisions and why `LuaExecutor` is implemented
    in the way it is. It is designed to learn how to integrate Lua with C++, with
    a structure that can be broken down into chapters.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you can use `LuaExecutor` to call most Lua scripts, although it has
    some limitations. For example, we do not support passing another table, except
    `self`, as a parameter to a function. You can try to implement such a function
    on your own, but it is likely not a good idea. It is better to keep the communication
    between Lua and C++ simple.
  prefs: []
  type: TYPE_NORMAL
- en: Take your time to experiment and practice what we have learned. The focus so
    far is on how to call Lua code from C++. In the next chapter, we will start to
    learn how to call C++ code from Lua.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rewrite the string key overload version of `LuaExecutor::getTable` and `LuaExecutor::setTable`.
    Use the `lua_getfield` and `lua_setfield` Lua library functions. You can use the
    same test code in this chapter to test whether you have implemented them correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `LuaExecutor::vtcall`. You should have already done so whether you
    have reached this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Part 3 – Calling C++ from Lua
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With your knowledge of calling Lua from C++, in this part, you will continue
    to learn how to call C++ from Lua.
  prefs: []
  type: TYPE_NORMAL
- en: You will start by learning how to implement and export a C++ function that can
    be called from Lua scripts. Then, the complexity will increase step by step. You
    will export a C++ class as a Lua module and improve the process of how it is exported.
    Finally, you will have a general module exporter that can help you to export any
    C++ class to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 6*, *How to Call C++ from Lua*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 7*, *Working with C++ Types*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 8*, *Abstracting a C++ Type Exporter*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
