- en: Chapter 6. Rendering and Texturing Particle Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 渲染和纹理化粒子系统
- en: 'In this chapter we will learn about:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Texturing particles
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理化粒子
- en: Adding a tail to our particles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的粒子添加尾巴
- en: Creating a cloth simulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建布料模拟
- en: Texturing a cloth simulation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理化布料模拟
- en: Texturing the particle system using point sprites and shaders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点精灵和着色器纹理化粒子系统
- en: Connecting particles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接粒子
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Continuing from [Chapter 5](ch05.html "Chapter 5. Building Particle Systems"),
    *Building Particle Systems*, we will learn how to render and apply textures to
    our particles in order to make them more appealing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第5章](ch05.html "第5章. 构建粒子系统")，*构建粒子系统*继续，我们将学习如何渲染和将纹理应用到我们的粒子上，以使它们更具吸引力。
- en: Texturing particles
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理化粒子
- en: In this recipe we will render particles introduced in the previous chapter using
    texture loaded from the PNG file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用从PNG文件加载的纹理来渲染上一章中引入的粒子。
- en: Getting started
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始
- en: This recipe code base is an example of the recipe *Simulating particles flying
    on the wind* from [Chapter 5](ch05.html "Chapter 5. Building Particle Systems"),
    *Building Particle Systems*. We also need a texture for a single particle. You
    can prepare one easily with probably any graphical program. For this example,
    we are going to use a PNG file with transparency stored inside the `assets` folder
    with a name, `particle.png`. In this case it is just a radial gradient with transparency.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码库是[第5章](ch05.html "第5章. 构建粒子系统")，*构建粒子系统*中*模拟粒子随风飘动*的食谱示例。我们还需要一个单个粒子的纹理。你可以用任何图形程序轻松制作一个。对于这个例子，我们将使用存储在`assets`文件夹中名为`particle.png`的PNG文件。在这种情况下，它只是一个带有透明度的径向渐变。
- en: '![Getting started](img/8703OS_06_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![开始](img/8703OS_06_01.jpg)'
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We will render particles using the previously created texture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前创建的纹理来渲染粒子。
- en: 'Include the necessary header files:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a member to the application main class:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向应用程序主类添加一个成员：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `setup` method load `particleTexture`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中加载`particleTexture`：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also have to change the particle size for this example:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须更改此示例中的粒子大小：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At the end of the `draw` method we will draw our particles as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法结束时，我们将按照以下方式绘制我们的粒子：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Replace the `draw` method inside the `Particle.cpp` source file with the following
    code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Particle.cpp`源文件内的`draw`方法替换为以下代码：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In step 5, we saw two important lines. One enables alpha blending and the other
    binds our texture stored in the `particleTexture` property. If you look at step
    6, you can see we drew each particle as a rectangle and each rectangle had texture
    applied. It is a simple way of texturing particles and not very performance effective,
    but in this case, it works quite well. It is possible to change the color of drawing
    particles by changing the color just before invoking the `draw` method on `ParticleSystem`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤5中，我们看到了两条重要的行。一条启用了alpha混合，另一条将存储在`particleTexture`属性中的纹理绑定。如果你看步骤6，你可以看到我们以矩形的形式绘制了每个粒子，每个矩形都应用了纹理。这是一种简单的纹理化粒子的方法，但不是非常高效，但在这个例子中，它相当有效。通过在调用`ParticleSystem`上的`draw`方法之前更改颜色，可以更改绘制粒子的颜色。
- en: '![How it works…](img/8703OS_06_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/8703OS_06_02.jpg)'
- en: See also
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Look into the recipe *Texturing the particle system using Point sprites and
    shaders*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 查看食谱*使用点精灵和着色器纹理化粒子系统*
- en: Adding a tail to our particles
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的粒子添加尾巴
- en: In this recipe, we will show you how to add a tail to the particle animation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将向您展示如何为粒子动画添加尾巴。
- en: Getting started
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始
- en: In this recipe we are going to use the code base from the recipe *Applying repulsion
    and attraction forces* from [Chapter 5](ch05.html "Chapter 5. Building Particle
    Systems"), *Building Particle Systems*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用来自[第5章](ch05.html "第5章. 构建粒子系统")，*构建粒子系统*中*应用排斥和吸引力的力*的代码库。
- en: How to do it…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We will add a tail to the particles using different techniques.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用不同的技术为粒子添加尾巴。
- en: Drawing history
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制历史
- en: 'Simply replace the `draw` method with the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地替换`draw`方法为以下代码：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tail as a line
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尾巴作为线条
- en: We will add a tail constructed from several lines.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加由几条线构成的尾巴。
- en: 'Add new properties to the `Particle` class inside the `Particle.h` header file:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle.h`头文件内的`Particle`类中添加新的属性：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the end of the `Particle` constructor, inside the `Particle.cpp` source
    file, set the default value to the `tailLength` property:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle`构造函数的末尾，在`Particle.cpp`源文件中，将`tailLength`属性的默认值设置为：
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At the end of the `update` method of the `Particle` class add the following
    code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Particle`类的`update`方法末尾添加以下代码：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace your `Particle::draw` method with the following code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的`Particle::draw`方法替换为以下代码：
- en: '[PRE10]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Now, we will explain how each technique works.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解释每种技术是如何工作的。
- en: Drawing history
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制历史
- en: The idea behind this method is very simple, instead of clearing the drawing
    area, we are continuously drawing semi-transparent rectangles that cover old drawing
    states more and more. This very simple method can give you interesting effects
    with particles. You can also manipulate the opacity of each rectangle by changing
    the alpha channel of the rectangle color, which becomes a color of the background.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的背后思想非常简单，我们不是清除绘图区域，而是连续绘制半透明的矩形，这些矩形越来越多地覆盖旧的绘图状态。这种方法非常简单，但可以给粒子带来有趣的效果。您还可以通过更改矩形的alpha通道来操纵每个矩形的透明度，这将成为背景的颜色。
- en: '![Drawing history](img/8703OS_06_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![绘制历史](img/8703OS_06_03.jpg)'
- en: Tail as a line
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾巴作为线条
- en: To draw a tail with lines, we have to store several particle positions and draw
    a line through these locations with variable opacity. The rule for opacity is
    just to draw older locations with less opacity. You can see the drawing code and
    alpha channel calculation in step 4
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要用线条绘制尾巴，我们必须存储几个粒子位置，并通过这些位置绘制具有可变透明度的线条。透明度的规则只是用较低的透明度绘制较旧的位置。您可以在步骤4中看到绘图代码和alpha通道计算。
- en: '![Tail as a line](img/8703OS_06_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![尾巴作为线条](img/8703OS_06_04.jpg)'
- en: Creating a cloth simulation
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建布料模拟
- en: In this recipe we will learn how to simulate cloth by creating a grid of particles
    connected by springs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何通过创建由弹簧连接的粒子网格来模拟布料。
- en: Getting Ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will be using the particle system described in the recipe
    *Creating a particle system in 2D* from [Chapter 5](ch05.html "Chapter 5. Building
    Particle Systems"), *Building Particle Systems*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用[第5章](ch05.html "第5章。构建粒子系统")中描述的粒子系统，*构建粒子系统*中的“在2D中创建粒子系统”。
- en: We will also be using the `Springs` class created in the recipe *Creating springs*
    from [Chapter 5](ch05.html "Chapter 5. Building Particle Systems"), *Building
    Particle Systems*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用在[第5章](ch05.html "第5章。构建粒子系统")中通过“创建弹簧”食谱创建的`Springs`类，*构建粒子系统*。
- en: 'So, you will need to add the following files to your project:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要将以下文件添加到您的项目中：
- en: '`Particle.h`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Particle.h`'
- en: '`ParticleSystem.h`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParticleSystem.h`'
- en: '`Spring.h`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spring.h`'
- en: '`Spring.cpp`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spring.cpp`'
- en: How to do it…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will create a grid of particles connected with springs to create a cloth
    simulation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个由弹簧连接的粒子网格来创建布料模拟。
- en: 'Include the particle system file in your project by adding the following code
    on top of your source file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在源文件顶部添加以下代码将粒子系统文件包含到您的项目中：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the `using` statements before the application class declaration as shown
    in the following code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序类声明之前添加`using`语句，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create an instance of a `ParticleSystem` object and member variables to store
    the top corners of the grid. We will also create variables to store the number
    of rows and lines that make up our grid. Add the following code in your application
    class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ParticleSystem`对象实例和存储网格顶角的成员变量。我们还将创建存储组成我们网格的行数和列数的变量。在您的应用程序类中添加以下代码：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Before we start creating our particle grid, let's update and draw our particle
    system in our application's `update` and `draw` methods.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始创建我们的粒子网格之前，让我们更新并绘制我们的应用程序中的`update`和`draw`方法中的粒子系统。
- en: '[PRE14]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `setup` method, let''s initialize the grid corner positions and number
    of rows and lines. Add the following code at the top of the `setup` method:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，让我们初始化网格角落位置和行数。在`setup`方法的顶部添加以下代码：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Calculate the distance between each particle on the grid.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算网格上每个粒子之间的距离。
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s create a grid of evenly spaced particles and add them to `ParticleSystem`.
    We''ll do this by creating a nested loop where each loop index will be used to
    calculate the particle''s position. Add the following code in the `setup` method:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个均匀分布的粒子网格并将它们添加到`ParticleSystem`中。我们将通过创建一个嵌套循环来实现这一点，其中每个循环索引将用于计算粒子的位置。在`setup`方法中添加以下代码：
- en: '[PRE17]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that the particles are created, we need to connect them with springs. Let''s
    start by connecting each particle to the one directly below it. In a nested loop,
    we will calculate the index of the particle in `ParticleSystem` and the one below
    it. We then create a `Spring` class connecting both particles using their current
    distance as `rest` and a `strength` value of `1.0`. Add the following to the bottom
    of the `setup` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在粒子已经创建，我们需要用弹簧将它们连接起来。让我们首先将每个粒子与其正下方的粒子连接起来。在一个嵌套循环中，我们将计算`ParticleSystem`中粒子的索引以及它下面的粒子的索引。然后我们创建一个`Spring`类，使用它们的当前距离作为`rest`和`strength`值为`1.0`来连接这两个粒子。将以下内容添加到`setup`方法的底部：
- en: '[PRE18]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We now have a static grid made out of particles and springs. Let''s add some
    gravity by applying a constant vertical force to each particle. Add the following
    code at the bottom of the `update` method:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个由粒子和弹簧组成的静态网格。让我们通过向每个粒子应用一个恒定的垂直力来添加一些重力。将以下代码添加到`update`方法的底部：
- en: '[PRE19]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To prevent the grid from falling down, we need to make the particles at the
    top edges static in their initial positions, defined by `mLeftCorner` and `mRightCorner`.
    Add the following code to the `update` method:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了防止网格向下坠落，我们需要将顶边界的粒子在它们的初始位置（由`mLeftCorner`和`mRightCorner`定义）设置为静态。将以下代码添加到`update`方法中：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Build and run the application; you'll see a grid of particles falling down with
    gravity, locked by its top corners.![How to do it…](img/8703OS_06_05.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序；您将看到一个带有重力下落的粒子网格，其顶部角落被锁定。![如何做到这一点…](img/8703OS_06_05.jpg)
- en: Let's add some interactivity by allowing the user to drag particles with the
    mouse. Declare a `Particle` pointer to store the particle being dragged.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过允许用户用鼠标拖动粒子来增加一些交互性。声明一个`Particle`指针来存储正在拖动的粒子。
- en: '[PRE21]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `setup` method initialize the particle to `NULL`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中初始化粒子为`NULL`。
- en: '[PRE22]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Declare the `mouseUp` and `mouseDown` methods in the application's class declaration.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的类声明中声明`mouseUp`和`mouseDown`方法。
- en: '[PRE23]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the implementation of the `mouseDown` event, we iterate the overall particles
    and, if a particle is under the cursor, we set `mDragParticle` to point to it.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mouseDown`事件的实现中，我们遍历所有粒子，如果粒子位于光标下，我们将`mDragParticle`设置为指向它。
- en: '[PRE24]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the `mouseUp` event we simply set `mDragParticle` to `NULL`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mouseUp`事件中，我们只需将`mDragParticle`设置为`NULL`。
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need to check if `mDragParticle` is a valid pointer and set the particle''s
    position to the mouse cursor. Add the following code to the `update` method:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要检查`mDragParticle`是否是一个有效的指针并将粒子的位置设置为鼠标光标。将以下代码添加到`update`方法中：
- en: '[PRE26]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Build and run the application. Press and drag the mouse over any particle and
    drag it around to see how the cloth simulation reacts.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。按住并拖动鼠标到任何粒子上，然后将其拖动以查看布料模拟如何反应。
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The cloth simulation is achieved by creating a two dimensional grid of particles
    and connecting them with springs. Each particle will be connected with a spring
    to the ones next to it and to the ones above and below it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 布料模拟是通过创建一个二维粒子网格并使用弹簧连接它们来实现的。每个粒子将与其相邻的粒子以及其上方和下方的粒子通过弹簧连接。
- en: There's more…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: The density of the grid can be changed to accommodate the user's needs. Using
    a grid with more particles will generate a more precise simulation but will be
    slower.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的密度可以根据用户的需求进行更改。使用具有更多粒子的网格将生成更精确的模拟，但速度会较慢。
- en: Change `mNumLines` and `mNumRows` to change the number of particles that make
    up the grid.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改`mNumLines`和`mNumRows`来更改构成网格的粒子的数量。
- en: Texturing a cloth simulation
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布料模拟纹理化
- en: In this recipe, we will learn how to apply a texture to the cloth simulation
    we created in the *Creating a cloth simulation* recipe of the current chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何将纹理应用到我们在当前章节的*创建布料模拟*菜谱中创建的布料模拟上。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using the cloth simulation developed in the recipe *Creating a cloth
    Simulation* as the base for this recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在菜谱*创建布料模拟*中开发的布料模拟作为这个菜谱的基础。
- en: You will also need an image to use as texture; place it inside your `assets`
    folder. In this recipe we will name our image `texture.jpg`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个图像作为纹理；将其放置在您的`assets`文件夹中。在这个菜谱中，我们将我们的图像命名为`texture.jpg`。
- en: How to do it…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We will calculate the correspondent texture coordinate to each particle in the
    cloth simulation and apply a texture.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算布料模拟中每个粒子的对应纹理坐标并应用纹理。
- en: Include the necessary files to work with the texture and read images.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的文件以使用纹理和读取图像。
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Declare a `ci::gl::Texture` object in your application's class declaration.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的应用程序类声明中声明一个`ci::gl::Texture`对象。
- en: '[PRE28]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the `setup` method load the image.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中加载图像。
- en: '[PRE29]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will remake the `draw` method. So we''ll erase everything in it which was
    changed in the *Creating a cloth simulation* recipe and apply the `clear` method.
    Your `draw` method should be like the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重新制作`draw`方法。所以我们将擦除在*创建布料模拟*配方中更改的所有内容，并应用`clear`方法。你的`draw`方法应该如下所示：
- en: '[PRE30]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After the `clear` method call, enable the `VERTEX` and `TEXTURE COORD` arrays
    and bind the texture. Add the following to the `draw` method:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`clear`方法之后，启用`VERTEX`和`TEXTURE COORD`数组并绑定纹理。将以下代码添加到`draw`方法中：
- en: '[PRE31]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will now iterate over all particles and springs that make up the cloth simulation
    grid and draw a textured triangle strip between each row and the row next to it.
    Start by creating a `for` loop with `mNumRows-1` iterations and create two `std::vector<Vec2f>`
    containers to store vertex and texture coordinates.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将遍历构成布料模拟网格的所有粒子和弹簧，并在每一行及其相邻行之间绘制一个纹理三角形条带。首先创建一个`for`循环，循环`mNumRows-1`次，并创建两个`std::vector<Vec2f>`容器来存储顶点和纹理坐标。
- en: '[PRE32]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside the loop we will create a nested loop that will iterate over all lines
    in the cloth grid. In this loop we will calculate the index of the particles whose
    vertices will be drawn, calculate their correspondent texture coordinates, and
    add them with the positions of `textureCoords` and `vertexCoords`. Type the following
    code into the loop that we created in the previous step:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内部，我们将创建一个嵌套循环，该循环将遍历布料网格中的所有行。在这个循环中，我们将计算将要绘制的粒子的索引，计算它们对应的纹理坐标，并将它们与`textureCoords`和`vertexCoords`的位置一起添加。将以下代码输入到我们在上一步创建的循环中：
- en: '[PRE33]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that the `vertex` and `texture` coordinates are calculated and placed inside
    `vertexCoords` and `textureCoords` we will draw them. Here is the complete nested
    loop:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在已经计算并放置了`vertex`和`texture`坐标到`vertexCoords`和`textureCoords`中，我们将绘制它们。以下是完整的嵌套循环：
- en: '[PRE34]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally we need to unbind `mTexture` by adding the following:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要通过添加以下代码来解除`mTexture`的绑定：
- en: '[PRE35]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We calculated the correspondent texture coordinate according to the particle's
    position on the grid. We then drew our texture as triangular strips formed by
    the particles on a row with the particles on the row next to it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据粒子在网格上的位置计算了相应的纹理坐标。然后，我们绘制了由行上的粒子及其相邻行上的粒子形成的三角形条带纹理。
- en: Texturing a particle system using point sprites and shaders
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用点精灵和着色器纹理化粒子系统
- en: In this recipe, we will learn how to apply a texture to all our particles using
    OpenGL point sprites and a GLSL Shader.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用OpenGL点精灵和GLSL着色器将纹理应用到所有粒子。
- en: This method is optimized and allows for a large number of particles to be drawn
    at fast frame rates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法经过优化，允许以快速帧率绘制大量粒子。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be using the particle system developed in the recipe *Creating a particle
    system in 2D* from [Chapter 5](ch05.html "Chapter 5. Building Particle Systems"),
    *Building Particle Systems*. So we will need to add the following files to your
    project:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在[第5章](ch05.html "第5章。构建粒子系统")中开发的2D粒子系统配方*在2D中创建粒子系统*，所以我们需要将以下文件添加到你的项目中：
- en: '`Particle.h`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Particle.h`'
- en: '`ParticleSystem.h`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParticleSystem.h`'
- en: We will also be loading an image to use as texture. The image's size must be
    a power of two, such as 256 x 256 or 512 x 512\. Place the image inside the `assets`
    folder and name it `particle.png`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将加载一个图像作为纹理使用。图像的大小必须是2的幂，例如256 x 256或512 x 512。将图像放置在`assets`文件夹中，并命名为`particle.png`。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will create a GLSL shader and then enable OpenGL point sprites to draw textured
    particles.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个GLSL着色器，然后启用OpenGL点精灵来绘制纹理化的粒子。
- en: 'Let''s begin by creating the GLSL Shader. Create the following files:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建GLSL着色器开始。创建以下文件：
- en: '`shader.frag`'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shader.frag`'
- en: '`shader.vert`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shader.vert`'
- en: Add them to the `assets` folder.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将它们添加到`assets`文件夹中。
- en: 'Open the file `shader.frag` in your IDE of choice and declare a `uniform sampler2D`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你选择的IDE中打开文件`shader.frag`并声明一个`uniform sampler2D`：
- en: '[PRE36]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `main` function we use the texture to define the fragment color. Add
    the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们使用纹理来定义片段颜色。添加以下代码：
- en: '[PRE37]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Open the `shader.vert` file and create `float attribute` to store the particle''s
    radiuses. In the `main` method we define the position, color, and point size attributes.
    Add the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`shader.vert`文件并创建一个`float attribute`来存储粒子的半径。在`main`方法中，我们定义了位置、颜色和点大小属性。添加以下代码：
- en: '[PRE38]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our shader is done! Let''s go to our application source file and include the
    necessary files. Add the following code to your application source file:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的着色器完成了！让我们转到我们的应用程序源文件并包含必要的文件。将以下代码添加到您的应用程序源文件中：
- en: '[PRE39]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Declare the member variables to create a particle system and arrays to store
    the particle's positions and radiuses. Also declare a variable to store the number
    of particles.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明创建粒子系统的成员变量以及存储粒子位置和半径的数组。还声明一个变量来存储粒子的数量。
- en: '[PRE40]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the `setup` method, let's initialize `mNumParticles` to `1000` and allocate
    the arrays. We will also create the random particles.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们将`mNumParticles`初始化为`1000`并分配数组。我们还将创建随机粒子。
- en: '[PRE41]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `update` method, we will update `mParticleSystem` and the `mPositions`
    and `mRadiuses` arrays. Add the following code to the `update` method:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们将更新`mParticleSystem`和`mPositions`以及`mRadiuses`数组。将以下代码添加到`update`方法中：
- en: '[PRE42]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Declare the shaders and the particle's texture.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明着色器和粒子的纹理。
- en: '[PRE43]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Load the shaders and texture by adding the following code in the `setup` method:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`setup`方法中添加以下代码来加载着色器和纹理：
- en: '[PRE44]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the `draw` method, we will start by clearing the background with black, set
    the window's matrices, enable the additive blend, and bind the shader.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中，我们将首先用黑色清除背景，设置窗口的矩阵，启用加法混合，并绑定着色器。
- en: '[PRE45]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Get the location for the `particleRadius` attribute in the `Vertex` shader.
    Enable vertex attribute arrays and set the pointer to `mRadiuses`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Vertex`着色器中获取`particleRadius`属性的定位。启用顶点属性数组并将指针设置为`mRadiuses`。
- en: '[PRE46]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Enable point sprites and enable our shader to write to point sizes.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用点精灵并启用我们的着色器以写入点大小。
- en: '[PRE47]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Enable vertex arrays and set the vertex pointer to `mPositions`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用顶点数组和设置顶点指针为`mPositions`。
- en: '[PRE48]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now enable and bind the texture, draw the vertex array as points, and unbind
    the texture.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在启用并绑定纹理，以点形式绘制顶点数组，然后解绑纹理。
- en: '[PRE49]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: All we need to do now is disable the vertex arrays, disable the vertex attribute
    arrays, and unbind the shader.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是禁用顶点数组，禁用顶点属性数组，并解绑着色器。
- en: '[PRE50]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Build and run the application and you will see `1000` random particles with
    the applied texture.![How to do it...](img/8703OS_06_06.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，你将看到应用了纹理的`1000`个随机粒子。![如何操作...](img/8703OS_06_06.jpg)
- en: How it works…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Point sprites is a nice feature of OpenGL that allows for the application of
    an entire texture to a single point. It is extremely useful when drawing particle
    systems and is quite optimized, since it reduces the amount of information sent
    to the graphics card and performs most of the calculations on the GPU.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 点精灵是OpenGL的一个不错特性，允许将整个纹理应用于单个点。当绘制粒子系统时非常实用，并且相当优化，因为它减少了发送到图形卡的信息量，并在GPU上执行了大部分计算。
- en: In the recipe we also created a GLSL shader, a high-level programming language,
    that allows more control over the programming pipeline, to define individual point
    sizes for each particle.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们还创建了一个GLSL着色器，一种高级编程语言，它允许对编程管道有更多的控制，为每个粒子定义单独的点大小。
- en: In the `update` method we updated the `Positions` and `Radiuses` arrays, so
    that if the particles are animated the arrays will represent the correct values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们更新了`Positions`和`Radiuses`数组，因此如果粒子被动画化，数组将代表正确的值。
- en: There's more…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Point sprites allow us to texturize points in 3D space. To draw the particle
    system in 3D do the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 点精灵允许我们在3D空间中对点进行纹理化。要绘制3D粒子系统，请执行以下操作：
- en: Use the `Particle` class described in the *There's more…* section of the recipe
    *Creating a Particle system in 2D* from [Chapter 5](ch05.html "Chapter 5. Building
    Particle Systems"), *Building Particle Systems*.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用配方中*There's more…*部分描述的*在2D中创建粒子系统*的`Particle`类，来自[第5章](ch05.html "第5章。构建粒子系统")，*构建粒子系统*。
- en: Declare and initialize `mPositions` as a `ci::Vec3f` array.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并初始化`mPositions`为一个`ci::Vec3f`数组。
- en: 'In the `draw` method, indicate that the vertex pointer contains 3D information
    by applying the following change:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中，通过应用以下更改来指示顶点指针包含3D信息：
- en: '[PRE51]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Change the previous code line to:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将之前的代码行更改为：
- en: '[PRE52]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The vertex shader needs to adjust the point size according to the depth of
    the particle. The `shader.vert` file would need to read the following code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器需要根据粒子的深度调整点的大小。`shader.vert` 文件需要读取以下代码：
- en: '[PRE53]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Connecting the dots
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接点
- en: In this recipe we will show how to connect particles with lines and introduce
    another way of drawing particles.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示如何用线条连接粒子，并介绍另一种绘制粒子的方法。
- en: Getting started
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始
- en: This recipe's code base is an example from the recipe *Simulating particles
    flying on the wind* (from [Chapter 5](ch05.html "Chapter 5. Building Particle
    Systems"), *Building Particle Systems*), so please refer to this recipe.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的代码库是来自菜谱 *模拟粒子随风飘动* 的示例（来自[第5章](ch05.html "第5章。构建粒子系统")，*构建粒子系统*），请参考此菜谱。
- en: How to do it…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We will connect particles rendered as circles with lines.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用线条连接渲染为圆形的粒子。
- en: 'Change the number of particles to create inside the `setup` method:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中更改要创建的粒子数量：
- en: '[PRE54]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will calculate `radius` and `mass` of each particle as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将按照以下方式计算每个粒子的 `radius` 和 `mass`：
- en: '[PRE55]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Replace the `draw` method inside the `Particle.cpp` source file with the following:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Particle.cpp` 源文件内的 `draw` 方法替换为以下内容：
- en: '[PRE56]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Replace the `draw` method inside the `ParticleSystem.cpp` source file as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式替换 `ParticleSystem.cpp` 源文件内的 `draw` 方法：
- en: '[PRE57]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: The most interesting part of this example is mentioned in step 4\. We are iterating
    through all the points, actually through all possible pairs of the points, to
    connect it with a line and apply the right opacity. The opacity of the line connecting
    two particles is calculated from the distance between these two particles; the
    longer distance makes the connection line more transparent.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中最有趣的部分在第4步中提到。我们正在遍历所有点，实际上是所有可能的点对，用线条连接它们并应用适当的透明度。连接两个粒子的线条透明度是根据这两个粒子之间的距离计算的；距离越长，连接线越透明。
- en: '![How it works…](img/8703OS_06_07.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/8703OS_06_07.jpg)'
- en: Have a look at how the particles are been drawn in step 3\. They are solid circles
    with a slightly bigger outer circle. The nice detail is the connection line that
    we are drawing between particles that stick to the edge of the outer circle, but
    don't cross it. We have done it in step 4, where we calculated the normalized
    vector of the vectors connecting two particles, then used them to move the attachment
    point towards that vector, multiplied by the outer circle radius.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 看看第3步中粒子的绘制方式。它们是带有略微更大的外圆的实心圆。一个很好的细节是我们绘制粒子之间的连接线，这些粒子粘附在外圆的边缘，但不会穿过它。我们在第4步中做到了这一点，当时我们计算了连接两个粒子的向量的归一化向量，然后使用它们将连接点移动到该向量，乘以外圆半径。
- en: '![How it works…](img/8703OS_06_08.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/8703OS_06_08.jpg)'
- en: Connecting particles with spline
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样条曲线连接粒子
- en: In this recipe we are going to learn how to connect particles with splines in
    3D.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在3D中用样条曲线连接粒子。
- en: Getting started
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始
- en: In this recipe we are going to use the particle's code base from the recipe
    *Creating a particle system*, from [Chapter 5](ch05.html "Chapter 5. Building
    Particle Systems"), *Building Particle Systems*. We are going to use the 3D version.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用来自菜谱 *创建粒子系统* 的粒子代码库，该菜谱位于[第5章](ch05.html "第5章。构建粒子系统")，*构建粒子系统*。我们将使用3D版本。
- en: How to do it…
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We will create splines connecting particles.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建连接粒子的样条曲线。
- en: 'Include the necessary header file inside `ParticleSystem.h`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ParticleSystem.h` 内包含必要的头文件：
- en: '[PRE58]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add a new property to the `ParticleSystem` class:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `ParticleSystem` 类添加一个新属性：
- en: '[PRE59]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Implement the `computeBSpline` method for the `ParticleSystem` class:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `ParticleSystem` 类实现 `computeBSpline` 方法：
- en: '[PRE60]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'At the end of the `ParticleSystem` update method, invoke the following code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ParticleSystem` 更新方法的末尾调用以下代码：
- en: '[PRE61]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Replace the `draw` method of `ParticleSystem` with the following:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ParticleSystem` 的 `draw` 方法替换为以下内容：
- en: '[PRE62]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add headers to your main Cinder application class files:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的主 Cinder 应用程序类文件添加头文件：
- en: '[PRE63]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add members for your `main` class:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的 `main` 类添加成员：
- en: '[PRE64]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Implement the `setup` method as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现 `setup` 方法：
- en: '[PRE65]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add members for camera navigation:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为相机导航添加成员：
- en: '[PRE66]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Implement the `update` method as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现 `update` 方法：
- en: '[PRE67]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Implement the `draw` method as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现 `draw` 方法：
- en: '[PRE68]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works…
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: '**B-spline** lets us draw a very smooth curved line through some given points,
    in our case, particle positions. We can still apply some attraction and repulsion
    forces so that the line behaves quite like a spring. In Cinder, you can use B-splines
    in 2D and 3D space and calculate them with the `BSpline` class.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**B样条**使我们能够通过一些给定的点绘制一条非常平滑的曲线，在我们的情况下，是粒子位置。我们仍然可以应用一些吸引和排斥力，使得这条线的行为相当像弹簧。在
    Cinder 中，你可以在 2D 和 3D 空间中使用 B 样条，并使用 `BSpline` 类来计算它们。'
- en: '![How it works…](img/8703OS_06_09.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/8703OS_06_09.jpg)'
- en: See also
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: More details about B-spline are available at [http://en.wikipedia.org/wiki/B-spline](http://en.wikipedia.org/wiki/B-spline).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 B 样条的更多详细信息可在 [http://zh.wikipedia.org/wiki/B样条](http://zh.wikipedia.org/wiki/B样条)
    找到。
