<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-64"><a id="_idTextAnchor065"/>3</h1>
<h1 id="_idParaDest-65"><a id="_idTextAnchor066"/>Testing the Multiplayer System with a Project Prototype</h1>
<p>Now that you know how networks work and how computers communicate remotely, it’s time to test some of the basic functionalities of the Unreal Engine networking framework. The best way to understand how different elements interact within the UE environment is by using one of the available project templates and enabling its multiplayer capabilities.</p>
<p>The main goal of this chapter is to serve as a gentle introduction to the main UE multiplayer framework features and how to test them on a single device, such as your computer. By the end, you will have created your first multiplayer prototype and will be ready for the next step, which is creating a fully working networked game from scratch.</p>
<p>So, through the next few sections, I will present you with the following topics:</p>
<ul>
<li>Creating a multiplayer game prototype</li>
<li>Testing a multiplayer game locally</li>
<li>Updating properties over the network</li>
<li>Executing functions over the network</li>
</ul>
<h1 id="_idParaDest-66"><a id="_idTextAnchor067"/>Technical requirements</h1>
<p>For this first prototype, you will just need UE 5 to be installed. For this chapter, you won’t be programming in C++, as the prototype will be Blueprints only.</p>
<p>To make things more interesting, I’ll be using some assets from Quixel Megascans by using the integrated plugin, but this is not mandatory.</p>
<p>The finished project can be found in this book’s project template on GitHub, in the <a href="B18203_03.xhtml#_idTextAnchor065"><em class="italic">Chapter 3</em></a> section: <a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout">Starting from this chapter, I will use the terms “Blueprint” and “Blueprint Class” interchangeably. If a distinction needs to be made, I will use the appropriate term, such as “Anim Blueprint.”</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor068"/>Creating a multiplayer game prototype</h1>
<p>For this project, gameplay will not be the primary focus; I want you to concentrate on the core components <a id="_idIndexMarker136"/>of the multiplayer framework. Accordingly, the game will be quite simple and abide by the following basic rules:</p>
<ul>
<li>Each player should control their character</li>
<li>The server will spawn item pickups at random positions</li>
<li>Players will capture pickups and gain points from that</li>
<li>The game will go on indefinitely</li>
</ul>
<p>Using a pre-made project such as a template is a great opportunity for you to gain hands-on experience with the main multiplayer capabilities in UE without having to waste time creating a project from scratch. Here, you’ll start by creating your own multiplayer game prototype by using the <strong class="bold">TopDown</strong> template.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/>Setting up the project from a template</h2>
<p>When you are <a id="_idIndexMarker137"/>ready, launch UE 5 from the Epic Games Launcher. Then, follow these steps:</p>
<ol>
<li>Select <strong class="bold">Games</strong> | <strong class="bold">TopDown</strong> from the available templates.</li>
<li>Set the project to <strong class="bold">Blueprint</strong>.</li>
<li>Name your project (for instance, <code>TopDown_Multiplayer</code>).</li>
<li>Leave the other settings as their default values.</li>
<li>Click the <strong class="bold">Create</strong> button.</li>
</ol>
<p><em class="italic">Figure 3</em><em class="italic">.1</em> shows the finished settings for the project:</p>
<div><div><img alt="Figure 3.1 – Project setup" src="img/Figure_03_01_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Project setup</p>
<p>Once the project <a id="_idIndexMarker138"/>has been created, you are ready to import some content.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Adding Quixel Megascans</h2>
<p>In this project, I want <a id="_idIndexMarker139"/>to use something <a id="_idIndexMarker140"/>a bit crazy for my pickups: I am going to choose some fruit <a id="_idIndexMarker141"/>and vegetables from the Quixel Megascans library (<a href="https://quixel.com/megascans">https://quixel.com/megascans</a>)!</p>
<p><strong class="bold">Quixel Megascans</strong> is a free library that contains high-resolution 3D scans: it is fully integrated with UE; you <a id="_idIndexMarker142"/>will just need to use your Epic Games account. To access the models from UE, you will need to use Quixel Bridge, a plugin that’s already installed in the Unreal Engine Editor.</p>
<p>To add some <a id="_idIndexMarker143"/>Megascans to the project, just do this:</p>
<ol>
<li>Open Quixel Bridge by clicking <strong class="bold">Quickly add to the project</strong> | <strong class="bold">Quixel Bridge</strong>.</li>
<li>From the <strong class="bold">3D Assets</strong> section, look for some fruit or vegetables – or anything that will spark your imagination!</li>
<li>Download the <a id="_idIndexMarker144"/>assets and add them to your project by clicking the <strong class="bold">Download</strong> button.</li>
</ol>
<p><em class="italic">Figure 3</em><em class="italic">.2</em> depicts Quixel Bridge with some of my selected models during the download phase:</p>
<div><div><img alt="Figure 3.2 – Quixel Bridge" src="img/Figure_03_02_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Quixel Bridge</p>
<p>Once you have obtained your assets, they will likely be of various sizes. However, you will need to resize them to create a visually appealing and functional pickup. To do so, follow these steps:</p>
<ol>
<li>From the main menu, create an empty level by selecting <code>Content</code> | <code>Characters</code> | <code>Mannequins</code> | <code>Meshes</code> folder).</li>
<li>Add your <a id="_idIndexMarker145"/>models next to <a id="_idIndexMarker146"/>the reference.</li>
<li>Scale them so that they are about a third of the size of the reference.</li>
</ol>
<p><em class="italic">Figure 3</em><em class="italic">.3</em> shows the models once they have been resized:</p>
<div><div><img alt="Figure 3.3 – The resized models" src="img/Figure_03_03_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – The resized models</p>
<p>Since the pickups will be created from a common Blueprint parent, the best thing to do is to set the scale of the models to 1, which we can achieve through the <strong class="bold">Modeling Tools</strong> available in UE. Open the <strong class="bold">Modeling Tools</strong> panel by selecting it from the <strong class="bold">Mode Selection</strong> dropdown in the <strong class="bold">Main Toolbar</strong> area, as shown in <em class="italic">Figure 3</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 3.4 – Activating the Modeling Tools panel" src="img/Figure_03_04_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Activating the Modeling Tools panel</p>
<p>Once the <strong class="bold">Modeling Tools</strong> panel has been enabled, execute the following steps for each of the models:</p>
<ol>
<li>Select <a id="_idIndexMarker147"/>the model.</li>
<li>Select <strong class="bold">Transform</strong> | <strong class="bold">BakeRS</strong> to <a id="_idIndexMarker148"/>activate the <strong class="bold">Rotation and Scale</strong> baking tool.</li>
<li>In the <strong class="bold">New Asset Location</strong> drop-down menu at the bottom of the tool, select <strong class="bold">AutoGen </strong><strong class="bold">Folder (Global)</strong>.</li>
<li>Click the blue <strong class="bold">Accept</strong> button to start the baking process.</li>
</ol>
<p><em class="italic">Figure 3</em><em class="italic">.5</em> depicts the <strong class="bold">BakeRS</strong> tool open and ready to process a model:</p>
<div><div><img alt="Figure 3.5 – The BakeRS tool" src="img/Figure_03_05_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – The BakeRS tool</p>
<p>At the end of this <a id="_idIndexMarker149"/>process, all three <a id="_idIndexMarker150"/>models will be of equal size, but each scaled to a value of 1.</p>
<p>The last thing you must do is generate a collision for each of the models:</p>
<ol>
<li>Open each of the static meshes in the project.</li>
<li>Open the <strong class="bold">Collision</strong> drop-down menu.</li>
<li>Select <strong class="bold">Add 26DOP Simplified Collision</strong> to add a collision area to the mesh.</li>
<li>Save the modified assets to apply the changes.</li>
</ol>
<p>This scene can be safely closed as you won’t be using it anymore. Open <code>Content</code> | <code>TopDown</code> | <code>Maps</code> folder. By doing this, your assets will be ready to use as pickups in the game.</p>
<p>The next step will be to modify the Player Controller so that you can handle the Pawn movement.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/>Modifying the Player Controller</h2>
<p>The Player Controller from the template is already operational and works properly, but to make the game a <a id="_idIndexMarker151"/>bit more <a id="_idIndexMarker152"/>exciting (it’s a multiplayer game, after all!), you’ll need to make some minor adjustments.</p>
<p>At the moment, character movement is controlled by a single click on a point on the map. However, we want players to be able to move their character by keeping the mouse button pressed and moving it around the level.</p>
<p>Follow these steps to modify the Player Controller Blueprint:</p>
<ol>
<li>Navigate to <strong class="bold">Content</strong> | <strong class="bold">TopDown</strong> | <strong class="bold">Blueprints</strong> and open the <strong class="bold">BP_TopDownController</strong> Blueprint.</li>
<li>Then, open the Event Graph by clicking the <strong class="bold">Event </strong><strong class="bold">Graph</strong> tab.</li>
<li>Delete the <strong class="bold">Set Destination Input – Touch</strong> group as you won’t be using it.</li>
<li>In the <strong class="bold">Set Destination Input – Gamepad and Mouse</strong> group, delete all the nodes connected to the <strong class="bold">Canceled</strong> and <strong class="bold">Completed</strong> execution pins.</li>
<li>Connect the <strong class="bold">Ongoing</strong> execution pin to the same <strong class="bold">Branch</strong> node as the <strong class="bold">Triggered</strong> execution pin.</li>
</ol>
<p>The modified graph should look like this:</p>
<div><div><img alt="Figure 3.6 – The modified graph for the Player Controller" src="img/Figure_03_06_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – The modified graph for the Player Controller</p>
<p>Now that the Player Controller has been modified, if you try playing the game as is, you should be able to move <a id="_idIndexMarker153"/>your character <a id="_idIndexMarker154"/>around whenever you keep the left mouse button pressed. This is the normal behavior you would expect when playing a standalone game.</p>
<p>In the next section, you’ll learn how to set up UE so that it simulates a multiplayer session on your computer.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor072"/>Testing a multiplayer game locally</h1>
<p>Testing a multiplayer game can pose a problem as it requires the game to be available across multiple <a id="_idIndexMarker155"/>devices. Luckily, UE allows you to simulate this scenario on a single computer, making it much easier for developers to create and test multiplayer games. In this section, you will learn how to use your editor as a server and launch other game instances locally.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/>Playing as a Listen Server</h2>
<p>It’s time to start <a id="_idIndexMarker156"/>testing how the game works in a multiplayer environment. You’ll be doing this by using UE’s <strong class="bold">Net </strong><strong class="bold">Mode</strong> feature:</p>
<ol>
<li>Open the <strong class="bold">Change Play Mode and Play Settings</strong> menu by clicking the hamburger button next to the <strong class="bold">Play</strong> button, as shown in <em class="italic">Figure 3</em><em class="italic">.7</em>:</li>
</ol>
<div><div><img alt="Figure 3.7 – The hamburger button" src="img/Figure_03_07_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – The hamburger button</p>
<ol>
<li value="2">In the <code>3</code>.</li>
<li>Then, select <strong class="bold">Net Mode</strong> | <strong class="bold">Play As Listen Server</strong>, as shown in <em class="italic">Figure 3</em><em class="italic">.8</em>:</li>
</ol>
<div><div><img alt="Figure 3.8 – The Net Mode settings" src="img/Figure_03_08_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – The Net Mode settings</p>
<p class="callout-heading">Note</p>
<p class="callout">When you are testing a game in the Editor as a <strong class="bold">Listen Server</strong>, the Editor acts as a server and a client. Depending on the number of players selected, additional instances will be opened for testing purposes. As a side note, launching the game in <strong class="bold">New Editor Window (PIE)</strong> mode will designate one of the screens as the server and the other screens as clients. This distinction can be identified by examining the title bar of the launched windows.</p>
<p>You can now click the <strong class="bold">Play</strong> button, after which the Editor will open one window for each additional player, as depicted in <em class="italic">Figure 3</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 3.9 – Testing the game as a Listen Server" src="img/Figure_03_09_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Testing the game as a Listen Server</p>
<p>Focusing on each <a id="_idIndexMarker157"/>window will let you play each independent character.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you check the <strong class="bold">Outliner</strong> window while in Play Mode, you will notice that there are three <strong class="bold">BP_TopDownCharacter</strong> instances (one for each player), but just one <strong class="bold">BP_TopDownController</strong> – this is the one you will need for the local player.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/>Updating over the network</h2>
<p>At this point, you <a id="_idIndexMarker158"/>may be wondering how characters can be synchronized across different clients, given that we have not done anything related to the network.</p>
<p>The answer is <strong class="bold">replication</strong>, which I explained in the previous chapter, and is demonstrated in this prototype: Character Actors are replication-enabled, so some of their properties, such as <strong class="bold">Location</strong> and <strong class="bold">Rotation</strong>, are updated across clients during gameplay.</p>
<p>To see whether an Actor replicates, do the following:</p>
<ol>
<li>Open the <strong class="bold">BP_TopDownCharacter</strong> Blueprint by going to <strong class="bold">Content</strong> | <strong class="bold">TopDown</strong> | <strong class="bold">Blueprints</strong>.</li>
<li>Open the <strong class="bold">Details</strong> panel by clicking the <strong class="bold">Class </strong><strong class="bold">Defaults</strong> tab.</li>
<li>Find the <strong class="bold">Replication</strong> category and notice that the <strong class="bold">Replicates</strong> attribute has been selected. Additionally, notice that <strong class="bold">Replicate Movement</strong> is selected, as depicted in <em class="italic">Figure 3</em><em class="italic">.10</em>:</li>
</ol>
<div><div><img alt="Figure 3.10 – The Replication category" src="img/Figure_03_10_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – The Replication category</p>
<p>One of the best <a id="_idIndexMarker159"/>parts of activating the <strong class="bold">Replicates</strong> attribute is that properties will be updated automatically over the network: you won’t need to do anything else. Later, you will learn how to execute functions by calling them over the network.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Adding additional character spawn points</h2>
<p>As you may <a id="_idIndexMarker160"/>have noticed, the three players have been spawned next to each other: this is because we have a single Player Start Actor in the level.</p>
<p>To fix things up, you will be adding some more spawn points:</p>
<ol>
<li>Add several <strong class="bold">Player Start</strong> objects, up to the number of players you want to test – you can do this by clicking the <strong class="bold">Quickly Add To The Project</strong> button, then selecting <strong class="bold">Basic</strong> | <strong class="bold">Player Start</strong>.</li>
<li>Place them anywhere on the map that you deem suitable for your game. In <em class="italic">Figure 3</em><em class="italic">.11</em>, you can see my choice for the three spawn points:</li>
</ol>
<div><div><img alt="Figure 3.11 – Adding more spawn points" src="img/Figure_03_11_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Adding more spawn points</p>
<p>If you test your game at this point, you will notice that players are now randomly spawning at the <strong class="bold">Player Start</strong> positions, but sometimes, two or more characters still end up at the same spawn point. This can easily be fixed by checking positions that have already been taken <a id="_idIndexMarker161"/>and excluding them from the selection when a new player joins the session. To do this, follow these steps:</p>
<ol>
<li>Open the <strong class="bold">BP_TopDownGameMode</strong> Blueprint by going to <strong class="bold">Content</strong> | <strong class="bold">Topdown</strong> | <strong class="bold">Blueprints</strong>.</li>
<li>Then, open the Event Graph.</li>
<li>In <strong class="bold">My Blueprints</strong> | <strong class="bold">Functions</strong>, add an override to the <strong class="bold">ChoosePlayerStart</strong> function by clicking the <strong class="bold">Override</strong> option.</li>
<li>Add a <strong class="bold">Get All Actors Of Class</strong> node and connect its incoming execution pin to the execution pin of the <strong class="bold">Choose Player Start</strong> node. Then, set the <strong class="bold">Actor Class</strong> drop-down attribute to <strong class="bold">Player Start</strong>.</li>
<li>Add a <strong class="bold">For Each Loop</strong> node to cycle through all the <strong class="bold">Out Actor</strong> properties you found in the previous node.</li>
<li>Connect the <strong class="bold">Loop Body</strong> execution pin to a <strong class="bold">Branch</strong> node.</li>
<li>Click and drag from the <strong class="bold">Array Element</strong> pin for the loop to get a <strong class="bold">Player Start Tag</strong> node and connect its outgoing pin to a not equal (<strong class="bold">!=</strong>) node. Assign the comparison value of this node to <strong class="bold">Used</strong>. Connect the outcome of this check to the <strong class="bold">Condition</strong> pin of the <strong class="bold">Branch</strong> node.</li>
<li>Connect the <strong class="bold">True</strong> execution pin of the <strong class="bold">Branch</strong> node to a <strong class="bold">Set Player Start </strong><strong class="bold">Tag </strong>node<strong class="bold"> </strong>with a value <a id="_idIndexMarker162"/>equal to <strong class="bold">Used</strong>. The <strong class="bold">Target</strong> pin should be connected to the <strong class="bold">Array Element</strong> area of the loop.</li>
<li>Connect the outgoing execution pin of the <strong class="bold">Set</strong> node to the graph’s <strong class="bold">Return Node</strong>.</li>
<li>The <strong class="bold">Return Value</strong> pin of <strong class="bold">Return Node</strong> should be set to the <strong class="bold">Array Element</strong> property of the loop.</li>
</ol>
<p>The resulting Blueprint is shown in <em class="italic">Figure 3</em><em class="italic">.12</em>:</p>
<div><div><img alt="Figure 3.12 – The Game Mode graph" src="img/Figure_03_12_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – The Game Mode graph</p>
<p>What this graph does is cycle through all of the <strong class="bold">Player Start</strong> objects in the level and look for one that has not been tagged as <strong class="bold">Used</strong> (that is, it has not been taken already). Once a good candidate has been found, it is tagged as <strong class="bold">Used</strong> and its value is returned, ready to be used as a spawn point for the character.</p>
<p>Run the game – each character should now be spawned at unique locations. With that, your players are <a id="_idIndexMarker163"/>now ready to interact with the level!</p>
<p>Play around and test your game: check that everything runs as expected and that players are correctly synchronized over all clients.</p>
<p>In the next section, you will learn how to update attributes across multiple clients by adding some pickups and assigning points to the characters as they get them.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/>Updating properties over the network</h1>
<p>Now, it’s time <a id="_idIndexMarker164"/>to add some gameplay and properly synchronize elements at runtime. In the next few subsections, you’ll work on the following features:</p>
<ul>
<li>Creating the pickup Blueprint</li>
<li>Adding pickup variants</li>
<li>Adding a points counter to the characters</li>
</ul>
<p>Let’s add these features now.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/>Creating the pickup Blueprint</h2>
<p>The first thing <a id="_idIndexMarker165"/>we are going to create is a pickable item that will grant points to the character that picks it up by sending them a message.</p>
<p>To create this type of communication, you’ll need to create an interface:</p>
<ol>
<li>In your <code>Blueprint</code> folder, right-click and select <strong class="bold">Blueprints</strong> | <strong class="bold">Blueprint Interface</strong>.</li>
<li>Name the interface <code>PointsAdder</code>.</li>
<li>Open the <strong class="bold">Blueprint Interface</strong>.</li>
<li>Rename the default function <code>AddPoints</code>.</li>
<li>Add an <code>Value</code> that’s of the <strong class="bold">Integer</strong> type.</li>
</ol>
<p>The interface you have just created should be the same as the one shown in <em class="italic">Figure 3</em><em class="italic">.13</em>:</p>
<div><div><img alt="Figure 3.13 – The PointsAdder interface with the AddPoints declaration" src="img/Figure_03_13_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – The PointsAdder interface with the AddPoints declaration</p>
<p>Once the interface is ready, you’ll <a id="_idIndexMarker166"/>need to create the pickup Blueprint that will use it:</p>
<ol>
<li>In your <code>Blueprints</code> folder, add a Blueprint Class that inherits from <code>BP_BasePickup</code>.</li>
<li>Open the Blueprint. Then, select the <strong class="bold">Class Defaults</strong> tab and add a mesh of your choice to the <strong class="bold">Static </strong><strong class="bold">Mesh</strong> field.</li>
<li>In the <strong class="bold">Physics</strong> section, enable the <strong class="bold">Simulate Physics</strong> attribute and check that the <strong class="bold">Enable Gravity</strong> attribute has been enabled.</li>
<li>Add a <strong class="bold">SphereCollision</strong> component to the Blueprint components hierarchy.</li>
<li>Name the component <code>Trigger</code> and ensure that the <strong class="bold">Generate Overlap Events</strong> attribute has been enabled.</li>
<li>Set the <strong class="bold">Sphere Radius</strong> attribute of the <strong class="bold">SphereCollision</strong> component to a value that is a little bigger than the static meshes you’ll be using (for instance, <strong class="bold">50</strong>).</li>
</ol>
<p>Now, you need to add some code logic to the Blueprint. First, let’s add a points value for the picking character:</p>
<ol>
<li>Open the Event Graph.</li>
<li>Add a variable <a id="_idIndexMarker167"/>of the <code>Points</code>.</li>
<li>Make it <strong class="bold">Instance Editable</strong> by clicking the eye button next to the variable type.</li>
<li>After compiling, set the variable's <strong class="bold">Default Value</strong> to <strong class="bold">1</strong>.</li>
</ol>
<p>The Blueprint Viewport should look the same as what’s shown in <em class="italic">Figure 3</em><em class="italic">.14</em>:</p>
<div><div><img alt="Figure 3.14 – The pickup Viewport" src="img/Figure_03_14_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – The pickup Viewport</p>
<p>Now, it’s time to set the overlap event behavior for the Blueprint:</p>
<ol>
<li>Delete the <strong class="bold">Event BeginPlay</strong> and <strong class="bold">Event Tick</strong> nodes as you won’t be using them.</li>
<li>Add a <strong class="bold">Cast To Character</strong> node and connect its incoming execution pin to the outgoing pin of <strong class="bold">Event ActorBeginOverlap</strong>, to check that the actor is of the required type (that is, a Character).</li>
<li>If the check succeeds, then add an <strong class="bold">AddPoints (Message)</strong> node: this is the function you previously declared in the interface.</li>
<li>Connect the <strong class="bold">As Character</strong> pin of the cast to the <strong class="bold">Target</strong> pin of the function node.</li>
<li>Add a <strong class="bold">Get Points</strong> node <a id="_idIndexMarker168"/>to the graph and connect the pin to the <strong class="bold">Value</strong> pin of the <strong class="bold">Add Points</strong> function node.</li>
<li>Finally, connect the outgoing execution pin of the <strong class="bold">Add Points</strong> node to a <strong class="bold">Destroy Actor</strong> node to remove the pickup once it has been taken.</li>
</ol>
<p>The final graph should be similar to the one shown in <em class="italic">Figure 3</em><em class="italic">.15</em>:</p>
<div><div><img alt="Figure 3.15 – The pickup Event Graph" src="img/Figure_03_15_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – The pickup Event Graph</p>
<p>What this graph does is pretty straightforward: whenever an actor overlaps with the pickup, the pickup will send an <strong class="bold">AddPoints</strong> message through the interface and then destroy itself. If the overlapping actor won’t implement the interface, the message will simply be lost without dispatching any errors.</p>
<p>Now, it’s time to take the most crucial step in the process: enabling replication. To do this, do the following:</p>
<ol>
<li>In the <strong class="bold">Components</strong> tab, select the <strong class="bold">BP_BasePickup (</strong><strong class="bold">self)</strong> element.</li>
<li>Then, in the <strong class="bold">Details</strong> panel, look <a id="_idIndexMarker169"/>for the <strong class="bold">Replication</strong> category and enable the <strong class="bold">Replicates</strong> attribute.</li>
</ol>
<p>Now that you have a base pickup, you can create variants, ready to be used in-game.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor078"/>Adding pickup variants</h2>
<p>Creating a <a id="_idIndexMarker170"/>variant for the pickup Blueprint is quite easy:</p>
<ol>
<li>Right-click on your <strong class="bold">BP_BasePickup</strong> item in the Content Browser.</li>
<li>Select <strong class="bold">Create Child Blueprint Class</strong>, give your new pickup a name, and open it.</li>
<li>Open the <strong class="bold">Class Defaults</strong> tab. Then, assign a mesh to the <strong class="bold">Static Mesh</strong> field (in my case, a fruit Megascan).</li>
<li>Assign a value of your choice to the <strong class="bold">Points</strong> attribute, as shown in <em class="italic">Figure 3</em><em class="italic">.16</em>:</li>
</ol>
<div><div><img alt="Figure 3.16 – The settings for the orange pickup" src="img/Figure_03_16_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – The settings for the orange pickup</p>
<p>Repeat these steps for each of your pickups and you’ll be ready to go!</p>
<p>Before you implement <a id="_idIndexMarker171"/>the <strong class="bold">AddPoints</strong> interface for the Blueprint character, you are free to add some of the brand-new pickups and test the game as a listen server multiplayer game.</p>
<p class="callout-heading">Note</p>
<p class="callout">If your pickups seem to have different rotations through the clients, this means that you probably didn’t enable replication. Please make sure that the <strong class="bold">Replicates</strong> and <strong class="bold">Replicate Movement</strong> fields are checked for your Blueprints!</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/>Adding a points counter to the character</h2>
<p>Now that you know <a id="_idIndexMarker172"/>how to replicate Actors across the network, it is time to learn how to replicate single variables and how to intercept changes at runtime.</p>
<p>You’ll be doing this by keeping track of the points that have been gained by each player by displaying them next to the gaming Actor. Follow these steps:</p>
<ol>
<li>Open <code>Blueprints</code> project folder.</li>
<li>Add a <strong class="bold">Points</strong> variable of the <strong class="bold">Integer</strong> type.</li>
<li>In the <strong class="bold">Details</strong> panel of the <strong class="bold">Points</strong> property, look for the <strong class="bold">Replication</strong> field and, from the drop-down menu, select <strong class="bold">RepNotify</strong>.</li>
</ol>
<p>You will notice that, once the <strong class="bold">RepNotify</strong> field has been selected, a function named <strong class="bold">OnRep_Points</strong> has been added to your Blueprint – this function will be called on the clients every time the variable is updated by the authoritative Actor.</p>
<p class="callout-heading">Note</p>
<p class="callout">The difference between the <strong class="bold">RepNotify</strong> and <strong class="bold">Replicated</strong> values is that in the second case, the variable will be updated over the network without executing any notification function. It should also be noted that the <strong class="bold">OnRep_XXX</strong> function is called from the server on each client, and will not be executed on the server itself.</p>
<p>You are now going to add a text component to the character to display the points they have gained during the match:</p>
<ol>
<li>Add a <code>PointsLabel</code>.</li>
<li>Place the component anywhere you deem appropriate. I opted for these <strong class="bold">Transform</strong> values: <strong class="bold">Location (-120, 0, -80)</strong> and <strong class="bold">Rotation (0, </strong><strong class="bold">90, 180)</strong>.</li>
<li>Enhance the characteristics of the components according to your wishes. I opted for the settings shown in <em class="italic">Figure 3</em><em class="italic">.17</em>:</li>
</ol>
<div><div><img alt="Figure 3.17 – The PointsLabel component" src="img/Figure_03_17_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – The PointsLabel component</p>
<p>It’s finally time <a id="_idIndexMarker173"/>to let pickups communicate with the character. We will do this by implementing the interface we defined some time ago:</p>
<ol>
<li>With <strong class="bold">BP_TopDownCharacter</strong> open, select the <strong class="bold">Class </strong><strong class="bold">Settings</strong> tab.</li>
<li>In the <strong class="bold">Details</strong> panel, click the <strong class="bold">Add</strong> drop-down button on the <strong class="bold">Implemented Interfaces</strong> field and select the <strong class="bold">PointsAdded</strong> interface.</li>
<li>A new function named <strong class="bold">AddPoints</strong> will be added to the <strong class="bold">Interfaces</strong> section of the <strong class="bold">MyBlueprint</strong> tab. Right-click on the function’s name and select <strong class="bold">Implement Event</strong> – this will add the corresponding node to the Event Graph and select it.</li>
<li>Drag the <strong class="bold">Points</strong> variable into the Event Graph and select the <strong class="bold">Set</strong> option.</li>
<li>Drag the <strong class="bold">Points</strong> variable again, this time selecting the <strong class="bold">Get</strong> option.</li>
<li>Add the outgoing <strong class="bold">Value</strong> pin from the event to the <strong class="bold">Get Points</strong> node by using an <strong class="bold">Add</strong> (<strong class="bold">+</strong>) node.</li>
<li>Connect the execution pin of the <strong class="bold">Event</strong> node to the <strong class="bold">Set</strong> node.</li>
<li>Connect the result pin of the <strong class="bold">Add</strong> node to the <strong class="bold">Points</strong> pin of the set node.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You will notice that both the <strong class="bold">Set</strong> and <strong class="bold">Get</strong> nodes you added to your graph now have an icon in the top-right corner. In addition, the <strong class="bold">Set</strong> node is decorated with text stating <strong class="bold">w/Notify</strong>: this means that the <strong class="bold">Points</strong> variable is replicated with a function notification.</p>
<p><em class="italic">Figure 3</em><em class="italic">.18</em> shows the <a id="_idIndexMarker174"/>final graph for the <strong class="bold">AddPoints</strong> event:</p>
<div><div><img alt="Figure 3.18 – The AddPoints event" src="img/Figure_03_18_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – The AddPoints event</p>
<p>The last thing we need to do is implement the notification function so that we can update the points that are displayed to the character:</p>
<ol>
<li>Double-click on the <strong class="bold">OnRep_Points</strong> function to open it.</li>
<li>Drag a <strong class="bold">Get</strong> node from the <strong class="bold">PointsLabel</strong> component in the Event Graph.</li>
<li>From its outgoing pin, add a <strong class="bold">Set Text</strong> node, and connect its incoming execution pin to the outgoing execution pin of the <strong class="bold">On Rep </strong><strong class="bold">Points</strong> node.</li>
<li>Drag a <strong class="bold">Get</strong> node from the <strong class="bold">Points</strong> variable in the Event Graph and connect its pin to the <strong class="bold">Value</strong> pin of the <strong class="bold">Set Text</strong> node. Unreal will automatically add a <strong class="bold">To Text</strong> conversion node.</li>
</ol>
<p>The final graph <a id="_idIndexMarker175"/>should be pretty similar to the one depicted in <em class="italic">Figure 3</em><em class="italic">.19</em>:</p>
<div><div><img alt="Figure 3.19 – The On Rep Points graph" src="img/Figure_03_19_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19 – The On Rep Points graph</p>
<p>Now, if you test the game, you should be able to see all the clients update whenever a player gets a pickup in the level.</p>
<p>With that, you’ve learned about how objects are updated during a multiplayer session. Specifically, you gained insight into how Actors are replicated and how to detect changes in variables through replication notifications. In the next section, you will work on enhancing your prototype by adding a spawn area for your pickups and making some aesthetic improvements to your characters so that they can easily be identified. You will achieve this by calling functions over the network.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor080"/>Executing functions over the network</h1>
<p>In this section, you will learn how to properly call functions over the network and what the word “authority” really <a id="_idIndexMarker176"/>means for the UE multiplayer system. In particular, you will get some insight into which entity should execute a function when it has been called: a client or the server.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor081"/>Spawning Actors</h2>
<p>It is time to start <a id="_idIndexMarker177"/>adding pickups at runtime. You <a id="_idIndexMarker178"/>are going to achieve this by adding a spawn area Blueprint to the level.</p>
<p>This Blueprint should be able to do the following:</p>
<ul>
<li>Choose a random position every time it spawns something</li>
<li>Spawn random pickups at predefined intervals</li>
<li>And obviously... behave correctly over the network!</li>
</ul>
<p>Let’s get started.</p>
<h3>Choosing a random spawn position</h3>
<p>Let’s start <a id="_idIndexMarker179"/>by creating the Blueprint and setting its parameters:</p>
<ol>
<li> Create a new Actor Blueprint and call it <code>BP_Spawner</code>.</li>
<li>Add a <code>SpawnArea</code>, and make it the <strong class="bold">Scene Root</strong> component by dragging it onto the default one.</li>
<li>Add an <code>SpawnableObjects</code>, making it <strong class="bold">Instance Editable</strong>.</li>
</ol>
<p>Once you have compiled and saved the Blueprint, open its Event Graph. Then, do the following:</p>
<ol>
<li>Create a function named <code>Spawn</code> and open it.</li>
<li>Connect the execution node of the function to a <strong class="bold">SpawnActor from </strong><strong class="bold">Class</strong> node.</li>
<li>Add a <strong class="bold">Get</strong> node for the <strong class="bold">SpawnableObjects</strong> variable and connect its outgoing pin to a <strong class="bold">Random Array </strong><strong class="bold">Item</strong> node.</li>
<li>Connect the outgoing <strong class="bold">Actor Class Reference</strong> pin of <strong class="bold">Random Node</strong> to the <strong class="bold">Class</strong> pin of the <strong class="bold">Spawn</strong> node.</li>
</ol>
<p>To get a position for the spawned item, we will get a random location inside the <strong class="bold">Box </strong><strong class="bold">Collision</strong> component:</p>
<ol>
<li>Right-click on the <strong class="bold">Spawn Transform</strong> pin of the <strong class="bold">SpawnActor</strong> node and select <strong class="bold">Split </strong><strong class="bold">Struct Pin</strong>.</li>
<li>Drag the <strong class="bold">SpawnArea</strong> component into the function graph and connect its pin to a <strong class="bold">Get Scaled Box </strong><strong class="bold">Extent</strong> node.</li>
<li>Add a <strong class="bold">Get Actor Location</strong> node and connect its outgoing pin to a <strong class="bold">Random Point in Bounding </strong><strong class="bold">Box</strong> node.</li>
<li>Connect the <a id="_idIndexMarker180"/>outgoing pin of the <strong class="bold">Get Scaled Box Extent</strong> node to the <strong class="bold">Half Size</strong> pin of the <strong class="bold">Random Point in Bounding </strong><strong class="bold">Box</strong> one.</li>
<li>Connect the <strong class="bold">Return Value</strong> pin of the <strong class="bold">Random Point in Bounding Box</strong> node to the <strong class="bold">Spawn Transform Location</strong> pin of the <strong class="bold">SpawnActor</strong> one.</li>
</ol>
<p>The final graph can be seen in <em class="italic">Figure 3</em><em class="italic">.20</em>:</p>
<div><div><img alt="Figure 3.20 – The Spawn function graph" src="img/Figure_03_20_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.20 – The Spawn function graph</p>
<p>The <strong class="bold">Spawn</strong> function <a id="_idIndexMarker181"/>selects a random Blueprint Class from a given list of elements and generates an instance of it at a random position within a defined area.</p>
<h3>Spawning random pickups at predefined intervals</h3>
<p>You are now <a id="_idIndexMarker182"/>going to add a timer to spawn pickups at predefined intervals:</p>
<ol>
<li>Open the Event Graph section of the Blueprint and delete the <strong class="bold">Actor BeginOverlap</strong> and <strong class="bold">Tick</strong> events.</li>
<li>Add a <strong class="bold">Set Timer by Event</strong> node and connect its incoming execution pin to the outgoing one of the <strong class="bold">BeginPlay</strong> event.</li>
<li>Set the <strong class="bold">Time</strong> value equal to <strong class="bold">1</strong> and check the box in <strong class="bold">Looping</strong>.</li>
<li>Connect the <code>OnTimer</code>.</li>
<li>Connect the execution pin of the custom event to the <strong class="bold">Spawn</strong> function.</li>
</ol>
<p>What you have just done may seem pretty straightforward and correct, but it is actually wrong... or, at least, it’s missing something: the code will behave differently on each client. Bear with me for a minute while we test this wrong behavior:</p>
<ol>
<li>Delete all the pickups you may have previously added to your game level.</li>
<li>Add an instance of <strong class="bold">BP_Spawner</strong> to the level.</li>
<li>Place the instance approximately at the center of the scene and change the <strong class="bold">Box Extent</strong> values of the <strong class="bold">SpawnArea</strong> component so that the box will cover the entire play area; if you are using the default scene, something such as <strong class="bold">(1300, 1600, 32)</strong> should be fine.</li>
<li>Place the <strong class="bold">SpawnArea</strong> component above the ground – pickups should be dropped from above and fall to the ground.</li>
<li>Add all the pickups you have created to the <strong class="bold">Spawnable </strong><strong class="bold">Objects</strong> array.</li>
<li>Run the multiplayer simulation.</li>
</ol>
<p>You will notice that things will seem totally out of sync between clients: in particular, the UE instance (that is, the server) will spawn a single pickup at each interval, while the additional client will be spawning two.</p>
<p>What did we do <a id="_idIndexMarker183"/>wrong? Put simply, at the moment, every spawner in every client is spawning items, but only the server (the one who has the authority) is spawning items across the network. This means that the server will get only one pickup at a time, but the clients will get two: one spawned by the server, and one created by themselves for which the server has no knowledge at all.</p>
<h3>Using Actor authority to correctly spawn pickups</h3>
<p>To fix the spawning <a id="_idIndexMarker184"/>issue, we just have to tell the spawner to generate pickups only if they have the authority to do so (that is, that it is the server):</p>
<ol>
<li>Add a <strong class="bold">Switch Has Authority</strong> node in between the execution pin of the <strong class="bold">BeginPlay</strong> event and <strong class="bold">Set Timer </strong><strong class="bold">by Event</strong>.</li>
<li>Connect the <strong class="bold">Authority</strong> execution pin to the incoming pin of the <strong class="bold">Timer</strong> node.</li>
</ol>
<p> The corrected graph is shown in <em class="italic">Figure 3</em><em class="italic">.21</em>:</p>
<div><div><img alt="Figure 3.21 – The spawn timer graph" src="img/Figure_03_21_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21 – The spawn timer graph</p>
<p>When you test the game now, it should behave correctly: the same object should be spawned at the same time in each client instance.</p>
<p>The prototype is <a id="_idIndexMarker185"/>almost finished, but I want you to create one last networked feature: a personalized skin for your characters.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor082"/>Skinning characters</h2>
<p>Playing the game with two or more identical characters may soon become very confusing. The best option for a prototype is to quickly create some colorized materials and assign them <a id="_idIndexMarker186"/>to the characters as soon as they are spawned. We will do this in a networked environment.</p>
<p>Let’s start by creating some material instances:</p>
<ol>
<li>In the Content Browser, navigate to <strong class="bold">Content</strong> | <strong class="bold">Characters</strong> | <strong class="bold">Mannequins</strong> | <strong class="bold">Materials</strong> | <strong class="bold">Instances</strong> | <strong class="bold">Manny</strong>.</li>
<li>Duplicate <strong class="bold">MI_Manny_01</strong> several times to equal the number of connections you set in the <strong class="bold">Play as a Listen Server</strong> section (that is, <strong class="bold">3</strong>).</li>
<li>Name the new materials with your own preferred conventions; I used <code>MI_Manny_01_[ColorName]</code>.</li>
<li>Open each new instance and change the <strong class="bold">Tint</strong> property to a color that you like.</li>
<li>Save all the material instances and close them.</li>
</ol>
<p>Now, let’s open the character Blueprint and add another replicated variable:</p>
<ol>
<li>Open <strong class="bold">BP_TopDownCharacter</strong>.</li>
<li>Add a new variable called <strong class="bold">SkinMaterial</strong> of the <strong class="bold">Material Interface Object Reference</strong> type and make it <strong class="bold">Instance Editable</strong>.</li>
<li>Set the drop-down menu for the <strong class="bold">Replication</strong> field to <strong class="bold">RepNotify</strong>. This will create a function called <strong class="bold">OnRep_SkinMaterial</strong>.</li>
</ol>
<p>Next, open the <strong class="bold">OnRep_SkinMaterial</strong> function to add the skin change logic. Then, do the following:</p>
<ol>
<li>Drag a reference for <strong class="bold">Mesh</strong> from the <strong class="bold">Components</strong> panel in the Event Graph.</li>
<li>Drag a <strong class="bold">Get</strong> node <a id="_idIndexMarker187"/>for the <strong class="bold">SkinMaterial</strong> variable.</li>
<li>Connect the function execution pin to a <strong class="bold">Set </strong><strong class="bold">Material</strong> node.</li>
<li>Connect the <strong class="bold">Mesh</strong> reference to the <strong class="bold">Target</strong> pin.</li>
<li>Connect the <strong class="bold">SkinMaterial</strong> reference to the <strong class="bold">Material</strong> pin.</li>
</ol>
<p>The graph for this function is shown in <em class="italic">Figure 3</em><em class="italic">.22</em>:</p>
<div><div><img alt="Figure 3.22 – The function for the replicated SkinMaterial variable" src="img/Figure_03_22_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.22 – The function for the replicated SkinMaterial variable</p>
<ol>
<li>Whenever the <strong class="bold">SkinMaterial</strong> variable is changed, <strong class="bold">OnRep_SkinMaterial</strong> will take care of assigning it to the first material of the character.</li>
</ol>
<p>Now, you need to change the material for each character once it has been added to the level:</p>
<ol>
<li>In the <code>Blueprints</code> folder, open <strong class="bold">BP_TopDownGameMode</strong>.</li>
<li>Add an <code>SkinMaterials</code>.</li>
<li>Once you have compiled the Blueprint, add all the materials you previously created to the <strong class="bold">Default Value</strong> field in the <strong class="bold">Details</strong> panel.</li>
<li>Add a variable of the <code>SkinCount</code>; this variable will be used as an index counter for selecting the skins.</li>
</ol>
<p>You may have noticed that we are not replicating the <strong class="bold">SkinCount</strong> variable; in this case, we don’t need to do <a id="_idIndexMarker188"/>this as this variable only exists in the server and it is used to handle the skin of the character as soon as they are spawned in the game. Knowing what variables to replicate and when is a topic I’ll cover in <em class="italic">Chapter 6</em>, <em class="italic">Replicating Properties </em><em class="italic">O</em><em class="italic">ver </em><em class="italic">the Network</em>.</p>
<p>Next, you must get a count of the used skins. Then, every time a new connection is created, you will assign the next available skin to the character. To achieve this, you’ll be using an event named <em class="italic">OnRestartPlayer</em> that is executed every time a player is restarted (including when it is spawned for the first time):</p>
<ol>
<li>In the Event Graph, add an <strong class="bold">Event </strong><strong class="bold">OnRestartPlayer</strong> node.</li>
<li>From <strong class="bold">New Player</strong>, connect a <strong class="bold">Get Controlled </strong><strong class="bold">Pawn</strong> node.</li>
<li>Cast its outgoing pin to a <strong class="bold">BP_TopDownCharacter </strong>node.</li>
<li>Connect the event execution pin to the <strong class="bold">Cast</strong> node.</li>
<li>Connect the outgoing <strong class="bold">As BP Top Down Character</strong> to a <strong class="bold">Set Skin Material</strong> node (note the <strong class="bold">w/Notify</strong> label that was added to indicate the notification call when the value is changed).</li>
<li>Connect the successful execution pin of the cast node to the <strong class="bold">Set Skin </strong><strong class="bold">Material</strong> node.</li>
<li>Add a <strong class="bold">Get</strong> node for the <strong class="bold">SkinMaterials</strong> array and a <strong class="bold">Get</strong> node for the <strong class="bold">SkinCount</strong> variable.</li>
<li>Connect the outgoing <strong class="bold">Skin Materials</strong> pin to the <strong class="bold">Get (a </strong><strong class="bold">copy)</strong> node.</li>
<li>Connect the <strong class="bold">Skin Count</strong> pin to the <strong class="bold">Get</strong> index.</li>
<li>Connect the outgoing pin of the <strong class="bold">Get</strong> node to the <strong class="bold">Skin Material</strong> pin of the <strong class="bold">Set Skin </strong><strong class="bold">Material</strong> node.</li>
<li>Finally, connect the <a id="_idIndexMarker189"/>outgoing execution pin of <strong class="bold">Set Skin Material</strong> to an <strong class="bold">Increment (++)</strong> node. The <strong class="bold">Skin Count x</strong> variable should be incremented; this will keep track of the selected skin in the array.</li>
</ol>
<p><em class="italic">Figure 3</em><em class="italic">.23</em> depicts the Game Mode graph:</p>
<div><div><img alt="Figure 3.23 – The Game Mode graph" src="img/Figure_03_23_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.23 – The Game Mode graph</p>
<p>Now that the prototype <a id="_idIndexMarker190"/>has been created, it’s time to test (and play) it!</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor083"/>Testing the game</h2>
<p>Run the game as a listen server – each character should have its colorized skin synchronized <a id="_idIndexMarker191"/>across the network and the points gained for each player should be correctly displayed on the character itself. <em class="italic">Figure 3</em><em class="italic">.24</em> shows the game prototype in action:</p>
<div><div><img alt="Figure 3.24 – Testing the game prototype" src="img/Figure_03.24_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.24 – Testing the game prototype</p>
<p>So, you’ve finally tested your multiplayer game prototype: players can run around and get the falling <a id="_idIndexMarker192"/>pickups, ready to gain points. As funny as it seems, this is just the beginning of multiplayer game development!</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/>Summary</h1>
<p>In this chapter, you created a prototype of your first multiplayer game and gained knowledge about synchronizing Actors and variables across the network. Moreover, you started testing the prototype through the UE system, which emulates multiple connections concurrently, and achieved all this through the use of Blueprints.</p>
<p>However, moving forward, you will transition to using the C++ programming language, which may seem a little daunting, but I assure you that I will strive to make this shift as effortless as possible!</p>
<p>It’s time to leave your prototype to its destiny... we have more important things to do! In the next chapter, you’ll start creating a game from scratch. You will develop it in C++ with all the advantages that come with this kind of development.</p>
</div>


<div><h1 id="_idParaDest-84" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor085"/>Part 2:Networking and Multiplayer Games in Unreal Engine</h1>
<p>In the second part of this book, you will lay the foundation for a complete multiplayer project using Unreal Engine. From there, you will delve into the essential features of the Unreal Engine Gameplay Framework, as well as how they are implemented within a multiplayer context.</p>
<p>This part includes the following chapters:</p>
<ul>
<li><a href="B18203_04.xhtml#_idTextAnchor086"><em class="italic">Chapter 4</em></a>, <em class="italic">Setting Up Your First Multiplayer Environment</em></li>
<li><a href="B18203_05.xhtml#_idTextAnchor107"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing Actors in a Multiplayer Environment</em></li>
<li><a href="B18203_06.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Replicating Properties </em><em class="italic">O</em><em class="italic">ver the Network</em></li>
<li><a href="B18203_07.xhtml#_idTextAnchor147"><em class="italic">Chapter 7</em></a>, <em class="italic">Using Remote Procedure Calls (RPCs)</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>