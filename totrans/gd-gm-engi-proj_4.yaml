- en: Space Rocks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 太空岩石
- en: By now, you should be getting more comfortable with working in Godot; adding
    nodes, creating scripts, modifying properties in the Inspector, and so on. As
    you progress through this book, you won't be forced to rehash the basics again
    and again. If you find yourself stuck, or feeling like you don't quite remember
    how something is done, feel free to jump back to a previous project where it was
    explained in more detail. As you repeat the more common actions in Godot, they
    will start to feel more and more familiar. At the same time, each chapter will
    introduce you to more nodes and techniques to expand your understanding of Godot's
    features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该已经对在Godot中工作感到更加得心应手；添加节点、创建脚本、在检查器中修改属性等等。随着您通过这本书的进展，您将不会被迫一次又一次地重复基础知识。如果您发现自己遇到了困难，或者感觉不太记得如何做某事，请随时回到之前的项目中，那里有更详细的解释。随着您在Godot中重复更常见的操作，它们将开始变得越来越熟悉。同时，每一章都将向您介绍更多节点和技术，以扩展您对Godot功能的理解。
- en: 'In this next project, you''ll make a space shooter game similar to the arcade
    classic Asteroids. The player will control a ship that can rotate and move in
    any direction. The goal will be to avoid the floating *space rocks* and shoot
    them with the ship''s laser. Refer to the following screenshot:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，您将制作一个类似于街机经典游戏《小行星》的空间射击游戏。玩家将控制一艘可以旋转和向任何方向移动的飞船。目标将是避开漂浮的*太空岩石*并用飞船的激光射击它们。请参考以下截图：
- en: '![](img/00077.jpeg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00077.jpeg)'
- en: 'You will learn about the following key topics in this project:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您将学习以下关键主题：
- en: Physics using `RigidBody2D`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RigidBody2D`进行物理运算
- en: Finite State Machines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限状态机
- en: Building a dynamic, scalable UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建动态、可扩展的用户界面
- en: Sound and music
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音和音乐
- en: Particle effects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子效果
- en: Project setup
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: Create a new project and download the project assets from [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并从[https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases)下载项目资源。
- en: For this project, you'll set up custom input actions using the Input Map. Using
    this feature, you can define custom events and assign different keys, mouse events,
    or other inputs to them. This allows for more flexibility in designing your game,
    as your code can be written to respond to the `jump` input, for example, without
    needing to know exactly what input the user pressed to make the event happen.
    This allows you to make the same code work on different devices, even if they
    have different hardware. In addition, since many gamers expect to be able to customize
    a game's inputs, this enables you to provide that option to the user as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，您将使用输入映射来设置自定义输入操作。使用此功能，您可以定义自定义事件并将不同的键、鼠标事件或其他输入分配给它们。这使您在游戏设计上具有更大的灵活性，因为您的代码可以编写为响应例如`jump`输入，而无需确切知道用户按下了什么输入来触发事件。这允许您使相同的代码在不同的设备上工作，即使它们具有不同的硬件。此外，由于许多玩家期望能够自定义游戏的输入，这也使您能够为用户提供此选项。
- en: To set up the inputs for this game, open Project | Project Settings and select
    the Input Map tab.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置游戏的输入，请打开项目 | 项目设置并选择输入映射选项卡。
- en: 'You''ll need to create four new input actions: `rotate_left`, `rotate_right`,
    `thrust`, and `shoot`. Type the name of each action into the Action box and click
    Add. Then, for each action, click the + button and select the type of input to
    assign. For example, to allow the player to use both the arrow keys and the popular
    WASD alternative, the setup will look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建四个新的输入操作：`rotate_left`、`rotate_right`、`thrust`和`shoot`。将每个操作的名称输入到动作框中并点击添加。然后，对于每个操作，点击+按钮并选择要分配的输入类型。例如，为了允许玩家使用箭头键和流行的WASD替代方案，设置将如下所示：
- en: '![](img/00078.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00078.jpeg)'
- en: 'If you have a gamepad or other controller connected to your computer, you can
    also add its inputs to the actions in the same way. Note: we''re only considering
    button-style inputs at this stage, so while you''ll be able to use a d-pad for
    this project, using an analog joystick would require changes to the project''s
    code.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机连接了游戏手柄或其他控制器，您也可以以相同的方式将其输入添加到操作中。注意：我们目前只考虑按钮式输入，因此虽然您可以使用这个项目中的十字键，但使用模拟摇杆将需要修改项目的代码。
- en: Rigid body physics
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚体物理
- en: In game development, you often need to know when two objects in the game space
    intersect or come into contact. This is known as *collision detection*. When a
    collision is detected, you typically want something to happen. This is known as *collision
    response*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，你经常需要知道游戏空间中的两个物体何时相交或接触。这被称为*碰撞检测*。当检测到碰撞时，你通常希望发生某些事情。这被称为*碰撞响应*。
- en: 'Godot offers three kinds of physics bodies, grouped under the `PhysicsBody2D`
    object type:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Godot提供了三种类型的物理刚体，这些刚体被归类在`PhysicsBody2D`对象类型下：
- en: '`StaticBody2D`: A static body is one that is not moved by the physics engine.
    It participates in collision detection, but does not move in response to the collision.
    This type of body is most often used for objects that are part of the environment
    or do not need to have any dynamic behavior, such as walls or the ground.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StaticBody2D`：静态刚体是指不会被物理引擎移动的刚体。它参与碰撞检测，但不会对碰撞做出移动。这种类型的刚体通常用于环境中的物体或不需要任何动态行为的物体，例如墙壁或地面。'
- en: '`RigidBody2D`: This is the physics body in Godot that provides simulated physics.
    This means that you don''t control a `RigidBody2D` directly. Instead, you apply
    forces to it (gravity, impulses, and so on) and Godot''s built-in physics engine
    calculates the resultant movement, including collisions, bouncing, rotating, and
    other effects.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RigidBody2D`：这是Godot中提供模拟物理的物理刚体。这意味着你不会直接控制`RigidBody2D`。相反，你对其施加力（重力、冲量等），然后Godot的内置物理引擎计算结果运动，包括碰撞、弹跳、旋转和其他效果。'
- en: '`KinematicBody2D`: This body type provides collision detection, but no physics.
    All movement must be implemented in code, and you must implement any collision
    response yourself. Kinematic bodies are most often used for player characters
    or other actors that require *arcade-style* physics rather than realistic simulation.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KinematicBody2D`：这种身体类型提供碰撞检测，但没有物理效果。所有运动都必须通过代码实现，并且你必须自己实现任何碰撞响应。运动刚体通常用于玩家角色或其他需要*街机风格*物理而不是真实模拟的演员。'
- en: Understanding when to use a particular physics body type is a big part of building
    your game. Using the right node can simplify your development, while trying to
    force the wrong node to do the job can lead to frustration and poor results. As
    you work with each type of body, you'll come to learn their pros and cons and
    get a feel for when they can help build what you need.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 了解何时使用特定的物理刚体类型是构建游戏的重要组成部分。使用正确的节点可以简化你的开发，而试图强制错误的节点完成工作可能会导致挫败感和不良结果。随着你与每种类型的刚体一起工作，你会了解它们的优缺点，并学会何时它们可以帮助构建你需要的东西。
- en: In this project, you'll be using the `RigidBody2D` node for the player ship
    as well as the *space rocks* themselves. You'll learn about the other body types
    in later chapters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用`RigidBody2D`节点来控制玩家飞船以及*太空岩石*本身。你将在后面的章节中了解其他刚体类型。
- en: 'Individual `RigidBody2D` nodes have many properties you can use to customize
    their behavior, such as `Mass`, `Friction`, or `Bounce`. These properties can
    be set in the Inspector:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单个`RigidBody2D`节点有许多你可以用来自定义其行为的属性，例如`质量`、`摩擦`或`弹跳`。这些属性可以在检查器中设置：
- en: '![](img/00079.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00079.jpeg)'
- en: 'Rigid bodies are also affected by the world''s properties, which can be set
    in the Project Settings under Physics | 2D. These settings apply to all bodies
    in the world. Refer to the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 刚体也受到世界属性的影响，这些属性可以在项目设置下的物理 | 2D 中设置。这些设置适用于世界中的所有刚体。请参考以下截图：
- en: '![](img/00080.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00080.jpeg)'
- en: In most cases, you won't need to modify these settings. However, note that by
    default, gravity has a value of `98` and a direction of `(0, 1)` (downward). If
    you want to change the world gravity, you can do that here. You should also be
    aware of the last two properties, Default Linear Damp and Default Angular Damp.
    These properties control how quickly a body will lose forward speed and rotation
    speed, respectively. Setting them to lower values will make the world feel frictionless,
    while using larger values will feel like your objects are moving through mud.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不需要修改这些设置。但是，请注意，默认情况下，重力值为`98`，方向为`(0, 1)`（向下）。如果你想更改世界重力，你可以在这里进行更改。你还应该注意最后两个属性，默认线性阻尼和默认角阻尼。这些属性控制刚体将如何快速失去前进速度和旋转速度。将它们设置为较低的值会使世界感觉没有摩擦，而使用较大的值会使你的物体感觉像是在泥中移动。
- en: '`Area2D` nodes can also be used to affect rigid body physics by using the Space
    Override property. Custom gravity and damping values will then be applied to any
    bodies that enter the area.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Since this game will be taking place in outer space, gravity won't be needed,
    so set Default Gravity to `0`. You can leave the other settings as they are.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Player ship
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player ship is the heart of the game. Most of the code you'll write for
    this project will be about making the ship work. It will be controlled in the
    classic Asteroids style, with left/right rotation and forward thrust. It will
    also detect the shoot input to allow the player to fire the laser and destroy
    the floating rocks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Body setup and physics
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new scene and add a `RigidBody2D` named `Player` as the root node,
    with `Sprite` and `CollisionShape2D` children. Add the `res://assets/player_ship.png`
    image to the Texture property of the `Sprite`. The ship image is quite large,
    so set the Scale property of the `Sprite` to `(0.5, 0.5)`and its Rotation to `90`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The image for the ship is drawn pointing upwards. In Godot, a rotation of `0`
    degrees points to the right (along the *x* axis). This means you need to set the
    Rotation of the `Sprite` node to `90` so it will match the body's direction.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Shape property of `CollisionShape2D`, add a `CircleShape2D` and scale
    it to cover the image as closely as possible (remember not to move the rectangular
    size handles):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Save the scene. When working on larger-scale projects, it is recommended to
    organize your scenes and scripts into folders based on each game object. For example,
    if you make a `player` folder, you can save player-related files there. This makes
    it easier to find and modify your files rather than having them all together in
    a single folder. While this project is relatively small, it's a good habit to
    adopt as your projects grow in size and complexity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: State machines
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player ship can be in a number of different states during gameplay. For
    example, when *alive,* the ship is visible and can be controlled by the player,
    but is vulnerable to being hit by rocks. On the other hand, when *invulnerable, *the
    ship should appear semi-transparent and immune to damage.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: One way that programmers often handle situations like this is to add Boolean
    flag variables to the code. For example, the `invulnerable` flag is set to `true` when
    the player spawns, or when the `alive` flag is set to `false` when the player
    is dead. However, this can lead to errors and strange situations where both the
    `alive` and `invulnerable` flags are set to `true` at the same time. What happens
    when a rock hits the player in this situation? The two states are mutually exclusive,
    so this shouldn't be allowed to happen.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: One solution to this problem is to use a **Finite State Machine** (**FSM**).
    When using an FSM, an entity can only be in one state at a given time. To design
    your FSM, you define some number of states and what events or actions can cause
    a transition from one state to another.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用**有限状态机**（**FSM**）。当使用FSM时，实体在给定时间只能处于一个状态。为了设计你的FSM，你需要定义一些状态以及什么事件或动作可以导致从一个状态转换到另一个状态。
- en: 'The following diagram outlines the FSM for the player ship:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图概述了玩家飞船的FSM：
- en: '![](img/00082.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00082.jpeg)'
- en: There are four states, and the arrows indicate what transitions are allowed,
    as well as what event triggers the transition. By checking the current state,
    you can decide what the player is allowed to do. For example, in the **DEAD**
    state, don't allow input, or in the **INVULNERABLE** state, don't allow shooting.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个状态，箭头表示允许的转换以及触发转换的事件。通过检查当前状态，你可以决定玩家被允许做什么。例如，在**DEAD**状态，不允许输入，或者在**INVULNERABLE**状态，不允许射击。
- en: Advanced FSM implementations can become quite complex, and the details are beyond
    the scope of this book (see the Appendix for further reading). In the purest sense,
    you technically won't be creating a true FSM, but for the purposes of this project,
    it will be sufficient to illustrate the concept and keep you from running into
    the Boolean flag problem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 高级FSM实现可能相当复杂，细节超出了本书的范围（参见附录以获取进一步阅读）。在最纯粹的意义上，技术上你不会创建一个真正的FSM，但为了这个项目的目的，它将足以说明这个概念并避免布尔标志问题。
- en: 'Add a script to the `Player` node and start by creating the skeleton of the
    FSM implementation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本添加到`Player`节点，并开始创建FSM实现的骨架：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An `enum` (short for enumeration) is a convenient way to create a set of constants.
    The `enum` statement in the preceding code snippet is equivalent to the following
    code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`（枚举的缩写）是创建一组常量的便捷方式。前面代码片段中的`enum`语句等同于以下代码：'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also assign a name to an `enum`, which is useful when you have more
    than one collection of constants in a single script. For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以给一个`enum`赋予一个名称，这在单个脚本中有多个常量集合时很有用。例如：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, this isn't needed in this script, as you'll only be using the one `enum`
    to track the ship's states.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个脚本中不需要这个，因为您只会使用一个`enum`来跟踪飞船的状态。
- en: 'Next, create the `change_state` function to handle state transitions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`change_state`函数来处理状态转换：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Whenever you need to change the state of the player, you'll call the `change_state()` function
    and pass it the value of the new state. Then, by using a `match` statement, you
    can execute whatever code should accompany the transition to the new state. To
    illustrate this, the `CollisionShape2D` is being enabled/disabled by the `new_state`
    value. In `_ready()`, you specify the initial state—currently `ALIVE` so that
    you can test, but you'll change it to `INIT` later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你需要更改玩家的状态时，你将调用`change_state()`函数并传递新状态的值。然后，通过使用`match`语句，你可以执行伴随状态转换到新状态的任何代码。为了说明这一点，`CollisionShape2D`是通过`new_state`值启用/禁用的。在`_ready()`中，你指定初始状态——目前是`ALIVE`以便测试，但稍后你会将其更改为`INIT`。
- en: Controls
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: 'Add the following variables to the script:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下变量添加到脚本中：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`engine_power` and `spin_power` control how fast the ship can accelerate and
    turn. In the Inspector, set them to `500` and `15000`, respectively. `thrust` will
    represent the force being applied by the ship''s engine: either `(0, 0)` when
    coasting, or a vector with the length of `engine_power` when powered on. `rotation_dir`
    will represent what direction the ship is turning in and apply a torque, or rotational
    force.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`engine_power`和`spin_power`控制飞船加速和转向的速度。在检查器中，将它们分别设置为`500`和`15000`。`thrust`将代表飞船引擎施加的力：当滑行时为`(0,
    0)`，当开启动力时为一个长度为`engine_power`的向量。`rotation_dir`将代表飞船转向的方向并施加扭矩，即旋转力。'
- en: By default, the physics settings provide some *damping*, which reduces a body's
    velocity and spin. In space, there's no friction, so for realism there shouldn't
    be any damping at all. However, for an arcade-style feel, it's preferable that
    the ship should stop when you let go of the keys. In the Inspector, set the player's
    Linear/Damp to `1` and its Angular/Damp to `5`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，物理设置提供了一些*阻尼*，这会减少物体的速度和旋转。在太空中，没有摩擦，所以为了真实感，不应该有任何阻尼。然而，为了达到街机风格的体验，当您松开按键时，飞船应该停止。在检查器中，将玩家的线性/阻尼设置为`1`，其角/阻尼设置为`5`。
- en: 'The next step is to detect the input and move the ship:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检测输入并移动船只：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `get_input()` function captures the key actions and sets the ship's thrust
    on or off, and the rotation direction (`rotation_dir`) to a positive or negative
    value (representing clockwise or counter-clockwise rotation). This function is
    called every frame in `_process()`. Note that if the state is `INIT` or `DEAD`,
    `get_input()` will exit by using `return` before checking for key actions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_input()`函数捕获关键操作并设置飞船的推力开启或关闭，以及旋转方向（`rotation_dir`）为正或负值（表示顺时针或逆时针旋转）。此函数在`_process()`中每帧都会被调用。注意，如果状态是`INIT`或`DEAD`，`get_input()`将在检查按键操作之前使用`return`退出。'
- en: When using physics bodies, their movement and related functions should be called
    in `_physics_process()`. Here, you can use `set_applied_force()` to apply the
    engine thrust in whatever direction the ship is facing. Then, you can use `set_applied_torque()`
    to cause the ship to rotate.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用物理体时，它们的移动和相关函数应在`_physics_process()`中调用。在这里，你可以使用`set_applied_force()`将引擎推力应用到飞船面向的任何方向。然后，你可以使用`set_applied_torque()`使飞船旋转。
- en: Play the scene and you should be able to fly around freely.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 播放场景后，你应该能够自由飞行。
- en: Screen wrap
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕卷曲
- en: 'Another feature of classic 2D arcade games is *screen wrap*. If the player
    goes off one side of the screen, they *appear* on the other side. In practice,
    you teleport or instantaneously change the ship''s position to the opposite side.
    Add the following to the class variables at the top of the script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 经典2D街机游戏的一个特点是*屏幕卷曲*。如果玩家离开屏幕的一侧，他们*就会出现在另一侧*。在实践中，你将传送或瞬间改变飞船的位置到另一侧。将以下内容添加到脚本顶部的类变量中：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And add this to `_ready()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 并将以下内容添加到`_ready()`中：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Later, the game's main script will handle setting `screensize` for all of the
    game's objects, but for now, this will allow you to test the screen wrapping with
    just the player scene.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，游戏的主脚本将处理设置所有游戏对象的`screensize`，但现在，这将允许你仅使用玩家场景测试屏幕卷曲。
- en: 'When first approaching this problem, you might think you could use the body''s
    `position` property and, if it exceeds the bounds of the screen, set it to the
    opposite side. However, when using `RigidBody2D`, you can''t directly set its
    `position`, because that would conflict with the movement that the physics engine
    is calculating. A common mistake is to try adding something like this to `_physics_process()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次接近这个问题时，你可能认为可以使用身体的`position`属性，如果它超出屏幕边界，就将其设置为相反的一侧。然而，当使用`RigidBody2D`时，你不能直接设置其`position`，因为这会与物理引擎正在计算的移动冲突。一个常见的错误是尝试在`_physics_process()`中添加类似以下内容：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will fail, trapping the player on the edge of the screen (and occasionally
    *glitching* unpredictably at the corners). So, why doesn't this work? The Godot
    documentation recommends `_physics_process()` for physics-related code—it even
    has *physics* in the name. It makes sense at first glance that this should work
    correctly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将失败，将玩家困在屏幕边缘（并且偶尔在角落处不可预测地*闪烁*）。那么，为什么这不起作用呢？Godot文档建议使用`_physics_process()`来编写与物理相关的代码——它甚至包含*物理*这个词。乍一看，这似乎应该能正常工作。
- en: In fact, the correct way to solve this problem is *not* to use `_physics_process()`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，解决这个问题的正确方法*不是*使用`_physics_process()`。
- en: 'To quote the `RigidBody2D` docs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 引用`RigidBody2D`文档：
- en: '"You should not change a RigidBody2D''s position or linear_velocity every frame
    or even very often. If you need to directly affect the body''s state, use _integrate_forces,
    which allows you to directly access the physics state."'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: “你不应该在每一帧或非常频繁地更改RigidBody2D的`position`或线性速度。如果你需要直接影响身体的`state`，请使用`_integrate_forces`，这允许你直接访问物理状态。”
- en: 'And in the description for `_integrate_forces()`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在`_integrate_forces()`的描述中：
- en: '"(It) Allows you to read and safely modify the simulation state for the object.
    Use this instead of _physics_process if you need to directly change the body''s
    position or other physics properties. (emphasis added)"'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: “（它）允许你读取和安全地修改对象的模拟状态。如果你需要直接更改身体的`position`或其他物理属性，请使用此方法代替`_physics_process`。（强调部分）”
- en: The answer is to change the physics callback to `_integrate_forces()`, which
    gives you access to the body's `Physics2DDirectBodyState`. This is a Godot object
    containing a great deal of useful information about the current physics state
    of the body. In the case of location, the key piece of information is the body's
    `Transform2D`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是将物理回调更改为`_integrate_forces()`，这让你可以访问身体的`Physics2DDirectBodyState`。这是一个包含大量关于身体当前物理状态的有用信息的Godot对象。在位置方面，关键信息是身体的`Transform2D`。
- en: A *transform* is a matrix representing one or more transformations in 2D space
    such as translation, rotation, and/or scaling. The translation (that is, position)
    information is found by accessing the `origin` property of the `Transform2D`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *变换* 是一个表示二维空间中一个或多个变换（如平移、旋转和/或缩放）的矩阵。通过访问 `Transform2D` 的 `origin` 属性可以找到平移（即位置）信息。
- en: 'Using this information, you can implement the wrap around effect by changing
    `_physics_process()` to `_integrate_forces()` and altering the transform''s origin:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，你可以通过将 `_physics_process()` 改为 `_integrate_forces()` 并改变变换的原点来实现环绕效果：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that the function''s argument name has been changed to `physics_state`
    from its default: `state`. This is to prevent any possible confusion with the
    already existing `state` variable, which tracks what FSM state the player is currently
    assigned to.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数的参数名称已从默认的 `state` 改为 `physics_state`。这是为了避免与已经存在的 `state` 变量产生任何可能的混淆，该变量跟踪玩家当前分配到的
    FSM 状态。
- en: Run the scene again and check that everything is working as expected. Make sure
    you try wrapping around in all four directions. A common mistake is to accidentally
    flip a greater-than or less-than sign, so check that first if you're having a
    problem with one or more screen edges.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行场景并检查一切是否按预期工作。确保你尝试在所有四个方向上进行环绕。一个常见的错误是意外地翻转大于或小于符号，所以如果你在屏幕的某个边缘遇到问题，首先检查这一点。
- en: Shooting
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射击
- en: Now, it's time to give your ship some weapons. When pressing the `shoot` action,
    a bullet should be spawned at the front of the ship and travel in a straight line
    until it exits the screen. Then, the gun isn't allowed to fire again until a small
    amount of time has passed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候给你的飞船装备一些武器了。当按下 `shoot` 动作时，子弹应该从飞船的前端生成并沿直线飞行，直到它退出屏幕。然后，直到经过一小段时间后，枪才允许再次开火。
- en: Bullet scene
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子弹场景
- en: 'This is the node setup for the bullet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是子弹的节点设置：
- en: '`Area2D` (named `Bullet`)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Area2D`（命名为 `Bullet`）'
- en: '`Sprite`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite`'
- en: '`CollisionShape2D`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollisionShape2D`'
- en: '`VisibilityNotifier2D`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VisibilityNotifier2D`'
- en: Use `res://assets/laser.png` from the assets folder for the texture of the `Sprite`,
    and a `CapsuleShape2D` for the collision shape. You'll have to set the Rotation of
    the `CollisionShape2D` to `90` so that it will fit correctly. You should also
    scale the `Sprite` down to half size (`(0.5, 0.5)`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从资源文件夹 `res://assets/laser.png` 中的 `laser.png` 作为 `Sprite` 的纹理，以及 `CapsuleShape2D`
    作为碰撞形状。你需要将 `CollisionShape2D` 的旋转设置为 `90` 以确保正确匹配。你还应该将 `Sprite` 缩小到一半大小（`(0.5,
    0.5)`）。
- en: 'Add the following script to the `Bullet` node:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下脚本添加到 `Bullet` 节点：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Set the exported `speed` property to `1000`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将导出的 `speed` 属性设置为 `1000`。
- en: 'The `VisibilityNotifier2D` is a node that can inform you (using signals) whenever
    a node becomes visible/invisible. You can use this to automatically delete a bullet
    when it goes off screen. Connect the `screen_exited` signal of `VisibilityNotifier2D`
    and add this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisibilityNotifier2D` 是一个节点，它可以通知你（使用信号）每当一个节点变为可见或不可见时。你可以使用这个功能在子弹离开屏幕时自动删除它。连接
    `VisibilityNotifier2D` 的 `screen_exited` 信号并添加以下内容：'
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, connect the bullet''s `body_entered` signal so that you can detect
    when the bullet hits a rock. The bullet doesn''t need to *know* anything about
    rocks, just that it has hit something. When you create the rocks, you''ll add
    them to a group called `rocks` and give them an `explode()` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，连接子弹的 `body_entered` 信号，以便你可以检测到子弹击中岩石的情况。子弹不需要 *知道* 任何关于岩石的信息，只需知道它击中了某个东西。当你创建岩石时，你将它们添加到名为
    `rocks` 的组中，并给它们一个 `explode()` 方法：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Firing bullets
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射子弹
- en: Now, you need instances of the bullet to be created whenever the player fires.
    However, if you make the bullet a child of the player, then it will move and rotate
    along with the player instead of moving independently. Instead, the bullet should
    be added as a child of the main scene. One way to do this would be to use `get_parent().add_child()`,
    since the `Main` scene will be the parent of the player when the game is running.
    However, this would mean you could no longer run the `Player` scene by itself
    like you have been doing, because `get_parent()` would produce an error. Or, if
    in the `Main` scene you decided to arrange things differently, making the player
    a child of some other node, the bullet wouldn't be added where you expect.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is a bad idea to write code that assumes a fixed tree layout.
    Especially try to avoid using `get_parent()` if at all possible. You may find
    it difficult to think this way at first, but it will result in a much more modular
    design and prevent some common mistakes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the player will *give* the bullet to the main scene using a signal.
    In this way, the `Player` scene doesn't need to *know* anything about how the
    `Main` scene is set up, or even if the `Main` scene exists. Producing the bullet
    and handing it off is the `Player` object's only responsibility.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Position2D` node to the player and name it `Muzzle`. This will mark the
    *muzzle* of the gun—the location where the bullet will spawn. Set its Position to
    `(50, 0)` to place it directly in front of the ship.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a `Timer` node named `GunTimer`. This will provide a *cooldown* to
    the gun, preventing a new bullet from firing until a certain amount of time has
    passed. Check the One Shot and Autoplay boxes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these new variables to the player''s script:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Drag the `Bullet.tscn` onto the new Bullet property in the Inspector, and set
    the Fire Rate to `0.25` (this value is in seconds).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this to `_ready()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And this to `get_input()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, create the `shoot()` function, which will handle creating the bullet(s):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When emitting the `shoot` signal, you pass the `Bullet` itself plus its starting
    position and direction. Then, you disable shooting with the `can_shoot` flag and
    start the `GunTimer`. To allow the gun to shoot again, connect the `timeout` signal
    of the `GunTimer`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, make your Main scene. Add a `Node` named `Main` and a `Sprite` named `Background`.
    Use `res://assets/space_background.png` as the Texture*.* Add an instance of the
    `Player` to the scene.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a script to `Main`, then connect the `Player` node''s `shoot` signal, and
    add the following to the created function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Play the `Main` scene and test that you can fly and shoot.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Rocks
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the game is to destroy the floating space rocks, so, now that you
    can shoot, it's time to add them. Like the ship, the rocks will also be `RigidBody2D`,
    which will make them travel in a straight line at a steady speed unless disturbed.
    They'll also bounce off each other in a realistic fashion. To make things more
    interesting, rocks will start out large and, when you shoot them, break into multiple
    smaller rocks.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的目标是摧毁漂浮的太空岩石，因此，现在您能够射击，是时候添加它们了。像飞船一样，岩石也将是 `RigidBody2D`，这将使它们以恒定的速度直线运动，除非受到干扰。它们还会以逼真的方式相互弹跳。为了使事情更有趣，岩石最初是大的，当您射击它们时，会破碎成多个较小的岩石。
- en: Scene setup
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置
- en: Start a new scene by making a `RigidBody2D`, naming it `Rock`, and adding a
    `Sprite` using the `res://assets/rock.png` texture. Add a `CollisionShape2D`,
    but *don't* add a shape to it yet. Because you'll be spawning different-sized
    rocks, the collision shape will need to be set in the code and adjusted to the
    correct size.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个 `RigidBody2D`，将其命名为 `Rock`，并使用 `res://assets/rock.png` 纹理添加一个 `Sprite`
    来开始一个新的场景。添加一个 `CollisionShape2D`，但 *不要* 向其中添加形状。因为您将生成不同大小的岩石，碰撞形状需要在代码中设置并调整到正确的大小。
- en: Set the Bounce property of the `Rock` to `1` and both Linear/Damp and Angular/Damp
    to `0`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Rock` 的弹跳属性设置为 `1`，并将线性/阻尼和角/阻尼都设置为 `0`。
- en: Variable size
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量大小
- en: 'Attach a script and define the member variables:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个脚本并定义成员变量：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Main` script will handle spawning new rocks, both at the beginning of a
    level as well as the smaller rocks that will appear after a large one explodes.
    A large rock will have a `size` of `3` and break into rocks of size `2`, and so
    on. The `scale_factor` is multiplied by `size` to set the sprite's scale, the
    collision radius, and so on. You can adjust it later to change how big each category
    of rock is.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 脚本将处理生成新的岩石，包括在关卡开始时以及在大岩石爆炸后出现的较小岩石。大岩石将具有 `3` 的 `size`，并破碎成 `2` 尺寸的岩石，依此类推。`scale_factor`
    乘以 `size` 以设置精灵的缩放、碰撞半径等。您可以在以后调整它以改变每种岩石的大小。'
- en: 'All of this will be set by the `start()` method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都将通过 `start()` 方法设置：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here is where you calculate the correct collision shape based on the rock's
    `size` and add it to the `CollisionShape2D`. Note that since `size` is already
    in use as a class variable, you can use `_size` for the function argument.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里您需要根据岩石的 `size` 计算正确的碰撞形状并将其添加到 `CollisionShape2D`。请注意，由于 `size` 已经作为类变量使用，您可以使用
    `_size` 作为函数参数。
- en: 'The rocks also need to wrap around the screen, so use the same technique you
    used for the `Player`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 岩石还需要在屏幕周围环绕，因此使用您为 `Player` 使用过的相同技术：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The difference here is that including the body's `radius` results in smoother-looking
    teleportation. The rock will appear to fully exit the screen before entering at
    the opposite side. You may want to do the same thing with the player ship. Try
    it and see which effect you like better.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不同之处在于包含身体的 `radius` 会使得传送看起来更平滑。岩石看起来会完全退出屏幕，然后从对面进入。您可能还想对玩家飞船做同样的事情。试试看，看看您更喜欢哪种效果。
- en: Instancing
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化
- en: 'When new rocks are spawned, the main scene will need to pick a random start
    location. To do this, you could use some geometry to pick a random point along
    the perimeter of the screen, but instead you can take advantage of yet another
    Godot node type. You''ll draw a path around the edge of the screen, and the script
    will pick a random location along the path. Add a `Path2D` node and name it `RockPath`.
    When you click on the `Path2D`, you will see some new buttons appear at the top
    of the editor:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成新的岩石时，主场景需要选择一个随机的起始位置。为此，您可以使用一些几何形状来选择屏幕边缘的随机点，但您可以利用另一种 Godot 节点类型。您将在屏幕边缘绘制一个路径，脚本将选择路径上的一个随机位置。添加一个
    `Path2D` 节点并将其命名为 `RockPath`。当您点击 `Path2D` 时，您将在编辑器的顶部看到一些新的按钮：
- en: '![](img/00083.gif)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00083.gif)'
- en: 'Select the middle one (Add Point) to draw the path by clicking to add the points
    shown. To make the points align, make sure Snap to grid is checked. This option
    is found under the Snapping Options button to the left of the `Lock` button. It
    appears as a series of three vertical dots. Refer to the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 选择中间的（添加点）通过点击添加显示的点来绘制路径。为了使点对齐，请确保启用“吸附到网格”。此选项位于“锁定”按钮左侧的“吸附选项”按钮下。它看起来像一系列三个垂直点。请参考以下截图：
- en: '![](img/00084.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00084.jpeg)'
- en: 'Draw the points in the order shown in the following screenshot. After clicking
    the fourth point, click the Close Curve button (**5**) and your path will be complete:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下截图所示的顺序绘制点。点击第四个点后，点击关闭曲线按钮（**5**），你的路径将完成：
- en: '![](img/00085.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: Now that the path is defined, add a `PathFollow2D` node as a child of `RockPath`
    and name it `RockSpawn`. This node's purpose is to automatically follow a path
    as it moves, using its `set_offset()` method. The higher the offset, the further
    along the path it goes. Since our path is closed, it will loop around if the offset
    value is bigger than the path's length.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在路径已经定义，将`PathFollow2D`节点作为`RockPath`的子节点添加，并命名为`RockSpawn`。此节点的作用是在移动时自动跟随路径，使用其`set_offset()`方法。偏移量越高，它沿着路径移动的距离就越远。由于我们的路径是闭合的，如果偏移值大于路径长度，它将循环。
- en: Next, add a `Node` and name it `Rocks`. This node will serve as a container
    to hold all the rocks. By checking its number of children, you can tell if there
    are any rocks remaining.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个`Node`并命名为`Rocks`。此节点将作为容器来保存所有岩石。通过检查其子节点数量，你可以判断是否还有剩余的岩石。
- en: 'Now, add this to `Main.gd`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下内容添加到`Main.gd`中：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The script starts by getting the `screensize` and passing that to the `Player`.
    Then, it spawns three rocks of size `3` using `spawn_rock()`, which is defined
    in the following code. Don''t forget to drag `Rock.tscn` onto the Rock property
    in the Inspector:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先获取`screensize`并将其传递给`Player`。然后，使用在以下代码中定义的`spawn_rock()`，生成三个大小为`3`的岩石。不要忘记将`Rock.tscn`拖放到检查器中的`Rock`属性：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function will serve two purposes. When called with only a size parameter,
    it picks a random position along the `RockPath` and a random velocity. However,
    if those values are also provided, it will use them instead. This will let you
    spawn the smaller rocks at the location of the explosion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将有两个作用。当只传递一个大小参数时，它会在`RockPath`上随机选择一个位置和一个随机速度。然而，如果也提供了这些值，它将使用它们。这将允许你在爆炸的位置生成较小的岩石。
- en: Run the game and you should see three rocks floating around. However, your bullets
    don't affect them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏后，你应该看到三个岩石在周围漂浮。然而，你的子弹不会影响它们。
- en: Exploding rocks
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爆炸岩石
- en: 'The `Bullet` is checking for bodies in the `rocks` group, so in the `Rock`
    scene, click on the Node tab and choose Groups. Type `rocks` and click Add:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bullet`正在检查`rocks`组中的身体，因此，在`Rock`场景中，点击节点选项卡并选择组。键入`rocks`并点击添加：'
- en: '![](img/00086.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: 'Now, if you run the game and shoot a rock, you''ll see an error message because
    the bullet is trying to call the rock''s `explode()` method, which you haven''t
    defined yet. This method needs to do three things:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行游戏并射击岩石，你会看到一个错误消息，因为子弹正在尝试调用岩石的`explode()`方法，但你还没有定义它。此方法需要做三件事：
- en: Remove the rock
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除岩石
- en: Play an explosion animation
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放爆炸动画
- en: Notify `Main` to spawn new, smaller rocks
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知`Main`生成新的、更小的岩石
- en: Explosion scene
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爆炸场景
- en: 'The explosion will be a separate scene, which you can add to the `Rock` and
    later to the `Player`. It will contain two nodes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 爆炸将是一个独立的场景，你可以将其添加到`Rock`和后来到`Player`。它将包含两个节点：
- en: '`Sprite` (named `Explosion`)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite`（命名为`Explosion`)'
- en: '`AnimationPlayer`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnimationPlayer`'
- en: For the sprite's Texture, use `res://assets/explosion.png`. You'll notice that
    this is a sprite sheet—an image made up of 64 smaller images laid out in a grid
    pattern. These images are the individual frames of the animation. You'll often
    find animations packaged this way, and Godot's `Sprite` node supports using them
    as individual frames.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于精灵的纹理，使用`res://assets/explosion.png`。你会注意到这是一个精灵图集——由64个较小的图像组成的网格图案。这些图像是动画的单独帧。你经常会发现以这种方式打包的动画，并且Godot的`Sprite`节点支持将它们作为单独的帧使用。
- en: 'In the Inspector, find the sprite''s Animation section. Set the Vframes and
    Hframes both to `8`. This will *slice* the sprite sheet into its individual images.
    You can verify this by changing the Frame property to different values between
    `0` and `63`. Make sure to set Frames back to `0` when finished:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中，找到精灵的动画部分。将Vframes和Hframes都设置为`8`。这将*切割*精灵图集成其单独的图像。你可以通过将帧属性更改为`0`到`63`之间的不同值来验证这一点。完成时，请确保将帧属性恢复到`0`：
- en: '![](img/00087.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: 'The `AnimationPlayer` can be used to animate any property of any node. You''ll
    use the `AnimationPlayer` to change the Frame property over time. Start by clicking
    on the node and you''ll see the Animation panel open at the bottom, as shown in
    the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimationPlayer` 可以用来动画化任何节点的任何属性。你将使用 `AnimationPlayer` 来随时间改变帧属性。首先点击节点，你将看到动画面板在底部打开，如下截图所示：'
- en: '![](img/00088.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00088.jpeg)'
- en: Click the New Animation button and name it `explosion`. Set the Length to `0.64` and
    the Step to `0.01`. Now, click on the `Sprite` node and you'll notice that each
    property in the Inspector now has a key button next to it. Each time you click
    on the key, you create a keyframe in the current animation. The key button next
    to the Frame property also has a `+` symbol on it, indicating that it will automatically
    increment the value when you add a key frame.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 点击新建动画按钮，将其命名为 `explosion`。设置长度为 `0.64`，步长为 `0.01`。现在，点击 `Sprite` 节点，你会注意到检查器中现在每个属性旁边都有一个键按钮。每次点击键，你就在当前动画中创建一个关键帧。帧属性旁边的键按钮上还有一个
    `+` 符号，表示当你添加关键帧时，它将自动增加值。
- en: Click the key and confirm that you want to create a new animation track. Note
    that the Frame property has incremented to `1`. Click the key button repeatedly
    until you have reached the final frame (`63`).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 点击键并确认你想要创建一个新的动画轨道。注意，帧属性已增加到 `1`。重复点击键按钮，直到达到最终帧（`63`）。
- en: Click the Play button in the Animation panel to see the animation being played.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画面板中点击播放按钮，以查看动画播放。
- en: Adding to Rock
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到岩石
- en: 'In the `Rock` scene, add an instance of `Explosion` and add this line to `start()`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Rock` 场景中，添加一个 `Explosion` 实例，并在 `start()` 中添加此行：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will ensure that the explosion is scaled to match the rock's size.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保爆炸的缩放与岩石的大小相匹配。
- en: 'Add a signal called `exploded` at the top of the script, then add the `explode()` function,
    which will be called when the bullet hits the rock:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本顶部添加一个名为 `exploded` 的信号，然后添加 `explode()` 函数，该函数将在子弹击中岩石时被调用：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `layers` property ensures that the explosion will be drawn on top of the
    other sprites on the screen. Then, you will send a signal that will let `Main`
    know to spawn new rocks. This signal also needs to pass the necessary data so
    that the new rocks will have the right properties.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`layers` 属性确保爆炸效果将被绘制在屏幕上其他精灵之上。然后，你将发送一个信号，让 `Main` 知道生成新的岩石。此信号还需要传递必要的数据，以便新岩石具有正确的属性。'
- en: 'When the animation finishes playing, the `AnimationPlayer` will emit a signal.
    To connect it, you need to make the `AnimationPlayer` node visible. Right-click
    on the instanced Explosion and select Editable Children, then select the `AnimationPlayer`
    and connect its `animation_finished` signal. Make sure to select the `Rock` in
    the Connect to Node section. The end of the animation means it is safe to delete
    the rock:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画播放完毕后，`AnimationPlayer` 将发出一个信号。要连接它，你需要使 `AnimationPlayer` 节点可见。右键单击实例化的爆炸，选择
    Editable Children，然后选择 `AnimationPlayer` 并连接其 `animation_finished` 信号。确保在连接到节点部分选择
    `Rock`。动画的结束意味着可以安全地删除岩石：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, test the game and check that you can see explosions when you shoot the
    rocks. At this point, your rock scene should look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试游戏并检查在射击岩石时是否可以看到爆炸效果。此时，你的岩石场景应该看起来像这样：
- en: '![](img/00089.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00089.jpeg)'
- en: Spawning smaller rocks
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成较小的岩石
- en: 'The `Rock` is emitting the signal, but it needs to be connected in `Main`.
    You can''t use the Node tab to connect it, because the `Rock` instances are being
    created in code. Signals can be connected in code as well. Add this line to the
    end of `spawn_rock()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rock` 正在发出信号，但需要在 `Main` 中连接。你不能使用节点标签页来连接它，因为岩石实例是在代码中创建的。信号也可以在代码中连接。将此行添加到
    `spawn_rock()` 的末尾：'
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This connects the rock''s signal to a function in `Main` called `_on_Rock_exploded()`.
    Create that function, which will be called whenever a rock sends its `exploded`
    signal:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把岩石的信号连接到 `Main` 中名为 `_on_Rock_exploded()` 的函数。创建该函数，它将在岩石发送其 `exploded` 信号时被调用：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this function, two new rocks are created unless the rock that was just destroyed
    was the smallest size it can be. The `offset` loop variable will ensure that they
    spawn and travel in opposite directions (that is, one will be the negative of
    the other). The `dir` variable finds the vector between the player and the rock,
    then uses `tangent()` to find the perpendicular to that vector. This ensures that
    the new rocks travel away from the player:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，除非刚刚被摧毁的石头是它可能的最小尺寸，否则将创建两个新的石头。`offset`循环变量将确保它们向相反方向（即，一个将是另一个的负值）生成和移动。`dir`变量找到玩家和石头之间的向量，然后使用`tangent()`找到该向量的垂直向量。这确保了新石头会远离玩家：
- en: '![](img/00090.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: Play the game once again and check that everything is working as expected.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 再次玩游戏并检查一切是否按预期工作。
- en: UI
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI
- en: Creating a game UI can be very complex, or at least time-consuming. Precisely
    placing individual elements and ensuring they work on different-sized screens
    and devices is the least interesting part of game development for many programmers.
    Godot provides a wide variety of Control nodes to assist in this process. Learning
    how to use the various Control nodes will help lessen the pain of creating your
    game's UI.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建游戏UI可能非常复杂，或者至少很耗时。精确放置单个元素并确保它们在不同大小的屏幕和设备上工作，对于许多程序员来说，是游戏开发中最不有趣的部分。Godot提供了各种`Control`节点来协助这个过程。学习如何使用各种`Control`节点将有助于减轻创建游戏UI的痛苦。
- en: 'For this game, you don''t need a very complex UI. The game needs to provide
    the following information and interactions:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个游戏，你不需要一个非常复杂的UI。游戏需要提供以下信息和交互：
- en: Start button
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始按钮
- en: Status message (Get Ready or Game Over)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态信息（准备或游戏结束）
- en: Score
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分数
- en: Lives counter
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命计数器
- en: 'The following is a preview of what you will be able to create:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将能够创建的预览：
- en: '![](img/00091.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.jpeg)'
- en: Create a new scene, and add a `CanvasLayer` with the name `HUD` as its root
    node. The UI will be built on this layer by using Godot's `Control` Layout features.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并添加一个名为`HUD`的`CanvasLayer`作为根节点。UI将通过使用Godot的`Control`布局功能构建在这个层上。
- en: Layout
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: Godot's `Control` nodes include a number of specialized containers. These nodes
    can be nested inside each other to create the precise layout you need. For example,
    a `MarginContainer` will automatically add padding around its contents, while
    `HBoxContainer` and `VBoxContainer` organize their contents in rows or columns,
    respectively.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Godot的`Control`节点包括许多专门的容器。这些节点可以嵌套使用，以创建所需的精确布局。例如，`MarginContainer`会自动为其内容添加填充，而`HBoxContainer`和`VBoxContainer`则分别按行或列组织其内容。
- en: Start by adding a `MarginContainer`, which will hold the score and lives counter.
    Under the Layout menu, select Top Wide. Then, scroll down to the Custom Constants
    section and set all four margins to `20`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加一个`MarginContainer`，它将包含分数和生命计数器。在布局菜单下，选择顶部宽。然后，向下滚动到自定义常量部分，将所有四个边距设置为`20`。
- en: Next, add an `HBoxContainer`, which will hold the score counter on the left
    and the lives counter on the right. Under this container, add a `Label` (name
    it `ScoreLabel`) and another `HBoxContainer` (name it `LivesCounter`).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个`HBoxContainer`，它将包含左边的分数计数器和右边的生命计数器。在这个容器下，添加一个`Label`（命名为`ScoreLabel`）和另一个`HBoxContainer`（命名为`LivesCounter`）。
- en: Set the `ScoreLabel` Text to `0` and, under `Size Flags`, set Horizontal to
    Fill, Expand. Under Custom Fonts, add a `DynamicFont` like you did in [Chapter
    1](part0022.html#KVCC0-5809b3bef8d2453086d97dfad17b2ee2), *Introduction*, using
    `res://assets/kenvector_future_thin.ttf` from the `assets` folder and setting
    the size to `64`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ScoreLabel`的文本设置为`0`，在`Size Flags`下设置水平为填充、扩展。在自定义字体中，添加一个`DynamicFont`，就像你在[第1章](part0022.html#KVCC0-5809b3bef8d2453086d97dfad17b2ee2)“简介”中做的那样，使用`res://assets/kenvector_future_thin.ttf`从`assets`文件夹中设置大小为`64`。
- en: Under the `LivesCounter`, add a `TextureRect` and name it `L1`. Drag `res://assets/player_small.png`
    into the Texture property and set the Stretch Mode to Keep Aspect Centered. Make
    sure you have the `L1` node selected and press Duplicate (*Ctrl* + *D*) two times
    to create `L2` and `L3` (they'll be named automatically). During the game, the
    `HUD` will show/hide these three textures to indicate how many lives the user
    has left.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LivesCounter`下添加一个`TextureRect`并命名为`L1`。将`res://assets/player_small.png`拖到纹理属性中，并将拉伸模式设置为保持宽高比居中。确保选中`L1`节点，然后按两次复制（*Ctrl*
    + *D*）来创建`L2`和`L3`（它们将被自动命名）。在游戏中，`HUD`将显示/隐藏这三个纹理，以指示用户剩余多少生命。
- en: In a larger, more complicated UI, you could save this section as its own scene
    and embed it in other sections of the UI. However, this game only needs a few
    more pieces for its UI, so it's fine to combine them all in one scene.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更大、更复杂的UI中，你可以将这一部分保存为其自己的场景，并将其嵌入UI的其他部分。然而，这个游戏只需要UI的几个更多组件，所以将它们全部组合在一个场景中是完全可以的。
- en: As a child of the `HUD` node, add a `TextureButton` (named `StartButton`), a
    `Label` (named `MessageLabel`), and a `Timer` (named `MessageTimer`).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 作为“HUD”节点的子节点，添加一个名为“StartButton”的“TextureButton”，一个名为“MessageLabel”的“Label”，以及一个名为“MessageTimer”的“Timer”。
- en: In the `res://assets` folder, there are two textures for the `StartButton`,
    one normal (`play_button.png`) and one to show when the mouse is hovering over
    it (`play_button_h.png`). Drag these to the Textures/Normal and Textures/Hover
    properties, respectively. In the Layout menu, choose Center.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在“res://assets”文件夹中，有两个用于“StartButton”的纹理，一个正常纹理（`play_button.png`）和一个当鼠标悬停时显示的纹理（`play_button_h.png`）。将它们分别拖到“Textures/Normal”和“Textures/Hover”属性中。在布局菜单中，选择居中。
- en: For the `MessageLabel`, make sure you set the font first before specifying the
    layout, or it won't be centered properly. You can use the same settings you used
    for the `ScoreLabel`. After setting the font, set the layout to Full Rect.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“MessageLabel”，在指定布局之前，请确保首先设置字体，否则它将无法正确居中。你可以使用与“ScoreLabel”相同的设置。设置字体后，将布局设置为全矩形。
- en: Finally, set the One Shot property of `MessageTimer` to On and its Wait Time
    to `2`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将“MessageTimer”的“One Shot”属性设置为“On”以及其等待时间为“2”。
- en: 'When finished, your UI''s scene tree should look like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的UI场景树应该看起来像这样：
- en: '![](img/00092.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00092.jpeg)'
- en: UI functions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI函数
- en: 'You''ve completed the UI layout, so now let''s add a script to `HUD` so you
    can add the functionality:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了UI布局，现在让我们给“HUD”添加一个脚本，以便你可以添加功能：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `start_game` signal will be emitted when the player clicks the `StartButton`.
    The `lives_counter` variable is an array holding references to the three life
    counter images. The names are fairly long, so make sure to let the editor's autocomplete
    fill them in for you to avoid mistakes.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家点击“StartButton”时，将发出“start_game”信号。变量“lives_counter”是一个包含三个生命计数器图像引用的数组。名称相当长，所以请确保让编辑器的自动完成功能帮你填写，以避免出错。
- en: 'Next, you need functions to handle updating the displayed information:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要函数来处理更新显示信息：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each function will be called when a value changes to update the display.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数将在值改变时被调用以更新显示。
- en: 'Next, add a function to handle the `Game Over` state:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个处理“游戏结束”状态的功能：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, connect the `pressed` signal of the `StartButton` so that it can emit
    the signal to `Main`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，连接“StartButton”的“pressed”信号，以便它可以发出信号到“Main”：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, connect the `timeout` signal of `MessageTimer` so that it can hide
    the message:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，连接“MessageTimer”的“timeout”信号，以便它可以隐藏信息：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Main scene code
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主场景代码
- en: 'Now, you can add an instance of the `HUD` to the `Main` scene. Add the following
    variables to `Main.gd`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在“Main”场景中添加一个“HUD”实例。将以下变量添加到“Main.gd”中：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These will track the named quantities. The following code will handle starting
    a new game:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将跟踪命名数量。以下代码将处理开始新游戏：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, you need to make sure that you remove any existing rocks that are left
    over from the previous game and initialize the variables. Don't worry about the
    `start()` function on the player; you'll add that soon.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要确保删除任何从上一局游戏留下的剩余岩石并初始化变量。不用担心玩家上的“start()”函数；你很快就会添加它。
- en: 'After showing the `"Get Ready!"` message, you will use `yield` to wait for
    the message to disappear before actually starting the level:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示“Get Ready!”信息后，你将使用“yield”等待信息消失，然后实际开始关卡：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function will be called every time the level changes. It announces the
    level number and spawns a number of rocks to match. Note—since you initialized
    `level` to `0,` this will set it to `1` for the first level.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将在每次关卡改变时被调用。它宣布关卡编号并生成与数量相匹配的岩石。注意——由于你将`level`初始化为`0`，这将使它对于第一个关卡设置为`1`。
- en: 'To detect whether the level has ended, you continually check how many children
    the `Rocks` node has:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测关卡是否结束，你需要持续检查“Rocks”节点有多少个子节点：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, you need to connect the HUD's `start_game` signal (emitted when the Play
    button is pressed) to the `new_game()` function. Select the `HUD`, click on the
    Node tab, and connect the `start_game` signal. Set Make Function to Off and type
    `new_game` in the Method In Node field.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following function to handle what happens when the game ends:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Play the game and check that pressing the Play button starts the game. Note
    that the `Player` is currently stuck in the `INIT` state, so you can't fly around
    yet—the `Player` doesn't know the game has started.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Player code
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new signal and a new variable to `Player.gd`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `setget` statement in GDScript allows you to specify a function that will
    be called whenever the value of a given variable is changed. This means that when
    `lives` decreases, you can emit a signal to let the `HUD` know it needs to update
    the display:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `start()` function is called by `Main` when a new game starts:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When using `setget`, if you access the variable locally (in the local script),
    you must put `self.` in front of the variable name. If you don't, the `setget`
    function will not be called.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to connect this signal from the `Player` to the `update_lives`
    method in the `HUD`. In `Main`, click on the `Player` instance and find its `lives_changed` signal
    in the Node tab. Click Connect, and in the connection window, under Connect to
    Node, choose the `HUD`. For Method In Node, type `update_lives`. Make sure you
    have Make Function off, and click Connect, as shown in the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: Game over
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll make the player detect when it is hit by rocks, add
    an invulnerability feature, and end the game when the player runs out of lives.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an instance of the `Explosion` to the `Player`, as well as a `Timer` node
    (named `InvulnerabilityTimer`). In the Inspector, set the Wait Time of `InvulnerabilityTimer`
    to `2` and its One Shot to On. Add this to the top of `Player.gd`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This signal will notify the `Main` scene that the player has run out of lives
    and the game is over. Before that, however, you need to update the state machine
    to do a little more with each state:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `modulate.a` property of a sprite sets its alpha channel (transparency).
    Setting it to `0.5` makes it semi-transparent, while `1.0` is solid.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'After entering the `INVULNERABLE` state, you start the `InvulnerabilityTimer`.
    Connect its `timeout` signal:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Also, connect the `animation_finished` signal from the `Explosion` animation
    like you did in the `Rock` scene:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Detecting collisions between physics bodies
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you fly around, the player ship bounces off the rocks, because both bodies
    are `RigidBody2D` nodes. However, if you want to make something happen when two
    rigid bodies collide, you need to enable contact monitoring. Select the `Player`
    node and in the Inspector, set Contact Monitoring to On. By default, no contacts
    are reported, so you must also set Contacts Reported to `1`. Now, the body will
    emit a signal when it contacts another body. Click on the Node tab and connect
    the `body_entered` signal:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当你飞行时，玩家飞船会从岩石上弹开，因为这两个物体都是`RigidBody2D`节点。然而，如果你想当两个刚体碰撞时发生某些事情，你需要启用接触监控。选择`Player`节点，并在检查器中设置接触监控为开启。默认情况下，不会报告任何接触，因此你还必须将接触报告设置为`1`。现在，当身体接触另一个身体时，它将发出信号。点击节点标签页，并连接`body_entered`信号：
- en: '[PRE46]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, go to the `Main` scene and connect the Player's `dead` signal to the `game_over()`
    function. Play the game and try running into a rock. Your ship should explode,
    become invulnerable (for two seconds), and lose one life. Check that the game
    ends if you get hit three times.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到`主`场景，并将玩家的`死亡`信号连接到`game_over()`函数。玩玩游戏，尝试撞上岩石。你的飞船应该会爆炸，变得无敌（两秒钟），并失去一条生命。检查如果你被击中三次，游戏是否会结束。
- en: Pausing the game
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: 'Many games require some sort of pause mode to allow the player to take a break
    in the action. In Godot, pausing is a function of the scene tree and can be set
    using `get_tree().paused = true`. When the `SceneTree` is paused, three things
    happen:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏都需要某种暂停模式，以便玩家在动作中休息。在Godot中，暂停是场景树的一个功能，可以使用`get_tree().paused = true`来设置。当`SceneTree`暂停时，会发生三件事：
- en: The physics thread stops running
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理线程停止运行
- en: '`_process` and `_physics_process` are no longer called, so no code in those
    methods is run'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_process`和`_physics_process`不再被调用，因此那些方法中的代码不再运行'
- en: '`_input` and `_input_event` are also not called'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_input`和`_input_event`也没有被调用'
- en: When the pause mode is triggered, every node in the running game can react accordingly,
    based on how you've configured it. This behavior is set via the node's Pause/Mode
    property, which you'll find all the way at the bottom of the Inspector list.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当暂停模式被触发时，正在运行的游戏中的每个节点都可以根据你的配置做出相应的反应。这种行为是通过节点的暂停/模式属性设置的，你可以在检查器列表的最底部找到它。
- en: 'The pause mode can be set to three values: `INHERIT` (the default value), `STOP`,
    and `PROCESS`. `STOP` means the node will cease processing while the tree is paused,
    while `PROCESS` sets the node to continue running, ignoring the paused state of
    the tree. Because it would be very tedious to set this property on every node
    in the whole game, `INHERIT` lets the node use the same pause mode as its parent.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停模式可以设置为三个值：`INHERIT`（默认值）、`STOP`和`PROCESS`。`STOP`表示在树暂停时节点将停止处理，而`PROCESS`将节点设置为继续运行，忽略树的暂停状态。由于在游戏中为每个节点设置此属性会很麻烦，`INHERIT`允许节点使用与父节点相同的暂停模式。
- en: Open the Input Map tab (in Project Settings) and create a new input action called
    `pause`. Choose a key you'd like to use to toggle pause mode; for example, P is
    a good choice.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 打开输入映射标签页（在项目设置中），创建一个新的输入动作，命名为`pause`。选择你想要用来切换暂停模式的键；例如，P是一个不错的选择。
- en: 'Next, add the following function to `Main.gd` to respond to the input action:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下函数添加到`Main.gd`中，以响应输入动作：
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you ran the game now, you''d have a problem—all nodes are paused, including
    `Main`. This means that since it isn''t processing `_input`, it can''t detect
    the input again to unpause the game! To fix this, you need to set the Pause/Mode of
    `Main` to `PROCESS`. Now, you have the opposite problem: all the nodes below `Main`
    inherit this setting. This is fine for most of the nodes, but you need to set
    the mode to `STOP` on these three nodes: `Player`, `Rocks`, and `HUD`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你会遇到问题——所有节点都处于暂停状态，包括`Main`。这意味着由于它没有处理`_input`，它无法再次检测输入来暂停游戏！为了解决这个问题，你需要将`Main`的`Pause/Mode`设置为`PROCESS`。现在，你遇到了相反的问题：`Main`下面的所有节点都继承了这个设置。这对大多数节点来说是可以的，但你需要在这三个节点上设置模式为`STOP`：`Player`、`Rocks`和`HUD`。
- en: Enemies
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人
- en: Space is filled with more dangers than just rocks. In this section, you'll create
    an enemy spaceship that will periodically appear and shoot at the player.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 空间中充满了比岩石更多的危险。在本节中，你将创建一个会定期出现并向玩家开火的敌人士兵飞船。
- en: Following a path
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沿着路径移动
- en: When the enemy appears, it should follow a path across the screen. To keep it
    from looking too repetitive, you can create multiple paths and randomly choose
    one when the enemy starts.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人出现时，它应该在屏幕上跟随一条路径。为了防止它看起来过于重复，你可以创建多条路径，并在敌人开始时随机选择一条。
- en: 'Create a new scene and add a `Node`. Name it `EnemyPaths` and save the scene.
    To draw the path, add a `Path2D` node. As you saw earlier, this node allows you
    to draw a series of connected points. When you add the node, a new menu bar appears:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个 `Node`。将其命名为 `EnemyPaths` 并保存场景。要绘制路径，添加一个 `Path2D` 节点。正如您之前所看到的，此节点允许您绘制一系列连接的点。添加节点时，会出现一个新的菜单栏：
- en: '![](img/00094.jpeg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00094.jpeg)'
- en: 'These buttons let you draw and modify the path''s points. Click the one with
    the + symbol to add points. Click to start the path somewhere just outside the
    game window (the bluish-purple rectangle), and then click a few more points to
    create a curve. Don''t worry about making it smooth just yet:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮允许您绘制和修改路径的点。点击带有 + 符号的按钮以添加点。点击以在游戏窗口（蓝色紫色矩形）的外侧开始路径，然后点击几个更多点以创建一个曲线。暂时不用担心让它变得平滑：
- en: '![](img/00095.jpeg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00095.jpeg)'
- en: 'When the enemy ship follows the path, it will not look very smooth when it
    hits the sharp corners. To smooth the curve, click the second button in the path
    toolbar (its tooltip says Select Control Points). Now, if you click and drag any
    of the curve''s points, you will add a control point that allows you to angle
    and curve the line. Smoothing the preceding line results in something like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌舰跟随路径时，当它遇到尖锐的角落时，看起来不会非常平滑。为了平滑曲线，点击路径工具栏中的第二个按钮（其工具提示说选择控制点）。现在，如果您点击并拖动曲线的任何点，您将添加一个控制点，允许您调整线和曲线的角度。平滑前面的线会产生类似这样的效果：
- en: '![](img/00096.jpeg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00096.jpeg)'
- en: 'Add a few more `Path2D` nodes to the scene and draw the paths however you like.
    Adding loops and curves rather than straight lines will make the enemy look more
    dynamic (and make it harder to hit). Remember that the first point you click will
    be the start of the path, so make sure to place them on different sides of the
    screen, for variety. Here are three example paths:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 向场景中添加更多 `Path2D` 节点，并按照您喜欢的样式绘制路径。添加循环和曲线而不是直线会使敌人看起来更加动态（并且更难被击中）。请记住，您点击的第一个点将是路径的起点，因此请确保将它们放置在屏幕的不同侧面，以增加多样性。以下是一些示例路径：
- en: '![](img/00097.jpeg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00097.jpeg)'
- en: Save the scene. You'll add this to the enemy's scene to give it the paths it
    can follow.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 保存场景。您将将其添加到敌人的场景中，以提供它可以跟随的路径。
- en: Enemy scene
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人场景
- en: 'Create a new scene for the Enemy, using an `Area2D` as its root node. Add a
    `Sprite` and use `res://assets/enemy_saucer.png` as its Texture. Set the Animation/HFrames to
    `3` so that you can choose between the different-colored ships:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为敌人创建一个新的场景，使用 `Area2D` 作为其根节点。添加一个 `Sprite` 并使用 `res://assets/enemy_saucer.png`
    作为其纹理。将动画/帧数设置为 `3` 以便在不同颜色的飞船之间进行选择：
- en: '![](img/00098.jpeg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00098.jpeg)'
- en: 'As you''ve done before, add a `CollisionShape2D` and give it a `CircleShape2D`
    scaled to cover the sprite image. Next, add an instance of the `EnemyPaths` scene
    and an `AnimationPlayer`. In the `AnimationPlayer`, you''ll need two animations:
    one to make the saucer spin as it moves, and the other to create a flash effect
    when the saucer is hit:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所做的那样，添加一个 `CollisionShape2D` 并将其 `CircleShape2D` 缩放以覆盖精灵图像。接下来，添加一个 `EnemyPaths`
    场景实例和一个 `AnimationPlayer`。在 `AnimationPlayer` 中，您需要两个动画：一个用于使飞碟在移动时旋转，另一个用于当飞碟被击中时产生闪光效果：
- en: '**Rotate animation**: Add a new animation named `rotate` and set its *Length* to
    `3`. Add a keyframe for the `Sprite` Transform/Rotation Degrees property after
    setting it to `0`, then drag the play bar to the end and add a keyframe with the
    rotation set to `360`. Click the Loop button and the Autoplay button.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转动画**：添加一个名为 `rotate` 的新动画，并将其 *长度* 设置为 `3`。在将 `Sprite` 的 Transform/Rotation
    Degrees 属性设置为 `0` 后，添加一个关键帧，然后将播放条拖动到末尾并添加一个旋转设置为 `360` 的关键帧。点击循环按钮和自动播放按钮。'
- en: '**Hit animation**: Add a second animation named `flash`. Set its *Length* to
    `0.25` and the *Step* to `0.01`. The property you''ll be animating is the Sprite''s
    Modulate (found under *Visibility*). Add a keyframe for Modulate to create the
    track, then move the scrubber to `0.04` and change the Modulate color to red.
    Move forward another `0.04` and change the color back to white.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**击中动画**：添加一个名为 `flash` 的第二个动画。将其 *长度* 设置为 `0.25`，将 *步长* 设置为 `0.01`。您将动画化的属性是精灵的
    Modulate（在 *可见性* 下找到）。为 Modulate 添加一个关键帧以创建轨迹，然后将刮擦器移动到 `0.04` 并将 Modulate 颜色更改为红色。再向前移动
    `0.04` 并将颜色改回白色。'
- en: Repeat this process two more times so that you have three flashes in total.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 重复此过程两次，以便总共有三个闪光效果。
- en: 'Add an instance of the `Explosion` scene as you did with the other objects.
    Also, like you did with the rocks, connect the explosion''s `AnimationPlayer` `animation_finished`
    signal and set it to delete the enemy when the explosion finishes:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Next, add a `Timer` node called `GunTimer` that will control how often the enemy
    shoots at the player. Set its Wait Time to `1.5` and Autostart to `On`. Connect
    its `timeout` signal, but leave the code reading `pass` for now.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click on the `Area2D` and the Node tab and add it to a group called
    `enemies`. As with the rocks, this will give you a way to identify the object,
    even if there are multiple enemies on the screen at the same time.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Moving the Enemy
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attach a script to the `Enemy` scene. To begin, you''ll make the code that
    will select a path and move the enemy along it:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: A `PathFollow2D` node is one that can automatically move along a parent `Path2D`.
    By default, it is set to loop around the path, so you need to manually set the
    property to `false`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to move along the path:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can detect the end of the path when `offset` is greater than the total path
    length. However, it's more straightforward to use `unit_offset`, which varies
    from zero to one over the length of the path.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Spawning enemies
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `Main` scene and add a `Timer` node called `EnemyTimer`. Set its One
    Shot property to `On`. Then, in `Main.gd`, add a variable to reference your enemy
    scene (drag it into the Inspector after saving the script):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add the following code to `new_level()`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Connect the `EnemyTimer` `timeout` signal, and add the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This code instances the enemy whenever the `EnemyTimer` times out. When you
    add shooting to the enemy, it will use the same process you used for the `Player`,
    so you can reuse the same bullet-spawning function, which is `_on_Player_shoot()`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Play the game, and you should see a flying saucer appear that will fly along
    one of your paths.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Enemy shooting and collisions
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The enemy needs to shoot at the player as well as react when hit by the player
    or the player's bullets.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Bullet` scene and choose Save Scene As to save it as `EnemyBullet.tscn`
    (afterwards, don''t forget to rename the root node as well). Remove the script
    by selecting the root node and clicking the Clear the script button:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: 'You also need to disconnect the signal connections by clicking the Node tab
    and choosing Disconnect:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: There is also a different texture in the `assets` folder you can use to make
    the enemy bullet appear distinct from the player's.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'The script will be very much the same as the regular bullet. Connect the area''s
    `body_entered` signal and the `screen_exited` signal of `VisibilityNotifier2D`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For now, the bullet won't do any damage to the player. You'll be adding a shield
    to the player in the next section, so you can add that at the same time.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Save the scene and drag it into the Bullet property on the `Enemy`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Enemy.gd`, add the `shoot` function:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: First, you must find the vector pointing to the player's position, then add
    a little bit of randomness to it so that the bullets don't follow exactly the
    same path.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须找到指向玩家位置的向量，然后给它添加一点随机性，这样子弹就不会沿着完全相同的路径飞行。
- en: 'For an extra challenge, you can make the enemy shoot in *pulses*, or multiple
    rapid shots:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加挑战，你可以让敌人以*脉冲*的形式射击，或者进行多次快速射击：
- en: '[PRE56]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This function creates a given number of bullets with `delay` time between them.
    You can use this whenever the `GunTimer` triggers a shot:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建了一定数量的子弹，它们之间有`delay`时间间隔。你可以使用这个函数 whenever the `GunTimer` 触发射击：
- en: '[PRE57]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This will shoot a pulse of `3` bullets with `0.15` seconds between them. Tough
    to dodge!
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发射一串`3`个子弹，它们之间有`0.15`秒的间隔。很难躲避！
- en: Next, the enemy needs to take damage when it's hit by a shot from the player.
    It will flash using the animation you made, and then explode when its health reaches
    `0`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当敌人被玩家的射击击中时，它需要受到伤害。它将使用你制作的动画闪烁，然后当其健康值达到`0`时爆炸。
- en: 'Add these functions to `Enemy.gd`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下功能添加到`Enemy.gd`中：
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Also, connect the area''s `body_entered` signal so the enemy will explode if
    the player runs into it:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，连接区域的`body_entered`信号，这样当玩家撞到敌人时，敌人会爆炸：
- en: '[PRE59]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Again, you're waiting for the player shield to add the damage to the player,
    so leave the `pass` placeholder there for now.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你正在等待玩家护盾将伤害添加到玩家身上，所以现在暂时留下`pass`占位符。
- en: 'Right now, the player''s bullet is only detecting physics bodies because its `body_entered` signal
    is connected. However, the enemy is an `Area2D`, so it will not trigger that signal.
    To detect the enemy, you need to also connect the  `area_entered` signal:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，玩家的子弹只检测物理体，因为它的`body_entered`信号已连接。然而，敌人是一个`Area2D`，所以它不会触发该信号。为了检测敌人，你还需要连接`area_entered`信号：
- en: '[PRE60]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Try playing the game again and you'll be doing battle with an aggressive alien
    opponent! Verify that all the collision combinations are being handled. Also note
    that the enemy's bullets can be blocked by rocks—maybe you can hide behind them
    for cover!
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试玩游戏，你将与一个侵略性的外星对手战斗！验证所有碰撞组合是否被处理。此外，请注意敌人的子弹可以被岩石阻挡——也许你可以躲在它们后面作为掩护！
- en: Additional features
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外功能
- en: 'The structure of the game is complete. You can start the game, play it through,
    and when it ends, play again. In this section, you''ll add some additional effects
    and features to the game to improve the gameplay experience. Effects is a broad
    term and can mean many different techniques, but in this case, you''ll specifically
    address three things:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的结构已经完成。你可以开始游戏，玩一遍，当它结束时，再次玩。在本节中，你将添加一些额外的效果和功能来改善游戏体验。效果是一个广泛的概念，可以指许多不同的技术，但在这个案例中，你将具体解决三件事：
- en: '**Sound effects and music: **Audio is very often overlooked, but can be a very
    effective part of game design. Good sound improves the *feel* of the game. Bad
    or annoying sounds can create boredom or frustration. You''ll add some action-packed
    background music, and some sound effects for several actions in the game.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音效和音乐：**音频往往被忽视，但可以是游戏设计中非常有效的部分。好的音效可以提升游戏的*感觉*。糟糕或令人讨厌的声音可能会引起无聊或挫败感。你将添加一些充满动作的背景音乐，以及游戏中几个动作的声音效果。'
- en: '**Particles: **Particle effects are images, usually small, that are generated
    in large numbers and animated by a particle system. They can be used for a countless
    number of impressive visual effects. Godot''s particle system is quite powerful;
    too powerful to fully explore here, but you''ll learn enough to get started experimenting
    with it.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子效果：**粒子效果是图像，通常是小的，由粒子系统生成并动画化。它们可以用于无数令人印象深刻的视觉效果。Godot的粒子系统非常强大；在这里完全探索它可能过于强大，但你会学到足够的知识来开始实验。'
- en: '**Player shield: **If you''re finding the game too hard, especially on higher
    levels where there are a lot of rocks, adding a shield to the player will greatly
    increase your chances of survival. You can also make larger rocks do more damage
    to the shield than smaller ones. You''ll also make a nice display bar on the HUD
    to show the player''s remaining shield level.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家护盾：**如果你觉得游戏太难，尤其是在有大量岩石的高级关卡中，给玩家添加一个护盾将大大提高你的生存机会。你还可以让大岩石对护盾造成的伤害比小岩石更多。你还会在HUD上制作一个漂亮的显示条，以显示玩家剩余的护盾等级。'
- en: Sound/music
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频/音乐
- en: 'In the `res://assets/sounds` folder are several audio files containing different
    sounds in the OggVorbis format. By default, Godot sets `.ogg` files to loop when
    imported. In the case of `explosion.ogg`, `laser_blast.ogg`, and `levelup.ogg`,
    you don''t want the sounds to loop, so you need to change the import settings
    for those files. To do this, select the file in the FileSystem dock, and then
    click the Import tab located next to the Scene tab on the right-hand side of the
    editor window. Uncheck the box next to Loop and click Reimport. Do this for each
    of the three sounds. Refer to the following screenshot:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在`res://assets/sounds`文件夹中，有几个包含不同OggVorbis格式声音的音频文件。默认情况下，Godot会将导入的`.ogg`文件设置为循环播放。在`explosion.ogg`、`laser_blast.ogg`和`levelup.ogg`的情况下，你不想让声音循环，因此需要更改这些文件的导入设置。为此，在文件系统窗口中选择文件，然后点击位于编辑器窗口右侧场景标签旁边的导入标签。取消循环旁边的框，然后点击重新导入。为这三个声音都这样做。参考以下截图：
- en: '![](img/00101.jpeg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00101.jpeg)'
- en: 'To play a sound, it needs to be loaded by an `AudioStreamPlayer` node. Add
    two of these nodes to the `Player` scene, naming them `LaserSound` and `EngineSound`.
    Drag the respective sound into each node''s Stream property in the Inspector.
    To play the sound when shooting, add the following line to `shoot()` in `Player.gd`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放声音，需要通过`AudioStreamPlayer`节点加载。在`Player`场景中添加两个这样的节点，分别命名为`LaserSound`和`EngineSound`。将相应的声音拖入每个节点的Stream属性中，在检查器中进行操作。要在射击时播放声音，请将以下行添加到`Player.gd`中的`shoot()`函数：
- en: '[PRE61]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Play the game and try shooting. If you find the sound a bit too loud, you can
    adjust the Volume Db property. Try a value of `-10`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 播玩游戏并尝试射击。如果你觉得声音有点响，可以调整Volume Db属性。尝试使用`-10`的值。
- en: 'The engine sound works a little differently. It needs to play when the thrust
    is on, but if you try to just `play()` the sound in the `get_input()` function,
    it will restart the sound every frame as long as you have the input pressed. This
    doesn''t sound good, so you only want to start playing the sound if it isn''t
    already playing. Here is the relevant section from the `get_input()` function:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎声音的工作方式略有不同。它需要在推力开启时播放，但如果你尝试在`get_input()`函数中直接`play()`声音，只要按下输入，声音就会在每一帧重新开始播放。这听起来不太好，所以你只想在声音尚未播放时开始播放。以下是`get_input()`函数中的相关部分：
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that a problem can occur—if the player dies while holding down the thrust
    key, the engine sound will remain stuck on. This can be solved by adding `$EngineSound.stop()` to
    the `DEAD` state in `change_state()`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果玩家在按住推力键的情况下死亡，引擎声音会卡在播放状态。这可以通过在`change_state()`函数中的`DEAD`状态添加`$EngineSound.stop()`来解决。
- en: 'In the `Main` scene, add three more `AudioStreamPlayer` nodes: `ExplodeSound`,
    `LevelupSound`, and `Music`. In their Stream properties, drop `explosion.ogg`,
    `levelup.ogg`, and `Funky-Gameplay_Looping.ogg`.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`场景中，添加三个额外的`AudioStreamPlayer`节点：`ExplodeSound`、`LevelupSound`和`Music`。在它们的Stream属性中，分别放置`explosion.ogg`、`levelup.ogg`和`Funky-Gameplay_Looping.ogg`。
- en: Add `$ExplodeSound.play()` as the first line of `_on_Rock_exploded()`, and add
    `$LevelupSound.play()` to `new_level()`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_on_Rock_exploded()`的第一行添加`$ExplodeSound.play()`，并将`$LevelupSound.play()`添加到`new_level()`中。
- en: To start/stop the music, add `$Music.play()` to `new_game()` and `$Music.stop()`
    to `game_over()`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始/停止音乐，请在`new_game()`中添加`$Music.play()`，在`game_over()`中添加`$Music.stop()`。
- en: The Enemy also needs an `ExplodeSound` and a `ShootSound`. You can use the same
    explosion as the player, but there is an `enemy_laser.wav` sound to use for the
    shot.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人也需要一个`ExplodeSound`和一个`ShootSound`。你可以使用与玩家相同的爆炸声，但有一个`enemy_laser.wav`声音用于射击。
- en: Particles
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子
- en: The player ship's thrust is a perfect use for particles, creating a streaming
    flame from the engine. Add a `Particles2D` node to the `Player` scene and name
    it `Exhaust`. You might want to zoom in on the ship image while you're doing this
    part.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家飞船的推力是使用粒子效果的完美例子，可以从引擎中创建一条流动的火焰。在`Player`场景中添加一个`Particles2D`节点，并将其命名为`Exhaust`。你可能需要在执行这部分操作时放大飞船图像。
- en: 'When first created, the `Particles2D` node has a warning: *A material to process
    the particles is not assigned*. Particles will not be emitted until you assign
    a `Process Material` in the Inspector. Two types of materials are possible: `ShaderMaterial`
    and `ParticlesMaterial`. `ShaderMaterial` allows you to write shader code in a
    GLSL-like language, while `ParticlesMaterial` is configured in the Inspector.
    Next to Particles Material, click the down-arrow and choose New ParticlesMaterial.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次创建时，`Particles2D`节点有一个警告：*未分配处理粒子的材质*。粒子将不会发射，直到你在检查器中分配一个`Process Material`。有两种类型的材质：`ShaderMaterial`和`ParticlesMaterial`。`ShaderMaterial`允许你用类似GLSL的语言编写着色器代码，而`ParticlesMaterial`在检查器中配置。在`Particles
    Material`旁边点击向下箭头，然后选择“新建ParticlesMaterial”。
- en: You'll see a line of white dots streaming down from the center of the player
    ship. Your challenge now is to turn those into an exhaust flame.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到从玩家飞船中心流下的一行白色点。你现在的挑战是将这些点变成尾气火焰。
- en: 'There are a very large number of properties to choose from when configuring
    particles, especially under `ParticlesMaterial`. Before starting on that, set
    these properties of the `Particles2D`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置粒子时，有非常多的属性可供选择，尤其是在`ParticlesMaterial`下。在开始之前，设置这些`Particles2D`的属性：
- en: 'Amount: `25`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数量：`25`
- en: Transform/Position*: *`(-28, 0)`
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换/位置：*`(-28, 0)`
- en: 'Transform/Rotation: `180`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换/旋转：`180`
- en: 'Visibility/Show Behind Parent: `On`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见性/显示在父级之后：`开启`
- en: Now, click on the `ParticlesMaterial`. This is where you'll find the majority
    of the properties that affect the particles' behavior. Start with Emission Shape—change
    it to Box. This will reveal Box Extents, which should be set to `(1, 5, 1)`. Now,
    the particles are emitted over a small area instead of a single point.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击`ParticlesMaterial`。这是你找到影响粒子行为的大多数属性的地方。从发射形状开始——将其更改为框。这将揭示框范围，应设置为`(1,
    5, 1)`。现在，粒子是在一个小区域内发射，而不是从单个点发射。
- en: Next, set Spread/Spread to `0` and Gravity/Gravity to `(0, 0, 0)`. Now, the
    particles aren't falling or spreading out, but they are moving very slowly.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将扩散/扩散设置为`0`，将重力/重力设置为`(0, 0, 0)`。现在，粒子不会下落或扩散，但它们移动得非常慢。
- en: The next property is Initial Velocity. Set Velocity to `400`. Then, scroll down
    to Scale and set it to `8`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个属性是初始速度。将速度设置为`400`。然后，向下滚动到缩放并设置为`8`。
- en: 'To make the size change over time, you can set a Scale Curve. Click on New
    CurveTexture and click on it. A new panel labeled Curve will appear. The left-hand
    dot represents the starting scale, and the right-hand dot represents the end.
    Drag the right-hand dot down until your curve looks something like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要使大小随时间变化，你可以设置一个缩放曲线。点击“新建曲线纹理”并点击它。会出现一个新的标签为“曲线”的面板。左侧的点代表起始缩放，右侧的点代表结束。将右侧的点向下拖动，直到你的曲线看起来像这样：
- en: '![](img/00102.jpeg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.jpeg)'
- en: Now, the particles are shrinking as they age. Click the left arrow at the top
    of the Inspector to go back to the previous section.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，粒子随着年龄的增长而缩小。点击检查器顶部的左箭头返回上一部分。
- en: 'The final section to adjust is Color. To make the particles appear like a flame,
    the particles should start out a bright orange-yellow and shift to red while fading
    out. In the Color Ramp property, click on New GradientTexture. Then, in the Gradient
    property, choose New Gradient:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要调整的部分是颜色。为了让粒子看起来像火焰，粒子应该从明亮的橙黄色开始，逐渐变为红色，同时逐渐消失。在颜色渐变属性中，点击“新建渐变纹理”。然后，在渐变属性中，选择“新建渐变”：
- en: '![](img/00103.jpeg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.jpeg)'
- en: The sliders labeled 1 and 2 select the starting and ending colors, while 3 shows
    what color is set on the currently selected slider. Click on slider 1 and then
    click 3 to choose an orange color, then click on slider 2 and set it to a deep
    red.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 标有1和2的滑块选择起始和结束颜色，而3显示当前所选滑块上设置的颜色。点击滑块1，然后点击3选择橙色，然后点击滑块2并将其设置为深红色。
- en: Now that we can see what the particles are doing, they are lasting far too long.
    Go back to the `Exhaust` node and change the Lifetime to `0.1`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以看到粒子在做什么了，它们持续的时间太长了。回到`Exhaust`节点，将寿命改为`0.1`。
- en: Hopefully, your ship's exhaust looks somewhat like a flame. If it doesn't, feel
    free to adjust the `ParticlesMaterial` properties until you are happy with it.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你的飞船尾气看起来有点像火焰。如果不像，请随意调整`ParticlesMaterial`属性，直到你满意为止。
- en: Now that the ship's `Exhaust` is configured, it needs to be turned on/off based
    on the player input. Go to the player script and add `$Exhaust.emitting = false`
    at the beginning of `get_input()`. Then, add `$Exhaust.emitting = true` under
    the `if` statement that checks for thrust input.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在船的`Exhaust`已配置，需要根据玩家输入开启/关闭。转到玩家脚本，并在`get_input()`的开始处添加`$Exhaust.emitting
    = false`。然后，在检查推力输入的`if`语句下添加`$Exhaust.emitting = true`。
- en: Enemy trail
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人轨迹
- en: 'You can also use particles to make a trail effect behind the enemy. Add a `Particles2D`
    to the enemy scene and set the properties as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用粒子在敌人后面创建轨迹效果。将`Particles2D`添加到敌人场景中，并设置以下属性：
- en: 'Amount: `20`'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数量：`20`
- en: 'Local Coords: `Off`'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地坐标：`Off`
- en: 'Texture: `res://assets/corona.png`'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理：`res://assets/corona.png`
- en: 'Show Behind Parent: `On`'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在父元素后面显示：`On`
- en: Note that the effect texture you're using is white on a black background. This
    image needs its blend mode changed. To do this, on the particle node, find the
    Material property (it is in the `CanvasItem` section). Select New CanvasItemMaterial
    and, in the resulting material, change the Blend Mode to `Add`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你使用的纹理效果是白色背景上的白色。这张图片需要更改其混合模式。为此，在粒子节点上，找到材质属性（它在`CanvasItem`部分）。选择新的`CanvasItemMaterial`，然后在生成的材质中，将混合模式更改为`Add`。
- en: 'Now, create a `ParticlesMaterial` like you did previously, and use these settings:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个`ParticlesMaterial`，就像你之前所做的那样，并使用以下设置：
- en: 'Emission Shape:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射形状：
- en: 'Shape: Box'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状：Box
- en: 'Box Extents: (`25`, `25`, `1`)'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箱体范围：(`25`, `25`, `1`)
- en: 'Spread: `25`'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描范围：`25`
- en: 'Gravity: (0, 0, 0)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力：(0, 0, 0)
- en: 'Now, create a `ScaleCurve` like you did for the player exhaust. This time,
    make the curve look something like the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个`ScaleCurve`，就像你为玩家排气所做的那样。这次，使曲线看起来像以下这样：
- en: '![](img/00104.jpeg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: Try running the game and see how it looks. Feel free to tinker with the settings
    until you have something you like.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行游戏并查看效果。你可以随意调整设置，直到你满意为止。
- en: Player shield
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家护盾
- en: In this section, you'll add a shield to the player and a display element to
    the `HUD` showing the current shield level.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将为玩家添加一个护盾，并在`HUD`中添加一个显示当前护盾等级的显示元素。
- en: 'First, add the following to the top of the `Player.gd` script:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下内容添加到`Player.gd`脚本的顶部：
- en: '[PRE63]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `shield` variable will work similarly to `lives`, emitting a signal to the
    `HUD` whenever it changes. Save the script and set `max_shield` to `100` and `shield_regen`
    to `5` in the Inspector.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`shield`变量将类似于`lives`，每当它改变时都会向`HUD`发送信号。保存脚本，并在检查器中将`max_shield`设置为`100`，将`shield_regen`设置为`5`。'
- en: 'Next, add the following function, which handles changing the shield''s value:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下函数，该函数处理更改护盾值：
- en: '[PRE64]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Also, since some things, such as regeneration, may add to the shield's value,
    you need to make sure it doesn't go above the maximum allowed value. Then, when
    you send the `shield_changed` signal, you pass the ratio of `shield/max_shield`.
    This way, the HUD's display doesn't need to know anything about the actual values,
    just the shield's relative state.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于一些事情，如再生，可能会增加护盾的值，你需要确保它不会超过最大允许值。然后，当你发送`shield_changed`信号时，传递`shield/max_shield`的比率。这样，HUD的显示就不需要了解实际值，只需了解护盾的相对状态。
- en: 'Add this line to `start()` and to `set_lives()`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 将此行添加到`start()`和`set_lives()`中：
- en: '[PRE65]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Hitting a rock will damage the shield, and bigger rocks should do more damage:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 击中岩石会损坏护盾，较大的岩石应该造成更多伤害：
- en: '[PRE66]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The enemy''s bullets should also do damage, so make this change to `EnemyBullet.gd`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人的子弹也应该造成伤害，所以更新`EnemyBullet.gd`中的以下内容：
- en: '[PRE67]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Also, running into the enemy should damage the player, so update this in `Enemy.gd`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，撞到敌人应该会伤害玩家，所以更新`Enemy.gd`中的以下内容：
- en: '[PRE68]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The last addition to the player script is to regenerate the shield each frame.
    Add this line to `_process()`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家脚本中的最后一个添加是每帧再生护盾。将此行添加到`_process()`中：
- en: '[PRE69]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The next step is to add the display element to the `HUD`. Rather than display
    the shield''s value in a `Label`, you''ll use a `TextureProgress` node. This is
    a `Control` node that is a type of `ProgressBar`: a node that displays a given
    value as a filled bar. The `TextureProgress` node allows you to assign a texture
    to be used for the bar''s display.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向`HUD`添加显示元素。而不是在`Label`中显示护盾的值，你将使用`TextureProgress`节点。这是一个`Control`节点，它是一种`ProgressBar`：一个显示给定值的填充条的节点。`TextureProgress`节点允许你为条形显示分配纹理。
- en: 'In the existing `HBoxContainer`, add `TextureRect` and `TextureProgress`. Place
    them after the `ScoreLabel` and before the `LivesCounter`. Change the name of
    the `TextureProgress` to ShieldBar. Your node setup should look like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有的`HBoxContainer`中添加`TextureRect`和`TextureProgress`。将它们放置在`ScoreLabel`之后和`LivesCounter`之前。将`TextureProgress`的名称改为ShieldBar。你的节点设置应该看起来像这样：
- en: '![](img/00105.jpeg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00105.jpeg)'
- en: Drag the `res://assets/shield_gold.png` texture into the *Texture* property
    of `TextureRect`. This will be an icon indicating what the bar is displaying.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 将`res://assets/shield_gold.png`纹理拖动到`TextureRect`的`Texture`属性中。这将是一个图标，表示条形显示的内容。
- en: 'The ShieldBar has three texture properties: Under, Over, and Progress. Progress is
    the texture that will be displayed as the bar''s value. Drag `res://assets/barHorizontal_green_mid
    200.png` into this property. The other two texture properties allow you to customize
    the appearance by setting an image to be drawn below or above the progress texture.
    Drag `res://assets/glassPanel_200.png` into the *Over* texture property.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ShieldBar有三个纹理属性：Under、Over和Progress。Progress是作为条形值显示的纹理。将`res://assets/barHorizontal_green_mid
    200.png`拖动到这个属性中。其他两个纹理属性允许你通过设置图像来自定义外观，该图像将被绘制在进度纹理的下方或上方。将`res://assets/glassPanel_200.png`拖动到`Over`纹理属性中。
- en: In the *Range* section, you can set the numeric properties of the bar. Min Value and
    Max Value should be set to `0` and `100`, as this bar will be showing the percentage
    value of the shield, not its raw value. Value is the property that controls the
    currently displayed fill value. Change it to `75` to see the bar partly filled.
    Also, set its Horizontal size flags to Fill, Expand.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在`范围`部分，你可以设置条形的数值属性。最小值`Min Value`和最大值`Max Value`应设置为`0`和`100`，因为这条条形将显示护盾的百分比值，而不是其原始值。值是控制当前显示填充值的属性。将其更改为`75`以查看条形部分填充。同时，设置其水平大小标志为填充、扩展。
- en: 'Now, you can update the HUD script to control the shield bar. Add these variables
    at the top:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以更新HUD脚本以控制护盾条。在顶部添加以下变量：
- en: '[PRE70]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In addition to the green bar texture, you also have red and yellow bars in
    the `assets` folder. This will allow you to change the shield''s color as the
    value decreases. Loading the textures in this way makes them easier to access
    later in the script when you want to assign the appropriate image to the `TextureProgress`
    node:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 除了绿色的条形纹理外，你还在`assets`文件夹中有红色和黄色的条形。这将允许你随着值的降低改变护盾的颜色。以这种方式加载纹理使得在脚本中稍后更容易访问，当你想要为`TextureProgress`节点分配适当的图像时：
- en: '[PRE71]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Lastly, click on the `Main` scene's `Player` node and connect the `shield_changed`
    signal to the `update_shield()` function you just created. Run the game and verify
    that you can see the shield and that it is working. You may want to increase or
    decrease the regeneration rate to adjust it to a speed you like.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击`Main`场景的`Player`节点，并将`shield_changed`信号连接到你刚刚创建的`update_shield()`函数。运行游戏并验证你是否能看到护盾并且它正在工作。你可能想要增加或减少再生速率以调整到你喜欢的高速。
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to work with `RigidBody2D` nodes and learned
    more about how Godot's physics works. You also implemented a basic Finite State
    Machine—something you'll find more and more useful as your projects grow larger.
    You saw how `Container` nodes help organize and keep UI nodes aligned. Finally,
    you added some sound effects and got your first taste of advanced visual effects
    by using the `AnimationPlayer` and `Particles2D` nodes.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用`RigidBody2D`节点，并更深入地了解了Godot物理的工作原理。你还实现了一个基本的有限状态机——随着你的项目越来越大，你会发现它越来越有用。你看到了`Container`节点如何帮助组织和保持UI节点对齐。最后，你添加了一些音效，并通过使用`AnimationPlayer`和`Particles2D`节点，第一次尝到了高级视觉效果的滋味。
- en: You also created a number of game objects using the standard Godot hierarchies,
    such as `CollisionShapes` being attached to `CollisionObjects`. At this point,
    some of these node configurations should be starting to look familiar to you.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你还使用标准的Godot层次结构创建了许多游戏对象，例如将`CollisionShapes`附加到`CollisionObjects`。在这个阶段，一些这些节点配置应该开始对你来说变得熟悉。
- en: Before moving on, look through the project again. Play it. Make sure you understand
    what each scene is doing, and read through the scripts to review how everything
    connects together.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，再次查看项目。播放它。确保你理解每个场景在做什么，并阅读脚本以回顾一切是如何连接在一起的。
- en: In the next chapter, you'll learn about kinematic bodies, and use them to create
    a side-scrolling platform game.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于运动体，并使用它们来创建一个侧滚动平台游戏。
