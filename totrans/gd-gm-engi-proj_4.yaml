- en: Space Rocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should be getting more comfortable with working in Godot; adding
    nodes, creating scripts, modifying properties in the Inspector, and so on. As
    you progress through this book, you won't be forced to rehash the basics again
    and again. If you find yourself stuck, or feeling like you don't quite remember
    how something is done, feel free to jump back to a previous project where it was
    explained in more detail. As you repeat the more common actions in Godot, they
    will start to feel more and more familiar. At the same time, each chapter will
    introduce you to more nodes and techniques to expand your understanding of Godot's
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next project, you''ll make a space shooter game similar to the arcade
    classic Asteroids. The player will control a ship that can rotate and move in
    any direction. The goal will be to avoid the floating *space rocks* and shoot
    them with the ship''s laser. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will learn about the following key topics in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Physics using `RigidBody2D`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finite State Machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a dynamic, scalable UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound and music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project and download the project assets from [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases).
  prefs: []
  type: TYPE_NORMAL
- en: For this project, you'll set up custom input actions using the Input Map. Using
    this feature, you can define custom events and assign different keys, mouse events,
    or other inputs to them. This allows for more flexibility in designing your game,
    as your code can be written to respond to the `jump` input, for example, without
    needing to know exactly what input the user pressed to make the event happen.
    This allows you to make the same code work on different devices, even if they
    have different hardware. In addition, since many gamers expect to be able to customize
    a game's inputs, this enables you to provide that option to the user as well.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the inputs for this game, open Project | Project Settings and select
    the Input Map tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll need to create four new input actions: `rotate_left`, `rotate_right`,
    `thrust`, and `shoot`. Type the name of each action into the Action box and click
    Add. Then, for each action, click the + button and select the type of input to
    assign. For example, to allow the player to use both the arrow keys and the popular
    WASD alternative, the setup will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have a gamepad or other controller connected to your computer, you can
    also add its inputs to the actions in the same way. Note: we''re only considering
    button-style inputs at this stage, so while you''ll be able to use a d-pad for
    this project, using an analog joystick would require changes to the project''s
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: Rigid body physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In game development, you often need to know when two objects in the game space
    intersect or come into contact. This is known as *collision detection*. When a
    collision is detected, you typically want something to happen. This is known as *collision
    response*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Godot offers three kinds of physics bodies, grouped under the `PhysicsBody2D`
    object type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StaticBody2D`: A static body is one that is not moved by the physics engine.
    It participates in collision detection, but does not move in response to the collision.
    This type of body is most often used for objects that are part of the environment
    or do not need to have any dynamic behavior, such as walls or the ground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RigidBody2D`: This is the physics body in Godot that provides simulated physics.
    This means that you don''t control a `RigidBody2D` directly. Instead, you apply
    forces to it (gravity, impulses, and so on) and Godot''s built-in physics engine
    calculates the resultant movement, including collisions, bouncing, rotating, and
    other effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KinematicBody2D`: This body type provides collision detection, but no physics.
    All movement must be implemented in code, and you must implement any collision
    response yourself. Kinematic bodies are most often used for player characters
    or other actors that require *arcade-style* physics rather than realistic simulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding when to use a particular physics body type is a big part of building
    your game. Using the right node can simplify your development, while trying to
    force the wrong node to do the job can lead to frustration and poor results. As
    you work with each type of body, you'll come to learn their pros and cons and
    get a feel for when they can help build what you need.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you'll be using the `RigidBody2D` node for the player ship
    as well as the *space rocks* themselves. You'll learn about the other body types
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual `RigidBody2D` nodes have many properties you can use to customize
    their behavior, such as `Mass`, `Friction`, or `Bounce`. These properties can
    be set in the Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rigid bodies are also affected by the world''s properties, which can be set
    in the Project Settings under Physics | 2D. These settings apply to all bodies
    in the world. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In most cases, you won't need to modify these settings. However, note that by
    default, gravity has a value of `98` and a direction of `(0, 1)` (downward). If
    you want to change the world gravity, you can do that here. You should also be
    aware of the last two properties, Default Linear Damp and Default Angular Damp.
    These properties control how quickly a body will lose forward speed and rotation
    speed, respectively. Setting them to lower values will make the world feel frictionless,
    while using larger values will feel like your objects are moving through mud.
  prefs: []
  type: TYPE_NORMAL
- en: '`Area2D` nodes can also be used to affect rigid body physics by using the Space
    Override property. Custom gravity and damping values will then be applied to any
    bodies that enter the area.'
  prefs: []
  type: TYPE_NORMAL
- en: Since this game will be taking place in outer space, gravity won't be needed,
    so set Default Gravity to `0`. You can leave the other settings as they are.
  prefs: []
  type: TYPE_NORMAL
- en: Player ship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player ship is the heart of the game. Most of the code you'll write for
    this project will be about making the ship work. It will be controlled in the
    classic Asteroids style, with left/right rotation and forward thrust. It will
    also detect the shoot input to allow the player to fire the laser and destroy
    the floating rocks.
  prefs: []
  type: TYPE_NORMAL
- en: Body setup and physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new scene and add a `RigidBody2D` named `Player` as the root node,
    with `Sprite` and `CollisionShape2D` children. Add the `res://assets/player_ship.png`
    image to the Texture property of the `Sprite`. The ship image is quite large,
    so set the Scale property of the `Sprite` to `(0.5, 0.5)`and its Rotation to `90`.
  prefs: []
  type: TYPE_NORMAL
- en: The image for the ship is drawn pointing upwards. In Godot, a rotation of `0`
    degrees points to the right (along the *x* axis). This means you need to set the
    Rotation of the `Sprite` node to `90` so it will match the body's direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Shape property of `CollisionShape2D`, add a `CircleShape2D` and scale
    it to cover the image as closely as possible (remember not to move the rectangular
    size handles):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Save the scene. When working on larger-scale projects, it is recommended to
    organize your scenes and scripts into folders based on each game object. For example,
    if you make a `player` folder, you can save player-related files there. This makes
    it easier to find and modify your files rather than having them all together in
    a single folder. While this project is relatively small, it's a good habit to
    adopt as your projects grow in size and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: State machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player ship can be in a number of different states during gameplay. For
    example, when *alive,* the ship is visible and can be controlled by the player,
    but is vulnerable to being hit by rocks. On the other hand, when *invulnerable, *the
    ship should appear semi-transparent and immune to damage.
  prefs: []
  type: TYPE_NORMAL
- en: One way that programmers often handle situations like this is to add Boolean
    flag variables to the code. For example, the `invulnerable` flag is set to `true` when
    the player spawns, or when the `alive` flag is set to `false` when the player
    is dead. However, this can lead to errors and strange situations where both the
    `alive` and `invulnerable` flags are set to `true` at the same time. What happens
    when a rock hits the player in this situation? The two states are mutually exclusive,
    so this shouldn't be allowed to happen.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to this problem is to use a **Finite State Machine** (**FSM**).
    When using an FSM, an entity can only be in one state at a given time. To design
    your FSM, you define some number of states and what events or actions can cause
    a transition from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram outlines the FSM for the player ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are four states, and the arrows indicate what transitions are allowed,
    as well as what event triggers the transition. By checking the current state,
    you can decide what the player is allowed to do. For example, in the **DEAD**
    state, don't allow input, or in the **INVULNERABLE** state, don't allow shooting.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced FSM implementations can become quite complex, and the details are beyond
    the scope of this book (see the Appendix for further reading). In the purest sense,
    you technically won't be creating a true FSM, but for the purposes of this project,
    it will be sufficient to illustrate the concept and keep you from running into
    the Boolean flag problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a script to the `Player` node and start by creating the skeleton of the
    FSM implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An `enum` (short for enumeration) is a convenient way to create a set of constants.
    The `enum` statement in the preceding code snippet is equivalent to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also assign a name to an `enum`, which is useful when you have more
    than one collection of constants in a single script. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, this isn't needed in this script, as you'll only be using the one `enum`
    to track the ship's states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the `change_state` function to handle state transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you need to change the state of the player, you'll call the `change_state()` function
    and pass it the value of the new state. Then, by using a `match` statement, you
    can execute whatever code should accompany the transition to the new state. To
    illustrate this, the `CollisionShape2D` is being enabled/disabled by the `new_state`
    value. In `_ready()`, you specify the initial state—currently `ALIVE` so that
    you can test, but you'll change it to `INIT` later.
  prefs: []
  type: TYPE_NORMAL
- en: Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following variables to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`engine_power` and `spin_power` control how fast the ship can accelerate and
    turn. In the Inspector, set them to `500` and `15000`, respectively. `thrust` will
    represent the force being applied by the ship''s engine: either `(0, 0)` when
    coasting, or a vector with the length of `engine_power` when powered on. `rotation_dir`
    will represent what direction the ship is turning in and apply a torque, or rotational
    force.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the physics settings provide some *damping*, which reduces a body's
    velocity and spin. In space, there's no friction, so for realism there shouldn't
    be any damping at all. However, for an arcade-style feel, it's preferable that
    the ship should stop when you let go of the keys. In the Inspector, set the player's
    Linear/Damp to `1` and its Angular/Damp to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to detect the input and move the ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `get_input()` function captures the key actions and sets the ship's thrust
    on or off, and the rotation direction (`rotation_dir`) to a positive or negative
    value (representing clockwise or counter-clockwise rotation). This function is
    called every frame in `_process()`. Note that if the state is `INIT` or `DEAD`,
    `get_input()` will exit by using `return` before checking for key actions.
  prefs: []
  type: TYPE_NORMAL
- en: When using physics bodies, their movement and related functions should be called
    in `_physics_process()`. Here, you can use `set_applied_force()` to apply the
    engine thrust in whatever direction the ship is facing. Then, you can use `set_applied_torque()`
    to cause the ship to rotate.
  prefs: []
  type: TYPE_NORMAL
- en: Play the scene and you should be able to fly around freely.
  prefs: []
  type: TYPE_NORMAL
- en: Screen wrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another feature of classic 2D arcade games is *screen wrap*. If the player
    goes off one side of the screen, they *appear* on the other side. In practice,
    you teleport or instantaneously change the ship''s position to the opposite side.
    Add the following to the class variables at the top of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And add this to `_ready()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Later, the game's main script will handle setting `screensize` for all of the
    game's objects, but for now, this will allow you to test the screen wrapping with
    just the player scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'When first approaching this problem, you might think you could use the body''s
    `position` property and, if it exceeds the bounds of the screen, set it to the
    opposite side. However, when using `RigidBody2D`, you can''t directly set its
    `position`, because that would conflict with the movement that the physics engine
    is calculating. A common mistake is to try adding something like this to `_physics_process()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will fail, trapping the player on the edge of the screen (and occasionally
    *glitching* unpredictably at the corners). So, why doesn't this work? The Godot
    documentation recommends `_physics_process()` for physics-related code—it even
    has *physics* in the name. It makes sense at first glance that this should work
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the correct way to solve this problem is *not* to use `_physics_process()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To quote the `RigidBody2D` docs:'
  prefs: []
  type: TYPE_NORMAL
- en: '"You should not change a RigidBody2D''s position or linear_velocity every frame
    or even very often. If you need to directly affect the body''s state, use _integrate_forces,
    which allows you to directly access the physics state."'
  prefs: []
  type: TYPE_NORMAL
- en: 'And in the description for `_integrate_forces()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '"(It) Allows you to read and safely modify the simulation state for the object.
    Use this instead of _physics_process if you need to directly change the body''s
    position or other physics properties. (emphasis added)"'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is to change the physics callback to `_integrate_forces()`, which
    gives you access to the body's `Physics2DDirectBodyState`. This is a Godot object
    containing a great deal of useful information about the current physics state
    of the body. In the case of location, the key piece of information is the body's
    `Transform2D`.
  prefs: []
  type: TYPE_NORMAL
- en: A *transform* is a matrix representing one or more transformations in 2D space
    such as translation, rotation, and/or scaling. The translation (that is, position)
    information is found by accessing the `origin` property of the `Transform2D`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this information, you can implement the wrap around effect by changing
    `_physics_process()` to `_integrate_forces()` and altering the transform''s origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the function''s argument name has been changed to `physics_state`
    from its default: `state`. This is to prevent any possible confusion with the
    already existing `state` variable, which tracks what FSM state the player is currently
    assigned to.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the scene again and check that everything is working as expected. Make sure
    you try wrapping around in all four directions. A common mistake is to accidentally
    flip a greater-than or less-than sign, so check that first if you're having a
    problem with one or more screen edges.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to give your ship some weapons. When pressing the `shoot` action,
    a bullet should be spawned at the front of the ship and travel in a straight line
    until it exits the screen. Then, the gun isn't allowed to fire again until a small
    amount of time has passed.
  prefs: []
  type: TYPE_NORMAL
- en: Bullet scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the node setup for the bullet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Area2D` (named `Bullet`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sprite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollisionShape2D`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VisibilityNotifier2D`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `res://assets/laser.png` from the assets folder for the texture of the `Sprite`,
    and a `CapsuleShape2D` for the collision shape. You'll have to set the Rotation of
    the `CollisionShape2D` to `90` so that it will fit correctly. You should also
    scale the `Sprite` down to half size (`(0.5, 0.5)`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following script to the `Bullet` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Set the exported `speed` property to `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VisibilityNotifier2D` is a node that can inform you (using signals) whenever
    a node becomes visible/invisible. You can use this to automatically delete a bullet
    when it goes off screen. Connect the `screen_exited` signal of `VisibilityNotifier2D`
    and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, connect the bullet''s `body_entered` signal so that you can detect
    when the bullet hits a rock. The bullet doesn''t need to *know* anything about
    rocks, just that it has hit something. When you create the rocks, you''ll add
    them to a group called `rocks` and give them an `explode()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Firing bullets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you need instances of the bullet to be created whenever the player fires.
    However, if you make the bullet a child of the player, then it will move and rotate
    along with the player instead of moving independently. Instead, the bullet should
    be added as a child of the main scene. One way to do this would be to use `get_parent().add_child()`,
    since the `Main` scene will be the parent of the player when the game is running.
    However, this would mean you could no longer run the `Player` scene by itself
    like you have been doing, because `get_parent()` would produce an error. Or, if
    in the `Main` scene you decided to arrange things differently, making the player
    a child of some other node, the bullet wouldn't be added where you expect.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is a bad idea to write code that assumes a fixed tree layout.
    Especially try to avoid using `get_parent()` if at all possible. You may find
    it difficult to think this way at first, but it will result in a much more modular
    design and prevent some common mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the player will *give* the bullet to the main scene using a signal.
    In this way, the `Player` scene doesn't need to *know* anything about how the
    `Main` scene is set up, or even if the `Main` scene exists. Producing the bullet
    and handing it off is the `Player` object's only responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Position2D` node to the player and name it `Muzzle`. This will mark the
    *muzzle* of the gun—the location where the bullet will spawn. Set its Position to
    `(50, 0)` to place it directly in front of the ship.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a `Timer` node named `GunTimer`. This will provide a *cooldown* to
    the gun, preventing a new bullet from firing until a certain amount of time has
    passed. Check the One Shot and Autoplay boxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these new variables to the player''s script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Drag the `Bullet.tscn` onto the new Bullet property in the Inspector, and set
    the Fire Rate to `0.25` (this value is in seconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this to `_ready()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And this to `get_input()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the `shoot()` function, which will handle creating the bullet(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When emitting the `shoot` signal, you pass the `Bullet` itself plus its starting
    position and direction. Then, you disable shooting with the `can_shoot` flag and
    start the `GunTimer`. To allow the gun to shoot again, connect the `timeout` signal
    of the `GunTimer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, make your Main scene. Add a `Node` named `Main` and a `Sprite` named `Background`.
    Use `res://assets/space_background.png` as the Texture*.* Add an instance of the
    `Player` to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a script to `Main`, then connect the `Player` node''s `shoot` signal, and
    add the following to the created function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Play the `Main` scene and test that you can fly and shoot.
  prefs: []
  type: TYPE_NORMAL
- en: Rocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the game is to destroy the floating space rocks, so, now that you
    can shoot, it's time to add them. Like the ship, the rocks will also be `RigidBody2D`,
    which will make them travel in a straight line at a steady speed unless disturbed.
    They'll also bounce off each other in a realistic fashion. To make things more
    interesting, rocks will start out large and, when you shoot them, break into multiple
    smaller rocks.
  prefs: []
  type: TYPE_NORMAL
- en: Scene setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start a new scene by making a `RigidBody2D`, naming it `Rock`, and adding a
    `Sprite` using the `res://assets/rock.png` texture. Add a `CollisionShape2D`,
    but *don't* add a shape to it yet. Because you'll be spawning different-sized
    rocks, the collision shape will need to be set in the code and adjusted to the
    correct size.
  prefs: []
  type: TYPE_NORMAL
- en: Set the Bounce property of the `Rock` to `1` and both Linear/Damp and Angular/Damp
    to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Variable size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attach a script and define the member variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Main` script will handle spawning new rocks, both at the beginning of a
    level as well as the smaller rocks that will appear after a large one explodes.
    A large rock will have a `size` of `3` and break into rocks of size `2`, and so
    on. The `scale_factor` is multiplied by `size` to set the sprite's scale, the
    collision radius, and so on. You can adjust it later to change how big each category
    of rock is.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this will be set by the `start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here is where you calculate the correct collision shape based on the rock's
    `size` and add it to the `CollisionShape2D`. Note that since `size` is already
    in use as a class variable, you can use `_size` for the function argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rocks also need to wrap around the screen, so use the same technique you
    used for the `Player`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The difference here is that including the body's `radius` results in smoother-looking
    teleportation. The rock will appear to fully exit the screen before entering at
    the opposite side. You may want to do the same thing with the player ship. Try
    it and see which effect you like better.
  prefs: []
  type: TYPE_NORMAL
- en: Instancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When new rocks are spawned, the main scene will need to pick a random start
    location. To do this, you could use some geometry to pick a random point along
    the perimeter of the screen, but instead you can take advantage of yet another
    Godot node type. You''ll draw a path around the edge of the screen, and the script
    will pick a random location along the path. Add a `Path2D` node and name it `RockPath`.
    When you click on the `Path2D`, you will see some new buttons appear at the top
    of the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00083.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the middle one (Add Point) to draw the path by clicking to add the points
    shown. To make the points align, make sure Snap to grid is checked. This option
    is found under the Snapping Options button to the left of the `Lock` button. It
    appears as a series of three vertical dots. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Draw the points in the order shown in the following screenshot. After clicking
    the fourth point, click the Close Curve button (**5**) and your path will be complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that the path is defined, add a `PathFollow2D` node as a child of `RockPath`
    and name it `RockSpawn`. This node's purpose is to automatically follow a path
    as it moves, using its `set_offset()` method. The higher the offset, the further
    along the path it goes. Since our path is closed, it will loop around if the offset
    value is bigger than the path's length.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a `Node` and name it `Rocks`. This node will serve as a container
    to hold all the rocks. By checking its number of children, you can tell if there
    are any rocks remaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add this to `Main.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The script starts by getting the `screensize` and passing that to the `Player`.
    Then, it spawns three rocks of size `3` using `spawn_rock()`, which is defined
    in the following code. Don''t forget to drag `Rock.tscn` onto the Rock property
    in the Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function will serve two purposes. When called with only a size parameter,
    it picks a random position along the `RockPath` and a random velocity. However,
    if those values are also provided, it will use them instead. This will let you
    spawn the smaller rocks at the location of the explosion.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and you should see three rocks floating around. However, your bullets
    don't affect them.
  prefs: []
  type: TYPE_NORMAL
- en: Exploding rocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Bullet` is checking for bodies in the `rocks` group, so in the `Rock`
    scene, click on the Node tab and choose Groups. Type `rocks` and click Add:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you run the game and shoot a rock, you''ll see an error message because
    the bullet is trying to call the rock''s `explode()` method, which you haven''t
    defined yet. This method needs to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the rock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play an explosion animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notify `Main` to spawn new, smaller rocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explosion scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The explosion will be a separate scene, which you can add to the `Rock` and
    later to the `Player`. It will contain two nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sprite` (named `Explosion`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnimationPlayer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the sprite's Texture, use `res://assets/explosion.png`. You'll notice that
    this is a sprite sheet—an image made up of 64 smaller images laid out in a grid
    pattern. These images are the individual frames of the animation. You'll often
    find animations packaged this way, and Godot's `Sprite` node supports using them
    as individual frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Inspector, find the sprite''s Animation section. Set the Vframes and
    Hframes both to `8`. This will *slice* the sprite sheet into its individual images.
    You can verify this by changing the Frame property to different values between
    `0` and `63`. Make sure to set Frames back to `0` when finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `AnimationPlayer` can be used to animate any property of any node. You''ll
    use the `AnimationPlayer` to change the Frame property over time. Start by clicking
    on the node and you''ll see the Animation panel open at the bottom, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click the New Animation button and name it `explosion`. Set the Length to `0.64` and
    the Step to `0.01`. Now, click on the `Sprite` node and you'll notice that each
    property in the Inspector now has a key button next to it. Each time you click
    on the key, you create a keyframe in the current animation. The key button next
    to the Frame property also has a `+` symbol on it, indicating that it will automatically
    increment the value when you add a key frame.
  prefs: []
  type: TYPE_NORMAL
- en: Click the key and confirm that you want to create a new animation track. Note
    that the Frame property has incremented to `1`. Click the key button repeatedly
    until you have reached the final frame (`63`).
  prefs: []
  type: TYPE_NORMAL
- en: Click the Play button in the Animation panel to see the animation being played.
  prefs: []
  type: TYPE_NORMAL
- en: Adding to Rock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `Rock` scene, add an instance of `Explosion` and add this line to `start()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that the explosion is scaled to match the rock's size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a signal called `exploded` at the top of the script, then add the `explode()` function,
    which will be called when the bullet hits the rock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `layers` property ensures that the explosion will be drawn on top of the
    other sprites on the screen. Then, you will send a signal that will let `Main`
    know to spawn new rocks. This signal also needs to pass the necessary data so
    that the new rocks will have the right properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the animation finishes playing, the `AnimationPlayer` will emit a signal.
    To connect it, you need to make the `AnimationPlayer` node visible. Right-click
    on the instanced Explosion and select Editable Children, then select the `AnimationPlayer`
    and connect its `animation_finished` signal. Make sure to select the `Rock` in
    the Connect to Node section. The end of the animation means it is safe to delete
    the rock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, test the game and check that you can see explosions when you shoot the
    rocks. At this point, your rock scene should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Spawning smaller rocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Rock` is emitting the signal, but it needs to be connected in `Main`.
    You can''t use the Node tab to connect it, because the `Rock` instances are being
    created in code. Signals can be connected in code as well. Add this line to the
    end of `spawn_rock()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This connects the rock''s signal to a function in `Main` called `_on_Rock_exploded()`.
    Create that function, which will be called whenever a rock sends its `exploded`
    signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, two new rocks are created unless the rock that was just destroyed
    was the smallest size it can be. The `offset` loop variable will ensure that they
    spawn and travel in opposite directions (that is, one will be the negative of
    the other). The `dir` variable finds the vector between the player and the rock,
    then uses `tangent()` to find the perpendicular to that vector. This ensures that
    the new rocks travel away from the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Play the game once again and check that everything is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a game UI can be very complex, or at least time-consuming. Precisely
    placing individual elements and ensuring they work on different-sized screens
    and devices is the least interesting part of game development for many programmers.
    Godot provides a wide variety of Control nodes to assist in this process. Learning
    how to use the various Control nodes will help lessen the pain of creating your
    game's UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this game, you don''t need a very complex UI. The game needs to provide
    the following information and interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: Start button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status message (Get Ready or Game Over)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lives counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a preview of what you will be able to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new scene, and add a `CanvasLayer` with the name `HUD` as its root
    node. The UI will be built on this layer by using Godot's `Control` Layout features.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Godot's `Control` nodes include a number of specialized containers. These nodes
    can be nested inside each other to create the precise layout you need. For example,
    a `MarginContainer` will automatically add padding around its contents, while
    `HBoxContainer` and `VBoxContainer` organize their contents in rows or columns,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Start by adding a `MarginContainer`, which will hold the score and lives counter.
    Under the Layout menu, select Top Wide. Then, scroll down to the Custom Constants
    section and set all four margins to `20`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add an `HBoxContainer`, which will hold the score counter on the left
    and the lives counter on the right. Under this container, add a `Label` (name
    it `ScoreLabel`) and another `HBoxContainer` (name it `LivesCounter`).
  prefs: []
  type: TYPE_NORMAL
- en: Set the `ScoreLabel` Text to `0` and, under `Size Flags`, set Horizontal to
    Fill, Expand. Under Custom Fonts, add a `DynamicFont` like you did in [Chapter
    1](part0022.html#KVCC0-5809b3bef8d2453086d97dfad17b2ee2), *Introduction*, using
    `res://assets/kenvector_future_thin.ttf` from the `assets` folder and setting
    the size to `64`.
  prefs: []
  type: TYPE_NORMAL
- en: Under the `LivesCounter`, add a `TextureRect` and name it `L1`. Drag `res://assets/player_small.png`
    into the Texture property and set the Stretch Mode to Keep Aspect Centered. Make
    sure you have the `L1` node selected and press Duplicate (*Ctrl* + *D*) two times
    to create `L2` and `L3` (they'll be named automatically). During the game, the
    `HUD` will show/hide these three textures to indicate how many lives the user
    has left.
  prefs: []
  type: TYPE_NORMAL
- en: In a larger, more complicated UI, you could save this section as its own scene
    and embed it in other sections of the UI. However, this game only needs a few
    more pieces for its UI, so it's fine to combine them all in one scene.
  prefs: []
  type: TYPE_NORMAL
- en: As a child of the `HUD` node, add a `TextureButton` (named `StartButton`), a
    `Label` (named `MessageLabel`), and a `Timer` (named `MessageTimer`).
  prefs: []
  type: TYPE_NORMAL
- en: In the `res://assets` folder, there are two textures for the `StartButton`,
    one normal (`play_button.png`) and one to show when the mouse is hovering over
    it (`play_button_h.png`). Drag these to the Textures/Normal and Textures/Hover
    properties, respectively. In the Layout menu, choose Center.
  prefs: []
  type: TYPE_NORMAL
- en: For the `MessageLabel`, make sure you set the font first before specifying the
    layout, or it won't be centered properly. You can use the same settings you used
    for the `ScoreLabel`. After setting the font, set the layout to Full Rect.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, set the One Shot property of `MessageTimer` to On and its Wait Time
    to `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When finished, your UI''s scene tree should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: UI functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve completed the UI layout, so now let''s add a script to `HUD` so you
    can add the functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `start_game` signal will be emitted when the player clicks the `StartButton`.
    The `lives_counter` variable is an array holding references to the three life
    counter images. The names are fairly long, so make sure to let the editor's autocomplete
    fill them in for you to avoid mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need functions to handle updating the displayed information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Each function will be called when a value changes to update the display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a function to handle the `Game Over` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, connect the `pressed` signal of the `StartButton` so that it can emit
    the signal to `Main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, connect the `timeout` signal of `MessageTimer` so that it can hide
    the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Main scene code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, you can add an instance of the `HUD` to the `Main` scene. Add the following
    variables to `Main.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'These will track the named quantities. The following code will handle starting
    a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: First, you need to make sure that you remove any existing rocks that are left
    over from the previous game and initialize the variables. Don't worry about the
    `start()` function on the player; you'll add that soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'After showing the `"Get Ready!"` message, you will use `yield` to wait for
    the message to disappear before actually starting the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This function will be called every time the level changes. It announces the
    level number and spawns a number of rocks to match. Note—since you initialized
    `level` to `0,` this will set it to `1` for the first level.
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect whether the level has ended, you continually check how many children
    the `Rocks` node has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, you need to connect the HUD's `start_game` signal (emitted when the Play
    button is pressed) to the `new_game()` function. Select the `HUD`, click on the
    Node tab, and connect the `start_game` signal. Set Make Function to Off and type
    `new_game` in the Method In Node field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following function to handle what happens when the game ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Play the game and check that pressing the Play button starts the game. Note
    that the `Player` is currently stuck in the `INIT` state, so you can't fly around
    yet—the `Player` doesn't know the game has started.
  prefs: []
  type: TYPE_NORMAL
- en: Player code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new signal and a new variable to `Player.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setget` statement in GDScript allows you to specify a function that will
    be called whenever the value of a given variable is changed. This means that when
    `lives` decreases, you can emit a signal to let the `HUD` know it needs to update
    the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `start()` function is called by `Main` when a new game starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When using `setget`, if you access the variable locally (in the local script),
    you must put `self.` in front of the variable name. If you don't, the `setget`
    function will not be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to connect this signal from the `Player` to the `update_lives`
    method in the `HUD`. In `Main`, click on the `Player` instance and find its `lives_changed` signal
    in the Node tab. Click Connect, and in the connection window, under Connect to
    Node, choose the `HUD`. For Method In Node, type `update_lives`. Make sure you
    have Make Function off, and click Connect, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Game over
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll make the player detect when it is hit by rocks, add
    an invulnerability feature, and end the game when the player runs out of lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an instance of the `Explosion` to the `Player`, as well as a `Timer` node
    (named `InvulnerabilityTimer`). In the Inspector, set the Wait Time of `InvulnerabilityTimer`
    to `2` and its One Shot to On. Add this to the top of `Player.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This signal will notify the `Main` scene that the player has run out of lives
    and the game is over. Before that, however, you need to update the state machine
    to do a little more with each state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `modulate.a` property of a sprite sets its alpha channel (transparency).
    Setting it to `0.5` makes it semi-transparent, while `1.0` is solid.
  prefs: []
  type: TYPE_NORMAL
- en: 'After entering the `INVULNERABLE` state, you start the `InvulnerabilityTimer`.
    Connect its `timeout` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, connect the `animation_finished` signal from the `Explosion` animation
    like you did in the `Rock` scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Detecting collisions between physics bodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you fly around, the player ship bounces off the rocks, because both bodies
    are `RigidBody2D` nodes. However, if you want to make something happen when two
    rigid bodies collide, you need to enable contact monitoring. Select the `Player`
    node and in the Inspector, set Contact Monitoring to On. By default, no contacts
    are reported, so you must also set Contacts Reported to `1`. Now, the body will
    emit a signal when it contacts another body. Click on the Node tab and connect
    the `body_entered` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, go to the `Main` scene and connect the Player's `dead` signal to the `game_over()`
    function. Play the game and try running into a rock. Your ship should explode,
    become invulnerable (for two seconds), and lose one life. Check that the game
    ends if you get hit three times.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many games require some sort of pause mode to allow the player to take a break
    in the action. In Godot, pausing is a function of the scene tree and can be set
    using `get_tree().paused = true`. When the `SceneTree` is paused, three things
    happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The physics thread stops running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_process` and `_physics_process` are no longer called, so no code in those
    methods is run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_input` and `_input_event` are also not called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the pause mode is triggered, every node in the running game can react accordingly,
    based on how you've configured it. This behavior is set via the node's Pause/Mode
    property, which you'll find all the way at the bottom of the Inspector list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pause mode can be set to three values: `INHERIT` (the default value), `STOP`,
    and `PROCESS`. `STOP` means the node will cease processing while the tree is paused,
    while `PROCESS` sets the node to continue running, ignoring the paused state of
    the tree. Because it would be very tedious to set this property on every node
    in the whole game, `INHERIT` lets the node use the same pause mode as its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Input Map tab (in Project Settings) and create a new input action called
    `pause`. Choose a key you'd like to use to toggle pause mode; for example, P is
    a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following function to `Main.gd` to respond to the input action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you ran the game now, you''d have a problem—all nodes are paused, including
    `Main`. This means that since it isn''t processing `_input`, it can''t detect
    the input again to unpause the game! To fix this, you need to set the Pause/Mode of
    `Main` to `PROCESS`. Now, you have the opposite problem: all the nodes below `Main`
    inherit this setting. This is fine for most of the nodes, but you need to set
    the mode to `STOP` on these three nodes: `Player`, `Rocks`, and `HUD`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Space is filled with more dangers than just rocks. In this section, you'll create
    an enemy spaceship that will periodically appear and shoot at the player.
  prefs: []
  type: TYPE_NORMAL
- en: Following a path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the enemy appears, it should follow a path across the screen. To keep it
    from looking too repetitive, you can create multiple paths and randomly choose
    one when the enemy starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new scene and add a `Node`. Name it `EnemyPaths` and save the scene.
    To draw the path, add a `Path2D` node. As you saw earlier, this node allows you
    to draw a series of connected points. When you add the node, a new menu bar appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These buttons let you draw and modify the path''s points. Click the one with
    the + symbol to add points. Click to start the path somewhere just outside the
    game window (the bluish-purple rectangle), and then click a few more points to
    create a curve. Don''t worry about making it smooth just yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the enemy ship follows the path, it will not look very smooth when it
    hits the sharp corners. To smooth the curve, click the second button in the path
    toolbar (its tooltip says Select Control Points). Now, if you click and drag any
    of the curve''s points, you will add a control point that allows you to angle
    and curve the line. Smoothing the preceding line results in something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a few more `Path2D` nodes to the scene and draw the paths however you like.
    Adding loops and curves rather than straight lines will make the enemy look more
    dynamic (and make it harder to hit). Remember that the first point you click will
    be the start of the path, so make sure to place them on different sides of the
    screen, for variety. Here are three example paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Save the scene. You'll add this to the enemy's scene to give it the paths it
    can follow.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new scene for the Enemy, using an `Area2D` as its root node. Add a
    `Sprite` and use `res://assets/enemy_saucer.png` as its Texture. Set the Animation/HFrames to
    `3` so that you can choose between the different-colored ships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you''ve done before, add a `CollisionShape2D` and give it a `CircleShape2D`
    scaled to cover the sprite image. Next, add an instance of the `EnemyPaths` scene
    and an `AnimationPlayer`. In the `AnimationPlayer`, you''ll need two animations:
    one to make the saucer spin as it moves, and the other to create a flash effect
    when the saucer is hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rotate animation**: Add a new animation named `rotate` and set its *Length* to
    `3`. Add a keyframe for the `Sprite` Transform/Rotation Degrees property after
    setting it to `0`, then drag the play bar to the end and add a keyframe with the
    rotation set to `360`. Click the Loop button and the Autoplay button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hit animation**: Add a second animation named `flash`. Set its *Length* to
    `0.25` and the *Step* to `0.01`. The property you''ll be animating is the Sprite''s
    Modulate (found under *Visibility*). Add a keyframe for Modulate to create the
    track, then move the scrubber to `0.04` and change the Modulate color to red.
    Move forward another `0.04` and change the color back to white.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat this process two more times so that you have three flashes in total.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an instance of the `Explosion` scene as you did with the other objects.
    Also, like you did with the rocks, connect the explosion''s `AnimationPlayer` `animation_finished`
    signal and set it to delete the enemy when the explosion finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Next, add a `Timer` node called `GunTimer` that will control how often the enemy
    shoots at the player. Set its Wait Time to `1.5` and Autostart to `On`. Connect
    its `timeout` signal, but leave the code reading `pass` for now.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, click on the `Area2D` and the Node tab and add it to a group called
    `enemies`. As with the rocks, this will give you a way to identify the object,
    even if there are multiple enemies on the screen at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the Enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attach a script to the `Enemy` scene. To begin, you''ll make the code that
    will select a path and move the enemy along it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: A `PathFollow2D` node is one that can automatically move along a parent `Path2D`.
    By default, it is set to loop around the path, so you need to manually set the
    property to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to move along the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can detect the end of the path when `offset` is greater than the total path
    length. However, it's more straightforward to use `unit_offset`, which varies
    from zero to one over the length of the path.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `Main` scene and add a `Timer` node called `EnemyTimer`. Set its One
    Shot property to `On`. Then, in `Main.gd`, add a variable to reference your enemy
    scene (drag it into the Inspector after saving the script):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to `new_level()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect the `EnemyTimer` `timeout` signal, and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This code instances the enemy whenever the `EnemyTimer` times out. When you
    add shooting to the enemy, it will use the same process you used for the `Player`,
    so you can reuse the same bullet-spawning function, which is `_on_Player_shoot()`.
  prefs: []
  type: TYPE_NORMAL
- en: Play the game, and you should see a flying saucer appear that will fly along
    one of your paths.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy shooting and collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The enemy needs to shoot at the player as well as react when hit by the player
    or the player's bullets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Bullet` scene and choose Save Scene As to save it as `EnemyBullet.tscn`
    (afterwards, don''t forget to rename the root node as well). Remove the script
    by selecting the root node and clicking the Clear the script button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You also need to disconnect the signal connections by clicking the Node tab
    and choosing Disconnect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There is also a different texture in the `assets` folder you can use to make
    the enemy bullet appear distinct from the player's.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script will be very much the same as the regular bullet. Connect the area''s
    `body_entered` signal and the `screen_exited` signal of `VisibilityNotifier2D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: For now, the bullet won't do any damage to the player. You'll be adding a shield
    to the player in the next section, so you can add that at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Save the scene and drag it into the Bullet property on the `Enemy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Enemy.gd`, add the `shoot` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: First, you must find the vector pointing to the player's position, then add
    a little bit of randomness to it so that the bullets don't follow exactly the
    same path.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an extra challenge, you can make the enemy shoot in *pulses*, or multiple
    rapid shots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This function creates a given number of bullets with `delay` time between them.
    You can use this whenever the `GunTimer` triggers a shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This will shoot a pulse of `3` bullets with `0.15` seconds between them. Tough
    to dodge!
  prefs: []
  type: TYPE_NORMAL
- en: Next, the enemy needs to take damage when it's hit by a shot from the player.
    It will flash using the animation you made, and then explode when its health reaches
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these functions to `Enemy.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, connect the area''s `body_entered` signal so the enemy will explode if
    the player runs into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Again, you're waiting for the player shield to add the damage to the player,
    so leave the `pass` placeholder there for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, the player''s bullet is only detecting physics bodies because its `body_entered` signal
    is connected. However, the enemy is an `Area2D`, so it will not trigger that signal.
    To detect the enemy, you need to also connect the  `area_entered` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Try playing the game again and you'll be doing battle with an aggressive alien
    opponent! Verify that all the collision combinations are being handled. Also note
    that the enemy's bullets can be blocked by rocks—maybe you can hide behind them
    for cover!
  prefs: []
  type: TYPE_NORMAL
- en: Additional features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The structure of the game is complete. You can start the game, play it through,
    and when it ends, play again. In this section, you''ll add some additional effects
    and features to the game to improve the gameplay experience. Effects is a broad
    term and can mean many different techniques, but in this case, you''ll specifically
    address three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sound effects and music: **Audio is very often overlooked, but can be a very
    effective part of game design. Good sound improves the *feel* of the game. Bad
    or annoying sounds can create boredom or frustration. You''ll add some action-packed
    background music, and some sound effects for several actions in the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Particles: **Particle effects are images, usually small, that are generated
    in large numbers and animated by a particle system. They can be used for a countless
    number of impressive visual effects. Godot''s particle system is quite powerful;
    too powerful to fully explore here, but you''ll learn enough to get started experimenting
    with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player shield: **If you''re finding the game too hard, especially on higher
    levels where there are a lot of rocks, adding a shield to the player will greatly
    increase your chances of survival. You can also make larger rocks do more damage
    to the shield than smaller ones. You''ll also make a nice display bar on the HUD
    to show the player''s remaining shield level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound/music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `res://assets/sounds` folder are several audio files containing different
    sounds in the OggVorbis format. By default, Godot sets `.ogg` files to loop when
    imported. In the case of `explosion.ogg`, `laser_blast.ogg`, and `levelup.ogg`,
    you don''t want the sounds to loop, so you need to change the import settings
    for those files. To do this, select the file in the FileSystem dock, and then
    click the Import tab located next to the Scene tab on the right-hand side of the
    editor window. Uncheck the box next to Loop and click Reimport. Do this for each
    of the three sounds. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To play a sound, it needs to be loaded by an `AudioStreamPlayer` node. Add
    two of these nodes to the `Player` scene, naming them `LaserSound` and `EngineSound`.
    Drag the respective sound into each node''s Stream property in the Inspector.
    To play the sound when shooting, add the following line to `shoot()` in `Player.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Play the game and try shooting. If you find the sound a bit too loud, you can
    adjust the Volume Db property. Try a value of `-10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The engine sound works a little differently. It needs to play when the thrust
    is on, but if you try to just `play()` the sound in the `get_input()` function,
    it will restart the sound every frame as long as you have the input pressed. This
    doesn''t sound good, so you only want to start playing the sound if it isn''t
    already playing. Here is the relevant section from the `get_input()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note that a problem can occur—if the player dies while holding down the thrust
    key, the engine sound will remain stuck on. This can be solved by adding `$EngineSound.stop()` to
    the `DEAD` state in `change_state()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Main` scene, add three more `AudioStreamPlayer` nodes: `ExplodeSound`,
    `LevelupSound`, and `Music`. In their Stream properties, drop `explosion.ogg`,
    `levelup.ogg`, and `Funky-Gameplay_Looping.ogg`.'
  prefs: []
  type: TYPE_NORMAL
- en: Add `$ExplodeSound.play()` as the first line of `_on_Rock_exploded()`, and add
    `$LevelupSound.play()` to `new_level()`.
  prefs: []
  type: TYPE_NORMAL
- en: To start/stop the music, add `$Music.play()` to `new_game()` and `$Music.stop()`
    to `game_over()`.
  prefs: []
  type: TYPE_NORMAL
- en: The Enemy also needs an `ExplodeSound` and a `ShootSound`. You can use the same
    explosion as the player, but there is an `enemy_laser.wav` sound to use for the
    shot.
  prefs: []
  type: TYPE_NORMAL
- en: Particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player ship's thrust is a perfect use for particles, creating a streaming
    flame from the engine. Add a `Particles2D` node to the `Player` scene and name
    it `Exhaust`. You might want to zoom in on the ship image while you're doing this
    part.
  prefs: []
  type: TYPE_NORMAL
- en: 'When first created, the `Particles2D` node has a warning: *A material to process
    the particles is not assigned*. Particles will not be emitted until you assign
    a `Process Material` in the Inspector. Two types of materials are possible: `ShaderMaterial`
    and `ParticlesMaterial`. `ShaderMaterial` allows you to write shader code in a
    GLSL-like language, while `ParticlesMaterial` is configured in the Inspector.
    Next to Particles Material, click the down-arrow and choose New ParticlesMaterial.'
  prefs: []
  type: TYPE_NORMAL
- en: You'll see a line of white dots streaming down from the center of the player
    ship. Your challenge now is to turn those into an exhaust flame.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a very large number of properties to choose from when configuring
    particles, especially under `ParticlesMaterial`. Before starting on that, set
    these properties of the `Particles2D`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Amount: `25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform/Position*: *`(-28, 0)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transform/Rotation: `180`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visibility/Show Behind Parent: `On`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, click on the `ParticlesMaterial`. This is where you'll find the majority
    of the properties that affect the particles' behavior. Start with Emission Shape—change
    it to Box. This will reveal Box Extents, which should be set to `(1, 5, 1)`. Now,
    the particles are emitted over a small area instead of a single point.
  prefs: []
  type: TYPE_NORMAL
- en: Next, set Spread/Spread to `0` and Gravity/Gravity to `(0, 0, 0)`. Now, the
    particles aren't falling or spreading out, but they are moving very slowly.
  prefs: []
  type: TYPE_NORMAL
- en: The next property is Initial Velocity. Set Velocity to `400`. Then, scroll down
    to Scale and set it to `8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the size change over time, you can set a Scale Curve. Click on New
    CurveTexture and click on it. A new panel labeled Curve will appear. The left-hand
    dot represents the starting scale, and the right-hand dot represents the end.
    Drag the right-hand dot down until your curve looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the particles are shrinking as they age. Click the left arrow at the top
    of the Inspector to go back to the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final section to adjust is Color. To make the particles appear like a flame,
    the particles should start out a bright orange-yellow and shift to red while fading
    out. In the Color Ramp property, click on New GradientTexture. Then, in the Gradient
    property, choose New Gradient:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The sliders labeled 1 and 2 select the starting and ending colors, while 3 shows
    what color is set on the currently selected slider. Click on slider 1 and then
    click 3 to choose an orange color, then click on slider 2 and set it to a deep
    red.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can see what the particles are doing, they are lasting far too long.
    Go back to the `Exhaust` node and change the Lifetime to `0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, your ship's exhaust looks somewhat like a flame. If it doesn't, feel
    free to adjust the `ParticlesMaterial` properties until you are happy with it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the ship's `Exhaust` is configured, it needs to be turned on/off based
    on the player input. Go to the player script and add `$Exhaust.emitting = false`
    at the beginning of `get_input()`. Then, add `$Exhaust.emitting = true` under
    the `if` statement that checks for thrust input.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy trail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also use particles to make a trail effect behind the enemy. Add a `Particles2D`
    to the enemy scene and set the properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Amount: `20`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Local Coords: `Off`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Texture: `res://assets/corona.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Show Behind Parent: `On`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the effect texture you're using is white on a black background. This
    image needs its blend mode changed. To do this, on the particle node, find the
    Material property (it is in the `CanvasItem` section). Select New CanvasItemMaterial
    and, in the resulting material, change the Blend Mode to `Add`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a `ParticlesMaterial` like you did previously, and use these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Emission Shape:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shape: Box'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Box Extents: (`25`, `25`, `1`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spread: `25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gravity: (0, 0, 0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, create a `ScaleCurve` like you did for the player exhaust. This time,
    make the curve look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Try running the game and see how it looks. Feel free to tinker with the settings
    until you have something you like.
  prefs: []
  type: TYPE_NORMAL
- en: Player shield
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll add a shield to the player and a display element to
    the `HUD` showing the current shield level.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following to the top of the `Player.gd` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `shield` variable will work similarly to `lives`, emitting a signal to the
    `HUD` whenever it changes. Save the script and set `max_shield` to `100` and `shield_regen`
    to `5` in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following function, which handles changing the shield''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Also, since some things, such as regeneration, may add to the shield's value,
    you need to make sure it doesn't go above the maximum allowed value. Then, when
    you send the `shield_changed` signal, you pass the ratio of `shield/max_shield`.
    This way, the HUD's display doesn't need to know anything about the actual values,
    just the shield's relative state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this line to `start()` and to `set_lives()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Hitting a rock will damage the shield, and bigger rocks should do more damage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The enemy''s bullets should also do damage, so make this change to `EnemyBullet.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, running into the enemy should damage the player, so update this in `Enemy.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The last addition to the player script is to regenerate the shield each frame.
    Add this line to `_process()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the display element to the `HUD`. Rather than display
    the shield''s value in a `Label`, you''ll use a `TextureProgress` node. This is
    a `Control` node that is a type of `ProgressBar`: a node that displays a given
    value as a filled bar. The `TextureProgress` node allows you to assign a texture
    to be used for the bar''s display.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the existing `HBoxContainer`, add `TextureRect` and `TextureProgress`. Place
    them after the `ScoreLabel` and before the `LivesCounter`. Change the name of
    the `TextureProgress` to ShieldBar. Your node setup should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Drag the `res://assets/shield_gold.png` texture into the *Texture* property
    of `TextureRect`. This will be an icon indicating what the bar is displaying.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ShieldBar has three texture properties: Under, Over, and Progress. Progress is
    the texture that will be displayed as the bar''s value. Drag `res://assets/barHorizontal_green_mid
    200.png` into this property. The other two texture properties allow you to customize
    the appearance by setting an image to be drawn below or above the progress texture.
    Drag `res://assets/glassPanel_200.png` into the *Over* texture property.'
  prefs: []
  type: TYPE_NORMAL
- en: In the *Range* section, you can set the numeric properties of the bar. Min Value and
    Max Value should be set to `0` and `100`, as this bar will be showing the percentage
    value of the shield, not its raw value. Value is the property that controls the
    currently displayed fill value. Change it to `75` to see the bar partly filled.
    Also, set its Horizontal size flags to Fill, Expand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can update the HUD script to control the shield bar. Add these variables
    at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the green bar texture, you also have red and yellow bars in
    the `assets` folder. This will allow you to change the shield''s color as the
    value decreases. Loading the textures in this way makes them easier to access
    later in the script when you want to assign the appropriate image to the `TextureProgress`
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, click on the `Main` scene's `Player` node and connect the `shield_changed`
    signal to the `update_shield()` function you just created. Run the game and verify
    that you can see the shield and that it is working. You may want to increase or
    decrease the regeneration rate to adjust it to a speed you like.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with `RigidBody2D` nodes and learned
    more about how Godot's physics works. You also implemented a basic Finite State
    Machine—something you'll find more and more useful as your projects grow larger.
    You saw how `Container` nodes help organize and keep UI nodes aligned. Finally,
    you added some sound effects and got your first taste of advanced visual effects
    by using the `AnimationPlayer` and `Particles2D` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: You also created a number of game objects using the standard Godot hierarchies,
    such as `CollisionShapes` being attached to `CollisionObjects`. At this point,
    some of these node configurations should be starting to look familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, look through the project again. Play it. Make sure you understand
    what each scene is doing, and read through the scripts to review how everything
    connects together.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about kinematic bodies, and use them to create
    a side-scrolling platform game.
  prefs: []
  type: TYPE_NORMAL
