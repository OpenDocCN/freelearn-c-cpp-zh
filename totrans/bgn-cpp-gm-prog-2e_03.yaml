- en: '*Chapter 2*: Variables, Operators, and Decisions – Animating Sprites'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：变量、运算符和决策 – 动画精灵'
- en: In this chapter, we will do quite a bit more drawing on the screen and, to achieve
    this, we will need to learn about some of the basics of C++. We will learn how
    to use variables to remember and manipulate values, and we will begin to add more
    graphics to the game. As this chapter progresses, we will find out how we can
    manipulate these values to animate the graphics. These values are known as variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在屏幕上进行更多的绘制，为了实现这一点，我们需要了解一些C++的基础知识。我们将学习如何使用变量来记住和操作值，并开始向游戏中添加更多图形。随着本章的进展，我们将了解如何操作这些值来动画图形。这些值被称为变量。
- en: 'Here is what is in store:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您将获得的内容：
- en: Learning all about C++ variables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习有关C++变量的所有内容
- en: Seeing how to manipulate the values stored in variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看如何操作存储在变量中的值
- en: Adding a static tree graphic, ready for the player to chop away at
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个静态树木图形，供玩家砍伐
- en: Drawing and animating a bee and three clouds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制和动画一只蜜蜂和三个云朵
- en: C++ variables
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++变量
- en: '**Variables** are the way that our C++ games store and manipulate values/data.
    If we want to know how much health the player has, we need a variable. Perhaps
    you want to know how many zombies are left in the current wave. That is a variable
    as well. If you need to remember the name of the player who got a high score,
    you guessed it—we need a variable for that. Is the game over or still playing?
    Yes, that''s a variable too.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**是我们C++游戏存储和操作值/数据的方式。如果我们想知道玩家有多少生命值，我们需要一个变量。也许你想知道当前波次中剩余了多少僵尸。那也是一个变量。如果你需要记住获得高分玩家的名字，你猜对了——我们需要一个变量来存储那个信息。游戏结束了吗，还是仍在进行中？是的，那也是一个变量。'
- en: Variables are named identifiers for locations in the memory of the PC. The memory
    of the PC is where computer programs are stored as they are being executed. So,
    we might name a variable `numberOfZombies` and that variable could refer to a
    place in memory that stores a value to represent the number of zombies that are
    left in the current wave.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是PC内存中位置的命名标识符。PC的内存是计算机程序在执行时存储的地方。因此，我们可以将一个变量命名为`numberOfZombies`，这个变量可以指向内存中的一个位置，该位置存储一个值，表示当前波次中剩余的僵尸数量。
- en: The way that computer systems address locations in memory is complex. Programming
    languages use variables to give us a human-friendly way to manage our data in
    that memory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统在内存中定位的方式很复杂。编程语言使用变量为我们提供了一种人性化的方式来管理该内存中的数据。
- en: The small amount we have just mentioned about variables implies that there must
    be different **types** of variable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才提到的关于变量的少量信息暗示了必须存在不同类型的**变量**。
- en: Types of variables
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量类型
- en: 'There is a wide variety of C++ variable types (see the next tip about variables
    in a couple of pages). It would easily be possible to spend an entire chapter
    discussing them. What follows is a table of the most commonly used types of variable
    in this book. Then, in the next section, we will look at how to use each of these
    variable types:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++变量类型繁多（请参阅几页后的关于变量的下一个提示）。很容易想象可以花整整一章来讨论它们。以下是一个表格，列出了本书中最常用的变量类型。然后，在下一节中，我们将探讨如何使用这些变量类型：
- en: '![](img/B14278_02_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_02_1.jpg)'
- en: The compiler must be told what type of variable it is so that it can allocate
    the right amount of memory for it. It is good practice to use the best and most
    appropriate type for each variable you use. In practice, however, you will often
    get away with promoting a variable. Perhaps you need a floating-point number with
    just five significant digits? The compiler won't complain if you store it as a
    `double`. However, if you tried to store a `float` or a `double` in an `int`,
    it will `int`. As we progress through this book, I will make it plain what the
    best variable type to use in each case is, and we will even see a few instances
    where we deliberately convert/cast between variable types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器必须被告知变量的类型，以便它可以为它分配正确的内存量。对于您使用的每个变量，使用最佳和最合适的类型是一种良好的实践。然而，在实践中，你通常会通过提升变量来解决问题。也许你需要一个只有五个有效数字的浮点数？如果你将其存储为`double`，编译器不会抱怨。然而，如果你试图将`float`或`double`存储在`int`中，它将变成`int`。随着我们通过这本书的进展，我会清楚地说明在每种情况下使用最佳变量类型是什么，我们甚至会看到一些我们故意在变量类型之间转换/转换的例子。
- en: A few extra details worth noticing in the preceding table include the `f` postfix
    next to all of the `float` values. This `f` postfix tells the compiler that the
    value is a `float` type, not `double`. A floating-point value without the `f`
    prefix is assumed to be `double`. See the next tip about variables for more about
    this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，有几个值得注意的额外细节包括所有 `float` 值旁边的 `f` 后缀。这个 `f` 后缀告诉编译器该值是 `float` 类型，而不是
    `double`。没有 `f` 前缀的浮点值默认是 `double`。关于这一点，请参阅下一节关于变量的提示。
- en: As we mentioned previously, there are many more types. If you want to find out
    more about types, see the next tip about variables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，还有许多其他类型。如果你想了解更多关于类型的信息，请参阅下一节关于变量的提示。
- en: User-defined types
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义的类型
- en: User-defined types are way more advanced than the types we have just seen. When
    we talk about user-defined types in C++, we are usually talking about classes.
    We briefly talked about classes and their related objects in the previous chapter.
    We would write code in a separate file, sometimes two. We are then able to declare,
    initialize, and use them. We will leave how we define/create our own types until
    [*Chapter 6*](B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154)*, Object-Oriented
    Programming – Starting the Pong Game*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的类型比我们刚刚看到的类型要高级得多。当我们谈论 C++ 中的用户定义类型时，我们通常指的是类。我们在上一章中简要介绍了类及其相关对象。我们将代码写入单独的文件，有时是两个文件。然后我们能够声明、初始化和使用它们。我们将如何定义/创建我们自己的类型留到
    [*第 6 章*](B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154)*，面向对象编程 – 开始乒乓球游戏*。
- en: Declaring and initializing variables
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明和初始化变量
- en: So far, we know that variables are for storing the data/values that our games
    need in order to work. For example, a variable would represent the number of lives
    a player has or the player's name. We also know that there is a wide selection
    of different types of values that these variables can represent, such as `int`,
    `float`, `bool`, and so on. Of course, what we haven't seen yet is how we would
    actually go about using a variable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道变量用于存储我们的游戏需要的数据/值，以便工作。例如，一个变量可以代表玩家拥有的生命值或玩家的名字。我们还知道，这些变量可以表示多种不同类型的值，例如
    `int`、`float`、`bool` 等。当然，我们还没有看到的是我们如何实际使用变量。
- en: There are two stages when it comes to creating and preparing a new variable.
    These stages are called **declaration** and **initialization**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和准备新变量有两个阶段。这些阶段被称为 **声明** 和 **初始化**。
- en: Declaring variables
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'We can declare variables in C++ like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 C++ 中这样声明变量：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we have written the code to declare a variable, it exists and is ready
    to be used in our code. However, we will usually want to give the variable an
    appropriate value, which is where initialization comes in.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了声明变量的代码，它就存在了，并准备好在我们的代码中使用。然而，我们通常会想要给变量赋予一个合适的值，这就是初始化的作用所在。
- en: Initializing variables
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化变量
- en: 'Now that we have declared the variables with meaningful names, we can initialize
    those same variables with appropriate values, like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用有意义的名字声明了变量，我们可以用适当的值初始化这些变量，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point, the variable exists and holds a specific value. Soon, we will
    see how we can change, test, and respond to these values. Next, we will see that
    we can combine declaring and initializing into one step.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，变量已经存在并持有特定的值。很快，我们将看到如何更改、测试和响应这些值。接下来，我们将看到我们可以将声明和初始化合并为一步。
- en: Declaring and initializing in one step
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一步声明和初始化
- en: 'When it suits us, we can combine the declaration and initialization steps into
    one. Sometimes, we know what value a variable must start the program with, and
    declaring and initializing in one step is appropriate. Often, we won''t, and we
    will first declare the variable and then initialize it later in the program, like
    so:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们觉得合适时，我们可以将声明和初始化步骤合并为一步。有时，我们知道变量必须以什么值开始程序，在这种情况下，一步声明和初始化是合适的。通常情况下，我们不知道，我们首先声明变量，然后在程序的后面初始化它，如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Variables tip
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 变量提示
- en: 'As promised, here is the tip on variables. If you want to see a complete list
    of C++ types, then check out this web page: [http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm](http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm).
    If you want a deeper discussion on `float`, `double`, and the `f` postfix, then
    read this: [http://www.cplusplus.com/forum/beginner/24483/](http://www.cplusplus.com/forum/beginner/24483/).
    Finally, if you want to know the ins and outs of the ASCII character codes, then
    there is some more information here: [http://www.cplusplus.com/doc/ascii/](http://www.cplusplus.com/doc/ascii/).
    Note that these links are for the extra curious reader and we have already discussed
    enough in order to proceed.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如承诺的那样，这里有一些关于变量的技巧。如果你想查看C++类型的完整列表，请查看这个网页：[http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm](http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm)。如果你想对`float`、`double`和`f`后缀进行更深入的讨论，请阅读这个：[http://www.cplusplus.com/forum/beginner/24483/](http://www.cplusplus.com/forum/beginner/24483/)。最后，如果你想了解ASCII字符码的来龙去脉，这里有一些更多信息：[http://www.cplusplus.com/doc/ascii/](http://www.cplusplus.com/doc/ascii/)。请注意，这些链接是为那些好奇心旺盛的读者准备的，我们已经讨论了足够的内容以便继续前进。
- en: Constants
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量
- en: 'Sometimes, we need to make sure that a value can never be changed. To achieve
    this, we can declare and initialize a `const` keyword:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要确保一个值永远不能被改变。为了实现这一点，我们可以声明并初始化一个`const`关键字：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is convention to declare constants in all uppercase. The values of the preceding
    constants can never be altered. We will see some constants in action in [*Chapter
    4*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)*, Loops, Arrays, Switches,
    Enumerations, and Functions – Implementing Game Mechanics*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 声明常量的惯例是全部大写。前面常量的值永远不能改变。我们将在[*第4章*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)“循环、数组、开关、枚举和函数
    – 实现游戏机制”中看到一些常量的实际应用。
- en: Declaring and initializing user-defined types
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明和初始化用户定义的类型
- en: We have already seen examples of how we can declare and initialize some SFML
    defined types. It is because of the way that we can create/define these types
    (classes) so flexibly that the way we declare and initialize them is also so varied.
    Here are a couple of reminders for declaring and initializing user-defined types
    from the previous chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何声明和初始化一些SFML定义的类型的例子。正是因为我们可以如此灵活地创建/定义这些类型（类），所以它们的声明和初始化方式也是多种多样的。这里有一些关于从上一章声明和初始化用户定义类型的提醒。
- en: 'Create an object of the `VideoMode` type called `vm` and initialize it with
    two `int` values, `1920` and `1080`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`vm`的`VideoMode`类型的对象，并用两个`int`值`1920`和`1080`进行初始化：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create an object of the `Texture` type called `textureBackground`, but don''t
    do any initialization:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`textureBackground`的`Texture`类型的对象，但不要进行任何初始化：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that it is possible (in fact, very likely) that even though we are not
    suggesting any specific values with which to initialize `textureBackground`, some
    setup of variables may take place internally. Whether or not an object needs/has
    the option of giving initialization values at this point is entirely dependent
    on how the class is coded and is almost infinitely flexible. This further suggests
    that, when we get to write our own classes, there will be some complexity. Fortunately,
    this also means we will have significant power to design our types/classes to
    be just what we need to make our games! Add this huge flexibility to the power
    of the SFML designed classes and the potential for our games is almost limitless.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使我们没有建议用于初始化`textureBackground`的具体值，也可能（实际上，可能性非常大）在内部进行一些变量的设置。一个对象是否需要/有在这一点上提供初始化值的选项，完全取决于类的编码方式，几乎是无限灵活的。这进一步表明，当我们开始编写自己的类时，将有一些复杂性。幸运的是，这也意味着我们将拥有显著的能力来设计我们的类型/类，以满足我们制作游戏的需求！将这种巨大的灵活性添加到SFML设计类的力量中，我们游戏的可能性几乎是无限的。
- en: We will see a few more user created types/classes provided by SFML in this chapter
    too, and loads more throughout this book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将看到SFML提供的更多用户创建的类型/类，在整个书中还有更多。
- en: We have now seen that a variable is a named location in the computer's memory
    and that a variable can be a simple integer through to a more powerful object.
    Now that we know we can initialize these variables, we will look at how we can
    manipulate the values they hold.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，变量是计算机内存中的一个命名位置，变量可以是简单的整数，也可以是更强大的对象。既然我们知道我们可以初始化这些变量，我们将看看我们如何可以操作它们所持有的值。
- en: Manipulating variables
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的操作
- en: At this point, we know exactly what variables are, the main types they can be,
    and how to declare and initialize them. We still can't do that much with them,
    however. We need to manipulate our variables; add them; take them away; and multiply,
    divide, and test them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们确切地知道变量是什么，它们可以有哪些主要类型，以及如何声明和初始化它们。然而，我们仍然不能做很多。我们需要操作我们的变量；给它们加值；减去它们的值；以及乘以、除以和测试它们。
- en: First, we will deal with how we can manipulate them and then we will look at
    how and why we test them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理如何操作它们，然后我们将看看如何以及为什么我们要测试它们。
- en: C++ arithmetic and assignment operators
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++算术和赋值运算符
- en: 'In order to manipulate variables, C++ has a range of **arithmetic operators**
    and **assignment operators**. Fortunately, most arithmetic and assignment operators
    are quite intuitive to use and those that aren''t are quite easy to explain. To
    get us started, let''s look at a table of arithmetic operators, followed by a
    table of assignment operators, all of which we will regularly use throughout this
    book:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作变量，C++提供了一系列的**算术运算符**和**赋值运算符**。幸运的是，大多数算术和赋值运算符的使用非常直观，那些不太直观的也很容易解释。为了让我们开始，让我们先看看算术运算符的表格，然后是赋值运算符的表格，这些表格我们将在这本书的整个过程中经常使用：
- en: '![](img/B14278_02_2.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_02_2.jpg)'
- en: 'And now for the assignment operators:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看赋值运算符：
- en: '![](img/B14278_02_3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_02_3.jpg)'
- en: Important note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Technically, all of these operators, except for `=`, `--`, and `++`, are called
    **compound assignment operators** because they comprise more than one operator.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，除了`=`、`--`和`++`之外的所有这些运算符都被称为**复合赋值运算符**，因为它们由多个运算符组成。
- en: Now that we have seen a good range of arithmetic and assignment operators, we
    can actually look at how we can manipulate our variables by combining operators,
    variables, and values to form **expressions**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一系列的算术和赋值运算符，我们可以实际看看我们如何通过结合运算符、变量和值来形成**表达式**来操作我们的变量。
- en: Getting things done with expressions
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表达式完成任务
- en: '**Expressions** are the result of combining variables, operators, and values.
    Using expressions, we can arrive at a result. Furthermore, as we will soon see,
    we can use an expression in a test. These tests can be used to decide what our
    code should do next. First, let''s look at some simple expressions we might see
    in our game code. Here is one example of a simple expression:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**是结合变量、运算符和值的结果。使用表达式，我们可以得到一个结果。此外，正如我们很快就会看到的，我们可以在测试中使用表达式。这些测试可以用来决定我们的代码下一步应该做什么。首先，让我们看看我们可能在游戏代码中看到的简单表达式。这里是一个简单表达式的例子：'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, the value held in the `score` variable is used to change
    the value in the `hiScore` variable. The two variables now hold the same value,
    but note that they are still separate and distinct variables (places in memory).
    This would likely be just what we need when the player beats a high score. Here
    is another example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`score`变量所持有的值被用来改变`hiScore`变量的值。现在这两个变量持有相同的值，但请注意，它们仍然是独立的、不同的变量（内存中的位置）。当玩家打破高分时，这可能是我们需要的。这里还有一个例子：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s take a look at the addition operator, which used in conjunction with
    the assignment operator:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看加法运算符，它与赋值运算符结合使用：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, the values held by `aliensShot` and `wavesCleared` are
    added together using the addition operator and then the result of the addition
    is assigned to the `score` variable. Now, let''s take a look at the following
    code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`aliensShot`和`wavesCleared`所持有的值通过加法运算符相加，然后将加法的结果赋值给`score`变量。现在，让我们看看以下代码：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that it is perfectly acceptable to use the same variable on both sides
    of an operator. In the preceding code, 100 is added to the value held by the `score`
    variable and then this new value is then assigned back into `score`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在运算符两侧使用相同的变量是完全可接受的。在前面代码中，100被加到`score`变量所持有的值上，然后这个新值被重新赋值给`score`。
- en: 'Look at the subtraction operator in conjunction with the assignment operator.
    The following code subtracts the value on the right-hand side of the subtraction
    operator from the value on the left. It is usually used in conjunction with the
    assignment operator, perhaps like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看看减法运算符与赋值运算符的结合。以下代码从减法运算符左侧的值中减去右侧的值。它通常与赋值运算符结合使用，可能如下所示：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It can also be used like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以这样使用：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will see how we might use the division operator. The following code
    divides the number on the left by the number on the right. Again, it is usually
    used with the assignment operator, like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到我们如何可能使用除法操作符。以下代码将左边的数字除以右边的数字。同样，它通常与赋值操作符一起使用，如下所示：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It can also be used like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以这样使用：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Obviously, in the previous example, the `recycledValueOfBlock` variable will
    need to be of the `float` type to accurately store the answer to a calculation
    like that.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在上一个例子中，`recycledValueOfBlock`变量需要是`float`类型，才能准确存储像那样的计算结果。
- en: 'Perhaps unsurprisingly, we could use the multiplication operator like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 也许不出所料，我们可以像这样使用乘法操作符：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It can also be used like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以这样使用：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Important note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As a side note, have you ever wondered how C++ got its name? C++ is an extension
    of the C language. Its inventor, **Bjarne Stroustrup**, originally called it "C
    with classes", but the name evolved. If you are interested, you can read the story
    of C++ at [http://www.cplusplus.com/info/history/](http://www.cplusplus.com/info/history/).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁白，你有没有想过C++是如何得到它的名字的？C++是C语言的扩展。它的发明者**Bjarne Stroustrup**最初称它为“带类的C”，但这个名字演变了。如果你感兴趣，你可以阅读C++的故事[http://www.cplusplus.com/info/history/](http://www.cplusplus.com/info/history/)。
- en: Now, let's look at the increment operator in action. This is a neat way to add
    1 to the value of one of our game's variables.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看增量操作符的实际应用。这是一种巧妙的方法，可以给我们的游戏变量中的一个值加1。
- en: 'Take a look at the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code gives the same result as the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码给出的结果与以下代码相同：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The decrement operator, `--`, is, you guessed it, a quick way to subtract 1
    from something, like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 减量操作符`--`，正如你所猜到的，是一种快速从某物中减去1的方法，如下所示：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the same as doing the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下操作相同：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s look at a few more operators in action and then we can get back to building
    the Timber!!! game. The addition, subtraction, multiplication, and division operators
    each have a related operator that combines their primary function (adding, subtracting,
    and so on) with assignment. They allow us to use more concise code when we want
    to perform the primary function of the operator, followed by assignment. Have
    a look at the four examples (one for each operator) that follow:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个操作符在实际中的应用，然后我们可以回到构建Timber!!!游戏。加法、减法、乘法和除法操作符每个都有一个相关的操作符，它将它们的主要功能（加法、减法等）与赋值结合起来。这允许我们在想要执行操作符的主要功能后进行赋值时，使用更简洁的代码。看看下面的四个例子（每个操作符一个）：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding four examples, we can see that the `*=`, `/=`, `+=`, and `-=`
    operators can be used to shorten the syntax when we want to use one of the four
    arithmetic operators followed by an assignment. We will do this quite a bit throughout
    this book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的四个例子中，我们可以看到`*=`、`/=`、`+=`和`-=`操作符可以用来缩短语法，当我们想要使用四个算术操作符之一后跟赋值时。我们将在整本书中这样做很多。
- en: It's time to add some more sprites to our game.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候给我们的游戏添加更多精灵了。
- en: Adding clouds, a tree, and a buzzing bee
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加云、树和嗡嗡的蜜蜂
- en: In this section, we will add clouds, a tree, and a buzzing bee to our Timber!!!
    game. First, we will add a tree. This is going to be easy. The reason for this
    is because the tree doesn't move. We will use the same procedure that we used
    in the previous chapter when we drew the background. The bee and the clouds will
    also be easy to draw in their starting positions, but we will need to combine
    what we have just learned about manipulating variables with some new C++ topics
    to make them move.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向Timber!!!游戏添加云、树和嗡嗡的蜜蜂。首先，我们将添加一棵树。这将会很容易。原因是树不会移动。我们将使用我们在上一章中绘制背景时使用的相同程序。蜜蜂和云在它们的起始位置也很容易绘制，但我们需要将我们刚刚学到的关于操作变量的知识与新学的C++主题结合起来，使它们移动。
- en: Preparing the tree
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备树
- en: 'Let''s get ready to draw the tree! Add the following highlighted code. Notice
    the unhighlighted code, which is the code we have already written. This should
    help you to identify that the new code should be typed immediately after we set
    the position of the background but before the start of the main game loop. We
    will provide a recap regarding what is going on in the new code after we have
    added it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备好绘制树！添加以下突出显示的代码。注意未突出显示的代码，这是我们已编写的代码。这应该有助于你识别新代码应该在设置背景位置之后、主游戏循环开始之前立即输入。我们将在添加新代码后提供关于新代码中发生的事情的回顾：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is what the following five lines of code (excluding the comment) do:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下五行代码（不包括注释）所做的是：
- en: First, we create an object of the `Texture` type called `textureTree`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `textureTree` 的 `Texture` 类型的对象。
- en: Next, we load a graphic into the texture from the `tree.png` graphics file.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从 `tree.png` 图形文件中加载一个图形到纹理中。
- en: Then, we declare an object of the `Sprite` type called `spriteTree`
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明一个名为 `spriteTree` 的 `Sprite` 类型的对象。
- en: After, we associate `textureTree` with `spriteTree`. Whenever we draw `spriteTree`,
    it will show the `textureTree` texture, which is a neat tree graphic.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将 `textureTree` 与 `spriteTree` 关联。每次我们绘制 `spriteTree` 时，它都会显示 `textureTree`
    纹理，这是一个整洁的树形图形。
- en: Finally, we set the position of the tree using the coordinates `810` on the
    *x* axis and `0` on the *y* axis.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 *x* 轴上的坐标 `810` 和 *y* 轴上的坐标 `0` 来设置树的位置。
- en: The tree sprite is ready to draw, along with the tree texture. Let's move on
    to the bee object, which is handled in an almost identical manner.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 树精灵准备就绪，可以绘制，以及树纹理。让我们继续到蜜蜂对象，它以几乎相同的方式处理。
- en: Preparing the bee
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备蜜蜂
- en: 'Preparing the bee sprite is very similar but not identical to preparing the
    tree sprite. The difference between the following code and the tree code is small
    but important. Since the bee needs to move, we also declare two bee-related variables.
    Add the following highlighted code and see whether you can work out how we might
    use the `beeActive` and `beeSpeed` variables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 准备蜜蜂精灵的过程与准备树精灵的过程非常相似，但并不完全相同。以下代码与树代码之间的差异很小但很重要。由于蜜蜂需要移动，我们也声明了两个与蜜蜂相关的变量。添加以下突出显示的代码，看看我们如何可能使用
    `beeActive` 和 `beeSpeed` 变量：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We create a bee in the same way we created a background and a tree. We use a
    `Texture`, a `Sprite`, and associate the two. Note that, in the previous bee code,
    there's some new code we haven't seen before. There is a `bool` variable for determining
    whether the bee is active. Remember that a `bool` variable can be either `true`
    or `false`. We initialize `beeActive` to `false` for now.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以创建背景和树相同的方式创建蜜蜂。我们使用 `Texture`、`Sprite` 并将它们关联起来。请注意，在之前的蜜蜂代码中，有一些我们之前没有见过的代码。有一个用于确定蜜蜂是否活跃的
    `bool` 变量。请记住，`bool` 变量可以是 `true` 或 `false`。我们目前将 `beeActive` 初始化为 `false`。
- en: Next, we declare a new `float` variable called `beeSpeed`. This will hold the
    speed in pixels per second that our bee will fly across the screen at.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个名为 `beeSpeed` 的新 `float` 变量。这将存储蜜蜂在屏幕上飞行的像素每秒速度。
- en: Soon, we will see how we use these two new variables to move the bee. Before
    we do, let's set up some clouds in an almost identical manner.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将看到我们如何使用这两个新变量来移动蜜蜂。在我们这样做之前，让我们以几乎相同的方式设置一些云朵。
- en: Preparing the clouds
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备云朵
- en: 'Add the following highlighted code. Study the new code and try and work out
    what it will do:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下突出显示的代码。研究新代码，并尝试弄清楚它将做什么：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The only thing about the code we have just added that might seem a little odd
    is that we have only one object of the `Texture` type. It is completely normal
    for multiple `Sprite` objects to share a texture. Once a `Texture` is stored in
    GPU memory, it can be associated with a `Sprite` object very quickly. It is only
    the initial loading of the graphic in the `loadFromFile` code that is a relatively
    slow operation. Of course, if we wanted three different shaped clouds, then we
    would need three textures.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码中唯一可能显得有点奇怪的是，我们只有一个 `Texture` 类型的对象。对于多个 `Sprite` 对象共享纹理是完全正常的。一旦
    `Texture` 存储在 GPU 内存中，它就可以非常快地与 `Sprite` 对象关联起来。只有 `loadFromFile` 代码中图形的初始加载是一个相对较慢的操作。当然，如果我们想要三个不同形状的云朵，那么我们需要三个纹理。
- en: Apart from the minor texture issue, the code we have just added is nothing new
    compared to the bee. The only difference is that there are three cloud sprites,
    three `bool` variables to determine whether each cloud is active, and three `float`
    variables to hold the speed for each cloud.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了微小的纹理问题外，我们刚刚添加的代码与蜜蜂的代码相比没有什么新意。唯一的区别是，有三个云朵精灵，三个用于确定每个云朵是否活跃的 `bool` 变量，以及三个用于存储每个云朵速度的
    `float` 变量。
- en: At this stage, all of the sprites and variables have been prepared. We can now
    move on to drawing them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，所有的精灵和变量都已经准备好了。我们现在可以继续绘制它们。
- en: Drawing the tree, the bee, and the clouds
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制树、蜜蜂和云朵
- en: 'Finally, we can draw them all to the screen by adding the following highlighted
    code in the drawing section:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在绘图部分添加以下突出显示的代码来将它们全部绘制到屏幕上：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Drawing the three clouds, the bee, and the tree is done in the same way that
    the background was drawn. Note, however, the order in which we draw the different
    objects to the screen. We must draw all of the graphics after the background,
    or they will be covered, and we must draw the clouds before the tree, or they
    will look a bit odd drifting in front of the tree. The bee would look OK either
    in front or behind the tree. I opted to draw the bee in front of the tree so that
    it can try and distract our lumberjack, a bit like a real bee might.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以与绘制背景相同的方式绘制三个云朵、蜜蜂和树木。注意，然而，我们在屏幕上绘制不同对象的顺序。我们必须在背景之后绘制所有图形，否则它们将被覆盖，我们必须在树木之前绘制云朵，否则它们在树木前飘动会显得有些奇怪。蜜蜂在树木前或后看起来都很好。我选择在树木前绘制蜜蜂，这样它就可以试图分散伐木工的注意力，就像一只真正的蜜蜂可能会做的那样。
- en: 'Run Timber!!! and gaze in awe at the tree, three clouds, and a bee that… don''t
    do anything! They look like they are lining up for a race; a race where the bee
    has to go backward:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Timber!!! 并敬畏地凝视那棵树、三个云朵和一只……什么也不做的蜜蜂。它们看起来像是在排队参加比赛；一场蜜蜂必须倒退着走的比赛：
- en: '![](img/B14278_02_01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_02_01.jpg)'
- en: Using what we know about operators, we could try and move the graphics we have
    just added, but there's a problem. The problem is that real clouds and bees move
    in a non-uniform manner. They don't have a set speed or location, with these elements
    determined by factors such as wind speed or how much of a hurry the bee might
    be in. To the casual observer, the path they take and their speed appear to be
    *random*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们对运算符的了解，我们可以尝试移动我们刚刚添加的图形，但有一个问题。问题是真正的云朵和蜜蜂以非均匀的方式移动。它们没有固定的速度或位置，这些元素由风速或蜜蜂可能有多急等因素决定。对于普通观察者来说，它们的路径和速度看起来是
    **随机** 的。
- en: Random numbers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机数
- en: '**Random numbers** are useful for lots of reasons in games—perhaps determining
    what card the player is dealt or how much damage within a certain range is subtracted
    from an enemy''s health. We will now learn how to generate random numbers to determine
    the starting location and speed of the bee and the clouds.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机数** 在游戏中有很多用途——比如确定玩家被发什么牌，或者从敌人健康值中减去一定范围内的伤害。现在我们将学习如何生成随机数以确定蜜蜂和云朵的起始位置和速度。'
- en: Generating random numbers in C++
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C++ 中生成随机数
- en: To generate random numbers, we will need to use some more C++ functions—two
    more, to be precise. Don't add any code to the game yet. Let's just look at the
    syntax and the steps that are required with some hypothetical code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成随机数，我们需要使用一些更多的 C++ 函数——确切地说，两个。现在不要向游戏中添加任何代码。让我们看看一些假设代码的语法和所需的步骤。
- en: 'Computers can''t genuinely pick random numbers. They can only use **algorithms**/**calculations**
    to pick a number that *appears* to be random. So that this algorithm doesn''t
    constantly return the same value, we must **seed** the random number generator.
    The seed can be any integer number, although it must be a different seed each
    time you require a unique random number. Look at the following code, which seeds
    the random number generator:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不能真正地选择随机数。它们只能使用 **算法**/**计算** 来选择一个看起来是随机的数字。为了使这个算法不会不断返回相同的值，我们必须 **初始化**
    随机数生成器。种子可以是任何整数，尽管每次需要不同的随机数时，它必须是一个不同的种子。看看以下代码，它初始化了随机数生成器：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code gets the time from the PC using the `time` function, that
    is, `time(0)`. The call to the `time` function is enclosed as the value to be
    sent to the `srand` function. The result of this is that the current time is used
    as the seed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码使用 `time` 函数从 PC 获取时间，即 `time(0)`。对 `time` 函数的调用被包含为要发送给 `srand` 函数的值。结果是使用当前时间作为种子。
- en: The previous code is made to look a little more complicated because of the slightly
    unusual looking `(int)` syntax. What this does is convert/cast the value that's
    returned from `time` into an `int`. This is required by the `srand` function in
    this situation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码看起来稍微复杂一些，因为 `(int)` 语法看起来有些不寻常。这样做是将 `time` 返回的值转换为 `int`。在这种情况下，这是 `srand`
    函数所必需的。
- en: Important note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The term that's used to describe a conversion from one type to another is **cast**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 描述从一种类型到另一种类型的转换所使用的术语是 **cast**。
- en: 'So, in summary, the previous line of code does the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，上一行代码执行以下操作：
- en: Gets the time using `time`
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `time` 获取时间
- en: Converts it into an `int`
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其转换为 `int`
- en: Sends this resulting value to `srand`, which seeds the random number generator
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此结果值发送到 `srand`，以初始化随机数生成器
- en: The time is, of course, always changing. This makes the `time` function a great
    way to seed the random number generator. However, think about what might happen
    if we seed the random number generator more than once and in such quick succession
    that `time` returns the same value. We will see and solve this problem when we
    animate our clouds.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 时间当然总是在变化的。这使得`time`函数成为随机数生成器的一个很好的种子方式。然而，想想如果我们多次并且快速地种子随机数生成器，而`time`返回相同的值会发生什么。当我们动画化我们的云时，我们将看到并解决这个问题。
- en: 'At this stage, we can create the random number, between a range, and save it
    to a variable for later use, like so:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以创建一个随机数，在某个范围内，并将其保存到变量中供以后使用，如下所示：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice the odd-looking way we assign a value to `number`. By using the Modulo
    operator (`%`) and the value of `100`, we are asking for the remainder, after
    dividing the number returned from `rand`, by 100\. When you divide by 100, the
    highest number you can possibly have as a remainder is 99\. The lowest number
    possible is 0\. Therefore, the previous code will generate a number between 0
    and 99 inclusive. This knowledge will be useful for generating a random speed
    and starting location for our bees and clouds.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们给`number`赋值的方式看起来很奇怪。通过使用模运算符（`%`）和`100`的值，我们是在询问从`rand`返回的数字除以100后的余数。当你除以100时，你作为余数的最大可能值是99。可能的最小值是0。因此，之前的代码将生成一个介于0到99（包括0和99）之间的数字。这个知识将对我们生成蜜蜂和云的随机速度和起始位置很有用。
- en: But before we can implement our random bees and clouds, we will need to learn
    how to make decisions in C++.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们能够实现我们的随机蜜蜂和云之前，我们需要学习如何在C++中做出决策。
- en: Making decisions with if and else
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if和else进行决策
- en: 'The C++ `if` in action in the previous chapter when we detected whether the
    player had pressed the *Esc* key each frame:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们在每一帧检测玩家是否按下了*Esc*键时，C++的`if`运算符的实际应用：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So far, we have seen how we can use arithmetic and assignment operators to create
    expressions. Now, we will look at some new operators.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们可以如何使用算术和赋值运算符来创建表达式。现在，我们将看看一些新的运算符。
- en: Logical operators
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: '**Logical operators** are going to help us to make decisions by building expressions
    that can be tested for a value of either true or false. At first, this might seem
    like quite a narrow choice and insufficient for the kind of choices that might
    be needed in an advanced PC game. Once we dig a little deeper, we will see that
    we can make all of the required decisions we will need with just a few of the
    logical operators.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑运算符**将帮助我们通过构建可以测试为真或假的值的表达式来做出决策。一开始，这可能会显得选择很有限，不足以满足高级PC游戏中可能需要的决策。一旦我们深入研究，我们将看到我们只需要几个逻辑运算符就可以做出所有需要的决策。'
- en: 'Here is a table of the most useful logical operators. Look at them and the
    associated examples, and then we will see how we can put them to use:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个最有用的逻辑运算符表。看看它们和相关的例子，然后我们将看看我们如何使用它们：
- en: '![](img/B14278_02_4.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_02_4.jpg)'
- en: Let's take a look at the C++ `if` and `else` keywords, which will allow us to
    put all of these logical operators to good use.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看C++的`if`和`else`关键字，这将使我们能够充分利用这些逻辑运算符。
- en: C++ if and else
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++的if和else
- en: Let's make the previous examples less abstract. Meet the C++ `if` and a few
    operators along with a small story to demonstrate their use. Next follows a made-up
    military situation that will hopefully be less abstract than the previous examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把之前的例子变得更具体一些。认识一下C++的`if`运算符和一些运算符，以及一个小故事来展示它们的使用。接下来是一个虚构的军事情况，希望它比之前的例子更具体。
- en: If they come over the bridge, shoot them!
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果他们过桥，就射击他们！
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a C++ program to convey his last orders for after
    he has died. The troops must hold one side of a bridge while waiting for reinforcements.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 舰长正在死去，并且知道他剩下的下属经验不足，他决定编写一个C++程序来传达他死后最后的命令。部队必须守住桥梁的一侧，等待增援。
- en: 'The first command the captain wants to make sure his troops understand is this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 舰长想要确保他的部队理解的第一条命令是：
- en: '"If they come over the bridge, shoot them!"'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '"如果他们过桥，就射击他们！"'
- en: So, how do we simulate this situation in C++? We need a `bool` variable, `isComingOverBridge`.
    The following bit of code assumes that the `isComingOverBridge` variable has been
    declared and initialized to either `true` or `false`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在C++中模拟这种情况？我们需要一个`bool`变量`isComingOverBridge`。以下代码片段假设`isComingOverBridge`变量已经被声明并初始化为`true`或`false`。
- en: 'We can then use `if` like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用`if`：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the `isComingOverBridge` variable is equal to `true`, the code inside the
    opening and closing curly braces `{...}` will run. If not, the program continues
    after the `if` block and without running the code within it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isComingOverBridge`变量等于`true`，则在大括号`{...}`内的代码将运行。如果不等于，则程序在`if`块之后继续执行，而不运行其中的代码。
- en: Shoot them … or else do this instead
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射击他们……或者做这个代替
- en: The captain also wants to tell his troops to stay put if the enemy is not coming
    over the bridge.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 指挥官还希望告诉他的士兵，如果敌人没有越过桥梁，他们应该原地待命。
- en: Now, we can introduce another C++ keyword, `if` does `true`, we can use `else`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以引入另一个C++关键字，如果`if`为`true`，我们可以使用`else`。
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we could write the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果敌人没有越过桥梁，我们可以编写以下代码来告诉士兵们原地待命：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The captain then realized that the problem wasn''t as simple as he first thought.
    What if the enemy comes over the bridge, but has too many troops? His squad would
    be overrun and slaughtered. So, he came up with the following code (we''ll use
    some variables as well this time):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，指挥官意识到问题并不像他最初想的那么简单。如果敌军越过桥梁，但人数过多怎么办？他的小队会被围攻并屠杀。因此，他想出了以下代码（这次我们也会使用一些变量）：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code has three possible paths of execution. First, if the enemy
    is coming over the bridge and the friendly troops are greater in number:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有三个可能的执行路径。首先，如果敌军越过桥梁且友军数量更多：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second occurs if the enemy troops are coming over the bridge but outnumber
    the friendly troops:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是敌军越过桥梁，但数量超过友军：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then, the third and final possible outcome, which will execute if neither of
    the others is `true`, is captured by the final `else`, without an `if` condition.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第三种也是最后一种可能的输出，如果没有其他任何一个是`true`，则由最后的`else`捕获，而不需要`if`条件。
- en: Reader challenge
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读者挑战
- en: 'Can you spot a flaw with the preceding code? One that might leave a bunch of
    inexperienced troops in complete disarray? The possibility of the enemy troops
    and friendly troops being exactly equal in number has not been handled explicitly
    and would therefore be handled by the final `else`. The final `else` is meant
    for when there are no enemy troops. I guess any self-respecting captain would
    expect his troops to fight in this situation. He could change the first `if` statement
    to accommodate this possibility, like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否发现前面代码中的缺陷？一个可能会让一群缺乏经验的士兵陷入混乱的缺陷？没有明确处理敌军和友军数量完全相等的情况，因此这种情况将由最后的`else`处理。最后的`else`是为了处理没有敌军的情况。我想任何有自尊的指挥官都会期望他的士兵在这种情况下战斗。他可以将第一个`if`语句改为适应这种情况，如下所示：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, the captain''s last concern was that if the enemy came over the bridge
    waving the white flag of surrender and were promptly slaughtered, then his men
    would end up as war criminals. The C++ code that was needed was obvious. Using
    the `wavingWhiteFlag` Boolean variable, he wrote this test:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，指挥官最后的担忧是，如果敌军挥舞着白旗投降并迅速被屠杀，那么他的士兵最终会成为战争罪犯。所需的C++代码很明显。使用`wavingWhiteFlag`布尔变量，他编写了以下测试：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But where to put this code was less clear. In the end, the captain opted for
    the following nested solution and changed the test for `wavingWhiteFlag` to logical
    NOT, like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但将这段代码放在哪里并不那么清楚。最后，指挥官选择了以下嵌套解决方案，并将`wavingWhiteFlag`的测试改为逻辑非，如下所示：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This demonstrates that we can nest `if` and `else` statements inside one another
    to create quite deep and detailed decisions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了我们可以将`if`和`else`语句嵌套在一起，以创建相当深入和详细的决策。
- en: We could go on making more and more complicated decisions with `if` and `else`
    but what we have seen is more than enough as an introduction. It is probably worth
    pointing out, that often, there is more than one way to arrive at a solution to
    a problem. The *right* way will usually be the way that solves the problem in
    the clearest and simplest manner.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`if`和`else`继续做出越来越复杂的决策，但我们所看到的已经足够作为入门了。也许值得指出的是，通常，解决问题有不止一种方法。*正确*的方法通常是以最清晰、最简单的方式解决问题的方法。
- en: We are getting closer to having all of the C++ knowledge we need to be able
    to animate our clouds and bee. We have one final animation issue to discuss and
    then we can get back to the game.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们越来越接近拥有所有必要的 C++ 知识来动画化我们的云和蜜蜂。我们还有一个最后的动画问题要讨论，然后我们可以回到游戏。
- en: Timing
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间控制
- en: Before we can move the bee and the clouds, we need to consider timing. As we
    already know, the main game loop executes repeatedly until the player presses
    the *Escape* key.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们移动蜜蜂和云之前，我们需要考虑时间控制。正如我们已经知道的，主游戏循环会重复执行，直到玩家按下 *Escape* 键。
- en: We have also learned that C++ and SFML are exceptionally fast. In fact, my aging
    laptop executes a simple game loop (like the current one) at around five thousand
    times per second.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到 C++ 和 SFML 非常快。事实上，我那台老化的笔记本电脑以大约每秒五千次的速度执行一个简单的游戏循环（就像当前的循环）。
- en: The frame rate problem
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧率问题
- en: Let's consider the speed of the bee. For the purpose of discussion, we could
    pretend that we are going to move it at 200 pixels per second. On a screen that
    is 1,920 pixels wide, it would take, very approximately, 10 seconds to cross the
    entire width, because 10 x 200 is 2,000 (near enough to 1,920).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑蜜蜂的速度。为了讨论的目的，我们可以假装我们将以每秒 200 像素的速度移动它。在一个宽度为 1,920 像素的屏幕上，它将非常近似地需要 10
    秒才能穿越整个宽度，因为 10 乘以 200 等于 2,000（接近 1,920）。
- en: Furthermore, we know that we can position any of our sprites with `setPosition(...,...)`.
    We just need to put the x and the y coordinates in the parentheses.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们知道我们可以使用 `setPosition(...,...)` 来定位任何我们的精灵。我们只需要将 x 和 y 坐标放入括号中。
- en: 'In addition to setting the position of a sprite, we can also get the current
    position of a sprite. To get the horizontal x coordinate of the bee for example,
    we would use the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置精灵的位置外，我们还可以获取精灵的当前位置。例如，要获取蜜蜂的水平 x 坐标，我们会使用以下代码：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The current x coordinate of the bee is now stored in `currentPosition`. To
    move the bee to the right, we need to add the appropriate fraction of 200 (our
    intended speed) divided by 5,000 (the approximate frames per second on my laptop)
    to `currentPosition`, like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 蜜蜂当前的 x 坐标现在存储在 `currentPosition` 中。要将蜜蜂向右移动，我们需要将 200（我们期望的速度）除以 5,000（在我的笔记本电脑上大约每秒的帧数）的适当分数加到
    `currentPosition` 上，如下所示：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we would use `setPosition` to move our bee. It would smoothly move from
    left to right by 200 divided by 5,000 pixels each frame. But there are two big
    problems with this approach.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `setPosition` 来移动我们的蜜蜂。它将以每帧 200 除以 5,000 像素的速度平滑地从左向右移动。但这种方法有两个大问题。
- en: Frame rate is the number of times per second that our game loop is processed.
    That is, the number of times that we handle the players input, update the game
    objects, and draw them to the screen. We will expand on and discuss matters of
    frame rate now and throughout the rest of this book.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 帧率是每秒我们游戏循环处理的次数。也就是说，我们处理玩家输入、更新游戏对象并将它们绘制到屏幕上的次数。我们现在将扩展并讨论帧率的问题，并在整本书的其余部分进行讨论。
- en: The frame rate on my laptop might not always be constant. The bee might look
    like it is intermittently "boosting" its way across the screen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我的笔记本电脑上的帧率可能并不总是恒定的。蜜蜂可能看起来像是在屏幕上间歇性地“加速”。
- en: And of course, we want a wider audience for our game than just my laptop! Every
    PC's frame rate will vary, at least slightly. If you have an old PC, the bee will
    appear to be weighed down with lead, and if you have the latest gaming rig, it
    will probably be something of a blurry turbo bee.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望我们的游戏比我的笔记本电脑拥有更广泛的受众！每台 PC 的帧率都会有所不同，至少有一点不同。如果你有一台旧电脑，蜜蜂看起来就像是被铅压得沉重，而如果你有最新的游戏装备，它可能更像是一个模糊的涡轮蜜蜂。
- en: Fortunately, this problem is the same for every game, and SFML has provided
    a solution. The easiest way to understand this solution is to implement it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题对每个游戏都是一样的，SFML 已经提供了一个解决方案。理解这个解决方案的最简单方法就是实现它。
- en: The SFML frame rate solution
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFML 帧率解决方案
- en: 'We will now measure and use the frame rate to control our game. To get started
    with implementing this, add the following code just before the main game loop:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测量并使用帧率来控制我们的游戏。为了开始实现这一点，在主游戏循环之前添加以下代码：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the previous code, we declare an object of the `Clock` type and we name it
    `clock`. The class name starts with a capital letter and the object name (which
    we will actually use) starts with a lowercase letter. The object name is arbitrary,
    but `clock` seems like an appropriate name for, well, a clock. We will add some
    more time-related variables here soon as well.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们声明了一个`Clock`类型的对象，并将其命名为`clock`。类名以大写字母开头，而对象名（我们实际会使用）以小写字母开头。对象名是任意的，但`clock`似乎是一个合适的名字，因为，嗯，它是时钟。我们很快还会添加一些更多与时间相关的变量。
- en: 'Now, in the update section of our game code, add the following highlighted
    code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的游戏代码的更新部分，添加以下突出显示的代码：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `clock.restart()` function, as you might expect, restarts the clock. We
    want to restart the clock every frame so that we can time how long each and every
    frame takes. In addition, however, it returns the amount of time that has elapsed
    since the last time we restarted the clock.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期的那样，`clock.restart()`函数重新启动时钟。我们希望每帧都重新启动时钟，这样我们就可以测量每一帧和每一帧的持续时间。此外，它还返回自上次我们重新启动时钟以来经过的时间量。
- en: As a result of this, in the previous code, we are declaring an object of the
    `Time` type called `dt` and using it to store the value returned by the `clock.restart()`
    function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在之前的代码中，我们声明了一个名为`dt`的`Time`类型对象，并使用它来存储`clock.restart()`函数返回的值。
- en: Now, we have a `Time` object called `dt` that holds the amount of time that
    elapsed since the last time we updated the scene and restarted the clock. Maybe
    you can see where this is going? We will be using the elapsed time each frame
    to control how far we move the bee and the clouds.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为`dt`的`Time`对象，它包含了自上次我们更新场景和重新启动时钟以来经过的时间量。也许你能看到这会走向何方？我们将使用每一帧的经过时间来控制蜜蜂和云朵移动的距离。
- en: Let's add some more code to the game and use everything we have learned so far
    about manipulating variables, generating random numbers, the `if` keyword, and
    the `else` keyword. Then, we will see how we can overcome the framerate problem
    with a `Clock` object and `dt`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在游戏中添加更多代码，并使用我们迄今为止学到的关于操作变量、生成随机数、`if`关键字和`else`关键字的一切。然后，我们将看到如何使用`Clock`对象和`dt`克服帧率问题。
- en: Important note
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`dt` stands for **delta time**, which is the time between two updates.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`dt`代表**delta time**，即两次更新之间的时间。'
- en: Moving the clouds and the bee
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动云朵和蜜蜂
- en: Let's use the elapsed time since the last frame to breathe life into the bee
    and the clouds. This will solve the problem of having a consistent frame rate
    across different PCs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用上一帧以来的经过时间来为蜜蜂和云朵注入生命。这将解决在不同PC上保持一致帧率的问题。
- en: Giving life to the bee
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为蜜蜂注入生命
- en: 'The first thing we want to do is set up the bee at a certain height and a certain
    speed. We only want to do this when the bee is inactive. Due to this, we will
    wrap the following code in an `if` block. Examine and add the following highlighted
    code, and then we will discuss it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想做的事情是设置蜜蜂在某个高度和某个速度。我们只想在蜜蜂不活跃时这样做。因此，我们将以下代码包裹在一个`if`块中。检查并添加以下突出显示的代码，然后我们将讨论它：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, if the bee is not active, just like it won''t be when the game first starts,
    `if(!beeActive)` will be `true` and the preceding code will do the following things,
    in this order:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果蜜蜂不活跃，就像游戏一开始时不会那样，`if(!beeActive)`将是`true`，前面的代码将按以下顺序执行以下操作：
- en: Seed the random number generator.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化随机数生成器。
- en: Get a random number between 200 and 399 and assign the result to `beeSpeed`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个介于200和399之间的随机数，并将结果分配给`beeSpeed`。
- en: Seed the random number generator again.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次初始化随机数生成器。
- en: Get a random number between 500 and 999 and assign the result to a new `float`
    variable called `height`.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个介于500和999之间的随机数，并将结果分配给一个新的名为`height`的`float`变量。
- en: Set the position of the bee to `2000` on the x axis (just off-screen to the
    right) and to whatever `height` equals on the y axis.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将蜜蜂的位置设置在x轴上的`2000`（刚好在屏幕右侧之外）以及y轴上的任意`height`。
- en: Set `beeActive` to true.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`beeActive`设置为true。
- en: Important note
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that the `height` variable is the first variable we have ever declared
    inside the game loop. Furthermore, because it was declared inside an `if` block,
    it is actually "invisible" outside of the `if` block. This is fine for our use
    because once we have set the height of the bee, we don't need it anymore. This
    phenomenon that affects variables is called **scope**. We will explore this more
    fully in [*Chapter 4*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)*, Loops,
    Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics*.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`height` 变量是我们第一次在游戏循环内部声明的变量。此外，因为它是在 `if` 块内部声明的，所以实际上在 `if` 块外部是“不可见”的。这对我们的使用来说是可以的，因为一旦我们设置了蜜蜂的高度，我们就不再需要它了。这种现象影响变量的是称为
    **作用域** 的现象。我们将在 [*第 4 章*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110) 中更全面地探讨这个问题，循环、数组、开关、枚举和函数
    – 实现游戏机制。
- en: If we run the game, nothing will happen to the bee yet, but now the bee is active,
    we can write some code that runs when `beeActive` is `true`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行游戏，蜜蜂目前不会有任何变化，但现在蜜蜂是活跃的，我们可以编写一些在 `beeActive` 为 `true` 时运行的代码。
- en: 'Add the following highlighted code which, as you can see, executes whenever
    `beeActive` is `true`. This is because it follows with `else` after the `if(!beeActive)`
    block:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下突出显示的代码，如您所见，当 `beeActive` 为 `true` 时执行。这是因为它在 `if(!beeActive)` 块之后跟着 `else`：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the `else` block, the following things happen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `else` 块中，以下事情会发生。
- en: The bee's position is changed using the following criteria. The `setPosition`
    function uses the `getPosition` function to get the current horizontal coordinate
    of the bee. It then subtracts `beeSpeed * dt.asSeconds()` from that coordinate.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 蜜蜂的位置是通过以下标准改变的。`setPosition` 函数使用 `getPosition` 函数获取蜜蜂当前的横向坐标。然后从这个坐标中减去 `beeSpeed
    * dt.asSeconds()`。
- en: The `beeSpeed` variable value is many pixels per second and was randomly assigned
    in the previous `if` block. The value of `dt.asSeconds()` will be a fraction of
    1 that represents how long the previous frame of animation took.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`beeSpeed` 变量的值是每秒许多像素，并在之前的 `if` 块中随机分配。`dt.asSeconds()` 的值将是一个代表上一帧动画持续时间的
    1 的分数。'
- en: 'Let''s assume that the bee''s current horizontal coordinate is `dt.asSeconds`
    would be `beeSpeed` was set to the maximum `setPosition` uses for the horizontal
    coordinate is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 假设蜜蜂当前的横向坐标是 `dt.asSeconds`，如果将 `beeSpeed` 设置为最大值，`setPosition` 用于横向坐标的计算方式如下：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Therefore, the new position on the horizontal axis for the bee would be 999.9202\.
    We can see that the bee is very, very smoothly drifting to the left, at well under
    a pixel per frame. If the frame rate fluctuates, then the formula will produce
    a new value to suit. If we run the same code on a PC that only achieves 100 frames
    per second or a PC that achieves a million frames per second, the bee will move
    at the same speed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，蜜蜂在水平轴上的新位置将是 999.9202。我们可以看到蜜蜂非常、非常平滑地向左漂移，每帧不到一个像素。如果帧率波动，则公式将产生一个新值以适应。如果我们在一个每秒只能达到
    100 帧的 PC 上运行相同的代码，或者在一个每秒可以达到一百万帧的 PC 上运行，蜜蜂将以相同的速度移动。
- en: The `setPosition` function uses `getPosition().y` to keep the bee in exactly
    the same vertical coordinate throughout this cycle of being active.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPosition` 函数使用 `getPosition().y` 来确保蜜蜂在整个活跃周期内保持完全相同的垂直坐标。'
- en: 'The final part of the code in the `else` block we just added is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的 `else` 块中的代码的最后部分如下：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code tests, in each and every frame (when `beeActive` is `true`), whether
    the bee has disappeared off of the left-hand side of the screen. If the `getPosition`
    function returns less than -100, it will certainly be out of view of the player.
    When this occurs, `beeActive` is set to `false` and, on the next frame, a "new"
    bee will be set flying at a new random height and a new random speed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在每个帧（当 `beeActive` 为 `true` 时）测试蜜蜂是否已经从屏幕的左侧消失。如果 `getPosition` 函数返回值小于 -100，它肯定会超出玩家的视野。当这种情况发生时，`beeActive`
    被设置为 `false`，在下一帧，将设置一个“新”的蜜蜂以新的随机高度和新的随机速度飞行。
- en: Try running the game and watch our bee dutifully fly from right to left and
    then come back to the right again at a new height and speed. It's almost like
    a new bee every time.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行游戏并观察我们的蜜蜂尽职尽责地从右向左飞行，然后在新的高度和速度下再次回到右侧。几乎每次都像是一只新蜜蜂。
- en: Tip
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Of course, a real bee would stick around for ages and pester you while you're
    trying to concentrate on chopping the tree. We will make some smarter game characters
    in later projects.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一只真正的蜜蜂会长时间围绕你转，在你试图集中精力砍树时打扰你。我们将在后续的项目中制作一些更智能的游戏角色。
- en: Now, we will get the clouds moving in a very similar way.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将以非常相似的方式使云彩移动。
- en: Blowing the clouds
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 吹散云彩
- en: 'The first thing we want to do is set up the first cloud at a certain height
    and a certain speed. We only want to do this when the cloud is inactive. Consequently,
    we will wrap the code that follows in an `if` block. Examine and add the following
    highlighted code, just after the code we added for the bee, and then we will discuss
    it. It is almost identical to the code we used on the bee:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要做的是将第一朵云设置在特定的高度和速度。我们只想在云彩不活跃时这样做。因此，我们将接下来的代码包裹在 `if` 块中。检查并添加以下突出显示的代码，就在我们为蜜蜂添加的代码之后，然后我们将讨论它。它与我们在蜜蜂上使用的代码几乎相同：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The only difference between the code we have just added and the bee-related
    code is that we work on a different sprite and use different ranges for our random
    numbers. Also, we multiply by ten (`* 10` ) to the result returned by `time(0)`
    so that we are always guaranteed to get a different seed for each of the clouds.
    When we code the other cloud movement next, you will see that we use `* 20` and
    `* 30`, respectively.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码与与蜜蜂相关的代码之间的唯一区别是我们处理不同的精灵，并使用不同的随机数范围。此外，我们将 `time(0)` 返回的结果乘以十 (`*
    10` )，以确保每个云彩都能得到不同的种子。当我们编写其他云彩移动时，你会看到我们分别使用 `* 20` 和 `* 30`。
- en: 'Now, we can act when the cloud is active. We will do so in the `else` block.
    Like the `if` block, the code is identical to that of the bee-related code, except
    that all of the code works on the cloud and not the bee:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当云彩活跃时，我们可以采取行动。我们将在 `else` 块中这样做。与 `if` 块一样，代码与与蜜蜂相关的代码相同，只是所有代码都针对云彩而不是蜜蜂：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we know what to do, we can duplicate the same code for the second
    and third clouds. Add the following highlighted code, which handles the second
    and third clouds, immediately after the code for the first cloud:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了该怎么做，我们可以为第二和第三朵云复制相同的代码。在第一朵云的代码之后立即添加以下突出显示的代码，以处理第二和第三朵云：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, you can run the game and the clouds will randomly and continuously drift
    across the screen. The bee will also buzz from right to left before respawning
    once more back on the right. The following screenshot shows what we''ve achieved
    in this chapter:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行游戏，云彩将随机且连续地在屏幕上飘动。蜜蜂也会在重生之前从右向左嗡嗡作响。以下截图显示了本章我们所取得的成果：
- en: '![](img/B14278_02_02.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_02_02.jpg)'
- en: Tip
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Does all of this cloud and bee handling seem a little bit repetitious? We will
    see how we could save lots of typing and make our code more readable as, in C++,
    there are ways of handling multiple instances of the same type of variable or
    object. One such way is called **arrays**, and we will learn about them in [*Chapter
    4*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)*, Loops, Arrays, Switches,
    Enumerations, and Functions – Implementing Game Mechanics*. At the end of this
    project, once we have learned about arrays, we will discuss how we can improve
    our cloud code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些云彩和蜜蜂的处理看起来有点重复吗？我们将看到如何节省大量输入并使我们的代码更易于阅读，因为在 C++ 中，有处理相同类型变量或对象多个实例的方法。其中一种方法称为
    **数组**，我们将在 [*第四章*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110) 中学习它们，即循环、数组、开关、枚举和函数
    – 实现游戏机制。在这个项目的最后，一旦我们学习了数组，我们将讨论如何改进我们的云彩代码。
- en: Take a look at a few frequently asked questions related to the topics in this
    chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 查看与本章主题相关的一些常见问题。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that a variable is a named storage location in memory
    in which we can keep values of a specific type. The types include `int`, `float`,
    `double`, `bool`, `String`, and `char`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到变量是内存中的一个命名存储位置，我们可以在这里存储特定类型的值。这些类型包括 `int`、`float`、`double`、`bool`、`String`
    和 `char`。
- en: We can declare and initialize all of the variables we need to store the data
    for our game. Once we have our variables, we can manipulate them using the arithmetic
    and assignment operators, as well as use them in tests with the logical operators.
    Used in conjunction with the `if` and `else` keywords, we can branch our code
    depending on the current situation in the game.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明和初始化所有存储游戏数据的变量。一旦我们有了这些变量，我们可以使用算术和赋值运算符来操作它们，并在逻辑运算符的测试中使用它们。与 `if`
    和 `else` 关键字结合使用，我们可以根据游戏中的当前情况分支我们的代码。
- en: Using all of this new knowledge, we animated some clouds and a bee. In the next
    chapter, we will use these skills some more to add a **Heads Up Display** (**HUD**)
    and add more input options for the player, as well as represent time visually
    using a time-bar.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 利用所有这些新的知识，我们制作了一些云朵和一只蜜蜂的动画。在下一章中，我们将运用这些技能来添加**抬头显示**（**HUD**）和为玩家添加更多输入选项，以及使用时间条来直观地表示时间。
- en: FAQ
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FAQ
- en: Q) Why do we set the bee to inactive when it gets to -100? Why not just zero
    since zero is the left-hand side of the window?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 为什么当蜜蜂到达-100时我们将其设置为非活动状态？为什么不直接设置为0，因为0是窗口的左侧？
- en: A) The bee graphic is 60 pixels wide and its origin is at the top left pixel.
    As a result, when the bee is drawn with its origin at x equals zero, the entire
    bee graphic is still on screen for the player to see. By waiting until it is at
    -100, we can be sure it is out of the player's view.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: A) 蜜蜂图形的宽度是60像素，其原点位于左上角的像素。因此，当蜜蜂以其原点在x等于零的位置被绘制时，整个蜜蜂图形仍然在屏幕上，玩家可以看到。通过等待它到达-100，我们可以确保它已经超出了玩家的视野。
- en: Q) How do I know how fast my game loop is?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我如何知道我的游戏循环运行得多快？
- en: A) If you have a modern NVIDIA graphics card, you might be able to already by
    configuring your GeForce Experience overlay to show the frame rate. To measure
    this explicitly using our own code, however, we will need to learn a few more
    things. We will add the ability to measure and display the current frame rate
    in [*Chapter 5*](B14278_05_Final_AG_ePub.xhtml#_idTextAnchor138)*, Collisions,
    Sound, and End Conditions – Making the Game Playable*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: A) 如果你有一张现代的NVIDIA显卡，你可能已经可以通过配置你的GeForce Experience叠加层来显示帧率。然而，要使用我们自己的代码明确地测量这个值，我们还需要了解一些其他的事情。我们将在[*第5章*](B14278_05_Final_AG_ePub.xhtml#_idTextAnchor138)*，碰撞、声音和结束条件
    – 使游戏可玩*中添加测量和显示当前帧率的功能。
