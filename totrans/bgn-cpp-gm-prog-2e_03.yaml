- en: '*Chapter 2*: Variables, Operators, and Decisions – Animating Sprites'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will do quite a bit more drawing on the screen and, to achieve
    this, we will need to learn about some of the basics of C++. We will learn how
    to use variables to remember and manipulate values, and we will begin to add more
    graphics to the game. As this chapter progresses, we will find out how we can
    manipulate these values to animate the graphics. These values are known as variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what is in store:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Learning all about C++ variables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing how to manipulate the values stored in variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a static tree graphic, ready for the player to chop away at
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing and animating a bee and three clouds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ variables
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Variables** are the way that our C++ games store and manipulate values/data.
    If we want to know how much health the player has, we need a variable. Perhaps
    you want to know how many zombies are left in the current wave. That is a variable
    as well. If you need to remember the name of the player who got a high score,
    you guessed it—we need a variable for that. Is the game over or still playing?
    Yes, that''s a variable too.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Variables are named identifiers for locations in the memory of the PC. The memory
    of the PC is where computer programs are stored as they are being executed. So,
    we might name a variable `numberOfZombies` and that variable could refer to a
    place in memory that stores a value to represent the number of zombies that are
    left in the current wave.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The way that computer systems address locations in memory is complex. Programming
    languages use variables to give us a human-friendly way to manage our data in
    that memory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The small amount we have just mentioned about variables implies that there must
    be different **types** of variable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Types of variables
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a wide variety of C++ variable types (see the next tip about variables
    in a couple of pages). It would easily be possible to spend an entire chapter
    discussing them. What follows is a table of the most commonly used types of variable
    in this book. Then, in the next section, we will look at how to use each of these
    variable types:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_02_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: The compiler must be told what type of variable it is so that it can allocate
    the right amount of memory for it. It is good practice to use the best and most
    appropriate type for each variable you use. In practice, however, you will often
    get away with promoting a variable. Perhaps you need a floating-point number with
    just five significant digits? The compiler won't complain if you store it as a
    `double`. However, if you tried to store a `float` or a `double` in an `int`,
    it will `int`. As we progress through this book, I will make it plain what the
    best variable type to use in each case is, and we will even see a few instances
    where we deliberately convert/cast between variable types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: A few extra details worth noticing in the preceding table include the `f` postfix
    next to all of the `float` values. This `f` postfix tells the compiler that the
    value is a `float` type, not `double`. A floating-point value without the `f`
    prefix is assumed to be `double`. See the next tip about variables for more about
    this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, there are many more types. If you want to find out
    more about types, see the next tip about variables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: User-defined types
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: User-defined types are way more advanced than the types we have just seen. When
    we talk about user-defined types in C++, we are usually talking about classes.
    We briefly talked about classes and their related objects in the previous chapter.
    We would write code in a separate file, sometimes two. We are then able to declare,
    initialize, and use them. We will leave how we define/create our own types until
    [*Chapter 6*](B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154)*, Object-Oriented
    Programming – Starting the Pong Game*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing variables
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we know that variables are for storing the data/values that our games
    need in order to work. For example, a variable would represent the number of lives
    a player has or the player's name. We also know that there is a wide selection
    of different types of values that these variables can represent, such as `int`,
    `float`, `bool`, and so on. Of course, what we haven't seen yet is how we would
    actually go about using a variable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: There are two stages when it comes to creating and preparing a new variable.
    These stages are called **declaration** and **initialization**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can declare variables in C++ like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we have written the code to declare a variable, it exists and is ready
    to be used in our code. However, we will usually want to give the variable an
    appropriate value, which is where initialization comes in.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Initializing variables
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have declared the variables with meaningful names, we can initialize
    those same variables with appropriate values, like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point, the variable exists and holds a specific value. Soon, we will
    see how we can change, test, and respond to these values. Next, we will see that
    we can combine declaring and initializing into one step.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing in one step
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When it suits us, we can combine the declaration and initialization steps into
    one. Sometimes, we know what value a variable must start the program with, and
    declaring and initializing in one step is appropriate. Often, we won''t, and we
    will first declare the variable and then initialize it later in the program, like
    so:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Variables tip
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'As promised, here is the tip on variables. If you want to see a complete list
    of C++ types, then check out this web page: [http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm](http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm).
    If you want a deeper discussion on `float`, `double`, and the `f` postfix, then
    read this: [http://www.cplusplus.com/forum/beginner/24483/](http://www.cplusplus.com/forum/beginner/24483/).
    Finally, if you want to know the ins and outs of the ASCII character codes, then
    there is some more information here: [http://www.cplusplus.com/doc/ascii/](http://www.cplusplus.com/doc/ascii/).
    Note that these links are for the extra curious reader and we have already discussed
    enough in order to proceed.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, we need to make sure that a value can never be changed. To achieve
    this, we can declare and initialize a `const` keyword:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is convention to declare constants in all uppercase. The values of the preceding
    constants can never be altered. We will see some constants in action in [*Chapter
    4*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)*, Loops, Arrays, Switches,
    Enumerations, and Functions – Implementing Game Mechanics*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing user-defined types
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already seen examples of how we can declare and initialize some SFML
    defined types. It is because of the way that we can create/define these types
    (classes) so flexibly that the way we declare and initialize them is also so varied.
    Here are a couple of reminders for declaring and initializing user-defined types
    from the previous chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an object of the `VideoMode` type called `vm` and initialize it with
    two `int` values, `1920` and `1080`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create an object of the `Texture` type called `textureBackground`, but don''t
    do any initialization:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that it is possible (in fact, very likely) that even though we are not
    suggesting any specific values with which to initialize `textureBackground`, some
    setup of variables may take place internally. Whether or not an object needs/has
    the option of giving initialization values at this point is entirely dependent
    on how the class is coded and is almost infinitely flexible. This further suggests
    that, when we get to write our own classes, there will be some complexity. Fortunately,
    this also means we will have significant power to design our types/classes to
    be just what we need to make our games! Add this huge flexibility to the power
    of the SFML designed classes and the potential for our games is almost limitless.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: We will see a few more user created types/classes provided by SFML in this chapter
    too, and loads more throughout this book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen that a variable is a named location in the computer's memory
    and that a variable can be a simple integer through to a more powerful object.
    Now that we know we can initialize these variables, we will look at how we can
    manipulate the values they hold.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating variables
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we know exactly what variables are, the main types they can be,
    and how to declare and initialize them. We still can't do that much with them,
    however. We need to manipulate our variables; add them; take them away; and multiply,
    divide, and test them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: First, we will deal with how we can manipulate them and then we will look at
    how and why we test them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: C++ arithmetic and assignment operators
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to manipulate variables, C++ has a range of **arithmetic operators**
    and **assignment operators**. Fortunately, most arithmetic and assignment operators
    are quite intuitive to use and those that aren''t are quite easy to explain. To
    get us started, let''s look at a table of arithmetic operators, followed by a
    table of assignment operators, all of which we will regularly use throughout this
    book:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_02_2.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'And now for the assignment operators:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_02_3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: Important note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Technically, all of these operators, except for `=`, `--`, and `++`, are called
    **compound assignment operators** because they comprise more than one operator.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen a good range of arithmetic and assignment operators, we
    can actually look at how we can manipulate our variables by combining operators,
    variables, and values to form **expressions**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Getting things done with expressions
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Expressions** are the result of combining variables, operators, and values.
    Using expressions, we can arrive at a result. Furthermore, as we will soon see,
    we can use an expression in a test. These tests can be used to decide what our
    code should do next. First, let''s look at some simple expressions we might see
    in our game code. Here is one example of a simple expression:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, the value held in the `score` variable is used to change
    the value in the `hiScore` variable. The two variables now hold the same value,
    but note that they are still separate and distinct variables (places in memory).
    This would likely be just what we need when the player beats a high score. Here
    is another example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s take a look at the addition operator, which used in conjunction with
    the assignment operator:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, the values held by `aliensShot` and `wavesCleared` are
    added together using the addition operator and then the result of the addition
    is assigned to the `score` variable. Now, let''s take a look at the following
    code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that it is perfectly acceptable to use the same variable on both sides
    of an operator. In the preceding code, 100 is added to the value held by the `score`
    variable and then this new value is then assigned back into `score`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the subtraction operator in conjunction with the assignment operator.
    The following code subtracts the value on the right-hand side of the subtraction
    operator from the value on the left. It is usually used in conjunction with the
    assignment operator, perhaps like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It can also be used like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will see how we might use the division operator. The following code
    divides the number on the left by the number on the right. Again, it is usually
    used with the assignment operator, like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It can also be used like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Obviously, in the previous example, the `recycledValueOfBlock` variable will
    need to be of the `float` type to accurately store the answer to a calculation
    like that.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps unsurprisingly, we could use the multiplication operator like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It can also be used like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Important note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, have you ever wondered how C++ got its name? C++ is an extension
    of the C language. Its inventor, **Bjarne Stroustrup**, originally called it "C
    with classes", but the name evolved. If you are interested, you can read the story
    of C++ at [http://www.cplusplus.com/info/history/](http://www.cplusplus.com/info/history/).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the increment operator in action. This is a neat way to add
    1 to the value of one of our game's variables.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code gives the same result as the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The decrement operator, `--`, is, you guessed it, a quick way to subtract 1
    from something, like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the same as doing the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s look at a few more operators in action and then we can get back to building
    the Timber!!! game. The addition, subtraction, multiplication, and division operators
    each have a related operator that combines their primary function (adding, subtracting,
    and so on) with assignment. They allow us to use more concise code when we want
    to perform the primary function of the operator, followed by assignment. Have
    a look at the four examples (one for each operator) that follow:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding four examples, we can see that the `*=`, `/=`, `+=`, and `-=`
    operators can be used to shorten the syntax when we want to use one of the four
    arithmetic operators followed by an assignment. We will do this quite a bit throughout
    this book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: It's time to add some more sprites to our game.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Adding clouds, a tree, and a buzzing bee
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add clouds, a tree, and a buzzing bee to our Timber!!!
    game. First, we will add a tree. This is going to be easy. The reason for this
    is because the tree doesn't move. We will use the same procedure that we used
    in the previous chapter when we drew the background. The bee and the clouds will
    also be easy to draw in their starting positions, but we will need to combine
    what we have just learned about manipulating variables with some new C++ topics
    to make them move.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the tree
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get ready to draw the tree! Add the following highlighted code. Notice
    the unhighlighted code, which is the code we have already written. This should
    help you to identify that the new code should be typed immediately after we set
    the position of the background but before the start of the main game loop. We
    will provide a recap regarding what is going on in the new code after we have
    added it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is what the following five lines of code (excluding the comment) do:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an object of the `Texture` type called `textureTree`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we load a graphic into the texture from the `tree.png` graphics file.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we declare an object of the `Sprite` type called `spriteTree`
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After, we associate `textureTree` with `spriteTree`. Whenever we draw `spriteTree`,
    it will show the `textureTree` texture, which is a neat tree graphic.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we set the position of the tree using the coordinates `810` on the
    *x* axis and `0` on the *y* axis.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tree sprite is ready to draw, along with the tree texture. Let's move on
    to the bee object, which is handled in an almost identical manner.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the bee
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Preparing the bee sprite is very similar but not identical to preparing the
    tree sprite. The difference between the following code and the tree code is small
    but important. Since the bee needs to move, we also declare two bee-related variables.
    Add the following highlighted code and see whether you can work out how we might
    use the `beeActive` and `beeSpeed` variables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We create a bee in the same way we created a background and a tree. We use a
    `Texture`, a `Sprite`, and associate the two. Note that, in the previous bee code,
    there's some new code we haven't seen before. There is a `bool` variable for determining
    whether the bee is active. Remember that a `bool` variable can be either `true`
    or `false`. We initialize `beeActive` to `false` for now.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a new `float` variable called `beeSpeed`. This will hold the
    speed in pixels per second that our bee will fly across the screen at.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Soon, we will see how we use these two new variables to move the bee. Before
    we do, let's set up some clouds in an almost identical manner.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the clouds
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following highlighted code. Study the new code and try and work out
    what it will do:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The only thing about the code we have just added that might seem a little odd
    is that we have only one object of the `Texture` type. It is completely normal
    for multiple `Sprite` objects to share a texture. Once a `Texture` is stored in
    GPU memory, it can be associated with a `Sprite` object very quickly. It is only
    the initial loading of the graphic in the `loadFromFile` code that is a relatively
    slow operation. Of course, if we wanted three different shaped clouds, then we
    would need three textures.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the minor texture issue, the code we have just added is nothing new
    compared to the bee. The only difference is that there are three cloud sprites,
    three `bool` variables to determine whether each cloud is active, and three `float`
    variables to hold the speed for each cloud.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, all of the sprites and variables have been prepared. We can now
    move on to drawing them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the tree, the bee, and the clouds
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we can draw them all to the screen by adding the following highlighted
    code in the drawing section:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Drawing the three clouds, the bee, and the tree is done in the same way that
    the background was drawn. Note, however, the order in which we draw the different
    objects to the screen. We must draw all of the graphics after the background,
    or they will be covered, and we must draw the clouds before the tree, or they
    will look a bit odd drifting in front of the tree. The bee would look OK either
    in front or behind the tree. I opted to draw the bee in front of the tree so that
    it can try and distract our lumberjack, a bit like a real bee might.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Run Timber!!! and gaze in awe at the tree, three clouds, and a bee that… don''t
    do anything! They look like they are lining up for a race; a race where the bee
    has to go backward:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_02_01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Using what we know about operators, we could try and move the graphics we have
    just added, but there's a problem. The problem is that real clouds and bees move
    in a non-uniform manner. They don't have a set speed or location, with these elements
    determined by factors such as wind speed or how much of a hurry the bee might
    be in. To the casual observer, the path they take and their speed appear to be
    *random*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Random numbers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Random numbers** are useful for lots of reasons in games—perhaps determining
    what card the player is dealt or how much damage within a certain range is subtracted
    from an enemy''s health. We will now learn how to generate random numbers to determine
    the starting location and speed of the bee and the clouds.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers in C++
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To generate random numbers, we will need to use some more C++ functions—two
    more, to be precise. Don't add any code to the game yet. Let's just look at the
    syntax and the steps that are required with some hypothetical code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Computers can''t genuinely pick random numbers. They can only use **algorithms**/**calculations**
    to pick a number that *appears* to be random. So that this algorithm doesn''t
    constantly return the same value, we must **seed** the random number generator.
    The seed can be any integer number, although it must be a different seed each
    time you require a unique random number. Look at the following code, which seeds
    the random number generator:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code gets the time from the PC using the `time` function, that
    is, `time(0)`. The call to the `time` function is enclosed as the value to be
    sent to the `srand` function. The result of this is that the current time is used
    as the seed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The previous code is made to look a little more complicated because of the slightly
    unusual looking `(int)` syntax. What this does is convert/cast the value that's
    returned from `time` into an `int`. This is required by the `srand` function in
    this situation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The term that's used to describe a conversion from one type to another is **cast**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in summary, the previous line of code does the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Gets the time using `time`
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converts it into an `int`
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends this resulting value to `srand`, which seeds the random number generator
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time is, of course, always changing. This makes the `time` function a great
    way to seed the random number generator. However, think about what might happen
    if we seed the random number generator more than once and in such quick succession
    that `time` returns the same value. We will see and solve this problem when we
    animate our clouds.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 时间当然总是在变化的。这使得`time`函数成为随机数生成器的一个很好的种子方式。然而，想想如果我们多次并且快速地种子随机数生成器，而`time`返回相同的值会发生什么。当我们动画化我们的云时，我们将看到并解决这个问题。
- en: 'At this stage, we can create the random number, between a range, and save it
    to a variable for later use, like so:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以创建一个随机数，在某个范围内，并将其保存到变量中供以后使用，如下所示：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice the odd-looking way we assign a value to `number`. By using the Modulo
    operator (`%`) and the value of `100`, we are asking for the remainder, after
    dividing the number returned from `rand`, by 100\. When you divide by 100, the
    highest number you can possibly have as a remainder is 99\. The lowest number
    possible is 0\. Therefore, the previous code will generate a number between 0
    and 99 inclusive. This knowledge will be useful for generating a random speed
    and starting location for our bees and clouds.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们给`number`赋值的方式看起来很奇怪。通过使用模运算符（`%`）和`100`的值，我们是在询问从`rand`返回的数字除以100后的余数。当你除以100时，你作为余数的最大可能值是99。可能的最小值是0。因此，之前的代码将生成一个介于0到99（包括0和99）之间的数字。这个知识将对我们生成蜜蜂和云的随机速度和起始位置很有用。
- en: But before we can implement our random bees and clouds, we will need to learn
    how to make decisions in C++.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们能够实现我们的随机蜜蜂和云之前，我们需要学习如何在C++中做出决策。
- en: Making decisions with if and else
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if和else进行决策
- en: 'The C++ `if` in action in the previous chapter when we detected whether the
    player had pressed the *Esc* key each frame:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们在每一帧检测玩家是否按下了*Esc*键时，C++的`if`运算符的实际应用：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So far, we have seen how we can use arithmetic and assignment operators to create
    expressions. Now, we will look at some new operators.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们可以如何使用算术和赋值运算符来创建表达式。现在，我们将看看一些新的运算符。
- en: Logical operators
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: '**Logical operators** are going to help us to make decisions by building expressions
    that can be tested for a value of either true or false. At first, this might seem
    like quite a narrow choice and insufficient for the kind of choices that might
    be needed in an advanced PC game. Once we dig a little deeper, we will see that
    we can make all of the required decisions we will need with just a few of the
    logical operators.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑运算符**将帮助我们通过构建可以测试为真或假的值的表达式来做出决策。一开始，这可能会显得选择很有限，不足以满足高级PC游戏中可能需要的决策。一旦我们深入研究，我们将看到我们只需要几个逻辑运算符就可以做出所有需要的决策。'
- en: 'Here is a table of the most useful logical operators. Look at them and the
    associated examples, and then we will see how we can put them to use:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个最有用的逻辑运算符表。看看它们和相关的例子，然后我们将看看我们如何使用它们：
- en: '![](img/B14278_02_4.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_02_4.jpg)'
- en: Let's take a look at the C++ `if` and `else` keywords, which will allow us to
    put all of these logical operators to good use.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看C++的`if`和`else`关键字，这将使我们能够充分利用这些逻辑运算符。
- en: C++ if and else
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++的if和else
- en: Let's make the previous examples less abstract. Meet the C++ `if` and a few
    operators along with a small story to demonstrate their use. Next follows a made-up
    military situation that will hopefully be less abstract than the previous examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把之前的例子变得更具体一些。认识一下C++的`if`运算符和一些运算符，以及一个小故事来展示它们的使用。接下来是一个虚构的军事情况，希望它比之前的例子更具体。
- en: If they come over the bridge, shoot them!
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果他们过桥，就射击他们！
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a C++ program to convey his last orders for after
    he has died. The troops must hold one side of a bridge while waiting for reinforcements.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 舰长正在死去，并且知道他剩下的下属经验不足，他决定编写一个C++程序来传达他死后最后的命令。部队必须守住桥梁的一侧，等待增援。
- en: 'The first command the captain wants to make sure his troops understand is this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 舰长想要确保他的部队理解的第一条命令是：
- en: '"If they come over the bridge, shoot them!"'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '"如果他们过桥，就射击他们！"'
- en: So, how do we simulate this situation in C++? We need a `bool` variable, `isComingOverBridge`.
    The following bit of code assumes that the `isComingOverBridge` variable has been
    declared and initialized to either `true` or `false`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在C++中模拟这种情况？我们需要一个`bool`变量`isComingOverBridge`。以下代码片段假设`isComingOverBridge`变量已经被声明并初始化为`true`或`false`。
- en: 'We can then use `if` like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用`if`：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the `isComingOverBridge` variable is equal to `true`, the code inside the
    opening and closing curly braces `{...}` will run. If not, the program continues
    after the `if` block and without running the code within it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isComingOverBridge`变量等于`true`，则在大括号`{...}`内的代码将运行。如果不等于，则程序在`if`块之后继续执行，而不运行其中的代码。
- en: Shoot them … or else do this instead
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射击他们……或者做这个代替
- en: The captain also wants to tell his troops to stay put if the enemy is not coming
    over the bridge.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 指挥官还希望告诉他的士兵，如果敌人没有越过桥梁，他们应该原地待命。
- en: Now, we can introduce another C++ keyword, `if` does `true`, we can use `else`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以引入另一个C++关键字，如果`if`为`true`，我们可以使用`else`。
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we could write the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果敌人没有越过桥梁，我们可以编写以下代码来告诉士兵们原地待命：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The captain then realized that the problem wasn''t as simple as he first thought.
    What if the enemy comes over the bridge, but has too many troops? His squad would
    be overrun and slaughtered. So, he came up with the following code (we''ll use
    some variables as well this time):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，指挥官意识到问题并不像他最初想的那么简单。如果敌军越过桥梁，但人数过多怎么办？他的小队会被围攻并屠杀。因此，他想出了以下代码（这次我们也会使用一些变量）：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code has three possible paths of execution. First, if the enemy
    is coming over the bridge and the friendly troops are greater in number:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有三个可能的执行路径。首先，如果敌军越过桥梁且友军数量更多：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second occurs if the enemy troops are coming over the bridge but outnumber
    the friendly troops:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是敌军越过桥梁，但数量超过友军：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then, the third and final possible outcome, which will execute if neither of
    the others is `true`, is captured by the final `else`, without an `if` condition.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第三种也是最后一种可能的输出，如果没有其他任何一个是`true`，则由最后的`else`捕获，而不需要`if`条件。
- en: Reader challenge
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读者挑战
- en: 'Can you spot a flaw with the preceding code? One that might leave a bunch of
    inexperienced troops in complete disarray? The possibility of the enemy troops
    and friendly troops being exactly equal in number has not been handled explicitly
    and would therefore be handled by the final `else`. The final `else` is meant
    for when there are no enemy troops. I guess any self-respecting captain would
    expect his troops to fight in this situation. He could change the first `if` statement
    to accommodate this possibility, like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否发现前面代码中的缺陷？一个可能会让一群缺乏经验的士兵陷入混乱的缺陷？没有明确处理敌军和友军数量完全相等的情况，因此这种情况将由最后的`else`处理。最后的`else`是为了处理没有敌军的情况。我想任何有自尊的指挥官都会期望他的士兵在这种情况下战斗。他可以将第一个`if`语句改为适应这种情况，如下所示：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, the captain''s last concern was that if the enemy came over the bridge
    waving the white flag of surrender and were promptly slaughtered, then his men
    would end up as war criminals. The C++ code that was needed was obvious. Using
    the `wavingWhiteFlag` Boolean variable, he wrote this test:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，指挥官最后的担忧是，如果敌军挥舞着白旗投降并迅速被屠杀，那么他的士兵最终会成为战争罪犯。所需的C++代码很明显。使用`wavingWhiteFlag`布尔变量，他编写了以下测试：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But where to put this code was less clear. In the end, the captain opted for
    the following nested solution and changed the test for `wavingWhiteFlag` to logical
    NOT, like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但将这段代码放在哪里并不那么清楚。最后，指挥官选择了以下嵌套解决方案，并将`wavingWhiteFlag`的测试改为逻辑非，如下所示：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This demonstrates that we can nest `if` and `else` statements inside one another
    to create quite deep and detailed decisions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了我们可以将`if`和`else`语句嵌套在一起，以创建相当深入和详细的决策。
- en: We could go on making more and more complicated decisions with `if` and `else`
    but what we have seen is more than enough as an introduction. It is probably worth
    pointing out, that often, there is more than one way to arrive at a solution to
    a problem. The *right* way will usually be the way that solves the problem in
    the clearest and simplest manner.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`if`和`else`继续做出越来越复杂的决策，但我们所看到的已经足够作为入门了。也许值得指出的是，通常，解决问题有不止一种方法。*正确*的方法通常是以最清晰、最简单的方式解决问题的方法。
- en: We are getting closer to having all of the C++ knowledge we need to be able
    to animate our clouds and bee. We have one final animation issue to discuss and
    then we can get back to the game.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Timing
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can move the bee and the clouds, we need to consider timing. As we
    already know, the main game loop executes repeatedly until the player presses
    the *Escape* key.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: We have also learned that C++ and SFML are exceptionally fast. In fact, my aging
    laptop executes a simple game loop (like the current one) at around five thousand
    times per second.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The frame rate problem
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's consider the speed of the bee. For the purpose of discussion, we could
    pretend that we are going to move it at 200 pixels per second. On a screen that
    is 1,920 pixels wide, it would take, very approximately, 10 seconds to cross the
    entire width, because 10 x 200 is 2,000 (near enough to 1,920).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we know that we can position any of our sprites with `setPosition(...,...)`.
    We just need to put the x and the y coordinates in the parentheses.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to setting the position of a sprite, we can also get the current
    position of a sprite. To get the horizontal x coordinate of the bee for example,
    we would use the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The current x coordinate of the bee is now stored in `currentPosition`. To
    move the bee to the right, we need to add the appropriate fraction of 200 (our
    intended speed) divided by 5,000 (the approximate frames per second on my laptop)
    to `currentPosition`, like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we would use `setPosition` to move our bee. It would smoothly move from
    left to right by 200 divided by 5,000 pixels each frame. But there are two big
    problems with this approach.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Frame rate is the number of times per second that our game loop is processed.
    That is, the number of times that we handle the players input, update the game
    objects, and draw them to the screen. We will expand on and discuss matters of
    frame rate now and throughout the rest of this book.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The frame rate on my laptop might not always be constant. The bee might look
    like it is intermittently "boosting" its way across the screen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: And of course, we want a wider audience for our game than just my laptop! Every
    PC's frame rate will vary, at least slightly. If you have an old PC, the bee will
    appear to be weighed down with lead, and if you have the latest gaming rig, it
    will probably be something of a blurry turbo bee.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this problem is the same for every game, and SFML has provided
    a solution. The easiest way to understand this solution is to implement it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The SFML frame rate solution
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now measure and use the frame rate to control our game. To get started
    with implementing this, add the following code just before the main game loop:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the previous code, we declare an object of the `Clock` type and we name it
    `clock`. The class name starts with a capital letter and the object name (which
    we will actually use) starts with a lowercase letter. The object name is arbitrary,
    but `clock` seems like an appropriate name for, well, a clock. We will add some
    more time-related variables here soon as well.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们声明了一个`Clock`类型的对象，并将其命名为`clock`。类名以大写字母开头，而对象名（我们实际会使用）以小写字母开头。对象名是任意的，但`clock`似乎是一个合适的名字，因为，嗯，它是时钟。我们很快还会添加一些更多与时间相关的变量。
- en: 'Now, in the update section of our game code, add the following highlighted
    code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的游戏代码的更新部分，添加以下突出显示的代码：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `clock.restart()` function, as you might expect, restarts the clock. We
    want to restart the clock every frame so that we can time how long each and every
    frame takes. In addition, however, it returns the amount of time that has elapsed
    since the last time we restarted the clock.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期的那样，`clock.restart()`函数重新启动时钟。我们希望每帧都重新启动时钟，这样我们就可以测量每一帧和每一帧的持续时间。此外，它还返回自上次我们重新启动时钟以来经过的时间量。
- en: As a result of this, in the previous code, we are declaring an object of the
    `Time` type called `dt` and using it to store the value returned by the `clock.restart()`
    function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在之前的代码中，我们声明了一个名为`dt`的`Time`类型对象，并使用它来存储`clock.restart()`函数返回的值。
- en: Now, we have a `Time` object called `dt` that holds the amount of time that
    elapsed since the last time we updated the scene and restarted the clock. Maybe
    you can see where this is going? We will be using the elapsed time each frame
    to control how far we move the bee and the clouds.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为`dt`的`Time`对象，它包含了自上次我们更新场景和重新启动时钟以来经过的时间量。也许你能看到这会走向何方？我们将使用每一帧的经过时间来控制蜜蜂和云朵移动的距离。
- en: Let's add some more code to the game and use everything we have learned so far
    about manipulating variables, generating random numbers, the `if` keyword, and
    the `else` keyword. Then, we will see how we can overcome the framerate problem
    with a `Clock` object and `dt`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在游戏中添加更多代码，并使用我们迄今为止学到的关于操作变量、生成随机数、`if`关键字和`else`关键字的一切。然后，我们将看到如何使用`Clock`对象和`dt`克服帧率问题。
- en: Important note
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`dt` stands for **delta time**, which is the time between two updates.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`dt`代表**delta time**，即两次更新之间的时间。'
- en: Moving the clouds and the bee
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动云朵和蜜蜂
- en: Let's use the elapsed time since the last frame to breathe life into the bee
    and the clouds. This will solve the problem of having a consistent frame rate
    across different PCs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用上一帧以来的经过时间来为蜜蜂和云朵注入生命。这将解决在不同PC上保持一致帧率的问题。
- en: Giving life to the bee
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为蜜蜂注入生命
- en: 'The first thing we want to do is set up the bee at a certain height and a certain
    speed. We only want to do this when the bee is inactive. Due to this, we will
    wrap the following code in an `if` block. Examine and add the following highlighted
    code, and then we will discuss it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想做的事情是设置蜜蜂在某个高度和某个速度。我们只想在蜜蜂不活跃时这样做。因此，我们将以下代码包裹在一个`if`块中。检查并添加以下突出显示的代码，然后我们将讨论它：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, if the bee is not active, just like it won''t be when the game first starts,
    `if(!beeActive)` will be `true` and the preceding code will do the following things,
    in this order:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果蜜蜂不活跃，就像游戏一开始时不会那样，`if(!beeActive)`将是`true`，前面的代码将按以下顺序执行以下操作：
- en: Seed the random number generator.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化随机数生成器。
- en: Get a random number between 200 and 399 and assign the result to `beeSpeed`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个介于200和399之间的随机数，并将结果分配给`beeSpeed`。
- en: Seed the random number generator again.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次初始化随机数生成器。
- en: Get a random number between 500 and 999 and assign the result to a new `float`
    variable called `height`.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个介于500和999之间的随机数，并将结果分配给一个新的名为`height`的`float`变量。
- en: Set the position of the bee to `2000` on the x axis (just off-screen to the
    right) and to whatever `height` equals on the y axis.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将蜜蜂的位置设置在x轴上的`2000`（刚好在屏幕右侧之外）以及y轴上的任意`height`。
- en: Set `beeActive` to true.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`beeActive`设置为true。
- en: Important note
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that the `height` variable is the first variable we have ever declared
    inside the game loop. Furthermore, because it was declared inside an `if` block,
    it is actually "invisible" outside of the `if` block. This is fine for our use
    because once we have set the height of the bee, we don't need it anymore. This
    phenomenon that affects variables is called **scope**. We will explore this more
    fully in [*Chapter 4*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)*, Loops,
    Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics*.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we run the game, nothing will happen to the bee yet, but now the bee is active,
    we can write some code that runs when `beeActive` is `true`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code which, as you can see, executes whenever
    `beeActive` is `true`. This is because it follows with `else` after the `if(!beeActive)`
    block:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the `else` block, the following things happen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The bee's position is changed using the following criteria. The `setPosition`
    function uses the `getPosition` function to get the current horizontal coordinate
    of the bee. It then subtracts `beeSpeed * dt.asSeconds()` from that coordinate.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The `beeSpeed` variable value is many pixels per second and was randomly assigned
    in the previous `if` block. The value of `dt.asSeconds()` will be a fraction of
    1 that represents how long the previous frame of animation took.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that the bee''s current horizontal coordinate is `dt.asSeconds`
    would be `beeSpeed` was set to the maximum `setPosition` uses for the horizontal
    coordinate is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Therefore, the new position on the horizontal axis for the bee would be 999.9202\.
    We can see that the bee is very, very smoothly drifting to the left, at well under
    a pixel per frame. If the frame rate fluctuates, then the formula will produce
    a new value to suit. If we run the same code on a PC that only achieves 100 frames
    per second or a PC that achieves a million frames per second, the bee will move
    at the same speed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The `setPosition` function uses `getPosition().y` to keep the bee in exactly
    the same vertical coordinate throughout this cycle of being active.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of the code in the `else` block we just added is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code tests, in each and every frame (when `beeActive` is `true`), whether
    the bee has disappeared off of the left-hand side of the screen. If the `getPosition`
    function returns less than -100, it will certainly be out of view of the player.
    When this occurs, `beeActive` is set to `false` and, on the next frame, a "new"
    bee will be set flying at a new random height and a new random speed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Try running the game and watch our bee dutifully fly from right to left and
    then come back to the right again at a new height and speed. It's almost like
    a new bee every time.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a real bee would stick around for ages and pester you while you're
    trying to concentrate on chopping the tree. We will make some smarter game characters
    in later projects.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will get the clouds moving in a very similar way.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Blowing the clouds
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we want to do is set up the first cloud at a certain height
    and a certain speed. We only want to do this when the cloud is inactive. Consequently,
    we will wrap the code that follows in an `if` block. Examine and add the following
    highlighted code, just after the code we added for the bee, and then we will discuss
    it. It is almost identical to the code we used on the bee:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The only difference between the code we have just added and the bee-related
    code is that we work on a different sprite and use different ranges for our random
    numbers. Also, we multiply by ten (`* 10` ) to the result returned by `time(0)`
    so that we are always guaranteed to get a different seed for each of the clouds.
    When we code the other cloud movement next, you will see that we use `* 20` and
    `* 30`, respectively.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can act when the cloud is active. We will do so in the `else` block.
    Like the `if` block, the code is identical to that of the bee-related code, except
    that all of the code works on the cloud and not the bee:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we know what to do, we can duplicate the same code for the second
    and third clouds. Add the following highlighted code, which handles the second
    and third clouds, immediately after the code for the first cloud:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, you can run the game and the clouds will randomly and continuously drift
    across the screen. The bee will also buzz from right to left before respawning
    once more back on the right. The following screenshot shows what we''ve achieved
    in this chapter:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_02_02.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Does all of this cloud and bee handling seem a little bit repetitious? We will
    see how we could save lots of typing and make our code more readable as, in C++,
    there are ways of handling multiple instances of the same type of variable or
    object. One such way is called **arrays**, and we will learn about them in [*Chapter
    4*](B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110)*, Loops, Arrays, Switches,
    Enumerations, and Functions – Implementing Game Mechanics*. At the end of this
    project, once we have learned about arrays, we will discuss how we can improve
    our cloud code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at a few frequently asked questions related to the topics in this
    chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that a variable is a named storage location in memory
    in which we can keep values of a specific type. The types include `int`, `float`,
    `double`, `bool`, `String`, and `char`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: We can declare and initialize all of the variables we need to store the data
    for our game. Once we have our variables, we can manipulate them using the arithmetic
    and assignment operators, as well as use them in tests with the logical operators.
    Used in conjunction with the `if` and `else` keywords, we can branch our code
    depending on the current situation in the game.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Using all of this new knowledge, we animated some clouds and a bee. In the next
    chapter, we will use these skills some more to add a **Heads Up Display** (**HUD**)
    and add more input options for the player, as well as represent time visually
    using a time-bar.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 利用所有这些新的知识，我们制作了一些云朵和一只蜜蜂的动画。在下一章中，我们将运用这些技能来添加**抬头显示**（**HUD**）和为玩家添加更多输入选项，以及使用时间条来直观地表示时间。
- en: FAQ
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FAQ
- en: Q) Why do we set the bee to inactive when it gets to -100? Why not just zero
    since zero is the left-hand side of the window?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 为什么当蜜蜂到达-100时我们将其设置为非活动状态？为什么不直接设置为0，因为0是窗口的左侧？
- en: A) The bee graphic is 60 pixels wide and its origin is at the top left pixel.
    As a result, when the bee is drawn with its origin at x equals zero, the entire
    bee graphic is still on screen for the player to see. By waiting until it is at
    -100, we can be sure it is out of the player's view.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: A) 蜜蜂图形的宽度是60像素，其原点位于左上角的像素。因此，当蜜蜂以其原点在x等于零的位置被绘制时，整个蜜蜂图形仍然在屏幕上，玩家可以看到。通过等待它到达-100，我们可以确保它已经超出了玩家的视野。
- en: Q) How do I know how fast my game loop is?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我如何知道我的游戏循环运行得多快？
- en: A) If you have a modern NVIDIA graphics card, you might be able to already by
    configuring your GeForce Experience overlay to show the frame rate. To measure
    this explicitly using our own code, however, we will need to learn a few more
    things. We will add the ability to measure and display the current frame rate
    in [*Chapter 5*](B14278_05_Final_AG_ePub.xhtml#_idTextAnchor138)*, Collisions,
    Sound, and End Conditions – Making the Game Playable*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: A) 如果你有一张现代的NVIDIA显卡，你可能已经可以通过配置你的GeForce Experience叠加层来显示帧率。然而，要使用我们自己的代码明确地测量这个值，我们还需要了解一些其他的事情。我们将在[*第5章*](B14278_05_Final_AG_ePub.xhtml#_idTextAnchor138)*，碰撞、声音和结束条件
    – 使游戏可玩*中添加测量和显示当前帧率的功能。
