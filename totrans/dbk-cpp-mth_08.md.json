["```cpp\nvoid putpixel(int x, int y, unsigned char color) {\n    unsigned char far* vid_mem = (unsigned char far*)0xA0000000L;\n    vid_mem[(y * 320) + x] = color;\n}\n```", "```cpp\nputpixel   proc   near\n  push bp              ; Save the base pointer on the stack\n  mov bp, sp      ; Set the BP to the current stack pointer\n  sub sp, 4           ; Reserve 4 bytes for local variables\n  mov word ptr [bp-2], 40960       ; Store 0xA000 at [bp-2]\n  mov word ptr [bp-4], 0                ; Store 0 at [bp-4]\n  mov ax, word ptr [bp+6]   ; Load the y-coordinate into AX\n  mov dx, 320               ; Load the screen width into DX\n  imul dx      ; Multiply AX (y-coord) by DX (screen width)\n  mov bx, word ptr [bp+4]   ; Load the x-coordinate into BX\n  add bx, ax      ; Add y*screen width (AX) to BX (x-coord)\n  mov es, word ptr [bp-2]             ; Load 0xA000 into ES\n  add bx, word ptr [bp-4]       ; Final pixel address in BX\n  mov al, byte ptr [bp+8]    ; Load the color value into AL\n  mov byte ptr es:[bx], al               ; Light the pixel!\n  mov sp, bp                    ; Restore the stack pointer\n  pop bp                         ; Restore the base pointer\n  ret                           ; Return from the procedure\n```", "```cpp\nvoid putpixel(int x, int y, unsigned char c) {\n  asm {\n  mov ax, 0xA000      // Load 0xA000 (VGA mode 13h) into AX\n  mov es, ax        // Set ES to the video segment (0xA000)\n  mov dx, y                // Load the y-coordinate into DX\n  mov di, x                // Load the x-coordinate into DI\n  mov bx, y                // Copy the y-coordinate into BX\n  shl dx, 8    // Multiply DX by 256 (left shift by 8 bits)\n  shl bx, 6     // Multiply BX by 64 (left shift by 6 bits)\n  add dx, bx // Add those, effectively multiplying y by 320\n  add di, dx   // Add the calculated y to DI (pixel offset)\n  mov al, c                 // Load the color value into AL\n  stosb                                  // Light the pixel\n} }\n```", "```cpp\nputpixel(int, int, unsigned char):\n  movzx eax, byte ptr [esp + 12]\n  mov ecx, dword ptr [esp + 4]\n  mov edx, dword ptr [esp + 8]\n  lea edx, [edx + 4*edx]\n  shl edx, 6\n  mov byte ptr [edx + ecx + 40960], al\n```", "```cpp\nvoid flip(unsigned int source, unsigned int dest) {\n  asm {\n     push ds   // Save the current value of the DS register\n     mov ax, dest   // Load the destination address into AX\n     mov es, ax       // Copy the value from AX into the ES\n     mov ax, source      // Load the source address into AX\n     mov ds, ax         // Copy the value in AX into the DS\n     xor si, si  // Zero out the SI (source index) register\n     xor di, di      // Zero out the DI (destination index)\n     mov cx, 64000       // Load 64000 into the CX register\n                   // (this is the number of bytes to copy)\n     rep movsb         // Run  the`movsb` instruction 64000\n          // times (movsb copies bytes from DS:SI to ES:DI)\n     pop ds         // Restore the original value of the DS\n} }\n```", "```cpp\nxor di,di\nmov cx,16000\ndb 0xF3,0x66,0xA5 //rep movsd\npop ds\n```", "```cpp\n#include <cstdio>\nint main() {\n    int sum = 0;\n    for (int i = 1; i <= 100; ++i) {\n        if (i % 2 != 0) {  // Check if the number is odd\n            sum += i;      // Add the odd number to the sum\n        }\n    }\n    printf(\"The sum is: %d\\n\",sum);\n    return 0;\n}\n```", "```cpp\n#include <cstdio>\nint main() {\n    int sum = 0;\n    int i = 1; // Start with the first odd number\n    __asm__ (\n        \"movl $1, %[i]\\n\"   // Initialize i to 1\n        \"movl $0, %[sum]\\n\" // Initialize sum to 0\n        \"loop_start:\\n\"\n        \"cmpl $100, %[i]\\n\"   // Compare i with 100\n        \"jg loop_end\\n\"       // If i > 100, exit the\n        \"addl %[i], %[sum]\\n\" // sum += i\n        \"addl $2, %[i]\\n\"     // i += 2\n        \"jmp loop_start\\n\"    // Repeat the loop\n        \"loop_end:\\n\"\n        : [sum] \"+r\" (sum), [i] \"+r\" (i)\n    );\n    printf(\"The sum is: %d\\n\", sum);\n    return 0;\n}\n```", "```cpp\n`string' DB 'The sum is: %d', 0aH, 00H ; `string'\n_main PROC\n  xor ecx, ecx  ; Clear the ECX register (set ECX to 0)\n  xor edx, edx  ; Clear the EDX register (set EDX to 0)\n  inc ecx       ; Increment ECX, setting it to 1\n $LL4@main:\n  test cl, 1    ; Test the least significant bit of CL\n                ; (ECX) to check if ECX is odd or even\n  lea eax, DWORD PTR [ecx+edx] ; Load the effective\n                ; address of ECX + EDX into EAX\n  cmove eax, edx; If the zero flag is set\n                ; (ECX was even), move EDX into EAX\n  inc ecx       ; Increment ECX by 1\n  mov edx, eax  ; Move the value in EAX to EDX\n                ; (update EDX for the next iteration)\n  cmp ecx, 100  ; Compare ECX with 100\n  jle SHORT $LL4@main ; Jump to the start of the loop\n                ; (loop until ECX > 100)\n  push edx      ; Push the final value of EDX (the sum)\n                ; after the loop onto the stack\n  push OFFSET `string' ; Push the offset of the string\n  call _printf  ; Call the printf function\n  pop ecx       ; Clean up the stack (remove string)\n  pop ecx       ; Clean up the stack (remove EDX)\n  ret 0         ; Return from the _main function\n _main ENDP\n```", "```cpp\nmain:\n  push rax\n  lea rdi, [rip + .L.str]\n  mov esi, 2500\n  xor eax, eax\n  call printf@PLT\n  xor eax, eax\n  pop rcx\n  ret\n.L.str:\n  .asciz \"The sum is: %d\\n\"\n```", "```cpp\nint countOneBits(uint32_t n) {\n    int count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n```", "```cpp\nint countOneBits(uint32_t n) {\n    return std::popcount(n);\n}\n```", "```cpp\ncountOneBits(unsigned int):\n  sub rsp, 8\n  mov edi, edi\n  call __popcountdi2\n  add rsp, 8\n  ret\n```", "```cpp\ncountOneBits(unsigned int):\n  popcnt eax, edi\n  ret\n```", "```cpp\ncountOneBits(unsigned int):\n  xor eax, eax\n  popcnt eax, edi\n  ret\n```", "```cpp\ncountOneBits(unsigned int):\n  mov eax, edi\n  shr eax\n  and eax, 1431655765\n  sub edi, eax\n  mov eax, edi\n  and eax, 858993459\n  shr edi, 2\n  and edi, 858993459\n  add edi, eax\n  mov eax, edi\n  shr eax, 4\n  add eax, edi\n  and eax, 252645135\n  imul eax, eax, 16843009\n  shr eax, 24\n  ret\n```"]