["```cpp\nstruct Light\n{\n //vec3 position;\n vec3 direction;\n\n vec3 ambient;\n vec3 diffuse;\n vec3 specular;\n};\n```", "```cpp\n // Diffuse\n vec3 norm = normalize(Normal);\n // vec3 lightDir = normalize(light.position - FragPos);\n vec3 lightDir = normalize(-light.direction);\n float diff = max(dot(norm, lightDir), 0.0);\n vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));\n```", "```cpp\n// Build and compile our shader program\n Shader lightingShader( \"res/shaders/lighting.vs\",  \n \"res/shaders/lighting.frag\" );\n //Shader lampShader( \"res/shaders/lamp.vs\", \"res/shaders/lamp.frag\" );\n```", "```cpp\n// Positions all containers\n glm::vec3 cubePositions[] = {\n glm::vec3( 0.0f, 0.0f, 0.0f),\n glm::vec3( 2.0f, 5.0f, -15.0f),\n glm::vec3( -1.5f, -2.2f, -2.5f),\n glm::vec3( -3.8f, -2.0f, -12.3f),\n glm::vec3( 2.4f, -0.4f, -3.5f),\n glm::vec3( -1.7f, 3.0f, -7.5f),\n glm::vec3( 1.3f, -2.0f, -2.5f),\n glm::vec3( 1.5f, 2.0f, -2.5f),\n glm::vec3( 1.5f, 0.2f, -1.5f),\n glm::vec3( -1.3f, 1.0f, -1.5f)\n };\n```", "```cpp\n/*\n // Then, we set the light's VAO (VBO stays the same. After all, the vertices are the same for the light object (also a 3D cube))\n GLuint lightVAO;\n glGenVertexArrays(1, &lightVAO);\n glBindVertexArray(lightVAO);\n // We only need to bind to the VBO (to link it with glVertexAttribPointer), no need to fill it; the VBO's data already contains all we need.\n glBindBuffer(GL_ARRAY_BUFFER, VBO);\n // Set the vertex attributes (only position data for the lamp))\n glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)0); // Note that we skip over the other data in our buffer object (we don't need the normals/textures, only positions).\n glEnableVertexAttribArray(0);\n glBindVertexArray(0);\n */\n```", "```cpp\n// Use cooresponding shader when setting uniforms/drawing objects\n lightingShader.Use( );\n //GLint lightPosLoc = glGetUniformLocation(lightingShader.Program, \"light.position\");\n GLint lightDirLoc = glGetUniformLocation( lightingShader.Program, \"light.direction\" );\n GLint viewPosLoc = glGetUniformLocation( lightingShader.Program, \"viewPos\" );\n//glUniform3f(lightPosLoc, lightPos.x, lightPos.y, lightPos.z);\nglUniform3f( lightDirLoc, -0.2f, -1.0f, -0.3f );\nglUniform3f( viewPosLoc, camera.GetPosition( ).x    , camera.GetPosition( ).y, camera.GetPosition( ).z );\n```", "```cpp\n // Draw 10 containers with the same VAO and VBO information; \n// only their world space coordinates differ\n glm::mat4 model;\n glBindVertexArray( boxVAO );\n for ( GLuint i = 0; i < 10; i++)\n {\n model = glm::mat4( );\n model = glm::translate( model, cubePositions[i] );\n GLfloat angle = 20.0f * i;\n model = glm::rotate( model, angle, glm::vec3( 1.0f, 0.3f, 0.5f ) );\n glUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );\n\n glDrawArrays( GL_TRIANGLES, 0, 36 );\n }\n glBindVertexArray( 0 );\n```", "```cpp\nstruct Light\n{\n //vec3 direction;\n vec3 position;\n\n vec3 ambient;\n vec3 diffuse;\n vec3 specular;\n\n float constant;\n float linear;\n float quadratic;\n};\n```", "```cpp\n// Diffuse\n vec3 norm = normalize(Normal);\n vec3 lightDir = normalize(light.position - FragPos);\n //vec3 lightDir = normalize(-light.direction); \n float diff = max(dot(norm, lightDir), 0.0);\n vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, \n TexCoords));\n```", "```cpp\n// Specular\n vec3 viewDir = normalize(viewPos - FragPos);\n vec3 reflectDir = reflect(-lightDir, norm);\n float spec = pow(max(dot(viewDir, reflectDir), 0.0),   \n material.shininess);\n vec3 specular = light.specular * spec * \n vec3(texture(material.specular, TexCoords)); \n```", "```cpp\n// Attenuation\n float distance = length(light.position - FragPos);\n float attenuation = 1.0f / (light.constant + light.linear * distance\n + light.quadratic * (distance * distance)); \n```", "```cpp\n // Attenuation\n float distance = length(light.position - FragPos);\n float attenuation = 1.0f / (light.constant + light.linear * \n distance + light.quadratic * (distance * distance));\n\n ambient *= attenuation;\n diffuse *= attenuation;\n specular *= attenuation;\n```", "```cpp\n// Build and compile our shader program\n Shader lightingShader( \"res/shaders/lighting.vs\", \n \"res/shaders/lighting.frag\" );\n Shader lampShader( \"res/shaders/lamp.vs\", \"res/shaders/lamp.frag\" );\n```", "```cpp\n GLuint VBO, boxVAO;\n glGenVertexArrays( 1, &boxVAO );\n glGenBuffers( 1, &VBO );\n\n glBindBuffer( GL_ARRAY_BUFFER, VBO );\n glBufferData( GL_ARRAY_BUFFER, sizeof(vertices), \n vertices, GL_STATIC_DRAW );\n\n glBindVertexArray( boxVAO );\n glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 8 * \n sizeof( GLfloat ), ( GLvoid * )0 );\n glEnableVertexAttribArray(0);\n glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE, 8 * \n sizeof( GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );\n glEnableVertexAttribArray( 1 );\n glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE, 8 * \n sizeof( GLfloat ), ( GLvoid * )( 6 * sizeof( GLfloat ) ) );\n glEnableVertexAttribArray( 2 );\n glBindVertexArray( 0 );\n```", "```cpp\n // Load textures\n GLuint diffuseMap, specularMap, emissionMap;\n glGenTextures( 1, &diffuseMap );\n glGenTextures( 1, &specularMap );\n glGenTextures( 1, &emissionMap );\n```", "```cpp\n lightingShader.Use( );\n\n GLint lightPosLoc = glGetUniformLocation( lightingShader.Program, \n \"light.position\" );\n //GLint lightDirLoc = glGetUniformLocation( lightingShader.Program,    \n //\"light.direction\" );\n GLint viewPosLoc = glGetUniformLocation( lightingShader.Program, \n \"viewPos\" );\n glUniform3f( lightPosLoc, lightPos.x, lightPos.y, lightPos.z );\n //glUniform3f( lightPosLoc, -02.f, 1.0f, -0.3f );\n glUniform3f( viewPosLoc, camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z );\n and comment out the directions, GLint lightDirLoc = glGetUniformLocation( lightingShader.Program, \"light.direction\" );, because again, the pointer light emits light in every direction. Also, don't forget to comment out glUniform3f( lightPosLoc, -02.f, 1.0f, -0.3f ); and remove the comment from glUniform3f( lightPosLoc, lightPos.x, lightPos.y, lightPos.z );\n```", "```cpp\n// Set lights properties\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"light.ambient\" ), 0.2f, 0.2f, 0.2f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"light.diffuse\" ), 0.5f, 0.5f, 0.5f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"light.specular\" ), 1.0f, 1.0f, 1.0f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"light.constant\" ), 1.0f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"light.linear\" ), 0.09 );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"light.quadratic\" ), 0.032 );\n```", "```cpp\n glDeleteVertexArrays( 1, &boxVAO );\n glDeleteVertexArrays( 1, &lightVAO );\n glDeleteBuffers( 1, &VBO );\n```", "```cpp\n// Camera\nCamera camera( glm::vec3( 0.0f, 0.0f, 3.0f ) );\nGLfloat lastX = WIDTH / 2.0;\nGLfloat lastY = HEIGHT / 2.0;\nbool keys[1024];\nbool firstMouse = true;\n\n// Light attributes\nglm::vec3 lightPos( 1.2f, 1.0f, -2.0f );\n```", "```cpp\n#version 330 core\nstruct Material\n{\n     sampler2D diffuse;\n     sampler2D specular;\n     float shininess;\n};\nstruct Light\n{\n     vec3 position;\n     vec3 direction;\n     float cutOff;\n float outerCutOff;\n\n     float constant;\n     float linear;\n     float quadratic;\n\n     vec3 ambient;\n     vec3 diffuse;\n     vec3 specular;\n};\n```", "```cpp\nfloat epsilon = (light.cutOff - light.outerCutOff);\n```", "```cpp\nfloat intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);\n```", "```cpp\ndiffuse *= intensity;\nspecular *= intensity;\n```", "```cpp\nglm::vec3 GetFront()\n{\n    return this -> front;\n}\n```", "```cpp\n lightingShader.Use();\n GLint lightPosLoc = glGetUniformLocation( lightingShader.Program, \"light.position\" );\n GLint lightSpotdirLoc = glGetUniformLocation( lightingShader.Program, \"light.direction\" );\n GLint lightSpotCutOffLoc = glGetUniformLocation( lightingShader.Program, \"light.cutOff\" );\n GLint lightSpotOuterCutOffLoc = glGetUniformLocation( lightingShader.Program, \"light.outerCutOff\" );\n GLint viewPosLoc = glGetUniformLocation( lightingShader.Program, \"viewPos\" );\n glUniform3f( lightPosLoc, camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z);\n glUniform3f( lightSpotdirLoc, camera.GetFront( ).x, camera.GetFront( ).y, camera.GetFront( ).z);\n glUniform1f( lightSpotCutOffLoc, glm::cos( glm::radians( 12.5f ) ) );\n glUniform1f( lightSpotOuterCutOffLoc, glm::cos( glm::radians( 17.5f ) ) );\n glUniform3f( viewPosLoc, camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z);\n```", "```cpp\nglUniform3f( glGetUniformLocation( lightingShader.Program, \"light.ambient\" ),   0.1f, 0.1f, 0.1f );\nglUniform3f( glGetUniformLocation( lightingShader.Program, \"light.diffuse\" ), 0.8f, 0.8f, 0.8f );\n\n```", "```cpp\nversion 330 core\n#define NUMBER_OF_POINT_LIGHTS 4\nstruct Material\n{\n     sampler2D diffuse;\n     sampler2D specular;\n     float shininess;\n};\n```", "```cpp\nstruct DirLight\n{\n     vec3 direction;\n\n     vec3 ambient;\n     vec3 diffuse;\n     vec3 specular;\n};\n```", "```cpp\nstruct PointLight\n{\n     vec3 position;\n\n     float constant;\n     float linear;\n     float quadratic;\n\n     vec3 ambient;\n     vec3 diffuse;\n     vec3 specular;\n};\n```", "```cpp\nstruct SpotLight\n{\n     vec3 position;\n     vec3 direction;\n     float cutOff;\n     float outerCutOff;\n\n     float constant;\n     float linear;\n     float quadratic;\n\n     vec3 ambient;\n     vec3 diffuse;\n     vec3 specular;\n};\n```", "```cpp\nuniform DirLight dirLight;\nuniform PointLight pointLights[NUMBER_OF_POINT_LIGHTS];\nuniform SpotLight spotLight;\nuniform Material material;\n```", "```cpp\n// Function prototypes\nvec3 CalcDirLight( DirLight light, vec3 normal, vec3 viewDir );\nvec3 CalcPointLight( PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir );\nvec3 CalcSpotLight( SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir );\n```", "```cpp\nvoid main( )\n{\n // Properties\n vec3 norm = normalize( Normal );\n vec3 viewDir = normalize( viewPos - FragPos );\n\n // Directional lighting\n vec3 result = CalcDirLight( dirLight, norm, viewDir );\n\n // Point lights\n for ( int i = 0; i < NUMBER_OF_POINT_LIGHTS; i++ )\n {\n result += CalcPointLight( pointLights[i], norm, FragPos, viewDir );\n }\n\n // Spot light\n result += CalcSpotLight( spotLight, norm, FragPos, viewDir );\n\n color = vec4( result, 1.0 );\n}\n```", "```cpp\n vec3 CalcDirLight( DirLight light, vec3 normal, vec3 viewDir )\n{\n vec3 lightDir = normalize( -light.direction );\n\n // Diffuse shading\n float diff = max( dot( normal, lightDir ), 0.0 );\n\n // Specular shading\n vec3 reflectDir = reflect( -lightDir, normal );\n float spec = pow( max( dot( viewDir, reflectDir ), 0.0 ), material.shininess );\n\n // Combine results\n vec3 ambient = light.ambient * vec3( texture( material.diffuse, TexCoords ) );\n vec3 diffuse = light.diffuse * diff * vec3( texture( material.diffuse, TexCoords ) );\n vec3 specular = light.specular * spec * vec3( texture( material.specular, TexCoords ) );\n\n return ( ambient + diffuse + specular );\n}\n```", "```cpp\n// Calculates the color when using a point light.\nvec3 CalcPointLight( PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir )\n{\n vec3 lightDir = normalize( light.position - fragPos );\n\n // Diffuse shading\n float diff = max( dot( normal, lightDir ), 0.0 );\n\n // Specular shading\n vec3 reflectDir = reflect( -lightDir, normal );\n float spec = pow( max( dot( viewDir, reflectDir ), 0.0 ), material.shininess );\n\n // Attenuation\n float distance = length( light.position - fragPos );\n float attenuation = 1.0f / ( light.constant + light.linear * distance + light.quadratic * ( distance * distance ) );\n\n // Combine results\n vec3 ambient = light.ambient * vec3( texture( material.diffuse, TexCoords ) );\n vec3 diffuse = light.diffuse * diff * vec3( texture( material.diffuse, TexCoords ) );\n vec3 specular = light.specular * spec * vec3( texture( material.specular, TexCoords ) );\n\n ambient *= attenuation;\n diffuse *= attenuation;\n specular *= attenuation;\n\n return ( ambient + diffuse + specular );\n}\n```", "```cpp\n// Calculates the color when using a spot light.\nvec3 CalcSpotLight( SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir )\n{\n vec3 lightDir = normalize( light.position - fragPos );\n\n // Diffuse shading\n float diff = max( dot( normal, lightDir ), 0.0 );\n\n // Specular shading\n vec3 reflectDir = reflect( -lightDir, normal );\n float spec = pow( max( dot( viewDir, reflectDir ), 0.0 ), material.shininess );\n\n // Attenuation\n float distance = length( light.position - fragPos );\n float attenuation = 1.0f / ( light.constant + light.linear * distance + light.quadratic * ( distance * distance ) );\n\n // Spotlight intensity\n float theta = dot( lightDir, normalize( -light.direction ) );\n float epsilon = light.cutOff - light.outerCutOff;\n float intensity = clamp( ( theta - light.outerCutOff ) / epsilon, 0.0, 1.0 );\n\n // Combine results\n vec3 ambient = light.ambient * vec3( texture( material.diffuse, TexCoords ) );\n vec3 diffuse = light.diffuse * diff * vec3( texture( material.diffuse, TexCoords ) );\n vec3 specular = light.specular * spec * vec3( texture( material.specular, TexCoords ) );\n\n ambient *= attenuation * intensity;\n diffuse *= attenuation * intensity;\n specular *= attenuation * intensity;\n\n return ( ambient + diffuse + specular );\n}\n```", "```cpp\n  // Positions of the point lights\n     glm::vec3 pointLightPositions[] = \n{\n     glm::vec3( 0.7f, 0.2f, 2.0f ),\n     glm::vec3( 2.3f, -3.3f, -4.0f ),\n     glm::vec3( -4.0f, 2.0f, -12.0f ),\n     glm::vec3( 0.0f, 0.0f, -3.0f )\n };\n```", "```cpp\n// Use cooresponding shader when setting uniforms/drawing objects\n lightingShader.Use( );\n GLint viewPosLoc = glGetUniformLocation( lightingShader.Program, \"viewPos\" );\n glUniform3f( viewPosLoc, camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z);\n // Set material properties\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"material.shininess\" ), 32.0f );\n```", "```cpp\n // Directional light\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"dirLight.direction\" ), -0.2f, -1.0f, -0.3f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"dirLight.ambient\" ), 0.05f, 0.05f, 0.05f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"dirLight.diffuse\" ), 0.4f, 0.4f, 0.4f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"dirLight.specular\" ), 0.5f, 0.5f, 0.5f );\n```", "```cpp\n// Point light 1\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[0].position\" ), pointLightPositions[0].x, pointLightPositions[0].y, pointLightPositions[0].z );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[0].ambient\" ), 0.05f, 0.05f, 0.05f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[0].diffuse\" ), 0.8f, 0.8f, 0.8f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[0].specular\" ), 1.0f, 1.0f, 1.0f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[0].constant\" ), 1.0f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[0].linear\" ), 0.09f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[0].quadratic\" ), 0.032f );\n```", "```cpp\n// Point light 2\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[1].position\" ), pointLightPositions[1].x, pointLightPositions[1].y, pointLightPositions[1].z );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[1].ambient\" ), 0.05f, 0.05f, 0.05f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[1].diffuse\" ), 0.8f, 0.8f, 0.8f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[1].specular\" ), 1.0f, 1.0f, 1.0f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[1].constant\" ), 1.0f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[1].linear\" ), 0.09f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[1].quadratic\" ), 0.032f );\n```", "```cpp\n // Point light 3\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[2].position\" ), pointLightPositions[2].x, pointLightPositions[2].y, pointLightPositions[2].z );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[2].ambient\" ), 0.05f, 0.05f, 0.05f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[2].diffuse\" ), 0.8f, 0.8f, 0.8f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[2].specular\" ), 1.0f, 1.0f, 1.0f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[2].constant\" ), 1.0f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[2].linear\" ), 0.09f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[2].quadratic\" ), 0.032f );\n```", "```cpp\n// Point light 4\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[3].position\" ), pointLightPositions[3].x, pointLightPositions[3].y, pointLightPositions[3].z );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[3].ambient\" ), 0.05f, 0.05f, 0.05f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[3].diffuse\" ), 0.8f, 0.8f, 0.8f );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"pointLights[3].specular\" ), 1.0f, 1.0f, 1.0f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[3].constant\" ),  1.0f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[3].linear\" ), 0.09f );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"pointLights[3].quadratic\" ), 0.032f );\n\n```", "```cpp\n// SpotLight\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"spotLight.position\" ), camera.GetPosition( ).x, camera.GetPosition( ).y, camera.GetPosition( ).z );\n glUniform3f( glGetUniformLocation( lightingShader.Program, \"spotLight.direction\" ), camera.GetFront( ).x, camera.GetFront( ).y, camera.GetFront( ).z );\n\nglUniform3f( glGetUniformLocation( lightingShader.Program, \"spotLight.ambient\" ), 0.0f, 0.0f, 0.0f );\n\n glUniform3f( glGetUniformLocation( lightingShader.Program, \n\"spotLight.diffuse\" ), 1.0f, 1.0f, 1.0f );\n\n glUniform3f( glGetUniformLocation( lightingShader.Program, \n\"spotLight.specular\" ), 1.0f, 1.0f, 1.0f );\n\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"spotLight.constant\" ), 1.0f );\n\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"spotLight.linear\" ), 0.09f );\n\nglUniform1f( glGetUniformLocation( lightingShader.Program, \"spotLight.quadratic\" ), 0.032f );\n\nglUniform1f( glGetUniformLocation( lightingShader.Program, \"spotLight.cutOff\" ), glm::cos( glm::radians( 12.5f ) ) );\n glUniform1f( glGetUniformLocation( lightingShader.Program, \"spotLight.outerCutOff\" ), glm::cos( glm::radians( 15.0f ) ) );\n```", "```cpp\n// We now draw as many light bulbs as we have point lights.\n glBindVertexArray( lightVAO );\n for ( GLuint i = 0; i < 4; i++ )\n {\n model = glm::mat4( );\n model = glm::translate( model, pointLightPositions[i] );\n model = glm::scale( model, glm::vec3( 0.2f ) ); // Make it a smaller cube\n glUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );\n glDrawArrays( GL_TRIANGLES, 0, 36 );\n }\n glBindVertexArray( 0 );\n```"]