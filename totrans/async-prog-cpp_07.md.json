["```cpp\ncmake . && cmake —build .\n```", "```cpp\nvoid func() {\n    std::cout << \"Using function pointer\\n\";\n}\nauto fut1 = std::async(func);\n```", "```cpp\nauto lambda_func = []() {\n    std::cout << \"Using lambda function\\n\";\n};\nauto fut2 = std::async(lambda_func);\n```", "```cpp\nauto fut3 = std::async([]() {\n    std::cout << \"Using embedded lambda function\\n\";\n});\n```", "```cpp\nclass FuncObjectClass {\n   public:\n    void operator()() {\n        std::cout << \"Using function object class\\n\";\n    }\n};\nauto fut4 = std::async(FuncObjectClass());\n```", "```cpp\nclass Obj {\n  public:\n    void func() {\n        std::cout << \"Using a non-static member function\"\n                  << std::endl;\n    }\n};\nObj obj;\nauto fut5 = std::async(&Obj::func, &obj);\n```", "```cpp\nclass Obj {\n  public:\n    static void static_func() {\n        std::cout << \"Using a static member function\"\n                  << std::endl;\n    }\n};\nauto fut6 = std::async(&Obj::static_func);\n```", "```cpp\nvoid funcByValue(const std::string& str, int val) {\n    std::cout << «str: « << str << «, val: « << val\n              << std::endl;\n}\nstd::string str{\"Passing by value\"};\nauto fut1 = async(funcByValue, str, 1);\n```", "```cpp\nvoid modifyValues(std::string& str) {\n    str += \" (Thread)\";\n}\nstd::string str{\"Passing by reference\"};\nauto fut2 = std::async(modifyValues, std::ref(str));\n```", "```cpp\nvoid printVector(const std::vector<int>& v) {\n    std::cout << \"Vector: \";\n    for (int num : v) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\nstd::vector<int> v{1, 2, 3, 4, 5};\nauto fut3 = std::async(printVector, std::cref(v));\n```", "```cpp\nauto fut4 = std::async(printVector, std::move(v));\n```", "```cpp\nstd::string str5{\"Hello\"};\nauto fut5 = std::async([&]() {\n    std::cout << \"str: \" << str5 << std::endl;\n});\n```", "```cpp\n#include <chrono>\n#include <cmath>\n#include <future>\n#include <iostream>\n#include <thread>\n#include <vector>\n#include <syncstream>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nint compute(unsigned taskId, int x, int y) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(\n                               rand() % 200));\n    sync_cout << \"Running task \" << taskId << '\\n';\n    return std::pow(x, y);\n}\nint main() {\n    std::vector<std::future<int>> futVec;\n    for (int i = 0; i <= 10; i++)\n        futVec.emplace_back(std::async(compute,\n                            i+1, 2, i));\n    sync_cout << \"Waiting in main thread\\n\";\n    std::this_thread::sleep_for(1s);\n    std::vector<int> results;\n    for (auto& fut : futVec)\n        results.push_back(fut.get());\n    for (auto& res : results)\n        std::cout << res << ' ';\n    std::cout << std::endl;\n    return 0;\n}\n```", "```cpp\nWaiting in main thread\nRunning task 11\nRunning task 9\nRunning task 2\nRunning task 8\nRunning task 4\nRunning task 6\nRunning task 10\nRunning task 3\nRunning task 1\nRunning task 7\nRunning task 5\n1 2 4 8 16 32 64 128 256 512 1024\n```", "```cpp\n#include <chrono>\n#include <future>\n#include <iostream>\n#include <string>\n#include <syncstream>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nint square(const std::string& task_name, int x) {\n    sync_cout << \"Launching \" << task_name\n              << « task...\\n»;\n    return x * x;\n}\n```", "```cpp\nsync_cout << \"Starting main thread...\\n\";\nauto fut_async = std::async(std::launch::async,\n                           square, «async_policy\", 2);\nauto fut_deferred = std::async(std::launch::deferred,\n                            square, «deferred_policy\", 3);\nauto fut_default = std::async(square,\n                            «default_policy\", 4);\n```", "```cpp\nauto is_deferred = [](std::future<int>& fut) {\n    return (fut.wait_for(0s) ==\n            std::future_status::deferred);\n};\nsync_cout << \"Checking if deferred:\\n\";\nsync_cout << \"  fut_async: \" << std::boolalpha\n          << is_deferred(fut_async) << '\\n';\nsync_cout << \"  fut_deferred: \" << std::boolalpha\n          << is_deferred(fut_deferred) << '\\n';\nsync_cout << \"  fut_default: \" << std::boolalpha\n          << is_deferred(fut_default) << '\\n';\n```", "```cpp\nsync_cout << \"Waiting in main thread...\\n\";\nstd::this_thread::sleep_for(1s);\nsync_cout << \"Wait in main thread finished.\\n\";\nsync_cout << \"Getting result from \"\n          << \"async policy task...\\n\";\nint val_async = fut_async.get();\nsync_cout << \"Result from async policy task: \"\n          << val_async << '\\n';\nsync_cout << \"Getting result from \"\n          << \"deferred policy task...\\n\";\nint val_deferred = fut_deferred.get();\nsync_cout << \"Result from deferred policy task: \"\n          << val_deferred << '\\n';\nsync_cout << \"Getting result from \"\n          << \"default policy task...\\n\";\nint val_default = fut_default.get();\nsync_cout << \"Result from default policy task: \"\n          << val_default << '\\n';\n```", "```cpp\nStarting main thread...\nLaunching async_policy task...\nLaunching default_policy task...\nChecking if deferred:\n  fut_async: false\n  fut_deferred: true\n  fut_default: false\nWaiting in main thread...\nWait in main thread finished.\nGetting result from async policy task...\nResult from async policy task: 4\nGetting result from deferred policy task...\nLaunching deferred_policy task...\nResult from deferred policy task: 9\nGetting result from default policy task...\nResult from default policy task: 16\n```", "```cpp\n#include <exception>\n#include <future>\n#include <iostream>\n#include <stdexcept>\n#include <string>\nvoid print_exceptions(const std::exception& e,\n                      int level = 1) {\n    auto indent = std::string(2 * level, ‹ ‹);\n    std::cerr << indent << e.what() << '\\n';\n    try {\n        std::rethrow_if_nested(e);\n    } catch (const std::exception& nestedException) {\n        print_exceptions(nestedException, level + 1);\n    } catch (...) { }\n}\nvoid func_throwing() {\n    throw std::runtime_error(\n               «Exception in func_throwing\");\n}\nint main() {\n    auto fut = std::async([]() {\n        try {\n            func_throwing();\n        } catch (...) {\n            std::throw_with_nested(\n                 std::runtime_error(\n                      \"Exception in async task.\"));\n        }\n    });\n    try {\n        fut.get();\n    } catch (const std::exception& e) {\n        std::cerr << \"Caught exceptions:\\n\";\n        print_exceptions(e);\n    }\n    return 0;\n}\n```", "```cpp\n#include <chrono>\n#include <functional>\n#include <future>\n#include <iostream>\n#include <thread>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nunsigned func(unsigned x) {\n    std::this_thread::sleep_for(10ms);\n    return 2 * x;\n}\n```", "```cpp\nauto start = std::chrono::high_resolution_clock::now();\n```", "```cpp\nauto duration_from = [](auto start) {\n    auto dur = std::chrono::high_resolution_clock::now()\n               - start;\n    return std::chrono::duration_cast\n               <std::chrono::milliseconds>(dur).count();\n};\n```", "```cpp\nconstexpr unsigned NUM_TASKS = 32;\nauto start = std::chrono::high_resolution_clock::now();\nfor (unsigned i = 0; i < NUM_TASKS; i++) {\n    std::async(std::launch::async, func, i);\n}\nstd::cout << \"Discarding futures: \"\n          << duration_from(start) << '\\n';\n```", "```cpp\nstart = std::chrono::high_resolution_clock::now();\nfor (unsigned i = 0; i < NUM_TASKS; i++) {\n    auto fut = std::async(std::launch::async, func, i);\n}\nstd::cout << \"In-place futures: \"\n          << duration_from(start) << '\\n';\n```", "```cpp\nstd::future<unsigned> fut;\nstart = std::chrono::high_resolution_clock::now();\nfor (unsigned i = 0; i < NUM_TASKS; i++) {\n    fut = std::async(std::launch::async, func, i);\n}\nstd::cout << \"Reusing future: \"\n          << duration_from(start) << '\\n';\n```", "```cpp\nstd::vector<unsigned> res;\nstart = std::chrono::high_resolution_clock::now();\nfor (unsigned i = 0; i < NUM_TASKS; i++) {\n    auto fut = std::async(std::launch::async, func, i);\n    res.push_back(fut.get());\n}\nstd::cout << \"Reused future and storing results: \"\n          << duration_from(start) << '\\n';\n```", "```cpp\nstd::vector<unsigned> res;\nstd::vector<std::future<unsigned>> futsVec;\nstart = std::chrono::high_resolution_clock::now();\nfor (unsigned i = 0; i < NUM_TASKS; i++) {\n    futsVec.emplace_back(std::async(std::launch::async,\n                         func, i));\n}\nfor (unsigned i = 0; i < NUM_TASKS; i++) {\n    res.push_back( futsVec[i].get() );\n}\nstd::cout << \"Futures vector and storing results: \"\n          << duration_from(start) << '\\n';\n```", "```cpp\n#include <chrono>\n#include <future>\n#include <iostream>\n#include <semaphore>\n#include <syncstream>\n#include <vector>\n#define sync_cout std::osyncstream(std::cout)\nusing namespace std::chrono_literals;\nvoid task(int id, std::counting_semaphore<>& sem) {\n    sem.acquire();\n    sync_cout << \"Running task \" << id << \"...\\n\";\n    std::this_thread::sleep_for(1s);\n    sem.release();\n}\nint main() {\n    const int total_tasks = 20;\n    const int max_concurrent_tasks =\n              std::thread::hardware_concurrency();\n    std::counting_semaphore<> sem(max_concurrent_tasks);\n    sync_cout << \"Allowing only \"\n              << max_concurrent_tasks\n              << \" concurrent tasks to run \"\n              << total_tasks << \" tasks.\\n\";\n    std::vector<std::future<void>> futures;\n    for (int i = 0; i < total_tasks; ++i) {\n        futures.push_back(\n                std::async(std::launch::async,\n                           task, i, std::ref(sem)));\n    }\n    for (auto& fut : futures) {\n        fut.get();\n    }\n    std::cout << \"All tasks completed.\" << std::endl;\n    return 0;\n}\n```", "```cpp\n#include <future>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nint square(int x) {\n    return x * x;\n}\nint sum_results(std::vector<std::future<int>>& futsVec) {\n    int sum = 0;\n    for (auto& fut : futsVec) {\n        sum += fut.get();\n    }\n    return sum;\n}\nint average_squares(int n) {\n    std::vector<std::future<int>> futsVec;\n    for (int i = 1; i <= n; ++i) {\n        futsVec.push_back(std::async(\n                std::launch::async, square, i));\n    }\n    return double(sum_results(futures)) / n;\n}\nint main() {\n    int N = 100;\n    std::cout << std::fixed << std::setprecision(2);\n    std::cout << \"Sum of squares for N = \" << N\n              << « is « << average_squares(N) << '\\n';\n    return 0;\n}\n```", "```cpp\n#include <algorithm>\n#include <forward_list>\n#include <future>\n#include <iostream>\n#include <list>\n#include <set>\n#include <string>\n#include <vector>\nint main() {\n    std::vector<std::string> africanAnimals =\n              {\"elephant\", \"giraffe\", \"lion\", \"zebra\"};\n    std::list<std::string> americanAnimals =\n              {\"alligator\", \"bear\", \"eagle\", \"puma\"};\n    std::forward_list<std::string> asianAnimals =\n              {\"orangutan\", \"panda\", \"tapir\", \"tiger\"};\n    std::set<std::string> europeanAnimals =\n              {«deer», «hedgehog», «linx\", \"wolf\"};\n    std::string target = «elephant»;\n    /* .... */\n}\n```", "```cpp\ntemplate <typename C>\nbool search(const C& container, const std::string& target) {\n    return std::find(container.begin(), container.end(),\n                     target) != container.end();\n}\n```", "```cpp\nint main() {\n    /* .... */\n    auto fut1 = std::async(std::launch::async,\n                   search<std::vector<std::string>>,\n                   africanAnimals, target);\n    auto fut2 = std::async(std::launch::async,\n                   search<std::list<std::string>>,\n                   americanAnimals, target);\n    auto fut3 = std::async(std::launch::async,\n                   search<std::forward_list<std::string>>,\n                   asianAnimals, target);\n    auto fut4 = std::async(std::launch::async,\n                search<std::set<std::string>>,\n                europeanAnimals, target);\n    /* .... */\n```", "```cpp\nint main() {\n    /* .... */\n    bool found = fut1.get() || fut2.get() ||\n                 fut3.get() || fut4.get();\n    if (found) {\n        std::cout << target\n                  << \" found in one of the containers.\\n\";\n    } else {\n        std::cout << target\n                  << \" not found in any of \"\n                  << \"the containers.\\n\";\n    }\n    return 0;\n}\n```", "```cpp\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <future>\n#include <algorithm>\n#include <random>\n// Generate a large vector of random integers using a uniform distribution\nstd::vector<int> generate_vector(size_t size) {\n    std::vector<int> vec(size);\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dist(1, size);\n    std::generate(vec.begin(), vec.end(), [&]() {\n        return dist(gen);\n    });\n    return vec;\n}\n```", "```cpp\nbool search_segment(const std::vector<int>& vec, int target, size_t begin, size_t end) {\n    auto begin_it = vec.begin() + begin;\n    auto end_it = vec.begin() + end;\n    return std::find(begin_it, end_it, target) != end_it;\n}\n```", "```cpp\nconst int target = 100;\nstd::vector<int> vec = generate_vector(5000000);\nauto vec_size = vec.size();\nsize_t num_segments = 16;\nsize_t segment_size = vec.size() / num_segments;\n```", "```cpp\nstd::vector<std::future<bool>> futs;\nfor (size_t i = 0; i < num_segments; ++i) {\n    auto begin = std::min(i * segment_size, vec_size);\n    auto end = std::min((i + 1) * segment_size, vec_size);\n    futs.push_back( std::async(std::launch::async,\n                               search_segment,\n                               std::cref(vec),\n                               target, begin, end) );\n}\n```", "```cpp\nbool found = false;\nfor (auto& fut : futs) {\n    if (fut.get()) {\n        found = true;\n        break;\n    }\n}\nif (found) {\n    std::cout << \"Target \" << target\n              << \" found in the large vector.\\n\";\n} else {\n    std::cout << \"Target \" << target\n              << \" not found in the large vector.\\n\";\n}\n```", "```cpp\n#include <cmath>\n#include <exception>\n#include <future>\n#include <iostream>\n#include <vector>\nusing matrix_t = std::vector<std::vector<int>>;\n```", "```cpp\nmatrix_t matrix_multiply(const matrix_t& A,\n                         const matrix_t& B) {\n    if (A[0].size() != B.size()) {\n        throw new std::runtime_error(\n                  «Wrong matrices dimmensions.\");\n    }\n    size_t rows = A.size();\n    size_t cols = B[0].size();\n    size_t inner_dim = B.size();\n    matrix_t res(rows, std::vector<int>(cols, 0));\n    std::vector<std::future<int>> futs;\n    for (auto i = 0; i < rows; ++i) {\n        for (auto j = 0; j < cols; ++j) {\n            std::vector<int> column(inner_dim);\n            for (size_t k = 0; k < inner_dim; ++k) {\n                column[k] = B[k][j];\n            }\n            futs.push_back(std::async(std::launch::async,\n                                      dot_product,\n                                      A[i], column));\n        }\n    }\n    for (auto i = 0; i < rows; ++i) {\n        for (auto j = 0; j < cols; ++j) {\n            res[i][j] = futs[i * cols + j].get();\n        }\n    }\n    return res;\n}\n```", "```cpp\nint dot_product(const std::vector<int>& a,\n                const std::vector<int>& b) {\n    int sum = 0;\n    for (size_t i = 0; i < a.size(); ++i) {\n        sum += a[i] * b[i];\n    }\n    return sum;\n}\n```", "```cpp\nint main() {\n    auto show_matrix = [](const std::string& name,\n                          matrix_t& mtx) {\n        std::cout << name << '\\n';\n        for (const auto& row : mtx) {\n            for (const auto& elem : row) {\n                std::cout << elem << \" \";\n            }\n            std::cout << '\\n';\n        }\n        std::cout << std::endl;\n    };\n    matrix_t A = {{1, 2, 3},\n                  {4, 5, 6}};\n    matrix_t B = {{7, 8, 9},\n                  {10, 11, 12},\n                  {13, 14, 15}};\n    auto res = matrix_multiply(A, B);\n    show_matrix(\"A\", A);\n    show_matrix(\"B\", B);\n    show_matrix(\"Result\", res);\n    return 0;\n}\n```", "```cpp\nA\n1 2 3\n4 5 6\nB\n7 8 9\n10 11 12\n13 14 15\nResult\n66 72 78\n156 171 186\n```", "```cpp\n#include <future>\n#include <iostream>\n#include <stdexcept>\nint stage1(int x) {\n    if (x < 0) throw std::runtime_error(\n                        \"Negative input not allowed\");\n    return x + 10;\n}\nint stage2(int x) {\n    return x * 2;\n}\nint stage3(int x) {\n    return x - 5;\n}\n```", "```cpp\nint main() {\n    int input_value = 5;\n    try {\n        auto fut1 = std::async(std::launch::async,\n                         stage1, input_value);\n        auto fut2 = std::async(std::launch::async,\n                         [&fut1]() {\n                            return stage2(fut1.get()); });\n        auto fut3 = std::async(std::launch::async,\n                         [&fut2]() {\n                            return stage3(fut2.get()); });\n        int final_result = fut3.get();\n        std::cout << \"Final Result: \"\n                  << final_result << std::endl;\n    } catch (const std::exception &ex) {\n        std::cerr << \"Exception caught: \"\n                  << ex.what() << std::endl;\n    }\n    return 0;\n}\n```", "```cpp\ntemplate <typename Func>\nclass Task {\n   public:\n    Task(int id, Func& func)\n        : id_(id), func_(func), has_dependency_(false) {\n        sync_cout << \"Task \" << id\n                 << \" constructed without dependencies.\\n\";\n        fut_ = std::async(std::launch::deferred,\n                         [this](){ (*this)(); });\n    }\n    template <typename... Futures>\n    Task(int id, Func& func, Futures&&... futures)\n        : id_(id), func_(func), has_dependency_(true) {\n        sync_cout << \"Task \" << id\n                  << \" constructed with dependencies.\\n\";\n        fut_ = std::async(std::launch::deferred,\n                         [this](){ (*this)(); });\n        add_dependencies(std::forward<Futures>\n                                     (futures)...);\n    }\n   private:\n    int id_;\n    Func& func_;\n    std::future<void> fut_;\n    std::vector<std::shared_future<void>> deps_;\n    bool has_dependency_;\n};\n```", "```cpp\npublic:\nvoid operator()() {\n    sync_cout << \"Starting task \" << id_ << std::endl;\n    wait_completion();\n    sync_cout << \"Running task \" << id_ << std::endl;\n    func_();\n}\nprivate:\nvoid wait_completion() {\n    sync_cout << \"Waiting completion for task \"\n              << id_ << std::endl;\n    if (!deps_.empty()) {\n        for (auto& fut : deps_) {\n            if (fut.valid()) {\n                sync_cout << \"Fut valid so getting \"\n                          << \"value in task \" << id_\n                          << std::endl;\n                fut.get();\n            }\n        }\n    }\n}\n```", "```cpp\npublic:\nvoid start() {\n    fut_.get();\n}\n```", "```cpp\nstd::shared_future<void> get_dependency() {\n    sync_cout << \"Getting future from task \"\n              << id_ << std::endl;\n    return fut_;\n}\n```", "```cpp\nint main() {\n    auto sleep1s = [](){\n        std::this_thread::sleep_for(1s);\n    };\n    auto sleep2s = [](){\n        std::this_thread::sleep_for(2s);\n    };\n    Task task1(1, sleep1s);\n    Task task2(2, sleep2s, task1.get_dependency());\n    Task task3(3, sleep1s, task2.get_dependency());\n    Task task4(4, sleep2s, task2.get_dependency());\n    Task task5(5, sleep2s, task3.get_dependency(),\n               task4.get_dependency());\n    sync_cout << \"Starting the pipeline...\" << std::endl;\n    task5.start();\n    sync_cout << \"All done!\" << std::endl;\n    return 0;\n}\n```", "```cpp\nTask 1 constructed without dependencies.\nGetting future from task 1\nTask 2 constructed with dependencies.\nGetting future from task 2\nTask 3 constructed with dependencies.\nGetting future from task 2\nTask 4 constructed with dependencies.\nGetting future from task 4\nGetting future from task 3\nTask 5 constructed with dependencies.\nStarting the pipeline...\nStarting task 5\nWaiting completion for task 5\nFut valid so getting value in task 5\nStarting task 3\nWaiting completion for task 3\nFut valid so getting value in task 3\nStarting task 2\nWaiting completion for task 2\nFut valid so getting value in task 2\nStarting task 1\nWaiting completion for task 1\nRunning task 1\nRunning task 2\nRunning task 3\nFut valid so getting value in task 5\nStarting task 4\nWaiting completion for task 4\nRunning task 4\nRunning task 5\nAll done!\n```"]