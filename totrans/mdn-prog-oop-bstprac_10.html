<html><head></head><body>
		<div><h1 id="_idParaDest-123"><em class="italics"><a id="_idTextAnchor131"/>Chapter 8</em></h1>
		</div>
		<div><h1 id="_idParaDest-124"><a id="_idTextAnchor132"/>Documentation</h1>
		</div>
		<div><h2 id="_idParaDest-125"><a id="_idTextAnchor133"/>Introduction</h2>
			<p>The amount of documentation produced as part of a software project varies dramatically. Before digging in to when and how it's appropriate to document your code, I'll first define how I'm using the term.</p>
			<p>Documentation in the context of this chapter means things that are produced to help other developers understand the software product and code, but that aren't the executable code or any of the other resources that go into the product itself. Comments in the code, not being executable, are part of the documentation. Unit tests, while executable, don't go into the product—they <em class="italics">would</em> be documentation, except that I cover automated testing in <em class="italics">Chapter 5, Coding Practices</em>. UML diagrams, developer wikis, commit messages, descriptions in bug reports, whiteboard meetings: these all fulfil the goal of explaining to other developers – not to the computer – what the code does, how, and why.</p>
			<p>On the other hand, documentation prepared for other stakeholders, like user manuals, online help, and marketing material for your users, or project schedules and overviews for managers, will not be considered here. That's all important too, and if you need to produce it then you need to do a good job of it. But charity begins at home and saving someone time by helping them understand the code they're working on is definitely a charitable act.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor134"/>Documentation Is More Useful Than You Might Think</h2>
			<p>A common reason given for not documenting code is that the <em class="italics">source code is accurate documentation</em>—<a href="http://www.codinghorror.com/blog/2012/04/learn-to-read-the-source-luke.html">http://www.codinghorror.com/blog/2012/04/learn-to-read-the-source-luke.html</a>; that, while documentation can be created with errors in it or can become inaccurate as the software changes, the source is guaranteed to be both an exactly accurate <em class="italics">and</em> exactly precise description of what the software does.</p>
			<p>If you assume that framework and compiler bugs don't exist, then this idea is correct: the source <em class="italics">is</em> complete and exact documentation of the software's behavior. The problem is, it's not always the most appropriate documentation to read.</p>
			<p>Sure, source code is entirely accurate, but it's also at the lowest possible level of abstraction. If you've just been brought onto a project and need to get to grips with the unfamiliar software, reading each operation in sequence (once you've even worked out the correct sequence) is not the easiest way to proceed.</p>
			<p>Even if you leave this point aside, there are still problems with using source code as your only source of information about the software. It does indeed tell you exactly <em class="italics">what</em> the product does. Given a bit of time studying, you can discover <em class="italics">how</em> it does it, too. But will the programming language instructions tell you <em class="italics">why</em> the software does what it does? Is that weird <code>if</code> statement there to fix a bug reported by a customer? Maybe it's there to work around a problem in the APIs? Maybe the original developer just couldn't work out a different way to solve the problem.</p>
			<p>So, good documentation should tell you <em class="italics">why</em> the code does what it does, and also let you quickly discover <em class="italics">how</em>. It should provide the context at the expense of the details, whereas the source provides all of the details at the expense of making the context hard to discover. In other words, where the source code represents an exact plan to the virtual world you're creating, your documentation should be the <strong class="bold">tourist's guide—</strong><a href="http://www.infoq.com/presentations/The-Frustrated-Architect">http://www.infoq.com/presentations/The-Frustrated-Architect</a> (This idea was first presented, to my knowledge, by <em class="italics">Simon Brown</em>—<a href="http://www.codingthearchitecture.com">http://www.codingthearchitecture.com</a>), with maps, recommendations of places to go (and to avoid), and information about world history.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor135"/>The Up-To-Dateness Problem</h2>
			<p>The other primary complaint about creating documentation other than source code is that, unless the docs are maintained alongside the source, they'll quickly go out of date; that reading documentation that's obsolete is worse than reading no documentation; and that effort that doesn't go into working code is effort wasted.</p>
			<p>I'll address the second point first. The point of producing <em class="italics">any</em> form of developer documentation is to make it easier for developers to work with the software. Therefore, the cost of creating the documentation should really be weighed against the <em class="italics">opportunity cost</em> of not producing it. If the effort saved by letting developers get straight on with their work is greater than the time spent creating and maintaining the documentation, then it's worth doing. Conversely, if the trade-off doesn't work out, you need to decide whether to give up on that form of documentation for something more valuable or find a quicker way to produce it.</p>
			<p>But what about the other issue – that obsolete docs are worse than no docs? There's some truth to that, in that being led in the wrong direction won't help someone find their way. It'll probably take much longer than you think, though, for this to become important. Remember that the documentation captures the high-level features: why (and to some extent, how) the code does what it does. Imagine you've got some documentation that is, whatever its completeness, current. Your very next commit isn't likely to change the frameworks used by your product, or the type of database it connects to, or even how it authenticates to a remote component. The product, at a high level, remains the same.</p>
			<p>Just as city guides are still useful if a handful of shops or restaurants change what they offer, the tourist guide to your code can still be helpful when some of the methods have changed their behavior a little. The risk that documentation really is uselessly out of date is one that plays out over years, not days.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor136"/>Automatically Generated Documentation</h2>
			<p>I talked in the last section about an economic trade-off associated with producing documentation: whether the cost of production is lower than the opportunity cost of not having that documentation available later. The balance can be tipped in favor of producing documentation in two ways: either by decreasing the cost of production or by increasing the value of the documentation.</p>
			<p>The automatic generation of documentation from code—often called <em class="italics">reverse engineering</em> the documentation—is a tactic used to drive down the cost of production. The idea is simple: if developers can always create the docs at a moment's notice from the source code, they can always avail themselves of up-to-the-minute descriptions of how that code works.</p>
			<p>Reverse engineering tools, which usually produce UML diagrams, a particular format of documentation discussed later in the chapter (To be clear, I'm not talking about tools that extract documentation embedded in code comments; you still have to write that form of documentation yourself), are good at providing high-level overviews of a project with some or all of the details elided. As an example, given a class definition such as a <code>.java</code> class or Objective-C <code>.h</code> and <code>.m</code> files, a reverse-engineering tool can highlight just the API methods and properties, as shown in the following <a id="_idTextAnchor137"/>figure:</p>
			<div><div><img alt="" src="img/B15099_08_01.jpg"/>
				</div>
			</div>
			<h6>Figure 8.1: A UML class diagram</h6>
			<p>They say there isn't any such thing as a free lunch (some people say TANSTAAFL), and this is correct. On the one hand, it costs almost nothing to produce that class diagram. If you understand UML class diagrams (You also need to understand how I've chosen to bend the UML to make it better at representing Objective-C – the U stands for <strong class="bold">Unified</strong>, not <strong class="bold">Universal</strong>), it certainly gives a better overview of the class's API than diving through the source code and picking out all the methods. But because the diagram was produced from the source, and the source doesn't tell us <em class="italics">why</em> it is the way it is, this diagram can't enlighten its readers as to the whys behind this class.</p>
			<p>Why does the API use delegate callbacks in one place and block callbacks elsewhere? Why use <code>NSURLConnection</code> rather than another class for downloading the content? Why are some of the instance variables protected, rather than private? You can't tell from this diagram.</p>
			<p>In addition, you don't get much of an idea of <em class="italics">how</em>. Does it matter in what order the methods are called? Is it OK to call the cancellation method when nothing's in progress? Can the delegate property be <code>nil</code>? The diagram doesn't say.</p>
			<p>So, yes, the automatic documentation was cheap. It removed information that was in the code but didn't provide anything additional. Having that brief overview is useful but it's unlikely that reverse-engineered documentation will solve all of your problems.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor138"/>Analysis Paralysis</h2>
			<p>Taking what you learned about generated documentation, it might be tempting to turn the controls the other way round. If documentation with zero input effort doesn't provide much additional value, then maybe the more you increase the effort spent on creating documentation, the more useful it becomes.</p>
			<p>Perhaps, to a point, this is true. However, the incremental value of adding documentation is asymptotic. In fact, no – it's worse than that. Create too much documentation and people can't even work out how to use <em class="italics">that</em> without some guide – some meta-documentation. Shovel too much in and it becomes harder to use the docs than if they didn't exist at all.</p>
			<p>Notice that <strong class="bold">analysis paralysis</strong> (http://c2.com/cgi/wiki?AnalysisParalysis) isn't <em class="italics">directly</em> related to writing documentation; it's actually a flawed design methods. The interaction with docs comes when you dig into the problem. Analysis paralysis occurs when you're afraid to move away from designing a solution toward building it. Have you thought of all the edge cases? Is every exceptional condition handled? Is there a use case you haven't thought of? You don't know—and you don't want to start building until you find out.</p>
			<p>Polishing your architecture documentation or class diagram is basically a complete waste of time. The best way you can find these edge cases is by building the thing and seeing what doesn't work—especially if you're writing unit tests to cover the corners of the API. You'll discover that a use case is missing by giving the software to your customer.</p>
			<p>So, analysis paralysis, then, isn't a problem that falls out of creating documentation; it occurs when you <em class="italics">focus</em> on the documentation. Remember, at the beginning of the chapter, I said the docs were there to support the development of the code by helping the programmers. Your goal is your product: the thing your customers want to be using.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor139"/>How to Document</h2>
			<p>The first couple of sections in this chapter were about the <em class="italics">whys</em> of documenting, what the benefits are, and why you might be in trouble if you do too little or too much. Now it's time to discuss the <em class="italics">how</em>, some of the forms of documentation that exist, how they can be useful (or otherwise), and how to go about making them.</p>
			<h3 id="_idParaDest-131"><a id="_idTextAnchor140"/>Coding Standards</h3>
			<p>Most organizations with more than a couple of developers working together have a style guide or coding standard. This document explains the minutiae of writing code to create a "company style": where to put the brackets, how to name variables, how many spaces to indent by, and so on. If you haven't seen one before, the <strong class="bold">GNU coding standard</strong>—<a href="http://www.gnu.org/prep/standards/standards.html">http://www.gnu.org/prep/standards/standards.html</a> is very comprehensive. Indeed, one company I worked at required their code to conform to the GNU standard rather than writing their own: it already existed, covered most issues, and was easy to conform to.</p>
			<p>Coding standards are great for ensuring that developers new to the project will write consistent code—particularly very novice programmers who may not yet appreciate the value of a single approach to layout, variable and method naming, and the like. (The value is that you're not surprised by the names of the variables, placement of expressions, and so on. The organization of the code gets out of the way so you can focus on the meaning of the code – perhaps in addition to why, how, and what, I should've added <em class="italics">where</em>.) For developers who are comfortable with the language they're using and its idioms, a coding standards document is a waste of time: they'll be able to <em class="italics">see</em> how you lay out your brackets from the code; they'll be able to adapt to your house style automatically, or at the very least configure their IDE to do it for them. As Herb Sutter and Alexei Alexandrescu put it in C++ Coding Standards:</p>
			<p><em class="italics">Issues that are really just personal taste and don't affect correctness or readability don't belong in a coding standard. Any professional programmer can easily read and write code that is formatted a little differently than they're used to.</em></p>
			<p>Sadly, many coding standards documents do not progress beyond those superficial features.</p>
			<p>The parts of a coding standard that don't specifically describe how to lay out code are not useful. They're busy work for people who want to be in control of what other people are writing. Telling a developer "ensure all exceptions are caught" or "handle all errors" is not something that they'll take to heart unless it's part of how they work anyway. If what you want to do is to ensure programmers are catching exceptions or handling errors, then you need to find those who don't and mentor them on making it part of how they think about their work. Writing an edict in some document handed to them on day one isn't going to stay with them, even into day two.</p>
			<p>An experienced developer who hasn't yet learned to handle all errors won't start just because a wiki page tells them to. An experienced developer who <em class="italics">has</em> learned to handle all errors, except the one they don't know about, won't discover that error through reading a document on coding standards. A novice developer who doesn't know how the error conditions arise is left none the wiser.</p>
			<p>High-level goals such as "handle all errors," "log all assertion failures" (Which is probably the entry after "assert all preconditions and postconditions"), and so on are great for code review checklists. They're even <em class="italics">better</em> for automated code analysis rules. They don't belong in standards documents: no one will make those things a "standard" just because they read a bullet point demanding them.</p>
			<h4>Coding Standards And Me</h4>
			<p class="callout">As previously mentioned, I've worked at a company that used the GNU standards. I've also created coding standards for a developer team, at a time when all team members (myself included) were inexperienced at the language we were using.</p>
			<p class="callout">In the last 4 years or so, despite working for and contracting at a number of different companies, none has had documented coding standards. I haven't really missed it – the "standard" layout becomes "whatever the IDE does out of the box," and everything else is done by automated or manual review.</p>
			<p class="callout">So, would I recommend writing a coding standard? Only if the lack of a standard is proving problematic. Actually, it might be just as easy—though more passive-aggressive—to write a pre-commit hook that reformats code before it gets into your repository. Some IDEs (those from JetBrains, for example) offer this feature already.</p>
			<h3 id="_idParaDest-132"><a id="_idTextAnchor141"/>Code Comments</h3>
			<p>There are a couple of platitudes that get trotted out whenever comments are mentioned:</p>
			<p><em class="italics">Real programmers don't comment their code. If it was hard to write, it should be hard to understand and even harder to modify (from </em><strong class="bold">Real Programmers Don't Write Specs</strong>—<a href="http://ifaq.wap.org/computers/realprogrammers.html">http://ifaq.wap.org/computers/realprogrammers.html</a>)</p>
			<p><em class="italics">Any code should be self-documenting.</em> (found all over the internet; in this case, on <strong class="bold">Stack Overflow</strong>—<a href="http://stackoverflow.com/questions/209015/what-is-self-documenting-code-and-can-it-replace-well-documented-code">http://stackoverflow.com/questions/209015/what-is-self-documenting-code-and-can-it-replace-well-documented-code</a>)</p>
			<p>It should be obvious that the first quote is a joke, and if it isn't, read the referenced article. The second quote is not a joke, just sorely misguided.</p>
			<p>At the time that you write any code, you're <em class="italics">in the zone</em>, mentally speaking. You're likely focused on that problem to the exclusion of all (or at least to the exclusion of many) others. You've been working on that particular problem for a short while, and on problems in that domain for quite a bit longer. So, of <em class="italics">course</em>, you don't think the code needs any comments. When you read the code, it fires off all those synaptic connections that remind you why you wrote it and what it's supposed to be doing.</p>
			<p>Nobody else has the benefit of those connections. Even you, when you come back to the code later, do not have that benefit: memories that are not reinforced will <em class="italics">decay over time</em>—<a href="http://www.simplypsychology.org/forgetting.html">http://www.simplypsychology.org/forgetting.html</a>. According to that link, memories fade from long-term recollection if they aren't consolidated.</p>
			<p>With this in mind, comments are among the best form of documentation you can create because they provide a connection between two distinct forms of information. The information is the code and the prose comment, and the connection is proximate: you see both in the same place (that is, the source code editor in your IDE). If one doesn't remind you what you were thinking about when you produced it, its connection with the other will trigger some memories.</p>
			<p>Recalling (pun somewhat intentional) the discussion from the beginning of this chapter, code tells you very quickly <em class="italics">what</em> software does, and with a little work tells you <em class="italics">how</em> it does it. There's no need for comments to retread that ground—you're already looking at something that gives you that information. (A quick reminder of how the code works can save an amount of reading, though. Or, as Fraser Hess put it by paraphrasing Frank Westheimer, <em class="italics">A month in the lab can save an hour in the library</em>— <a href="https://twitter.com/fraserhess/status/299261317892685824">https://twitter.com/fraserhess/status/299261317892685824</a>.) Comments should therefore focus on <em class="italics">why</em>.</p>
			<p>Many people are put off comments by reading code that looks something like this:</p>
			<pre>    //add 1 to i
    i++;</pre>
			<p>When you're experienced enough at programming to know what the various operators in your language do, a comment like that is redundant line noise. If all comments were similar to this example, then there would be little point in competent developers reading comments—a situation in which it would indeed be hard to justify them writing comments. Obviously, not all comments <em class="italics">are</em> like that; indeed, the ones you write don't need to be.</p>
			<p>If you find it hard to believe that anyone could ever need reminding what the <code>++</code> operator does, you probably don't remember learning programming, and haven't had to teach it either. The <strong class="bold">Teaching H.E. Programming blog</strong>—<a href="http://teachingheprogramming.blogspot.co.uk">http://teachingheprogramming.blogspot.co.uk</a> is a good overview of just how hard that thing you do every day is for people who don't do it every day.</p>
			<p>The thing is that redundant comments are simply redundant. You read them, realize they don't help, and move on. This doesn't waste much time. It's worse to read comments that are mentally jarring: ones that actively stop you thinking about the code and make you think about the comment.</p>
			<p>That joke that seems really funny in your head – don't write it down. It might work well on Twitter or in the company chatroom, but not in a code comment. Even if the person reading it thinks it's funny the first time, they probably won't if they have to stop grokking code every day for the rest of their career while they read that joke over and over.</p>
			<p>While I was writing this book, someone asked on a Q&amp;A website whether <em class="italics">there's empirical evidence for the value of comments in code</em>—<a href="http://programmers.stackexchange.com/questions/187722/are-there-any-empirical-studies-about-the-effects-of-commenting-source-code-on-s">http://programmers.stackexchange.com/questions/187722/are-there-any-empirical-studies-about-the-effects-of-commenting-source-code-on-s</a>. More usefully, someone answered that question with references. One of the papers, <strong class="bold">The effect of modularization and comments on program comprehension</strong>—<a href="http://portal.acm.org/ft_gateway.cfm?id=802534&amp;type=pdf&amp;coll=DL&amp;dl=GUIDE&amp;CFID=278950761&amp;CFTOKEN=48982755">http://portal.acm.org/ft_gateway.cfm?id=802534&amp;type=pdf&amp;coll=DL&amp;dl=GUIDE&amp;CFID=278950761&amp;CFTOKEN=48982755</a>, is worth looking into in more detail.</p>
			<p>Your first reaction may be to look at the date of this paper—March 1981—and decide that it can't possibly say anything relevant to modern programmers. But wait up. The article investigates how people (who haven't changed much in three decades) read (which also hasn't changed much) comments (written in English, which hasn't changed much) and code that is organized along different lines of modularity. Only the way we write code has changed, and really not by very much. This paper investigates code written in FORTRAN, a language that's still in use and not too dissimilar from C. It investigates code written with different approaches to modularity, a variation that's observed in modern code whether written using procedural or object-oriented languages. There's really no reason to dismiss this article based on age.</p>
			<p>What they did was to implement a few different code solutions to one problem: a monolithic program, a modularized program, an over-modularized program (each "module" consisted of 3-15 lines), and one organized around an abstract data type. They produced two different versions of each; one had comments describing each module's functionality and the other did not. Interestingly, to remove other hints as to the operation of the programs, they made all variable names nondescriptive and removed any formatting hints. </p>
			<p>Whether this represents as good a control as, for example, using a consistent (meaningful) naming and formatting strategy throughout all examples would be worth exploring. Forty-eight programmers were each given one version of the code and a quiz about its operation. They summarized their results as follows:</p>
			<p><em class="italics">The comment results seem to imply that the comprehension of a program can be significantly improved with the addition of short phrases which summarize the function that a module is to perform. Contrary to the original hypothesis, it was concluded that comments were not significantly beneficial to logical module identification. Those working with the uncommented monolithic version seemed able to comprehend the program and understand the interaction of the parts as well as those working with the commented monolithic version. However, it seems that those working with the uncommented modularized programs found it more difficult to understand the function of a module and how it fit into the context of the program than those who were given the commented modularized versions.</em></p>
			<p>This does not say "comments are good" or "comments are bad." It <em class="italics">does</em> say that a particular type of comment can help people to understand a modular program. Notice that it also says that <em class="italics">uncommented</em> modular programs are harder to understand than <em class="italics">uncommented</em> monolithic programs. Could this result have any relevance to the Dunsmore et al. study in <em class="italics">Chapter 5, Coding Practices</em>? Remember that they found object-oriented programs hard to understand:</p>
			<p><em class="italics">The desirable design properties that lead to a connected system of loosely coupled objects also produce a system where it's difficult to discover the flow of execution; you can't easily see where control goes as a result of any particular message.</em></p>
			<h3 id="_idParaDest-133"><a id="_idTextAnchor142"/>Literate Programming</h3>
			<p>Donald Knuth took the idea of comments recalling the programmer's thought processes much further with his idea of <strong class="bold">Literate Programming</strong> (<a href="http://www.literateprogramming.com">http://www.literateprogramming.com</a>). In a literate programming environment, programs are written as "webs" in which prose and code can be intermingled.</p>
			<p>Programmers are encouraged to explain the thought processes behind the code they create, including the code implementation as part of the documentation. A hyperlinked tree of code references in the web is used to generate a source-only view of the web (via a tool called <code>tangle</code>), which can then be fed into the usual compiler or interpreter. Another tool, <code>weave</code>, converts the web into a pretty-printed readable document.</p>
			<p>The purpose of this hyperlinked graph is to separate the structure required by the programming language (for example, the classes and methods in an OOP language) from the structure of your thoughts. If you're thinking about two different classes and how they'll interact, you can write the parts of the code as you think of them and tell the compiler how they should be ordered later.</p>
			<p>Reading the web back later, the person who wrote it will remember why they made the decisions they did as the organization of the code matches their thought processes. Other readers will get insight into how the code evolved and why certain decisions were made: the key reasons for writing documentation.</p>
			<p>I'm not sure whether literate programming is a style to adopt – I haven't yet built any large projects as webs. I've kicked the tires on LP tools though and it is a fun way to write software (but then I like writing prose anyway, as you can probably tell). I'm not convinced it would scale – not necessarily to large projects. If I'd known about CWEB when I wrote <strong class="bold">Test-Driven iOS Development</strong>—<a href="http://blog.securemacprogramming.com/2012/04/test-driven-ios-development/">http://blog.securemacprogramming.com/2012/04/test-driven-ios-development/</a>, I would have got it done quicker and with fewer errors. When the authors of <strong class="bold">The Pragmatic Programmer</strong>—<a href="http://pragprog.com/the-pragmatic-programmer/">http://pragprog.com/the-pragmatic-programmer/</a> wrote that book, they effectively re-implemented bits of LP to keep their manuscript in sync with their code.</p>
			<p>The scaling I wonder about is scaling to multiple developers. If you find reading someone else's code style irksome, then wait until you have to read their unproofed prose. Of course, there's one way to find out.</p>
			<h3 id="_idParaDest-134"><a id="_idTextAnchor143"/>Comment Documentation</h3>
			<p>While literate programming webs focus on the structure of your thoughts and documentation, letting the code fit into that flow, many other tools exist that retain the code's structure but extract and pretty-print comments into hyperlinked API documentation. (Doesn't comment documentation come under "comments," discussed above? Not precisely, as the formality and intention are very different.)</p>
			<p>These tools—including Doxygen, Headerdoc, and friends—retain the proximity of the code with its documentation. As you're making changes to a method, you can see that its comment is right above, inviting an update to remain consistent.</p>
			<p>I find it helpful to produce comment documentation for classes and interfaces that I believe other people are going to use. I don't normally generate pretty output, but that's something people can do if they want. I certainly appreciate that option where it exists and use the formatted documentation for another programmers' API.</p>
			<p>Some static analysis tools, notably Microsoft's, warn about undocumented methods, classes, and fields. This leads to comments for the sake of their presence, without necessarily leading to a better standard of documentation. Well-formatted comments explaining that a method's purpose is "banana" and its return value is "banana" are rife.</p>
			<p>Much of what is specified in comment documentation often includes restrictions on input values to methods ("the <code>index</code> argument must be greater than 0 but less than <code>count</code>"), when to call them ("it is an error to call this method before you have called <code>configure()</code>"), or expectations about the return value ("the object returned will have a <code>size</code> less than <code>2*count</code>"). These are candidates for being expressed as assertions (usually in addition to, rather than instead of, the documentation), or you could use a language that supports contracts.</p>
			<h3 id="_idParaDest-135"><a id="_idTextAnchor144"/>Uml Diagrams</h3>
			<p>UML is a huge topic. Several books have been written on the subject. I'm not even going to try to replicate all of that, so here's the potted version, which also lets you draw analogies with other diagramming techniques:</p>
			<p><em class="italics">A UML diagram is a view of some aspect of your code expressed in a manner that conforms to the rules of the UML. Any developer that understands those rules will derive the same information (Provided the diagram actually expresses enough information to be unambiguous, of course) from the diagram.</em></p>
			<p>This means you can consider CRC cards, data flow diagrams, and other techniques to be covered by this section.</p>
			<p>The first thing to notice is that it's possible to understand UML diagrams even if you don't know the UML. It's just boxes and lines, though sometimes the meaning of "box" is more precise than "thing" and the meaning of "line" is more precise than "joined to this other thing." Don't be put off by the idea that it's some complicated language with lots of rules you need to learn. That's only true if you want it to be.</p>
			<p>Diagrams like these can appear in many contexts. I usually create them as quick sketches, on whiteboards or with paper and pencil (or their modern equivalent – the iPad and stylus). In these cases, the rules are not <em class="italics">too</em> important, but do increase the likelihood that another reader will understand the details on my diagram and that I'll create the same diagram twice if documenting the same thing.</p>
			<p>It may be clear that diagrams produced in this way are for the moment, not forever. They might be captured via an iPhone photo "just in case," but the likelihood is that they'll never be looked at again. There's certainly no expectation that they'll go into some "<em class="italics">Project X Artefacts</em>" folder to be kept indefinitely.</p>
			<p>The more effort you put into this sort of graphic, the more likely you are to want to keep it around. For something like a blog post or a diagram in a book, I'll usually use <strong class="bold">Omnigraffle</strong>—<a href="http://www.omnigroup.com/products/omnigraffle/">http://www.omnigroup.com/products/omnigraffle/</a>), <strong class="bold">dia</strong>—<a href="https://live.gnome.org/Dia/">https://live.gnome.org/Dia/</a>, or something else that lets me use the shapes and lines from the UML but doesn't care about the rules.</p>
			<p>I have also used tools that <em class="italics">do</em> care about the rules. One company I worked at had a site license for <strong class="bold">Enterprise Architect</strong>—<a href="http://www.sparxsystems.com.au">http://www.sparxsystems.com.au</a>), a tool that requires you to construct conforming diagrams and supports "round-trips" through the code. A round-trip means that it can both generate the diagram from the code (discussed earlier) and also generate stub code from the diagram. It could also respect existing code, not trampling over existing methods when adding new features to a class.</p>
			<p>A few of the other teams made use of this extensively, maintaining the design of their components or applications in UML and implementing the behavior in generated C++ or Java classes. My team couldn't make use of it because the tool didn't (and, to my knowledge, still doesn't) support Objective-C. I therefore feel underqualified to talk about whether this is a good idea: my gut feeling is that it could be a good idea, because it forces you to think at a high level (the features exposed in the diagram) while designing, without getting bogged down in implementation details. On the other hand, different languages have different idioms and preferred ways of doing things, and those aren't readily expressed in a UML model. There's also some overhead associated with configuring the code generator to your team's liking—you still have to <em class="italics">read</em> its code, even if you don't have to <em class="italics">write</em> it.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor145"/>Summary</h2>
			<p>Documentation is a good thing to have, at those times when you need it. It's useful for telling you why and how software does what it does, when the code can only tell you what it does with a little bit of <em class="italics">how</em> mixed in.</p>
			<p>Maintaining documentation incurs additional cost and carries the risk that the documentation and the code could become unsynchronized. There are various ways to document code, and the preferred trade-off between effort and benefit can be found by experimentation.</p>
		</div>
	</body></html>