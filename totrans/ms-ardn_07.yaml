- en: Programming the Arduino - Beyond the Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things that I learned early on in my development career is that I
    can write some pretty amazing applications even if I only know the basics of the
    programming language that I am using; however, it usually makes the code hard
    to maintain and read while also adding significant development time to the project.
    I always tell people that are learning a language to take the time to understand
    some of the more advanced features of the language they are learning prior to
    using it for serious projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to set the pin mode on an Arduino digital pin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get and set the values of an Arduino digital pin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get and set the values of an Arduino analog pin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use structures and unions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use additional tabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use classes and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at the basics of the Arduino programming
    language. In this chapter, we are going to go beyond the basics of the language
    itself. We will start off by looking at how we can interact with the digital pins
    on the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: For the samples in this chapter, we will be using the prototype that we created
    at the end of [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml), *Basic Prototyping*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting digital pin mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](a46a0d68-6899-45e9-8f90-3ba0f15ad9e6.xhtml), *The Arduino*,
    we saw that the Arduino has several digital pins that we can connect external
    sensors and other devices to. Before we use these pins, we should configure them
    for either input or output depending on what we are using them for. To do this,
    we use the `pinMode()` function that is built into the Arduino programming language.
    Usually for smaller sketches we call the `pinMode()` function within the `setup()`
    function; however, this is not required. The following code shows the syntax for
    the `pinMode()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is called with two parameters. The first is the number of the
    pin that we are setting and the second is the mode for the pin. The mode for the
    pin can be either `INPUT`, to read the value from the pin (external sensor writes
    a value to the pin), or `OUTPUT`, to set the value for the pin. The following
    code shows how to use this command to set the pin mode for two pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we set pin `11` to input and pin `12` for output. Therefore,
    we would write values to pin 11 and read values from pin 12.
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice never to use the pin numbers themselves, as shown in the
    last example, to access the pin on the Arduino. Instead of using the pin numbers
    like this, we should set a variable or constant with the number of the pin and
    then use that variable or constant when accessing the pin. This will prevent us
    from typing in the wrong number within the code.
  prefs: []
  type: TYPE_NORMAL
- en: My personal preference is to use `#define` to define the pin numbers that I
    am using when the pin number will not change. This allows me to separate my pin
    definitions from the other constants within my sketch.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to use constants instead of `#define`, that is perfectly acceptable,
    and some people would say that it is preferable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we should use the `pinMode()` function within
    a sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined constants that represented two pins. The first
    line defines `BUTTON_ONE` to the number (pin) `12` and the second line defines
    `LED_ONE` to the number (pin) `11`. We then set the `BUTTON_ONE` pin to input
    mode and `LED_ONE` pin to output mode within the `setup()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `pinMode()` function can also be used to configure the internal pull-up
    resistor by setting the mode of the pin to `INPUT_PULLUP`. This will invert the
    behavior of the pin when it is in input mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'These digital pins may have one of two values: `HIGH` or `LOW`. Let''s see
    how we can set the value of a digital pin.'
  prefs: []
  type: TYPE_NORMAL
- en: Digital write
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set the value of a digital pin in the Arduino programming language, we use
    the `digitalWrite()` function. This function takes the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `digitalWrite()` function accepts two parameters, where the first one is
    the pin number and the second is the value to set. We should use either `HIGH`
    or `LOW` when setting the value of a digital pin. The following code shows how
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we set the pin defined by the `LED_ONE` constant too
    `HIGH` and then pause for half a second. The `delay()` function in the Arduino
    programming language pauses the execution of the sketch for a certain amount of
    time. The time for this function is in milliseconds. After the `delay()` function
    we then set the pin defined by the `LED_ONE` constant too `LOW` and wait another
    half a second before looping back to the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code can be used in the `loop()` function to blink an LED; however,
    before we do that we need to define the `LED_ONE` constant and also set the pin
    mode. Let's look at the full sketch required to blink an LED.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code starts off by defining the `LED_ONE` constant and setting to `11`.
    The pin mode for the `LED_ONE` pin is then set in the `setup()` function. Finally,
    the code that will cause the LED to blink is added to the `loop()` function. If
    you connect the prototype that we developed in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping* and ran this code, you should see one of the LEDs blinking.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to write to a digital pin, let's see how we can read the
    value of one.
  prefs: []
  type: TYPE_NORMAL
- en: Digital read
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To read the value of a digital pin in the Arduino programming language, we
    use the `digitalRead()` function. This function takes the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `digitalRead()` function takes one parameter, which is the number of the
    digital pin to read, and will return an integer value. The following code shows
    how we can use the `digitalRead()` function to read one of the digital pins on
    the Arduino:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this code, the `digitalRead()` function will return the value of the pin
    defined by the `BUTTON_ONE` constant and put that value into the variable named
    `val`. The `val` variable is defined to be an integer. However, the `digitalRead()`
    function will only return a 0 or a 1\. We can use the same `HIGH` and `LOW` constants
    that we saw in the *Digital write* section to see if the pin is either high or
    low. Using these constants are preferred and makes your code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how we can use the `digitalRead()` function to read the status
    of a button. The following code will read the status of the button from the prototype
    that we built in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml), *Basic Prototyping*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code starts off by defining the `BUTTON_ONE` constant and setting it to
    `12`. The serial monitor and the pin mode for the pin that the button is connected
    to are both configured in the `setup()` function. Within the loop button, the
    `digitalRead()` function is used to read the pin and the `if` statement is used
    to compare the value that was returned with the `HIGH` constant. If they are equal,
    then the message `Button HIGH` is sent to the serial monitor otherwise the message
    `Button LOW` is sent.
  prefs: []
  type: TYPE_NORMAL
- en: If this code is run on the prototype that was created in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping*, then you should see one of the two messages being printed
    to the serial monitor depending if the button is pressed or not.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how we can write to an analog pin on the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Analog write
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analog values are written to the Arduino with the **Pulse-Width Modulation**
    (**PWM**) pins. In [Chapter 1](a46a0d68-6899-45e9-8f90-3ba0f15ad9e6.xhtml), *The
    Arduino*, we looked at what PWM is and how they work. On most Arduino boards the
    PWM pins are configured for pins 3, 5, 6, 9, 10, and 11; however, the Arduino
    Mega has significantly more pins available for PWM functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform an analog write, we use the `analogWrite()` function, which takes
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `analogWrite()` function accepts two parameters, where the first one is
    the pin number and the second is the value to set. The value for the `analogWrite()`
    function can range from 0 to 255.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a sample sketch to see how we can use the `analogWrite()` function
    to fade a led in and out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code starts off by defining a `LED_ONE` constant with a value of `11`.
    This will be the pin that the LED is connected to. There are also two global variables
    defined, both of the integer type, named `val` and `change`. The `val` integer
    will store the current value of the analog pin, and the `change` integer will
    store how much the `val` integer should change each loop.
  prefs: []
  type: TYPE_NORMAL
- en: The pin defined by the `LED_ONE` constant is set to output mode within the `setup()`
    function. This will enable us to write to the pin and change the brightness of
    the LED connected to the pin.
  prefs: []
  type: TYPE_NORMAL
- en: The `loop()` function starts off by adding the `change` variable to the `val`
    variable, and the result is stored in the `val` variable. If the value of the
    `val` variable is greater than 250 or less than 5 we multiple the `change` variable
    by -1\. This causes the `change` variable to rotate between 5 and -5, which causes
    the `val` variable to increase or decrease each loop. Finally, the value of the
    `val` variable is written to the pin defined by the `LED_ONE` constant, and then
    there is a short delay before looping back.
  prefs: []
  type: TYPE_NORMAL
- en: If this code is run on the prototype that was created in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping*, then you should see LED fade in and out. Now let's look at
    how we can read an analog pin.
  prefs: []
  type: TYPE_NORMAL
- en: Analog read
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We read the value from an analog pin using the `analogRead()` function. This
    function will return a value between 0 and 1023\. This means that if the sensor
    is returning the full voltage of 5V, then the `analogRead()` function will return
    a value 1023, which results in a value of 0.0049V per unit (we will use this number
    in the sample code). The following code shows the syntax for the `analogRead()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `analogRead()` function takes one parameter which is the pin to read from.
    The following code uses the `analogRead()` function with a tmp36 temperature sensor
    to determine the current temperature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code starts off by defining the pin that the temperature sensor
    is attached to which is the analog pin 5\. The `setup()` function configures the
    serial monitor so the application can print the temperature to it.
  prefs: []
  type: TYPE_NORMAL
- en: The `loop()` function begins by reading the analog pin and storing the value
    in the `pinValue` variable. To convert this value to the actual voltage, we multiply
    it by the 0.0049V value that we saw earlier in this section. If we look at the
    datasheet for the tmp36 temperature sensor, we will determine that the `(voltage
    - .5) *100.0` is the correct formula to calculate the temperature in Celsius.
    We can then use the standard formula `(celsiusTemp *1.8) + 32` to determine the
    temperature in Fahrenheit. Finally, we print these values to the serial monitor
    and delay for two seconds before beginning the loop again.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the `digitalRead()`, `digitalWrite()`, `analogRead()` and `analogWrite()`
    functions a lot in this book so you will be getting familiar with them.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at structures.
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A structure is a user-defined a composite data type that is used to group multiple
    variables together. The variables in a structure may be of different types enabling
    us to store related data, of different types, together. The following code shows
    the syntax of how we would define a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When a structure is defined, the `struct` keyword is used followed by the name
    of the structure. The variable list is then defined between the curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can create and use a structure by changing the
    previous sketch, which used the `analogRead()` function to read the TMP36 temperature,
    to use a structure. The first thing we need to do is to define a structure that
    will store the temperature information from the sensor. We will name this structure
    `tmp36_reading,` and it will contain three variables all of the double type. The
    following code shows how to define this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a structure named `tmp36_reading` that contains three
    variables all of the double type. Keep in mind that the variables in a structure
    do not have to be of the same type, it just worked out that all of the individual
    variables in this structure were of the double type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we would create a variable of the `tmp36_reading`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a variable named `temp` that is of the `tmp36_reading`
    type. We can then assign or retrieve values by using the dot syntax as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code we assign values to the `voltage`, `tempC` and `tempF`
    variables of the `tmp36_reading` structure. Now let''s see how we can integrate
    this code into a sketch that reads the TMP36 temperature sensor. The following
    is the complete code for the new sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This sketch functions exactly like the previous sketch that read the TMP36 temperature
    sensor, except now we use a structure to store the values from the sensor rather
    than variables.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple values that you can group together like this, it is recommended
    that we use a structure rather than variables because all of the values are grouped
    together in one structure.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at another special data type that may look similar to a structure;
    however, the functionality is significantly different.
  prefs: []
  type: TYPE_NORMAL
- en: Unions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A union is a special data type that enables us to store different data types
    in a single definition, similar to the structure; however, only one of the members
    may contain data at any one time. The following shows the syntax for defining
    a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If the syntax looks a lot like the syntax for a structure. In fact, it is the
    same syntax except for the `struct`/`union` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we would use a union. The following code defines a new union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines a union named `some_data` that can contain an integer,
    double or a character string. The keyword in that last sentence is the *o**r*.
    Unlike the structure, which can store several different values, a union can only
    store one value at a time. The following code will illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we define a union named `some_data`. Then in the `setup()`
    function we create an instance of the `some_data` union type named `myData`. We
    then assign values to each member of the union type. The integer member is set
    to `42`, the double member is set to `3.14` and the character string is set to
    `Arduino`. When this code is run, we will see that the `Arduino` character string
    is correctly printed to the serial monitor; however, when the integer and double
    members are printed to the serial monitor the information is not correct.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, when the `some_data.i` member is set to `42`, the `some_data`
    union will contain the integer 42\. Then when we set the `some_data.d` member
    to `3.14`, the integer value of 42 is overwritten, and the `some_data` union would
    now contain 3.14\. Finally when we set the `some_data.s` member to `Arduino` it
    overwrites the `some_data.d` member, so the `some_data` union now contains the
    string `Arduino`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at more features of the Arduino programming language, let's look
    at another feature of the Arduino IDE and the Web Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you begin to work with larger and more complex projects, it quickly becomes
    important to divide your code up into separate workspaces because it makes your
    code easier to manage. To do this, in both the Arduino IDE and the Web Editor,
    we can add new tabs to a sketch.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new tab to the Arduino IDE, click on the button with an upside-down
    triangle in it that is located at the upper right side of the IDE window, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17df9d15-3f78-4982-80fc-48a433b0694e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the window that pops up, click on the New Tab option, and you will see an
    orange bar below the code section of the Arduino IDE windows. In this orange bar,
    you can name the new tab and then press the OK button to create the tab. The following
    screenshot shows how to name the new tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af64ca57-2280-48f2-ba1a-0718dabd3aaf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click OK a new tab is created, with the name you gave it, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c582b88-8706-47a0-a7ed-8536061683e7.png)'
  prefs: []
  type: TYPE_IMG
- en: We can create a new tab in the Web Editor exactly as we did in the Arduino IDE.
    In the Web Editor, there is a similar button with an upside-down triangle. When
    that button is clicked a menu will appear, and you can select the New Tab option.
    Once you name the new tab, it will appear in the Web Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start adding tabs to our projects, we need to have a plan on how we
    want to separate the code. I find that for large projects it is good practice
    to only have the `setup()` and `loop()` functions in the main tab. I then create
    a tab for each functional area of the project. For example, if I made a weather
    station that had both temperature rain sensors, then I would have my main tab
    with the `setup()` and `loop()` functions and then have two additional tabs; one
    for the temperature sensor functionality and one for the rain sensor functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using additional tabs for code, it is also good practice, for
    larger projects and libraries, to have tabs that define constants that need to
    be used in multiple tabs. These constants are usually put into header files. A
    header file should be named with a `.h` extension. Now let's see how to work with
    tabs.
  prefs: []
  type: TYPE_NORMAL
- en: Working with tabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating a new tab, the first thing we need to decide is what is going
    to the tab. For example in this section, we will create two new tabs. One will
    be named `led.h` and the other `led`. The `led.h` file will contain the constant
    definition, and the `led` file will contain code.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a tab with the `.h` extension we are creating, what is known
    in the C language, a header file. A header file is a file that contains declarations
    and macro definitions. These tabs can then be included in the normal code tabs.
    In the next section, we will see another type of tab which is the cpp tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the new tabs are created, add the following code to the `led.h` tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code will define two constants, which are the pin header numbers for the
    two LEDs on the prototype that we built in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping*. The `#ifndef` and `#endif` ensure that the header file is
    imported only once within any tab. The `#ifndef` looks to see if the `LED_H` constant
    is defined, and if not then it includes the code between the `#ifndef` and `#endif`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in the `led` tab add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `blink_led()` function contains a single parameter, which will be the pin
    for the LED that we wish to blink. The function itself will turn the LED on for
    1/2 a second and then turn it off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in the main tab, we will need to include an `#include` statement at the
    top of the tab to include the `led.h` header file. The following code shows how
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `#include` statement will take a header file and includes it in the tab,
    allowing us to use the definitions within our code. If we attempted to use one
    of the constants within our code but forgot to include the header file, we would
    receive an error that the constant was not declared in this scope meaning the
    compiler was unable to find the declarations for the constant.
  prefs: []
  type: TYPE_NORMAL
- en: If we are adding a header file from the sketch, we are working in, the name
    of the header file is surrounded by double quotes. If we include a header file
    from a separate library the name will be surrounded by the less than and greater
    than signs. We will see this later in this book as we use third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `loop()` function, we will want to call the `blink_led()` function from
    the `led` tab. One thing to note here is we only need to include the `#include`
    statement for the header file and not for the tab that contains the code. The
    following shows the code for the main tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now if you connect the prototype that we created in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping*, you should see the LEDs blink one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing your code between separate tabs is a great way to organize it when
    working with larger projects. This makes it a lot easier to maintain and organize
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are usually used when creating libraries for the Arduino. While creating
    libraries is beyond the scope of this book, it is good to know what classes are
    and how to use them because we will be using libraries in certain sections of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) is a programming paradigm that helps
    us divide our code into reusable components using classes and objects. An object
    is designed to model something. For example, we could create an LED object that
    will contain the properties and functionality we want for a LED; however, before
    we can create an object we need to have a blueprint for it. This blueprint is
    called a **class**. Let''s see how this works by creating a class that will help
    us control a LED.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start off by creating two new tabs named `led.cpp` and `led.h`. The
    `led.h` file will contain the definition for the class, and the `led.cpp` file
    will contain the code. Let''s start off by adding the following code to the `led.h`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is similar to the `led.h` file in the working with tabs section except
    the `Led` class definition is added. The `Led` class definition defines three
    properties (variables) for the class: `ledPin`, `onTime`, and `offTime`. Previous
    to this example, all of the variables we used have been either global variables
    or defined within a function. Class properties are variables that are defined
    within a class and usually define something about the object. In this example,
    the `ledPin` property defines what pin the LED is connected to; the `onTime` property
    defines the amount of time to keep the LED on and the `offTime` property defines
    how long to keep the LED off.'
  prefs: []
  type: TYPE_NORMAL
- en: After the properties, a constructor for the class is defined. A constructor
    is used to create an instance of a class, and we will see how to use this later
    in this section. After the constructor, three methods (functions) for the class.
    A class method is simply a function that is part of a class and usually defines
    the functionality of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where the `led.h` tab contains the definition for the `Led` class, the `led.cpp`
    tab contains the code for the class. Let''s add the following code to the `led.cpp`
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code starts off by importing two header files. The first header file is
    the `led.h` file that we just created and the second is the `Arduino.h` header
    file. The `Arduino.h` header file contains the definitions for all of the custom
    Arduino functions. It is automatically added to the main tab; however, if you
    wish to use the Arduino custom functions in other tabs, as is needed here, we
    need to import this file.
  prefs: []
  type: TYPE_NORMAL
- en: Following the imports is the implementation of the constructor for the `Led`
    class that was defined in the `led.h` tab. When we implement a constructor or
    a method for a class we prefix the name of it with the name of the class followed
    by two colons (::). The name of a constructor for a class is required to be the
    same as the class name. Therefore, the implementation for the constructor is `Led::Led`.
    Within the constructor, we set the class properties and the pin mode for the pin
    that the LED is connected too.
  prefs: []
  type: TYPE_NORMAL
- en: The next two class methods, `Led::turnOn` and `Led::turnOff`, use the `digitalWrite()`
    method to turn the LED on or off. Notice how these two methods us the `ledPin`
    property within the `digitalWrite()` method. This property is set within the constructor
    when the class is created.
  prefs: []
  type: TYPE_NORMAL
- en: Finally the implementation for the `Led::blinkLed()` method is defined. This
    method uses the `Led::turnOn` and `Led::turnOff` methods defined previously to
    blink the LED on and OFF. When we call a method of a class we use the dash/greater
    than signs together (`->`) as shown in the `blinkLed()` method. The `this` keyword
    is used to refer to the current instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how we would use the `Led` class. Within the main tab, the first
    thing we need to do is to include the `led.h` file. Add the following line to
    the top of the tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a global instance of the `Led` class and give it a
    name of `led`. To do this, we use the constructor that we created for the class.
    The following code will create an instance of the `Led` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `Led` class the constructor is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the definition for the `Led` class has three parameters (`pin`,
    `on` and `off`). These three parameters match the three values that we are passing
    into the constructor when we create an instance of the `Led` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the class to make the LED blink by calling the `blinkLed()`
    method of the class. The following code shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the code within the main tab that will use the `Led`
    class to blink an LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code on the prototype that we created in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping*, you will see one of the LEDs blink.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we only gave a very brief introduction to OOP enabling you
    to understand how most professional Arduino libraries are created and how to use
    them. There are whole books written about OOP, and if you wish to create libraries
    for the Arduino, I would recommend reading more object-oriented design in general
    and OOP for the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at how we can use the built-in String library for the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: String library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The String library, which is part of the Arduino core libraries, enables us
    to use and manipulate text easier and in a more complex way then character arrays
    do. It does take more memory to use the String library than it does to use character
    arrays but it is easier to use the String library
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous ways to create an instance of the String type. Let''s look
    at a few examples here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of the first two lines create a simple string with the word `Arduino`
    in it. In the third line, a new String instance is created from a single constant
    character. In this line, notice that the single quote is used. The last example
    concatenates two Strings. There are several more constructors that enable us to
    create instances of the String class from a number. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `strNum1` String instance would contain the text
    `42`, which is the decimal version of the number 42\. The `strNum2` String instance
    would contain the text `2a` which is the hex version of the number 42\. The `strNum3`
    String instance would contain the text `101010`, which is the binary version of
    the number 42.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also numerous methods that can be used in instances of the `String`
    class. Some of these methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`concat(string)`: Concatenates one string to the end of the original string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endsWith(string)`: Returns true if the original string ends with the characters
    of the other string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equals()`: Will compare two strings and return true if the strings contain
    the same text. When comparing the strings, this method is case sensitive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equalsIgnoreCase()`: Will compare two strings and returns true if the strings
    contain the same text. When comparing strings, this method is case insensitive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length()`: Returns the length of the strings. The length will not include
    the trailing null character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace(substring1, substring2)`: This method will replace all instances of
    one substring with another substring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startsWith(string)`: Returns true if the original string starts with the characters
    of the other string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLowerCase()`: Returns the lower case version of the original string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toUpperCase()`: Returns the upper case version of the original string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The String library can be used as a replacement for the character array; however,
    you will find that most sample code on the internet uses character arrays mainly
    because they take up less memory and they execute faster than the String library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This ends the introduction to the Arduino programming language. You can refer
    to the Arduino quick reference pages for additional information about the Arduino
    programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the reference pages here: [https://www.arduino.cc/reference/en/](https://www.arduino.cc/reference/en/).
    On this page, you will find links to information about the built-in Arduino functions
    and variables. That are also links to information about the operators and other
    Arduino language elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you do not feel comfortable writing your own Arduino programs
    right now because we will be writing a lot of code in the remaining chapters of
    this book, and by the end you should feel comfortable writing your own Arduino
    applications.
  prefs: []
  type: TYPE_NORMAL
