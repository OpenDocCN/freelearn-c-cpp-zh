<html><head></head><body>
		<div id="_idContainer114">
			<h1 id="_idParaDest-344"><a id="_idTextAnchor356"/><em class="italic">Chapter 18</em>: Particle Systems and Shaders</h1>
			<p>In this chapter, we will look at what a particle system is and then go ahead and code one into our game. We will scratch the surface of the topic of OpenGL shaders and see how writing code in another language (<strong class="bold">GLSL</strong>), that can be run directly on the graphics card, can lead to smooth graphical effects that might otherwise be impossible. As usual, we will also use our new skills and knowledge to enhance the current project.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Building a particle system</li>
				<li>OpenGL shaders and GLSL</li>
				<li>Using shaders in the Thomas Was Late game</li>
			</ul>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor357"/>Building a particle system</h1>
			<p>Before we start coding, it will be helpful to see exactly what it is that we are trying to achieve.</p>
			<p>Take a look at the following diagram:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B14278_18_01.jpg" alt=""/>
				</div>
			</div>
			<p>The previous illustration is a screenshot of the particle effect on a plain background. We will use this effect in our game. We will spawn one of these effects each time the player dies.</p>
			<p>The way we achieve this effect is as follows:</p>
			<ol>
				<li>First, we spawn 1,000 dots (particles), one on top of the other, at a chosen pixel position.</li>
				<li>Each frame of the game moves each of the 1,000 particles outwards at a predetermined but random speed and angle.</li>
				<li>Repeat step two for two seconds and then make the particles disappear.</li>
			</ol>
			<p>We will use a <strong class="source-inline">VertexArray</strong> to draw all the dots and the primitive type of <strong class="source-inline">Point</strong> to represent each particle visually. Furthermore, we will inherit from the SFML <strong class="source-inline">Drawable</strong> class so that our particle system can take care of drawing itself.</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor358"/>Coding the Particle class</h2>
			<p>The <strong class="source-inline">Particle</strong> class will be a simple class that represents just one particle from a thousand particles. Let's get coding.</p>
			<h3>Coding Particle.h</h3>
			<p>Right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Particle.h</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the header file for the <strong class="source-inline">Particle</strong> class.</p>
			<p>Add the following code to the <strong class="source-inline">Particle.h</strong> file:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Particle</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    Vector2f m_Position;</p>
			<p class="source-code">    Vector2f m_Velocity;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    Particle(Vector2f direction);</p>
			<p class="source-code">    void update(float dt);</p>
			<p class="source-code">    void setPosition(Vector2f position);</p>
			<p class="source-code">    Vector2f getPosition();</p>
			<p class="source-code">};</p>
			<p>In the preceding code, we have two <strong class="source-inline">Vector2f</strong> objects. One will represent the horizontal and vertical coordinate of the particle, while the other will represent the horizontal and vertical speed.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When you have a rate of change (speed) in more than one direction, the combined values also define a direction. This is called <strong class="bold">velocity</strong>. Hence,<strong class="source-inline">Vector2f</strong> is called <strong class="source-inline">m_Velocity</strong>.</p>
			<p>We also have several public functions. First is the constructor. It takes a <strong class="source-inline">Vector2f</strong> and uses this to let it know which direction/velocity this particle will have. This implies that the system, not the particle itself, will be choosing the velocity.</p>
			<p>Next is the <strong class="source-inline">update</strong> function, which takes the time the previous frame has taken. We will use this to move the particle by precisely the correct amount.</p>
			<p>The final two functions, <strong class="source-inline">setPosition</strong> and <strong class="source-inline">getPosition</strong>, are used to move the particle in position and find out its position, respectively.</p>
			<p>All of these functions will make complete sense when we code them.</p>
			<h3>Coding the Particle.cpp file</h3>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Particle.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">.cpp</strong> file for the <strong class="source-inline">Particle</strong> class.</p>
			<p>Add the following code to <strong class="source-inline">Particle.cpp</strong>:</p>
			<p class="source-code">#include "Particle.h"</p>
			<p class="source-code">Particle::Particle(Vector2f direction)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Determine the direction</p>
			<p class="source-code">    </p>
			<p class="source-code">    m_Velocity.x = direction.x;</p>
			<p class="source-code">    m_Velocity.y = direction.y;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Particle::update(float dtAsSeconds)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Move the particle</p>
			<p class="source-code">    m_Position += m_Velocity * dtAsSeconds;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Particle::setPosition(Vector2f position)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Position = position;</p>
			<p class="source-code">}</p>
			<p class="source-code">Vector2f Particle::getPosition()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Position;</p>
			<p class="source-code">}</p>
			<p>All of these functions use concepts we have seen before. The constructor sets up the <strong class="source-inline">m_Velocity.x</strong> and <strong class="source-inline">m_Velocity.y</strong> values using the passed in <strong class="source-inline">Vector2f</strong> object.</p>
			<p>The <strong class="source-inline">update</strong> function moves the horizontal and vertical positions of the particle by multiplying <strong class="source-inline">m_Velocity</strong> by the elapsed time (<strong class="source-inline">dtAsSeconds</strong>). Notice how, to achieve this, we simply add the two <strong class="source-inline">Vector2f</strong> objects together. There is no need to perform calculations for both the x and y members separately.</p>
			<p>The <strong class="source-inline">setPosition</strong> function, as we explained previously, initializes the <strong class="source-inline">m_Position</strong> object with the passed in values. The <strong class="source-inline">getPosition</strong> function returns <strong class="source-inline">m_Position</strong> to the calling code.</p>
			<p>We now have a fully functioning <strong class="source-inline">Particle</strong> class. Next, we will code a <strong class="source-inline">ParticleSystem</strong> class to spawn and control the particles. </p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor359"/>Coding the ParticleSystem class</h2>
			<p>The <strong class="source-inline">ParticleSystem</strong> class does most of the work for our particle effects. It is this class that we will create an instance of in the <strong class="source-inline">Engine</strong> class. Before we do, however, let's talk a little bit more about OOP and the SFML <strong class="source-inline">Drawable</strong> class.</p>
			<h1 id="_idParaDest-348"><a id="_idTextAnchor360"/>Exploring SFML's Drawable class and OOP</h1>
			<p>The <strong class="source-inline">Drawable</strong> class has just one function. It has no variables either. Furthermore, its one and only function is pure virtual. This means that, if we inherit from <strong class="source-inline">Drawable</strong>, we must implement its one and only function. The purpose, as a reminder from <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>, is that we can then use our class that inherits from <strong class="source-inline">drawable</strong> as a polymorphic type. Put more simply, anything that SFML allows us to do with a <strong class="source-inline">Drawable</strong> object, we will be able to do with our class that inherits from it. The only requirement is that we must provide a definition for the pure virtual function, <strong class="source-inline">draw</strong>.</p>
			<p>Some classes that inherit from <strong class="source-inline">Drawable</strong> already include <strong class="source-inline">Sprite</strong> and <strong class="source-inline">VertexArray</strong> (among others). Whenever we have used <strong class="source-inline">Sprite</strong> or <strong class="source-inline">VertexArray</strong>, we passed them to the <strong class="source-inline">draw</strong> function of the <strong class="source-inline">RenderWindow</strong> class.</p>
			<p>The reason that we have been able to draw every object we have ever drawn, in this entire book, is because they have all been inherited from <strong class="source-inline">Drawable</strong>. We can use this knowledge to our advantage.</p>
			<p>We can inherit from <strong class="source-inline">Drawable</strong> with any object we like, as long as we implement the pure virtual <strong class="source-inline">draw</strong> function. This is also a straightforward process. Consider a hypothetical <strong class="source-inline">SpaceShip</strong> class. The header file (<strong class="source-inline">SpaceShip.h</strong>) of the <strong class="source-inline">SpaceShip</strong> class that inherits from <strong class="source-inline">Drawable</strong> would look like this:</p>
			<p class="source-code">class SpaceShip : public Drawable</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    Sprite m_Sprite;</p>
			<p class="source-code">    // More private members</p>
			<p class="source-code">public:</p>
			<p class="source-code">    virtual void draw(RenderTarget&amp; target, </p>
			<p class="source-code">        RenderStates states) const;</p>
			<p class="source-code">    // More public members</p>
			<p class="source-code">};</p>
			<p>In the previous code, we can see the pure virtual <strong class="source-inline">draw</strong> function and a <strong class="source-inline">Sprite</strong> instance. Notice there is no way to access the private <strong class="source-inline">Sprite</strong> outside of the class – not even a <strong class="source-inline">getSprite</strong> function!</p>
			<p>The <strong class="source-inline">SpaceShip.cpp</strong> file would look something like this:</p>
			<p class="source-code">void SpaceShip::SpaceShip</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Set up the spaceship</p>
			<p class="source-code">}</p>
			<p class="source-code">void SpaceShip::draw(RenderTarget&amp; target, RenderStates states) const</p>
			<p class="source-code">{</p>
			<p class="source-code">    target.draw(m_Sprite, states);</p>
			<p class="source-code">}</p>
			<p class="source-code">// Any other functions</p>
			<p>In the previous code, notice the simple implementation of the <strong class="source-inline">draw</strong> function. The parameters are beyond the scope of this book. Just note that the <strong class="source-inline">target</strong> parameter is used to call <strong class="source-inline">draw</strong> and passes in <strong class="source-inline">m_Sprite</strong> as well as <strong class="source-inline">states</strong>, the other parameter.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">While it is not necessary to understand the parameters to take full advantage of <strong class="source-inline">Drawable</strong>, in the context of this book, you might be intrigued. You can read more about SFML <strong class="source-inline">Drawable</strong> on the SFML website here: <a href="https://www.sfml-dev.org/tutorials/2.5/graphics-vertex-array.php">https://www.sfml-dev.org/tutorials/2.5/graphics-vertex-array.php</a>.</p>
			<p>In the main game loop, we could now treat a <strong class="source-inline">SpaceShip</strong> instance as if it were a <strong class="source-inline">Sprite</strong> or any other class that inherits from <strong class="source-inline">Drawable</strong>, like so:</p>
			<p class="source-code">SpaceShip m_SpaceShip;</p>
			<p class="source-code">// create other objects here</p>
			<p class="source-code">// ...</p>
			<p class="source-code">// In the draw function</p>
			<p class="source-code">// Rub out the last frame</p>
			<p class="source-code">m_Window.clear(Color::Black);</p>
			<p class="source-code">// Draw the spaceship</p>
			<p class="source-code"><strong class="bold">m_Window.draw(m_SpaceShip);</strong></p>
			<p class="source-code">// More drawing here</p>
			<p class="source-code">// ...</p>
			<p class="source-code">// Show everything we have just drawn</p>
			<p class="source-code">m_Window.display();</p>
			<p>It is because <strong class="source-inline">SpaceShip</strong> <strong class="bold">is a</strong> <strong class="source-inline">Drawable</strong> that we can treat it like it was a <strong class="source-inline">Sprite</strong> or <strong class="source-inline">VertexArray</strong> and, because we overrode the pure virtual <strong class="source-inline">draw</strong> function, everything just works as we want it to. You will use this approach in this chapter to draw the particle system.</p>
			<p>While we are on the subject of OOP, let's look at an alternative way of encapsulating the drawing code into the game object that we will use in the next project.</p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor361"/>An alternative to inheriting from Drawable</h2>
			<p>It is also possible to keep all the drawing functionality within the class that is the object to be drawn by implementing our own function, within our class, perhaps by using the following code:</p>
			<p class="source-code">void drawThisObject(RenderWindow window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.draw(m_Sprite)</p>
			<p class="source-code">}</p>
			<p>The previous code assumes that <strong class="source-inline">m_Sprite</strong> represents the visual appearance of the current class we are drawing, as it has throughout this and the previous project. Assuming that the instance of the class that contains the <strong class="source-inline">drawThisObject</strong> function is called <strong class="source-inline">playerHero</strong> and further assuming we have an instance of <strong class="source-inline">RenderWindow</strong> called <strong class="source-inline">m_Window</strong>, we could then draw the object from the main game loop with this code:</p>
			<p class="source-code"> playerHero.draw(m_Window);</p>
			<p>In this solution, we pass the <strong class="source-inline">RenderWindow</strong>, <strong class="source-inline">m_Window</strong>, into the <strong class="source-inline">drawThisObject</strong> function as a parameter. The <strong class="source-inline">drawThisObject </strong>function then uses <strong class="source-inline">RenderWindow</strong> to draw the <strong class="source-inline">Sprite</strong>, <strong class="source-inline">m_Sprite</strong>.</p>
			<p>If we have a more complicated set of game objects, then passing a reference of <strong class="source-inline">RenderWindow</strong> to the object to be drawn, each frame, so it can draw itself, is a good tactic.</p>
			<p>We will use this tactic in the final project of this book, which we will start in the next chapter. Let's finish the particle system by coding the <strong class="source-inline">ParticleSystem</strong> class, which will inherit from <strong class="source-inline">Drawable</strong>.</p>
			<h3>Coding ParticleSystem.h</h3>
			<p>Right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">ParticleSystem.h</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the header file for the <strong class="source-inline">ParticleSystem</strong> class.</p>
			<p>Add the code for the <strong class="source-inline">ParticleSystem</strong> class to <strong class="source-inline">ParticleSystem.h</strong>:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "Particle.h"</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class ParticleSystem : public Drawable</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    vector&lt;Particle&gt; m_Particles;</p>
			<p class="source-code">    VertexArray m_Vertices;</p>
			<p class="source-code">    float m_Duration;</p>
			<p class="source-code">    bool m_IsRunning = false;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    virtual void draw(RenderTarget&amp; target, </p>
			<p class="source-code">      RenderStates states) const;</p>
			<p class="source-code">        </p>
			<p class="source-code">    void init(int count);</p>
			<p class="source-code">    void emitParticles(Vector2f position);</p>
			<p class="source-code">    void update(float elapsed);</p>
			<p class="source-code">    bool running();</p>
			<p class="source-code">};</p>
			<p>Let's go through this a bit at a time. First, notice that we are inheriting from SFML's <strong class="source-inline">Drawable</strong> class. This is what will allow us to pass our <strong class="source-inline">ParticleSystem</strong> instance to <strong class="source-inline">m_Window.draw</strong>, because <strong class="source-inline">ParticleSystem</strong> <strong class="bold">is a</strong> <strong class="source-inline">Drawable</strong>. And, since we inherit from <strong class="source-inline">Drawable</strong>, we can override the <strong class="source-inline">draw</strong> function using the same function signature as the <strong class="source-inline">Drawable</strong> class uses internally. Shortly, when we use the <strong class="source-inline">ParticleSystem</strong> class, we will see the following code.</p>
			<p class="source-code">m_Window.draw(m_PS);</p>
			<p>The <strong class="source-inline">m_PS</strong> object is an instance of our <strong class="source-inline">ParticleSystem</strong> class, and we will pass it directly to the <strong class="source-inline">draw</strong> function of the <strong class="source-inline">RenderWindow</strong> class, just like we have done for the <strong class="source-inline">Sprite</strong>, <strong class="source-inline">VertexArray</strong>, and <strong class="source-inline">RectangleShape</strong> instances. All this is made possible by the power of inheritance and polymorphism. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Don't add the <strong class="source-inline">m_Window.draw…</strong> code just yet; we have a bit more work to do first.</p>
			<p>There is a vector named <strong class="source-inline">m_Particles</strong> of the <strong class="source-inline">Particle</strong> type. This vector will hold each and every instance of <strong class="source-inline">Particle</strong>. Next, we have a <strong class="source-inline">VertexArray</strong> called <strong class="source-inline">m_Vertices</strong>. This will be used to draw all the particles in the form of a whole bunch of <strong class="source-inline">Point</strong> primitives. </p>
			<p>The <strong class="source-inline">m_Duration</strong>, <strong class="source-inline">float</strong> variable is how long each effect will last. We will initialize it in the constructor function.</p>
			<p>The <strong class="source-inline">m_IsRunning</strong> Boolean variable will be used to indicate whether the particle system is currently in use or not.</p>
			<p>Next, in the public section, we have the pure virtual function, <strong class="source-inline">draw</strong>, that we will soon implement to handle what happens when we pass our instance of <strong class="source-inline">ParticleSystem</strong> to <strong class="source-inline">m_Window.draw</strong>.</p>
			<p>The <strong class="source-inline">init</strong> function will prepare the <strong class="source-inline">VertexArray</strong> and the <strong class="source-inline">vector</strong>. It will also initialize all the <strong class="source-inline">Particle</strong> objects (held by the <strong class="source-inline">vector</strong>) with their velocities and initial positions.</p>
			<p>The <strong class="source-inline">update</strong> function will loop through each <strong class="source-inline">Particle</strong> instance in the <strong class="source-inline">vector</strong> and call their individual <strong class="source-inline">update</strong> functions.</p>
			<p>The <strong class="source-inline">running</strong> function provides access to the <strong class="source-inline">m_IsRunning</strong> variable so that the game engine can query whether the <strong class="source-inline">ParticleSystem</strong> is currently in use.</p>
			<p>Let's code the function definitions to see what goes on inside <strong class="source-inline">ParticleSystem</strong>.</p>
			<h3>Coding the ParticleSystem.cpp file</h3>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">ParticleSystem.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">.cpp</strong> file for the <strong class="source-inline">ParticleSystem</strong> class.</p>
			<p>We will split this file into five sections so that we can code and discuss it in more detail. Add the first section of code, as follows:</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "ParticleSystem.h"</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">void ParticleSystem::init(int numParticles)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Vertices.setPrimitiveType(Points);</p>
			<p class="source-code">    m_Vertices.resize(numParticles);</p>
			<p class="source-code">    // Create the particles</p>
			<p class="source-code">    for (int i = 0; i &lt; numParticles; i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        srand(time(0) + i);</p>
			<p class="source-code">        float angle = (rand() % 360) * 3.14f / 180.f;</p>
			<p class="source-code">        float speed = (rand() % 600) + 600.f;</p>
			<p class="source-code">        Vector2f direction;</p>
			<p class="source-code">        direction = Vector2f(cos(angle) * speed,</p>
			<p class="source-code">            sin(angle) * speed);</p>
			<p class="source-code">        m_Particles.push_back(Particle(direction));</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>After the necessary <strong class="source-inline">includes</strong>, we have the definition of the<strong class="source-inline"> init</strong> function. We call <strong class="source-inline">setPrimitiveType</strong> with <strong class="source-inline">Points</strong> as the argument so that <strong class="source-inline">m_VertexArray</strong> knows what type of primitives it will be dealing with. We resize <strong class="source-inline">m_Vertices</strong> with <strong class="source-inline">numParticles</strong>, which was passed in to the <strong class="source-inline">init</strong> function when it was called.</p>
			<p>The <strong class="source-inline">for</strong> loop creates random values for speed and angle. It then uses trigonometric functions to convert those values into a vector which is stored in the <strong class="source-inline">Vector2f</strong>, <strong class="source-inline">direction</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to know more about how the trigonometric functions (<strong class="source-inline">cos</strong> and <strong class="source-inline">sin</strong>) convert angles and speeds into a vector, then you can take a look at this article series: <a href="http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/">http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/</a>.</p>
			<p>The last thing that happens in the <strong class="source-inline">for</strong> loop (and the <strong class="source-inline">init</strong> function) is that the vector is passed into the <strong class="source-inline">Particle</strong> constructor. The new <strong class="source-inline">Particle</strong> instance is stored in <strong class="source-inline">m_Particles</strong> using the <strong class="source-inline">push_back</strong> function. Therefore, a call to <strong class="source-inline">init</strong> with a value of <strong class="source-inline">1000</strong> would mean we have 1,000 instances of <strong class="source-inline">Particle</strong>, with random velocity, stashed away in <strong class="source-inline">m_Particles</strong>, just waiting to blow!</p>
			<p>Next, add the <strong class="source-inline">update</strong> function to <strong class="source-inline">ParticleSysytem.cpp</strong>:</p>
			<p class="source-code">void ParticleSystem::update(float dt)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Duration -= dt;</p>
			<p class="source-code">    vector&lt;Particle&gt;::iterator i;</p>
			<p class="source-code">    int currentVertex = 0;</p>
			<p class="source-code">    for (i = m_Particles.begin(); i != m_Particles.end(); i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Move the particle</p>
			<p class="source-code">        (*i).update(dt);</p>
			<p class="source-code">        // Update the vertex array</p>
			<p class="source-code">        m_Vertices[currentVertex++].position = i-&gt;getPosition();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_Duration &lt; 0)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_IsRunning = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">update</strong> function is simpler than it looks at first glance. First of all, <strong class="source-inline">m_Duration</strong> is reduced by the passed in time, <strong class="source-inline">dt</strong>. This is so we know when the two seconds have elapsed. A vector iterator, <strong class="source-inline">i</strong>, is declared for use with <strong class="source-inline">m_Particles</strong>.</p>
			<p>The <strong class="source-inline">for</strong> loop goes through each of the <strong class="source-inline">Particle</strong> instances in <strong class="source-inline">m_Particles</strong>. For each one, it calls its <strong class="source-inline">update</strong> function and passes in <strong class="source-inline">dt</strong>. Each particle will update its position.  After the particle has updated itself, the appropriate vertex in <strong class="source-inline">m_Vertices</strong> is updated by using the particle's <strong class="source-inline">getPosition</strong> function. At the end of each pass through the <strong class="source-inline">for</strong> loop, <strong class="source-inline">currentVertex</strong> is incremented, ready for the next vertex.</p>
			<p>After the <strong class="source-inline">for</strong> loop has completed the code, <strong class="source-inline">if(m_Duration &lt; 0)</strong> checks whether it is time to switch off the effect. If two seconds have elapsed, <strong class="source-inline">m_IsRunning</strong> is set to <strong class="source-inline">false</strong>.</p>
			<p>Next, add the <strong class="source-inline">emitParticles</strong> function:</p>
			<p class="source-code">void ParticleSystem::emitParticles(Vector2f startPosition)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_IsRunning = true;</p>
			<p class="source-code">    m_Duration = 2;</p>
			<p class="source-code">    </p>
			<p class="source-code">    int currentVertex = 0;</p>
			<p class="source-code">    for (auto it = m_Particles.begin(); </p>
			<p class="source-code">         it != m_Particles.end();</p>
			<p class="source-code">         it++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Vertices[currentVertex++].color = Color::Yellow;</p>
			<p class="source-code">        it-&gt;setPosition(startPosition);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This is the function we will call to start the particle system. So predictably, we set <strong class="source-inline">m_IsRunning</strong> to <strong class="source-inline">true</strong> and <strong class="source-inline">m_Duration</strong> to <strong class="source-inline">2</strong>. We declare an <strong class="source-inline">iterator</strong>, <strong class="source-inline">i</strong>, to iterate through all the <strong class="source-inline">Particle</strong> objects in <strong class="source-inline">m_Particles</strong> and then we do so in a <strong class="source-inline">for</strong> loop.</p>
			<p>Inside the <strong class="source-inline">for</strong> loop, we set each particle in the vertex array to yellow and set each position to <strong class="source-inline">startPosition</strong>, which was passed in as a parameter. Remember that each particle starts life in the same position, but they are each assigned a different velocity.</p>
			<p>Next, add the pure virtual <strong class="source-inline">draw</strong> function definition:</p>
			<p class="source-code">void ParticleSystem::</p>
			<p class="source-code">       draw(RenderTarget&amp; target, </p>
			<p class="source-code">       RenderStates states) const</p>
			<p class="source-code">{</p>
			<p class="source-code">    target.draw(m_Vertices, states);</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we simply use <strong class="source-inline">target</strong> to call <strong class="source-inline">draw</strong>, passing <strong class="source-inline">m_Vertices</strong> and <strong class="source-inline">states</strong> as parameters. Remember that we will never call this function directly! Shortly, when we declare an instance of <strong class="source-inline">ParticleSystem</strong>, we will pass that instance to the <strong class="source-inline">RenderWindow draw</strong> function. The <strong class="source-inline">draw</strong> function we have just coded will be called internally from there.</p>
			<p>Finally, add the <strong class="source-inline">running</strong> function:</p>
			<p class="source-code">bool ParticleSystem::running()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_IsRunning;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">running</strong> function is a simple getter function that returns the value of <strong class="source-inline">m_IsRunning</strong>. We will see where this is useful in this chapter, so that we can determine the current state of the particle system.</p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor362"/>Using the ParticleSystem object</h2>
			<p>Putting our particle </p>
			<p>system to work is very straightforward, especially because we inherited from <strong class="source-inline">Drawable</strong>.</p>
			<h3>Adding a ParticleSystem object to the Engine class</h3>
			<p>Open <strong class="source-inline">Engine.h</strong> and add a <strong class="source-inline">ParticleSystem</strong> object, as shown in the following highlighted code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">#include "Thomas.h"</p>
			<p class="source-code">#include "Bob.h"</p>
			<p class="source-code">#include "LevelManager.h"</p>
			<p class="source-code">#include "SoundManager.h"</p>
			<p class="source-code">#include "HUD.h"</p>
			<p class="source-code"><strong class="bold">#include "ParticleSystem.h"</strong></p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Engine</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // The texture holder</p>
			<p class="source-code">    TextureHolder th;</p>
			<p class="source-code"><strong class="bold">    // create a particle system</strong></p>
			<p class="source-code"><strong class="bold">    ParticleSystem m_PS;</strong></p>
			<p class="source-code">    // Thomas and his friend, Bob</p>
			<p class="source-code">    Thomas m_Thomas;</p>
			<p class="source-code">    Bob m_Bob;</p>
			<p>Now, we need to initialize the system.</p>
			<h3>Initializing ParticleSystem</h3>
			<p>Open the <strong class="source-inline">Engine.cpp</strong> file and add the short highlighted code right at the end of the <strong class="source-inline">Engine</strong> constructor:</p>
			<p class="source-code">Engine::Engine()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Get the screen resolution and create an SFML window and View</p>
			<p class="source-code">    Vector2f resolution;</p>
			<p class="source-code">    resolution.x = VideoMode::getDesktopMode().width;</p>
			<p class="source-code">    resolution.y = VideoMode::getDesktopMode().height;</p>
			<p class="source-code">    m_Window.create(VideoMode(resolution.x, resolution.y),</p>
			<p class="source-code">        "Thomas was late",</p>
			<p class="source-code">        Style::Fullscreen);</p>
			<p class="source-code">    // Initialize the full screen view</p>
			<p class="source-code">    m_MainView.setSize(resolution);</p>
			<p class="source-code">    m_HudView.reset(</p>
			<p class="source-code">        FloatRect(0, 0, resolution.x, resolution.y));</p>
			<p class="source-code">    // Initialize the split-screen Views</p>
			<p class="source-code">    m_LeftView.setViewport(</p>
			<p class="source-code">        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));</p>
			<p class="source-code">    m_RightView.setViewport(</p>
			<p class="source-code">        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));</p>
			<p class="source-code">    m_BGLeftView.setViewport(</p>
			<p class="source-code">        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));</p>
			<p class="source-code">    m_BGRightView.setViewport(</p>
			<p class="source-code">        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));</p>
			<p class="source-code">    // Can this graphics card use shaders?</p>
			<p class="source-code">    if (!sf::Shader::isAvailable())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Time to get a new PC</p>
			<p class="source-code">        m_Window.close();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    m_BackgroundTexture = TextureHolder::GetTexture(</p>
			<p class="source-code">        "graphics/background.png");</p>
			<p class="source-code">    // Associate the sprite with the texture</p>
			<p class="source-code">    m_BackgroundSprite.setTexture(m_BackgroundTexture);</p>
			<p class="source-code">    // Load the texture for the background vertex array</p>
			<p class="source-code">    m_TextureTiles = TextureHolder::GetTexture(</p>
			<p class="source-code">        "graphics/tiles_sheet.png");</p>
			<p class="source-code"><strong class="bold">    // Initialize the particle system</strong></p>
			<p class="source-code"><strong class="bold">    m_PS.init(1000);</strong></p>
			<p class="source-code">}// End Engine constructor</p>
			<p>The <strong class="source-inline">VertexArray</strong> and the <strong class="source-inline">vector</strong> of <strong class="source-inline">Particle</strong> instances are ready for action.</p>
			<h3>Updating the particle system each frame</h3>
			<p>Open the <strong class="source-inline">Update.cpp</strong> file and add the following highlighted code. It can go right at the end of the <strong class="source-inline">update</strong> function:</p>
			<p class="source-code">    // Update the HUD every m_TargetFramesPerHUDUpdate frames</p>
			<p class="source-code">    if (m_FramesSinceLastHUDUpdate &gt; m_TargetFramesPerHUDUpdate)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Update game HUD text</p>
			<p class="source-code">        stringstream ssTime;</p>
			<p class="source-code">        stringstream ssLevel;</p>
			<p class="source-code">        // Update the time text</p>
			<p class="source-code">        ssTime &lt;&lt; (int)m_TimeRemaining;</p>
			<p class="source-code">        m_Hud.setTime(ssTime.str());</p>
			<p class="source-code">        // Update the level text</p>
			<p class="source-code">        ssLevel &lt;&lt; "Level:" &lt;&lt; m_LM.getCurrentLevel();</p>
			<p class="source-code">        m_Hud.setLevel(ssLevel.str());</p>
			<p class="source-code">        m_FramesSinceLastHUDUpdate = 0;</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // Update the particles</strong></p>
			<p class="source-code"><strong class="bold">    if (m_PS.running())</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_PS.update(dtAsSeconds);</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}// End of update function</p>
			<p>All that is needed in the previous code is the call to <strong class="source-inline">update</strong>. Notice that it is wrapped in a check to make sure the system is currently running. If it isn't running, there is no point updating it.</p>
			<h3>Starting the particle system</h3>
			<p>Open the <strong class="source-inline">DetectCollisions.cpp</strong> file, which has the <strong class="source-inline">detectCollisions</strong> function in it. We left a comment in it when we originally coded it.</p>
			<p>Identify the correct place from the context and add the following highlighted code:</p>
			<p class="source-code">// Is character colliding with a regular block</p>
			<p class="source-code">if (m_ArrayLevel[y][x] == 1)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (character.getRight().intersects(block))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        character.stopRight(block.left);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (character.getLeft().intersects(block))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        character.stopLeft(block.left);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (character.getFeet().intersects(block))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        character.stopFalling(block.top);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (character.getHead().intersects(block))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        character.stopJump();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">// More collision detection here once </p>
			<p class="source-code">// we have learned about particle effects</p>
			<p class="source-code"><strong class="bold">// Have the characters' feet touched fire or water?</strong></p>
			<p class="source-code"><strong class="bold">// If so, start a particle effect</strong></p>
			<p class="source-code"><strong class="bold">// Make sure this is the first time we have detected this</strong></p>
			<p class="source-code"><strong class="bold">// by seeing if an effect is already running            </strong></p>
			<p class="source-code"><strong class="bold">if (!m_PS.running()) {</strong></p>
			<p class="source-code"><strong class="bold">    if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        if (character.getFeet().intersects(block))</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            // position and start the particle system</strong></p>
			<p class="source-code"><strong class="bold">            m_PS.emitParticles(character.getCenter());</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">// Has the character reached the goal?</p>
			<p class="source-code">if (m_ArrayLevel[y][x] == 4)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Character has reached the goal</p>
			<p class="source-code">    reachedGoal = true;</p>
			<p class="source-code">}</p>
			<p>First, the code checks if the particle system is already running. If it isn't, it checks if the current tile being checked is either a water or fire tile. If either is the case, it checks whether the character's feet are in contact with it. When each of these <strong class="source-inline">if</strong> statements are true, the particle system is started by calling the <strong class="source-inline">emitParticles</strong> function and passing in the location of the center of the character as the coordinates to start the effect.</p>
			<h3>Drawing the particle system</h3>
			<p>This is the best bit. See how easy it is to draw <strong class="source-inline">ParticleSystem</strong>. We pass our instance directly to the <strong class="source-inline">m_Window.draw</strong> function, after checking that the particle system is running.</p>
			<p>Open the <strong class="source-inline">Draw.cpp</strong> file and add the following highlighted code in all the necessary places:</p>
			<p class="source-code">void Engine::draw()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Rub out the last frame</p>
			<p class="source-code">    m_Window.clear(Color::White);</p>
			<p class="source-code">    if (!m_SplitScreen)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGMainView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_MainView</p>
			<p class="source-code">        m_Window.setView(m_MainView);        </p>
			<p class="source-code">        // Draw the Level</p>
			<p class="source-code">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Thomas.getSprite());</p>
			<p class="source-code">        // Draw bob</p>
			<p class="source-code">        m_Window.draw(m_Bob.getSprite());</p>
			<p class="source-code"><strong class="bold">        // Draw the particle system</strong></p>
			<p class="source-code"><strong class="bold">        if (m_PS.running())</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            m_Window.draw(m_PS);</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Split-screen view is active</p>
			<p class="source-code">        // First draw Thomas' side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGLeftView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_LeftView</p>
			<p class="source-code">        m_Window.setView(m_LeftView);</p>
			<p class="source-code">        // Draw the Level</p>
			<p class="source-code">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</p>
			<p class="source-code">            </p>
			<p class="source-code">        // Draw bob</p>
			<p class="source-code">        m_Window.draw(m_Bob.getSprite());</p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Thomas.getSprite());</p>
			<p class="source-code"><strong class="bold">        // Draw the particle system</strong></p>
			<p class="source-code"><strong class="bold">        if (m_PS.running())</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            m_Window.draw(m_PS);</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code">        </p>
			<p class="source-code">        // Now draw Bob's side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGRightView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_RightView</p>
			<p class="source-code">        m_Window.setView(m_RightView);</p>
			<p class="source-code">        // Draw the Level</p>
			<p class="source-code">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Thomas.getSprite());</p>
			<p class="source-code">        // Draw bob</p>
			<p class="source-code">        m_Window.draw(m_Bob.getSprite());</p>
			<p class="source-code"><strong class="bold">        // Draw the particle system</strong></p>
			<p class="source-code"><strong class="bold">        if (m_PS.running())</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            m_Window.draw(m_PS);</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code">                </p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Draw the HUD</p>
			<p class="source-code">    // Switch to m_HudView</p>
			<p class="source-code">    m_Window.setView(m_HudView);</p>
			<p class="source-code">    m_Window.draw(m_Hud.getLevel());</p>
			<p class="source-code">    m_Window.draw(m_Hud.getTime());</p>
			<p class="source-code">    if (!m_Playing)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Window.draw(m_Hud.getMessage());</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    </p>
			<p class="source-code">    // Show everything we have just drawn</p>
			<p class="source-code">    m_Window.display();</p>
			<p class="source-code">}</p>
			<p>Note that we must draw the particle system in all of the left, right, and full-screen code blocks.</p>
			<p>Run the game and move one of the character's feet over the edge of a fire tile. Notice the particle system burst into life:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B14278_18_02.jpg" alt=""/>
				</div>
			</div>
			<p>No<a id="_idTextAnchor363"/>w, it's time for something else that's new.</p>
			<h1 id="_idParaDest-351"><a id="_idTextAnchor364"/>OpenGL, Shaders, and GLSL</h1>
			<p>The<strong class="bold"> Open Graphics Library</strong> (<strong class="bold">OpenGL</strong>) is a programming library that handles 2D as well as 3D graphics. OpenGL works on all major desktop operating systems and there is also a version that works on mobile devices, known as OpenGL ES.</p>
			<p>OpenGL was originally released in 1992. It has been refined and improved over more than twenty years. Furthermore, graphics card manufacturers design their hardware to make it work well with OpenGL. The point of mentioning this is not for the history lesson but to explain that it would be a fool's errand to try and improve upon OpenGL and use it in 2D (and 3D games) on the desktop, especially if we want our game to run on more than just Windows, which is the obvious choice. We are already using OpenGL because SFML uses OpenGL. Shaders are programs that run on the GPU itself. We'll find out more about them in the following section.</p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor365"/>The programmable pipeline and shaders</h2>
			<p>Through OpenGL, we have access to what is called a<strong class="bold"> programmable pipeline</strong>. We can send our graphics off to be drawn, each frame, with the <strong class="source-inline">RenderWindow</strong> instance's <strong class="source-inline">draw</strong> function. We can also write code that runs on the GPU that can manipulate each and every pixel independently, after the call to <strong class="source-inline">draw</strong>. This is a very powerful feature.</p>
			<p>This extra code that runs on the GPU is called a <strong class="bold">shader program</strong>. We can write code to manipulate the geometry (position) of our graphics in a <strong class="bold">vertex shader</strong>. We can also write code that manipulates the appearance of every pixel individually in code. This is known as a <strong class="bold">fragment shader</strong>. </p>
			<p>Although we will not be exploring shaders in any great depth, we will write some shader code using the <strong class="bold">GL Shader Language</strong> (<strong class="bold">GLSL</strong>) and we will get a glimpse of the possibilities that it offers.</p>
			<p>In OpenGL, everything is a point, a line, or a triangle. In addition, we can attach colors and textures to this basic geometry, and we can also combine these elements to make the complex graphics that we see in today's modern games. These are collectively known as <strong class="bold">primitives</strong>. We have access to OpenGL primitives through the SFML primitives and <strong class="source-inline">VertexArray</strong>, as well as the <strong class="source-inline">Sprite</strong> and <strong class="source-inline">Shape</strong> classes.</p>
			<p>In addition to primitives, OpenGL uses matrices. Matrices are a method and structure for performing arithmetic. This arithmetic can range from extremely simple high school-level calculations such as  moving (translating) a coordinate or it can be quite complex, such as performing more advanced mathematics, for example, to convert our game world coordinates into OpenGL screen coordinates that the GPU can use. Fortunately, it is this complexity that SFML handles for us behind the scenes. SFML also allows us to handle OpenGL directly.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to find out more about OpenGL, you can get started here: <a href="http://learnopengl.com/#!Introduction">http://learnopengl.com/#!Introduction</a>. If you want to use OpenGL directly, alongside SFML, you can read this article to find out more: <a href="https://www.sfml-dev.org/tutorials/2.5/window-opengl.php">https://www.sfml-dev.org/tutorials/2.5/window-opengl.php</a>.</p>
			<p>An application can have many shaders. We can then <em class="italic">attach</em> different shaders to different game objects to create the desired effects. We will only have one vertex and one fragment shader in this game. We will apply it to every frame, as well as to the background.</p>
			<p>However, when you see how to attach a shader to a <strong class="source-inline">draw</strong> call, it will be plain that it is trivial to have more shaders.</p>
			<p>We will follow these steps:</p>
			<ol>
				<li value="1">First, we need the code for the shader that will be executed on the GPU.  </li>
				<li>Then, we need to compile that code.</li>
				<li>Finally, we need to attach the shader to the appropriate <strong class="source-inline">draw</strong> function call in the draw function of our game engine. </li>
			</ol>
			<p>GLSL is a language and it also has its own types, and variables of those types, which can be declared and utilized.  Furthermore, we can interact with the shader program's variables from our C++ code.</p>
			<p>As we will see, GLSL has some syntax similarities to C++.</p>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor366"/>Coding a fragment shader</h2>
			<p>Here is the code from the <strong class="source-inline">rippleShader.frag</strong> file in the <strong class="source-inline">shaders</strong> folder. We don't need to code this because it is in the assets that we added back in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>:</p>
			<p class="source-code">// attributes from vertShader.vert</p>
			<p class="source-code">varying vec4 vColor;</p>
			<p class="source-code">varying vec2 vTexCoord;</p>
			<p class="source-code">// uniforms</p>
			<p class="source-code">uniform sampler2D uTexture;</p>
			<p class="source-code">uniform float uTime;</p>
			<p class="source-code">void main() {</p>
			<p class="source-code">    float coef = sin(gl_FragCoord.y * 0.1 + 1 * uTime);</p>
			<p class="source-code">    vTexCoord.y +=  coef * 0.03;</p>
			<p class="source-code">    gl_FragColor = vColor * texture2D(uTexture, vTexCoord);</p>
			<p class="source-code">}</p>
			<p>The first four lines (excluding comments) are the variables that the fragment shader will use, but they are not ordinary variables. The first type we can see is <strong class="source-inline">varying</strong>. These are variables which are in scope between both <strong class="source-inline">shaders</strong>. Next, we have the <strong class="source-inline">uniform</strong> variables. These variables can be manipulated directly from our C++ code. We will see how we do this soon.</p>
			<p>In addition to the <strong class="source-inline">varying</strong> and <strong class="source-inline">uniform</strong> types, each of the variables also has a more conventional type that defines the actual data, as follows: </p>
			<ul>
				<li><strong class="source-inline">vec4</strong> is a vector with four values.</li>
				<li><strong class="source-inline">vec2</strong> is a vector with two values.</li>
				<li><strong class="source-inline">sampler2d </strong>will hold a texture.</li>
				<li><strong class="source-inline">float</strong> is just like a <strong class="source-inline">float data type</strong> in C++.</li>
			</ul>
			<p>The code inside the <strong class="source-inline">main</strong> function is executed. If we look closely at the code in <strong class="source-inline">main</strong>, we will see each of the variables in use. Exactly what this code does is beyond the scope of the book. In summary, however, the texture coordinates (<strong class="source-inline">vTexCoord</strong>) and the color of the pixels/fragments (<strong class="source-inline">glFragColor</strong>) are manipulated by several mathematical functions and operations. Remember that this executes for each pixel involved in the <strong class="source-inline">draw</strong> function that's called on each frame of our game. Furthermore, be aware that <strong class="source-inline">uTime</strong> is passed in as a different value for each frame. The result, as we will soon see, will be a rippling effect.</p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor367"/>Coding a vertex shader</h2>
			<p>Here is the code from the <strong class="source-inline">vertShader.vert</strong> file. You don't need to code this. It was in the assets we added back in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>:</p>
			<p class="source-code">//varying "out" variables to be used in the fragment shader</p>
			<p class="source-code">varying vec4 vColor;</p>
			<p class="source-code">varying vec2 vTexCoord;</p>
			<p class="source-code"> </p>
			<p class="source-code">void main() {</p>
			<p class="source-code">    vColor = gl_Color;</p>
			<p class="source-code">    vTexCoord = (gl_TextureMatrix[0] * gl_MultiTexCoord0).xy;</p>
			<p class="source-code">    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;</p>
			<p class="source-code">}</p>
			<p>First of all, notice the two <strong class="source-inline">varying</strong> variables. These are the very same variables that we manipulated back in the fragment shader. In the <strong class="source-inline">main</strong> function, the code manipulates the position of each and every vertex. How the code works is beyond the scope of this book, but there is some quite in-depth mathematics going on behind the scenes. If it interests you, then exploring GLSL further will be fascinating.</p>
			<p>Now that we have two shaders (one fragment and one vertex), we can use them in our game.</p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor368"/>Adding shaders to the engine class</h2>
			<p>Open the <strong class="source-inline">Engine.h</strong> file. Add the following highlighted line of code, which adds an SFML <strong class="source-inline">Shader</strong> instance called <strong class="source-inline">m_RippleShader</strong> to the <strong class="source-inline">Engine</strong> class:</p>
			<p class="source-code">// Three views for the background</p>
			<p class="source-code">View m_BGMainView;</p>
			<p class="source-code">View m_BGLeftView;</p>
			<p class="source-code">View m_BGRightView;</p>
			<p class="source-code">View m_HudView;</p>
			<p class="source-code">// Declare a sprite and a Texture for the background</p>
			<p class="source-code">Sprite m_BackgroundSprite;</p>
			<p class="source-code">Texture m_BackgroundTexture;</p>
			<p class="source-code"><strong class="bold">// Declare a shader for the background</strong></p>
			<p class="source-code"><strong class="bold">Shader m_RippleShader;</strong></p>
			<p class="source-code">// Is the game currently playing?</p>
			<p class="source-code">bool m_Playing = false;</p>
			<p class="source-code">// Is character 1 or 2 the current focus?</p>
			<p class="source-code">bool m_Character1 = true;</p>
			<p>The engine object and all its functions now have access to <strong class="source-inline">m_RippleShader</strong>. Note that an SFML <strong class="source-inline">Shader</strong> object will be comprised of both shader code files.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor369"/>Loading the shaders</h2>
			<p>Add the following code, which checks whether the player's GPU can handle shaders. The game will quit if it can't. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You will have to have an exceptionally old PC for this not to work. If you do have a GPU that doesn't handle shaders, please accept my apologies.</p>
			<p>Next, we will add an <strong class="source-inline">else</strong> clause that loads the shaders if the system can handle them. Open the <strong class="source-inline">Engine.cpp</strong> file and add this code to the constructor:</p>
			<p class="source-code"><strong class="bold">// Can this graphics card use shaders?</strong></p>
			<p class="source-code"><strong class="bold">if (!sf::Shader::isAvailable())</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    // Time to get a new PC</strong></p>
			<p class="source-code"><strong class="bold">    // Or remove all the shader related code L</strong></p>
			<p class="source-code"><strong class="bold">    m_Window.close();</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code"><strong class="bold">else</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    // Load two shaders (1 vertex, 1 fragment)</strong></p>
			<p class="source-code"><strong class="bold">    m_RippleShader.loadFromFile("shaders/vertShader.vert",</strong></p>
			<p class="source-code"><strong class="bold">        "shaders/rippleShader.frag");</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">m_BackgroundTexture = TextureHolder::GetTexture(</p>
			<p class="source-code">    "graphics/background.png");</p>
			<p>We are nearly ready to see our ripple effect in action.</p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor370"/>Updating and drawing the shader</h2>
			<p>Open the <strong class="source-inline">Draw.cpp</strong> file. As we already discussed when we coded the shaders, we will update the <strong class="source-inline">uTime</strong> variable directly from our C++ code each frame. We will do so with the <strong class="source-inline">setParameter</strong> function.</p>
			<p>Add the following highlighted code to update the shader's <strong class="source-inline">uTime</strong> variable and change the call to <strong class="source-inline">draw</strong> for <strong class="source-inline">m_BackgroundSprite</strong>, in each of the possible drawing scenarios:</p>
			<p class="source-code">void Engine::draw()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Rub out the last frame</p>
			<p class="source-code">    m_Window.clear(Color::White);</p>
			<p class="source-code"><strong class="bold">    // Update the shader parameters</strong></p>
			<p class="source-code"><strong class="bold">    m_RippleShader.setUniform("uTime", </strong></p>
			<p class="source-code"><strong class="bold">      m_GameTimeTotal.asSeconds());</strong></p>
			<p class="source-code">    if (!m_SplitScreen)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGMainView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code"><strong class="bold">        //m_Window.draw(m_BackgroundSprite);</strong></p>
			<p class="source-code"><strong class="bold">        // Draw the background, complete with shader effect</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_BackgroundSprite, &amp;m_RippleShader);</strong></p>
			<p class="source-code">        // Switch to m_MainView</p>
			<p class="source-code">        m_Window.setView(m_MainView);</p>
			<p class="source-code">        // Draw the Level</p>
			<p class="source-code">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Thomas.getSprite());</p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Bob.getSprite());</p>
			<p class="source-code">        // Draw the particle system</p>
			<p class="source-code">        if (m_PS.running())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_Window.draw(m_PS);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Split-screen view is active</p>
			<p class="source-code">        // First draw Thomas' side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGLeftView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code"><strong class="bold">        //m_Window.draw(m_BackgroundSprite);</strong></p>
			<p class="source-code"><strong class="bold">        // Draw the background, complete with shader effect</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_BackgroundSprite, &amp;m_RippleShader);</strong></p>
			<p class="source-code">        // Switch to m_LeftView</p>
			<p class="source-code">        m_Window.setView(m_LeftView);</p>
			<p class="source-code">        // Draw the Level</p>
			<p class="source-code">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</p>
			<p class="source-code">            </p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Bob.getSprite());</p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Thomas.getSprite());</p>
			<p class="source-code">        // Draw the particle system</p>
			<p class="source-code">        if (m_PS.running())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_Window.draw(m_PS);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        </p>
			<p class="source-code">        // Now draw Bob's side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGRightView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code"><strong class="bold">        //m_Window.draw(m_BackgroundSprite);</strong></p>
			<p class="source-code"><strong class="bold">        // Draw the background, complete with shader effect</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_BackgroundSprite, &amp;m_RippleShader);</strong></p>
			<p class="source-code">        // Switch to m_RightView</p>
			<p class="source-code">        m_Window.setView(m_RightView);</p>
			<p class="source-code">        // Draw the Level</p>
			<p class="source-code">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Thomas.getSprite());</p>
			<p class="source-code">        // Draw bob</p>
			<p class="source-code">        m_Window.draw(m_Bob.getSprite());</p>
			<p class="source-code">        // Draw the particle system</p>
			<p class="source-code">        if (m_PS.running())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_Window.draw(m_PS);</p>
			<p class="source-code">        }                </p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Draw the HUD</p>
			<p class="source-code">    // Switch to m_HudView</p>
			<p class="source-code">    m_Window.setView(m_HudView);</p>
			<p class="source-code">    m_Window.draw(m_Hud.getLevel());</p>
			<p class="source-code">    m_Window.draw(m_Hud.getTime());</p>
			<p class="source-code">    if (!m_Playing)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Window.draw(m_Hud.getMessage());</p>
			<p class="source-code">    }    </p>
			<p class="source-code">    </p>
			<p class="source-code">    // Show everything we have just drawn</p>
			<p class="source-code">    m_Window.display();</p>
			<p class="source-code">}</p>
			<p>It would be best to delete the lines of code that were commented out.</p>
			<p>Run the game and you will get an eerie kind of molten rock. Experiment with changing the background image to have some fun:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B14278_18_03.jpg" alt=""/>
				</div>
			</div>
			<p>That's it! Our fourth game is done.</p>
			<h1 id="_idParaDest-358"><a id="_idTextAnchor371"/>Summary</h1>
			<p>In this chapter, we explored the concepts of particle systems and shaders. Although we looked at probably the simplest possible case for each, we still managed to create a simple explosion and an eerie molten rock effect.</p>
			<p>In the next four chapters, we will look at more ways that we can improve our code using design patterns at the same time as building a Space Invaders game.</p>
		</div>
	</body></html>