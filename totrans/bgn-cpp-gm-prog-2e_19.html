<html><head></head><body>
		<div><h1 id="_idParaDest-344"><a id="_idTextAnchor356"/><em class="italic">Chapter 18</em>: Particle Systems and Shaders</h1>
			<p>In this chapter, we will look at what a particle system is and then go ahead and code one into our game. We will scratch the surface of the topic of OpenGL shaders and see how writing code in another language (<strong class="bold">GLSL</strong>), that can be run directly on the graphics card, can lead to smooth graphical effects that might otherwise be impossible. As usual, we will also use our new skills and knowledge to enhance the current project.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Building a particle system</li>
				<li>OpenGL shaders and GLSL</li>
				<li>Using shaders in the Thomas Was Late game</li>
			</ul>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor357"/>Building a particle system</h1>
			<p>Before we start coding, it will be helpful to see exactly what it is that we are trying to achieve.</p>
			<p>Take a look at the following diagram:</p>
			<div><div><img src="img/B14278_18_01.jpg" alt=""/>
				</div>
			</div>
			<p>The previous illustration is a screenshot of the particle effect on a plain background. We will use this effect in our game. We will spawn one of these effects each time the player dies.</p>
			<p>The way we achieve this effect is as follows:</p>
			<ol>
				<li>First, we spawn 1,000 dots (particles), one on top of the other, at a chosen pixel position.</li>
				<li>Each frame of the game moves each of the 1,000 particles outwards at a predetermined but random speed and angle.</li>
				<li>Repeat step two for two seconds and then make the particles disappear.</li>
			</ol>
			<p>We will use a <code>VertexArray</code> to draw all the dots and the primitive type of <code>Point</code> to represent each particle visually. Furthermore, we will inherit from the SFML <code>Drawable</code> class so that our particle system can take care of drawing itself.</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor358"/>Coding the Particle class</h2>
			<p>The <code>Particle</code> class will be a simple class that represents just one particle from a thousand particles. Let's get coding.</p>
			<h3>Coding Particle.h</h3>
			<p>Right-click <code>Particle.h</code>. Finally, click the <code>Particle</code> class.</p>
			<p>Add the following code to the <code>Particle.h</code> file:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
class Particle
{
private:
    Vector2f m_Position;
    Vector2f m_Velocity;
public:
    Particle(Vector2f direction);
    void update(float dt);
    void setPosition(Vector2f position);
    Vector2f getPosition();
};</pre>
			<p>In the preceding code, we have two <code>Vector2f</code> objects. One will represent the horizontal and vertical coordinate of the particle, while the other will represent the horizontal and vertical speed.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When you have a rate of change (speed) in more than one direction, the combined values also define a direction. This is called <code>Vector2f</code> is called <code>m_Velocity</code>.</p>
			<p>We also have several public functions. First is the constructor. It takes a <code>Vector2f</code> and uses this to let it know which direction/velocity this particle will have. This implies that the system, not the particle itself, will be choosing the velocity.</p>
			<p>Next is the <code>update</code> function, which takes the time the previous frame has taken. We will use this to move the particle by precisely the correct amount.</p>
			<p>The final two functions, <code>setPosition</code> and <code>getPosition</code>, are used to move the particle in position and find out its position, respectively.</p>
			<p>All of these functions will make complete sense when we code them.</p>
			<h3>Coding the Particle.cpp file</h3>
			<p>Right-click <code>Particle.cpp</code>. Finally, click the <code>.cpp</code> file for the <code>Particle</code> class.</p>
			<p>Add the following code to <code>Particle.cpp</code>:</p>
			<pre>#include "Particle.h"
Particle::Particle(Vector2f direction)
{
    // Determine the direction
    
    m_Velocity.x = direction.x;
    m_Velocity.y = direction.y;
}
void Particle::update(float dtAsSeconds)
{
    // Move the particle
    m_Position += m_Velocity * dtAsSeconds;
}
void Particle::setPosition(Vector2f position)
{
    m_Position = position;
}
Vector2f Particle::getPosition()
{
    return m_Position;
}</pre>
			<p>All of these functions use concepts we have seen before. The constructor sets up the <code>m_Velocity.x</code> and <code>m_Velocity.y</code> values using the passed in <code>Vector2f</code> object.</p>
			<p>The <code>update</code> function moves the horizontal and vertical positions of the particle by multiplying <code>m_Velocity</code> by the elapsed time (<code>dtAsSeconds</code>). Notice how, to achieve this, we simply add the two <code>Vector2f</code> objects together. There is no need to perform calculations for both the x and y members separately.</p>
			<p>The <code>setPosition</code> function, as we explained previously, initializes the <code>m_Position</code> object with the passed in values. The <code>getPosition</code> function returns <code>m_Position</code> to the calling code.</p>
			<p>We now have a fully functioning <code>Particle</code> class. Next, we will code a <code>ParticleSystem</code> class to spawn and control the particles. </p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor359"/>Coding the ParticleSystem class</h2>
			<p>The <code>ParticleSystem</code> class does most of the work for our particle effects. It is this class that we will create an instance of in the <code>Engine</code> class. Before we do, however, let's talk a little bit more about OOP and the SFML <code>Drawable</code> class.</p>
			<h1 id="_idParaDest-348"><a id="_idTextAnchor360"/>Exploring SFML's Drawable class and OOP</h1>
			<p>The <code>Drawable</code> class has just one function. It has no variables either. Furthermore, its one and only function is pure virtual. This means that, if we inherit from <code>Drawable</code>, we must implement its one and only function. The purpose, as a reminder from <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>, is that we can then use our class that inherits from <code>drawable</code> as a polymorphic type. Put more simply, anything that SFML allows us to do with a <code>Drawable</code> object, we will be able to do with our class that inherits from it. The only requirement is that we must provide a definition for the pure virtual function, <code>draw</code>.</p>
			<p>Some classes that inherit from <code>Drawable</code> already include <code>Sprite</code> and <code>VertexArray</code> (among others). Whenever we have used <code>Sprite</code> or <code>VertexArray</code>, we passed them to the <code>draw</code> function of the <code>RenderWindow</code> class.</p>
			<p>The reason that we have been able to draw every object we have ever drawn, in this entire book, is because they have all been inherited from <code>Drawable</code>. We can use this knowledge to our advantage.</p>
			<p>We can inherit from <code>Drawable</code> with any object we like, as long as we implement the pure virtual <code>draw</code> function. This is also a straightforward process. Consider a hypothetical <code>SpaceShip</code> class. The header file (<code>SpaceShip.h</code>) of the <code>SpaceShip</code> class that inherits from <code>Drawable</code> would look like this:</p>
			<pre>class SpaceShip : public Drawable
{
private:
    Sprite m_Sprite;
    // More private members
public:
    virtual void draw(RenderTarget&amp; target, 
        RenderStates states) const;
    // More public members
};</pre>
			<p>In the previous code, we can see the pure virtual <code>draw</code> function and a <code>Sprite</code> instance. Notice there is no way to access the private <code>Sprite</code> outside of the class – not even a <code>getSprite</code> function!</p>
			<p>The <code>SpaceShip.cpp</code> file would look something like this:</p>
			<pre>void SpaceShip::SpaceShip
{
    // Set up the spaceship
}
void SpaceShip::draw(RenderTarget&amp; target, RenderStates states) const
{
    target.draw(m_Sprite, states);
}
// Any other functions</pre>
			<p>In the previous code, notice the simple implementation of the <code>draw</code> function. The parameters are beyond the scope of this book. Just note that the <code>target</code> parameter is used to call <code>draw</code> and passes in <code>m_Sprite</code> as well as <code>states</code>, the other parameter.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">While it is not necessary to understand the parameters to take full advantage of <code>Drawable</code>, in the context of this book, you might be intrigued. You can read more about SFML <code>Drawable</code> on the SFML website here: <a href="https://www.sfml-dev.org/tutorials/2.5/graphics-vertex-array.php">https://www.sfml-dev.org/tutorials/2.5/graphics-vertex-array.php</a>.</p>
			<p>In the main game loop, we could now treat a <code>SpaceShip</code> instance as if it were a <code>Sprite</code> or any other class that inherits from <code>Drawable</code>, like so:</p>
			<pre>SpaceShip m_SpaceShip;
// create other objects here
// ...
// In the draw function
// Rub out the last frame
m_Window.clear(Color::Black);
// Draw the spaceship
<strong class="bold">m_Window.draw(m_SpaceShip);</strong>
// More drawing here
// ...
// Show everything we have just drawn
m_Window.display();</pre>
			<p>It is because <code>SpaceShip</code> <code>Drawable</code> that we can treat it like it was a <code>Sprite</code> or <code>VertexArray</code> and, because we overrode the pure virtual <code>draw</code> function, everything just works as we want it to. You will use this approach in this chapter to draw the particle system.</p>
			<p>While we are on the subject of OOP, let's look at an alternative way of encapsulating the drawing code into the game object that we will use in the next project.</p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor361"/>An alternative to inheriting from Drawable</h2>
			<p>It is also possible to keep all the drawing functionality within the class that is the object to be drawn by implementing our own function, within our class, perhaps by using the following code:</p>
			<pre>void drawThisObject(RenderWindow window)
{
    window.draw(m_Sprite)
}</pre>
			<p>The previous code assumes that <code>m_Sprite</code> represents the visual appearance of the current class we are drawing, as it has throughout this and the previous project. Assuming that the instance of the class that contains the <code>drawThisObject</code> function is called <code>playerHero</code> and further assuming we have an instance of <code>RenderWindow</code> called <code>m_Window</code>, we could then draw the object from the main game loop with this code:</p>
			<pre> playerHero.draw(m_Window);</pre>
			<p>In this solution, we pass the <code>RenderWindow</code>, <code>m_Window</code>, into the <code>drawThisObject</code> function as a parameter. The <code>drawThisObject </code>function then uses <code>RenderWindow</code> to draw the <code>Sprite</code>, <code>m_Sprite</code>.</p>
			<p>If we have a more complicated set of game objects, then passing a reference of <code>RenderWindow</code> to the object to be drawn, each frame, so it can draw itself, is a good tactic.</p>
			<p>We will use this tactic in the final project of this book, which we will start in the next chapter. Let's finish the particle system by coding the <code>ParticleSystem</code> class, which will inherit from <code>Drawable</code>.</p>
			<h3>Coding ParticleSystem.h</h3>
			<p>Right-click <code>ParticleSystem.h</code>. Finally, click the <code>ParticleSystem</code> class.</p>
			<p>Add the code for the <code>ParticleSystem</code> class to <code>ParticleSystem.h</code>:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include "Particle.h"
using namespace sf;
using namespace std;
class ParticleSystem : public Drawable
{
private:
    vector&lt;Particle&gt; m_Particles;
    VertexArray m_Vertices;
    float m_Duration;
    bool m_IsRunning = false;
public:
    virtual void draw(RenderTarget&amp; target, 
      RenderStates states) const;
        
    void init(int count);
    void emitParticles(Vector2f position);
    void update(float elapsed);
    bool running();
};</pre>
			<p>Let's go through this a bit at a time. First, notice that we are inheriting from SFML's <code>Drawable</code> class. This is what will allow us to pass our <code>ParticleSystem</code> instance to <code>m_Window.draw</code>, because <code>ParticleSystem</code> <code>Drawable</code>. And, since we inherit from <code>Drawable</code>, we can override the <code>draw</code> function using the same function signature as the <code>Drawable</code> class uses internally. Shortly, when we use the <code>ParticleSystem</code> class, we will see the following code.</p>
			<pre>m_Window.draw(m_PS);</pre>
			<p>The <code>m_PS</code> object is an instance of our <code>ParticleSystem</code> class, and we will pass it directly to the <code>draw</code> function of the <code>RenderWindow</code> class, just like we have done for the <code>Sprite</code>, <code>VertexArray</code>, and <code>RectangleShape</code> instances. All this is made possible by the power of inheritance and polymorphism. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Don't add the <code>m_Window.draw…</code> code just yet; we have a bit more work to do first.</p>
			<p>There is a vector named <code>m_Particles</code> of the <code>Particle</code> type. This vector will hold each and every instance of <code>Particle</code>. Next, we have a <code>VertexArray</code> called <code>m_Vertices</code>. This will be used to draw all the particles in the form of a whole bunch of <code>Point</code> primitives. </p>
			<p>The <code>m_Duration</code>, <code>float</code> variable is how long each effect will last. We will initialize it in the constructor function.</p>
			<p>The <code>m_IsRunning</code> Boolean variable will be used to indicate whether the particle system is currently in use or not.</p>
			<p>Next, in the public section, we have the pure virtual function, <code>draw</code>, that we will soon implement to handle what happens when we pass our instance of <code>ParticleSystem</code> to <code>m_Window.draw</code>.</p>
			<p>The <code>init</code> function will prepare the <code>VertexArray</code> and the <code>vector</code>. It will also initialize all the <code>Particle</code> objects (held by the <code>vector</code>) with their velocities and initial positions.</p>
			<p>The <code>update</code> function will loop through each <code>Particle</code> instance in the <code>vector</code> and call their individual <code>update</code> functions.</p>
			<p>The <code>running</code> function provides access to the <code>m_IsRunning</code> variable so that the game engine can query whether the <code>ParticleSystem</code> is currently in use.</p>
			<p>Let's code the function definitions to see what goes on inside <code>ParticleSystem</code>.</p>
			<h3>Coding the ParticleSystem.cpp file</h3>
			<p>Right-click <code>ParticleSystem.cpp</code>. Finally, click the <code>.cpp</code> file for the <code>ParticleSystem</code> class.</p>
			<p>We will split this file into five sections so that we can code and discuss it in more detail. Add the first section of code, as follows:</p>
			<pre>#include &lt;SFML/Graphics.hpp&gt;
#include "ParticleSystem.h"
using namespace sf;
using namespace std;
void ParticleSystem::init(int numParticles)
{
    m_Vertices.setPrimitiveType(Points);
    m_Vertices.resize(numParticles);
    // Create the particles
    for (int i = 0; i &lt; numParticles; i++)
    {
        srand(time(0) + i);
        float angle = (rand() % 360) * 3.14f / 180.f;
        float speed = (rand() % 600) + 600.f;
        Vector2f direction;
        direction = Vector2f(cos(angle) * speed,
            sin(angle) * speed);
        m_Particles.push_back(Particle(direction));
    }
}</pre>
			<p>After the necessary <code>includes</code>, we have the definition of the<code> init</code> function. We call <code>setPrimitiveType</code> with <code>Points</code> as the argument so that <code>m_VertexArray</code> knows what type of primitives it will be dealing with. We resize <code>m_Vertices</code> with <code>numParticles</code>, which was passed in to the <code>init</code> function when it was called.</p>
			<p>The <code>for</code> loop creates random values for speed and angle. It then uses trigonometric functions to convert those values into a vector which is stored in the <code>Vector2f</code>, <code>direction</code>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to know more about how the trigonometric functions (<code>cos</code> and <code>sin</code>) convert angles and speeds into a vector, then you can take a look at this article series: <a href="http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/">http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/</a>.</p>
			<p>The last thing that happens in the <code>for</code> loop (and the <code>init</code> function) is that the vector is passed into the <code>Particle</code> constructor. The new <code>Particle</code> instance is stored in <code>m_Particles</code> using the <code>push_back</code> function. Therefore, a call to <code>init</code> with a value of <code>1000</code> would mean we have 1,000 instances of <code>Particle</code>, with random velocity, stashed away in <code>m_Particles</code>, just waiting to blow!</p>
			<p>Next, add the <code>update</code> function to <code>ParticleSysytem.cpp</code>:</p>
			<pre>void ParticleSystem::update(float dt)
{
    m_Duration -= dt;
    vector&lt;Particle&gt;::iterator i;
    int currentVertex = 0;
    for (i = m_Particles.begin(); i != m_Particles.end(); i++)
    {
        // Move the particle
        (*i).update(dt);
        // Update the vertex array
        m_Vertices[currentVertex++].position = i-&gt;getPosition();
    }
    if (m_Duration &lt; 0)
    {
        m_IsRunning = false;
    }
}</pre>
			<p>The <code>update</code> function is simpler than it looks at first glance. First of all, <code>m_Duration</code> is reduced by the passed in time, <code>dt</code>. This is so we know when the two seconds have elapsed. A vector iterator, <code>i</code>, is declared for use with <code>m_Particles</code>.</p>
			<p>The <code>for</code> loop goes through each of the <code>Particle</code> instances in <code>m_Particles</code>. For each one, it calls its <code>update</code> function and passes in <code>dt</code>. Each particle will update its position.  After the particle has updated itself, the appropriate vertex in <code>m_Vertices</code> is updated by using the particle's <code>getPosition</code> function. At the end of each pass through the <code>for</code> loop, <code>currentVertex</code> is incremented, ready for the next vertex.</p>
			<p>After the <code>for</code> loop has completed the code, <code>if(m_Duration &lt; 0)</code> checks whether it is time to switch off the effect. If two seconds have elapsed, <code>m_IsRunning</code> is set to <code>false</code>.</p>
			<p>Next, add the <code>emitParticles</code> function:</p>
			<pre>void ParticleSystem::emitParticles(Vector2f startPosition)
{
    m_IsRunning = true;
    m_Duration = 2;
    
    int currentVertex = 0;
    for (auto it = m_Particles.begin(); 
         it != m_Particles.end();
         it++)
    {
        m_Vertices[currentVertex++].color = Color::Yellow;
        it-&gt;setPosition(startPosition);
    }
}</pre>
			<p>This is the function we will call to start the particle system. So predictably, we set <code>m_IsRunning</code> to <code>true</code> and <code>m_Duration</code> to <code>2</code>. We declare an <code>iterator</code>, <code>i</code>, to iterate through all the <code>Particle</code> objects in <code>m_Particles</code> and then we do so in a <code>for</code> loop.</p>
			<p>Inside the <code>for</code> loop, we set each particle in the vertex array to yellow and set each position to <code>startPosition</code>, which was passed in as a parameter. Remember that each particle starts life in the same position, but they are each assigned a different velocity.</p>
			<p>Next, add the pure virtual <code>draw</code> function definition:</p>
			<pre>void ParticleSystem::
       draw(RenderTarget&amp; target, 
       RenderStates states) const
{
    target.draw(m_Vertices, states);
}</pre>
			<p>In the preceding code, we simply use <code>target</code> to call <code>draw</code>, passing <code>m_Vertices</code> and <code>states</code> as parameters. Remember that we will never call this function directly! Shortly, when we declare an instance of <code>ParticleSystem</code>, we will pass that instance to the <code>RenderWindow draw</code> function. The <code>draw</code> function we have just coded will be called internally from there.</p>
			<p>Finally, add the <code>running</code> function:</p>
			<pre>bool ParticleSystem::running()
{
    return m_IsRunning;
}</pre>
			<p>The <code>running</code> function is a simple getter function that returns the value of <code>m_IsRunning</code>. We will see where this is useful in this chapter, so that we can determine the current state of the particle system.</p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor362"/>Using the ParticleSystem object</h2>
			<p>Putting our particle </p>
			<p>system to work is very straightforward, especially because we inherited from <code>Drawable</code>.</p>
			<h3>Adding a ParticleSystem object to the Engine class</h3>
			<p>Open <code>Engine.h</code> and add a <code>ParticleSystem</code> object, as shown in the following highlighted code:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include "TextureHolder.h"
#include "Thomas.h"
#include "Bob.h"
#include "LevelManager.h"
#include "SoundManager.h"
#include "HUD.h"
<strong class="bold">#include "ParticleSystem.h"</strong>
using namespace sf;
class Engine
{
private:
    // The texture holder
    TextureHolder th;
<strong class="bold">    // create a particle system</strong>
<strong class="bold">    ParticleSystem m_PS;</strong>
    // Thomas and his friend, Bob
    Thomas m_Thomas;
    Bob m_Bob;</pre>
			<p>Now, we need to initialize the system.</p>
			<h3>Initializing ParticleSystem</h3>
			<p>Open the <code>Engine.cpp</code> file and add the short highlighted code right at the end of the <code>Engine</code> constructor:</p>
			<pre>Engine::Engine()
{
    // Get the screen resolution and create an SFML window and View
    Vector2f resolution;
    resolution.x = VideoMode::getDesktopMode().width;
    resolution.y = VideoMode::getDesktopMode().height;
    m_Window.create(VideoMode(resolution.x, resolution.y),
        "Thomas was late",
        Style::Fullscreen);
    // Initialize the full screen view
    m_MainView.setSize(resolution);
    m_HudView.reset(
        FloatRect(0, 0, resolution.x, resolution.y));
    // Initialize the split-screen Views
    m_LeftView.setViewport(
        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));
    m_RightView.setViewport(
        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));
    m_BGLeftView.setViewport(
        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));
    m_BGRightView.setViewport(
        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));
    // Can this graphics card use shaders?
    if (!sf::Shader::isAvailable())
    {
        // Time to get a new PC
        m_Window.close();
    }
    m_BackgroundTexture = TextureHolder::GetTexture(
        "graphics/background.png");
    // Associate the sprite with the texture
    m_BackgroundSprite.setTexture(m_BackgroundTexture);
    // Load the texture for the background vertex array
    m_TextureTiles = TextureHolder::GetTexture(
        "graphics/tiles_sheet.png");
<strong class="bold">    // Initialize the particle system</strong>
<strong class="bold">    m_PS.init(1000);</strong>
}// End Engine constructor</pre>
			<p>The <code>VertexArray</code> and the <code>vector</code> of <code>Particle</code> instances are ready for action.</p>
			<h3>Updating the particle system each frame</h3>
			<p>Open the <code>Update.cpp</code> file and add the following highlighted code. It can go right at the end of the <code>update</code> function:</p>
			<pre>    // Update the HUD every m_TargetFramesPerHUDUpdate frames
    if (m_FramesSinceLastHUDUpdate &gt; m_TargetFramesPerHUDUpdate)
    {
        // Update game HUD text
        stringstream ssTime;
        stringstream ssLevel;
        // Update the time text
        ssTime &lt;&lt; (int)m_TimeRemaining;
        m_Hud.setTime(ssTime.str());
        // Update the level text
        ssLevel &lt;&lt; "Level:" &lt;&lt; m_LM.getCurrentLevel();
        m_Hud.setLevel(ssLevel.str());
        m_FramesSinceLastHUDUpdate = 0;
    }
<strong class="bold">    // Update the particles</strong>
<strong class="bold">    if (m_PS.running())</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_PS.update(dtAsSeconds);</strong>
<strong class="bold">    }</strong>
}// End of update function</pre>
			<p>All that is needed in the previous code is the call to <code>update</code>. Notice that it is wrapped in a check to make sure the system is currently running. If it isn't running, there is no point updating it.</p>
			<h3>Starting the particle system</h3>
			<p>Open the <code>DetectCollisions.cpp</code> file, which has the <code>detectCollisions</code> function in it. We left a comment in it when we originally coded it.</p>
			<p>Identify the correct place from the context and add the following highlighted code:</p>
			<pre>// Is character colliding with a regular block
if (m_ArrayLevel[y][x] == 1)
{
    if (character.getRight().intersects(block))
    {
        character.stopRight(block.left);
    }
    else if (character.getLeft().intersects(block))
    {
        character.stopLeft(block.left);
    }
    if (character.getFeet().intersects(block))
    {
        character.stopFalling(block.top);
    }
    else if (character.getHead().intersects(block))
    {
        character.stopJump();
    }
}
// More collision detection here once 
// we have learned about particle effects
<strong class="bold">// Have the characters' feet touched fire or water?</strong>
<strong class="bold">// If so, start a particle effect</strong>
<strong class="bold">// Make sure this is the first time we have detected this</strong>
<strong class="bold">// by seeing if an effect is already running            </strong>
<strong class="bold">if (!m_PS.running()) {</strong>
<strong class="bold">    if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        if (character.getFeet().intersects(block))</strong>
<strong class="bold">        {</strong>
<strong class="bold">            // position and start the particle system</strong>
<strong class="bold">            m_PS.emitParticles(character.getCenter());</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong>
// Has the character reached the goal?
if (m_ArrayLevel[y][x] == 4)
{
    // Character has reached the goal
    reachedGoal = true;
}</pre>
			<p>First, the code checks if the particle system is already running. If it isn't, it checks if the current tile being checked is either a water or fire tile. If either is the case, it checks whether the character's feet are in contact with it. When each of these <code>if</code> statements are true, the particle system is started by calling the <code>emitParticles</code> function and passing in the location of the center of the character as the coordinates to start the effect.</p>
			<h3>Drawing the particle system</h3>
			<p>This is the best bit. See how easy it is to draw <code>ParticleSystem</code>. We pass our instance directly to the <code>m_Window.draw</code> function, after checking that the particle system is running.</p>
			<p>Open the <code>Draw.cpp</code> file and add the following highlighted code in all the necessary places:</p>
			<pre>void Engine::draw()
{
    // Rub out the last frame
    m_Window.clear(Color::White);
    if (!m_SplitScreen)
    {
        // Switch to background view
        m_Window.setView(m_BGMainView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_MainView
        m_Window.setView(m_MainView);        
        // Draw the Level
        m_Window.draw(m_VALevel, &amp;m_TextureTiles);
        // Draw thomas
        m_Window.draw(m_Thomas.getSprite());
        // Draw bob
        m_Window.draw(m_Bob.getSprite());
<strong class="bold">        // Draw the particle system</strong>
<strong class="bold">        if (m_PS.running())</strong>
<strong class="bold">        {</strong>
<strong class="bold">            m_Window.draw(m_PS);</strong>
<strong class="bold">        }</strong>
    }
    else
    {
        // Split-screen view is active
        // First draw Thomas' side of the screen
        // Switch to background view
        m_Window.setView(m_BGLeftView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_LeftView
        m_Window.setView(m_LeftView);
        // Draw the Level
        m_Window.draw(m_VALevel, &amp;m_TextureTiles);
            
        // Draw bob
        m_Window.draw(m_Bob.getSprite());
        // Draw thomas
        m_Window.draw(m_Thomas.getSprite());
<strong class="bold">        // Draw the particle system</strong>
<strong class="bold">        if (m_PS.running())</strong>
<strong class="bold">        {</strong>
<strong class="bold">            m_Window.draw(m_PS);</strong>
<strong class="bold">        }</strong>
        
        // Now draw Bob's side of the screen
        // Switch to background view
        m_Window.setView(m_BGRightView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_RightView
        m_Window.setView(m_RightView);
        // Draw the Level
        m_Window.draw(m_VALevel, &amp;m_TextureTiles);
        // Draw thomas
        m_Window.draw(m_Thomas.getSprite());
        // Draw bob
        m_Window.draw(m_Bob.getSprite());
<strong class="bold">        // Draw the particle system</strong>
<strong class="bold">        if (m_PS.running())</strong>
<strong class="bold">        {</strong>
<strong class="bold">            m_Window.draw(m_PS);</strong>
<strong class="bold">        }</strong>
                
    }
    
    // Draw the HUD
    // Switch to m_HudView
    m_Window.setView(m_HudView);
    m_Window.draw(m_Hud.getLevel());
    m_Window.draw(m_Hud.getTime());
    if (!m_Playing)
    {
        m_Window.draw(m_Hud.getMessage());
    }
    
    
    // Show everything we have just drawn
    m_Window.display();
}</pre>
			<p>Note that we must draw the particle system in all of the left, right, and full-screen code blocks.</p>
			<p>Run the game and move one of the character's feet over the edge of a fire tile. Notice the particle system burst into life:</p>
			<div><div><img src="img/B14278_18_02.jpg" alt=""/>
				</div>
			</div>
			<p>No<a id="_idTextAnchor363"/>w, it's time for something else that's new.</p>
			<h1 id="_idParaDest-351"><a id="_idTextAnchor364"/>OpenGL, Shaders, and GLSL</h1>
			<p>The<strong class="bold"> Open Graphics Library</strong> (<strong class="bold">OpenGL</strong>) is a programming library that handles 2D as well as 3D graphics. OpenGL works on all major desktop operating systems and there is also a version that works on mobile devices, known as OpenGL ES.</p>
			<p>OpenGL was originally released in 1992. It has been refined and improved over more than twenty years. Furthermore, graphics card manufacturers design their hardware to make it work well with OpenGL. The point of mentioning this is not for the history lesson but to explain that it would be a fool's errand to try and improve upon OpenGL and use it in 2D (and 3D games) on the desktop, especially if we want our game to run on more than just Windows, which is the obvious choice. We are already using OpenGL because SFML uses OpenGL. Shaders are programs that run on the GPU itself. We'll find out more about them in the following section.</p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor365"/>The programmable pipeline and shaders</h2>
			<p>Through OpenGL, we have access to what is called a<code>RenderWindow</code> instance's <code>draw</code> function. We can also write code that runs on the GPU that can manipulate each and every pixel independently, after the call to <code>draw</code>. This is a very powerful feature.</p>
			<p>This extra code that runs on the GPU is called a <strong class="bold">shader program</strong>. We can write code to manipulate the geometry (position) of our graphics in a <strong class="bold">vertex shader</strong>. We can also write code that manipulates the appearance of every pixel individually in code. This is known as a <strong class="bold">fragment shader</strong>. </p>
			<p>Although we will not be exploring shaders in any great depth, we will write some shader code using the <strong class="bold">GL Shader Language</strong> (<strong class="bold">GLSL</strong>) and we will get a glimpse of the possibilities that it offers.</p>
			<p>In OpenGL, everything is a point, a line, or a triangle. In addition, we can attach colors and textures to this basic geometry, and we can also combine these elements to make the complex graphics that we see in today's modern games. These are collectively known as <code>VertexArray</code>, as well as the <code>Sprite</code> and <code>Shape</code> classes.</p>
			<p>In addition to primitives, OpenGL uses matrices. Matrices are a method and structure for performing arithmetic. This arithmetic can range from extremely simple high school-level calculations such as  moving (translating) a coordinate or it can be quite complex, such as performing more advanced mathematics, for example, to convert our game world coordinates into OpenGL screen coordinates that the GPU can use. Fortunately, it is this complexity that SFML handles for us behind the scenes. SFML also allows us to handle OpenGL directly.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to find out more about OpenGL, you can get started here: <a href="http://learnopengl.com/#!Introduction">http://learnopengl.com/#!Introduction</a>. If you want to use OpenGL directly, alongside SFML, you can read this article to find out more: <a href="https://www.sfml-dev.org/tutorials/2.5/window-opengl.php">https://www.sfml-dev.org/tutorials/2.5/window-opengl.php</a>.</p>
			<p>An application can have many shaders. We can then <em class="italic">attach</em> different shaders to different game objects to create the desired effects. We will only have one vertex and one fragment shader in this game. We will apply it to every frame, as well as to the background.</p>
			<p>However, when you see how to attach a shader to a <code>draw</code> call, it will be plain that it is trivial to have more shaders.</p>
			<p>We will follow these steps:</p>
			<ol>
				<li value="1">First, we need the code for the shader that will be executed on the GPU.  </li>
				<li>Then, we need to compile that code.</li>
				<li>Finally, we need to attach the shader to the appropriate <code>draw</code> function call in the draw function of our game engine. </li>
			</ol>
			<p>GLSL is a language and it also has its own types, and variables of those types, which can be declared and utilized.  Furthermore, we can interact with the shader program's variables from our C++ code.</p>
			<p>As we will see, GLSL has some syntax similarities to C++.</p>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor366"/>Coding a fragment shader</h2>
			<p>Here is the code from the <code>rippleShader.frag</code> file in the <code>shaders</code> folder. We don't need to code this because it is in the assets that we added back in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>:</p>
			<pre>// attributes from vertShader.vert
varying vec4 vColor;
varying vec2 vTexCoord;
// uniforms
uniform sampler2D uTexture;
uniform float uTime;
void main() {
    float coef = sin(gl_FragCoord.y * 0.1 + 1 * uTime);
    vTexCoord.y +=  coef * 0.03;
    gl_FragColor = vColor * texture2D(uTexture, vTexCoord);
}</pre>
			<p>The first four lines (excluding comments) are the variables that the fragment shader will use, but they are not ordinary variables. The first type we can see is <code>varying</code>. These are variables which are in scope between both <code>shaders</code>. Next, we have the <code>uniform</code> variables. These variables can be manipulated directly from our C++ code. We will see how we do this soon.</p>
			<p>In addition to the <code>varying</code> and <code>uniform</code> types, each of the variables also has a more conventional type that defines the actual data, as follows: </p>
			<ul>
				<li><code>vec4</code> is a vector with four values.</li>
				<li><code>vec2</code> is a vector with two values.</li>
				<li><code>sampler2d </code>will hold a texture.</li>
				<li><code>float</code> is just like a <code>float data type</code> in C++.</li>
			</ul>
			<p>The code inside the <code>main</code> function is executed. If we look closely at the code in <code>main</code>, we will see each of the variables in use. Exactly what this code does is beyond the scope of the book. In summary, however, the texture coordinates (<code>vTexCoord</code>) and the color of the pixels/fragments (<code>glFragColor</code>) are manipulated by several mathematical functions and operations. Remember that this executes for each pixel involved in the <code>draw</code> function that's called on each frame of our game. Furthermore, be aware that <code>uTime</code> is passed in as a different value for each frame. The result, as we will soon see, will be a rippling effect.</p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor367"/>Coding a vertex shader</h2>
			<p>Here is the code from the <code>vertShader.vert</code> file. You don't need to code this. It was in the assets we added back in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>:</p>
			<pre>//varying "out" variables to be used in the fragment shader
varying vec4 vColor;
varying vec2 vTexCoord;
 
void main() {
    vColor = gl_Color;
    vTexCoord = (gl_TextureMatrix[0] * gl_MultiTexCoord0).xy;
    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
}</pre>
			<p>First of all, notice the two <code>varying</code> variables. These are the very same variables that we manipulated back in the fragment shader. In the <code>main</code> function, the code manipulates the position of each and every vertex. How the code works is beyond the scope of this book, but there is some quite in-depth mathematics going on behind the scenes. If it interests you, then exploring GLSL further will be fascinating.</p>
			<p>Now that we have two shaders (one fragment and one vertex), we can use them in our game.</p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor368"/>Adding shaders to the engine class</h2>
			<p>Open the <code>Engine.h</code> file. Add the following highlighted line of code, which adds an SFML <code>Shader</code> instance called <code>m_RippleShader</code> to the <code>Engine</code> class:</p>
			<pre>// Three views for the background
View m_BGMainView;
View m_BGLeftView;
View m_BGRightView;
View m_HudView;
// Declare a sprite and a Texture for the background
Sprite m_BackgroundSprite;
Texture m_BackgroundTexture;
<strong class="bold">// Declare a shader for the background</strong>
<strong class="bold">Shader m_RippleShader;</strong>
// Is the game currently playing?
bool m_Playing = false;
// Is character 1 or 2 the current focus?
bool m_Character1 = true;</pre>
			<p>The engine object and all its functions now have access to <code>m_RippleShader</code>. Note that an SFML <code>Shader</code> object will be comprised of both shader code files.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor369"/>Loading the shaders</h2>
			<p>Add the following code, which checks whether the player's GPU can handle shaders. The game will quit if it can't. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You will have to have an exceptionally old PC for this not to work. If you do have a GPU that doesn't handle shaders, please accept my apologies.</p>
			<p>Next, we will add an <code>else</code> clause that loads the shaders if the system can handle them. Open the <code>Engine.cpp</code> file and add this code to the constructor:</p>
			<pre><strong class="bold">// Can this graphics card use shaders?</strong>
<strong class="bold">if (!sf::Shader::isAvailable())</strong>
<strong class="bold">{</strong>
<strong class="bold">    // Time to get a new PC</strong>
<strong class="bold">    // Or remove all the shader related code L</strong>
<strong class="bold">    m_Window.close();</strong>
<strong class="bold">}</strong>
<strong class="bold">else</strong>
<strong class="bold">{</strong>
<strong class="bold">    // Load two shaders (1 vertex, 1 fragment)</strong>
<strong class="bold">    m_RippleShader.loadFromFile("shaders/vertShader.vert",</strong>
<strong class="bold">        "shaders/rippleShader.frag");</strong>
<strong class="bold">}</strong>
m_BackgroundTexture = TextureHolder::GetTexture(
    "graphics/background.png");</pre>
			<p>We are nearly ready to see our ripple effect in action.</p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor370"/>Updating and drawing the shader</h2>
			<p>Open the <code>Draw.cpp</code> file. As we already discussed when we coded the shaders, we will update the <code>uTime</code> variable directly from our C++ code each frame. We will do so with the <code>setParameter</code> function.</p>
			<p>Add the following highlighted code to update the shader's <code>uTime</code> variable and change the call to <code>draw</code> for <code>m_BackgroundSprite</code>, in each of the possible drawing scenarios:</p>
			<pre>void Engine::draw()
{
    // Rub out the last frame
    m_Window.clear(Color::White);
<strong class="bold">    // Update the shader parameters</strong>
<strong class="bold">    m_RippleShader.setUniform("uTime", </strong>
<strong class="bold">      m_GameTimeTotal.asSeconds());</strong>
    if (!m_SplitScreen)
    {
        // Switch to background view
        m_Window.setView(m_BGMainView);
        // Draw the background
<strong class="bold">        //m_Window.draw(m_BackgroundSprite);</strong>
<strong class="bold">        // Draw the background, complete with shader effect</strong>
<strong class="bold">        m_Window.draw(m_BackgroundSprite, &amp;m_RippleShader);</strong>
        // Switch to m_MainView
        m_Window.setView(m_MainView);
        // Draw the Level
        m_Window.draw(m_VALevel, &amp;m_TextureTiles);
        // Draw thomas
        m_Window.draw(m_Thomas.getSprite());
        // Draw thomas
        m_Window.draw(m_Bob.getSprite());
        // Draw the particle system
        if (m_PS.running())
        {
            m_Window.draw(m_PS);
        }
    }
    else
    {
        // Split-screen view is active
        // First draw Thomas' side of the screen
        // Switch to background view
        m_Window.setView(m_BGLeftView);
        // Draw the background
<strong class="bold">        //m_Window.draw(m_BackgroundSprite);</strong>
<strong class="bold">        // Draw the background, complete with shader effect</strong>
<strong class="bold">        m_Window.draw(m_BackgroundSprite, &amp;m_RippleShader);</strong>
        // Switch to m_LeftView
        m_Window.setView(m_LeftView);
        // Draw the Level
        m_Window.draw(m_VALevel, &amp;m_TextureTiles);
            
        // Draw thomas
        m_Window.draw(m_Bob.getSprite());
        // Draw thomas
        m_Window.draw(m_Thomas.getSprite());
        // Draw the particle system
        if (m_PS.running())
        {
            m_Window.draw(m_PS);
        }
        
        // Now draw Bob's side of the screen
        // Switch to background view
        m_Window.setView(m_BGRightView);
        // Draw the background
<strong class="bold">        //m_Window.draw(m_BackgroundSprite);</strong>
<strong class="bold">        // Draw the background, complete with shader effect</strong>
<strong class="bold">        m_Window.draw(m_BackgroundSprite, &amp;m_RippleShader);</strong>
        // Switch to m_RightView
        m_Window.setView(m_RightView);
        // Draw the Level
        m_Window.draw(m_VALevel, &amp;m_TextureTiles);
        // Draw thomas
        m_Window.draw(m_Thomas.getSprite());
        // Draw bob
        m_Window.draw(m_Bob.getSprite());
        // Draw the particle system
        if (m_PS.running())
        {
            m_Window.draw(m_PS);
        }                
    }
    
    // Draw the HUD
    // Switch to m_HudView
    m_Window.setView(m_HudView);
    m_Window.draw(m_Hud.getLevel());
    m_Window.draw(m_Hud.getTime());
    if (!m_Playing)
    {
        m_Window.draw(m_Hud.getMessage());
    }    
    
    // Show everything we have just drawn
    m_Window.display();
}</pre>
			<p>It would be best to delete the lines of code that were commented out.</p>
			<p>Run the game and you will get an eerie kind of molten rock. Experiment with changing the background image to have some fun:</p>
			<div><div><img src="img/B14278_18_03.jpg" alt=""/>
				</div>
			</div>
			<p>That's it! Our fourth game is done.</p>
			<h1 id="_idParaDest-358"><a id="_idTextAnchor371"/>Summary</h1>
			<p>In this chapter, we explored the concepts of particle systems and shaders. Although we looked at probably the simplest possible case for each, we still managed to create a simple explosion and an eerie molten rock effect.</p>
			<p>In the next four chapters, we will look at more ways that we can improve our code using design patterns at the same time as building a Space Invaders game.</p>
		</div>
	</body></html>