- en: Where Am I? Location and Positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Devices with GPS chips are everywhere. You can even track your cat or chicken!
    In this chapter, you will learn how to use Qt for location and positioning services.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Positioning entails geographic coordinates from various sources, including
    satellites, Wi-Fi, and log files. Qt Location is all about local places, for example
    services, such as restaurants or public parks, and also routing information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Positioning with satellites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping the positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Places of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning with satellites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A phone usually has a built-in GPS modem but also other sources of positioning
    information, so I will use Android for this example. The main Qt classes we will
    look at are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the Qt Positioning APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QGeoSatelliteInfo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QGeoLocation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QGeoPositionInfoSource`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QGeoCoordinate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are the Qt Location APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QPlaceSearchResult`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QPlaceContent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QGeoRoute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we need to edit the `.pro` file and add `QT += positioning`.
  prefs: []
  type: TYPE_NORMAL
- en: QGeoSatelliteInfoSource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can show the user satellite information by using `QGeoSatelliteInfoSource`, which
    has a `static` method to get `QGeoSatelliteInfoSource.`
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter08-1` directory,
    in the `cp8` branch.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by calling `QGeoSatelliteInfoSource::createDefaultSource`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On some systems, such as iOS, satellite information is not exposed to the public
    API, so `QGeoSatelliteInfoSource` will not work on that platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'This constructs a `QGeoSatelliteInfoSource` object for the highest-priority
    plugin on the system, which is about the same as doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two signals of particular interest: `satellitesInUseUpdated` and
    `satellitesInViewUpdated`. In addition, there is the overloaded `error` signal,
    so we need to use the special `QOverload` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `satellitesInUseUpdated` signal is emitted when the number of satellites
    that the system is using changes. The `satellitesInViewUpdated` signal gets emitted
    when the number of satellites the system can see changes. We will receive a list
    of `QGeoSatelliteInfo` objects.
  prefs: []
  type: TYPE_NORMAL
- en: QGeoSatelliteInfo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s connect the `satellitesInViewUpdated` signal so we can detect when satellites
    are found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can receive information for individual satellites this way. Information
    such as a satellite identifier, signal strength, elevation, and azimuth is included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot to see here on a small screen. Every update is a new line, and
    you can see as it locates and adds different satellites when they come into view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e67199f7-ab26-4d0e-84eb-0aa5d209cc9e.png)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to use those satellites to triangulate our position on the
    globe. We start by using `QGeoPositionInfoSource`.
  prefs: []
  type: TYPE_NORMAL
- en: QGeoPositionInfoSource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can get the latitude and longitude position of the device by using `QGeoPositionInfoSource`,
    which encapsulates positional data. Like `QGeoSatelliteInfoSource`, it has two
    `static` methods to create the `source` object:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter08-2` directory,
    in the `cp8` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QGeoPositionInfoSource` signal we are interested in is `positionUpdated(const
    QGeoPositionInfo &update)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To start receiving updates, call `startUpdates();`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `positionUpdated` signal receives a `QGeoPositionInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: QGeoPositionInfo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QGeoPositionInfo` contains a `QGeoCoordinate` that contains our latitude and
    longitude coordinates, as well as a timestamp for the location data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can also contain the following optional attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Direction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroundSpeed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerticalSpeed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MagneticVariation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HorizontalAccuracy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerticalAccuracy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The attributes can be checked with `hasAttribute(QGeoPositionInfo::Attribute)`
    and retrieved with the `attribute(QGeoPositionInfo::Attribute)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To get latitude and longitude information, call the `coordinate()` function
    in the `QGeoPositionInfo` class, which returns a `QGeoCoordinate`.
  prefs: []
  type: TYPE_NORMAL
- en: QGeoCoordinate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QGeoCoordinate` contains the latitude and longitude coordinates, and can be
    found calling the respective `latitude()` and `longitude()` functions. It can
    be made up of different types of data, and can be discovered by calling the `type()`
    function, which returns an `enum` of `QGeoCoordinate::CoordinateType`, which can
    be one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InvalidCoordinate`: Invalid coordinate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Coordinate2D`: Contains latitude and longitude coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Coordinate3D`: Contains latitude, longitude, and altitude coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can get the `QGeoCoordinate` from the `QGeoPositionInfo` object''s `coordinate()`
    function which, in turn, has `latitude` and `longitude` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at how we do this using Qt Quick and QML.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are corresponding QML elements available for positioning.
  prefs: []
  type: TYPE_NORMAL
- en: The `import` statement would be `import QtPositioning 5.12`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do the same simple thing with QML and show our latitude and longitude
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the Qt Quick item equivalents of the previously-mentioned classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PositionSource`: `QGeoPositionInfoSource`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Position`: `QGeoPositionInfo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Coordinate`: `QGeoCoordinate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Quick is often much simpler, and quick to implement these things.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter08-3` directory,
    in the `cp8` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement `PositionSource` with an `updateInterval` of 1,000, which means
    the devices position will update every 1,000 milliseconds. We set it to `active`
    to start the updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This component has a signal named `onPositionChanged`, which gets called when
    the position changes. We receive the changed coordinates and can then use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know where we are, we can use those location details to get certain
    details around the coordinates, like the map and location's place details.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the positions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need a map of some sort to show our location findings.
  prefs: []
  type: TYPE_NORMAL
- en: The `Map` component for QML is the only way Qt provides for mapping, so you
    will have to use Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Map` component can be backed by various backend plugins. In fact, you
    need to specify which plugin you are using. `Map` has built-in support for the
    following plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Provider** | **Key** | **Notes** | **Url** |'
  prefs: []
  type: TYPE_TB
- en: '| Esri | esri | Subscription required | `www.esri.com` |'
  prefs: []
  type: TYPE_TB
- en: '| HERE | here | Access token required | `developer.here.com/terms-and-conditions`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Mapbox | mapbox | Access token required | `www.mapbox.com/tos` |'
  prefs: []
  type: TYPE_TB
- en: '| Mapbox GL | mapboxgl | Access token required | `www.mapbox.com/tos` |'
  prefs: []
  type: TYPE_TB
- en: '| **Open Street Map** (**OSM**) | osm | Free access | `openstreetmap.org/`
    |'
  prefs: []
  type: TYPE_TB
- en: I will be using the OSM and HERE providers.
  prefs: []
  type: TYPE_NORMAL
- en: The HERE plugin requires an account at `developer.here.com`. It's easy to sign
    up and there is a free version. You need the app ID and app code to access their
    maps and API.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start using the `Map` component, in your chosen `.qml` file, add both `QtLocation`
    and `QtPositioning` in the `import` lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The source code can be found on the Git repository under the `Chapter08-4` directory,
    in the `cp8` branch.
  prefs: []
  type: TYPE_NORMAL
- en: The `Map` component needs a `plugin` object, whose `name` property is one of
    the keys from the preceding table. You can set where the map is centered by setting
    the `center` property to a coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am using the OSM backend and it is centered on the Gold Coast, Australia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Map centers on the coordinates we indicate with the `center` property, which
    is used to position the map to the user's current location.
  prefs: []
  type: TYPE_NORMAL
- en: We defined the Map's `plugin` property to be the `"osm"` plugin, which is an
    identifier for the Open Street Map plugin.
  prefs: []
  type: TYPE_NORMAL
- en: It is that easy to show a map.
  prefs: []
  type: TYPE_NORMAL
- en: MapCircle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can highlight an area by placing a `MapCircle` in the `Map`. Again, centered
    on the Gold Coast.
  prefs: []
  type: TYPE_NORMAL
- en: A `MapCircle` has a `center` property that we can define by using a `latitude`
    and `longitude` location in a signed decimal value.
  prefs: []
  type: TYPE_NORMAL
- en: The `radius` property here is in the unit of meters according to the map. So
    in our example, the `MapCircle` will have a radius of 5,000 meters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Each map backend has its own parameters, which can be set using the `PluginParameter`
    component in the `Map` component.
  prefs: []
  type: TYPE_NORMAL
- en: PluginParameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the OSM backend downloads lower-resolution tiles. If you want high-resolution
    maps, you can specify the `''osm.mapping.highdpi_tiles''` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `PluginParameter` element holds just one `name`/`value` parameter pair.
    If you need to set several parameters, you will need a `PluginParameter` element
    for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Other `PluginParameters` you could consider are tokens and app IDs for various
    map providers, such as HERE maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how our map looks, running on Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49538139-169e-48a8-8e2c-0309ad29cccf.png)'
  prefs: []
  type: TYPE_IMG
- en: There are other Qt Quick items that we can use with addresses on the map. Let's
    look at routing.
  prefs: []
  type: TYPE_NORMAL
- en: RouteModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To show a route on a map, you will need to use `RouteModel`, which is a property
    of the `Map` item, `RouteQuery` to add waypoints, and a `MapItemView` to display
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '`RouteModel` needs a plugin, so we just reuse the plugin for the `Map` item.
    It also needs a `RouteQuery` for its `query` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`MapItemView` is used to display model data on the map. It also needs a delegate
    of `MapRoute`. In our case, this is a line that describes the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now what we need is a starting point, an ending point, and any point in between.
    In this example, I keep it simple and only specify start and end points. You can
    specify a GPS coordinate by using `QtPositioning.coordinate`, which takes a latitude
    and longitude value as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The start-point coordinate is some random area on the Gold Coast, Australia;
    the endpoint is where the last south-of-the-equator Trolltech office was. The
    `RouteQuery travelModes` property determines how the route is figured, whether
    traveling by car, foot, or public transport. It can be one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CarTravel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PedestrianTravel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BicycleTravel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublicTransit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TruckTravel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `RouteQuery` property, `routeOptimzations`, limits the query to the following
    different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ShortestRoute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FastestRoute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MostEconomicRoute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MostScenicRoute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, I made `routeQuery` fire off in the `Component.onCompleted`
    signal. Usually, something like this would be triggered after the user has configured
    the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the route looks. This route indicated by the blue line starting
    in the big red circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/189324f1-d058-4353-a244-4acaed6350f0.png)'
  prefs: []
  type: TYPE_IMG
- en: You can add more `Waypoints` to establish different routes or get turn-by-turn
    directions by setting `routeModel` to a `ListView` or similar.
  prefs: []
  type: TYPE_NORMAL
- en: Not only can Qt Location show maps and routes, but there is also support for
    displaying places of interest, such as restaurants, gas stations, and national
    parks, in the `Places` API.
  prefs: []
  type: TYPE_NORMAL
- en: Places of interest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, I am going to switch to the HERE maps plugin. I tried to get
    the OpenStreetMaps places to work, but it could not find anything around.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step of the construction of our map, we use `PlaceSearchModel` to
    search for places. As with the `RouteModel` before, `MapItemView` can display
    this model on our map.
  prefs: []
  type: TYPE_NORMAL
- en: Just like `RouteModel`, `PlaceSearchModel` needs some way of displaying the
    data; we could choose a `ListView`, which is useful for some purposes, but let's
    choose `MapItemView` for the visual effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to state which plugin we are using with `searchArea` and `searchTerm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `MapItemView` and `delegate` code look like this. The `searchView` delegate
    will show up as an icon with its title text, from the resulting place :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, the place points are a bit difficult to read and are superimposed
    on top of the other ones that are around. This indicates that there are places
    too near each other for the zoom level and the map is having difficulties in placing
    the names. You can work around this issue by using a different zoom level or by
    using some collision detection and layout algorithms that I won't go into there.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90adbe26-04ad-42a1-a2a8-680274dde9d2.png)'
  prefs: []
  type: TYPE_IMG
- en: The `map-pin.png` icon is from [https://feathericons.com/](https://feathericons.com/)
    and is released under the open source MIT license.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered many aspects of mapping using Qt Location and Qt
    Positioning. We can get satellite information with `QGeoSatelliteInfo`, and locate
    the exact current position coordinates with `QGeoPositionInfo`. We learned how
    to use Qt Quick `Map` and different map providers to show the current location.
    We covered how to provide a route with `RouteModel`, search for places nearby
    using `PlaceSearchModel`, and show them using `MapItemView`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss audio and video with Qt Multimedia.
  prefs: []
  type: TYPE_NORMAL
