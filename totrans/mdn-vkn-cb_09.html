<html><head></head><body>
<div id="_idContainer070">
<h1 class="chapter-number" id="_idParaDest-296"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-297"><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.2.1">Debugging and Performance Measurement Techniques</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Debugging failures and reverse engineering an implementation, as well as measuring the performance of a system once it has been authored, are as important as writing new code. </span><span class="koboSpan" id="kobo.3.2">Vulkan is a vast and complicated API and, more than ever, knowing how to debug it is paramount. </span><span class="koboSpan" id="kobo.3.3">In this chapter, we will explore several recipes on how to debug and inspect your implementation. </span><span class="koboSpan" id="kobo.3.4">We will also demonstrate how to measure the performance of your implementation once you can display an image onscreen. </span><span class="koboSpan" id="kobo.3.5">After all, graphics programming is all about extracting the last drop of performance from the hardware and Vulkan was designed to help you do </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">just that.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">main topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.7.1">Frame debugging</span></span></li>
<li><span class="koboSpan" id="kobo.8.1">Naming Vulkan objects for </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">easy debugging</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Printing values from shaders </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">in Vulkan</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Intercepting validation </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">layer messages</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Retrieving debug information </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">from shaders</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Measuring performance in Vulkan with </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">timestamp queries</span></span></li>
</ul>
<h1 id="_idParaDest-298"><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">For this chapter, you will need to make sure you have VS 2022 installed along with the Vulkan SDK. </span><span class="koboSpan" id="kobo.19.2">Please revisit </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.20.1">Chapter 1</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.21.1">, Vulkan Core Concepts</span></em><span class="koboSpan" id="kobo.22.1">, under the </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Technical requirements</span></em><span class="koboSpan" id="kobo.24.1"> section for details on setting up. </span><span class="koboSpan" id="kobo.24.2">Additionally, you will need RenderDoc and Tracy for this chapter. </span><span class="koboSpan" id="kobo.24.3">The steps to download and install these tools will be provided in the corresponding recipes within </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">this chapter.</span></span></p>
<h1 id="_idParaDest-299"><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.26.1">Frame debugging</span></h1>
<p><span class="koboSpan" id="kobo.27.1">Capturing and replaying a frame is very important for debugging graphics applications. </span><span class="koboSpan" id="kobo.27.2">Different than a live capture, in which results are captured and displayed as your application is </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.28.1">running, capturing means recording all the commands sent to the GPU along with their data. </span><span class="koboSpan" id="kobo.28.2">This includes all the draw calls, shaders, textures, buffers, and other resources used to render the frame. </span><span class="koboSpan" id="kobo.28.3">Replaying a frame means executing those recorded commands again. </span><span class="koboSpan" id="kobo.28.4">Frame replay is a powerful feature for debugging because it allows developers to closely examine the rendering process, step by step, and see exactly what’s happening at each stage. </span><span class="koboSpan" id="kobo.28.5">If a bug or graphical glitch occurs, frame replay can help pin down exactly where and why it’s happening. </span><span class="koboSpan" id="kobo.28.6">There are multiple tools for frame debugging, such as RenderDoc, PIX, NVIDIA’s Nsight Graphics, and AMD Radeon </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">GPU Profiler.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">In this recipe, we will </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.31.1">focus on how to use </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">RenderDoc</span></strong><span class="koboSpan" id="kobo.33.1"> since it is open source, cross-platform, and works on almost </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">all GPUs.</span></span></p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.35.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.36.1">As a first step, you need </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.37.1">to download RenderDoc </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">from </span></span><a href="https://renderdoc.org/builds"><span class="No-Break"><span class="koboSpan" id="kobo.39.1">https://renderdoc.org/builds</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.40.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">RenderDoc’s UI contains the following </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">main components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.43.1">Timeline</span></strong><span class="koboSpan" id="kobo.44.1">: This is typically found on the top row of RenderDoc’s user interface. </span><span class="koboSpan" id="kobo.44.2">The timeline provides a graphical representation of all the API calls (events) that occurred during the frame you’ve captured. </span><span class="koboSpan" id="kobo.44.3">It’s color-coded to indicate different types of events (such as draw calls or compute dispatches), making it easy to get a high-level overview of what’s happening in your frame. </span><span class="koboSpan" id="kobo.44.4">You can select any event in the timeline to view more detailed information in </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">Event Browser</span></strong><span class="koboSpan" id="kobo.46.1"> (on the left side of the UI) and the various tabs on the right side of </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">the UI.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">Event Browser</span></strong><span class="koboSpan" id="kobo.49.1">: Located on the left side of the UI, </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">Event Browser</span></strong><span class="koboSpan" id="kobo.51.1"> provides a detailed, hierarchical view of all the events in your frame. </span><span class="koboSpan" id="kobo.51.2">It shows the order of the API calls and allows you to navigate through them easily. </span><span class="koboSpan" id="kobo.51.3">When you select an event in </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">Event Browser</span></strong><span class="koboSpan" id="kobo.53.1">, RenderDoc will highlight the corresponding event in the timeline and update the tabs on the right side of the UI with information related to </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">that event.</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.55.1">Tabs</span></strong><span class="koboSpan" id="kobo.56.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.57.1">Texture Viewer</span></strong><span class="koboSpan" id="kobo.58.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">Mesh Viewer</span></strong><span class="koboSpan" id="kobo.60.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">Pipeline State</span></strong><span class="koboSpan" id="kobo.62.1">, and so on): These tabs are found on the right side of the UI, and they provide detailed information about the </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.63.1">currently selected event. </span><span class="koboSpan" id="kobo.63.2">Each tab focuses on a different aspect of the </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">rendering process:</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.65.1">Texture Viewer</span></strong><span class="koboSpan" id="kobo.66.1">: This tab allows you to view all of the textures that are used in your frame. </span><span class="koboSpan" id="kobo.66.2">You can inspect each texture’s properties, visualize their contents, and see how they are used in </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">your shaders.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.68.1">Mesh Viewer</span></strong><span class="koboSpan" id="kobo.69.1">: This tab provides a visual and numerical view of the vertex and index buffers used by a draw call. </span><span class="koboSpan" id="kobo.69.2">You can inspect the raw buffer data, view the resulting geometry, and see how the vertices are transformed by your </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">vertex shader.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.71.1">Pipeline State</span></strong><span class="koboSpan" id="kobo.72.1">: This tab shows the complete state of the GPU pipeline for the selected event. </span><span class="koboSpan" id="kobo.72.2">You can see all the bound resources (such as buffers and textures), inspect the shaders being used, and view the configuration of the various </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">pipeline stages.</span></span></li></ul><p class="list-inset"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.74.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.75.1">.1</span></em><span class="koboSpan" id="kobo.76.1"> shows RenderDoc’s main UI elements with a captured frame opened </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">for inspection.</span></span></p></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.78.1"><img alt="Figure 9.1 – RenderDoc main screen" src="image/B18491_09_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.79.1">Figure 9.1 – RenderDoc main screen</span></p>
<p><span class="koboSpan" id="kobo.80.1">In the next section, we will demonstrate how to use RenderDoc using executables from </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.81.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.82.1">, </span><em class="italic"><span class="koboSpan" id="kobo.83.1">Vulkan Core Concepts</span></em><span class="koboSpan" id="kobo.84.1">, and </span><a href="B18491_03.xhtml#_idTextAnchor217"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.85.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.86.1">, </span><em class="italic"><span class="koboSpan" id="kobo.87.1">Implementing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.88.1">GPU-Driven Rendering</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">.</span></span></p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.90.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.91.1">Capturing </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.92.1">a frame (or frames) with RenderDoc can be done programmatically or interactively, using the user interface. </span><span class="koboSpan" id="kobo.92.2">The next steps will explain how to capture frames from your application using RenderDoc’s </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">user interface:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.94.1">As a first step, you can launch the application by selecting the application to launch in the </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">Launch Application</span></strong><span class="koboSpan" id="kobo.96.1"> tab. </span><span class="koboSpan" id="kobo.96.2">Once the application is launched, click </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">Capture Frame(s) Immediately</span></strong><span class="koboSpan" id="kobo.98.1">. </span><span class="koboSpan" id="kobo.98.2">This will capture the current frame of the application, which we can inspect. </span><span class="koboSpan" id="kobo.98.3">Once the frame is captured, double-clicking it will open it for inspection. </span><span class="koboSpan" id="kobo.98.4">You can also save the frame on disk to open </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">it later.</span></span></li>
<li><span class="koboSpan" id="kobo.100.1">After the capture, we can select the draw call in </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">Event Browser</span></strong><span class="koboSpan" id="kobo.102.1"> (on the left of the UI) that we would like to inspect. </span><span class="koboSpan" id="kobo.102.2">In this case, that call is </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">vkCmdDraw</span></strong><span class="koboSpan" id="kobo.104.1"> (EID 7). </span><span class="koboSpan" id="kobo.104.2">Once you select it, you will see all the input and output textures used by this draw call in the </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">Texture Viewer</span></strong><span class="koboSpan" id="kobo.106.1"> tab as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.107.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.108.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.110.1">When you’re interested in exploring the mesh data, the </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">Mesh Viewer</span></strong><span class="koboSpan" id="kobo.112.1"> tab is your go-to tool. </span><span class="koboSpan" id="kobo.112.2">This feature provides a comprehensive view of both input and output vertex data, offering a deeper understanding of how your mesh is structured. </span><span class="koboSpan" id="kobo.112.3">Let’s say a specific vertex is giving you trouble, or you simply want to understand </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.113.1">its behavior better. </span><span class="koboSpan" id="kobo.113.2">To achieve this, you need to select the vertex in question. </span><span class="koboSpan" id="kobo.113.3">A right-click will then reveal an option named </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">Debug this vertex</span></strong><span class="koboSpan" id="kobo.115.1">. </span><span class="koboSpan" id="kobo.115.2">Selecting this option will lead you to the vertex shader that was used in rendering your mesh. </span><span class="koboSpan" id="kobo.115.3">Note that the shader’s source code will only be available if the SPIR-V has been generated with </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">debug symbols.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.117.1"><img alt="Figure 9.2 – RenderDoc Texture Viewer" src="image/B18491_09_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.118.1">Figure 9.2 – RenderDoc Texture Viewer</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.119.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Pipeline State</span></strong><span class="koboSpan" id="kobo.121.1"> tab is a crucial component in the RenderDoc UI. </span><span class="koboSpan" id="kobo.121.2">It offers an extensive view of the various stages, and their states, involved in the graphics pipeline, serving as a powerful tool for analyzing and debugging your rendering process. </span><span class="koboSpan" id="kobo.121.3">In the vertex shader stage, you can inspect the operations applied to each vertex. </span><span class="koboSpan" id="kobo.121.4">This includes transformations to position vertices in the correct 3D space, as well as </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.122.1">calculations to determine vertex colors or texture coordinates. </span><span class="koboSpan" id="kobo.122.2">You can also select V</span><strong class="bold"><span class="koboSpan" id="kobo.123.1">iew </span></strong><span class="koboSpan" id="kobo.124.1">S</span><strong class="bold"><span class="koboSpan" id="kobo.125.1">hader</span></strong><span class="koboSpan" id="kobo.126.1"> to inspect the shader source code used during this draw call. </span><span class="koboSpan" id="kobo.126.2">Moving on to the fragment shader stage, the </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">Pipeline State</span></strong><span class="koboSpan" id="kobo.128.1"> tab allows you to scrutinize how each fragment (potential pixel) is processed. </span><span class="koboSpan" id="kobo.128.2">This includes operations such as determining its final color based on lighting, texture, and/or other factors. </span><span class="koboSpan" id="kobo.128.3">Debugging this stage can help you resolve issues related to color computations, texture mapping, </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">and more.</span></span></li>
<li><span class="koboSpan" id="kobo.130.1">To debug a specific fragment, you’ll need to select a pixel in </span><strong class="bold"><span class="koboSpan" id="kobo.131.1">Texture Viewer</span></strong><span class="koboSpan" id="kobo.132.1">. </span><span class="koboSpan" id="kobo.132.2">You can do this by clicking on the pixel you’re interested in. </span><span class="koboSpan" id="kobo.132.3">The values of this pixel represent the output of the fragment shader for that specific pixel. </span><span class="koboSpan" id="kobo.132.4">After selecting a pixel, you can debug the fragment shader that produced it. </span><span class="koboSpan" id="kobo.132.5">To do this, right-click on the pixel and select the </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">Debug</span></strong><span class="koboSpan" id="kobo.134.1"> button shown inside the </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">Pixel Context</span></strong><span class="koboSpan" id="kobo.136.1"> window. </span><span class="koboSpan" id="kobo.136.2">This will open a new </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Shader Viewer</span></strong><span class="koboSpan" id="kobo.138.1"> tab, where you can step through the shader code line by line. </span><span class="koboSpan" id="kobo.138.2">For each line, you can inspect the values of your variables and see how they change as the </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">shader executes.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.140.1">The compute shader stage is used for performing general-purpose computations on the GPU. </span><span class="koboSpan" id="kobo.140.2">Here, you can inspect and debug the operations that aren’t directly related to rendering, such as physics simulations or culling. </span><span class="koboSpan" id="kobo.140.3">In the next step, we will demonstrate using the executable from </span><a href="B18491_03.xhtml#_idTextAnchor217"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.141.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.142.1">, </span><em class="italic"><span class="koboSpan" id="kobo.143.1">Implementing GPU-Driven Rendering</span></em><span class="koboSpan" id="kobo.144.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.145.1">Frustum culling using compute </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.146.1">shaders</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.147.1"> recipe.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.148.1">To understand how to debug the compute shader, we will first need to launch </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">Chapter03_GPU_Culling.exe</span></strong><span class="koboSpan" id="kobo.150.1"> from RenderDoc. </span><span class="koboSpan" id="kobo.150.2">Once the application is up, we will take a capture. </span><span class="koboSpan" id="kobo.150.3">Next, navigate to the </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">Pipeline State</span></strong><span class="koboSpan" id="kobo.152.1"> tab. </span><span class="koboSpan" id="kobo.152.2">Now, your focus should be on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">vkCmdDispatch</span></strong><span class="koboSpan" id="kobo.154.1"> call. </span><span class="koboSpan" id="kobo.154.2">Selecting this call in </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">Event Browser</span></strong><span class="koboSpan" id="kobo.156.1"> will display the associated pipeline used by this call in the </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">Pipeline State</span></strong><span class="koboSpan" id="kobo.158.1"> tab, as demonstrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.159.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.160.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.162.1"><img alt="Figure 9.3 – Compute shader as seen in RenderDoc" src="image/B18491_09_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.163.1">Figure 9.3 – Compute shader as seen in RenderDoc</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.164.1">When it comes to culling, we launch as many threads as there are meshes. </span><span class="koboSpan" id="kobo.164.2">Then, on the GPU, we’re simply discarding any mesh that isn’t visible in the frustum. </span><span class="koboSpan" id="kobo.164.3">Let’s assume </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.165.1">we’re interested in understanding why mesh number 5 is outside the frustum. </span><span class="koboSpan" id="kobo.165.2">To debug this, click the </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">Debug</span></strong><span class="koboSpan" id="kobo.167.1"> button and specify the thread ID in the </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">Debug Compute Shader</span></strong><span class="koboSpan" id="kobo.169.1"> window. </span><span class="koboSpan" id="kobo.169.2">This window allows you to specify either a global thread ID or a thread group and a local thread ID. </span><span class="koboSpan" id="kobo.169.3">In our case, to debug mesh number 5, you would enter 5 in the global X dimension (in the </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">Dispatch Thread ID</span></strong><span class="koboSpan" id="kobo.171.1"> section). </span><span class="koboSpan" id="kobo.171.2">Once you click the </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">Debug</span></strong><span class="koboSpan" id="kobo.173.1"> button, a new window containing the shader source code will be launched. </span><span class="koboSpan" id="kobo.173.2">Here, you can inspect and debug the compute shader, enabling you to understand why a particular mesh was discarded. </span><span class="koboSpan" id="kobo.173.3">The process is demonstrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.174.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.175.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.177.1"><img alt="Figure 9.4 – Debugging a compute shader in RenderDoc" src="image/B18491_09_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.178.1">Figure 9.4 – Debugging a compute shader in RenderDoc</span></p>
<p><span class="koboSpan" id="kobo.179.1">This recipe is </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.180.1">a very brief introduction to </span><em class="italic"><span class="koboSpan" id="kobo.181.1">one</span></em><span class="koboSpan" id="kobo.182.1"> frame debugging tool. </span><span class="koboSpan" id="kobo.182.2">Keep in mind other tools exist and operate in </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">different ways.</span></span></p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.184.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.185.1">For a comprehensive understanding of how to utilize RenderDoc, we highly recommend viewing the following video tutorials. </span><span class="koboSpan" id="kobo.185.2">These will provide you with detailed insights into </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">its usage:</span></span></p>
<ul>
<li><a href="https://youtu.be/7eznPe3TyAY"><span class="No-Break"><span class="koboSpan" id="kobo.187.1">https://youtu.be/7eznPe3TyAY</span></span></a></li>
<li><a href="https://youtu.be/EMFG5wmng-M"><span class="No-Break"><span class="koboSpan" id="kobo.188.1">https://youtu.be/EMFG5wmng-M</span></span></a></li>
<li><a href="https://renderdoc.org/docs/getting_started/quick_start.html"><span class="No-Break"><span class="koboSpan" id="kobo.189.1">https://renderdoc.org/docs/getting_started/quick_start.html</span></span></a></li>
</ul>
<h1 id="_idParaDest-303"><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.190.1">Naming Vulkan objects for easy debugging</span></h1>
<p><span class="koboSpan" id="kobo.191.1">Using Vulkan </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.192.1">means you need to create and manage many Vulkan objects. </span><span class="koboSpan" id="kobo.192.2">By default, those objects are identified by their handle, a numerical ID. </span><span class="koboSpan" id="kobo.192.3">Although numerical IDs are easy to maintain from an application perspective, they are meaningless to humans. </span><span class="koboSpan" id="kobo.192.4">Consider the following error message, provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">validation layer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
VUID-VkImageViewCreateInfo-imageViewType-04974 ] Object 0: handle = 0xcb3ee80000000007, type = VK_OBJECT_TYPE_IMAGE; | MessageID = 0xc120e150 | vkCreateImageView(): Using pCreateInfo-&gt;viewType VK_IMAGE_VIEW_TYPE_2D and the subresourceRange.layerCount VK_REMAINING_ARRAY_LAYERS=(2) and must 1 (try looking into VK_IMAGE_VIEW_TYPE_*_ARRAY). </span><span class="koboSpan" id="kobo.194.2">The Vulkan spec states: If viewType is VK_IMAGE_VIEW_TYPE_1D, VK_IMAGE_VIEW_TYPE_2D, or VK_IMAGE_VIEW_TYPE_3D; and subresourceRange.layerCount is VK_REMAINING_ARRAY_LAYERS, then the remaining number of layers must be 1</span></pre> <p><span class="koboSpan" id="kobo.195.1">The preceding </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.196.1">message is useful, but finding which image has been created with the wrong number of layers </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">is hard.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">If, on the other hand, we give that image a name, the validation layer message becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
VUID-VkImageViewCreateInfo-imageViewType-04974 ] Object 0: handle = 0xcb3ee80000000007, </span><strong class="bold"><span class="koboSpan" id="kobo.201.1">name = Image: Swapchain image 0</span></strong><span class="koboSpan" id="kobo.202.1">, type = VK_OBJECT_TYPE_IMAGE; | MessageID = 0xc120e150 | vkCreateImageView(): Using pCreateInfo-&gt;viewType VK_IMAGE_VIEW_TYPE_2D and the subresourceRange.layerCount VK_REMAINING_ARRAY_LAYERS=(2) and must 1 (try looking into VK_IMAGE_VIEW_TYPE_*_ARRAY). </span><span class="koboSpan" id="kobo.202.2">The Vulkan spec states: If viewType is VK_IMAGE_VIEW_TYPE_1D, VK_IMAGE_VIEW_TYPE_2D, or VK_IMAGE_VIEW_TYPE_3D; and subresourceRange.layerCount is VK_REMAINING_ARRAY_LAYERS, then the remaining number of layers must be 1</span></pre> <p><span class="koboSpan" id="kobo.203.1">Note that the name of the object is now part of the error message. </span><span class="koboSpan" id="kobo.203.2">That makes it much easier to know where to look in your code and fix </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">the error.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">In this recipe, you will learn how to use a Vulkan extension to give human-readable or meaningful names to all </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">Vulkan objects.</span></span></p>
<h2 id="_idParaDest-304"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.207.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.208.1">To be able to assign names to a Vulkan object, you first need to enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">VK_EXT_debug_utils</span></strong><span class="koboSpan" id="kobo.210.1"> instance extension. </span><span class="koboSpan" id="kobo.210.2">This extension’s name needs to be provided </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.211.1">during the creation of the Vulkan instance as either a string, </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">VK_EXT_debug_utils</span></strong><span class="koboSpan" id="kobo.213.1">, or using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">VK_EXT_DEBUG_UTILS_EXTENSION_NAME</span></strong><span class="koboSpan" id="kobo.215.1"> macro. </span><span class="koboSpan" id="kobo.215.2">The following code snippet initializes a Vulkan instance with debug </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">utilities enabled:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
VkInstance instance_ = VK_NULL_HANDLE;
std::vector&lt;const char *&gt; instanceExtensions = {
  </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">VK_EXT_DEBUG_UTILS_EXTENSION_NAME</span></strong><span class="koboSpan" id="kobo.219.1">};
const VkInstanceCreateInfo instanceInfo = {
  .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
  ...
</span><span class="koboSpan" id="kobo.219.2">  .enabledExtensionCount = static_cast&lt;uint32_t&gt;(
    instanceExtensions.size()),
  .ppEnabledExtensionNames =
    instanceExtensions.data(),
};
VK_CHECK(vkCreateInstance(&amp;instanceInfo, nullptr,
                          &amp;instance_));</span></pre> <p><span class="koboSpan" id="kobo.220.1">Now you are ready to start naming your Vulkan object. </span><span class="koboSpan" id="kobo.220.2">Let’s see how in the </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">next section.</span></span></p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.222.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.223.1">Once the extension has been enabled, here are the steps to name </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">your objects:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.225.1">Once the extension has been enabled, you may add a name to any Vulkan object, given its handle, by calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">vkSetDebugUtilsObjectNameEXT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.228.1">
VkDevice device_; // Valid Vulkan device
VkObjectType type = VK_OBJECT_TYPE_UNKNOWN;
std::string name; // human readable name
const VkDebugUtilsObjectNameInfoEXT
  objectNameInfo = {
    .sType =
      VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
    .objectType = type,
    .objectHandle =
      reinterpret_cast&lt;uint64_t&gt;(</span><strong class="bold"><span class="koboSpan" id="kobo.229.1">handle</span></strong><span class="koboSpan" id="kobo.230.1">),
    .pObjectName = name.c_str(),
};
VK_CHECK(vkSetDebugUtilsObjectNameEXT(
  device_, &amp;objectNameInfo));</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.231.1">The object type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">type</span></strong><span class="koboSpan" id="kobo.233.1">) is one of the values of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">VkObject</span></strong><span class="koboSpan" id="kobo.235.1"> enumeration and must match </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.236.1">the object’s type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">VK_OBJECT_TYPE_IMAGE</span></strong><span class="koboSpan" id="kobo.238.1"> for a Vulkan Image, for example). </span><span class="koboSpan" id="kobo.238.2">The handle is the object’s handle, which needs to be cast to </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">uint64_t</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.242.1">This function is only available if the extension is also available, so make sure to guard it in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">#ifdef</span></strong><span class="koboSpan" id="kobo.244.1"> block and check whether the extension has been enabled for </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">the instance.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.246.1">In the repository, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">VulkanCore::Context:: setVkObjectname</span></strong><span class="koboSpan" id="kobo.248.1"> method wraps this function in a templated class and does the casting for you. </span><span class="koboSpan" id="kobo.248.2">Also, it’s worth mentioning that names aren’t only displayed on validation error messages. </span><span class="koboSpan" id="kobo.248.3">They also appear in frame capture and </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">debugging tools.</span></span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.250.1"><img alt="Figure 9.5 - Examples of how object names appear in RenderDoc" src="image/B18491_09_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.251.1">Figure 9.5 - Examples of how object names appear in RenderDoc</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.252.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.253.1">.5</span></em><span class="koboSpan" id="kobo.254.1"> shows how </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.255.1">object names are displayed in RenderDoc. </span><span class="koboSpan" id="kobo.255.2">In the screenshot, one of the swapchain images is named </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">Image: Swapchain image 1</span></strong><span class="koboSpan" id="kobo.257.1">. </span><span class="koboSpan" id="kobo.257.2">The depth buffer is named </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">Image: </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.259.1">depth buffer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">.</span></span></p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.261.1">Printing values from shaders in Vulkan</span></h1>
<p><span class="koboSpan" id="kobo.262.1">As graphics programmers, we must all agree that debugging shaders is one of the most frustrating </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.263.1">aspects of our jobs. </span><span class="koboSpan" id="kobo.263.2">Even though some frame capture software provides shader debugging, it may still be difficult to find the exact pixel you would like to debug, or you may need another piece of information about a set of pixels instead of just inspecting them one </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">by one.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Thankfully, Vulkan provides a way to print values directly from shaders. </span><span class="koboSpan" id="kobo.265.2">The information can be inspected directly on RenderDoc, for example, or retrieved from the validation error messages (please refer to the </span><em class="italic"><span class="koboSpan" id="kobo.266.1">Retrieving debugging information from shaders</span></em><span class="koboSpan" id="kobo.267.1"> recipe for more details on how to </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">do this).</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">In this recipe, you will learn how to print values from your shader code using a simple function that is </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">like </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">printf</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">.</span></span></p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.273.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.274.1">To utilize the functionality of printing values from shaders, it’s a prerequisite to enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">VK_KHR_shader_non_semantic_info</span></strong><span class="koboSpan" id="kobo.276.1"> device extension. </span><span class="koboSpan" id="kobo.276.2">This can be achieved by </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.277.1">adding either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">VK_KHR_shader_non_semantic_info</span></strong><span class="koboSpan" id="kobo.279.1"> string or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME</span></strong><span class="koboSpan" id="kobo.281.1"> macro to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">VkDeviceCreateInfo</span></strong><span class="koboSpan" id="kobo.283.1"> structure during the creation of a Vulkan device. </span><span class="koboSpan" id="kobo.283.2">This process is demonstrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
VkPhysicalDevice physicalDevice; // Valid Vulkan
                                 // Physical Device
const std::vector&lt;const char *&gt; deviceExtensions =
  {</span><strong class="bold"><span class="koboSpan" id="kobo.286.1">VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME</span></strong><span class="koboSpan" id="kobo.287.1">};
const VkDeviceCreateInfo dci = {
  .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
  ...
</span><span class="koboSpan" id="kobo.287.2">  .enabledExtensionCount = static_cast&lt;uint32_t&gt;(
    deviceExtensions.size()),
  .ppEnabledExtensionNames = deviceExtensions.data(),
};
VK_CHECK(vkCreateDevice(physicalDevice_, &amp;dci,
  nullptr, &amp;device_));</span></pre> <p><span class="koboSpan" id="kobo.288.1">Now that the extension has been enabled, let’s see what the steps are to print values directly </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">from shaders.</span></span></p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.290.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.291.1">Once the </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.292.1">extension has been enabled, you will also need to add a GLSL extension to </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">your shaders:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.294.1">Enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">GL_EXT_debug_printf</span></strong><span class="koboSpan" id="kobo.296.1"> extension in your </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">shader code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.298.1">
#version 460
</span><strong class="bold"><span class="koboSpan" id="kobo.299.1">#extension GL_EXT_debug_printf: enable</span></strong></pre></li> <li><span class="koboSpan" id="kobo.300.1">Call </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">debugPrintfEXT</span></strong><span class="koboSpan" id="kobo.302.1"> in your shader code whenever you would like to print values. </span><span class="koboSpan" id="kobo.302.2">In the following code snippet, we are printing the value </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">gl_VertexIndex</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.306.1">
debugPrintfEXT("gl_VertexIndex = %i", gl_VertexIndex);</span></pre></li> <li><span class="koboSpan" id="kobo.307.1">The function provides specifiers for vector values as well. </span><span class="koboSpan" id="kobo.307.2">Here’s an example of a call that prints all components of a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">vec3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1"> variable:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.310.1">
vec3 position;
debugPrintfEXT("%2.3v3f", position);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.311.1">The preceding function call prints the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">x</span></strong><span class="koboSpan" id="kobo.313.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">y</span></strong><span class="koboSpan" id="kobo.315.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">z</span></strong><span class="koboSpan" id="kobo.317.1"> components of </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">position</span></strong><span class="koboSpan" id="kobo.319.1"> as a floating-point value with </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">3 decimals.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.321.1">Here’s the abridged version of the vertex shader used in </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.322.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.323.1">, </span><em class="italic"><span class="koboSpan" id="kobo.324.1">Vulkan Core Concepts</span></em><span class="koboSpan" id="kobo.325.1">, with the added </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">debugPrintfEXT</span></strong><span class="koboSpan" id="kobo.327.1"> call to print the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">gl_VertexIndex</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.329.1"> value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.330.1">
#version 460
#extension GL_EXT_debug_printf: enable
layout(location = 0) out vec4 outColor;
vec2 positions[3] = vec2[]( ... </span><span class="koboSpan" id="kobo.330.2">);
vec3 colors[3] = vec3[]( ... </span><span class="koboSpan" id="kobo.330.3">);
void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    debugPrintfEXT(«gl_VertexIndex = %i», gl_VertexIndex);
    outColor = vec4(colors[gl_VertexIndex], 1.0);
}</span></pre> <p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.331.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.332.1">.6</span></em><span class="koboSpan" id="kobo.333.1"> shows how </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.334.1">the printed values can be inspected </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">in RenderDoc:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.336.1"><img alt="Figure 9.6 – debugPrintfEXT values visible in RenderDoc" src="image/B18491_09_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.337.1">Figure 9.6 – debugPrintfEXT values visible in RenderDoc</span></p>
<h1 id="_idParaDest-309"><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.338.1">Intercepting validation layer messages</span></h1>
<p><span class="koboSpan" id="kobo.339.1">In some circumstances, validation errors are so plentiful that it becomes impossible to know where </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.340.1">the cause of the problem is. </span><span class="koboSpan" id="kobo.340.2">For that reason, it would be ideal to interrupt the execution of your program as soon as an error is detected, especially when debugging your application. </span><span class="koboSpan" id="kobo.340.3">The debug utility extension (</span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">VK_EXT_debug_utils</span></strong><span class="koboSpan" id="kobo.342.1">) allows you to install a callback function that is invoked whenever an error </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">is detected.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">In this recipe, you will learn how to install a debug callback to intercept error messages emitted by the validation layer and make your debugging sessions </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">more productive.</span></span></p>
<h2 id="_idParaDest-310"><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.346.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.347.1">To be able to set a callback whenever an error occurs, you need to enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">VK_EXT_debug_utils</span></strong><span class="koboSpan" id="kobo.349.1"> extension. </span><span class="koboSpan" id="kobo.349.2">Please refer to the </span><em class="italic"><span class="koboSpan" id="kobo.350.1">Getting ready</span></em><span class="koboSpan" id="kobo.351.1"> section of the </span><em class="italic"><span class="koboSpan" id="kobo.352.1">Naming Vulkan objects for easier debugging</span></em><span class="koboSpan" id="kobo.353.1"> recipe to learn how to enable this extension when creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">Vulkan instance.</span></span></p>
<h2 id="_idParaDest-311"><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.355.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.356.1">Before installing and using the callback, you need to define one. </span><span class="koboSpan" id="kobo.356.2">After that, and once the extension has been enabled and a Vulkan instance object has been created, you need to install the callback using a special </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">Vulkan function:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.358.1">Define a callback function with the </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">following signature:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.360.1">
typedef VkBool32(
  VKAPI_PTR
     PFN_vkDebugUtilsMessengerCallbackEXT)(
  VkDebugUtilsMessageSeverityFlagBitsEXT
    messageSeverity,
  VkDebugUtilsMessageTypeFlagsEXT messageTypes,
  const VkDebugUtilsMessengerCallbackDataEXT
     pCallbackData,
  void *pUserData);</span></pre></li> <li><span class="koboSpan" id="kobo.361.1">Here’s </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.362.1">the function used as a callback provided in </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">the repository:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.364.1">
VkBool32 VKAPI_PTR debugMessengerCallback(
  VkDebugUtilsMessageSeverityFlagBitsEXT
    messageSeverity,
  VkDebugUtilsMessageTypeFlagsEXT messageTypes,
  const VkDebugUtilsMessengerCallbackDataEXT
     pCallbackData,
  void *pUserData) {
  if (
    messageSeverity &amp;
    (VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT)) {
    LOGE("debugMessengerCallback : MessageCode "
         "is %s &amp; Message is %s",
         pCallbackData-&gt;pMessageIdName,
         pCallbackData-&gt;pMessage);
#if defined(_WIN32)
    __debugbreak();
#else
    raise(SIGTRAP);
#endif
  } else if (
    messageSeverity &amp;
    (VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT)) {
    LOGW("debugMessengerCallback : MessageCode "
         "is %s &amp; Message is %s",
         pCallbackData-&gt;pMessageIdName,
         pCallbackData-&gt;pMessage);
  } else {
    LOGI("debugMessengerCallback : MessageCode "
         "is %s &amp; Message is %s",
         pCallbackData-&gt;pMessageIdName,
         pCallbackData-&gt;pMessage);
  }
  return VK_FALSE;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.365.1">Your </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.366.1">callback can decide how to treat the message, if at all, based on its type (general message, validation message, performance message) or its severity (verbose, info, warning, or error). </span><span class="koboSpan" id="kobo.366.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">pCallbackData</span></strong><span class="koboSpan" id="kobo.368.1"> parameter (of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">VkDebugUtilsMessengerCallbackDataEXT</span></strong><span class="koboSpan" id="kobo.370.1">) provides a plethora of different information you can use, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">pUserData</span></strong><span class="koboSpan" id="kobo.372.1"> parameter may contain your own data, which is provided when installing </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">the callback.</span></span></p></li> <li><span class="koboSpan" id="kobo.374.1">Install the callback once you have a valid Vulkan instance by creating an instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">VkDebugUtilsMessengerCreateInfoEXT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1"> structure:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.377.1">
VkInstance instance; // Valid Vulkan Instance
VkDebugUtilsMessengerEXT messenger =
  VK_NULL_HANDLE;
const VkDebugUtilsMessengerCreateInfoEXT messengerInfo = {
  .sType =
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
  .flags = 0,
  .messageSeverity =
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
  .messageType =
    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
  .pfnUserCallback = &amp;debugMessengerCallback,
  .pUserData = nullptr,
};
VK_CHECK(vkCreateDebugUtilsMessengerEXT(
  instance, &amp;messengerInfo, nullptr, &amp;messenger));</span></pre></li> <li><span class="koboSpan" id="kobo.378.1">Make sure </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.379.1">to destroy the messenger once you are done with your Vulkan instance. </span><span class="koboSpan" id="kobo.379.2">This is necessary because, in Vulkan, any resources created need to be explicitly destroyed when they’re no longer needed to avoid memory leaks and to free up </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">system resources:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.381.1">
vkDestroyDebugUtilsMessengerEXT(instance_,
                                messenger_,
                                nullptr);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.382.1">The debug callback is very useful and should always be used. </span><span class="koboSpan" id="kobo.382.2">Make sure to have one as soon as possible and know how to </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">use it.</span></span></p>
<h1 id="_idParaDest-312"><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.384.1">Retrieving debug information from shaders</span></h1>
<p><span class="koboSpan" id="kobo.385.1">One of the most difficult tasks in graphics programming is writing tests. </span><span class="koboSpan" id="kobo.385.2">Be those smoke, integration, end-to-end, or unit tests, how do you ensure that the output of your engine is really </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.386.1">what you would expect? </span><span class="koboSpan" id="kobo.386.2">Except for simple tests, screenshot-like types of tests are prone to several problems. </span><span class="koboSpan" id="kobo.386.3">One particularly difficult problem is testing shader code – since you don’t usually have access to the hardware, testing shader code is </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">very painful.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">Thankfully, Vulkan has a mechanism that allows you to capture the value output from shaders with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">debugPrintfEXT</span></strong><span class="koboSpan" id="kobo.390.1"> function directly from the validation layer. </span><span class="koboSpan" id="kobo.390.2">This mechanism isn’t </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.391.1">new and could be enabled using the </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">Vulkan Configurator</span></strong><span class="koboSpan" id="kobo.393.1">. </span><span class="koboSpan" id="kobo.393.2">But, introduced with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">Vulkan SDK 1.3.275</span></strong><span class="koboSpan" id="kobo.395.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">VK_EXT_layer_settings</span></strong><span class="koboSpan" id="kobo.397.1"> instance extension allows you to enable this mechanism directly from your application without manually having to edit any </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">other configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">In this recipe, you will learn how to enable this feature and retrieve the output of </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">debugPrintfEXT</span></strong><span class="koboSpan" id="kobo.401.1"> calls </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">from shaders.</span></span></p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.403.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.404.1">For this recipe, you will need </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">Vulkan SDK version 1.3.275</span></strong><span class="koboSpan" id="kobo.406.1">. </span><span class="koboSpan" id="kobo.406.2">Although all the code in the repository was tested with </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">SDK version 1.3.265</span></strong><span class="koboSpan" id="kobo.408.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">VK_EXT_layer_settings</span></strong><span class="koboSpan" id="kobo.410.1"> extension was only available with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">SDK 1.3.275</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">.</span></span></p>
<h2 id="_idParaDest-314"><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.413.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.414.1">Enabling this feature is easy and requires only a few steps. </span><span class="koboSpan" id="kobo.414.2">Let’s get </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">to them:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.416.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">VK_EXT_layer_settings</span></strong><span class="koboSpan" id="kobo.418.1"> extension introduces a way for you to change individual layer settings. </span><span class="koboSpan" id="kobo.418.2">Each setting must be set using an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">VKLayerSettingEXT</span></strong><span class="koboSpan" id="kobo.420.1"> structure, defined </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.422.1">
typedef struct VkLayerSettingEXT {
  const char *pLayerName;
  const char *pSettingName;
  VkLayerSettingTypeEXT type;
  uint32_t valueCount;
  const void *pValues;
} VkLayerSettingEXT;</span></pre></li> <li><span class="koboSpan" id="kobo.423.1">To enable the feature that allows you to receive output from shaders, you need to enable a few settings of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">VK_LAYER_KHRONOS_validation</span></strong><span class="koboSpan" id="kobo.425.1"> layer. </span><span class="koboSpan" id="kobo.425.2">Let’s start </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.426.1">by creating a constant with the layer name for which we’ll change </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">the settings:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.428.1">
const std::string layer_name =
  "VK_LAYER_KHRONOS_validation";</span></pre></li> <li><span class="koboSpan" id="kobo.429.1">Now we create arrays to store the values of the settings </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">we’ll use:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.431.1">
const std::array&lt;const char *, 1&gt;
  settin</span><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.432.1">g_debug_action = {"VK_DBG_LAYER_ACTION_BREAK"};
const std::array&lt;const char *, 1&gt;
  setting_gpu_based_action = {
    "GPU_BASED_DEBUG_PRINTF"};
const std::array&lt;VkBool32, 1&gt;
  setting_printf_to_stdout = {VK_TRUE};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.433.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">debug_action</span></strong><span class="koboSpan" id="kobo.435.1"> setting was changed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">VK_DBG_LAYER_ACTION_BREAK</span></strong><span class="koboSpan" id="kobo.437.1"> so that the callback is called whenever there’s a new value from </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">debugPrintfEXT</span></strong><span class="koboSpan" id="kobo.439.1">. </span><span class="koboSpan" id="kobo.439.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">validate_gpu_based</span></strong><span class="koboSpan" id="kobo.441.1"> setting is set to receive the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">debugPrintEXT</span></strong><span class="koboSpan" id="kobo.443.1"> values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">GPU_BASED_DEBUG_PRINTF</span></strong><span class="koboSpan" id="kobo.445.1">) and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">printf_to_stdout</span></strong><span class="koboSpan" id="kobo.447.1"> setting (set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">VK_FALSE</span></strong><span class="koboSpan" id="kobo.449.1">) specifies we don’t want those values to go to </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">stdout</span></strong><span class="koboSpan" id="kobo.451.1">; we want to receive them in </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">the callback.</span></span></p></li> <li><span class="koboSpan" id="kobo.453.1">We create instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">VkLayerSettingEXT</span></strong><span class="koboSpan" id="kobo.455.1"> structure for each setting we would </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.456.1">like to change. </span><span class="koboSpan" id="kobo.456.2">Here, we are changing the following settings of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">layer_name</span></strong><span class="koboSpan" id="kobo.458.1"> layer: </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">debug_action</span></strong><span class="koboSpan" id="kobo.460.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">validate_gpu_based</span></strong><span class="koboSpan" id="kobo.462.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">printf_to_stdout</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.466.1">
const array&lt;VkLayerSettingEXT, 3&gt; settings = {
  VkLayerSettingEXT{
    .pLayerName = layer_name.c_str(),
    .pSettingName = </span><strong class="bold"><span class="koboSpan" id="kobo.467.1">"debug_action"</span></strong><span class="koboSpan" id="kobo.468.1">,
    .type = VK_LAYER_SETTING_TYPE_STRING_EXT,
    .valueCount = 1,
    .pValues = setting_debug_action.data(),
  },
  VkLayerSettingEXT{
    .pLayerName = layer_name.c_str(),
    .pSettingName = </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">"validate_gpu_based"</span></strong><span class="koboSpan" id="kobo.470.1">,
    .type = VK_LAYER_SETTING_TYPE_STRING_EXT,
    .valueCount = 1,
    .pValues = setting_gpu_based_action.data(),
  },
  VkLayerSettingEXT{
    .pLayerName = layer_name.c_str(),
    .pSettingName = </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">"printf_to_stdout"</span></strong><span class="koboSpan" id="kobo.472.1">,
    .type = VK_LAYER_SETTING_TYPE_BOOL32_EXT,
    .valueCount = 1,
    .pValues = setting_printf_to_stdout.data(),
  },
};</span></pre></li> <li><span class="koboSpan" id="kobo.473.1">Then we add those settings to an instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">VkLayerSettingsCreateInfoEXT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1"> structure:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.476.1">
const VkLayerSettingsCreateInfoEXT
  layer_settings_ci = {
    .sType =
      VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT,
    .pNext = nullptr,
    .settingCount =
      static_cast&lt;uint32_t&gt;(settings.size()),
    .pSettings = settings.data(),
};</span></pre></li> <li><span class="koboSpan" id="kobo.477.1">Finally, we </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.478.1">add this instance to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">pNext</span></strong><span class="koboSpan" id="kobo.480.1"> chain of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">VkInstanceCreateInfo</span></strong><span class="koboSpan" id="kobo.482.1"> structure used to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">Vulkan instance:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.484.1">
const VkInstanceCreateInfo instanceInfo = {
  .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
  .pNext = &amp;layer_settings_ci,
  ...
</span><span class="koboSpan" id="kobo.484.2">};
VK_CHECK(vkCreateInstance(&amp;instanceInfo, nullptr,
                          &amp;instance_));</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.485.1">When enabled for </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.486.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.487.1">, </span><em class="italic"><span class="koboSpan" id="kobo.488.1">Vulkan Core Concepts,</span></em><span class="koboSpan" id="kobo.489.1"> code in the repository, the message received by the callback looks something </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
Validation Information: [ WARNING-DEBUG-PRINTF ] | MessageID = 0x76589099 | vkQueueSubmit():  gl_VertexIndex = 1</span></pre> <p><span class="koboSpan" id="kobo.492.1">It is possible to enable a verbose output, in which case the preceding message would look </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
Validation Information: [ WARNING-DEBUG-PRINTF ] Object 0: handle = 0x26e6bf17bd0, type = VK_OBJECT_TYPE_QUEUE; | MessageID = 0x76589099 | vkQueueSubmit():  Command buffer (Command buffer:  0)(0x26e6c6613b0). </span><span class="koboSpan" id="kobo.494.2">Draw Index 0. </span><span class="koboSpan" id="kobo.494.3">Pipeline (Graphics pipeline: )(0x26e78d000d0). </span><span class="koboSpan" id="kobo.494.4">Shader Module (Shader Module: )(0x26e73b68450). </span><span class="koboSpan" id="kobo.494.5">Shader Instruction Index = 92.  gl_VertexIndex = 1 Debug shader printf message generated at line 21.
</span><span class="koboSpan" id="kobo.494.6">21:     outColor = vec4(colors[gl_VertexIndex], 1.0);</span></pre> <p><span class="koboSpan" id="kobo.495.1">Hopefully, this </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.496.1">feature will help you write tests for obscure corners of your code that weren’t even possible to </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">test before.</span></span></p>
<h1 id="_idParaDest-315"><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.498.1">Measuring performance in Vulkan with timestamp queries</span></h1>
<p><span class="koboSpan" id="kobo.499.1">Measuring </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.500.1">the performance </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.501.1">of CPU and GPU workloads side by side is invaluable. </span><span class="koboSpan" id="kobo.501.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.502.1">Tracy profiler</span></strong><span class="koboSpan" id="kobo.503.1"> allows you to do just that in a </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.504.1">cross-platform way with minimal intrusion. </span><span class="koboSpan" id="kobo.504.2">And it’s easy to use, all within a small </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">C++ library.</span></span></p>
<p><span class="koboSpan" id="kobo.506.1">In this recipe, you will learn how to integrate Tracy Profiler into your app and instrument it to collect GPU </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">performance information.</span></span></p>
<h2 id="_idParaDest-316"><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.508.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.509.1">The first thing to do is to download Tracy from </span><a href="https://github.com/wolfpld/tracy"><span class="koboSpan" id="kobo.510.1">https://github.com/wolfpld/tracy</span></a><span class="koboSpan" id="kobo.511.1"> and include it in your project. </span><span class="koboSpan" id="kobo.511.2">You should also download the Tracy client/server to collect and inspect </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">the data.</span></span></p>
<h2 id="_idParaDest-317"><a id="_idTextAnchor355"/><span class="koboSpan" id="kobo.513.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.514.1">Instrumenting your code to use with Tracy is easy and requires only a few steps. </span><span class="koboSpan" id="kobo.514.2">To be able to collect data about the GPU performance, you will need a Tracy/Vulkan context along with a dedicated command buffer for it to calibrate the timestamps. </span><span class="koboSpan" id="kobo.514.3">After that, instrumenting your code </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">is straightforward:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.516.1">First, include the Tracy header file in </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">your application:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.518.1">
#include &lt;tracy/Tracy.hpp&gt;
#include &lt;tracy/TracyVulkan.hpp&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.519.1">Second, you need a Tracy/Vulkan context that can be created by using a macro provided by the Tracy library. </span><span class="koboSpan" id="kobo.519.2">There are two options: one that creates a context with </span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.520.1">calibrated timestamps and one that creates a context without calibrated timestamps. </span><span class="koboSpan" id="kobo.520.2">Vulkan </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.521.1">provides ways to correlate the time an operation happened on timelines of different time domains. </span><span class="koboSpan" id="kobo.521.2">Without calibration, Tracy can only guess when an operation on the device happened in relation to the ones that took place on the CPU. </span><span class="koboSpan" id="kobo.521.3">Here’s how you can initialize the context that better suits </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">your needs:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.523.1">
VkPhysicalDevice physicalDevice;
VkDevice device;
int graphicsQueueIndex;
VkCommandBuffer commandBuffer;
#if defined(VK_EXT_calibrated_timestamps)
TracyVkCtx tracyCtx_ = TracyVkContextCalibrated(
  physicalDevice, device, graphicsQueueIndex,
  commandBuffer,
  vkGetPhysicalDeviceCalibrateableTimeDomainsKHR,
  vkGetCalibratedTimestampsKHR);
#else
TracyVkCtx tracyCtx_ = TracyVkContext(
  physicalDevice, device, graphicsQueueIndex,
  commandBuffer);
#endif</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.524.1">The command buffer used here is a dedicated one and it should not be shared with any </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">other operations.</span></span></p></li> <li><span class="koboSpan" id="kobo.526.1">Collecting </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.527.1">GPU information </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.528.1">is now easy. </span><span class="koboSpan" id="kobo.528.2">All you must do is use one of the macros provided by Tracy, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.530.1">
TracyVkZone(tracyCtx_, commandBuffer, "Model upload");</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.531.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">commandBuffer</span></strong><span class="koboSpan" id="kobo.533.1"> variable used in this macro is the command buffer you wish to capture data from, the one being recorded. </span><span class="koboSpan" id="kobo.533.2">This command buffer is </span><em class="italic"><span class="koboSpan" id="kobo.534.1">different</span></em><span class="koboSpan" id="kobo.535.1"> than the one provided during the construction of the </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">Tracy context.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.537.1">This macro should be added whenever you would like to instrument your GPU execution. </span><span class="koboSpan" id="kobo.537.2">For example, you might want to add this macro to a scope where you issue the draw call (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">vkCmdDraw</span></strong><span class="koboSpan" id="kobo.539.1">). </span><span class="koboSpan" id="kobo.539.2">You will then get information about that command being processed in the GPU. </span><span class="koboSpan" id="kobo.539.3">In the repository, you can find examples of how this macro </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">is used.</span></span></p></li> <li><span class="koboSpan" id="kobo.541.1">Tracy also provides macros that allow you to identify the zone with a color or name, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">TracyVkNamedZone</span></strong><span class="koboSpan" id="kobo.543.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">TracyVkNamedZoneC</span></strong><span class="koboSpan" id="kobo.545.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">so on.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.547.1">Occasionally, you need to tell Tracy to collect the timestamps from the command buffer by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">TracyVkCollect</span></strong><span class="koboSpan" id="kobo.549.1">. </span><span class="koboSpan" id="kobo.549.2">This macro can be called at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">a frame:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.551.1">
TracyVkCollect(tracyCtx_, commandBuffer);</span></pre></li> <li><span class="koboSpan" id="kobo.552.1">After exiting the render loop, and before shutting down your application, you need to destroy the Tracy context by </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">TracyVkDestroy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.556.1">
TracyVkDestroy(tracyCtx_);</span></pre></li> <li><span class="koboSpan" id="kobo.557.1">The last step is to build your project with </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">TRACY_ENABLE</span></strong><span class="koboSpan" id="kobo.559.1"> defined. </span><span class="koboSpan" id="kobo.559.2">If using CMake, you can do this by adding the following parameters when generating the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">build files:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.561.1">
-DTRACY_ENABLE=1</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.562.1">Now </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.563.1">all you must </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.564.1">do is compile your code and run it. </span><span class="koboSpan" id="kobo.564.2">Make sure to start the Tracy client beforehand and start a connection. </span><span class="koboSpan" id="kobo.564.3">The Tracy client will automatically detect your application and start collecting data once </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">it starts.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.566.1">If you instrument your code to collect CPU data using Tracy, which you can do using macros such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">ZoneScoped</span></strong><span class="koboSpan" id="kobo.568.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">ZoneScopedC</span></strong><span class="koboSpan" id="kobo.570.1">, and so on, you will see the results side by side after collection. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.571.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.572.1">.7</span></em><span class="koboSpan" id="kobo.573.1"> shows the result of capturing one of the executables from </span><a href="B18491_02.xhtml#_idTextAnchor126"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.574.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.575.1">, </span><em class="italic"><span class="koboSpan" id="kobo.576.1">Working with Modern Vulkan</span></em><span class="koboSpan" id="kobo.577.1">. </span><span class="koboSpan" id="kobo.577.2">Note the CPU and GPU zones in </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">the screenshot.</span></span></p><div class="IMG---Figure" id="_idContainer069"><span class="koboSpan" id="kobo.579.1"><img alt="Figure 9.7 – Tracy profiler capture with GPU and CPU information side by side" src="image/B18491_09_07.jpg"/></span></div></li> </ol>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.580.1">Figure 9.7 – Tracy profiler capture with GPU and CPU information side by side</span></p>
<p><span class="koboSpan" id="kobo.581.1">Tracy is </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.582.1">a very simple-to-use </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.583.1">library that provides invaluable information about your application. </span><span class="koboSpan" id="kobo.583.2">It provides nanosecond resolution along with CPU and GPU performance tracking and is cross-platform. </span><span class="koboSpan" id="kobo.583.3">If you don’t already have other performance-measuring libraries or facilities in your code base, Tracy can get you up and running in </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">no time.</span></span></p>
</div>
</body></html>