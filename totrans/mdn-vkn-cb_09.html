<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-296"><a id="_idTextAnchor333"/>9</h1>
<h1 id="_idParaDest-297"><a id="_idTextAnchor334"/>Debugging and Performance Measurement Techniques</h1>
<p>Debugging failures and reverse engineering an implementation, as well as measuring the performance of a system once it has been authored, are as important as writing new code. Vulkan is a vast and complicated API and, more than ever, knowing how to debug it is paramount. In this chapter, we will explore several recipes on how to debug and inspect your implementation. We will also demonstrate how to measure the performance of your implementation once you can display an image onscreen. After all, graphics programming is all about extracting the last drop of performance from the hardware and Vulkan was designed to help you do just that.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Frame debugging</li>
<li>Naming Vulkan objects for easy debugging</li>
<li>Printing values from shaders in Vulkan</li>
<li>Intercepting validation layer messages</li>
<li>Retrieving debug information from shaders</li>
<li>Measuring performance in Vulkan with timestamp queries</li>
</ul>
<h1 id="_idParaDest-298"><a id="_idTextAnchor335"/>Technical requirements</h1>
<p>For this chapter, you will need to make sure you have VS 2022 installed along with the Vulkan SDK. Please revisit <a href="B18491_01.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a><em class="italic">, Vulkan Core Concepts</em>, under the <em class="italic">Technical requirements</em> section for details on setting up. Additionally, you will need RenderDoc and Tracy for this chapter. The steps to download and install these tools will be provided in the corresponding recipes within this chapter.</p>
<h1 id="_idParaDest-299"><a id="_idTextAnchor336"/>Frame debugging</h1>
<p>Capturing and replaying a frame is very important for debugging graphics applications. Different than a live capture, in which results are captured and displayed as your application is <a id="_idIndexMarker665"/>running, capturing means recording all the commands sent to the GPU along with their data. This includes all the draw calls, shaders, textures, buffers, and other resources used to render the frame. Replaying a frame means executing those recorded commands again. Frame replay is a powerful feature for debugging because it allows developers to closely examine the rendering process, step by step, and see exactly what’s happening at each stage. If a bug or graphical glitch occurs, frame replay can help pin down exactly where and why it’s happening. There are multiple tools for frame debugging, such as RenderDoc, PIX, NVIDIA’s Nsight Graphics, and AMD Radeon GPU Profiler.</p>
<p>In this recipe, we will <a id="_idIndexMarker666"/>focus on how to use <strong class="bold">RenderDoc</strong> since it is open source, cross-platform, and works on almost all GPUs.</p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor337"/>Getting ready</h2>
<p>As a first step, you need <a id="_idIndexMarker667"/>to download RenderDoc from <a href="https://renderdoc.org/builds">https://renderdoc.org/builds</a>.</p>
<p>RenderDoc’s UI contains the following main components:</p>
<ul>
<li><strong class="bold">Timeline</strong>: This is typically found on the top row of RenderDoc’s user interface. The timeline provides a graphical representation of all the API calls (events) that occurred during the frame you’ve captured. It’s color-coded to indicate different types of events (such as draw calls or compute dispatches), making it easy to get a high-level overview of what’s happening in your frame. You can select any event in the timeline to view more detailed information in <strong class="bold">Event Browser</strong> (on the left side of the UI) and the various tabs on the right side of the UI.</li>
<li><strong class="bold">Event Browser</strong>: Located on the left side of the UI, <strong class="bold">Event Browser</strong> provides a detailed, hierarchical view of all the events in your frame. It shows the order of the API calls and allows you to navigate through them easily. When you select an event in <strong class="bold">Event Browser</strong>, RenderDoc will highlight the corresponding event in the timeline and update the tabs on the right side of the UI with information related to that event.<ul><li><strong class="bold">Tabs</strong> (<strong class="bold">Texture Viewer</strong>, <strong class="bold">Mesh Viewer</strong>, <strong class="bold">Pipeline State</strong>, and so on): These tabs are found on the right side of the UI, and they provide detailed information about the <a id="_idIndexMarker668"/>currently selected event. Each tab focuses on a different aspect of the rendering process:</li><li><strong class="bold">Texture Viewer</strong>: This tab allows you to view all of the textures that are used in your frame. You can inspect each texture’s properties, visualize their contents, and see how they are used in your shaders.</li><li><strong class="bold">Mesh Viewer</strong>: This tab provides a visual and numerical view of the vertex and index buffers used by a draw call. You can inspect the raw buffer data, view the resulting geometry, and see how the vertices are transformed by your vertex shader.</li><li><strong class="bold">Pipeline State</strong>: This tab shows the complete state of the GPU pipeline for the selected event. You can see all the bound resources (such as buffers and textures), inspect the shaders being used, and view the configuration of the various pipeline stages.</li></ul><p class="list-inset"><em class="italic">Figure 9</em><em class="italic">.1</em> shows RenderDoc’s main UI elements with a captured frame opened for inspection.</p></li>
</ul>
<div><div><img alt="Figure 9.1 – RenderDoc main screen" src="img/B18491_09_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – RenderDoc main screen</p>
<p>In the next section, we will demonstrate how to use RenderDoc using executables from <a href="B18491_01.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a>, <em class="italic">Vulkan Core Concepts</em>, and <a href="B18491_03.xhtml#_idTextAnchor217"><em class="italic">Chapter 3</em></a>, <em class="italic">Implementing </em><em class="italic">GPU-Driven Rendering</em>.</p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor338"/>How to do it…</h2>
<p>Capturing <a id="_idIndexMarker669"/>a frame (or frames) with RenderDoc can be done programmatically or interactively, using the user interface. The next steps will explain how to capture frames from your application using RenderDoc’s user interface:</p>
<ol>
<li>As a first step, you can launch the application by selecting the application to launch in the <strong class="bold">Launch Application</strong> tab. Once the application is launched, click <strong class="bold">Capture Frame(s) Immediately</strong>. This will capture the current frame of the application, which we can inspect. Once the frame is captured, double-clicking it will open it for inspection. You can also save the frame on disk to open it later.</li>
<li>After the capture, we can select the draw call in <code>vkCmdDraw</code> (EID 7). Once you select it, you will see all the input and output textures used by this draw call in the <strong class="bold">Texture Viewer</strong> tab as depicted in <em class="italic">Figure 9</em><em class="italic">.2</em>.</li>
<li>When you’re interested in exploring the mesh data, the <strong class="bold">Mesh Viewer</strong> tab is your go-to tool. This feature provides a comprehensive view of both input and output vertex data, offering a deeper understanding of how your mesh is structured. Let’s say a specific vertex is giving you trouble, or you simply want to understand <a id="_idIndexMarker670"/>its behavior better. To achieve this, you need to select the vertex in question. A right-click will then reveal an option named <strong class="bold">Debug this vertex</strong>. Selecting this option will lead you to the vertex shader that was used in rendering your mesh. Note that the shader’s source code will only be available if the SPIR-V has been generated with debug symbols.</li>
</ol>
<div><div><img alt="Figure 9.2 – RenderDoc Texture Viewer" src="img/B18491_09_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – RenderDoc Texture Viewer</p>
<ol>
<li value="4">The <strong class="bold">Pipeline State</strong> tab is a crucial component in the RenderDoc UI. It offers an extensive view of the various stages, and their states, involved in the graphics pipeline, serving as a powerful tool for analyzing and debugging your rendering process. In the vertex shader stage, you can inspect the operations applied to each vertex. This includes transformations to position vertices in the correct 3D space, as well as <a id="_idIndexMarker671"/>calculations to determine vertex colors or texture coordinates. You can also select V<strong class="bold">iew </strong>S<strong class="bold">hader</strong> to inspect the shader source code used during this draw call. Moving on to the fragment shader stage, the <strong class="bold">Pipeline State</strong> tab allows you to scrutinize how each fragment (potential pixel) is processed. This includes operations such as determining its final color based on lighting, texture, and/or other factors. Debugging this stage can help you resolve issues related to color computations, texture mapping, and more.</li>
<li>To debug a specific fragment, you’ll need to select a pixel in <strong class="bold">Texture Viewer</strong>. You can do this by clicking on the pixel you’re interested in. The values of this pixel represent the output of the fragment shader for that specific pixel. After selecting a pixel, you can debug the fragment shader that produced it. To do this, right-click on the pixel and select the <strong class="bold">Debug</strong> button shown inside the <strong class="bold">Pixel Context</strong> window. This will open a new <strong class="bold">Shader Viewer</strong> tab, where you can step through the shader code line by line. For each line, you can inspect the values of your variables and see how they change as the shader executes.</li>
</ol>
<p>The compute shader stage is used for performing general-purpose computations on the GPU. Here, you can inspect and debug the operations that aren’t directly related to rendering, such as physics simulations or culling. In the next step, we will demonstrate using the executable from <a href="B18491_03.xhtml#_idTextAnchor217"><em class="italic">Chapter 3</em></a>, <em class="italic">Implementing GPU-Driven Rendering</em>, in the <em class="italic">Frustum culling using compute </em><em class="italic">shaders</em> recipe.</p>
<ol>
<li>To understand how to debug the compute shader, we will first need to launch <code>Chapter03_GPU_Culling.exe</code> from RenderDoc. Once the application is up, we will take a capture. Next, navigate to the <code>vkCmdDispatch</code> call. Selecting this call in <strong class="bold">Event Browser</strong> will display the associated pipeline used by this call in the <strong class="bold">Pipeline State</strong> tab, as demonstrated in <em class="italic">Figure 9</em><em class="italic">.3</em>:</li>
</ol>
<div><div><img alt="Figure 9.3 – Compute shader as seen in RenderDoc" src="img/B18491_09_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Compute shader as seen in RenderDoc</p>
<ol>
<li value="2">When it comes to culling, we launch as many threads as there are meshes. Then, on the GPU, we’re simply discarding any mesh that isn’t visible in the frustum. Let’s assume <a id="_idIndexMarker672"/>we’re interested in understanding why mesh number 5 is outside the frustum. To debug this, click the <strong class="bold">Debug</strong> button and specify the thread ID in the <strong class="bold">Debug Compute Shader</strong> window. This window allows you to specify either a global thread ID or a thread group and a local thread ID. In our case, to debug mesh number 5, you would enter 5 in the global X dimension (in the <strong class="bold">Dispatch Thread ID</strong> section). Once you click the <strong class="bold">Debug</strong> button, a new window containing the shader source code will be launched. Here, you can inspect and debug the compute shader, enabling you to understand why a particular mesh was discarded. The process is demonstrated in <em class="italic">Figure 9</em><em class="italic">.4</em>:</li>
</ol>
<div><div><img alt="Figure 9.4 – Debugging a compute shader in RenderDoc" src="img/B18491_09_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Debugging a compute shader in RenderDoc</p>
<p>This recipe is <a id="_idIndexMarker673"/>a very brief introduction to <em class="italic">one</em> frame debugging tool. Keep in mind other tools exist and operate in different ways.</p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor339"/>See also</h2>
<p>For a comprehensive understanding of how to utilize RenderDoc, we highly recommend viewing the following video tutorials. These will provide you with detailed insights into its usage:</p>
<ul>
<li><a href="https://youtu.be/7eznPe3TyAY">https://youtu.be/7eznPe3TyAY</a></li>
<li><a href="https://youtu.be/EMFG5wmng-M">https://youtu.be/EMFG5wmng-M</a></li>
<li><a href="https://renderdoc.org/docs/getting_started/quick_start.html">https://renderdoc.org/docs/getting_started/quick_start.html</a></li>
</ul>
<h1 id="_idParaDest-303"><a id="_idTextAnchor340"/>Naming Vulkan objects for easy debugging</h1>
<p>Using Vulkan <a id="_idIndexMarker674"/>means you need to create and manage many Vulkan objects. By default, those objects are identified by their handle, a numerical ID. Although numerical IDs are easy to maintain from an application perspective, they are meaningless to humans. Consider the following error message, provided by the validation layer:</p>
<pre class="source-code">
VUID-VkImageViewCreateInfo-imageViewType-04974 ] Object 0: handle = 0xcb3ee80000000007, type = VK_OBJECT_TYPE_IMAGE; | MessageID = 0xc120e150 | vkCreateImageView(): Using pCreateInfo-&gt;viewType VK_IMAGE_VIEW_TYPE_2D and the subresourceRange.layerCount VK_REMAINING_ARRAY_LAYERS=(2) and must 1 (try looking into VK_IMAGE_VIEW_TYPE_*_ARRAY). The Vulkan spec states: If viewType is VK_IMAGE_VIEW_TYPE_1D, VK_IMAGE_VIEW_TYPE_2D, or VK_IMAGE_VIEW_TYPE_3D; and subresourceRange.layerCount is VK_REMAINING_ARRAY_LAYERS, then the remaining number of layers must be 1</pre> <p>The preceding <a id="_idIndexMarker675"/>message is useful, but finding which image has been created with the wrong number of layers is hard.</p>
<p>If, on the other hand, we give that image a name, the validation layer message becomes the following:</p>
<pre class="source-code">
VUID-VkImageViewCreateInfo-imageViewType-04974 ] Object 0: handle = 0xcb3ee80000000007, <strong class="bold">name = Image: Swapchain image 0</strong>, type = VK_OBJECT_TYPE_IMAGE; | MessageID = 0xc120e150 | vkCreateImageView(): Using pCreateInfo-&gt;viewType VK_IMAGE_VIEW_TYPE_2D and the subresourceRange.layerCount VK_REMAINING_ARRAY_LAYERS=(2) and must 1 (try looking into VK_IMAGE_VIEW_TYPE_*_ARRAY). The Vulkan spec states: If viewType is VK_IMAGE_VIEW_TYPE_1D, VK_IMAGE_VIEW_TYPE_2D, or VK_IMAGE_VIEW_TYPE_3D; and subresourceRange.layerCount is VK_REMAINING_ARRAY_LAYERS, then the remaining number of layers must be 1</pre> <p>Note that the name of the object is now part of the error message. That makes it much easier to know where to look in your code and fix the error.</p>
<p>In this recipe, you will learn how to use a Vulkan extension to give human-readable or meaningful names to all Vulkan objects.</p>
<h2 id="_idParaDest-304"><a id="_idTextAnchor341"/>Getting ready</h2>
<p>To be able to assign names to a Vulkan object, you first need to enable the <code>VK_EXT_debug_utils</code> instance extension. This extension’s name needs to be provided <a id="_idIndexMarker676"/>during the creation of the Vulkan instance as either a string, <code>VK_EXT_debug_utils</code>, or using the <code>VK_EXT_DEBUG_UTILS_EXTENSION_NAME</code> macro. The following code snippet initializes a Vulkan instance with debug utilities enabled:</p>
<pre class="source-code">
VkInstance instance_ = VK_NULL_HANDLE;
std::vector&lt;const char *&gt; instanceExtensions = {
  <strong class="bold">VK_EXT_DEBUG_UTILS_EXTENSION_NAME</strong>};
const VkInstanceCreateInfo instanceInfo = {
  .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
  ...
  .enabledExtensionCount = static_cast&lt;uint32_t&gt;(
    instanceExtensions.size()),
  .ppEnabledExtensionNames =
    instanceExtensions.data(),
};
VK_CHECK(vkCreateInstance(&amp;instanceInfo, nullptr,
                          &amp;instance_));</pre> <p>Now you are ready to start naming your Vulkan object. Let’s see how in the next section.</p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor342"/>How to do it…</h2>
<p>Once the extension has been enabled, here are the steps to name your objects:</p>
<ol>
<li>Once the extension has been enabled, you may add a name to any Vulkan object, given its handle, by calling the <code>vkSetDebugUtilsObjectNameEXT</code> function:<pre class="source-code">
VkDevice device_; // Valid Vulkan device
VkObjectType type = VK_OBJECT_TYPE_UNKNOWN;
std::string name; // human readable name
const VkDebugUtilsObjectNameInfoEXT
  objectNameInfo = {
    .sType =
      VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
    .objectType = type,
    .objectHandle =
      reinterpret_cast&lt;uint64_t&gt;(<strong class="bold">handle</strong>),
    .pObjectName = name.c_str(),
};
VK_CHECK(vkSetDebugUtilsObjectNameEXT(
  device_, &amp;objectNameInfo));</pre><p class="list-inset">The object type (<code>type</code>) is one of the values of the <code>VkObject</code> enumeration and must match <a id="_idIndexMarker677"/>the object’s type (<code>VK_OBJECT_TYPE_IMAGE</code> for a Vulkan Image, for example). The handle is the object’s handle, which needs to be cast to type <code>uint64_t</code>.</p></li> <li>This function is only available if the extension is also available, so make sure to guard it in an <code>#ifdef</code> block and check whether the extension has been enabled for the instance.<p class="list-inset">In the repository, the <code>VulkanCore::Context:: setVkObjectname</code> method wraps this function in a templated class and does the casting for you. Also, it’s worth mentioning that names aren’t only displayed on validation error messages. They also appear in frame capture and debugging tools.</p></li>
</ol>
<div><div><img alt="Figure 9.5 - Examples of how object names appear in RenderDoc" src="img/B18491_09_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 - Examples of how object names appear in RenderDoc</p>
<p><em class="italic">Figure 9</em><em class="italic">.5</em> shows how <a id="_idIndexMarker678"/>object names are displayed in RenderDoc. In the screenshot, one of the swapchain images is named <strong class="bold">Image: Swapchain image 1</strong>. The depth buffer is named <strong class="bold">Image: </strong><strong class="bold">depth buffer</strong>.</p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor343"/>Printing values from shaders in Vulkan</h1>
<p>As graphics programmers, we must all agree that debugging shaders is one of the most frustrating <a id="_idIndexMarker679"/>aspects of our jobs. Even though some frame capture software provides shader debugging, it may still be difficult to find the exact pixel you would like to debug, or you may need another piece of information about a set of pixels instead of just inspecting them one by one.</p>
<p>Thankfully, Vulkan provides a way to print values directly from shaders. The information can be inspected directly on RenderDoc, for example, or retrieved from the validation error messages (please refer to the <em class="italic">Retrieving debugging information from shaders</em> recipe for more details on how to do this).</p>
<p>In this recipe, you will learn how to print values from your shader code using a simple function that is like <code>printf</code>.</p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor344"/>Getting ready</h2>
<p>To utilize the functionality of printing values from shaders, it’s a prerequisite to enable the <code>VK_KHR_shader_non_semantic_info</code> device extension. This can be achieved by <a id="_idIndexMarker680"/>adding either the <code>VK_KHR_shader_non_semantic_info</code> string or the <code>VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME</code> macro to the <code>VkDeviceCreateInfo</code> structure during the creation of a Vulkan device. This process is demonstrated in the following code snippet:</p>
<pre class="source-code">
VkPhysicalDevice physicalDevice; // Valid Vulkan
                                 // Physical Device
const std::vector&lt;const char *&gt; deviceExtensions =
  {<strong class="bold">VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME</strong>};
const VkDeviceCreateInfo dci = {
  .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
  ...
  .enabledExtensionCount = static_cast&lt;uint32_t&gt;(
    deviceExtensions.size()),
  .ppEnabledExtensionNames = deviceExtensions.data(),
};
VK_CHECK(vkCreateDevice(physicalDevice_, &amp;dci,
  nullptr, &amp;device_));</pre> <p>Now that the extension has been enabled, let’s see what the steps are to print values directly from shaders.</p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor345"/>How to do it…</h2>
<p>Once the <a id="_idIndexMarker681"/>extension has been enabled, you will also need to add a GLSL extension to your shaders:</p>
<ol>
<li>Enable the <code>GL_EXT_debug_printf</code> extension in your shader code:<pre class="source-code">
#version 460
<code>debugPrintfEXT</code> in your shader code whenever you would like to print values. In the following code snippet, we are printing the value of <code>gl_VertexIndex</code>:<pre class="source-code">
debugPrintfEXT("gl_VertexIndex = %i", gl_VertexIndex);</pre></li> <li>The function provides specifiers for vector values as well. Here’s an example of a call that prints all components of a <code>vec3</code> variable:<pre class="source-code">
vec3 position;
debugPrintfEXT("%2.3v3f", position);</pre><p class="list-inset">The preceding function call prints the <code>x</code>, <code>y</code>, and <code>z</code> components of <code>position</code> as a floating-point value with 3 decimals.</p></li> </ol>
<p>Here’s the abridged version of the vertex shader used in <a href="B18491_01.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a>, <em class="italic">Vulkan Core Concepts</em>, with the added <code>debugPrintfEXT</code> call to print the <code>gl_VertexIndex</code> value:</p>
<pre class="source-code">
#version 460
#extension GL_EXT_debug_printf: enable
layout(location = 0) out vec4 outColor;
vec2 positions[3] = vec2[]( ... );
vec3 colors[3] = vec3[]( ... );
void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    debugPrintfEXT(«gl_VertexIndex = %i», gl_VertexIndex);
    outColor = vec4(colors[gl_VertexIndex], 1.0);
}</pre> <p><em class="italic">Figure 9</em><em class="italic">.6</em> shows how <a id="_idIndexMarker682"/>the printed values can be inspected in RenderDoc:</p>
<div><div><img alt="Figure 9.6 – debugPrintfEXT values visible in RenderDoc" src="img/B18491_09_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – debugPrintfEXT values visible in RenderDoc</p>
<h1 id="_idParaDest-309"><a id="_idTextAnchor346"/>Intercepting validation layer messages</h1>
<p>In some circumstances, validation errors are so plentiful that it becomes impossible to know where <a id="_idIndexMarker683"/>the cause of the problem is. For that reason, it would be ideal to interrupt the execution of your program as soon as an error is detected, especially when debugging your application. The debug utility extension (<code>VK_EXT_debug_utils</code>) allows you to install a callback function that is invoked whenever an error is detected.</p>
<p>In this recipe, you will learn how to install a debug callback to intercept error messages emitted by the validation layer and make your debugging sessions more productive.</p>
<h2 id="_idParaDest-310"><a id="_idTextAnchor347"/>Getting ready</h2>
<p>To be able to set a callback whenever an error occurs, you need to enable the <code>VK_EXT_debug_utils</code> extension. Please refer to the <em class="italic">Getting ready</em> section of the <em class="italic">Naming Vulkan objects for easier debugging</em> recipe to learn how to enable this extension when creating a Vulkan instance.</p>
<h2 id="_idParaDest-311"><a id="_idTextAnchor348"/>How to do it…</h2>
<p>Before installing and using the callback, you need to define one. After that, and once the extension has been enabled and a Vulkan instance object has been created, you need to install the callback using a special Vulkan function:</p>
<ol>
<li>Define a callback function with the following signature:<pre class="source-code">
typedef VkBool32(
  VKAPI_PTR
     PFN_vkDebugUtilsMessengerCallbackEXT)(
  VkDebugUtilsMessageSeverityFlagBitsEXT
    messageSeverity,
  VkDebugUtilsMessageTypeFlagsEXT messageTypes,
  const VkDebugUtilsMessengerCallbackDataEXT
     pCallbackData,
  void *pUserData);</pre></li> <li>Here’s <a id="_idIndexMarker684"/>the function used as a callback provided in the repository:<pre class="source-code">
VkBool32 VKAPI_PTR debugMessengerCallback(
  VkDebugUtilsMessageSeverityFlagBitsEXT
    messageSeverity,
  VkDebugUtilsMessageTypeFlagsEXT messageTypes,
  const VkDebugUtilsMessengerCallbackDataEXT
     pCallbackData,
  void *pUserData) {
  if (
    messageSeverity &amp;
    (VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT)) {
    LOGE("debugMessengerCallback : MessageCode "
         "is %s &amp; Message is %s",
         pCallbackData-&gt;pMessageIdName,
         pCallbackData-&gt;pMessage);
#if defined(_WIN32)
    __debugbreak();
#else
    raise(SIGTRAP);
#endif
  } else if (
    messageSeverity &amp;
    (VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT)) {
    LOGW("debugMessengerCallback : MessageCode "
         "is %s &amp; Message is %s",
         pCallbackData-&gt;pMessageIdName,
         pCallbackData-&gt;pMessage);
  } else {
    LOGI("debugMessengerCallback : MessageCode "
         "is %s &amp; Message is %s",
         pCallbackData-&gt;pMessageIdName,
         pCallbackData-&gt;pMessage);
  }
  return VK_FALSE;
}</pre><p class="list-inset">Your <a id="_idIndexMarker685"/>callback can decide how to treat the message, if at all, based on its type (general message, validation message, performance message) or its severity (verbose, info, warning, or error). The <code>pCallbackData</code> parameter (of type <code>VkDebugUtilsMessengerCallbackDataEXT</code>) provides a plethora of different information you can use, while the <code>pUserData</code> parameter may contain your own data, which is provided when installing the callback.</p></li> <li>Install the callback once you have a valid Vulkan instance by creating an instance of the <code>VkDebugUtilsMessengerCreateInfoEXT</code> structure:<pre class="source-code">
VkInstance instance; // Valid Vulkan Instance
VkDebugUtilsMessengerEXT messenger =
  VK_NULL_HANDLE;
const VkDebugUtilsMessengerCreateInfoEXT messengerInfo = {
  .sType =
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
  .flags = 0,
  .messageSeverity =
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
  .messageType =
    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
  .pfnUserCallback = &amp;debugMessengerCallback,
  .pUserData = nullptr,
};
VK_CHECK(vkCreateDebugUtilsMessengerEXT(
  instance, &amp;messengerInfo, nullptr, &amp;messenger));</pre></li> <li>Make sure <a id="_idIndexMarker686"/>to destroy the messenger once you are done with your Vulkan instance. This is necessary because, in Vulkan, any resources created need to be explicitly destroyed when they’re no longer needed to avoid memory leaks and to free up system resources:<pre class="source-code">
vkDestroyDebugUtilsMessengerEXT(instance_,
                                messenger_,
                                nullptr);</pre></li> </ol>
<p>The debug callback is very useful and should always be used. Make sure to have one as soon as possible and know how to use it.</p>
<h1 id="_idParaDest-312"><a id="_idTextAnchor349"/>Retrieving debug information from shaders</h1>
<p>One of the most difficult tasks in graphics programming is writing tests. Be those smoke, integration, end-to-end, or unit tests, how do you ensure that the output of your engine is really <a id="_idIndexMarker687"/>what you would expect? Except for simple tests, screenshot-like types of tests are prone to several problems. One particularly difficult problem is testing shader code – since you don’t usually have access to the hardware, testing shader code is very painful.</p>
<p>Thankfully, Vulkan has a mechanism that allows you to capture the value output from shaders with the <code>debugPrintfEXT</code> function directly from the validation layer. This mechanism isn’t <a id="_idIndexMarker688"/>new and could be enabled using the <code>Vulkan SDK 1.3.275</code>, the <code>VK_EXT_layer_settings</code> instance extension allows you to enable this mechanism directly from your application without manually having to edit any other configuration.</p>
<p>In this recipe, you will learn how to enable this feature and retrieve the output of <code>debugPrintfEXT</code> calls from shaders.</p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor350"/>Getting ready</h2>
<p>For this recipe, you will need <code>Vulkan SDK version 1.3.275</code>. Although all the code in the repository was tested with <code>SDK version 1.3.265</code>, the <code>VK_EXT_layer_settings</code> extension was only available with <code>SDK 1.3.275</code>.</p>
<h2 id="_idParaDest-314"><a id="_idTextAnchor351"/>How to do it…</h2>
<p>Enabling this feature is easy and requires only a few steps. Let’s get to them:</p>
<ol>
<li>The <code>VK_EXT_layer_settings</code> extension introduces a way for you to change individual layer settings. Each setting must be set using an instance of the <code>VKLayerSettingEXT</code> structure, defined as follows:<pre class="source-code">
typedef struct VkLayerSettingEXT {
  const char *pLayerName;
  const char *pSettingName;
  VkLayerSettingTypeEXT type;
  uint32_t valueCount;
  const void *pValues;
} VkLayerSettingEXT;</pre></li> <li>To enable the feature that allows you to receive output from shaders, you need to enable a few settings of the <code>VK_LAYER_KHRONOS_validation</code> layer. Let’s start <a id="_idIndexMarker689"/>by creating a constant with the layer name for which we’ll change the settings:<pre class="source-code">
const std::string layer_name =
  "VK_LAYER_KHRONOS_validation";</pre></li> <li>Now we create arrays to store the values of the settings we’ll use:<pre class="source-code">
const std::array&lt;const char *, 1&gt;
  settin<a id="_idTextAnchor352"/>g_debug_action = {"VK_DBG_LAYER_ACTION_BREAK"};
const std::array&lt;const char *, 1&gt;
  setting_gpu_based_action = {
    "GPU_BASED_DEBUG_PRINTF"};
const std::array&lt;VkBool32, 1&gt;
  setting_printf_to_stdout = {VK_TRUE};</pre><p class="list-inset">The <code>debug_action</code> setting was changed to <code>VK_DBG_LAYER_ACTION_BREAK</code> so that the callback is called whenever there’s a new value from <code>debugPrintfEXT</code>. The <code>validate_gpu_based</code> setting is set to receive the <code>debugPrintEXT</code> values (<code>GPU_BASED_DEBUG_PRINTF</code>) and the <code>printf_to_stdout</code> setting (set to <code>VK_FALSE</code>) specifies we don’t want those values to go to <code>stdout</code>; we want to receive them in the callback.</p></li> <li>We create instances of the <code>VkLayerSettingEXT</code> structure for each setting we would <a id="_idIndexMarker690"/>like to change. Here, we are changing the following settings of the <code>layer_name</code> layer: <code>debug_action</code>, <code>validate_gpu_based</code>, and <code>printf_to_stdout</code>:<pre class="source-code">
const array&lt;VkLayerSettingEXT, 3&gt; settings = {
  VkLayerSettingEXT{
    .pLayerName = layer_name.c_str(),
    .pSettingName = <strong class="bold">"debug_action"</strong>,
    .type = VK_LAYER_SETTING_TYPE_STRING_EXT,
    .valueCount = 1,
    .pValues = setting_debug_action.data(),
  },
  VkLayerSettingEXT{
    .pLayerName = layer_name.c_str(),
    .pSettingName = <strong class="bold">"validate_gpu_based"</strong>,
    .type = VK_LAYER_SETTING_TYPE_STRING_EXT,
    .valueCount = 1,
    .pValues = setting_gpu_based_action.data(),
  },
  VkLayerSettingEXT{
    .pLayerName = layer_name.c_str(),
    .pSettingName = <strong class="bold">"printf_to_stdout"</strong>,
    .type = VK_LAYER_SETTING_TYPE_BOOL32_EXT,
    .valueCount = 1,
    .pValues = setting_printf_to_stdout.data(),
  },
};</pre></li> <li>Then we add those settings to an instance of the <code>VkLayerSettingsCreateInfoEXT</code> structure:<pre class="source-code">
const VkLayerSettingsCreateInfoEXT
  layer_settings_ci = {
    .sType =
      VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT,
    .pNext = nullptr,
    .settingCount =
      static_cast&lt;uint32_t&gt;(settings.size()),
    .pSettings = settings.data(),
};</pre></li> <li>Finally, we <a id="_idIndexMarker691"/>add this instance to the <code>pNext</code> chain of the <code>VkInstanceCreateInfo</code> structure used to create the Vulkan instance:<pre class="source-code">
const VkInstanceCreateInfo instanceInfo = {
  .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
  .pNext = &amp;layer_settings_ci,
  ...
};
VK_CHECK(vkCreateInstance(&amp;instanceInfo, nullptr,
                          &amp;instance_));</pre></li> </ol>
<p>When enabled for <a href="B18491_01.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a>, <em class="italic">Vulkan Core Concepts,</em> code in the repository, the message received by the callback looks something like this:</p>
<pre class="source-code">
Validation Information: [ WARNING-DEBUG-PRINTF ] | MessageID = 0x76589099 | vkQueueSubmit():  gl_VertexIndex = 1</pre> <p>It is possible to enable a verbose output, in which case the preceding message would look like this:</p>
<pre class="source-code">
Validation Information: [ WARNING-DEBUG-PRINTF ] Object 0: handle = 0x26e6bf17bd0, type = VK_OBJECT_TYPE_QUEUE; | MessageID = 0x76589099 | vkQueueSubmit():  Command buffer (Command buffer:  0)(0x26e6c6613b0). Draw Index 0. Pipeline (Graphics pipeline: )(0x26e78d000d0). Shader Module (Shader Module: )(0x26e73b68450). Shader Instruction Index = 92.  gl_VertexIndex = 1 Debug shader printf message generated at line 21.
21:     outColor = vec4(colors[gl_VertexIndex], 1.0);</pre> <p>Hopefully, this <a id="_idIndexMarker692"/>feature will help you write tests for obscure corners of your code that weren’t even possible to test before.</p>
<h1 id="_idParaDest-315"><a id="_idTextAnchor353"/>Measuring performance in Vulkan with timestamp queries</h1>
<p>Measuring <a id="_idIndexMarker693"/>the performance <a id="_idIndexMarker694"/>of CPU and GPU workloads side by side is invaluable. The <strong class="bold">Tracy profiler</strong> allows you to do just that in a <a id="_idIndexMarker695"/>cross-platform way with minimal intrusion. And it’s easy to use, all within a small C++ library.</p>
<p>In this recipe, you will learn how to integrate Tracy Profiler into your app and instrument it to collect GPU performance information.</p>
<h2 id="_idParaDest-316"><a id="_idTextAnchor354"/>Getting ready</h2>
<p>The first thing to do is to download Tracy from <a href="https://github.com/wolfpld/tracy">https://github.com/wolfpld/tracy</a> and include it in your project. You should also download the Tracy client/server to collect and inspect the data.</p>
<h2 id="_idParaDest-317"><a id="_idTextAnchor355"/>How to do it…</h2>
<p>Instrumenting your code to use with Tracy is easy and requires only a few steps. To be able to collect data about the GPU performance, you will need a Tracy/Vulkan context along with a dedicated command buffer for it to calibrate the timestamps. After that, instrumenting your code is straightforward:</p>
<ol>
<li>First, include the Tracy header file in your application:<pre class="source-code">
#include &lt;tracy/Tracy.hpp&gt;
#include &lt;tracy/TracyVulkan.hpp&gt;</pre></li> <li>Second, you need a Tracy/Vulkan context that can be created by using a macro provided by the Tracy library. There are two options: one that creates a context with <a id="_idIndexMarker696"/>calibrated timestamps and one that creates a context without calibrated timestamps. Vulkan <a id="_idIndexMarker697"/>provides ways to correlate the time an operation happened on timelines of different time domains. Without calibration, Tracy can only guess when an operation on the device happened in relation to the ones that took place on the CPU. Here’s how you can initialize the context that better suits your needs:<pre class="source-code">
VkPhysicalDevice physicalDevice;
VkDevice device;
int graphicsQueueIndex;
VkCommandBuffer commandBuffer;
#if defined(VK_EXT_calibrated_timestamps)
TracyVkCtx tracyCtx_ = TracyVkContextCalibrated(
  physicalDevice, device, graphicsQueueIndex,
  commandBuffer,
  vkGetPhysicalDeviceCalibrateableTimeDomainsKHR,
  vkGetCalibratedTimestampsKHR);
#else
TracyVkCtx tracyCtx_ = TracyVkContext(
  physicalDevice, device, graphicsQueueIndex,
  commandBuffer);
#endif</pre><p class="list-inset">The command buffer used here is a dedicated one and it should not be shared with any other operations.</p></li> <li>Collecting <a id="_idIndexMarker698"/>GPU information <a id="_idIndexMarker699"/>is now easy. All you must do is use one of the macros provided by Tracy, such as the following:<pre class="source-code">
TracyVkZone(tracyCtx_, commandBuffer, "Model upload");</pre><p class="list-inset">Note that the <code>commandBuffer</code> variable used in this macro is the command buffer you wish to capture data from, the one being recorded. This command buffer is <em class="italic">different</em> than the one provided during the construction of the Tracy context.</p><p class="list-inset">This macro should be added whenever you would like to instrument your GPU execution. For example, you might want to add this macro to a scope where you issue the draw call (such as <code>vkCmdDraw</code>). You will then get information about that command being processed in the GPU. In the repository, you can find examples of how this macro is used.</p></li> <li>Tracy also provides macros that allow you to identify the zone with a color or name, such as <code>TracyVkNamedZone</code>, <code>TracyVkNamedZoneC</code>, and so on.<p class="list-inset">Occasionally, you need to tell Tracy to collect the timestamps from the command buffer by calling <code>TracyVkCollect</code>. This macro can be called at the end of a frame:</p><pre class="source-code">
TracyVkCollect(tracyCtx_, commandBuffer);</pre></li> <li>After exiting the render loop, and before shutting down your application, you need to destroy the Tracy context by calling <code>TracyVkDestroy</code>:<pre class="source-code">
TracyVkDestroy(tracyCtx_);</pre></li> <li>The last step is to build your project with <code>TRACY_ENABLE</code> defined. If using CMake, you can do this by adding the following parameters when generating the project’s build files:<pre class="source-code">
-DTRACY_ENABLE=1</pre><p class="list-inset">Now <a id="_idIndexMarker700"/>all you must <a id="_idIndexMarker701"/>do is compile your code and run it. Make sure to start the Tracy client beforehand and start a connection. The Tracy client will automatically detect your application and start collecting data once it starts.</p><p class="list-inset">If you instrument your code to collect CPU data using Tracy, which you can do using macros such as <code>ZoneScoped</code>, <code>ZoneScopedC</code>, and so on, you will see the results side by side after collection. <em class="italic">Figure 9</em><em class="italic">.7</em> shows the result of capturing one of the executables from <a href="B18491_02.xhtml#_idTextAnchor126"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Modern Vulkan</em>. Note the CPU and GPU zones in the screenshot.</p><div><img alt="Figure 9.7 – Tracy profiler capture with GPU and CPU information side by side" src="img/B18491_09_07.jpg"/></div></li> </ol>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Tracy profiler capture with GPU and CPU information side by side</p>
<p>Tracy is <a id="_idIndexMarker702"/>a very simple-to-use <a id="_idIndexMarker703"/>library that provides invaluable information about your application. It provides nanosecond resolution along with CPU and GPU performance tracking and is cross-platform. If you don’t already have other performance-measuring libraries or facilities in your code base, Tracy can get you up and running in no time.</p>
</div>
</body></html>