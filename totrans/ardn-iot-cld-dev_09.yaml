- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Project 4 – Collecting Data from the Soil and Environment for Smart Farming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to **smart agriculture**. Our population is growing
    rapidly and food consumption is directly proportional to population. Fortunately,
    we have the latest tools and technologies that help us to boost our crop yields
    by using fewer natural resources. In smart agriculture, there are different parameters
    to monitor, but we will only focus on soil moisture and soil temperature as both
    are linked to water consumption; access to clean water is another issue with the
    rapid growth of industries and population.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will practically explore smart agriculture by monitoring
    the soil moisture level, soil temperature, and outdoor temperature and humidity,
    which will help us to understand how our soil responds to changes in the outside
    environment and for how many days the soil retains moisture after watering the
    crop. Our smart agriculture device will send all the data to the Arduino IoT Cloud,
    where we will monitor it in real time and make decisions that will help us to
    use controlled watering for crops, which will save water and improve the soil
    quality.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to use open source and cost-effective sensors
    to carry out experiments in labs as well as in the field. For the development
    board, we are using the **ESP32** and **ADS1115** **analog-to-digital converter**
    (**ADC**) modules in combination with four capacitive soil moisture and four **DS18B20**
    sensors for soil temperature monitoring, as well as a **DHT22** module for outdoor
    temperature and humidity monitoring. This project will help you optimize your
    crops with precision farming, tunnel farming, and drip irrigation, as well as
    be useful for home gardening.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Smart farming with IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential hardware for your agri-tech project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecting your agriculture IoT system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perfecting sensor calibration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up things, networks, and cloud variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating web and mobile dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following hardware components are required to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: ESP32 development board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ADS1115 ADC module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DHT22 module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soil moisture sensor x4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DS18B20 x4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PCB (link is available in the *PCB design and the assembly of hardware* *components*
    section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.54 mm three-pin connectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Female headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper cables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For coding, we will use the Arduino Web Editor, which includes a large collection
    of development board and sensor libraries, and we will use the Arduino IoT Cloud
    for Thing and dashboard setup. To develop hardware and sensor designs, we need
    the Fritzing desktop software.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter code is available in the book’s official GitHub repository, or you
    can directly download the code at [https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers](https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers).
  prefs: []
  type: TYPE_NORMAL
- en: Smart farming with IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Internet of Things** (**IoT**) technology is used in smart agriculture to
    optimize farm operations, improve crop yields, reduce waste, and increase profits.
    Here are some examples of how IoT is used in smart agriculture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated irrigation**: IoT sensors can be used to monitor soil moisture
    levels and weather conditions to determine when to irrigate crops. Automated irrigation
    systems can then be triggered to deliver the right amount of water to crops, which
    can reduce water wastage and increase crop yields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Livestock management**: IoT sensors can be used to monitor the health and
    behavior of livestock, such as their movement, feeding habits, and sleeping patterns.
    This data can be used to detect early signs of illness, track breeding cycles,
    and ensure optimal conditions for the livestock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crop monitoring**: IoT sensors can be used to monitor crop growth, detect
    pests and diseases, and identify areas that need attention. This data can be used
    to make timely interventions and improve crop yields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Precision farming**: IoT sensors can be used to gather data on individual
    plants or crops, enabling farmers to optimize their use of resources, such as
    water, fertilizers, and pesticides. This can help reduce waste, improve yields,
    and save money.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart harvesting**: IoT sensors can be used to monitor crop ripeness and
    determine the optimal time for harvesting. This can help reduce waste and improve
    the quality of harvested crops.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weather monitoring**: IoT sensors can be used to monitor weather conditions
    such as temperature, humidity, and rainfall. This data can be used to make informed
    decisions about planting, harvesting, and other farming operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, IoT technology is transforming the way that agriculture is practiced.
    By using real-time data and analytics, farmers can make better decisions and achieve
    better outcomes, ultimately leading to a more sustainable food supply for the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed smart agriculture and different terms and
    techniques that are common in smart agriculture. In the next section, we will
    discuss the hardware components that we are going to use in this chapter’s project.
  prefs: []
  type: TYPE_NORMAL
- en: Essential hardware for your agri-tech project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we have chosen open source and easily available hardware components.
    To demonstrate how the Arduino IoT Cloud works with ESP32 series development boards,
    we have chosen the following hardware. In the ESP32 series, we have a wide selection
    of development boards that vary in size and number of pins. In this chapter, we
    are using **ESP32-DevKit V1** as it’s very compact and smaller in size compared
    to other boards. It is, of course, also cheaper and provides a 5V pin, which is
    also known as VIN, as well as having the option of a 3.3V pin. The following figure
    shows the **pin layout** (**pinout**) diagram of ESP32 V1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: ESP32-DevKit V1](img/B19752_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: ESP32-DevKit V1'
  prefs: []
  type: TYPE_NORMAL
- en: ESP32 provides multiple pins for digital and analog input/output. If you want
    to use multiple analog sensors, then ADCs are available. One of the most well-known
    ADCs is the ADS1115/ADS1015 module, which provides four analog pins and is good
    when you need to add additional analog pins to your project. In this project,
    four analog pins are required to fetch soil moisture sensor values; this board
    has enough analog pins but I am using ADS1115 to demonstrate how we can use the
    ADC module to add extra analog pins to our projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the current project, we need five digital pins for the DHT22 module and DS18B20
    temperature probe and four analog pins for the capacitive soil moisture sensors.
    One of the good features of this development board is that it provides a 5V power
    pin, which is not available in most ESP32 series development boards.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are using the DHT22 module to sense outdoor temperature and humidity,
    but you can also use the DHT11 sensor, depending on your requirements. If specifically
    talking about features, then the DHT22 provides a broader range of sensors compared
    to the DHT11, but it costs more. The following figure shows the DHT22 module,
    and we have labeled the pins for better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: DHT22 and DHT11 module pinout](img/B19752_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: DHT22 and DHT11 module pinout'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows the pinout of the DHT22/DHT11 sensor module; the
    complete pin connection configuration can be seen in *Table 9.3*. The first pin
    (**VCC**) works with both 3.3V and 5V. The second pin is the **DATA** pin, which
    connects with any digital pin of ESP32-DevKit V1\. The third pin is the **GND**
    pin, which connects with the GND pin of the development board.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, the following table explains all the specification differences
    between the DHT22 and DHT11\. The most notable things are the sensing range and
    sensing period:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **DHT22** | **DHT11** |'
  prefs: []
  type: TYPE_TB
- en: '| Power supply | 3.3 to 5V |'
  prefs: []
  type: TYPE_TB
- en: '| Output signal | Digital signal via a single bus |'
  prefs: []
  type: TYPE_TB
- en: '| Sensing element | Polymer capacitor |'
  prefs: []
  type: TYPE_TB
- en: '| Sensing range | Humidity 0-100% Relative Humidity (RH)Temperature 40-0°C
    | Humidity 20-90% RHTemperature 0-50°C |'
  prefs: []
  type: TYPE_TB
- en: '| Accuracy | Humidity: +-2% RH (max +-5% RH)Temperature: <+-0.5°C | Humidity:
    1% RH (max 5% RH)Temperature: <2°C |'
  prefs: []
  type: TYPE_TB
- en: '| Sensing period | Average 2 s | Average 1 s |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.1: DHT22 and DHT11 sensor specification'
  prefs: []
  type: TYPE_NORMAL
- en: The main sensor of the project is a capacitive soil moisture sensor and it is
    used to monitor the soil moisture of a specific area. It is a low-cost soil moisture
    monitoring sensor and is rustproof due to its use of PCB (PCB sheets use plastic
    and paint, making them rustproof). It senses the soil moisture by passing a small
    amount of electric current into the soil moisture sensors, as shown in *Figure
    9**.3*, and determining the soil moisture based on the returned current. If the
    sensor receives a higher current, then it means the moisture is high; if it receives
    a low current, then there is little or no moisture content in the soil.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Capacitive soil moisture sensor pinout](img/B19752_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Capacitive soil moisture sensor pinout'
  prefs: []
  type: TYPE_NORMAL
- en: 'The soil moisture sensor consists of three pins: `map()` method under the `FetchSoilMoisture()`
    method. The complete code is available on GitHub in the folder for this chapter.
    The sensor operates with both 5V power as well as 3.3V, but 5V is recommended.'
  prefs: []
  type: TYPE_NORMAL
- en: The other main sensor of this project is the DS18B20 waterproof temperature
    sensor probe, which is used to monitor the soil temperature of a specific area,
    along with soil moisture levels. It is a low-cost waterproof temperature monitoring
    sensor and is rustproof due to its steel enclosure. The following figure shows
    the DS18B20 waterproof temperature probe and its pinout and connection diagram
    with ESP32-DevKit V1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: DS18B20 waterproof temperature probe](img/B19752_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: DS18B20 waterproof temperature probe'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure shows the sensor and its pinout diagram. DS18B20 contains
    three colored wires: the black wire is used for GND, the red wire is used to connect
    VCC either with 3.3V or 5V, and the yellow wire is used to connect with any digital
    pin but with a 4.7k pull resistor, as shown in the figure. If we’re talking about
    sensor specifications, then its temperature sensing range is good – it is capable
    of measuring a temperature from -55 to 125°C. All the other details are given
    in the following table for further exploration:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **DS18B20** |'
  prefs: []
  type: TYPE_TB
- en: '| Power supply | 3.3 to 5V |'
  prefs: []
  type: TYPE_TB
- en: '| Output signal | Digital signal/one wire |'
  prefs: []
  type: TYPE_TB
- en: '| Temperature sensing range | -55~125°C |'
  prefs: []
  type: TYPE_TB
- en: '| Temperature accuracy | Temperature ± 0.5°C |'
  prefs: []
  type: TYPE_TB
- en: '| Sensing period | <750 ms |'
  prefs: []
  type: TYPE_TB
- en: Table 9.2 – DS18B20 specification table
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed development boards and sensors in detail,
    with complete specifications and pinout diagrams. In the next section, we will
    talk about how these sensors connect to ESP32-DevKit V1 as well as the PCB design
    of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Architecting your agriculture IoT system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we discussed the sensors and development board in
    detail. Now it’s time to put things into practice. In hardware development, before
    starting to work with sensors and development boards, we need to develop the design
    concepts to get a better understanding of how things will be connected. There
    are many pieces of software available to design and develop design concepts for
    electronic projects, but we are going to use **Fritzing**.
  prefs: []
  type: TYPE_NORMAL
- en: In the following two subsections, we will first talk about the schematics and
    design of the project and explain how to connect the pins with the development
    board. Then, we will talk about PCB design and its implementation to make the
    product ready for deployment in the field.
  prefs: []
  type: TYPE_NORMAL
- en: Schematics and design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of the design is to get a clear understanding of how sensors will
    connect with the development board. It helps engineers develop prototypes on a
    breadboard or Veroboard by basing them on these design files. A major benefit
    of designing using Fritzing is that it builds hardware schematics and PCB design
    in the background according to your design, which can be adjusted by designers
    according to the system requirements. The following figure shows the whole project
    diagram, illustrating how the sensors and ADS1115 module connect to the ESP32-DevKit
    V1 board.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: Smart agriculture system design](img/B19752_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Smart agriculture system design'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.5* depicts the whole project schematic diagram, which also includes
    the pin numbers. But to make it easier for you, we have provided the following
    tables with all the pin numbers. *Table 9.3* contains the pin configuration for
    DHT22 with ESP32:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ESP32** | **DHT22** |'
  prefs: []
  type: TYPE_TB
- en: '| D13 | Data (I/O) |'
  prefs: []
  type: TYPE_TB
- en: '| GND | GND |'
  prefs: []
  type: TYPE_TB
- en: '| 3.3V | VCC |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.3: ESP32 and DHT22 pinout table'
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 9.4* contains the pin configuration for DS18B20 temperature probes with
    ESP32\. Here, we are using four DS18B20 temperature probes, and in each column
    of sensors, we have mentioned the ESP32 pin number that will connect with the
    DS18B20 data pin. GND and VCC pins of ESP32 development board will be common to
    all sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Soil Temperature** **Sensor #1** | **Soil Temperature** **Sensor #2** |
    **Soil Temperature** **Sensor #3** | **Soil Temperature** **Sensor #4** |'
  prefs: []
  type: TYPE_TB
- en: '| Data pin with ESP32 (D32) | Data pin with ESP32 (D33) | Data pin with ESP32
    (D25) | Data pin with ESP32 (D26) |'
  prefs: []
  type: TYPE_TB
- en: '| ESP32 GND to GND | ESP32 GND to GND | ESP32 GND to GND | ESP32 GND to GND
    |'
  prefs: []
  type: TYPE_TB
- en: '| ESP32 3.3V to VCC | ESP32 3.3V to VCC | ESP32 3.3V to VCC | ESP32 3.3V to
    VCC |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.4: ESP32 and DS18B20 temperature probes pinout table'
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 9.5* illustrates ESP32 to ADS1115 pin configuration. The rest of the
    soil moisture sensors will connect to the system via ADS1115 analog pins, which
    are explained in *Table 9.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ESP32** | **ADS1115** |'
  prefs: []
  type: TYPE_TB
- en: '| D22 | SCL |'
  prefs: []
  type: TYPE_TB
- en: '| D21 | SDA |'
  prefs: []
  type: TYPE_TB
- en: '| 3.3V | VCC |'
  prefs: []
  type: TYPE_TB
- en: '| GND | GND |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.5: ESP32 and ADS1115 pinout table'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Table 9.6*, you will see how we have attached soil moisture sensors to
    the system using ADS1115\. The second row of the table states which pin of ADS1115
    will be used to connect soil moisture sensors to the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Soil Moisture** **Sensor #1** | **Soil Moisture** **Sensor #2** | **Soil
    Moisture** **Sensor #3** | **Soil Moisture** **Sensor #4** |'
  prefs: []
  type: TYPE_TB
- en: '| Soil moisture analog pin to ADS1115 (A0) | Soil moisture analog pin to ADS1115
    (A1) | Soil moisture analog pin to ADS1115 (A2) | Soil moisture analog pin to
    ADS1115 (A3) |'
  prefs: []
  type: TYPE_TB
- en: '| ESP32 GND to GND | ESP32 GND to GND | ESP32 GND to GND | ESP32 GND to GND
    |'
  prefs: []
  type: TYPE_TB
- en: '| ESP32 VCC to VCC | ESP32 VCC to VCC | ESP32 VCC to VCC | ESP32 VCC to VCC
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.6: ADS1115 and soil moisture sensors pinout table'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding design provides a full overview showing how you can connect the
    sensors to the development board. According to the design, we have only one 5V
    and one GND from the development board, which will be used across all the sensors.
    Soil moisture sensors are analog sensors, so we connected all the sensors with
    ADS1115 module pins from the AO pin to the A4 pin, as shown in *Figure 9**.5*
    and *Table 9.6*, while the DHT22 module and DS18B20 are digital sensors and are
    connected to the D12, D32, D33, D25, and D26 pins of ESP32, as shown in *Figure
    9**.5* and in *Table 9.3* and *Table 9.4*, respectively. The ESP32 to ADS1115
    pinout is shown in *Table 9.5* as well as in *Figure 9**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: PCB design and the assembly of hardware components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding section, we saw a design that is good for creating prototypes
    using a breadboard or Veroboard, but what if we want to deploy that solution in
    the field? Fritzing is a great tool that provides the option to design a PCB,
    and when you develop the design, it automatically creates the PCB design in the
    backend, which is accessible in the Fritzing software via the **PCB Design** tab.
    Automatic PCB design is just a basic functionality and is not suitable for direct
    production, so it’s mandatory to review and rearrange the design according to
    professional practices. The following figure shows the PCB design for the current
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: Smart agriculture system PCB design](img/B19752_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Smart agriculture system PCB design'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows the final PCB design of the project. (I was able
    to create this design easily thanks to Fritzing.) There are many different tools
    available for PCB design, such as **EasyEDA**, **Circuit Maker**, and **Altium**.
    It’s easy to develop a PCB; just make sure that the connection line on the PCB
    doesn’t intersect with other connection lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the PCB design, you have two options: either develop the PCB yourself
    using the DIY method (which is good for learning purposes but not suitable for
    large-scale products) or choose a professional organization that will manufacture
    the PCB professionally. Many organizations in China provide PCB manufacturing
    and fabrication services, such as Seeed Studio, JLCPCB, and PCBWay. We tried PCBWay
    and were impressed with their working and delivery time. We have uploaded the
    PCB design to the PCBWay project repository, and from there, you can select the
    PCB design and order easily: [https://www.pcbway.com/project/shareproject/ESP32_Based_Smart_Agriculture_Node_11223e5a.html](https://www.pcbway.com/project/shareproject/ESP32_Based_Smart_Agriculture_Node_11223e5a.html).'
  prefs: []
  type: TYPE_NORMAL
- en: After getting the PCBs, it’s time to solder the female headers and 2.54 mm three-pin
    connectors for development boards and sensors. Never solder the development board
    and sensors directly on a PCB so that if anything stops working, then it’s easy
    to detach and replace. The following figure shows the final face of the PCB which
    contains 2.5mm three-pin connectors in white color for soil moisture sensors,
    DS18B20 & DHT22 while black female headers are used to insert the ESP32-DevKit
    V1 and ADS1115 module.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Smart agriculture system PCB](img/B19752_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Smart agriculture system PCB'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows how the PCB looks after soldering the three-pin 2.54
    mm connectors and female headers. Soil moisture connectors are marked with **SM**
    while DS18B20 connectors are marked with **T** and resistances are marked with
    **R**, as shown in *Figure 9**.7*. Now it’s time to plug all the connectors to
    get our smart agriculture node ready for further procedures. But wait – by default,
    soil moisture sensors come with a very small length of wire, which is not enough,
    so here you need to extend the cable lengths by putting 2.54 mm female connectors
    on both ends, as soil moisture sensors also use the same connectors for connectivity.
    DS18B20 also comes with a naked terminal but we plugged a 2.54 mm female connector
    for easy and clean connectivity. The following figure shows the complete setup
    with all the sensors and cabling arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: Smart agriculture system with all sensors and modules](img/B19752_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: Smart agriculture system with all sensors and modules'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows all the components stacked on the PCB. We can see
    that soil moisture sensors are extended with custom cabling with the help of connectors,
    while the DS18B20 naked terminal is connected to female connectors, and the same
    for the DHT22 module. After hardware assembly, we need to calibrate the soil moisture
    and DS18B20 temperature before deploying the node into the field.
  prefs: []
  type: TYPE_NORMAL
- en: Perfecting sensor calibration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sensor calibration is a very important aspect of product development, especially
    when you have a plan to deploy your product in a real-time environment. So, before
    moving on, first we need to calibrate the capacitive soil moisture and DS18B20
    sensors. The soil moisture sensor operation varies from area to area due to air
    humidity and water levels.
  prefs: []
  type: TYPE_NORMAL
- en: So firstly, we will calibrate the soil moisture sensor by taking the values
    of sensors in the air and then putting sensors in the water. These values will
    be used to bind the final readings and, finally, we will convert the soil moisture
    sensor value from 0 to 100% via the map method. The soil moisture sensor is an
    analog sensor, so there is no requirement for an extra helping library, except
    the **ADS module library**, which is shown in the following figure with the name
    **Adafruit ADS1X15**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – ADS1115 library](img/B19752_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – ADS1115 library
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we need to install a library for ADS1115/ADS1015 in the Arduino IDE so
    we can use the ADS module. Navigate to `Adafruit ADS1X15`, and install the latest
    version, which is shown in the preceding figure. After installation of the library,
    download the code from the official GitHub book repository and open the code from
    the `Soil-Moisture-Calibration` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet contains two arrays: one for air values and one
    for sensor values when they are dipped into the water. For soil sensor calibration,
    we need to get `AirValue` and then `WaterValue` values only by one time. Upload
    the code to the development board and make sure your soil moisture sensors are
    dry. Open the serial monitor and note down the `AirValue` value for each sensor.
    After that, dip the sensors into a pot of water and note down the `WaterValue`
    value of the sensors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the `AirValue`s of AIN0, AIN1, AIN2, and AIN3, as shown in *Figure
    9**.10*. **AIN** is short for **Analog Input** and the proceeding 0, 1, 2, and
    3 are the pin numbers of the ADC1115 module where soil moisture sensors are connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10: Air values of soil moisture sensors](img/B19752_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Air values of soil moisture sensors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the `WaterValue`s after putting the soil moisture sensors
    in the water:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11: Water values of soil moisture sensors](img/B19752_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Water values of soil moisture sensors'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for some time and note down the values when they become stable. After fetching
    the `Air` and `Water` values, put these values into the preceding arrays and upload
    the code again to the development board. Verify the values of the soil moisture
    percentage levels by putting the sensors into the water and then cleaning them.
    Here, you will get 100% when sensors are deeply in water and 0% when they are
    dry.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the soil moisture levels, it’s time to verify the DS18B20 temperature
    probe sensor readings. Firstly, we need to install a library for the DS18B20 temperature
    sensor. Navigate to `Dallas Temperature by Miles Burton`, and install the latest
    version. After installation of the library, download the code from the official
    GitHub book repository and open the code from the `DS18B20-Calibration` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have mentioned digital pin numbers, which are reserved
    on the PCB to connect DS18B20 sensors. If you are using different pins on the
    breadboard, then update the pin number according to your selection. Upload the
    code on the development board, then after uploading, open up the serial monitor
    and see whether you are getting the values from the sensors or not. The following
    figure shows the DS18B20 temperature probe readings on the serial monitor for
    calibration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: DS18B20 temperature sensor values on the Serial Monitor](img/B19752_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: DS18B20 temperature sensor values on the Serial Monitor'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows that the DS18B20 temperature sensors are working
    fine and the values are stabilized. Now, we can move forward with lab calibration.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A 4.7k **pull resistor** is mandatory for DS18B20\. Without pull-up resistor,
    you will not get the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the soil moisture sensors have tested with the `Air` and `Water` values,
    it’s time to calibrate both sensors in the lab. For moisture testing, we used
    the hot air oven method to verify the accuracy of the soil moisture sensor. We
    added water to soil, sand, and salt at different levels and measured it with sensors.
    After that, we inserted these samples into a hot air oven and compared the sensor
    readings between the two methods; the results were incredible: only a ±0.5 difference.
    For DS18B20, we used a calibrated analog thermometer and observed only a ±0.5
    difference. The following figure shows a photo of the lab where we calibrated
    the soil moisture and DS18B20 sensors to industry standards.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13: Moisture sensor and temperature sensor calibration in the lab](img/B19752_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: Moisture sensor and temperature sensor calibration in the lab'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows the calibration of sensors in the lab. Here, we have
    tested the sensors with soil, sand, and salt.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed sensors and their connection to ES32-DevKit V1
    using a schematic diagram, as well as PCB design and its implementation. After
    that, we discussed soil moisture and DS18B20 sensor calibration. In the upcoming
    section, we will set up things, network credentials, and cloud variables and look
    into the code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up things, networks, and cloud variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After setting up the hardware, it’s time to set up a thing in the Arduino IoT
    Cloud. For this project, we need 10 cloud variables to fetch monitoring parameters
    from the device; the network settings will be different due to the ESP series
    board. The following figure gives a complete overview of the **AgriStack** Thing
    we will set up.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14: Smart agriculture system thing setup](img/B19752_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: Smart agriculture system thing setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a new thing with the name `AgriStack`. Follow these steps to create
    variables, an associated device, network configuration, and, finally, the code.
    We have marked the preceding figure with different red boxes and assigned numbers.
    These numbers correspond to the following steps, which will help you to set up
    the Thing:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to set up 10 cloud variables, as shown in *Figure 9**.14*.
    There are two cloud variables for outdoor temperature and humidity; these values
    will be taken from DHT22\. There are four cloud variables for soil moisture and
    four variables for soil temperature. The previous four will use soil moisture
    sensor and the latter four will use the DS18B20 temperature probe. More details
    about cloud variables are available in the next subsection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we need to associate the device with the Thing. In the current project,
    we are going to use ESP32-DevKit V1, so the wizard will be different compared
    to Arduino boards. Complete details are available in the *Associating a* *device*
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to set up the network configuration for the device, but this
    time, we need to provide a security key for ESP series boards to make the connection
    secure, whereas Arduino-compatible boards are configured by the Arduino IoT Cloud
    automatically during the device setup wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we have discussed the different steps that help us to set up our thing.
    In the proceeding section, we will start looking into cloud variables.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table explains all the properties of variables that we need to
    use during cloud variable creation. An integer (`int`) is a very famous data type,
    but here you will observe two new variable types regarding humidity and temperature,
    which take values in percentage and Celsius, respectively. Also, ensure you have
    the same variable declaration as per the table; otherwise, you will need to modify
    the example code according to your naming.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have set the permission of all cloud variables to **Read Only**, but we
    also have the **Read/Write** option. In this project, we only want to receive
    data from the device instead of sending data from dashboard, which is why **Read
    Only** mode is used, to avoid issues with data consistency. **Update Policy**
    is set to **On change**, as the device will send the data after five minutes,
    so this option is more appropriate compared to **Periodically update**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Serial** **no.** | **Variable Name** | **Variable Type** | **Declaration**
    | **Permission** | **Update** **Policy** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `Humidity` | `CloudRelativeHumidity` | `humidity` | **Read Only** | **On
    change** |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `Temperature` | `CloudTemperatureSensor` | `temperature` | **Read Only**
    | **On change** |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `SM1` | `int` | `sM1` | **Read Only** | **On change** |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `SM2` | `int` | `sM2` | **Read Only** | **On change** |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `SM3` | `int` | `sM3` | **Read Only** | **On change** |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `SM4` | `int` | `sM4` | **Read Only** | **On change** |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `ST1` | `int` | `sT1` | **Read Only** | **On change** |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | `ST2` | `int` | `sT2` | **Read Only** | **On change** |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | `ST3` | `int` | `sT3` | **Read Only** | **On change** |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | `ST4` | `int` | `sT4` | **Read Only** | **On change** |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.7: Cloud variables list with complete parameters'
  prefs: []
  type: TYPE_NORMAL
- en: After the successful creation of cloud variables, we will proceed further with
    the device association step, where we will add and associate the ESP32-DevKit
    V1 with our thing.
  prefs: []
  type: TYPE_NORMAL
- en: Associating a device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After variable creation, it’s time to add a device and associate it with the
    Thing. Before adding the device, connect the development board to the computer,
    and open the **Arduino Create Agent** application. We discussed the Arduino Create
    Agent in [*Chapter 2*](B19752_02.xhtml#_idTextAnchor038), in the *What is the
    Arduino Create* *Agent?* section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15: Device selection wizard](img/B19752_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: Device selection wizard'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Select Device** button under the **Associated Device** section
    on the Thing page. A popup will appear where you can see all the devices that
    are already available. If you have already added your WeMos D1 mini, select it.
    Otherwise, click on **SET UP NEW DEVICE**. Next, click on the **Set up a 3rd party
    device** option. Select **ESP32** and **DOIT ESP32 DEVKIT V1** from the dropdown
    and click on the **CONTINUE** button. Provide the device name and click on the
    **Next** button. In the final wizard, the **Device ID** and **Secret Key** details
    will be displayed. Copy the secret key to a safe place as it will be used during
    the network configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Network configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After associating the device with the Thing, it is time to configure the Wi-Fi
    settings for device communication, as shown in *Figure 9**.14*, in the area marked
    *3*. Under **Network**, you will find the option to fill in the form with the
    Wi-Fi name and password. In the last field, you will find a new field for the
    secret key. Paste the secret key that we received from the system during device
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16: Network configuration for the Thing](img/B19752_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: Network configuration for the Thing'
  prefs: []
  type: TYPE_NORMAL
- en: After network configuration, we are done with our main task; now, the coding
    task remains, and in the next section, we will go through it.
  prefs: []
  type: TYPE_NORMAL
- en: Coding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project code is available in the book’s official GitHub repository in a
    ZIP file named `AgriStack_mar05a`. Download it and import it to your Arduino Web
    Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code and put it into your thing by navigating to the `setup`
    method and use the `timer` library to delay calling; remember, never try to use
    the `delay` method as it will block the `ArduinoCloud.update()` method. Then,
    a method called `SmartAgri()` is called every five minutes. The following is the
    complete `SmartAgri()` method. After this, we will explore what operations are
    carried out by this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this project, we have divided all the operations into different methods
    for easiness. So, firstly, we are calling `FetchSoilMoisture()`, which is responsible
    for fetching soil moisture readings from sensors and storing them in an array.
    Before storing the data in an array, it maps the value for the percentage. Next,
    we have the `FetchTemperature()` method, which is responsible for fetching the
    temperatures from all DS18B20 sensors and saving them into the soil temperature
    array for further usage. Finally, we call `FetchDHTTempHum()` to fetch the outdoor
    temperature and humidity values from the DHT22 module, which will be stored in
    two variables. Now, we will explore how we get the values from the soil moisture
    sensors in the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding technique is used in the `FetchSoilMoisture()` method to fetch
    the readings for soil moisture. Here, you will see that the method takes values
    from the sensor five times with a delay of one second and adds them to the variable;
    then later, it divides the sensor readings by 5 to get the average. The benefit
    of this technique is that you will get the best possible value from the soil sensor.
  prefs: []
  type: TYPE_NORMAL
- en: The previous three methods have been used to fetch values from different sensors
    and store them in global variables and arrays. Now it’s time to send these values
    to the Arduino IoT Cloud; for that reason, we have the `SendToArduinoIoTCloud()`
    method, which assigns all the values of sensors to cloud variables, and these
    values will be updated on the cloud with the help of the `ArduinoCloud.update()`
    method. At the end, we have the `PrintTheReadingsSerialPort()` method, which is
    optional for use at runtime and is used to display all the sensor values on the
    serial monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Upload the code to the device and verify the connectivity and readings. If you
    want to change the reading time, then just modify the `timer.every(600000, SmartAgri);`
    value. Make sure you are providing the time in milliseconds, where 1 second equals
    1,000 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you used a different naming scheme in the variable declaration, then update
    the code according to your naming scheme. But first, you should follow all the
    steps according to the book and then you can later change the cloud variable names
    and modify your code, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Never try to use the `delay` method, as it will block the `ArduinoCloud.update()`
    method. Always use milliseconds to calculate the waiting time. Review the `loop()`
    method to call the other methods after five minutes.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud only updates the value on the dashboard whenever the variable
    value is changed. For example, if the temperature is 30°C and it’s the same after
    five minutes, then the Arduino IoT Cloud will not record the value, so don’t get
    confused if values are not changing on the graph. Another benefit of this feature
    is you will not get duplicated data when you are exporting the content.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully discussing the different methods in the code and uploading
    the code to ESP32-DevKit V1, it’s time to explore how to visualize all the data
    using awesome Arduino IoT Cloud dashboard widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Creating web and mobile dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After uploading the code to the device, it’s time to set up a dashboard for
    web and mobile to visualize the data with different widgets. The following figure
    shows the visualization of readings with different widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17: Thing dashboard](img/B19752_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: Thing dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have 10 different readings: **Outdoor Temperature**, **Outdoor Humidity**,
    four **Soil Moisture** readings, and four **Soil Temperature** readings. For every
    reading, we are using the gauge widget control, and advanced charts have been
    used to compare **Soil Moisture** and **Soil Temperature** to visualize the proper
    correlation between these two attributes. But we also want to monitor historical
    data; graphs are the best widgets to display live as well as older data. Here,
    as seen in the lower part of the preceding figure, we have used four graphs, and
    each graph is connected to a specific cloud variable.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have successfully created a dashboard for a smart agriculture
    thing that shows all the sensor readings in text format, as well as used graphs
    for comparison purposes.
  prefs: []
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We still have a lot of options available to explore, but now it’s your turn
    to use different sensors and development boards to do some more experiments and
    learn from them. In this chapter, we used 10 sensors but only 3 different types,
    that is, moisture, temperature, and outdoor temperature and humidity. However,
    on the market, there are a lot of sensors that provide a wide variety of functionalities
    for soil, such as **NPK** (which stands for **nitrogen, phosphorus, and potassium**),
    **EC** (which stands for **electrical conductivity**), and pH sensors and different
    gas sensors for outdoor measurement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following sensors to enhance your practical knowledge and compare them
    with other sensors in terms of features, ranges, and cost:'
  prefs: []
  type: TYPE_NORMAL
- en: NPK sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soil EC sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soil pH sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MQ series sensors, which are designed to sense specific gases, including MQ-2,
    MQ-3, MQ-4, MQ-5, MQ-7, MQ-8, and MQ-9, to find the correlation of gases and their
    effects on soil and crops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeed Studio SCD30 (temperature, humidity, and CO2) for outdoor monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to develop a smart agriculture monitoring system
    using DHT22, capacitive soil moisture sensors, a DS18B20 probe for soil temperature,
    and an ESP32 development board along with the ADS1115 ADC module. We calibrated
    soil moisture and temperature sensors in the lab before using them in the field.
    We also set up a thing, which included creating cloud variables, device association,
    network configuration, and coding of the development board. Then, we created a
    dashboard to visualize the Thing’s sensor readings with different types of widgets
    to display current readings as well as historical data with the help of graphs.
  prefs: []
  type: TYPE_NORMAL
- en: This project will help you and give you the confidence to collaborate with agriculture
    researchers and soil scientists to work on a more advanced level. It will help
    you to add IoT systems to real fields and tunnel farms, as well as help you in
    home gardening.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will work on a smart home project where we will develop
    a smart RGB LED light that will be connected to the Amazon Alexa Voice assistant
    and help you to understand and develop smart home solutions.
  prefs: []
  type: TYPE_NORMAL
