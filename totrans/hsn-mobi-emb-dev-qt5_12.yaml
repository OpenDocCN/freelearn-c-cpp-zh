- en: Sounds and Visions - Qt Multimedia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications that need to play sounds or show videos are usually games, while
    others are full-blown multimedia apps. Qt Multimedia can handle both.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Multimedia can be used with both Qt Widgets and Qt Quick, or even without
    a GUI interface. It has both C++ and QML APIs, but the QML API has a few special
    treats and tricks. A little-known fact is that Qt can also play 3D positional
    audio in Qt Quick. You can control the gain and pitch with three dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Sonic vibrations – audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image sensors – camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual media – playing video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuning it in – FM radio tuner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sonic vibrations – audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have a relationship with audio that goes way back—before computers were household
    things, when Mylar tape and magnets ruled the sonic realms. Things have progressed
    since then. Now, mobile phones fit into our pockets and light bulbs can play music.
  prefs: []
  type: TYPE_NORMAL
- en: 3D audio in Qt is supported through the OpenAL API. If you are using Linux,
    the default Qt binaries from Qt Company do not ship with the needed Qt Audio Engine
    API. You will have to install the OpenAL development package and then compile
    Qt Multimedia for yourself. OpenAL is not supported on Android, so no joy there.
    Luckily, it is supported by default on Apple Mac and iOS. So, that is where I
    am going to develop this next section. Let's grab the nearest MacBook and head
    over there.
  prefs: []
  type: TYPE_NORMAL
- en: 3D audio is audio in three dimensions, just like 3D graphics—not just left and
    right, but also up, down, front, and back placement of audio. The term *positional
    audio* might explain this better.
  prefs: []
  type: TYPE_NORMAL
- en: With Qt, 3D audio is only supported using Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found in the Git repository under the `Chapter09-3dAudio` directory,
    in the `cp9` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Qt Multimedia, you need to edit the project `.pro` file and add the
    following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `qml` file that you want to use the 3D audio in, and add the `import`
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 3D space is made up of three axes named x, y, and z, which correspond to horizontal/vertical
    and up/down in 3-dimensional space.
  prefs: []
  type: TYPE_NORMAL
- en: '`AudioEngine` and other associated classes use the `Qt.vector3d` value type.
    It is essential to understand this element to use 3D audio.'
  prefs: []
  type: TYPE_NORMAL
- en: Qt.vector3d
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Qt.vector3d` is an array of values that represents the x, y, and z axes—x
    being horizontal, y being vertical, and z being up or down. Each value is a single-precision
    `qreal`.'
  prefs: []
  type: TYPE_NORMAL
- en: It can be used like `Qt.vector3d(15, -5, 0)` or `"15, -5, 0"` as a `String`.
  prefs: []
  type: TYPE_NORMAL
- en: The positioning of the audio is controlled through the use of the `vector3d`
    property value.
  prefs: []
  type: TYPE_NORMAL
- en: '`Qt.vector3d` is used to position the audio in 3 dimensional space.'
  prefs: []
  type: TYPE_NORMAL
- en: The main component for using 3D audio in QML is called `AudioEngine`. The other
    components we will use can be children of this component.
  prefs: []
  type: TYPE_NORMAL
- en: AudioEngine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AudioEngine` is the central container for the other 3D audio items that you
    will use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set up the component easily enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `dopplerFactor` property creates a Doppler shift effect. The `speedOfSound`
    value reflects the speed of sound in which the Doppler effect is calculated.
  prefs: []
  type: TYPE_NORMAL
- en: You assign a `listener` through the `listener` property. We will get to that
    later in the *AudioListener* section.
  prefs: []
  type: TYPE_NORMAL
- en: We have an audio sample we want to load and use, so we declare at least one `AudioSample`.
  prefs: []
  type: TYPE_NORMAL
- en: AudioSample
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AudioSample` can be defined as a child of an `AudioEngine` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be added using the `AudioEngine.addAudioSample()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `source` property holds the sample's filename and a name to refer to it
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to play the sound using the `Sound` component.
  prefs: []
  type: TYPE_NORMAL
- en: Sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Sound` element is a container for one or more samples that will play with
    different parameters and variances. In other words, you can define a `PlayVariation`
    item, which defines how a `Sound` plays an `AudioSample`, with maximum or minimum
    values in pitch and gain. You can also declare the sample to be `looping`, which
    means it plays over and over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `attenuationModel` property controls the way the sound volume level falls
    off, or fades over time. It can be one of these values:'
  prefs: []
  type: TYPE_NORMAL
- en: Linear is a straight falloff
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inverse is a more natural, non-linear curve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can control this using the `start`, `end`, and `rolloff` properties.
  prefs: []
  type: TYPE_NORMAL
- en: AudioListener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AudioListener` component represents the `listener` and its position in
    the 3D realm. There is only one `listener`. It can either be constructed as the
    `listener` property of the `AudioEngine` component, or as a definable element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A `SoundInstance` is the component that a `Sound` uses to play the sample.
  prefs: []
  type: TYPE_NORMAL
- en: SoundInstance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SoundInstance` has a few properties that you can use to adjust the sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '`direction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gain`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pitch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`position`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties take a `vector3d` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sound` property of the `SoundInstance` element takes a string that represents
    the name of a `Sound` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, I start playing the sound when the component is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we just need some mechanism to move the sound position around. We can use
    the `Accelerometer` values if we have an accelerometer on the device. I'm just
    going to use the mouse. Remember that on a touchscreen, a `MouseArea` also includes
    touch input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must enable `hover` in order to track the mouse without clicking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To propagate the mouse clicks to buttons or other items when using `MouseArea`,
    put the `MouseArea` at the top of the file, as Qt Quick will set the z order in
    the order of the components from the top of the file, down to the bottom. You
    could also set the `z` property of the buttons and set the `z` property of the
    `MouseArea` to the lowest value.
  prefs: []
  type: TYPE_NORMAL
- en: 'I previously declared three values in my `Window` component to use in the positioning
    of the audio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you move the mouse around, the audio will appear to move around.
  prefs: []
  type: TYPE_NORMAL
- en: But there is no mouse on a phone. There is a touch point, but no scrolling.
    I could use an `Accelerometer` as it has the z axis, or use `PinchArea` to control
    the up and down position.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few other ways to deal with audio.
  prefs: []
  type: TYPE_NORMAL
- en: Audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Audio` element is probably the easiest way to play audio. It only takes
    a few lines. It would be good for playing sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found in this book's Git repository under the `Chapter09-1` directory,
    in the `cp9` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a simple stanza that will play the `.mp3` file named `sample.mp3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `source` property is where you declare which file to play. Now, you just
    have to call the `play()` method to have this `sample.wav` file play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can also set the `autoPlay` property to `true` instead of calling `play`,
    and that would play the file once the component is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the volume is as easy as declaring the `volume` property and setting
    a decimal value between 0 and 1—1 being full volume and 0 being muted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Getting the metadata or ID tags from the file is not obvious, as they only become
    available after the `metaDataChanged` signal gets emitted. This is only emitted
    by the `Audio` element's `metaData` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you might need to display a file''s metadata, or the extra data
    that can be within the audio file''s headers. The `Audio` component has a `metaData`
    property that can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you need to access the microphone and record audio, you will need to dive
    into C++, so let's take a look at `QAudioRecorder`.
  prefs: []
  type: TYPE_NORMAL
- en: QAudioRecorder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recording audio is one of my passions. Recording audio, or more specifically
    using the microphone, may require user permissions on some platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The recording of audio, called taping back in my day, can be implemented by
    using the `QAudioRecorder` class. Recording properties are controlled by the `QAudioEncoderSettings`
    class, from which you can control the codec that's used, the channel count, the
    bit rate, and the sample rate. You can either explicitly set the bit rate and
    sample rate, or use the more generic `setQuality` function.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found in this book's Git repository under the `Chapter09-2` directory,
    in the `cp9` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to query the input devices and see which settings are available.
    To do that, you would query using `QAudioDeviceInfo`, iterating through `QAudioDeviceInfo::availableDevices(QAudio::AudioInput)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Qt Multimedia uses the term sample sizes for the more common term bit depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from my laptop, I have a few different audio input devices.
    The laptop''s built-in audio chip got fried from an electrical spike, which is
    why it isn''t seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5acaf2c-000a-4c42-9ccb-ada79d0bf846.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For iPhone, it is different. It has only one audio device, named `default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ef5a2e6-b9df-4ad1-ab1a-60cc43d0dd76.png)'
  prefs: []
  type: TYPE_IMG
- en: My Linux desktop reports a lot of audio input devices because of the ALSA Driver,
    which I won't include here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set up the recording encoder settings with the type of audio file
    we want to record. This includes the number of channels, the code, sample rate,
    and bit rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to let the system decide on the various settings, it is quicker
    and takes less code to use the `setQuality` function, which can take one of the
    following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QMultimedia::VeryLowQuality`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QMultimedia::LowQuality`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QMultimedia::NormalQuality`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QMultimedia::HighQuality`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QMultimedia::VeryHighQuality`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s choose `NormalQuality`, which will give the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QAudioRecorder` class is used to record the audio, so let''s construct
    a `QAudioRecorder` and set the encoding settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify which audio input to use, but first you will need to get
    a list of available audio input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t want to bother about which audio device to use, you can specify
    it using the default device with the `defaultAudioInput()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can save it to a file, or even a network location, as the `setOutputLocation`
    function takes a `QUrl`. We will just specify a local file to save it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the file is relative, like it is here, you can get the actual output location
    using `outputLocation()` once the recording has started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can start the recording process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are also the `stop()` and `pause()` methods to control the recording operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you will want to connect to the error signal, because errors can
    and will happen from time to time. Again, note the use of the `QOverload` syntax
    that''s used in error-reporting signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, now that we have recorded some audio, we might want to listen to it. This
    is where `QMediaPlayer` comes in.
  prefs: []
  type: TYPE_NORMAL
- en: QMediaPlayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QMediaPlayer` is fairly straightforward. It can play both audio and video,
    but here we will only be playing audio. First, we need to set up the media to
    play by calling `setMedia`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `QAudioRecorder` to get the output file and use it to play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have to monitor the current playing position, so we will connect the
    `positionChanged` signal to a progress bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect the error signal and its `QOverload` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, just call `play()` on the `QMediaPlayer` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even set the playback volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you need access to the media data, let's say for getting the volume level
    of the data as it plays, you will want to use something other than `QMediaPlayer`
    to play your file.
  prefs: []
  type: TYPE_NORMAL
- en: QAudioOutput
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QAudioOutput` provides a way to send audio to an audio output device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using `QAudioOutput`, you will need to set up the exact format of your file.
    To get the format of your file, you could use `QMediaResource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scratch that—`QMediaResource` is being depreciated in Qt 6.0, and does not
    do what the docs say it is supposed to do, and doesn''t work like it should. We
    need to hardcode the data format, so we will use the basic good-quality stereo
    format. `QAudioFormat` is the way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will iterate through the audio devices and check that `QAudioDeviceInfo`
    supports this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I connected to the `stateChanged` signal and tested whether the state
    is `StoppedState`; we know there might be an error, so we check the `error()`
    of the `QAudioOutput` object. Otherwise, we can play the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We see now that Qt Multimedia has various ways of playing audio. Now, let's
    take a look at the camera and recording video.
  prefs: []
  type: TYPE_NORMAL
- en: Image sensors – camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we should establish whether the device has any cameras. This helps us
    determine specifics about the use of the camera and other camera specifications,
    such as the orientation or position on the device.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we will use `QCameraInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: QCameraInfo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can get a list of cameras using the `QCameraInfo::availableCameras()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found in this book's Git repository under the `Chapter09-4` directory,
    in the `cp9` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'On my Android device, I see two cameras, named `back` and `front`. You can
    also check for `front` and `back` cameras using `QCameraInfo::position()`, which
    will return one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QCamera::UnspecifiedPosition`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::BackFace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::FrontFace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FrontFace` means that the camera lens is on the same side as the screen. You
    can then use `QCameraInfo` to construct a `QCamera` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check for the capture modes the camera supports, which can be one of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QCamera::CaptureViewfinder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::CaptureStillImage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::CaptureVideo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s do a quick still image shot first. We need to tell the camera to use
    the `QCamera::CaptureStillImage` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `statusChanged` signal is used to monitor the status, which can be one
    of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QCamera::UnavailableStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::UnloadedStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::UnloadingStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::LoadingStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::LoadedStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::StandbyStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::StartingStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::StoppingStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QCamera::ActiveStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s connect to the `statusChanged` signal so that we can see status changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to fiddle with any of the camera settings, you will have to `load()`
    it before you can get access to the `QCameraImageProcessing` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With the `QCameraImageProcessing` class, you can set configurations, such as
    brightness, contrast, saturation, and sharpening.
  prefs: []
  type: TYPE_NORMAL
- en: Before we call start on the camera, we need to set up a `QMediaRecorder` object
    for the camera. Since `QCamera` is inherited from `QMediaObject`, we can feed
    it to the `QMediaRecorder` object.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Multimedia Widgets are not supported on Android.
  prefs: []
  type: TYPE_NORMAL
- en: I tried `QCamera` version 5.12 on both Mac and iOS, but it kept crashing when
    I tried to `start()` the camera. I was successful on Linux desktop. On Android,
    since multimedia widgets are not supported, the camera viewfinder widget did not
    work, but I could still capture images from the image sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you'll have better luck with the QML side of things. QML APIs are usually
    optimized for easy use.
  prefs: []
  type: TYPE_NORMAL
- en: Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yes, the QML `Camera` is so much easier to implement. Really, there are only
    two components you need to take a photo: `Camera` and `VideoOutput`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`VideoOutput` is the element to use for the viewfinder. It is also used when
    you are recording video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `position` property controls which camera to use, especially on a mobile
    device that may have a front-facing and rear-facing camera. Here, I am not only
    using the rear camera. You would use the `FrontFace` position to take a selfie.
  prefs: []
  type: TYPE_NORMAL
- en: '`imageCaptured` pertains to the `CameraCapture` sub-element. We can handle
    the `onImageCaptured` signal to preview the image or to alert the user that a
    photo has been taken.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other properties of the `Camera` object can be controlled by their corresponding
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`focus : CameraFocus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flash : CameraFlash`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exposure : CameraExposure`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imageProcessing : CameraImageProcessing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imageCapture : CameraCapture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`videoRecorder: CameraRecorder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CameraRecorder` is what you would use to controls saturation, brightness,
    color filters, contrast, and other settings.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CameraExposure` controls things such as aperture, exposure compensation, and
    shutter speed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CameraFlash` can turn the flash on, off, or use auto mode. It can also set
    red-eye compensation and video (constant) mode.'
  prefs: []
  type: TYPE_NORMAL
- en: We need a view finder to see what the heck we are trying to capture, so let's
    take a look at the `VideoOutput` element.
  prefs: []
  type: TYPE_NORMAL
- en: VideoOutput
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`VideoOutput` is the component we use to view what the camera is sensing.'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter09-5` directory,
    in the `cp9` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `VideoOutput` component, you need to define the `source` property.
    Here, we are using the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `autoOrientation` property is used to allow the `VideoOutput` component
    to compensate for the device orientation of the image sensor. Without this being
    true, the image might show up in the view finder with the wrong orientation and
    confuse the user, making it harder to take a good photo or video.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make this `VideoOutput` clickable by adding a `MouseArea`, where I will
    use the `onClicked` and `onPressAndHold` signals to focus and actually capture
    an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: I also added a `Switch` component from Qt Quick Controls to control whether
    the user wants a still photo or video recorded.
  prefs: []
  type: TYPE_NORMAL
- en: To focus the camera, call the `searchAndLock()` method, which starts focus,
    white balance, and exposure computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add support for recording videos. We will add a `CameraRecorder` container
    to the `Camera` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can set certain aspects for the video, such as bit rate, frame rate, number
    of audio channels, and what container to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to also change the way our `onPressAndHold` signal works to make sure
    we record video when the user has specified it, by the use of the switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We need some way to stop recording, so let''s modify the `onClicked` signal
    handler to stop the recording when it is in `RecordingState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to actually see the video we just recorded. Let's move on and look
    at how to play a video.
  prefs: []
  type: TYPE_NORMAL
- en: Visual media – playing video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playing a video with QML is much like playing audio using `MediaPlayer`, only
    using a `VideoOutput` instead of an `AudioOutput` component.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter09-6` directory,
    in the `cp9` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by implementing a `MediaPlayer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The property named `autoPlay` will control the automatic starting of the video
    once the component is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `source` property is set to the filename of our video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a `VideoOutput` component, with the source being our `MediaPlayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `MouseArea`, which is the entire application, is used here to start playing
    the video when you click anywhere on the application.
  prefs: []
  type: TYPE_NORMAL
- en: With C++, you would use the `QMediaPlayer` class with a `QGraphicsVideoItem`, `QVideoWidget`, or
    something else.
  prefs: []
  type: TYPE_NORMAL
- en: Since `QMultimediaWidgets` have limited support on mobile devices, I will leave
    this as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Multimedia also supports FM, AM, and some other radios, providing your device
    has a radio in it as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning it in – FM radio tuner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some Android phones have an FM radio receiver. Mine does! It requires the wired
    headphones to be inserted to work as the antenna.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by implementing a `Radio` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Radio` element has a `band` property that you can use to configure the
    radio''s frequency band use. They are one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Radio.AM` : 520 - 1610 kHz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radio.FM` : 87.5 - 108 MHz, Japan 76 - 90 MHz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radio.SW` : 1.711 to 30 MHz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radio.LW` : 148.5 to 283.5 kHz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radio.FM2` : Range not defined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `availability` property can return the following different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Radio.Available`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radio.Busy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radio.Unavailable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radio.ResourceMissing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first thing the user will do with a radio is scan for stations, which can
    be accomplished by using the `searchAllStations` method, which takes one of the
    following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Radio.SearchFast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radio.SearchGetStationId`: Like `SearchFast`, it emits the `stationFound`
    signal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `stationsFound` signal returns an `int` `frequency` and `stationId` string
    for each station that's tuned in. You could collect these in a model-based component,
    such as `ListView`, using a `ListModel`. The `ListView` would use the `ListModel`
    as its model.
  prefs: []
  type: TYPE_NORMAL
- en: You can cancel the scan by calling the `cancelScan()` method. The `scanUp()`
    and `scanDown()` methods are similar to `searchAllStations`, except it does not
    remember the stations it found. The `tuneUp` and `tuneDown` methods will tune
    the frequency up or down one step, according to the `frequencyStep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some other interesting properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`antennaConnected`: True if an antenna is connected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signalStrength`: Strength of the signal in %'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frequency`: Holds and sets the frequency that the radio is tuned to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the different aspects of the big API of Qt Multimedia.
    You should now be able to position sound in a 3-dimensional way for 3D games.
    We learned how to record and play audio and video, and control and use the camera
    to take a selfie. We also touched on using QML to listen to radio stations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dig into using `QSqlDatabase` to access databases.
  prefs: []
  type: TYPE_NORMAL
