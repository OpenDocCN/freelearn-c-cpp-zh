["```cpp\nUCLASS()\npublic Singleton : public AActor\n{\n    static TObjectPtr<Singleton> _instance;\npublic:\n    void Init();\n}\n```", "```cpp\nvoid Singleton::Init()\n{\n    if (_instance == nullptr)\n    {\n        _instance = this;\n    }\n    else\n    {\n        this->Destroy();\n    }\n}\n```", "```cpp\nvoid AUnit::Init(AGrid* grid)\n{\n    _GridRef = grid;\n}\nvoid AUnit::Move(FVector2 targetCoords)\n{\n    Path p = GridRef->GetPath(_CurrentCoords,\n        targetCoords))\n    if(p != nullptr)\n{\n        //Move the Unit\n    }\n}\n```", "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"Command.generated.h\"\nUCLASS(Abstract)\nclass RTS_AI_API UCommand : public UObject\n{\n    GENERATED_BODY()\npublic:\n    virtual void Execute();\n};\n```", "```cpp\nUCLASS()\nclass RTS_AI_API UCommand_UnitMove : public UCommand\n{\n    GENERATED_BODY()\npublic:\n    void Init(AActor* unit, FVector moveLocation);\n    virtual void Execute() override;\nprivate:\n    TObjectPtr<AActor> _unit;\n    FVector _moveLocation;\n};\n```", "```cpp\nvoid UCommand_UnitMove::Init(AActor* unit,\n    FVector moveLocation) : _unit(unit)_moveLocation\n        (moveLocation) \n{}\nvoid UCommand_UnitMove::Execute()\n{\n    Super::Execute();\n    IControllableUnit::Execute_SetMoveLocation(_unit,_moveLocation);\n}\n```", "```cpp\nvoid AEliteUnit::QueueMoveLocation_Implementation(FVector targetLocation)\n{\n    if(!_isMoving)\n    {\n        _AIController->GetBlackboardComponent()->\n            SetValueAsVector(\"MoveToLocation\", targetLocation);\n        _isMoving = true;\n        return;\n    }\n    TobjectPtr<Ucommand_UnitMove> moveCommand =\n        NewObject<Ucommand_UnitMove>(this);\n    moveCommand->Init(this, targetLocation);\n    _CommandQueue.Enqueue(moveCommand);\n}\n```", "```cpp\nvoid AEliteUnit::MoveLocationReached_Implementation()\n{\n    _isMoving = false;\n    if(!_CommandQueue.IsEmpty())\n    {\n        TObjectPtr<UCommand> command;\n        _CommandQueue.Dequeue(command);\n        command->Execute();\n    }\n}\n```", "```cpp\nUENUM(BlueprintType)\nenum class EState : uint8\n{\n    State1    UMETA(DisplayName = \"First State\"),\n    State2    UMETA(DisplayName = \"Second State\"),\n    State3    UMETA(DisplayName = \"Third State\"),\n};\n```", "```cpp\nEstate _State;\nvoid SomeFunction()\n// some code…\nswitch(_State)\n{\ncase Estate::State1:\n    //State1 code\n    break;\ncase Estate::State2:\n    //State2 code\n    break;\ncase Estate::State3:\n    //State3 code\n    break;\ndefault:\n    //unhandled state code\n    break;\n}\n```", "```cpp\nclass State\n{\npublic:\n    virtual EState Update() = 0;\n    virtual void Enter() = 0;\n    virtual void Exit() = 0;\n}\n```", "```cpp\nclass SomeClass\n{\npublic:\n    SomeClass();\n    void Update();\nprivate:\n    State* _State;\n    EState _CurrentState;\n    Map<Estate, State*> _StateLibrary;\n    void ChangeState(EState nextState);\n};\n```", "```cpp\nSomeClass::SomeClass()\n{\n    State* tempState = new ExampleState();\n    _StateLibrary.Add(EState::example, tempState);\n    tempState = new OtherState();\n    _StateLibrary.Add(EState::other, tempState);\n    // Do this for each state the state machine requires\n    _CurrentState = EState::example;\n    _State = _StateLibrary[_CurrentState];\n    _State->Enter();\n}\nvoid SomeClass::Update()\n{\n    EState next = _State.Update();\n    if (next != _CurrentState)\n    {\n        ChangeState(next);\n    }\n}\nvoid SomeClass::ChangeState(EState nextState)\n{\n    _State->Exit();\n    _CurrentState = nextState;\n    _State = _StateLibrary[_CurrentState];\n    _State->Enter();\n}\n```", "```cpp\nvoid SomeClass::Update()\n{\n    EMoveState nextMove = _StateMove.Update();\n    EAttackState nextAttack = _StateAttack.Update();\n    if (nextMove != _MoveStateTracker)\n    {\n        ChangeState(nextMove, _MoveStateTracker, _MoveState);\n    }\n    if (nextAttack != _AttackStateTracker)\n    {\n        ChangeState(nextAttack, _AttackStateTracker, _AttackState);\n    }\n}\nvoid SomeClass::ChangeState(EState nextState,     EState& stateTracker, State*& stateMachine)\n{\n    stateMachine->Exit();\n    stateTracker = nextState;\n    stateMachine = _StateLibrary[stateTracker];\n    stateMachine->Enter();\n}\n```"]