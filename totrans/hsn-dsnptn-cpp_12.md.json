["```cpp\n// Example 01\nclass C {\n  int x_;\n  public:\n  C(int x) : x_(x) {}\n};\nC increase(C c, int dx) {\n  return C(c.x_ + dx);     // Does not compile\n}\n```", "```cpp\n// Example 02\nclass C {\n  int x_;\n  public:\n  C(int x) : x_(x) {}\n  friend C increase(C c, int dx);\n};\nC increase(C c, int dx) {\n  return C(c.x_ + dx);    // Now it compiles\n}\n```", "```cpp\n// Example 03\nclass C {\n  int x_;\n  public:\n  C(int x) : x_(x) {}\n  C operator+(const C& rhs) const {\n    return C(x_ + rhs.x_);\n  }\n};\n...\nC x(1), y(2);\nC z = x + y;\n```", "```cpp\n// Example 03\nC x(1);\nC z = x + 2;\n```", "```cpp\n// Example 03\nC x(1);\nC z = 2 + x; // Does NOT compile\n```", "```cpp\nC operator+(const C& lhs, const C& rhs) {\n  return C(lhs.x_ + rhs.x_);\n}\n```", "```cpp\n// Example 04\nclass C {\n  int x_;\n  public:\n  C(int x) : x_(x) {}\n  friend C operator+(const C& lhs, const C& rhs);\n};\nC operator+(const C& lhs, const C& rhs) {\n  return C(lhs.x_ + rhs.x_);\n}\n...\nC x(1), y(2);\nC z1 = x + y;\nC z2 = x + 2;\nC z3 = 1 + y;\n```", "```cpp\n// Example 05\nclass C {\n  int x_;\n  public:\n  C(int x) : x_(x) {}\n  friend C operator+(const C& lhs, const C& rhs) {\n    return C(lhs.x_ + rhs.x_);\n  }\n};\n```", "```cpp\nC c1(5);\nstd::cout << c1;\n```", "```cpp\n// Example 06\nclass C {\n  ...\n  friend std::ostream& operator<<(std::ostream& out,\n                                  const C& c);\n};\nstd::ostream& operator<<(std::ostream& out, const C& c) {\n  out << c.x_;\n  return out;\n}\n```", "```cpp\n// Example 07\nclass C {\n  int x_;\n  public:\n  C(int x) : x_(x) {}\n  friend std::ostream& operator<<(std::ostream& out,\n                                  const C& c) {\n    out << c.x_;\n    return out;\n  }\n};\n```", "```cpp\nC c1(5), c2(7);\nstd::cout << c1 << c2;\n```", "```cpp\n// Example 08\nclass C {\n  friend C operator+(const C& lhs, const C& rhs);\n  ...\n};\nC operator+(const C& lhs, const C& rhs) { … }\n```", "```cpp\n// Example 09\nclass C;\nC operator+(const C& lhs, const C& rhs);\nclass C {\n  friend C operator+(const C& lhs, const C& rhs);\n  ...\n};\nC operator+(const C& lhs, const C& rhs) { … }\n```", "```cpp\nclass C {\n  static void f(const C& c);\n  ...\n};\nC c;\nC::f(c);    // Must be called as C::f() not f()\n```", "```cpp\nclass C {\n  friend void f(const C& c);\n  ...\n};\nC c;\nC::f(c);    // Does not compile – not a member\n```", "```cpp\n// Example 10\nclass C {\n  static int n_;\n  int x_;\n  public:\n  C(int x) : x_(x) {}\n  friend int f(int i) { return i + C::n_; }\n  friend int g(const C& c) { return c.x_ + C::n_; }\n};\nint C::n_ = 42;\n...\nC c(1);\nf(0);        // Does not comppile - no ADL\ng(c);        // Compiles fine\n```", "```cpp\n// Example 11\nint f(int i);    // Forward declaration\nclass C {\n  ...\n  friend int f(int i) { return i + C::n_; }\n};\nf(0);        // No problem\n```", "```cpp\n// Example 12\nclass C {\n  ...\n  friend int f(int i);    // Forward declaration\n};\nint f(int i) { return i + C::n_; }\nf(0);        // No problem\n```", "```cpp\n// Example 13\nclass Alloc {\n  void* alloc(size_t s);    // Allocates memory\n  void dealloc(void* p);     // Releases memory\n  friend void* operator new (size_t s, Alloc* a);\n  friend void operator delete(void* p, Alloc* a);\n};\nvoid* operator new (size_t s, Alloc* a) {\n  return a->alloc(s);\n}\nvoid operator delete(void* p, Alloc* a) {\n  a->dealloc(p);\n}\nclass C { ... };\nAlloc a;\nC* c = new (&a) C;\n```", "```cpp\n// Example 14\nclass Alloc {\n  void* alloc(size_t s);    // Allocates memory\n  void dealloc(void* p);     // Releases memory\n  friend void* operator new (size_t s, Alloc* a) {\n    return a->alloc(s);\n  }\n  friend void operator delete(void* p, Alloc* a) {\n    a->dealloc(p);\n  }\n};\nclass C { ... };\nAlloc a;\nC* c = new (&a) C;\n```", "```cpp\nvoid* new(size_t size, void* addr) { return addr; }\n```", "```cpp\ntemplate <typename T> class C {\n  T x_;\n  public:\n  C(T x) : x_(x) {}\n};\n```", "```cpp\ntemplate <typename T>\nC<T> operator+(const C<T>& lhs, const C<T>& rhs) {\n  return C<T>(lhs.x_ + rhs.x_);\n}\n```", "```cpp\ntemplate <typename C>\nC operator+(const C& lhs, const C& rhs) { // NEVER do this!\n  return C<T>(lhs.x_ + rhs.x_);\n}\n```", "```cpp\n// Example 15\ntemplate <typename T> class C {\n  T x_;\n  public:\n  C(T x) : x_(x) {}\n  template <typename U>\n  friend C<U> operator+(const C<U>& lhs, const C<U>& rhs);\n};\ntemplate <typename T>\nC<T> operator+(const C<T>& lhs, const C<T>& rhs) {\n  return C<T>(lhs.x_ + rhs.x_);\n}\n```", "```cpp\n// Example 16\ntemplate <typename T> class C {\n  int x_;\n  public:\n  C(int x) : x_(x) {}\n  template <typename U>\n  friend C<U> operator+(const C<U>& lhs, const C<U>& rhs) {\n    return C<U>(lhs.x_ + rhs.x_);\n  }\n};\n```", "```cpp\nC<int> x(1), y(2);\nC<int> z = x + y; // So far so good...\n```", "```cpp\nC<int> x(1), y(2);\nC<int> z1 = x + 2; // This does not compile!\nC<int> z2 = 1 + 2; // Neither does this!\n```", "```cpp\n// Example 17\ntemplate <typename T> class C {\n  int x_;\n  public:\n  C(int x) : x_(x) {}\n  friend C operator+(const C& lhs, const C& rhs) {\n    return C(lhs.x_ + rhs.x_);\n  }\n};\n```", "```cpp\nC<int> x(1), y(2);\nC<int> z1 = x + y; // This works\nC<int> z2 = x + 2; // and this too\nC<int> z3 = 1 + 2; // so does this\n```", "```cpp\n// Example 18\nnamespace NS {\ntemplate <typename T> class C {\n  int x_;\n  public:\n  C(int x) : x_(x) {}\n  friend C operator+(const C& lhs, const C& rhs) {\n    return C(lhs.x_ + rhs.x_);\n  }\n  friend std::ostream&\n  operator<<(std::ostream& out, const C& c) {\n    out << c.x_;\n    return out;\n  }\n};\n} // namespace NS\n```", "```cpp\nNS::C<int> x(1), y(2);\nstd::cout << (x + y) << std::endl;\n```", "```cpp\nauto p = &NS::C<int>::operator+; // Does not compile\n```", "```cpp\n// Example 19\ntemplate <typename D> class B {\n  public:\n  friend bool operator!=(const D& lhs, const D& rhs) {\n    return !(lhs == rhs);\n  }\n};\ntemplate <typename T> class C : public B<C<T>> {\n  T x_;\n  public:\n  C(T x) : x_(x) {}\n  friend bool operator==(const C& lhs, const C& rhs) {\n    return lhs.x_ == rhs.x_;\n  }\n};\n```", "```cpp\n// Example 20\ntemplate <typename D> class B {\n  public:\n  friend D operator+(const D& lhs, const D& rhs) {\n    D res(lhs);\n    res += rhs; // Convert += to +\n    return res;\n  }\n  friend std::ostream&\n  operator<<(std::ostream& out, const D& d) {\n    d.print(out);\n    return out;\n  }\n};\ntemplate <typename T> class C : public B<C<T>> {\n  T x_;\n  public:\n  C(T x) : x_(x) {}\n  C operator+=(const C& incr) {\n    x_ += incr.x_;\n    return *this;\n  }\n  void print(std::ostream& out) const {\n    out << x_;\n  }\n};\n```"]