<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-244">
    <a id="_idTextAnchor243">
    </a>
    
     12
    
   </h1>
   <h1 id="_idParaDest-245">
    <a id="_idTextAnchor244">
    </a>
    
     Sanitizing and Testing Asynchronous Software
    
   </h1>
   <p>
    <strong class="bold">
     
      Testing
     
    </strong>
    
     is the process
    
    <a id="_idIndexMarker887">
    </a>
    
     of evaluating and verifying that a software solution does what it’s meant to do, validating its quality and ensuring that user requirements are met.
    
    
     With proper testing, we can prevent bugs from happening and
    
    
     
      improve performance.
     
    
   </p>
   <p>
    
     In this chapter, we will
    
    <a id="_idIndexMarker888">
    </a>
    
     explore several techniques to test asynchronous software, mainly using the
    
    <strong class="bold">
     
      GoogleTest
     
    </strong>
    
     library and sanitizers available from
    
    <strong class="bold">
     
      GNU Compiler Collection
     
    </strong>
    
     (
    
    <strong class="bold">
     
      GCC
     
    </strong>
    
     ) and
    
    <strong class="bold">
     
      Clang
     
    </strong>
    
     compilers.
    
    
     Some prior knowledge in unit testing is required.
    
    
     In the
    
    <em class="italic">
     
      Further reading
     
    </em>
    
     section at
    
    <a id="_idIndexMarker889">
    </a>
    
     the end of this chapter, you can find some references
    
    <a id="_idIndexMarker890">
    </a>
    
     that could be useful to refresh and expand your knowledge in
    
    
     
      these areas.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Sanitizing code to analyze the software and find
     
     
      
       potential issues
      
     
    </li>
    <li>
     
      Testing
     
     
      
       asynchronous code
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-246">
    <a id="_idTextAnchor245">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     For this chapter, we will
    
    <a id="_idIndexMarker891">
    </a>
    
     need to install
    
    <strong class="bold">
     
      GoogleTest
     
    </strong>
    
     (
    
    <a href="https://google.github.io/googletest">
     
      https://google.github.io/googletest
     
    </a>
    
     ) to compile some of
    
    
     
      the examples.
     
    
   </p>
   <p>
    
     Some examples need a compiler supporting C++20.
    
    
     Therefore, check the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section in
    
    <a href="B22219_03.xhtml#_idTextAnchor051">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     , as it includes some guidance on how to install GCC 13 and Clang
    
    
     
      8 compilers.
     
    
   </p>
   <p>
    
     You can find all the complete code in the following
    
    
     
      GitHub repository:
     
    
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     
      
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      
     
    </a>
   </p>
   <p>
    
     The examples for this chapter are located under the
    
    <strong class="source-inline">
     
      Chapter_12
     
    </strong>
    
     folder.
    
    
     All source code files can be compiled using CMake
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
$ cmake . &amp;&amp; cmake —build .</pre>
   <p>
    
     Executable binaries will be generated under the
    
    
     <strong class="source-inline">
      
       bin
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <h1 id="_idParaDest-247">
    <a id="_idTextAnchor246">
    </a>
    
     Sanitizing code to analyze the software and find 
potential issues
    
   </h1>
   <p>
    <strong class="bold">
     
      Sanitizers
     
    </strong>
    
     are tools, originally developed by Google, used to detect and prevent various types
    
    <a id="_idIndexMarker892">
    </a>
    
     of issues or security vulnerabilities in code, helping developers catch bugs early in the development process, reducing the cost of issues being fixed late, and increasing software stability
    
    
     
      and security.
     
    
   </p>
   <p>
    
     Sanitizers are usually integrated into development environments and are usually enabled
    
    <a id="_idIndexMarker893">
    </a>
    
     during manual testing or when running unit tests,
    
    <strong class="bold">
     
      continuous integration
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CI
     
    </strong>
    
     ) pipelines, or code
    
    
     
      review pipelines.
     
    
   </p>
   <p>
    
     C++ compilers, such as GCC and Clang, have compiler options to generate code when building the program to track the execution at runtime and report errors and vulnerabilities.
    
    
     They are implemented in Clang from version 3.1 and GCC from
    
    
     
      version 4.8.
     
    
   </p>
   <p>
    
     As extra instructions are injected into the program’s binary code, there is a performance penalty of around 1.5x to 4x slowdowns depending on the sanitizer type.
    
    
     Also, there is an overall memory overhead of 2x to 4x and a stack size increase of up to 3x.
    
    
     But note that slowdowns are much lower than the ones experienced when using other instrumentation
    
    <a id="_idIndexMarker894">
    </a>
    
     frameworks or dynamic analysis tools, such as
    
    <strong class="bold">
     
      Valgrind
     
    </strong>
    
     (
    
    <a href="https://valgrind.org">
     
      https://valgrind.org
     
    </a>
    
     ), which imposes a much higher slowdown of up to 50 times slower than production binaries.
    
    
     On the other hand, the benefit of using Valgrind is that no recompilation is needed.
    
    
     Both approaches only detect issues while the program is running and only on those code paths that the execution traverses.
    
    
     So, we need to ensure
    
    
     
      sufficient coverage.
     
    
   </p>
   <p>
    
     There are also static analysis tools and linters, useful for detecting issues during compilation and checking all the code that is being included in the program.
    
    
     For example, compilers, such as GCC and Clang, can perform extra checks and provide useful information by enabling the
    
    <strong class="source-inline">
     
      –Werror
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      –Wall
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      –
     
    </strong>
    
     <strong class="source-inline">
      
       pedantic
      
     </strong>
    
    
     
      options.
     
    
   </p>
   <p>
    
     There are also
    
    <a id="_idIndexMarker895">
    </a>
    
     open source alternatives, such as
    
    <strong class="bold">
     
      Cppcheck
     
    </strong>
    
     or
    
    <strong class="bold">
     
      Flawfinder
     
    </strong>
    
     , or commercial
    
    <a id="_idIndexMarker896">
    </a>
    
     solutions that
    
    <a id="_idIndexMarker897">
    </a>
    
     are free for open source projects, such
    
    <a id="_idIndexMarker898">
    </a>
    
     as
    
    <strong class="bold">
     
      PVS-Studio
     
    </strong>
    
     or
    
    <strong class="bold">
     
      Coverity Scan
     
    </strong>
    
     .
    
    
     Other
    
    <a id="_idIndexMarker899">
    </a>
    
     solutions, such as
    
    <strong class="bold">
     
      SonarQube
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      CodeSonar
     
    </strong>
    
     , or
    
    <strong class="bold">
     
      OCLint
     
    </strong>
    
     , can be
    
    <a id="_idIndexMarker900">
    </a>
    
     used in
    
    <strong class="bold">
     
      continuous integration / continuous delivery
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CI/CD
     
    </strong>
    
     ) pipelines
    
    <a id="_idIndexMarker901">
    </a>
    
     for ongoing
    
    
     
      quality tracking.
     
    
   </p>
   <p>
    
     In this
    
    <a id="_idIndexMarker902">
    </a>
    
     section, we will focus on sanitizers, which can be enabled by passing some special options to
    
    
     
      the compiler.
     
    
   </p>
   <h2 id="_idParaDest-248">
    <a id="_idTextAnchor247">
    </a>
    
     Compiler options
    
   </h2>
   <p>
    
     To enable
    
    <a id="_idIndexMarker903">
    </a>
    
     sanitizers, we need to pass some compiler options when compiling
    
    
     
      the program.
     
    
   </p>
   <p>
    
     The main option is
    
    <strong class="source-inline">
     
      --fsanitize=sanitizer_name
     
    </strong>
    
     , where
    
    <strong class="source-inline">
     
      sanitizer_name
     
    </strong>
    
     is one of the
    
    
     
      following options:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       address
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker904">
     </a>
     
      is for
     
     <strong class="bold">
      
       AddressSanitizer
      
     </strong>
     
      (
     
     <strong class="bold">
      
       ASan
      
     </strong>
     
      ), to detect memory errors such as buffer overflows and
     
     
      
       use-after-free bugs
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       thread
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker905">
     </a>
     
      is for
     
     <strong class="bold">
      
       ThreadSanitizer
      
     </strong>
     
      (
     
     <strong class="bold">
      
       TSan
      
     </strong>
     
      ), to identify data races and other thread synchronization issues in multi-threaded programs by monitoring
     
     
      
       thread interactions
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       leak
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker906">
     </a>
     
      is for
     
     <strong class="bold">
      
       LeakSanitizer
      
     </strong>
     
      (
     
     <strong class="bold">
      
       LSan
      
     </strong>
     
      ), to spot memory leaks by tracking memory allocations and ensuring that all allocated memory is
     
     
      
       properly freed
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       memory
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker907">
     </a>
     
      is for
     
     <strong class="bold">
      
       MemorySanitizer
      
     </strong>
     
      (
     
     <strong class="bold">
      
       MSan
      
     </strong>
     
      ), to uncover the use of
     
     
      
       uninitialized memory
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       undefined
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker908">
     </a>
     
      is for
     
     <strong class="bold">
      
       UndefinedBehaviorSanitizer
      
     </strong>
     
      (
     
     <strong class="bold">
      
       UBSan
      
     </strong>
     
      ), to detect undefined behavior, such as integer overflows, invalid type casts, and other
     
     
      
       erroneous operations
      
     
    </li>
   </ul>
   <p>
    
     Clang also includes
    
    <strong class="source-inline">
     
      dataflow
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      cfi
     
    </strong>
    
     (control flow integrity),
    
    <strong class="source-inline">
     
      safe_stack
     
    </strong>
    
     ,
    
    
     
      and
     
    
    
     <strong class="source-inline">
      
       realtime
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     GCC adds
    
    <strong class="source-inline">
     
      kernel-address
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      hwaddress
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      kernel-hwaddress
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      pointer-compare
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      pointer-subtract
     
    </strong>
    
     ,
    
    
     
      and
     
    
    
     <strong class="source-inline">
      
       shadow-call-stack
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     As this list and
    
    <a id="_idIndexMarker909">
    </a>
    
     flag behavior can change over time, it’s recommended to check the compilers’
    
    
     
      official documentation.
     
    
   </p>
   <p>
    
     Additional flags might
    
    
     
      be needed:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       -fno-omit-frame-pointer
      
     </strong>
     
      : A
     
     <strong class="bold">
      
       frame pointer
      
     </strong>
     
      is a register used by compilers
     
     <a id="_idIndexMarker910">
     </a>
     
      to track the current stack frame, containing, among other information, the base address of the current function.
     
     
      Omitting frame pointers might increase the performance of the program but at the cost of making debugging significantly harder; it makes it more difficult to locate local variables and reconstruct
     
     
      
       stack traces.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       -g
      
     </strong>
     
      : Include debug information and display filenames and line numbers in the warning messages.
     
     
      If the debugger GDB is used, the
     
     <strong class="source-inline">
      
       –ggdb
      
     </strong>
     
      option might be desirable as the compiler can produce more expressive symbols to be used when debugging.
     
     
      Also, a level can be specified by using
     
     <strong class="source-inline">
      
       –g[level]
      
     </strong>
     
      , with
     
     <strong class="source-inline">
      
       [level]
      
     </strong>
     
      being a value from
     
     <strong class="source-inline">
      
       0
      
     </strong>
     
      to
     
     <strong class="source-inline">
      
       3
      
     </strong>
     
      , adding more debug information at each level increase.
     
     
      The default level
     
     
      
       is
      
     
     
      <strong class="source-inline">
       
        2
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       –fsanitize-recover
      
     </strong>
     
      : These options cause the sanitizer to attempt to continue running the program as if no error
     
     
      
       was detected.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       –fno-sanitize-recover
      
     </strong>
     
      : The sanitizer will detect only the first error, and the program will exit with a non-zero
     
     
      
       exit code.
      
     
    </li>
   </ul>
   <p>
    
     To keep a reasonable performance, we might need to adjust the optimization level by specifying the
    
    <strong class="source-inline">
     
      –O[num]
     
    </strong>
    
     option.
    
    
     Different sanitizers work best up to a certain level of optimization.
    
    
     It’s best to start with
    
    <strong class="source-inline">
     
      –O0
     
    </strong>
    
     and, if the slowdown is significant, try to increase to
    
    <strong class="source-inline">
     
      –O1
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      –O2
     
    </strong>
    
     , and so on.
    
    
     Also, as different sanitizers and compilers recommend specific optimization levels, check
    
    
     
      their documentation.
     
    
   </p>
   <p>
    
     When using Clang, to make stack traces easy to understand and let sanitizers convert addresses into
    
    <a id="_idIndexMarker911">
    </a>
    
     source code locations, apart from using the flags mentioned earlier, we can also set the specific environment variable,
    
    <strong class="source-inline">
     
      [X]SAN_SYMBOLIZER_PATH
     
    </strong>
    
     , to the location of
    
    <strong class="source-inline">
     
      llvm-symbolizer
     
    </strong>
    
     (with
    
    <strong class="source-inline">
     
      [X]
     
    </strong>
    
     being
    
    <strong class="source-inline">
     
      A
     
    </strong>
    
     for AddressSatinizer,
    
    <strong class="source-inline">
     
      L
     
    </strong>
    
     for LSan,
    
    <strong class="source-inline">
     
      M
     
    </strong>
    
     for MSan, and so on).
    
    
     We can also include this location in the
    
    <strong class="source-inline">
     
      PATH
     
    </strong>
    
     environment variable.
    
    
     Here is an example of setting the
    
    <strong class="source-inline">
     
      PATH
     
    </strong>
    
     variables
    
    <a id="_idIndexMarker912">
    </a>
    
     when
    
    
     
      using
     
    
    
     <strong class="bold">
      
       AddressSatinizer
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="console">
export ASAN_SYMBOLIZER_PATH=`which llvm-symbolizer`
export PATH=$ASAN_SYMBOLIZER_PATH:$PATH</pre>
   <p>
    
     Note that enabling
    
    <strong class="source-inline">
     
      –Werror
     
    </strong>
    
     with certain sanitizers can lead to false positives.
    
    
     Also, other compiler flags might be needed, but warning messages during execution will show that a problem is happening and will be evident that a flag is needed.
    
    
     Check the sanitizers’ and compilers’ documentation to find which flag to use in
    
    
     
      those cases.
     
    
   </p>
   <h3>
    
     Avoiding sanitizing part of the code
    
   </h3>
   <p>
    
     Sometimes, we
    
    <a id="_idIndexMarker913">
    </a>
    
     may want to silence some sanitizer warning and skip sanitizing some functions due to the following reasons: it is a well-known issue, the function is correct, it’s a false positive, this function needs to speed up, or it is an issue in a third-party library.
    
    
     In those cases, we can use suppression files or exclude the code area by using some macro instructions.
    
    
     There is also a blacklist mechanism, but as it is deprecated in favor of suppression files; we will not comment on
    
    
     
      it here.
     
    
   </p>
   <p>
    
     With suppression files, we just need to create a text file listing the areas of the code where we don’t want the sanitizer to run.
    
    
     Each line consists of a pattern following a specific
    
    <a id="_idIndexMarker914">
    </a>
    
     format depending on the sanitizer, but typically, the structure is
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
type:location_pattern</pre>
   <p>
    
     Here,
    
    <strong class="source-inline">
     
      type
     
    </strong>
    
     indicates the type of suppression, for example, the
    
    <strong class="source-inline">
     
      leak
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      race
     
    </strong>
    
     values, and
    
    <strong class="source-inline">
     
      location_pattern
     
    </strong>
    
     is a regular expression matching the function or library name to suppress.
    
    
     Here is an example of a suppression file for an ASan, explained in the
    
    
     
      next section:
     
    
   </p>
   <pre class="console">
# Suppress known memory leaks in third-party function Func1 in library Lib1
leak:Lib1::Func1
# Ignore false-positive from function Func2 in library Lib2
race:Lib2::Func2
# Suppress issue from libc
leak:/usr/lib/libc.so.*</pre>
   <p>
    
     Let’s call this file
    
    <strong class="source-inline">
     
      myasan.supp
     
    </strong>
    
     .
    
    
     Then, compile and pass this suppression file to the sanitizer via
    
    <strong class="source-inline">
     
      [X]SAN_OPTIONS
     
    </strong>
    
     
      as follows:
     
    
   </p>
   <pre class="console">
$ clang++ -O0 -g -fsanitize=address -fno-omit-frame-pointer test.cpp –o test
$ ASAN_OPTIONS=suppressions=myasan.supp ./test</pre>
   <p>
    
     We can also use macros in source code to exclude specific functions to be sanitized by using
    
    <strong class="source-inline">
     
      __attribute__((no_sanitize("&lt;sanitizer_name&gt;")))
     
    </strong>
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
#if defined(__clang__) || defined (__GNUC__)
# define ATTRIBUTE_NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address))
#else
# define ATTRIBUTE_NO_SANITIZE_ADDRESS
#endif
...
ATTRIBUTE_NO_SANITIZE_ADDRESS
void ThisFunctionWillNotBeInstrumented() {...}</pre>
   <p>
    
     This technique
    
    <a id="_idIndexMarker915">
    </a>
    
     provides a fine-grained compile-time control over what should be instrumented by
    
    
     
      the sanitizer.
     
    
   </p>
   <p>
    
     Let’s now explore the most common types of code sanitizers, starting with one of the most relevant to check
    
    
     
      address misusages.
     
    
   </p>
   <h2 id="_idParaDest-249">
    <a id="_idTextAnchor248">
    </a>
    
     AddressSanitizer
    
   </h2>
   <p>
    
     The purpose of
    
    <a id="_idIndexMarker916">
    </a>
    
     ASan is to detect memory-related errors happening due to buffer overflows (heap, stack, and global) during out-of-bounds accesses of arrays, using a block of memory after being released with free or delete operations, and other
    
    
     
      memory leaks.
     
    
   </p>
   <p>
    
     Apart from setting
    
    <strong class="source-inline">
     
      -fsanitize=address
     
    </strong>
    
     and other flags recommended earlier, we can also use
    
    <strong class="source-inline">
     
      –fsanitize-address-use-after-scope
     
    </strong>
    
     to detect the memory used after moving out of scope or setting the
    
    <strong class="source-inline">
     
      ASAN_OPTIONS=option detect_stack_use_after_return=1
     
    </strong>
    
     environment variable to detect use
    
    
     
      after return.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      ASAN_OPTIONS
     
    </strong>
    
     can also be used to instruct the ASan to print the stack trace or set a log file
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
ASAN_OPTIONS=detect_stack_use_after_return=1,print_stacktrace=1,log_path=asan.log</pre>
   <p>
    
     Clang on Linux has full support for ASan, followed by GCC on Linux.
    
    
     By default, ASan is disabled as it adds extra
    
    
     
      runtime overhead.
     
    
   </p>
   <p>
    
     Also, ASan processes all calls to
    
    <strong class="source-inline">
     
      glibc
     
    </strong>
    
     – the GNU C library providing the core libraries for GNU systems.
    
    
     However, this is not the case with other libraries, so it’s recommended to recompile such libraries with the
    
    <strong class="source-inline">
     
      –fsanitize=address
     
    </strong>
    
     option.
    
    
     As commented earlier, with Valgrind, recompilation is
    
    
     
      not required.
     
    
   </p>
   <p>
    
     ASan can be
    
    <a id="_idIndexMarker917">
    </a>
    
     combined with UBSan, which we will see later, but It slows down the performance by
    
    
     
      around 50%.
     
    
   </p>
   <p>
    
     If we want a more aggressive diagnostics sanitizing, we can use the following
    
    
     
      flag combination:
     
    
   </p>
   <pre class="console">
ASAN_OPTIONS=strict_string_checks=1:detect_stack_use_after_return=1:check_initialization_order=1:strict_init_order=1</pre>
   <p>
    
     Let’s see two examples of using ASan to detect common software issues, with memory being used after being freed and detecting
    
    
     
      buffer overflows.
     
    
   </p>
   <h3>
    
     Memory usage after being freed
    
   </h3>
   <p>
    
     One common
    
    <a id="_idIndexMarker918">
    </a>
    
     issue in software is using memory after being freed.
    
    
     In this example, memory allocated in the heap is being used after
    
    
     
      being deleted:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;memory&gt;
int main() {
  auto arr = new int[100];
  delete[] arr;
  std::cout &lt;&lt; "arr[0] = " &lt;&lt; arr[0] &lt;&lt; '\n';
  return 0;
}</pre>
   <p>
    
     Let’s suppose that the previous source code is in a file called
    
    <strong class="source-inline">
     
      test.cpp
     
    </strong>
    
     .
    
    
     To enable ASan, we just compile the file using the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ clang++ -fsanitize=address -fno-omit-frame-pointer -g -O0 –o test test.cpp</pre>
   <p>
    
     Then, executing
    
    <a id="_idIndexMarker919">
    </a>
    
     the resulting output
    
    <strong class="source-inline">
     
      test
     
    </strong>
    
     program, we obtain the following output (note that the output is simplified, only showing relevant content and might differ from different compiler versions and
    
    
     
      execution context):
     
    
   </p>
   <pre class="console">
ERROR: AddressSanitizer: heap-use-after-free on address 0x514000000040 at pc 0x63acc82a0bec bp 0x7fff2d096c60 sp 0x7fff2d096c58
READ of size 4 at 0x514000000040 thread T0
    #0 0x63acc82a0beb in main test.cpp:7:31
0x514000000040 is located 0 bytes inside of 400-byte region [0x514000000040,0x5140000001d0)
freed by thread T0 here:
    #0 0x63acc829f161 in operator delete[](void*) (/mnt/StorePCIE/Projects/Books/Packt/Book/Code/build/bin/Chapter_11/11x02-ASAN_heap_use_after_free+0x106161) (BuildId: 7bf8fe6b1f86a8b587fbee39ae3a5ced3e866931)
previously allocated by thread T0 here:
    #0 0x63acc829e901 in operator new[](unsigned long) (/mnt/StorePCIE/Projects/Books/Packt/Book/Code/build/bin/Chapter_11/11x02-ASAN_heap_use_after_free+0x105901) (BuildId: 7bf8fe6b1f86a8b587fbee39ae3a5ced3e866931)
SUMMARY: AddressSanitizer: heap-use-after-free test.cpp:7:31 in main</pre>
   <p>
    
     The output shows that the ASan was applied and detected a heap-use-after-free error.
    
    
     This error is happening in the
    
    <strong class="source-inline">
     
      T0
     
    </strong>
    
     thread (main thread).
    
    
     The output also points to the code where that memory region was allocated, and later freed, and its size (400
    
    
     
      bytes region).
     
    
   </p>
   <p>
    
     These kinds
    
    <a id="_idIndexMarker920">
    </a>
    
     of errors not only happen with heap memory but also with memory regions allocated in the stack or global area.
    
    
     ASan can be used to detect these kinds of issues, such as
    
    
     
      memory overflows.
     
    
   </p>
   <h3>
    
     Memory overflows
    
   </h3>
   <p>
    
     Memory overflows, also known as buffer overflows or overruns, happen when some data is written in a memory address past the allocated memory of
    
    
     
      a buffer.
     
    
   </p>
   <p>
    
     The following example shows a heap
    
    
     
      memory overflow:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
int main() {
  auto arr = new int[100];
  arr[0] = 0;
  int res = arr[100];
  std::cout &lt;&lt; "res = " &lt;&lt; res &lt;&lt; '\n';
  delete[] arr;
  return 0;
}</pre>
   <p>
    
     After compiling and running the resulting program, this is
    
    
     
      the output:
     
    
   </p>
   <pre class="console">
ERROR: AddressSanitizer: heap-buffer-overflow on address 0x5140000001d0 at pc 0x582953d2ac07 bp 0x7ffde9d58910 sp 0x7ffde9d58908
READ of size 4 at 0x5140000001d0 thread T0
    #0 0x582953d2ac06 in main test.cpp:6:13
0x5140000001d0 is located 0 bytes after 400-byte region [0x514000000040,0x5140000001d0)
allocated by thread T0 here:
    #0 0x582953d28901 in operator new[](unsigned long) (test+0x105901) (BuildId: 82a16fc86e01bc81f6392d4cbcad0fe8f78422c0)
    #1 0x582953d2ab78 in main test.cpp:4:14
(test+0x2c374) (BuildId: 82a16fc86e01bc81f6392d4cbcad0fe8f78422c0)
SUMMARY: AddressSanitizer: heap-buffer-overflow test.cpp:6:13 in main</pre>
   <p>
    
     As we
    
    <a id="_idIndexMarker921">
    </a>
    
     can see from the output, now ASan reports a heap-buffer-overflow error in the main thread (
    
    <strong class="source-inline">
     
      T0
     
    </strong>
    
     ) when accessing a memory address beyond a 400-byte region (the
    
    
     <strong class="source-inline">
      
       arr
      
     </strong>
    
    
     
      variable).
     
    
   </p>
   <p>
    
     A sanitizer that is integrated into ASan is LSan.
    
    
     Let’s learn now how to detect memory leaks using
    
    
     
      this sanitizer.
     
    
   </p>
   <h2 id="_idParaDest-250">
    <a id="_idTextAnchor249">
    </a>
    
     LeakSanitizer
    
   </h2>
   <p>
    
     LSan is
    
    <a id="_idIndexMarker922">
    </a>
    
     used to detect memory leaks happening when memory has been allocated but not
    
    
     
      properly freed.
     
    
   </p>
   <p>
    
     LSan is integrated into ASan and enabled by default on Linux systems.
    
    
     It can be enabled on macOS by using
    
    <strong class="source-inline">
     
      ASAN_OPTIONS=detect_leaks=1
     
    </strong>
    
     .
    
    
     To disable it, just
    
    
     
      set
     
    
    
     <strong class="source-inline">
      
       detect_leaks=0
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     If the
    
    <strong class="source-inline">
     
      –fsanitize=leak
     
    </strong>
    
     option is used, the program will link against a subset of the ASan supporting LSan, disabling compile-time instrumentation and reducing the ASan slowdown.
    
    
     Note that this mode is not as well tested as the
    
    
     
      default mode.
     
    
   </p>
   <p>
    
     Let’s
    
    <a id="_idIndexMarker923">
    </a>
    
     see an example of
    
    
     
      memory leak:
     
    
   </p>
   <pre class="source-code">
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
int main() {
    auto arr = new char[100];
    strcpy(arr, "Hello world!");
    std::cout &lt;&lt; "String = " &lt;&lt; arr &lt;&lt; '\n';
    return 0;
}</pre>
   <p>
    
     In this example, 100 bytes are allocated (the
    
    <strong class="source-inline">
     
      arr
     
    </strong>
    
     variable) but
    
    
     
      never freed.
     
    
   </p>
   <p>
    
     To enable LSan, we just compile the file using the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ clang++ -fsanitize=leak -fno-omit-frame-pointer -g -O2 –o test test.cpp</pre>
   <p>
    
     Running the resulting test binary, we obtain the
    
    
     
      following result:
     
    
   </p>
   <pre class="console">
ERROR: LeakSanitizer: detected memory leaks
Direct leak of 100 byte(s) in 1 object(s) allocated from:
    #0 0x5560ba9a017c in operator new[](unsigned long) (test+0x3417c) (BuildId: 2cc47a28bb898b4305d90c048c66fdeec440b621)
    #1 0x5560ba9a2564 in main test.cpp:6:16
SUMMARY: LeakSanitizer: 100 byte(s) leaked in 1 allocation(s).</pre>
   <p>
    
     LSan
    
    <a id="_idIndexMarker924">
    </a>
    
     correctly reports that a memory region of 100 bytes was allocated by using the operator
    
    <strong class="source-inline">
     
      new
     
    </strong>
    
     but
    
    
     
      never deleted.
     
    
   </p>
   <p>
    
     As this book explores multithreading and asynchronous programming, let’s learn now about a sanitizer to detect data races and other thread
    
    
     
      issues: TSan.
     
    
   </p>
   <h2 id="_idParaDest-251">
    <a id="_idTextAnchor250">
    </a>
    
     ThreadSanitizer
    
   </h2>
   <p>
    
     TSan is used to detect threading issues, especially data races and synchronization issues.
    
    
     It cannot
    
    <a id="_idIndexMarker925">
    </a>
    
     be combined with ASan or LSan.
    
    
     TSan is the sanitizer most aligned with the content of
    
    
     
      this book.
     
    
   </p>
   <p>
    
     This sanitizer is enabled by specifying the
    
    <strong class="source-inline">
     
      –fsanitize=thread
     
    </strong>
    
     compiler option and its behavior can be modified by using the
    
    <strong class="source-inline">
     
      TSAN_OPTIONS
     
    </strong>
    
     environment variable.
    
    
     For example, if we want to stop after the first error, just use
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
TSAN_OPTIONS=halt_on_error=1</pre>
   <p>
    
     Also, for a reasonable performance, use the compiler’s
    
    <strong class="source-inline">
     
      –
     
    </strong>
    
     <strong class="source-inline">
      
       O2
      
     </strong>
    
    
     
      option.
     
    
   </p>
   <p>
    
     TSan only reports race conditions happening at runtime, thus it won’t alert on race conditions present in code paths not executed at runtime.
    
    
     Therefore, we need to design tests that provide good coverage and use a
    
    
     
      realistic workload.
     
    
   </p>
   <p>
    
     Let’s see some examples of TSan detecting data races.
    
    
     In the next example, we’ll do this by using a global variable without protecting its access with
    
    
     
      a mutex:
     
    
   </p>
   <pre class="source-code">
#include &lt;thread&gt;
int globalVar{0};
void increase() {
  globalVar++;
}
void decrease() {
  globalVar--;
}
int main() {
  std::thread t1(increase);
  std::thread t2(decrease);
  t1.join();
  t2.join();
  return 0;
}</pre>
   <p>
    
     After
    
    <a id="_idIndexMarker926">
    </a>
    
     compiling the program, use the following command to
    
    
     
      enable TSan:
     
    
   </p>
   <pre class="console">
$ clang++ -fsanitize=thread -fno-omit-frame-pointer -g -O2 –o test test.cpp</pre>
   <p>
    
     Running the resulting program generates the
    
    
     
      following output:
     
    
   </p>
   <pre class="console">
WARNING: ThreadSanitizer: data race (pid=31692)
  Write of size 4 at 0x5932b0585ae8 by thread T2:
    #0 decrease() test.cpp:10:12 (test+0xe0b32) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)
  Previous write of size 4 at 0x5932b0585ae8 by thread T1:
    #0 increase() test.cpp:6:12 (test+0xe0af2) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)
  Thread T2 (tid=31695, running) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6062f) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)
  Thread T1 (tid=31694, finished) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6062f) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)
SUMMARY: ThreadSanitizer: data race test.cpp:10:12 in decrease()
ThreadSanitizer: reported 1 warnings</pre>
   <p>
    
     From the
    
    <a id="_idIndexMarker927">
    </a>
    
     output, it’s clear that there is a data race when accessing
    
    <strong class="source-inline">
     
      globalVar
     
    </strong>
    
     in the
    
    <strong class="source-inline">
     
      increase()
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       decrease()
      
     </strong>
    
    
     
      functions.
     
    
   </p>
   <p>
    
     If we decide to use GCC instead of Clang, the following error can be reported when running the
    
    
     
      resulting program:
     
    
   </p>
   <pre class="console">
FATAL: ThreadSanitizer: unexpected memory mapping 0x603709d10000-0x603709d11000</pre>
   <p>
    
     This
    
    <a id="_idIndexMarker928">
    </a>
    
     memory mapping issue is caused by a security feature called
    
    <strong class="bold">
     
      address space layout randomization
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ASLR
     
    </strong>
    
     ), a memory-protection technique used by the OS to protect against buffer overflow attacks by randomizing the address space
    
    
     
      of processes.
     
    
   </p>
   <p>
    
     One solution is to reduce ASLR by using the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ sudo sysctl vm.mmap_rnd_bits=30</pre>
   <p>
    
     The value passed to
    
    <strong class="source-inline">
     
      vm.mmap_rnd_bits
     
    </strong>
    
     (
    
    <strong class="source-inline">
     
      30
     
    </strong>
    
     in the preceding command) can be reduced further if the error is still happening.
    
    
     To check that the value is correctly set, just run
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
$ sudo sysctl vm.mmap_rnd_bits
vm.mmap_rnd_bits = 30</pre>
   <p>
    
     Note that this change is not permanent.
    
    
     Therefore, when the machine reboots, its value will be set to the default one.
    
    
     To persist this change, add
    
    <strong class="source-inline">
     
      m.mmap_rnd_bits=30
     
    </strong>
    
     
      to
     
    
    
     <strong class="source-inline">
      
       /etc/sysctl.conf
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     But that reduces the security of the system, so it might be preferable to temporarily disable ASLR for a particular program by using the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ setarch `uname -m` -R ./test</pre>
   <p>
    
     Running
    
    <a id="_idIndexMarker929">
    </a>
    
     the preceding command will show a similar output to what was shown earlier when compiling
    
    
     
      with Clang.
     
    
   </p>
   <p>
    
     Let’s move to another example where a
    
    <strong class="source-inline">
     
      std::map
     
    </strong>
    
     object is accessed without a mutex.
    
    
     Even if the map is being accessed for different key values, as writing to a
    
    <strong class="source-inline">
     
      std::map
     
    </strong>
    
     invalidates their iterators, that can cause
    
    
     
      data races:
     
    
   </p>
   <pre class="source-code">
#include &lt;map&gt;
#include &lt;thread&gt;
std::map&lt;int,int&gt; m;
void Thread1() {
  m[123] = 1;
}
void Thread2() {
  m[345] = 0;
}
int main() {
  std::jthread t1(Thread1);
  std::jthread t2(Thread1);
  return 0;
}</pre>
   <p>
    
     Compiling and
    
    <a id="_idIndexMarker930">
    </a>
    
     running the resulting binary generates a large output with three warnings.
    
    
     Here, we only show the most relevant lines of the first warning (other warnings
    
    
     
      are similar):
     
    
   </p>
   <pre class="console">
WARNING: ThreadSanitizer: data race (pid=8907)
  Read of size 4 at 0x720c00000020 by thread T2:
  Previous write of size 8 at 0x720c00000020 by thread T1:
  Location is heap block of size 40 at 0x720c00000000 allocated by thread T1:
  Thread T2 (tid=8910, running) created by main thread at:
  Thread T1 (tid=8909, finished) created by main thread at:
SUMMARY: ThreadSanitizer: data race test.cpp:11:3 in Thread2()</pre>
   <p>
    
     The TSan warnings are flagged when both the
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     threads are writing into the
    
    
     
      map,
     
    
    
     <strong class="source-inline">
      
       m
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In the next example, there is only one auxiliary thread accessing the map via a pointer, but this thread is competing against the main thread to access and use the map.
    
    
     The
    
    <strong class="source-inline">
     
      t
     
    </strong>
    
     thread
    
    <a id="_idIndexMarker931">
    </a>
    
     accesses the map,
    
    <strong class="source-inline">
     
      m
     
    </strong>
    
     , to change the value for the
    
    <strong class="source-inline">
     
      foo
     
    </strong>
    
     key; meanwhile, the main thread prints its value to
    
    
     
      the console:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;map&gt;
#include &lt;string&gt;
typedef std::map&lt;std::string, std::string&gt; map_t;
void *func(void *p) {
  map_t&amp; m = *static_cast&lt;map_t*&gt;(p);
  m["foo"] = "bar";
  return 0;
}
int main() {
  map_t m;
  std::thread t(func, &amp;m);
  std::cout &lt;&lt; "foo = " &lt;&lt; m["foo"] &lt;&lt; '\n';
  t.join();
  return 0;
}</pre>
   <p>
    
     Compiling and running this example generates a massive output with seven TSan warnings.
    
    
     Here, we only show the first warning.
    
    
     Feel free to check the complete report by compiling
    
    <a id="_idIndexMarker932">
    </a>
    
     and running the example in the
    
    
     
      GitHub repository:
     
    
   </p>
   <pre class="console">
WARNING: ThreadSanitizer: data race (pid=10505)
  Read of size 8 at 0x721800003028 by main thread:
    #8 main test.cpp:17:28 (test+0xe1d75) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
  Previous write of size 8 at 0x721800003028 by thread T1:
    #0 operator new(unsigned long) &lt;null&gt; (test+0xe0c3b) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
    #9 func(void*) test.cpp:10:3 (test+0xe1bb7) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
  Location is heap block of size 96 at 0x721800003000 allocated by thread T1:
    #0 operator new(unsigned long) &lt;null&gt; (test+0xe0c3b) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
    #9 func(void*) test.cpp:10:3 (test+0xe1bb7) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
  Thread T1 (tid=10507, finished) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x616bf) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
SUMMARY: ThreadSanitizer: data race test.cpp:17:28 in main
ThreadSanitizer: reported 7 warnings</pre>
   <p>
    
     From the output, TSan is warning about a data race when accessing a
    
    <strong class="source-inline">
     
      std::map
     
    </strong>
    
     object allocated in the heap.
    
    
     That object is the
    
    
     
      map
     
    
    
     <strong class="source-inline">
      
       m
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     However, TSan can not only detect data races due to a lack of mutexes but can also report when a variable must
    
    
     
      be atomic.
     
    
   </p>
   <p>
    
     The next example shows that scenario.
    
    
     The
    
    <strong class="source-inline">
     
      RefCountedObject
     
    </strong>
    
     class defines objects that can keep a reference count of how many objects of that class have been created.
    
    
     Smart pointers
    
    <a id="_idIndexMarker933">
    </a>
    
     follow this idea to delete the underlying allocated memory on destruction when the counter reaches the value
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     .
    
    
     In this example, we are only showing the
    
    <strong class="source-inline">
     
      Ref()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Unref()
     
    </strong>
    
     functions that increment and decrement the reference count variable,
    
    <strong class="source-inline">
     
      ref_
     
    </strong>
    
     .
    
    
     To avoid issues in a multithreading environment,
    
    <strong class="source-inline">
     
      ref_
     
    </strong>
    
     must be an atomic variable.
    
    
     As here, this is not the case, and the
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     threads are modifying
    
    <strong class="source-inline">
     
      ref_
     
    </strong>
    
     , a possible data race
    
    
     
      can happen:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;thread&gt;
class RefCountedObject {
   public:
    void Ref() {
        ++ref_;
    }
    void Unref() {
        --ref_;
    }
   private:
    // ref_ should be atomic to avoid synchronization issues
    int ref_{0};
};
int main() {
  RefCountedObject obj;
  std::jthread t1(&amp;RefCountedObject::Ref, &amp;obj);
  std::jthread t2(&amp;RefCountedObject::Unref, &amp;obj);
  return 0;
}</pre>
   <p>
    
     Compiling and
    
    <a id="_idIndexMarker934">
    </a>
    
     running this example shows the
    
    
     
      following output:
     
    
   </p>
   <pre class="console">
WARNING: ThreadSanitizer: data race (pid=32574)
  Write of size 4 at 0x7fffffffcc04 by thread T2:
    #0 RefCountedObject::Unref() test.cpp:12:9 (test+0xe1dd0) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
  Previous write of size 4 at 0x7fffffffcc04 by thread T1:
    #0 RefCountedObject::Ref() test.cpp:8:9 (test+0xe1c00) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
  Location is stack of main thread.
  Location is global '??' at 0x7ffffffdd000 ([stack]+0x1fc04)
  Thread T2 (tid=32577, running) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6164f) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
    #2 main test.cpp:23:16 (test+0xe1b94) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
  Thread T1 (tid=32576, finished) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6164f) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
    #2 main test.cpp:22:16 (test+0xe1b56) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
SUMMARY: ThreadSanitizer: data race test.cpp:12:9 in RefCountedObject::Unref()
ThreadSanitizer: reported 1 warnings</pre>
   <p>
    
     TSan output shows
    
    <a id="_idIndexMarker935">
    </a>
    
     that there is a data race condition happening in the
    
    <strong class="source-inline">
     
      Unref()
     
    </strong>
    
     function when
    
    <a id="_idIndexMarker936">
    </a>
    
     accessing a memory location previously modified by the
    
    
     <strong class="source-inline">
      
       Ref()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     Data races can
    
    <a id="_idIndexMarker937">
    </a>
    
     also happen in objects being initialized from several threads without any synchronization mechanism.
    
    
     In the following example, an object of type
    
    <strong class="source-inline">
     
      MyObj
     
    </strong>
    
     is being created in the
    
    <strong class="source-inline">
     
      init_object()
     
    </strong>
    
     function, and the global static pointer,
    
    <strong class="source-inline">
     
      obj
     
    </strong>
    
     , is assigned its address.
    
    
     As this pointer is not protected by a mutex, there is a data race happening when the
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     threads try to create an object and update the
    
    <strong class="source-inline">
     
      obj
     
    </strong>
    
     pointer from the
    
    <strong class="source-inline">
     
      func1()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      func2()
     
    </strong>
    
     
      functions respectively:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;thread&gt;
class MyObj {};
static MyObj *obj = nullptr;
void init_object() {
  if (!obj) {
    obj = new MyObj();
  }
}
void func1() {
  init_object();
}
void func2() {
  init_object();
}
int main() {
  std::thread t1(func1);
  std::thread t2(func2);
  t1.join();
  t2.join();
  return 0;
}</pre>
   <p>
    
     This is the
    
    <a id="_idIndexMarker938">
    </a>
    
     output after compiling and running
    
    
     
      this example:
     
    
   </p>
   <pre class="console">
WARNING: ThreadSanitizer: data race (pid=32826)
  Read of size 1 at 0x5663912cbae8 by thread T2:
    #0 func2() test.cpp (test+0xe0b68) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)
  Previous write of size 1 at 0x5663912cbae8 by thread T1:
    #0 func1() test.cpp (test+0xe0b3d) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)
  Location is global 'obj (.init)' of size 1 at 0x5663912cbae8 (test+0x150cae8)
  Thread T2 (tid=32829, running) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6062f) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)
  Thread T1 (tid=32828, finished) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6062f) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)
SUMMARY: ThreadSanitizer: data race test.cpp in func2()
ThreadSanitizer: reported 1 warnings</pre>
   <p>
    
     The output shows what we described earlier, a data race happening due to access to the
    
    <strong class="source-inline">
     
      obj
     
    </strong>
    
     global variable from
    
    <strong class="source-inline">
     
      func1()
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       func2()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     As the C++11 standard has officially deemed data races as undefined behavior, let’s see now how to use UBSan to detect undefined behavior issues in
    
    
     
      the program.
     
    
   </p>
   <h2 id="_idParaDest-252">
    <a id="_idTextAnchor251">
    </a>
    
     UndefinedBehaviorSanitizer
    
   </h2>
   <p>
    
     UBSan can
    
    <a id="_idIndexMarker939">
    </a>
    
     detect undefined behavior in code, for example, when shifting bits by an excessive amount, integer overflows, or misuse of null pointers.
    
    
     It can be enabled by specifying the
    
    <strong class="source-inline">
     
      –fsanitize=undefined
     
    </strong>
    
     option.
    
    
     Its behavior can be modified at runtime by setting the
    
    
     <strong class="source-inline">
      
       UBSAN_OPTIONS
      
     </strong>
    
    
     
      variable.
     
    
   </p>
   <p>
    
     Many errors that can be detected by UBSan are also detected by the compiler
    
    
     
      during compilation.
     
    
   </p>
   <p>
    
     Let’s see a
    
    
     
      simple example:
     
    
   </p>
   <pre class="source-code">
int main() {
  int val = 0x7fffffff;
  val += 1;
  return 0;
}</pre>
   <p>
    
     To compile the program and enable UBSan, use the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ clang++ -fsanitize=undefined -fno-omit-frame-pointer -g -O2 –o test test.cpp</pre>
   <p>
    
     Running the resulting program generates the
    
    
     
      following output:
     
    
   </p>
   <pre class="console">
test.cpp:3:7: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior test.cpp:3:7</pre>
   <p>
    
     The output is quite simple and self-explanatory; there is a signed integer
    
    
     
      overflow operation.
     
    
   </p>
   <p>
    
     Let’s now learn about another useful C++ sanitizer to detect uninitialized memory and other memory usage
    
    
     
      issues: MSan.
     
    
   </p>
   <h2 id="_idParaDest-253">
    <a id="_idTextAnchor252">
    </a>
    
     MemorySanitizer
    
   </h2>
   <p>
    
     MSan can detect uninitialized memory usage, for example, when using variables or pointers
    
    <a id="_idIndexMarker940">
    </a>
    
     before they have been assigned a value or address.
    
    
     It can also track uninitialized bits in
    
    
     
      a bitfield.
     
    
   </p>
   <p>
    
     To enable MSan, use the following
    
    
     
      compiler flags:
     
    
   </p>
   <pre class="console">
-fsanitize=memory -fPIE -pie -fno-omit-frame-pointer</pre>
   <p>
    
     It can also track each uninitialized value to the memory allocation from where it was created by specifying the
    
    <strong class="source-inline">
     
      -
     
    </strong>
    
     <strong class="source-inline">
      
       fsanitize-memory-track-origins
      
     </strong>
    
    
     
      option.
     
    
   </p>
   <p>
    
     GCC has no support for MSan, so the
    
    <strong class="source-inline">
     
      -fsanitize=memory
     
    </strong>
    
     flag is not valid when using
    
    
     
      this compiler.
     
    
   </p>
   <p>
    
     In the following example, the
    
    <strong class="source-inline">
     
      arr
     
    </strong>
    
     integer array is created, but only its position
    
    <strong class="source-inline">
     
      5
     
    </strong>
    
     is initialized.
    
    
     The value at position
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     is used when printing the message to the console, but this value is
    
    
     
      still uninitialized:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
int main() {
  auto arr = new int[10];
  arr[5] = 0;
  std::cout &lt;&lt; "Value at position 0 = " &lt;&lt; arr[0] &lt;&lt; '\n';
  return 0;
}</pre>
   <p>
    
     To compile the program and enable MSan, use the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ clang++ -fsanitize=memory -fno-omit-frame-pointer -g -O2 –o test test.cpp</pre>
   <p>
    
     Running the resulting program generates the
    
    
     
      following output:
     
    
   </p>
   <pre class="console">
==20932==WARNING: MemorySanitizer: use-of-uninitialized-value
    #0 0x5b9fa2bed38f in main test.cpp:6:41
    #3 0x5b9fa2b53324 in _start (test+0x32324) (BuildId: c0a0d31f01272c3ed59d4ac66b8700e9f457629f)
SUMMARY: MemorySanitizer: use-of-uninitialized-value test.cpp:6:41 in main</pre>
   <p>
    
     Again, the output
    
    <a id="_idIndexMarker941">
    </a>
    
     shows clearly that an uninitialized value is being used at line 6 when reading the value at position
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     in the
    
    
     <strong class="source-inline">
      
       arr
      
     </strong>
    
    
     
      array.
     
    
   </p>
   <p>
    
     Finally, let’s summarize other sanitizers in the
    
    
     
      next section.
     
    
   </p>
   <h2 id="_idParaDest-254">
    <a id="_idTextAnchor253">
    </a>
    
     Other sanitizers
    
   </h2>
   <p>
    
     There are
    
    <a id="_idIndexMarker942">
    </a>
    
     other sanitizers available that are useful when developing for certain systems, such as kernel or
    
    
     
      real-time development:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Hardware-assisted AddressSanitizers (HWASan)
      
     </strong>
     
      : A new variant of ASan that
     
     <a id="_idIndexMarker943">
     </a>
     
      consumes much less memory by using the hardware ability to ignore the top byte of a pointer.
     
     
      It can be enabled by specifying the
     
     <strong class="source-inline">
      
       –
      
     </strong>
     
      <strong class="source-inline">
       
        fsanitize=hwaddress
       
      </strong>
     
     
      
       option.
      
     
    </li>
    <li>
     <strong class="bold">
      
       RealTimeSanitizer (RTSan)
      
     </strong>
     
      : Real-time testing tool to detect real-time violations
     
     <a id="_idIndexMarker944">
     </a>
     
      when calling methods that are not safe in functions with deterministic
     
     
      
       runtime requirements.
      
     
    </li>
    <li>
     <strong class="bold">
      
       FuzzerSanitizer
      
     </strong>
     
      : A sanitizer
     
     <a id="_idIndexMarker945">
     </a>
     
      that detects potential vulnerabilities by feeding large volumes of random data into the program, checking if the program crashes, and looking for memory corruption or other
     
     
      
       security vulnerabilities.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Kernel-related sanitizers
      
     </strong>
     
      : There
     
     <a id="_idIndexMarker946">
     </a>
     
      are also sanitizers available to track issues by kernel developers.
     
     
      For the sake of curiosity, some of these are
     
     
      
       as follows:
      
     
     <ul>
      <li>
       <strong class="bold">
        
         Kernel Address
        
       </strong>
       
        <strong class="bold">
         
          Sanitizer
         
        </strong>
       
       
        
         (
        
       
       
        <strong class="bold">
         
          KASAN
         
        </strong>
       
       
        
         )
        
       
      </li>
      <li>
       <strong class="bold">
        
         Kernel Concurrency
        
       </strong>
       
        <strong class="bold">
         
          Sanitizer
         
        </strong>
       
       
        
         (
        
       
       
        <strong class="bold">
         
          KCSAN
         
        </strong>
       
       
        
         )
        
       
      </li>
      <li>
       <strong class="bold">
        
         Kernel
        
       </strong>
       
        <strong class="bold">
         
          Electric-Fence
         
        </strong>
       
       
        
         (
        
       
       
        <strong class="bold">
         
          KFENCE
         
        </strong>
       
       
        
         )
        
       
      </li>
      <li>
       <strong class="bold">
        
         Kernel Memory
        
       </strong>
       
        <strong class="bold">
         
          Sanitizer
         
        </strong>
       
       
        
         (
        
       
       
        <strong class="bold">
         
          KMSAN
         
        </strong>
       
       
        
         )
        
       
      </li>
      <li>
       <strong class="bold">
        
         Kernel Thread
        
       </strong>
       
        <strong class="bold">
         
          Sanitizer
         
        </strong>
       
       
        
         (
        
       
       
        <strong class="bold">
         
          KTSAN
         
        </strong>
       
       
        
         )
        
       
      </li>
     </ul>
    </li>
   </ul>
   <p>
    
     Sanitizers
    
    <a id="_idIndexMarker947">
    </a>
    
     can automatically find many issues in our code.
    
    
     Once
    
    <a id="_idIndexMarker948">
    </a>
    
     we have found and debugged
    
    <a id="_idIndexMarker949">
    </a>
    
     some bugs and can reproduce scenarios
    
    <a id="_idIndexMarker950">
    </a>
    
     that lead to those specific bugs, it would be
    
    <a id="_idIndexMarker951">
    </a>
    
     convenient to design some tests that cover those cases to avoid future changes in code that could lead to similar problems
    
    
     
      or incidents.
     
    
   </p>
   <p>
    
     Let’s learn how to test multithreaded and asynchronous code in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-255">
    <a id="_idTextAnchor254">
    </a>
    
     Testing asynchronous code
    
   </h1>
   <p>
    
     Finally, let’s
    
    <a id="_idIndexMarker952">
    </a>
    
     explore some techniques to test asynchronous code.
    
    
     The examples
    
    <a id="_idIndexMarker953">
    </a>
    
     shown in this section need
    
    <strong class="bold">
     
      GoogleTest
     
    </strong>
    
     and
    
    <strong class="bold">
     
      GoogleTest Mock
     
    </strong>
    
     (
    
    <strong class="bold">
     
      gMock
     
    </strong>
    
     ) libraries to compile.
    
    
     If you are unfamiliar with these libraries, please
    
    <a id="_idIndexMarker954">
    </a>
    
     check the official documentation on how to install and
    
    
     
      use them.
     
    
   </p>
   <p>
    
     As we know,
    
    <strong class="bold">
     
      unit testing
     
    </strong>
    
     is the
    
    <a id="_idIndexMarker955">
    </a>
    
     practice of writing small and isolated tests that verify the functionality and behavior of a single unit of code.
    
    
     Unit testing helps to find and fix bugs, refactor and improve your code quality, document and communicate the underlying code design, and facilitate collaboration
    
    
     
      and integration.
     
    
   </p>
   <p>
    
     This section will not cover the best way to group tests into logical and descriptive suites, or when you should use assertions or expectations to verify the values of different variables and tested methods outcomes.
    
    
     The purpose of this section is to provide some guidelines on how to create unit tests to test asynchronous code.
    
    
     Therefore, some previous knowledge
    
    <a id="_idIndexMarker956">
    </a>
    
     about unit testing or
    
    <strong class="bold">
     
      test-driven development
     
    </strong>
    
     (
    
    <strong class="bold">
     
      TDD
     
    </strong>
    
     )
    
    
     
      is desirable.
     
    
   </p>
   <p>
    
     The main difficulty when dealing with asynchronous code is that it might execute in another thread, and usually without knowing when that will happen, or when it
    
    
     
      will complete.
     
    
   </p>
   <p>
    
     The main
    
    <a id="_idIndexMarker957">
    </a>
    
     approach to follow when testing asynchronous code is to try to separate the functionality from multithreading, meaning that we might want to test the asynchronous code in a synchronous way, trying to execute it in one specific thread, removing context switching, threads creation and destruction, and other activities that might affect the result and timings on the tests.
    
    
     Sometimes, timers are also used, waiting for a callback to be invoked
    
    
     
      before timeout.
     
    
   </p>
   <h2 id="_idParaDest-256">
    <a id="_idTextAnchor255">
    </a>
    
     Testing a simple asynchronous function
    
   </h2>
   <p>
    
     Let’s start
    
    <a id="_idIndexMarker958">
    </a>
    
     with a small example
    
    <a id="_idIndexMarker959">
    </a>
    
     of testing an asynchronous operation.
    
    
     This example shows a
    
    <strong class="source-inline">
     
      asyncFunc()
     
    </strong>
    
     function that is tested by running it asynchronously by using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     , as shown in
    
    <a href="B22219_07.xhtml#_idTextAnchor143">
     
      <em class="italic">
       
        Chapter 7
       
      </em>
     
    </a>
    
     
      :
     
    
   </p>
   <pre class="source-code">
#include &lt;gtest/gtest.h&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
using namespace std::chrono_literals;
int asyncFunc() {
    std::this_thread::sleep_for(100ms);
    return 42;
}
TEST(AsyncTests, TestHandleAsyncOperation) {
    std::future&lt;int&gt; result = std::async(
                         std::launch::async,
                         asyncFunc);
    EXPECT_EQ(result.get(), 42);
}
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</pre>
   <p>
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     returns
    
    <a id="_idIndexMarker960">
    </a>
    
     a future that
    
    <a id="_idIndexMarker961">
    </a>
    
     is used to retrieve the computed value.
    
    
     In this case,
    
    <strong class="source-inline">
     
      asyncFunc
     
    </strong>
    
     just waits for
    
    <strong class="source-inline">
     
      100ms
     
    </strong>
    
     before returning the value
    
    <strong class="source-inline">
     
      42
     
    </strong>
    
     .
    
    
     If the asynchronous task runs properly, the test will pass as there is an expectation instruction checking that the returned value is in
    
    
     
      fact
     
    
    
     <strong class="source-inline">
      
       42
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     There is only one test defined, using the
    
    <strong class="source-inline">
     
      TEST()
     
    </strong>
    
     macro, where its first parameter is the test suite name (in this example,
    
    <strong class="source-inline">
     
      AsyncTests
     
    </strong>
    
     ) and the second parameter is the test
    
    
     
      name (
     
    
    
     <strong class="source-inline">
      
       TestHandleAsyncOperation
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function, the GoogleTest library is initialized by calling
    
    <strong class="source-inline">
     
      ::testing::InitGoogleTest()
     
    </strong>
    
     .
    
    
     This function parses the command line for the flags that
    
    <a id="_idIndexMarker962">
    </a>
    
     GoogleTest recognizes.
    
    
     Then,
    
    <strong class="source-inline">
     
      RUN_ALL_TESTS()
     
    </strong>
    
     is called, which collects and runs all tests and returns
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     if all tests are
    
    <a id="_idIndexMarker963">
    </a>
    
     successful or
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     otherwise.
    
    
     This function originally was a macro, which is why its name is
    
    
     
      in uppercase.
     
    
   </p>
   <h2 id="_idParaDest-257">
    <a id="_idTextAnchor256">
    </a>
    
     Limiting test durations by using timeouts
    
   </h2>
   <p>
    
     One issue that could happen with this approach is that the asynchronous task can fail to be
    
    <a id="_idIndexMarker964">
    </a>
    
     scheduled for any reason, take longer than expected to complete, or just not get completed for any reason.
    
    
     To deal with this situation, a timer can be used, setting its timeout period to a reasonable value to give enough time for the test to complete successfully.
    
    
     Therefore, if the timer times out, the test will fail.
    
    
     The following example shows that approach by using a timed waiting on the future returned
    
    
     
      by
     
    
    
     <strong class="source-inline">
      
       std::async
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
#include &lt;gtest/gtest.h&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
using namespace std::chrono;
using namespace std::chrono_literals;
int asyncFunc() {
    std::this_thread::sleep_for(100ms);
    return 42;
}
TEST(AsyncTest, TestTimeOut) {
    auto start = steady_clock::now();
    std::future&lt;int&gt; result = std::async(
                         std::launch::async,
                         asyncFunc);
    if (result.wait_for(200ms) ==
               std::future_status::timeout) {
        FAIL() &lt;&lt; "Test timed out!";
    }
    EXPECT_EQ(result.get(), 42);
    auto end = steady_clock::now();
    auto elapsed = duration_cast&lt;milliseconds&gt;(
                                end - start);
    EXPECT_LT(elapsed.count(), 200);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</pre>
   <p>
    
     Now, the
    
    <strong class="source-inline">
     
      wait_for()
     
    </strong>
    
     function of the future object
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     is called, waiting 200 ms for the asynchronous task to complete.
    
    
     As the task will be completed in 100 ms, the timeout will
    
    <a id="_idIndexMarker965">
    </a>
    
     not expire.
    
    
     If for any reason
    
    <strong class="source-inline">
     
      wait_for()
     
    </strong>
    
     is called with a value lower than 100 ms, it would time out and the
    
    <strong class="source-inline">
     
      FAIL()
     
    </strong>
    
     macro will be called, making the
    
    
     
      test fail.
     
    
   </p>
   <p>
    
     The test continues running and checks if the returned value is
    
    <strong class="source-inline">
     
      42
     
    </strong>
    
     as in the previous example, and then also checks if the time spent running the asynchronous task is less than the
    
    
     
      used timeout.
     
    
   </p>
   <h2 id="_idParaDest-258">
    <a id="_idTextAnchor257">
    </a>
    
     Testing callbacks
    
   </h2>
   <p>
    
     Testing
    
    <a id="_idIndexMarker966">
    </a>
    
     callback is a relevant task, especially when
    
    <a id="_idIndexMarker967">
    </a>
    
     implementing libraries and
    
    <strong class="bold">
     
      application programming interfaces
     
    </strong>
    
     (
    
    <strong class="bold">
     
      APIs
     
    </strong>
    
     ).
    
    
     The following example shows how to test that a callback has been called and
    
    
     
      its result:
     
    
   </p>
   <pre class="source-code">
#include &lt;gtest/gtest.h&gt;
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void asyncFunc(std::function&lt;void(int)&gt; callback) {
    std::thread([callback]() {
        std::this_thread::sleep_for(1s);
        callback(42);
    }).detach();
}
TEST(AsyncTest, TestCallback) {
    int result = 0;
    bool callback_called = false;
    auto callback = [&amp;](int value) {
        callback_called = true;
        result = value;
    };
    asyncFunc(callback);
    std::this_thread::sleep_for(2s);
    EXPECT_TRUE(callback_called);
    EXPECT_EQ(result, 42);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      TestCallback
     
    </strong>
    
     test just defines a callback as a lambda function that accepts an argument.
    
    
     This
    
    <a id="_idIndexMarker968">
    </a>
    
     lambda function captures by reference the
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     variable where the
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     argument is stored, and the
    
    <strong class="source-inline">
     
      callback_called
     
    </strong>
    
     Boolean variable that by default is
    
    <strong class="source-inline">
     
      false
     
    </strong>
    
     and set to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     when the callback
    
    
     
      is called.
     
    
   </p>
   <p>
    
     Then, the test calls the
    
    <strong class="source-inline">
     
      asyncFunc()
     
    </strong>
    
     function that spawns a thread that waits for one second before calling the callback and passing the value
    
    <strong class="source-inline">
     
      42
     
    </strong>
    
     .
    
    
     The test waits for two seconds before checking if the callback has been called by using the
    
    <strong class="source-inline">
     
      EXPECT_TRUE
     
    </strong>
    
     macro and checking the value of
    
    <strong class="source-inline">
     
      callback_called
     
    </strong>
    
     , and if
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     has the expected value
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       42
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-259">
    <a id="_idTextAnchor258">
    </a>
    
     Testing event-driven software
    
   </h2>
   <p>
    
     We saw in
    
    <a href="B22219_09.xhtml#_idTextAnchor184">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     how to
    
    <a id="_idIndexMarker969">
    </a>
    
     use
    
    <strong class="bold">
     
      Boost.Asio
     
    </strong>
    
     and its event queue to dispatch
    
    <a id="_idIndexMarker970">
    </a>
    
     asynchronous tasks.
    
    
     In event-driven programming, typically, we also need to test callbacks, as in the previous example.
    
    
     We can set up the test to inject callbacks and validate the result after they are called.
    
    
     The following example shows how to test asynchronous tasks in a
    
    
     
      Boost.Asio program:
     
    
   </p>
   <pre class="source-code">
#include &lt;gtest/gtest.h&gt;
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void asyncFunc(boost::asio::io_context&amp; io_context,
               std::function&lt;void(int)&gt; callback) {
    io_context.post([callback]() {
        std::this_thread::sleep_for(100ms);
        callback(42);
    });
}
TEST(AsyncTest, BoostAsio) {
    boost::asio::io_context io_context;
    int result = 0;
    asyncFunc(io_context, [&amp;result](int value) {
        result = value;
    });
    std::jthread io_thread([&amp;io_context]() {
        io_context.run();
    });
    std::this_thread::sleep_for(150ms);
    EXPECT_EQ(result, 42);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      BoostAsio
     
    </strong>
    
     test starts by creating an I/O execution context object,
    
    <strong class="source-inline">
     
      io_context
     
    </strong>
    
     , and
    
    <a id="_idIndexMarker971">
    </a>
    
     passing it to the
    
    <strong class="source-inline">
     
      asyncFunc()
     
    </strong>
    
     function together with a lambda function implementing a task or callback to run in the background.
    
    
     This callback simply sets the value of the
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     variable, captured by the lambda function, to the value passed
    
    
     
      to it.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      asyncFunc()
     
    </strong>
    
     function
    
    <a id="_idIndexMarker972">
    </a>
    
     just uses
    
    <strong class="source-inline">
     
      io_context
     
    </strong>
    
     to post a task that consists of a lambda function that calls the callback with the value
    
    <strong class="source-inline">
     
      42
     
    </strong>
    
     after waiting for
    
    
     
      100 ms.
     
    
   </p>
   <p>
    
     The test then just waits for 150 ms for the background task to finish and checks that the result value is
    
    <strong class="source-inline">
     
      42
     
    </strong>
    
     to mark the test
    
    
     
      as passed.
     
    
   </p>
   <h2 id="_idParaDest-260">
    <a id="_idTextAnchor259">
    </a>
    
     Mocking external resources
    
   </h2>
   <p>
    
     If the asynchronous code also depends on external resources, such as file access, network servers, timers, or other modules, we might need to mock them and avoid unwanted
    
    <a id="_idIndexMarker973">
    </a>
    
     failures due to any resource issues translated into the tests.
    
    
     Mocking and stubbing are techniques used to replace or modify the behavior of a real object or function with a fake or simplified one, for testing purposes.
    
    
     This way, we can control the input and output of the asynchronous code and avoid side effects or interference from
    
    
     
      other factors.
     
    
   </p>
   <p>
    
     For example, if the tested code depends on a server, the server can fail to connect or execute its task, making the test fail.
    
    
     In these cases, failures are due to resource issues, not due to the asynchronous code being tested, causing a false, and usually transient, failure.
    
    
     We can mock external resources by using our own mock classes that mimic their interfaces.
    
    
     Let’s see an example of how to use a mock class and use dependency injection to use that class
    
    
     
      for testing.
     
    
   </p>
   <p>
    
     In this example, there is an external resource,
    
    <strong class="source-inline">
     
      AsyncTaskScheduler
     
    </strong>
    
     , whose
    
    <strong class="source-inline">
     
      runTask()
     
    </strong>
    
     method is used to execute an asynchronous task.
    
    
     As we only want to test the asynchronous task and remove any undesired side effects that the asynchronous task scheduler
    
    <a id="_idIndexMarker974">
    </a>
    
     could generate, we can use a mock class mimicking the
    
    <strong class="source-inline">
     
      AsyncScheduler
     
    </strong>
    
     interface.
    
    
     This class is
    
    <strong class="source-inline">
     
      MockTaskScheduler
     
    </strong>
    
     , which inherits from
    
    <strong class="source-inline">
     
      AsyncTaskScheduler
     
    </strong>
    
     and implements its
    
    <strong class="source-inline">
     
      runTask()
     
    </strong>
    
     base class method, where the task is
    
    
     
      run synchronously:
     
    
   </p>
   <pre class="source-code">
#include &lt;gtest/gtest.h&gt;
#include &lt;functional&gt;
class AsyncTaskScheduler {
   public:
    virtual int runTask(std::function&lt;int()&gt; task) = 0;
};
class MockTaskScheduler : public AsyncTaskScheduler {
   public:
    int runTask(std::function&lt;int()&gt; task) override {
        return task();
    }
};
TEST(AsyncTests, TestDependencyInjection) {
    MockTaskScheduler scheduler;
    auto task = []() -&gt; int {
        return 42;
    };
    int result = scheduler.runTask(task);
    EXPECT_EQ(result, 42);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      TestDependencyInjection
     
    </strong>
    
     test just creates a
    
    <strong class="source-inline">
     
      MockTaskScheduler
     
    </strong>
    
     object and
    
    <a id="_idIndexMarker975">
    </a>
    
     a task in the form of a lambda function and uses the mock object to execute the task by running the
    
    <strong class="source-inline">
     
      runTask()
     
    </strong>
    
     function.
    
    
     Once the task runs,
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     will have the
    
    
     
      value
     
    
    
     <strong class="source-inline">
      
       42
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Instead of fully defining the mock class, we can also use the gMock library and mock only the needed methods.
    
    
     This example shows gMock
    
    
     
      in action:
     
    
   </p>
   <pre class="source-code">
#include &lt;gmock/gmock.h&gt;
#include &lt;gtest/gtest.h&gt;
#include &lt;functional&gt;
class AsyncTaskScheduler {
   public:
    virtual int runTask(std::function&lt;int()&gt; task) = 0;
};
class MockTaskScheduler : public AsyncTaskScheduler {
   public:
    MOCK_METHOD(int, runTask, (std::function&lt;int()&gt; task), (override));
};
TEST(AsyncTests, TestDependencyInjection) {
    using namespace testing;
    MockTaskScheduler scheduler;
    auto task = []() -&gt; int {
        return 42;
    };
    EXPECT_CALL(scheduler, runTask(_)).WillOnce(
        Invoke(task)
    );
    auto result = scheduler.runTask(task);
    EXPECT_EQ(result, 42);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</pre>
   <p>
    
     Now,
    
    <strong class="source-inline">
     
      MockTaskScheduler
     
    </strong>
    
     also inherits from
    
    <strong class="source-inline">
     
      AsyncTaskScheduler
     
    </strong>
    
     , where the interface
    
    <a id="_idIndexMarker976">
    </a>
    
     is defined, but instead of overriding its methods, the
    
    <strong class="source-inline">
     
      MOCK_METHOD
     
    </strong>
    
     macro is used instead, where the return type, the mocked method name, and its parameters
    
    
     
      are passed.
     
    
   </p>
   <p>
    
     Then, the
    
    <strong class="source-inline">
     
      TestMockMethod
     
    </strong>
    
     test uses the
    
    <strong class="source-inline">
     
      EXPECT_CALL
     
    </strong>
    
     macro to define an expected call to the
    
    <strong class="source-inline">
     
      runTask()
     
    </strong>
    
     mocked method in
    
    <strong class="source-inline">
     
      MockTaskScheduler
     
    </strong>
    
     , which will happen only once and invoke the lambda function task, which returns the
    
    
     
      value
     
    
    
     <strong class="source-inline">
      
       42
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     That call just happens in the next instruction where
    
    <strong class="source-inline">
     
      scheduler.runTask()
     
    </strong>
    
     is called, storing the returned value in the result.
    
    
     The test finishes by checking if
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     is the expected value
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       42
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-261">
    <a id="_idTextAnchor260">
    </a>
    
     Testing exceptions and failures
    
   </h2>
   <p>
    
     Asynchronous
    
    <a id="_idIndexMarker977">
    </a>
    
     tasks do not always succeed and generate a valid result.
    
    
     Sometimes something can go wrong (network failures, timeouts, exceptions, etc.), and returning an error or throwing an exception is the way to let the user know about this situation.
    
    
     We should simulate failures to ensure that the code handles
    
    
     
      these gracefully.
     
    
   </p>
   <p>
    
     Testing errors or exceptions can be done in the usual way, by using a try-catch block and using assertions or expectations to check if an error is thrown and make the test succeed or fail.
    
    
     GoogleTest also provides the
    
    <strong class="source-inline">
     
      EXPECT_ANY_THROW()
     
    </strong>
    
     macro that simplifies
    
    <a id="_idIndexMarker978">
    </a>
    
     checking if an exception has happened.
    
    
     Both approaches are shown in the
    
    
     
      following example:
     
    
   </p>
   <pre class="source-code">
#include &lt;gtest/gtest.h&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std::chrono_literals;
int asyncFunc(bool should_fail) {
    std::this_thread::sleep_for(100ms);
    if (should_fail) {
        throw std::runtime_error("Simulated failure");
    }
    return 42;
}
TEST(AsyncTest, TestAsyncFailure1) {
    try {
        std::future&lt;int&gt; result = std::async(
                             std::launch::async,
                             asyncFunc, true);
        result.get();
        FAIL() &lt;&lt; "No expected exception thrown";
    } catch (const std::exception&amp; e) {
        SUCCEED();
    }
}
TEST(AsyncTest, TestAsyncFailure2) {
    std::future&lt;int&gt; result = std::async(
                         std::launch::async,
                         asyncFunc, true);
    EXPECT_ANY_THROW(result.get());
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</pre>
   <p>
    
     Both
    
    <a id="_idIndexMarker979">
    </a>
    
     the
    
    <strong class="source-inline">
     
      TestAsyncFailure1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      TestAsyncFailure2
     
    </strong>
    
     tests are very similar.
    
    
     Both execute asynchronously the
    
    <strong class="source-inline">
     
      asyncFunc()
     
    </strong>
    
     function, which now accepts a
    
    <strong class="source-inline">
     
      should_fail
     
    </strong>
    
     Boolean argument indicating whether the task should succeed and return the value
    
    <strong class="source-inline">
     
      42
     
    </strong>
    
     or fail and throw an exception.
    
    
     Both tests make the task fail, with the difference being that
    
    <strong class="source-inline">
     
      TestAsyncFailure1
     
    </strong>
    
     uses the
    
    <strong class="source-inline">
     
      FAIL()
     
    </strong>
    
     macro if no exception
    
    <a id="_idIndexMarker980">
    </a>
    
     is thrown, making the test fail, or
    
    <strong class="source-inline">
     
      SUCCEED()
     
    </strong>
    
     if an exception is caught by the try-catch block, and
    
    <strong class="source-inline">
     
      TestAsyncFailure2
     
    </strong>
    
     uses the
    
    <strong class="source-inline">
     
      EXPECT_ANY_THROW()
     
    </strong>
    
     macro to check if an exception happens when trying to retrieve the result from the future result by calling its
    
    
     <strong class="source-inline">
      
       get()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <h2 id="_idParaDest-262">
    <a id="_idTextAnchor261">
    </a>
    
     Testing multiple threads
    
   </h2>
   <p>
    
     When testing asynchronous software involving multiple threads in C++, one common and effective
    
    <a id="_idIndexMarker981">
    </a>
    
     technique is using condition variables to synchronize the threads.
    
    
     As we have seen in
    
    <a href="B22219_04.xhtml#_idTextAnchor074">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     , condition variables allow threads to wait for certain conditions to be met before proceeding, making them essential for managing inter-thread communication
    
    
     
      and coordination.
     
    
   </p>
   <p>
    
     Next is an example where multiple threads perform some tasks while the main thread waits for all other threads
    
    
     
      to finish.
     
    
   </p>
   <p>
    
     Let’s start by defining some necessary global variables, such as the total number of threads (
    
    <strong class="source-inline">
     
      num_threads
     
    </strong>
    
     ),
    
    <strong class="source-inline">
     
      counter
     
    </strong>
    
     as an atomic variable that will increase each time the asynchronous task is invoked, and the condition variable,
    
    <strong class="source-inline">
     
      cv
     
    </strong>
    
     , and its associated mutex,
    
    <strong class="source-inline">
     
      mtx
     
    </strong>
    
     , which will help to unblock the main thread once all asynchronous tasks have
    
    
     
      been completed:
     
    
   </p>
   <pre class="source-code">
#include &lt;gtest/gtest.h&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using namespace std::chrono_literals;
#define sync_cout std::osyncstream(std::cout)
std::condition_variable cv;
std::mutex mtx;
bool ready = false;
std::atomic&lt;unsigned&gt; counter = 0;
const std::size_t num_threads = 5;</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      asyncTask()
     
    </strong>
    
     function will execute the asynchronous task (simply waiting for 100 ms in this example) before increasing the
    
    <strong class="source-inline">
     
      counter
     
    </strong>
    
     atomic variable and notifying via the
    
    <strong class="source-inline">
     
      cv
     
    </strong>
    
     condition
    
    <a id="_idIndexMarker982">
    </a>
    
     variable to the main thread that its work
    
    
     
      is done:
     
    
   </p>
   <pre class="source-code">
void asyncTask(int id) {
    sync_cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; ": Starting work..."
              &lt;&lt; std::endl;
    std::this_thread::sleep_for(100ms);
    sync_cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; ": Work finished."
              &lt;&lt; std::endl;
    ++counter;
    cv.notify_one();
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      TestMultipleThreads
     
    </strong>
    
     test will start by spawning a number of threads where each one will asynchronously run the
    
    <strong class="source-inline">
     
      asyncTask()
     
    </strong>
    
     task.
    
    
     Then, it will wait, using a condition
    
    <a id="_idIndexMarker983">
    </a>
    
     variable that
    
    <strong class="source-inline">
     
      counter
     
    </strong>
    
     has the same value as the number of threads, meaning that all background tasks have finished their work.
    
    
     The condition variable sets a timeout of 150 ms using the
    
    <strong class="source-inline">
     
      wait_for()
     
    </strong>
    
     function to limit the time the test can run but gives some room for all background tasks to be
    
    
     
      completed successfully:
     
    
   </p>
   <pre class="source-code">
TEST(AsyncTest, TestMultipleThreads) {
    std::vector&lt;std::jthread&gt; threads;
    for (int i = 0; i &lt; num_threads; ++i) {
        threads.emplace_back(asyncTask, i + 1);
    }
    {
        std::unique_lock&lt;std::mutex&gt; lock(mtx);
        cv.wait_for(lock, 150ms, [] {
            return counter == num_threads;
        });
        sync_cout &lt;&lt; "All threads have finished."
                  &lt;&lt; std::endl;
    }
    EXPECT_EQ(counter, num_threads);
}</pre>
   <p>
    
     The test
    
    <a id="_idIndexMarker984">
    </a>
    
     finishes by checking that indeed
    
    <strong class="source-inline">
     
      counter
     
    </strong>
    
     has the same value
    
    
     
      as
     
    
    
     <strong class="source-inline">
      
       num_threads
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Finally, the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function
    
    
     
      is implemented:
     
    
   </p>
   <pre class="source-code">
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</pre>
   <p>
    
     As explained earlier, the program starts by initializing the GoogleTest library by calling
    
    <strong class="source-inline">
     
      ::testing::InitGoogleTest()
     
    </strong>
    
     and then calling
    
    <strong class="source-inline">
     
      RUN_ALL_TESTS()
     
    </strong>
    
     to collect and run
    
    
     
      all tests.
     
    
   </p>
   <h2 id="_idParaDest-263">
    <a id="_idTextAnchor262">
    </a>
    
     Testing coroutines
    
   </h2>
   <p>
    
     With C++20, coroutines provide a new way to write and manage asynchronous code.
    
    
     Coroutine-based
    
    <a id="_idIndexMarker985">
    </a>
    
     code can be tested by using a similar approach to other asynchronous code, but with the subtle difference that coroutines can suspend and
    
    
     
      be resumed.
     
    
   </p>
   <p>
    
     Let’s see an example with a
    
    
     
      simple coroutine.
     
    
   </p>
   <p>
    
     We have seen in
    
    <a href="B22219_08.xhtml#_idTextAnchor164">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     that coroutines have some boilerplate code to define their promise type and awaitable methods.
    
    
     Let’s start by implementing the
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     structure that will define the coroutine.
    
    
     Please revisit
    
    <a href="B22219_08.xhtml#_idTextAnchor164">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     to fully understand
    
    
     
      this code.
     
    
   </p>
   <p>
    
     Let’s start by defining the
    
    
     <strong class="source-inline">
      
       Task
      
     </strong>
    
    
     
      structure:
     
    
   </p>
   <pre class="source-code">
#include &lt;gtest/gtest.h&gt;
#include &lt;coroutine&gt;
#include &lt;exception&gt;
#include &lt;iostream&gt;
struct Task {
    struct promise_type;
    using handle_type =
              std::coroutine_handle&lt;promise_type&gt;;
    handle_type handle_;
    Task(handle_type h) : handle_(h) {}
    ~Task() {
        if (handle_) handle_.destroy();
    }
    // struct promise_type definition
    // and await methods
};</pre>
   <p>
    
     Inside
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     , we
    
    <a id="_idIndexMarker986">
    </a>
    
     define
    
    <strong class="source-inline">
     
      promise_type
     
    </strong>
    
     , which describes how the coroutine is managed.
    
    
     This type provides certain predefined methods (hooks) that control how the values are returned, how the coroutine
    
    <a id="_idIndexMarker987">
    </a>
    
     is suspended, and how resources are managed once the coroutine
    
    
     
      is completed:
     
    
   </p>
   <pre class="source-code">
struct Task {
    // ...
    struct promise_type {
        int result_;
        std::exception_ptr exception_;
        Task get_return_object() {
            return Task(handle_type::from_promise(*this));
        }
        std::suspend_always initial_suspend() {
            return {};
        }
        std::suspend_always final_suspend() noexcept {
            return {};
        }
        void return_value(int value) {
            result_ = value;
        }
        void unhandled_exception() {
            exception_ = std::current_exception();
        }
    };
    // ....
};</pre>
   <p>
    
     Then, the methods used for controlling the suspension and resumption of the coroutine
    
    
     
      are implemented:
     
    
   </p>
   <pre class="source-code">
struct Task {
    // ...
    bool await_ready() const noexcept {
        return handle_.done();
    }
    void await_suspend(std::coroutine_handle&lt;&gt;
                           awaiting_handle) {
        handle_.resume();
        awaiting_handle.resume();
    }
    int await_resume() {
        if (handle_.promise().exception_) {
            std::rethrow_exception(
                handle_.promise().exception_);
        }
        return handle_.promise().result_;
    }
    int result() {
        if (handle_.promise().exception_) {
            std::rethrow_exception(
                    handle_.promise().exception_);
        }
        return handle_.promise().result_;
    }
    // ....
};</pre>
   <p>
    
     Having the
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     structure in place, let’s define two coroutines, one that computes a valid value
    
    <a id="_idIndexMarker988">
    </a>
    
     and another that throws
    
    
     
      an exception:
     
    
   </p>
   <pre class="source-code">
Task asyncFunc(int x) {
    co_return 2 * x;
}
Task asyncFuncWithException() {
    throw std::runtime_error("Exception from coroutine");
    co_return 0;
}</pre>
   <p>
    
     As test functions inside the
    
    <strong class="source-inline">
     
      TEST()
     
    </strong>
    
     macro in GoogleTest cannot directly be coroutines because
    
    <a id="_idIndexMarker989">
    </a>
    
     they don’t have a
    
    <strong class="source-inline">
     
      promise_type
     
    </strong>
    
     structure associated with them, we need to define some
    
    
     
      helper functions:
     
    
   </p>
   <pre class="source-code">
Task testCoroutineHelper(int value) {
    co_return co_await asyncFunc(value);
}
Task testCoroutineWithExceptionHelper() {
    co_return co_await asyncFuncWithException();
}</pre>
   <p>
    
     With that in place, we can now implement
    
    
     
      the tests:
     
    
   </p>
   <pre class="source-code">
TEST(AsyncTest, TestCoroutine) {
    auto task = testCoroutineHelper(5);
    task.handle_.resume();
    EXPECT_EQ(task.result(), 10);
}
TEST(AsyncTest, TestCoroutineWithException) {
    auto task = testCoroutineWithExceptionHelper();
    EXPECT_THROW({
            task.handle_.resume();
            task.result();
        },
        std::runtime_error);
}
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      TestCoroutine
     
    </strong>
    
     test defines a task using the
    
    <strong class="source-inline">
     
      testCoroutineHelper()
     
    </strong>
    
     helper function
    
    <a id="_idIndexMarker990">
    </a>
    
     and passing the value
    
    <strong class="source-inline">
     
      5
     
    </strong>
    
     .
    
    
     When resuming the coroutine, it’s expected that it will return the value doubled, thus the value
    
    <strong class="source-inline">
     
      10
     
    </strong>
    
     , which is tested
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       EXPECT_EQ()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      TestCoroutineWithException
     
    </strong>
    
     test uses a similar approach, but now using the
    
    <strong class="source-inline">
     
      testCoroutineWithExceptionHelper()
     
    </strong>
    
     helper function, which will throw an exception when the coroutine is resumed.
    
    
     This is exactly what happens inside the
    
    <strong class="source-inline">
     
      EXPECT_THROW()
     
    </strong>
    
     assertion macro before checking that indeed the exception is of
    
    
     
      type
     
    
    
     <strong class="source-inline">
      
       std::runtime_error
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-264">
    <a id="_idTextAnchor263">
    </a>
    
     Stress testing
    
   </h2>
   <p>
    
     A race condition detector can be achieved by performing stress testing.
    
    
     For highly concurrent
    
    <a id="_idIndexMarker991">
    </a>
    
     or multi-threaded asynchronous code, stress testing is crucial.
    
    
     We can simulate high load with multiple asynchronous tasks to check if the system behaves correctly under stress.
    
    
     Also, it’s important to use random delays, thread interleaving, or stress-testing tools, to reduce deterministic conditions, increasing the
    
    
     
      test coverage.
     
    
   </p>
   <p>
    
     The next example shows the implementation of a stress test that spawns 100 (
    
    <strong class="source-inline">
     
      total_nums
     
    </strong>
    
     ) threads
    
    <a id="_idIndexMarker992">
    </a>
    
     that execute the asynchronous task where the atomic variable counter is increased with each run after a
    
    
     
      random wait:
     
    
   </p>
   <pre class="source-code">
#include &lt;gtest/gtest.h&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
std::atomic&lt;int&gt; counter(0);
const std::size_t total_runs = 100;
void asyncIncrement() {
    std::this_thread::sleep_for(std::chrono::milliseconds(rand() % 100));
    counter.fetch_add(1);
}
TEST(AsyncTest, StressTest) {
    std::vector&lt;std::thread&gt; threads;
    for (std::size_t i = 0; i &lt; total_runs; ++i) {
        threads.emplace_back(asyncIncrement);
    }
    for (auto&amp; thread : threads) {
        thread.join();
    }
    EXPECT_EQ(counter, total_runs);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</pre>
   <p>
    
     The test
    
    <a id="_idIndexMarker993">
    </a>
    
     succeeds if the counter has the same value as the total number
    
    
     
      of threads.
     
    
   </p>
   <h2 id="_idParaDest-265">
    <a id="_idTextAnchor264">
    </a>
    
     Parallelizing tests
    
   </h2>
   <p>
    
     To run test suites quicker we can parallelize the tests running in different threads, but tests
    
    <a id="_idIndexMarker994">
    </a>
    
     must be independent, each running in a specific thread as a synchronous single-threaded solution.
    
    
     Also, they need to set up and tear down any necessary objects without keeping the state from previous
    
    
     
      test runs.
     
    
   </p>
   <p>
    
     When using CMake together with GoogleTest, we can run all detected tests in parallel by specifying the number of concurrent jobs we want to use with the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ ctest –j &lt;num_jobs&gt;</pre>
   <p>
    
     All the
    
    <a id="_idIndexMarker995">
    </a>
    
     examples shown in this section are a small subset of what can be done for testing asynchronous code.
    
    
     We hope that these techniques provide enough insight and knowledge to develop further testing techniques that deal with specific scenarios you
    
    
     
      might face.
     
    
   </p>
   <h1 id="_idParaDest-266">
    <a id="_idTextAnchor265">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we learned about how to sanitize and test
    
    
     
      asynchronous programs.
     
    
   </p>
   <p>
    
     We started by learning how to sanitize code using sanitizers to help find multithreaded and asynchronous issues, such as race conditions, memory leaks, and use-after-scope errors, among many
    
    
     
      other issues.
     
    
   </p>
   <p>
    
     Then, some testing techniques designed to deal with asynchronous software were described, using GoogleTest as the
    
    
     
      testing library.
     
    
   </p>
   <p>
    
     Using these tools and techniques helps detect and prevent undefined behavior, memory errors, and security vulnerabilities while ensuring that concurrent operations execute correctly, timing issues are handled properly, and code performs as expected under various conditions.
    
    
     This improves the overall program’s reliability
    
    
     
      and stability.
     
    
   </p>
   <p>
    
     In the next chapter, we will learn about performance and optimization techniques that can be used to improve asynchronous programs’ runtime and
    
    
     
      resource usage.
     
    
   </p>
   <h1 id="_idParaDest-267">
    <a id="_idTextAnchor266">
    </a>
    
     Further reading
    
   </h1>
   <ul>
    <li>
     
      
       Sanitizers:
      
     
     <a href="https://github.com/google/sanitizers">
      
       
        https://github.com/google/sanitizers
       
      
     </a>
    </li>
    <li>
     
      Clang 20.0
     
     
      
       ASan:
      
     
     <a href="https://clang.llvm.org/docs/AddressSanitizer.html">
      
       
        https://clang.llvm.org/docs/AddressSanitizer.html
       
      
     </a>
    </li>
    <li>
     
      Clang 20.0 hardware-assisted
     
     
      
       ASan:
      
     
     <a href="https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html">
      
       
        https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html
       
      
     </a>
    </li>
    <li>
     
      Clang 20.0
     
     
      
       TSan:
      
     
     <a href="https://clang.llvm.org/docs/ThreadSanitizer.html">
      
       
        https://clang.llvm.org/docs/ThreadSanitizer.html
       
      
     </a>
    </li>
    <li>
     
      Clang 20.0
     
     
      
       MSan:
      
     
     <a href="https://clang.llvm.org/docs/MemorySanitizer.html">
      
       
        https://clang.llvm.org/docs/MemorySanitizer.html
       
      
     </a>
    </li>
    <li>
     
      Clang 20.0
     
     
      
       UBSan
      
     
     
      
       :
      
     
     <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">
      
       
        https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html
       
      
     </a>
    </li>
    <li>
     
      Clang 20.0
     
     
      
       DataFlowSanitizer:
      
     
     <a href="https://clang.llvm.org/docs/DataFlowSanitizer.html">
      
       
        https://clang.llvm.org/docs/DataFlowSanitizer.html
       
      
     </a>
    </li>
    <li>
     
      Clang 20.0
     
     
      
       LSan:
      
     
     <a href="https://clang.llvm.org/docs/LeakSanitizer.html">
      
       
        https://clang.llvm.org/docs/LeakSanitizer.html
       
      
     </a>
    </li>
    <li>
     
      Clang 20.0
     
     
      
       RealtimeSanitizer:
      
     
     <a href="https://clang.llvm.org/docs/RealtimeSanitizer.html">
      
       
        https://clang.llvm.org/docs/RealtimeSanitizer.html
       
      
     </a>
    </li>
    <li>
     
      Clang 20.0
     
     
      
       SanitizerCoverage:
      
     
     <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">
      
       
        https://clang.llvm.org/docs/SanitizerCoverage.html
       
      
     </a>
    </li>
    <li>
     
      Clang 20.0
     
     
      
       SanitizerStats:
      
     
     <a href="https://clang.llvm.org/docs/SanitizerStats.html">
      
       
        https://clang.llvm.org/docs/SanitizerStats.html
       
      
     </a>
    </li>
    <li>
     
      GCC:
     
     <em class="italic">
      
       Program Instrumentation
      
     </em>
     
      <em class="italic">
       
        Options
       
      </em>
     
     
      
       :
      
     
     <a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html">
      
       
        https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html
       
      
     </a>
    </li>
    <li>
     
      Apple Developer:
     
     <em class="italic">
      
       Diagnosing memory, thread, and crash issues
      
     </em>
     
      <em class="italic">
       
        early
       
      </em>
     
     
      
       :
      
     
     <a href="https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early">
      
       
        https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early
       
      
     </a>
    </li>
    <li>
     
      GCC:
     
     <em class="italic">
      
       Options for Debugging Your
      
     </em>
     
      <em class="italic">
       
        Program
       
      </em>
     
     
      
       :
      
     
     <a href="https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html">
      
       
        https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html
       
      
     </a>
    </li>
    <li>
     
      OpenSSL:
     
     <em class="italic">
      
       Compiler Options Hardening Guide for C and
      
     </em>
     
      <em class="italic">
       
        C++
       
      </em>
     
     
      
       :
      
     
     <a href="https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html">
      
       
        https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html
       
      
     </a>
    </li>
    <li>
     
      Memory error checking in C and C++: Comparing Sanitizers and
     
     
      
       Valgrind:
      
     
     <a href="https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind">
      
       
        https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind
       
      
     </a>
    </li>
    <li>
     
      The GNU C
     
     
      
       Library:
      
     
     <a href="https://www.gnu.org/software/libc">
      
       
        https://www.gnu.org/software/libc
       
      
     </a>
    </li>
    <li>
     
      Sanitizers: Common
     
     
      
       flags:
      
     
     <a href="https://github.com/google/sanitizers/wiki/SanitizerCommonFlags">
      
       
        https://github.com/google/sanitizers/wiki/SanitizerCommonFlags
       
      
     </a>
    </li>
    <li>
     
      AddressSanitizer
     
     
      
       flags:
      
     
     <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags">
      
       
        https://github.com/google/sanitizers/wiki/AddressSanitizerFlags
       
      
     </a>
    </li>
    <li>
     
      AddressSanitizer: A Fast Address Sanity
     
     
      
       Checker:
      
     
     <a href="https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf">
      
       
        https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf
       
      
     </a>
    </li>
    <li>
     
      MemorySanitizer: Fast detector of uninitialized memory use in
     
     
      
       C++:
      
     
     <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43308.pdf">
      
       
        https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43308.pdf
       
      
     </a>
    </li>
    <li>
     
      Linux Kernel
     
     
      
       Sanitizers:
      
     
     <a href="https://github.com/google/kernel-sanitizers">
      
       
        https://github.com/google/kernel-sanitizers
       
      
     </a>
    </li>
    <li>
     
      TSan
     
     
      
       flags:
      
     
     <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags">
      
       
        https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags
       
      
     </a>
    </li>
    <li>
     
      TSan: Popular data
     
     
      
       races:
      
     
     <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerPopularDataRaces">
      
       
        https://github.com/google/sanitizers/wiki/ThreadSanitizerPopularDataRaces
       
      
     </a>
    </li>
    <li>
     
      TSan report
     
     
      
       format:
      
     
     <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat">
      
       
        https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat
       
      
     </a>
    </li>
    <li>
     
      TSan
     
     
      
       algorithm:
      
     
     <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm">
      
       
        https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm
       
      
     </a>
    </li>
    <li>
     
      Address space layout
     
     
      
       randomization:
      
     
     <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">
      
       
        https://en.wikipedia.org/wiki/Address_space_layout_randomization
       
      
     </a>
    </li>
    <li>
     
      GoogleTest User’s
     
     
      
       Guide:
      
     
     <a href="https://google.github.io/googletest">
      
       
        https://google.github.io/googletest
       
      
     </a>
    </li>
   </ul>
  </div>
 </body></html>