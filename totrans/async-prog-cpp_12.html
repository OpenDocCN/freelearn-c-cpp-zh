<html><head></head><body>
  <div id="_idContainer066">
   <h1 class="chapter-number" id="_idParaDest-244">
    <a id="_idTextAnchor243">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     12
    </span>
   </h1>
   <h1 id="_idParaDest-245">
    <a id="_idTextAnchor244">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Sanitizing and Testing Asynchronous Software
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.3.1">
      Testing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.4.1">
     is the process
    </span>
    <a id="_idIndexMarker887">
    </a>
    <span class="koboSpan" id="kobo.5.1">
     of evaluating and verifying that a software solution does what it’s meant to do, validating its quality and ensuring that user requirements are met.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     With proper testing, we can prevent bugs from happening and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      improve performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     In this chapter, we will
    </span>
    <a id="_idIndexMarker888">
    </a>
    <span class="koboSpan" id="kobo.8.1">
     explore several techniques to test asynchronous software, mainly using the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.9.1">
      GoogleTest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.10.1">
     library and sanitizers available from
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.11.1">
      GNU Compiler Collection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.12.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.13.1">
      GCC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.14.1">
     ) and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.15.1">
      Clang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.16.1">
     compilers.
    </span>
    <span class="koboSpan" id="kobo.16.2">
     Some prior knowledge in unit testing is required.
    </span>
    <span class="koboSpan" id="kobo.16.3">
     In the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.17.1">
      Further reading
     </span>
    </em>
    <span class="koboSpan" id="kobo.18.1">
     section at
    </span>
    <a id="_idIndexMarker889">
    </a>
    <span class="koboSpan" id="kobo.19.1">
     the end of this chapter, you can find some references
    </span>
    <a id="_idIndexMarker890">
    </a>
    <span class="koboSpan" id="kobo.20.1">
     that could be useful to refresh and expand your knowledge in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.21.1">
      these areas.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.22.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.23.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.24.1">
      Sanitizing code to analyze the software and find
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       potential issues
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.26.1">
      Testing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.27.1">
       asynchronous code
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-246">
    <a id="_idTextAnchor245">
    </a>
    <span class="koboSpan" id="kobo.28.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     For this chapter, we will
    </span>
    <a id="_idIndexMarker891">
    </a>
    <span class="koboSpan" id="kobo.30.1">
     need to install
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.31.1">
      GoogleTest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.32.1">
     (
    </span>
    <a href="https://google.github.io/googletest">
     <span class="koboSpan" id="kobo.33.1">
      https://google.github.io/googletest
     </span>
    </a>
    <span class="koboSpan" id="kobo.34.1">
     ) to compile some of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      the examples.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     Some examples need a compiler supporting C++20.
    </span>
    <span class="koboSpan" id="kobo.36.2">
     Therefore, check the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.37.1">
      Technical requirements
     </span>
    </em>
    <span class="koboSpan" id="kobo.38.1">
     section in
    </span>
    <a href="B22219_03.xhtml#_idTextAnchor051">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.39.1">
        Chapter 3
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.40.1">
     , as it includes some guidance on how to install GCC 13 and Clang
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.41.1">
      8 compilers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.42.1">
     You can find all the complete code in the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.43.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.44.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     The examples for this chapter are located under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.46.1">
      Chapter_12
     </span>
    </strong>
    <span class="koboSpan" id="kobo.47.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.47.2">
     All source code files can be compiled using CMake
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.48.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.49.1">
$ cmake . </span><span class="koboSpan" id="kobo.49.2">&amp;&amp; cmake —build .</span></pre>
   <p>
    <span class="koboSpan" id="kobo.50.1">
     Executable binaries will be generated under the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.51.1">
       bin
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.52.1">
      directory.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-247">
    <a id="_idTextAnchor246">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     Sanitizing code to analyze the software and find 
potential issues
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.54.1">
      Sanitizers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.55.1">
     are tools, originally developed by Google, used to detect and prevent various types
    </span>
    <a id="_idIndexMarker892">
    </a>
    <span class="koboSpan" id="kobo.56.1">
     of issues or security vulnerabilities in code, helping developers catch bugs early in the development process, reducing the cost of issues being fixed late, and increasing software stability
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      and security.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     Sanitizers are usually integrated into development environments and are usually enabled
    </span>
    <a id="_idIndexMarker893">
    </a>
    <span class="koboSpan" id="kobo.59.1">
     during manual testing or when running unit tests,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.60.1">
      continuous integration
     </span>
    </strong>
    <span class="koboSpan" id="kobo.61.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.62.1">
      CI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.63.1">
     ) pipelines, or code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.64.1">
      review pipelines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     C++ compilers, such as GCC and Clang, have compiler options to generate code when building the program to track the execution at runtime and report errors and vulnerabilities.
    </span>
    <span class="koboSpan" id="kobo.65.2">
     They are implemented in Clang from version 3.1 and GCC from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.66.1">
      version 4.8.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.67.1">
     As extra instructions are injected into the program’s binary code, there is a performance penalty of around 1.5x to 4x slowdowns depending on the sanitizer type.
    </span>
    <span class="koboSpan" id="kobo.67.2">
     Also, there is an overall memory overhead of 2x to 4x and a stack size increase of up to 3x.
    </span>
    <span class="koboSpan" id="kobo.67.3">
     But note that slowdowns are much lower than the ones experienced when using other instrumentation
    </span>
    <a id="_idIndexMarker894">
    </a>
    <span class="koboSpan" id="kobo.68.1">
     frameworks or dynamic analysis tools, such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.69.1">
      Valgrind
     </span>
    </strong>
    <span class="koboSpan" id="kobo.70.1">
     (
    </span>
    <a href="https://valgrind.org">
     <span class="koboSpan" id="kobo.71.1">
      https://valgrind.org
     </span>
    </a>
    <span class="koboSpan" id="kobo.72.1">
     ), which imposes a much higher slowdown of up to 50 times slower than production binaries.
    </span>
    <span class="koboSpan" id="kobo.72.2">
     On the other hand, the benefit of using Valgrind is that no recompilation is needed.
    </span>
    <span class="koboSpan" id="kobo.72.3">
     Both approaches only detect issues while the program is running and only on those code paths that the execution traverses.
    </span>
    <span class="koboSpan" id="kobo.72.4">
     So, we need to ensure
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.73.1">
      sufficient coverage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     There are also static analysis tools and linters, useful for detecting issues during compilation and checking all the code that is being included in the program.
    </span>
    <span class="koboSpan" id="kobo.74.2">
     For example, compilers, such as GCC and Clang, can perform extra checks and provide useful information by enabling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.75.1">
      –Werror
     </span>
    </strong>
    <span class="koboSpan" id="kobo.76.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.77.1">
      –Wall
     </span>
    </strong>
    <span class="koboSpan" id="kobo.78.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.79.1">
      –
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.80.1">
       pedantic
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.81.1">
      options.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.82.1">
     There are also
    </span>
    <a id="_idIndexMarker895">
    </a>
    <span class="koboSpan" id="kobo.83.1">
     open source alternatives, such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.84.1">
      Cppcheck
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.86.1">
      Flawfinder
     </span>
    </strong>
    <span class="koboSpan" id="kobo.87.1">
     , or commercial
    </span>
    <a id="_idIndexMarker896">
    </a>
    <span class="koboSpan" id="kobo.88.1">
     solutions that
    </span>
    <a id="_idIndexMarker897">
    </a>
    <span class="koboSpan" id="kobo.89.1">
     are free for open source projects, such
    </span>
    <a id="_idIndexMarker898">
    </a>
    <span class="koboSpan" id="kobo.90.1">
     as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.91.1">
      PVS-Studio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.92.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.93.1">
      Coverity Scan
     </span>
    </strong>
    <span class="koboSpan" id="kobo.94.1">
     .
    </span>
    <span class="koboSpan" id="kobo.94.2">
     Other
    </span>
    <a id="_idIndexMarker899">
    </a>
    <span class="koboSpan" id="kobo.95.1">
     solutions, such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.96.1">
      SonarQube
     </span>
    </strong>
    <span class="koboSpan" id="kobo.97.1">
     ,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.98.1">
      CodeSonar
     </span>
    </strong>
    <span class="koboSpan" id="kobo.99.1">
     , or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.100.1">
      OCLint
     </span>
    </strong>
    <span class="koboSpan" id="kobo.101.1">
     , can be
    </span>
    <a id="_idIndexMarker900">
    </a>
    <span class="koboSpan" id="kobo.102.1">
     used in
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.103.1">
      continuous integration / continuous delivery
     </span>
    </strong>
    <span class="koboSpan" id="kobo.104.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.105.1">
      CI/CD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.106.1">
     ) pipelines
    </span>
    <a id="_idIndexMarker901">
    </a>
    <span class="koboSpan" id="kobo.107.1">
     for ongoing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.108.1">
      quality tracking.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.109.1">
     In this
    </span>
    <a id="_idIndexMarker902">
    </a>
    <span class="koboSpan" id="kobo.110.1">
     section, we will focus on sanitizers, which can be enabled by passing some special options to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.111.1">
      the compiler.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-248">
    <a id="_idTextAnchor247">
    </a>
    <span class="koboSpan" id="kobo.112.1">
     Compiler options
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     To enable
    </span>
    <a id="_idIndexMarker903">
    </a>
    <span class="koboSpan" id="kobo.114.1">
     sanitizers, we need to pass some compiler options when compiling
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.115.1">
      the program.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.116.1">
     The main option is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.117.1">
      --fsanitize=sanitizer_name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.118.1">
     , where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.119.1">
      sanitizer_name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.120.1">
     is one of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.121.1">
      following options:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.122.1">
       address
      </span>
     </strong>
     <span class="koboSpan" id="kobo.123.1">
      : This
     </span>
     <a id="_idIndexMarker904">
     </a>
     <span class="koboSpan" id="kobo.124.1">
      is for
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.125.1">
       AddressSanitizer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.126.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.127.1">
       ASan
      </span>
     </strong>
     <span class="koboSpan" id="kobo.128.1">
      ), to detect memory errors such as buffer overflows and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.129.1">
       use-after-free bugs
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.130.1">
       thread
      </span>
     </strong>
     <span class="koboSpan" id="kobo.131.1">
      : This
     </span>
     <a id="_idIndexMarker905">
     </a>
     <span class="koboSpan" id="kobo.132.1">
      is for
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.133.1">
       ThreadSanitizer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.134.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.135.1">
       TSan
      </span>
     </strong>
     <span class="koboSpan" id="kobo.136.1">
      ), to identify data races and other thread synchronization issues in multi-threaded programs by monitoring
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.137.1">
       thread interactions
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.138.1">
       leak
      </span>
     </strong>
     <span class="koboSpan" id="kobo.139.1">
      : This
     </span>
     <a id="_idIndexMarker906">
     </a>
     <span class="koboSpan" id="kobo.140.1">
      is for
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.141.1">
       LeakSanitizer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.142.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.143.1">
       LSan
      </span>
     </strong>
     <span class="koboSpan" id="kobo.144.1">
      ), to spot memory leaks by tracking memory allocations and ensuring that all allocated memory is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.145.1">
       properly freed
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.146.1">
       memory
      </span>
     </strong>
     <span class="koboSpan" id="kobo.147.1">
      : This
     </span>
     <a id="_idIndexMarker907">
     </a>
     <span class="koboSpan" id="kobo.148.1">
      is for
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.149.1">
       MemorySanitizer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.150.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.151.1">
       MSan
      </span>
     </strong>
     <span class="koboSpan" id="kobo.152.1">
      ), to uncover the use of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.153.1">
       uninitialized memory
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.154.1">
       undefined
      </span>
     </strong>
     <span class="koboSpan" id="kobo.155.1">
      : This
     </span>
     <a id="_idIndexMarker908">
     </a>
     <span class="koboSpan" id="kobo.156.1">
      is for
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.157.1">
       UndefinedBehaviorSanitizer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.158.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.159.1">
       UBSan
      </span>
     </strong>
     <span class="koboSpan" id="kobo.160.1">
      ), to detect undefined behavior, such as integer overflows, invalid type casts, and other
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.161.1">
       erroneous operations
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.162.1">
     Clang also includes
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.163.1">
      dataflow
     </span>
    </strong>
    <span class="koboSpan" id="kobo.164.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.165.1">
      cfi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.166.1">
     (control flow integrity),
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.167.1">
      safe_stack
     </span>
    </strong>
    <span class="koboSpan" id="kobo.168.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.169.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.170.1">
       realtime
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.171.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.172.1">
     GCC adds
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.173.1">
      kernel-address
     </span>
    </strong>
    <span class="koboSpan" id="kobo.174.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.175.1">
      hwaddress
     </span>
    </strong>
    <span class="koboSpan" id="kobo.176.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.177.1">
      kernel-hwaddress
     </span>
    </strong>
    <span class="koboSpan" id="kobo.178.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.179.1">
      pointer-compare
     </span>
    </strong>
    <span class="koboSpan" id="kobo.180.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.181.1">
      pointer-subtract
     </span>
    </strong>
    <span class="koboSpan" id="kobo.182.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.183.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.184.1">
       shadow-call-stack
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.185.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     As this list and
    </span>
    <a id="_idIndexMarker909">
    </a>
    <span class="koboSpan" id="kobo.187.1">
     flag behavior can change over time, it’s recommended to check the compilers’
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.188.1">
      official documentation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.189.1">
     Additional flags might
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.190.1">
      be needed:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.191.1">
       -fno-omit-frame-pointer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.192.1">
      : A
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.193.1">
       frame pointer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.194.1">
      is a register used by compilers
     </span>
     <a id="_idIndexMarker910">
     </a>
     <span class="koboSpan" id="kobo.195.1">
      to track the current stack frame, containing, among other information, the base address of the current function.
     </span>
     <span class="koboSpan" id="kobo.195.2">
      Omitting frame pointers might increase the performance of the program but at the cost of making debugging significantly harder; it makes it more difficult to locate local variables and reconstruct
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.196.1">
       stack traces.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.197.1">
       -g
      </span>
     </strong>
     <span class="koboSpan" id="kobo.198.1">
      : Include debug information and display filenames and line numbers in the warning messages.
     </span>
     <span class="koboSpan" id="kobo.198.2">
      If the debugger GDB is used, the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.199.1">
       –ggdb
      </span>
     </strong>
     <span class="koboSpan" id="kobo.200.1">
      option might be desirable as the compiler can produce more expressive symbols to be used when debugging.
     </span>
     <span class="koboSpan" id="kobo.200.2">
      Also, a level can be specified by using
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.201.1">
       –g[level]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.202.1">
      , with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.203.1">
       [level]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.204.1">
      being a value from
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.205.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.206.1">
      to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.207.1">
       3
      </span>
     </strong>
     <span class="koboSpan" id="kobo.208.1">
      , adding more debug information at each level increase.
     </span>
     <span class="koboSpan" id="kobo.208.2">
      The default level
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.209.1">
       is
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.210.1">
        2
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.211.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.212.1">
       –fsanitize-recover
      </span>
     </strong>
     <span class="koboSpan" id="kobo.213.1">
      : These options cause the sanitizer to attempt to continue running the program as if no error
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.214.1">
       was detected.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.215.1">
       –fno-sanitize-recover
      </span>
     </strong>
     <span class="koboSpan" id="kobo.216.1">
      : The sanitizer will detect only the first error, and the program will exit with a non-zero
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.217.1">
       exit code.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.218.1">
     To keep a reasonable performance, we might need to adjust the optimization level by specifying the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.219.1">
      –O[num]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.220.1">
     option.
    </span>
    <span class="koboSpan" id="kobo.220.2">
     Different sanitizers work best up to a certain level of optimization.
    </span>
    <span class="koboSpan" id="kobo.220.3">
     It’s best to start with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.221.1">
      –O0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.222.1">
     and, if the slowdown is significant, try to increase to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.223.1">
      –O1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.224.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.225.1">
      –O2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.226.1">
     , and so on.
    </span>
    <span class="koboSpan" id="kobo.226.2">
     Also, as different sanitizers and compilers recommend specific optimization levels, check
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.227.1">
      their documentation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.228.1">
     When using Clang, to make stack traces easy to understand and let sanitizers convert addresses into
    </span>
    <a id="_idIndexMarker911">
    </a>
    <span class="koboSpan" id="kobo.229.1">
     source code locations, apart from using the flags mentioned earlier, we can also set the specific environment variable,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.230.1">
      [X]SAN_SYMBOLIZER_PATH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.231.1">
     , to the location of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.232.1">
      llvm-symbolizer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.233.1">
     (with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.234.1">
      [X]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.235.1">
     being
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.236.1">
      A
     </span>
    </strong>
    <span class="koboSpan" id="kobo.237.1">
     for AddressSatinizer,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.238.1">
      L
     </span>
    </strong>
    <span class="koboSpan" id="kobo.239.1">
     for LSan,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.240.1">
      M
     </span>
    </strong>
    <span class="koboSpan" id="kobo.241.1">
     for MSan, and so on).
    </span>
    <span class="koboSpan" id="kobo.241.2">
     We can also include this location in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.242.1">
      PATH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.243.1">
     environment variable.
    </span>
    <span class="koboSpan" id="kobo.243.2">
     Here is an example of setting the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.244.1">
      PATH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.245.1">
     variables
    </span>
    <a id="_idIndexMarker912">
    </a>
    <span class="koboSpan" id="kobo.246.1">
     when
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.247.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.248.1">
       AddressSatinizer
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.249.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.250.1">
export ASAN_SYMBOLIZER_PATH=`which llvm-symbolizer`
export PATH=$ASAN_SYMBOLIZER_PATH:$PATH</span></pre>
   <p>
    <span class="koboSpan" id="kobo.251.1">
     Note that enabling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.252.1">
      –Werror
     </span>
    </strong>
    <span class="koboSpan" id="kobo.253.1">
     with certain sanitizers can lead to false positives.
    </span>
    <span class="koboSpan" id="kobo.253.2">
     Also, other compiler flags might be needed, but warning messages during execution will show that a problem is happening and will be evident that a flag is needed.
    </span>
    <span class="koboSpan" id="kobo.253.3">
     Check the sanitizers’ and compilers’ documentation to find which flag to use in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      those cases.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.255.1">
     Avoiding sanitizing part of the code
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.256.1">
     Sometimes, we
    </span>
    <a id="_idIndexMarker913">
    </a>
    <span class="koboSpan" id="kobo.257.1">
     may want to silence some sanitizer warning and skip sanitizing some functions due to the following reasons: it is a well-known issue, the function is correct, it’s a false positive, this function needs to speed up, or it is an issue in a third-party library.
    </span>
    <span class="koboSpan" id="kobo.257.2">
     In those cases, we can use suppression files or exclude the code area by using some macro instructions.
    </span>
    <span class="koboSpan" id="kobo.257.3">
     There is also a blacklist mechanism, but as it is deprecated in favor of suppression files; we will not comment on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.258.1">
      it here.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.259.1">
     With suppression files, we just need to create a text file listing the areas of the code where we don’t want the sanitizer to run.
    </span>
    <span class="koboSpan" id="kobo.259.2">
     Each line consists of a pattern following a specific
    </span>
    <a id="_idIndexMarker914">
    </a>
    <span class="koboSpan" id="kobo.260.1">
     format depending on the sanitizer, but typically, the structure is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.261.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.262.1">
type:location_pattern</span></pre>
   <p>
    <span class="koboSpan" id="kobo.263.1">
     Here,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.264.1">
      type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.265.1">
     indicates the type of suppression, for example, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.266.1">
      leak
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.268.1">
      race
     </span>
    </strong>
    <span class="koboSpan" id="kobo.269.1">
     values, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.270.1">
      location_pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.271.1">
     is a regular expression matching the function or library name to suppress.
    </span>
    <span class="koboSpan" id="kobo.271.2">
     Here is an example of a suppression file for an ASan, explained in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.272.1">
      next section:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.273.1">
# Suppress known memory leaks in third-party function Func1 in library Lib1
leak:Lib1::Func1
# Ignore false-positive from function Func2 in library Lib2
race:Lib2::Func2
# Suppress issue from libc
leak:/usr/lib/libc.so.*</span></pre>
   <p>
    <span class="koboSpan" id="kobo.274.1">
     Let’s call this file
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.275.1">
      myasan.supp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.276.1">
     .
    </span>
    <span class="koboSpan" id="kobo.276.2">
     Then, compile and pass this suppression file to the sanitizer via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.277.1">
      [X]SAN_OPTIONS
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.278.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.279.1">
$ clang++ -O0 -g -fsanitize=address -fno-omit-frame-pointer test.cpp –o test
$ ASAN_OPTIONS=suppressions=myasan.supp ./test</span></pre>
   <p>
    <span class="koboSpan" id="kobo.280.1">
     We can also use macros in source code to exclude specific functions to be sanitized by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.281.1">
      __attribute__((no_sanitize("&lt;sanitizer_name&gt;")))
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.283.1">
#if defined(__clang__) || defined (__GNUC__)
# define ATTRIBUTE_NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address))
#else
# define ATTRIBUTE_NO_SANITIZE_ADDRESS
#endif
...
</span><span class="koboSpan" id="kobo.283.2">ATTRIBUTE_NO_SANITIZE_ADDRESS
void ThisFunctionWillNotBeInstrumented() {...}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.284.1">
     This technique
    </span>
    <a id="_idIndexMarker915">
    </a>
    <span class="koboSpan" id="kobo.285.1">
     provides a fine-grained compile-time control over what should be instrumented by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.286.1">
      the sanitizer.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.287.1">
     Let’s now explore the most common types of code sanitizers, starting with one of the most relevant to check
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.288.1">
      address misusages.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-249">
    <a id="_idTextAnchor248">
    </a>
    <span class="koboSpan" id="kobo.289.1">
     AddressSanitizer
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.290.1">
     The purpose of
    </span>
    <a id="_idIndexMarker916">
    </a>
    <span class="koboSpan" id="kobo.291.1">
     ASan is to detect memory-related errors happening due to buffer overflows (heap, stack, and global) during out-of-bounds accesses of arrays, using a block of memory after being released with free or delete operations, and other
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      memory leaks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.293.1">
     Apart from setting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.294.1">
      -fsanitize=address
     </span>
    </strong>
    <span class="koboSpan" id="kobo.295.1">
     and other flags recommended earlier, we can also use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.296.1">
      –fsanitize-address-use-after-scope
     </span>
    </strong>
    <span class="koboSpan" id="kobo.297.1">
     to detect the memory used after moving out of scope or setting the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.298.1">
      ASAN_OPTIONS=option detect_stack_use_after_return=1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.299.1">
     environment variable to detect use
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.300.1">
      after return.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.301.1">
      ASAN_OPTIONS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.302.1">
     can also be used to instruct the ASan to print the stack trace or set a log file
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.303.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.304.1">
ASAN_OPTIONS=detect_stack_use_after_return=1,print_stacktrace=1,log_path=asan.log</span></pre>
   <p>
    <span class="koboSpan" id="kobo.305.1">
     Clang on Linux has full support for ASan, followed by GCC on Linux.
    </span>
    <span class="koboSpan" id="kobo.305.2">
     By default, ASan is disabled as it adds extra
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.306.1">
      runtime overhead.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.307.1">
     Also, ASan processes all calls to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.308.1">
      glibc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.309.1">
     – the GNU C library providing the core libraries for GNU systems.
    </span>
    <span class="koboSpan" id="kobo.309.2">
     However, this is not the case with other libraries, so it’s recommended to recompile such libraries with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.310.1">
      –fsanitize=address
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     option.
    </span>
    <span class="koboSpan" id="kobo.311.2">
     As commented earlier, with Valgrind, recompilation is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.312.1">
      not required.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.313.1">
     ASan can be
    </span>
    <a id="_idIndexMarker917">
    </a>
    <span class="koboSpan" id="kobo.314.1">
     combined with UBSan, which we will see later, but It slows down the performance by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.315.1">
      around 50%.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.316.1">
     If we want a more aggressive diagnostics sanitizing, we can use the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.317.1">
      flag combination:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.318.1">
ASAN_OPTIONS=strict_string_checks=1:detect_stack_use_after_return=1:check_initialization_order=1:strict_init_order=1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.319.1">
     Let’s see two examples of using ASan to detect common software issues, with memory being used after being freed and detecting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.320.1">
      buffer overflows.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.321.1">
     Memory usage after being freed
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.322.1">
     One common
    </span>
    <a id="_idIndexMarker918">
    </a>
    <span class="koboSpan" id="kobo.323.1">
     issue in software is using memory after being freed.
    </span>
    <span class="koboSpan" id="kobo.323.2">
     In this example, memory allocated in the heap is being used after
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.324.1">
      being deleted:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.325.1">
#include &lt;iostream&gt;
#include &lt;memory&gt;
int main() {
  auto arr = new int[100];
  delete[] arr;
  std::cout &lt;&lt; "arr[0] = " &lt;&lt; arr[0] &lt;&lt; '\n';
  return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.326.1">
     Let’s suppose that the previous source code is in a file called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.327.1">
      test.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.328.1">
     .
    </span>
    <span class="koboSpan" id="kobo.328.2">
     To enable ASan, we just compile the file using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.329.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.330.1">
$ clang++ -fsanitize=address -fno-omit-frame-pointer -g -O0 –o test test.cpp</span></pre>
   <p>
    <span class="koboSpan" id="kobo.331.1">
     Then, executing
    </span>
    <a id="_idIndexMarker919">
    </a>
    <span class="koboSpan" id="kobo.332.1">
     the resulting output
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.333.1">
      test
     </span>
    </strong>
    <span class="koboSpan" id="kobo.334.1">
     program, we obtain the following output (note that the output is simplified, only showing relevant content and might differ from different compiler versions and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.335.1">
      execution context):
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.336.1">
ERROR: AddressSanitizer: heap-use-after-free on address 0x514000000040 at pc 0x63acc82a0bec bp 0x7fff2d096c60 sp 0x7fff2d096c58
READ of size 4 at 0x514000000040 thread T0
    #0 0x63acc82a0beb in main test.cpp:7:31
0x514000000040 is located 0 bytes inside of 400-byte region [0x514000000040,0x5140000001d0)
freed by thread T0 here:
    #0 0x63acc829f161 in operator delete[](void*) (/mnt/StorePCIE/Projects/Books/Packt/Book/Code/build/bin/Chapter_11/11x02-ASAN_heap_use_after_free+0x106161) (BuildId: 7bf8fe6b1f86a8b587fbee39ae3a5ced3e866931)
previously allocated by thread T0 here:
    #0 0x63acc829e901 in operator new[](unsigned long) (/mnt/StorePCIE/Projects/Books/Packt/Book/Code/build/bin/Chapter_11/11x02-ASAN_heap_use_after_free+0x105901) (BuildId: 7bf8fe6b1f86a8b587fbee39ae3a5ced3e866931)
SUMMARY: AddressSanitizer: heap-use-after-free test.cpp:7:31 in main</span></pre>
   <p>
    <span class="koboSpan" id="kobo.337.1">
     The output shows that the ASan was applied and detected a heap-use-after-free error.
    </span>
    <span class="koboSpan" id="kobo.337.2">
     This error is happening in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.338.1">
      T0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.339.1">
     thread (main thread).
    </span>
    <span class="koboSpan" id="kobo.339.2">
     The output also points to the code where that memory region was allocated, and later freed, and its size (400
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.340.1">
      bytes region).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.341.1">
     These kinds
    </span>
    <a id="_idIndexMarker920">
    </a>
    <span class="koboSpan" id="kobo.342.1">
     of errors not only happen with heap memory but also with memory regions allocated in the stack or global area.
    </span>
    <span class="koboSpan" id="kobo.342.2">
     ASan can be used to detect these kinds of issues, such as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.343.1">
      memory overflows.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.344.1">
     Memory overflows
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.345.1">
     Memory overflows, also known as buffer overflows or overruns, happen when some data is written in a memory address past the allocated memory of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.346.1">
      a buffer.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.347.1">
     The following example shows a heap
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.348.1">
      memory overflow:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.349.1">
#include &lt;iostream&gt;
int main() {
  auto arr = new int[100];
  arr[0] = 0;
  int res = arr[100];
  std::cout &lt;&lt; "res = " &lt;&lt; res &lt;&lt; '\n';
  delete[] arr;
  return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.350.1">
     After compiling and running the resulting program, this is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.351.1">
      the output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.352.1">
ERROR: AddressSanitizer: heap-buffer-overflow on address 0x5140000001d0 at pc 0x582953d2ac07 bp 0x7ffde9d58910 sp 0x7ffde9d58908
READ of size 4 at 0x5140000001d0 thread T0
    #0 0x582953d2ac06 in main test.cpp:6:13
0x5140000001d0 is located 0 bytes after 400-byte region [0x514000000040,0x5140000001d0)
allocated by thread T0 here:
    #0 0x582953d28901 in operator new[](unsigned long) (test+0x105901) (BuildId: 82a16fc86e01bc81f6392d4cbcad0fe8f78422c0)
    #1 0x582953d2ab78 in main test.cpp:4:14
(test+0x2c374) (BuildId: 82a16fc86e01bc81f6392d4cbcad0fe8f78422c0)
SUMMARY: AddressSanitizer: heap-buffer-overflow test.cpp:6:13 in main</span></pre>
   <p>
    <span class="koboSpan" id="kobo.353.1">
     As we
    </span>
    <a id="_idIndexMarker921">
    </a>
    <span class="koboSpan" id="kobo.354.1">
     can see from the output, now ASan reports a heap-buffer-overflow error in the main thread (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.355.1">
      T0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.356.1">
     ) when accessing a memory address beyond a 400-byte region (the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.357.1">
       arr
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.358.1">
      variable).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.359.1">
     A sanitizer that is integrated into ASan is LSan.
    </span>
    <span class="koboSpan" id="kobo.359.2">
     Let’s learn now how to detect memory leaks using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.360.1">
      this sanitizer.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-250">
    <a id="_idTextAnchor249">
    </a>
    <span class="koboSpan" id="kobo.361.1">
     LeakSanitizer
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.362.1">
     LSan is
    </span>
    <a id="_idIndexMarker922">
    </a>
    <span class="koboSpan" id="kobo.363.1">
     used to detect memory leaks happening when memory has been allocated but not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.364.1">
      properly freed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.365.1">
     LSan is integrated into ASan and enabled by default on Linux systems.
    </span>
    <span class="koboSpan" id="kobo.365.2">
     It can be enabled on macOS by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.366.1">
      ASAN_OPTIONS=detect_leaks=1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.367.1">
     .
    </span>
    <span class="koboSpan" id="kobo.367.2">
     To disable it, just
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.368.1">
      set
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.369.1">
       detect_leaks=0
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.370.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.371.1">
     If the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.372.1">
      –fsanitize=leak
     </span>
    </strong>
    <span class="koboSpan" id="kobo.373.1">
     option is used, the program will link against a subset of the ASan supporting LSan, disabling compile-time instrumentation and reducing the ASan slowdown.
    </span>
    <span class="koboSpan" id="kobo.373.2">
     Note that this mode is not as well tested as the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.374.1">
      default mode.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.375.1">
     Let’s
    </span>
    <a id="_idIndexMarker923">
    </a>
    <span class="koboSpan" id="kobo.376.1">
     see an example of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.377.1">
      memory leak:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.378.1">
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
int main() {
    auto arr = new char[100];
    strcpy(arr, "Hello world!");
    std::cout &lt;&lt; "String = " &lt;&lt; arr &lt;&lt; '\n';
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.379.1">
     In this example, 100 bytes are allocated (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.380.1">
      arr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.381.1">
     variable) but
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.382.1">
      never freed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.383.1">
     To enable LSan, we just compile the file using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.384.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.385.1">
$ clang++ -fsanitize=leak -fno-omit-frame-pointer -g -O2 –o test test.cpp</span></pre>
   <p>
    <span class="koboSpan" id="kobo.386.1">
     Running the resulting test binary, we obtain the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.387.1">
      following result:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.388.1">
ERROR: LeakSanitizer: detected memory leaks
Direct leak of 100 byte(s) in 1 object(s) allocated from:
    #0 0x5560ba9a017c in operator new[](unsigned long) (test+0x3417c) (BuildId: 2cc47a28bb898b4305d90c048c66fdeec440b621)
    #1 0x5560ba9a2564 in main test.cpp:6:16
SUMMARY: LeakSanitizer: 100 byte(s) leaked in 1 allocation(s).</span></pre>
   <p>
    <span class="koboSpan" id="kobo.389.1">
     LSan
    </span>
    <a id="_idIndexMarker924">
    </a>
    <span class="koboSpan" id="kobo.390.1">
     correctly reports that a memory region of 100 bytes was allocated by using the operator
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.391.1">
      new
     </span>
    </strong>
    <span class="koboSpan" id="kobo.392.1">
     but
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.393.1">
      never deleted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.394.1">
     As this book explores multithreading and asynchronous programming, let’s learn now about a sanitizer to detect data races and other thread
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.395.1">
      issues: TSan.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-251">
    <a id="_idTextAnchor250">
    </a>
    <span class="koboSpan" id="kobo.396.1">
     ThreadSanitizer
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.397.1">
     TSan is used to detect threading issues, especially data races and synchronization issues.
    </span>
    <span class="koboSpan" id="kobo.397.2">
     It cannot
    </span>
    <a id="_idIndexMarker925">
    </a>
    <span class="koboSpan" id="kobo.398.1">
     be combined with ASan or LSan.
    </span>
    <span class="koboSpan" id="kobo.398.2">
     TSan is the sanitizer most aligned with the content of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.399.1">
      this book.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.400.1">
     This sanitizer is enabled by specifying the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.401.1">
      –fsanitize=thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.402.1">
     compiler option and its behavior can be modified by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.403.1">
      TSAN_OPTIONS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.404.1">
     environment variable.
    </span>
    <span class="koboSpan" id="kobo.404.2">
     For example, if we want to stop after the first error, just use
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.405.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.406.1">
TSAN_OPTIONS=halt_on_error=1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.407.1">
     Also, for a reasonable performance, use the compiler’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.408.1">
      –
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.409.1">
       O2
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.410.1">
      option.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.411.1">
     TSan only reports race conditions happening at runtime, thus it won’t alert on race conditions present in code paths not executed at runtime.
    </span>
    <span class="koboSpan" id="kobo.411.2">
     Therefore, we need to design tests that provide good coverage and use a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.412.1">
      realistic workload.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.413.1">
     Let’s see some examples of TSan detecting data races.
    </span>
    <span class="koboSpan" id="kobo.413.2">
     In the next example, we’ll do this by using a global variable without protecting its access with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.414.1">
      a mutex:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.415.1">
#include &lt;thread&gt;
int globalVar{0};
void increase() {
  globalVar++;
}
void decrease() {
  globalVar--;
}
int main() {
  std::thread t1(increase);
  std::thread t2(decrease);
  t1.join();
  t2.join();
  return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.416.1">
     After
    </span>
    <a id="_idIndexMarker926">
    </a>
    <span class="koboSpan" id="kobo.417.1">
     compiling the program, use the following command to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.418.1">
      enable TSan:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.419.1">
$ clang++ -fsanitize=thread -fno-omit-frame-pointer -g -O2 –o test test.cpp</span></pre>
   <p>
    <span class="koboSpan" id="kobo.420.1">
     Running the resulting program generates the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.421.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.422.1">
WARNING: ThreadSanitizer: data race (pid=31692)
  Write of size 4 at 0x5932b0585ae8 by thread T2:
    #0 decrease() test.cpp:10:12 (test+0xe0b32) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)
  Previous write of size 4 at 0x5932b0585ae8 by thread T1:
    #0 increase() test.cpp:6:12 (test+0xe0af2) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)
  Thread T2 (tid=31695, running) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6062f) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)
  Thread T1 (tid=31694, finished) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6062f) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)
SUMMARY: ThreadSanitizer: data race test.cpp:10:12 in decrease()
ThreadSanitizer: reported 1 warnings</span></pre>
   <p>
    <span class="koboSpan" id="kobo.423.1">
     From the
    </span>
    <a id="_idIndexMarker927">
    </a>
    <span class="koboSpan" id="kobo.424.1">
     output, it’s clear that there is a data race when accessing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.425.1">
      globalVar
     </span>
    </strong>
    <span class="koboSpan" id="kobo.426.1">
     in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.427.1">
      increase()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.428.1">
     and
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.429.1">
       decrease()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.430.1">
      functions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.431.1">
     If we decide to use GCC instead of Clang, the following error can be reported when running the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.432.1">
      resulting program:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.433.1">
FATAL: ThreadSanitizer: unexpected memory mapping 0x603709d10000-0x603709d11000</span></pre>
   <p>
    <span class="koboSpan" id="kobo.434.1">
     This
    </span>
    <a id="_idIndexMarker928">
    </a>
    <span class="koboSpan" id="kobo.435.1">
     memory mapping issue is caused by a security feature called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.436.1">
      address space layout randomization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.437.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.438.1">
      ASLR
     </span>
    </strong>
    <span class="koboSpan" id="kobo.439.1">
     ), a memory-protection technique used by the OS to protect against buffer overflow attacks by randomizing the address space
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.440.1">
      of processes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.441.1">
     One solution is to reduce ASLR by using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.442.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.443.1">
$ sudo sysctl vm.mmap_rnd_bits=30</span></pre>
   <p>
    <span class="koboSpan" id="kobo.444.1">
     The value passed to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.445.1">
      vm.mmap_rnd_bits
     </span>
    </strong>
    <span class="koboSpan" id="kobo.446.1">
     (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.447.1">
      30
     </span>
    </strong>
    <span class="koboSpan" id="kobo.448.1">
     in the preceding command) can be reduced further if the error is still happening.
    </span>
    <span class="koboSpan" id="kobo.448.2">
     To check that the value is correctly set, just run
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.449.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.450.1">
$ sudo sysctl vm.mmap_rnd_bits
vm.mmap_rnd_bits = 30</span></pre>
   <p>
    <span class="koboSpan" id="kobo.451.1">
     Note that this change is not permanent.
    </span>
    <span class="koboSpan" id="kobo.451.2">
     Therefore, when the machine reboots, its value will be set to the default one.
    </span>
    <span class="koboSpan" id="kobo.451.3">
     To persist this change, add
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.452.1">
      m.mmap_rnd_bits=30
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.453.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.454.1">
       /etc/sysctl.conf
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.455.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.456.1">
     But that reduces the security of the system, so it might be preferable to temporarily disable ASLR for a particular program by using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.457.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.458.1">
$ setarch `uname -m` -R ./test</span></pre>
   <p>
    <span class="koboSpan" id="kobo.459.1">
     Running
    </span>
    <a id="_idIndexMarker929">
    </a>
    <span class="koboSpan" id="kobo.460.1">
     the preceding command will show a similar output to what was shown earlier when compiling
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.461.1">
      with Clang.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.462.1">
     Let’s move to another example where a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.463.1">
      std::map
     </span>
    </strong>
    <span class="koboSpan" id="kobo.464.1">
     object is accessed without a mutex.
    </span>
    <span class="koboSpan" id="kobo.464.2">
     Even if the map is being accessed for different key values, as writing to a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.465.1">
      std::map
     </span>
    </strong>
    <span class="koboSpan" id="kobo.466.1">
     invalidates their iterators, that can cause
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.467.1">
      data races:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.468.1">
#include &lt;map&gt;
#include &lt;thread&gt;
std::map&lt;int,int&gt; m;
void Thread1() {
  m[123] = 1;
}
void Thread2() {
  m[345] = 0;
}
int main() {
  std::jthread t1(Thread1);
  std::jthread t2(Thread1);
  return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.469.1">
     Compiling and
    </span>
    <a id="_idIndexMarker930">
    </a>
    <span class="koboSpan" id="kobo.470.1">
     running the resulting binary generates a large output with three warnings.
    </span>
    <span class="koboSpan" id="kobo.470.2">
     Here, we only show the most relevant lines of the first warning (other warnings
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.471.1">
      are similar):
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.472.1">
WARNING: ThreadSanitizer: data race (pid=8907)
  Read of size 4 at 0x720c00000020 by thread T2:
  Previous write of size 8 at 0x720c00000020 by thread T1:
  Location is heap block of size 40 at 0x720c00000000 allocated by thread T1:
  Thread T2 (tid=8910, running) created by main thread at:
  Thread T1 (tid=8909, finished) created by main thread at:
SUMMARY: ThreadSanitizer: data race test.cpp:11:3 in Thread2()</span></pre>
   <p>
    <span class="koboSpan" id="kobo.473.1">
     The TSan warnings are flagged when both the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.474.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.475.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.476.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.477.1">
     threads are writing into the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.478.1">
      map,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.479.1">
       m
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.480.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.481.1">
     In the next example, there is only one auxiliary thread accessing the map via a pointer, but this thread is competing against the main thread to access and use the map.
    </span>
    <span class="koboSpan" id="kobo.481.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.482.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.483.1">
     thread
    </span>
    <a id="_idIndexMarker931">
    </a>
    <span class="koboSpan" id="kobo.484.1">
     accesses the map,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.485.1">
      m
     </span>
    </strong>
    <span class="koboSpan" id="kobo.486.1">
     , to change the value for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.487.1">
      foo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.488.1">
     key; meanwhile, the main thread prints its value to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.489.1">
      the console:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.490.1">
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;map&gt;
#include &lt;string&gt;
typedef std::map&lt;std::string, std::string&gt; map_t;
void *func(void *p) {
  map_t&amp; m = *static_cast&lt;map_t*&gt;(p);
  m["foo"] = "bar";
  return 0;
}
int main() {
  map_t m;
  std::thread t(func, &amp;m);
  std::cout &lt;&lt; "foo = " &lt;&lt; m["foo"] &lt;&lt; '\n';
  t.join();
  return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.491.1">
     Compiling and running this example generates a massive output with seven TSan warnings.
    </span>
    <span class="koboSpan" id="kobo.491.2">
     Here, we only show the first warning.
    </span>
    <span class="koboSpan" id="kobo.491.3">
     Feel free to check the complete report by compiling
    </span>
    <a id="_idIndexMarker932">
    </a>
    <span class="koboSpan" id="kobo.492.1">
     and running the example in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.493.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.494.1">
WARNING: ThreadSanitizer: data race (pid=10505)
  Read of size 8 at 0x721800003028 by main thread:
    #8 main test.cpp:17:28 (test+0xe1d75) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
  Previous write of size 8 at 0x721800003028 by thread T1:
    #0 operator new(unsigned long) &lt;null&gt; (test+0xe0c3b) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
    #9 func(void*) test.cpp:10:3 (test+0xe1bb7) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
  Location is heap block of size 96 at 0x721800003000 allocated by thread T1:
    #0 operator new(unsigned long) &lt;null&gt; (test+0xe0c3b) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
    #9 func(void*) test.cpp:10:3 (test+0xe1bb7) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
  Thread T1 (tid=10507, finished) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x616bf) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)
SUMMARY: ThreadSanitizer: data race test.cpp:17:28 in main
ThreadSanitizer: reported 7 warnings</span></pre>
   <p>
    <span class="koboSpan" id="kobo.495.1">
     From the output, TSan is warning about a data race when accessing a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.496.1">
      std::map
     </span>
    </strong>
    <span class="koboSpan" id="kobo.497.1">
     object allocated in the heap.
    </span>
    <span class="koboSpan" id="kobo.497.2">
     That object is the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.498.1">
      map
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.499.1">
       m
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.500.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.501.1">
     However, TSan can not only detect data races due to a lack of mutexes but can also report when a variable must
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.502.1">
      be atomic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.503.1">
     The next example shows that scenario.
    </span>
    <span class="koboSpan" id="kobo.503.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.504.1">
      RefCountedObject
     </span>
    </strong>
    <span class="koboSpan" id="kobo.505.1">
     class defines objects that can keep a reference count of how many objects of that class have been created.
    </span>
    <span class="koboSpan" id="kobo.505.2">
     Smart pointers
    </span>
    <a id="_idIndexMarker933">
    </a>
    <span class="koboSpan" id="kobo.506.1">
     follow this idea to delete the underlying allocated memory on destruction when the counter reaches the value
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.507.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.508.1">
     .
    </span>
    <span class="koboSpan" id="kobo.508.2">
     In this example, we are only showing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.509.1">
      Ref()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.510.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.511.1">
      Unref()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.512.1">
     functions that increment and decrement the reference count variable,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.513.1">
      ref_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.514.1">
     .
    </span>
    <span class="koboSpan" id="kobo.514.2">
     To avoid issues in a multithreading environment,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.515.1">
      ref_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.516.1">
     must be an atomic variable.
    </span>
    <span class="koboSpan" id="kobo.516.2">
     As here, this is not the case, and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.517.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.518.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.519.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.520.1">
     threads are modifying
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.521.1">
      ref_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.522.1">
     , a possible data race
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.523.1">
      can happen:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.524.1">
#include &lt;iostream&gt;
#include &lt;thread&gt;
class RefCountedObject {
   public:
    void Ref() {
        ++ref_;
    }
    void Unref() {
        --ref_;
    }
   private:
    // ref_ should be atomic to avoid synchronization issues
    int ref_{0};
};
int main() {
  RefCountedObject obj;
  std::jthread t1(&amp;RefCountedObject::Ref, &amp;obj);
  std::jthread t2(&amp;RefCountedObject::Unref, &amp;obj);
  return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.525.1">
     Compiling and
    </span>
    <a id="_idIndexMarker934">
    </a>
    <span class="koboSpan" id="kobo.526.1">
     running this example shows the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.527.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.528.1">
WARNING: ThreadSanitizer: data race (pid=32574)
  Write of size 4 at 0x7fffffffcc04 by thread T2:
    #0 RefCountedObject::Unref() test.cpp:12:9 (test+0xe1dd0) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
  Previous write of size 4 at 0x7fffffffcc04 by thread T1:
    #0 RefCountedObject::Ref() test.cpp:8:9 (test+0xe1c00) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
  Location is stack of main thread.
</span><span class="koboSpan" id="kobo.528.2">  Location is global '??' </span><span class="koboSpan" id="kobo.528.3">at 0x7ffffffdd000 ([stack]+0x1fc04)
  Thread T2 (tid=32577, running) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6164f) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
    #2 main test.cpp:23:16 (test+0xe1b94) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
  Thread T1 (tid=32576, finished) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6164f) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
    #2 main test.cpp:22:16 (test+0xe1b56) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)
SUMMARY: ThreadSanitizer: data race test.cpp:12:9 in RefCountedObject::Unref()
ThreadSanitizer: reported 1 warnings</span></pre>
   <p>
    <span class="koboSpan" id="kobo.529.1">
     TSan output shows
    </span>
    <a id="_idIndexMarker935">
    </a>
    <span class="koboSpan" id="kobo.530.1">
     that there is a data race condition happening in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.531.1">
      Unref()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.532.1">
     function when
    </span>
    <a id="_idIndexMarker936">
    </a>
    <span class="koboSpan" id="kobo.533.1">
     accessing a memory location previously modified by the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.534.1">
       Ref()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.535.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.536.1">
     Data races can
    </span>
    <a id="_idIndexMarker937">
    </a>
    <span class="koboSpan" id="kobo.537.1">
     also happen in objects being initialized from several threads without any synchronization mechanism.
    </span>
    <span class="koboSpan" id="kobo.537.2">
     In the following example, an object of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.538.1">
      MyObj
     </span>
    </strong>
    <span class="koboSpan" id="kobo.539.1">
     is being created in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.540.1">
      init_object()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.541.1">
     function, and the global static pointer,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.542.1">
      obj
     </span>
    </strong>
    <span class="koboSpan" id="kobo.543.1">
     , is assigned its address.
    </span>
    <span class="koboSpan" id="kobo.543.2">
     As this pointer is not protected by a mutex, there is a data race happening when the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.544.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.545.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.546.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.547.1">
     threads try to create an object and update the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.548.1">
      obj
     </span>
    </strong>
    <span class="koboSpan" id="kobo.549.1">
     pointer from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.550.1">
      func1()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.551.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.552.1">
      func2()
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.553.1">
      functions respectively:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.554.1">
#include &lt;iostream&gt;
#include &lt;thread&gt;
class MyObj {};
static MyObj *obj = nullptr;
void init_object() {
  if (!obj) {
    obj = new MyObj();
  }
}
void func1() {
  init_object();
}
void func2() {
  init_object();
}
int main() {
  std::thread t1(func1);
  std::thread t2(func2);
  t1.join();
  t2.join();
  return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.555.1">
     This is the
    </span>
    <a id="_idIndexMarker938">
    </a>
    <span class="koboSpan" id="kobo.556.1">
     output after compiling and running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.557.1">
      this example:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.558.1">
WARNING: ThreadSanitizer: data race (pid=32826)
  Read of size 1 at 0x5663912cbae8 by thread T2:
    #0 func2() test.cpp (test+0xe0b68) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)
  Previous write of size 1 at 0x5663912cbae8 by thread T1:
    #0 func1() test.cpp (test+0xe0b3d) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)
  Location is global 'obj (.init)' of size 1 at 0x5663912cbae8 (test+0x150cae8)
  Thread T2 (tid=32829, running) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6062f) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)
  Thread T1 (tid=32828, finished) created by main thread at:
    #0 pthread_create &lt;null&gt; (test+0x6062f) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)
SUMMARY: ThreadSanitizer: data race test.cpp in func2()
ThreadSanitizer: reported 1 warnings</span></pre>
   <p>
    <span class="koboSpan" id="kobo.559.1">
     The output shows what we described earlier, a data race happening due to access to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.560.1">
      obj
     </span>
    </strong>
    <span class="koboSpan" id="kobo.561.1">
     global variable from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.562.1">
      func1()
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.563.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.564.1">
       func2()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.565.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.566.1">
     As the C++11 standard has officially deemed data races as undefined behavior, let’s see now how to use UBSan to detect undefined behavior issues in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.567.1">
      the program.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-252">
    <a id="_idTextAnchor251">
    </a>
    <span class="koboSpan" id="kobo.568.1">
     UndefinedBehaviorSanitizer
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.569.1">
     UBSan can
    </span>
    <a id="_idIndexMarker939">
    </a>
    <span class="koboSpan" id="kobo.570.1">
     detect undefined behavior in code, for example, when shifting bits by an excessive amount, integer overflows, or misuse of null pointers.
    </span>
    <span class="koboSpan" id="kobo.570.2">
     It can be enabled by specifying the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.571.1">
      –fsanitize=undefined
     </span>
    </strong>
    <span class="koboSpan" id="kobo.572.1">
     option.
    </span>
    <span class="koboSpan" id="kobo.572.2">
     Its behavior can be modified at runtime by setting the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.573.1">
       UBSAN_OPTIONS
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.574.1">
      variable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.575.1">
     Many errors that can be detected by UBSan are also detected by the compiler
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.576.1">
      during compilation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.577.1">
     Let’s see a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.578.1">
      simple example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.579.1">
int main() {
  int val = 0x7fffffff;
  val += 1;
  return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.580.1">
     To compile the program and enable UBSan, use the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.581.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.582.1">
$ clang++ -fsanitize=undefined -fno-omit-frame-pointer -g -O2 –o test test.cpp</span></pre>
   <p>
    <span class="koboSpan" id="kobo.583.1">
     Running the resulting program generates the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.584.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.585.1">
test.cpp:3:7: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior test.cpp:3:7</span></pre>
   <p>
    <span class="koboSpan" id="kobo.586.1">
     The output is quite simple and self-explanatory; there is a signed integer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.587.1">
      overflow operation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.588.1">
     Let’s now learn about another useful C++ sanitizer to detect uninitialized memory and other memory usage
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.589.1">
      issues: MSan.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-253">
    <a id="_idTextAnchor252">
    </a>
    <span class="koboSpan" id="kobo.590.1">
     MemorySanitizer
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.591.1">
     MSan can detect uninitialized memory usage, for example, when using variables or pointers
    </span>
    <a id="_idIndexMarker940">
    </a>
    <span class="koboSpan" id="kobo.592.1">
     before they have been assigned a value or address.
    </span>
    <span class="koboSpan" id="kobo.592.2">
     It can also track uninitialized bits in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.593.1">
      a bitfield.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.594.1">
     To enable MSan, use the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.595.1">
      compiler flags:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.596.1">
-fsanitize=memory -fPIE -pie -fno-omit-frame-pointer</span></pre>
   <p>
    <span class="koboSpan" id="kobo.597.1">
     It can also track each uninitialized value to the memory allocation from where it was created by specifying the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.598.1">
      -
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.599.1">
       fsanitize-memory-track-origins
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.600.1">
      option.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.601.1">
     GCC has no support for MSan, so the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.602.1">
      -fsanitize=memory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.603.1">
     flag is not valid when using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.604.1">
      this compiler.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.605.1">
     In the following example, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.606.1">
      arr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.607.1">
     integer array is created, but only its position
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.608.1">
      5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.609.1">
     is initialized.
    </span>
    <span class="koboSpan" id="kobo.609.2">
     The value at position
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.610.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.611.1">
     is used when printing the message to the console, but this value is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.612.1">
      still uninitialized:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.613.1">
#include &lt;iostream&gt;
int main() {
  auto arr = new int[10];
  arr[5] = 0;
  std::cout &lt;&lt; "Value at position 0 = " &lt;&lt; arr[0] &lt;&lt; '\n';
  return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.614.1">
     To compile the program and enable MSan, use the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.615.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.616.1">
$ clang++ -fsanitize=memory -fno-omit-frame-pointer -g -O2 –o test test.cpp</span></pre>
   <p>
    <span class="koboSpan" id="kobo.617.1">
     Running the resulting program generates the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.618.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.619.1">
==20932==WARNING: MemorySanitizer: use-of-uninitialized-value
    #0 0x5b9fa2bed38f in main test.cpp:6:41
    #3 0x5b9fa2b53324 in _start (test+0x32324) (BuildId: c0a0d31f01272c3ed59d4ac66b8700e9f457629f)
SUMMARY: MemorySanitizer: use-of-uninitialized-value test.cpp:6:41 in main</span></pre>
   <p>
    <span class="koboSpan" id="kobo.620.1">
     Again, the output
    </span>
    <a id="_idIndexMarker941">
    </a>
    <span class="koboSpan" id="kobo.621.1">
     shows clearly that an uninitialized value is being used at line 6 when reading the value at position
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.622.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.623.1">
     in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.624.1">
       arr
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.625.1">
      array.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.626.1">
     Finally, let’s summarize other sanitizers in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.627.1">
      next section.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-254">
    <a id="_idTextAnchor253">
    </a>
    <span class="koboSpan" id="kobo.628.1">
     Other sanitizers
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.629.1">
     There are
    </span>
    <a id="_idIndexMarker942">
    </a>
    <span class="koboSpan" id="kobo.630.1">
     other sanitizers available that are useful when developing for certain systems, such as kernel or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.631.1">
      real-time development:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.632.1">
       Hardware-assisted AddressSanitizers (HWASan)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.633.1">
      : A new variant of ASan that
     </span>
     <a id="_idIndexMarker943">
     </a>
     <span class="koboSpan" id="kobo.634.1">
      consumes much less memory by using the hardware ability to ignore the top byte of a pointer.
     </span>
     <span class="koboSpan" id="kobo.634.2">
      It can be enabled by specifying the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.635.1">
       –
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.636.1">
        fsanitize=hwaddress
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.637.1">
       option.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.638.1">
       RealTimeSanitizer (RTSan)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.639.1">
      : Real-time testing tool to detect real-time violations
     </span>
     <a id="_idIndexMarker944">
     </a>
     <span class="koboSpan" id="kobo.640.1">
      when calling methods that are not safe in functions with deterministic
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.641.1">
       runtime requirements.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.642.1">
       FuzzerSanitizer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.643.1">
      : A sanitizer
     </span>
     <a id="_idIndexMarker945">
     </a>
     <span class="koboSpan" id="kobo.644.1">
      that detects potential vulnerabilities by feeding large volumes of random data into the program, checking if the program crashes, and looking for memory corruption or other
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.645.1">
       security vulnerabilities.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.646.1">
       Kernel-related sanitizers
      </span>
     </strong>
     <span class="koboSpan" id="kobo.647.1">
      : There
     </span>
     <a id="_idIndexMarker946">
     </a>
     <span class="koboSpan" id="kobo.648.1">
      are also sanitizers available to track issues by kernel developers.
     </span>
     <span class="koboSpan" id="kobo.648.2">
      For the sake of curiosity, some of these are
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.649.1">
       as follows:
      </span>
     </span>
     <ul>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.650.1">
         Kernel Address
        </span>
       </strong>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.651.1">
          Sanitizer
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.652.1">
         (
        </span>
       </span>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.653.1">
          KASAN
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.654.1">
         )
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.655.1">
         Kernel Concurrency
        </span>
       </strong>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.656.1">
          Sanitizer
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.657.1">
         (
        </span>
       </span>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.658.1">
          KCSAN
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.659.1">
         )
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.660.1">
         Kernel
        </span>
       </strong>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.661.1">
          Electric-Fence
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.662.1">
         (
        </span>
       </span>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.663.1">
          KFENCE
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.664.1">
         )
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.665.1">
         Kernel Memory
        </span>
       </strong>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.666.1">
          Sanitizer
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.667.1">
         (
        </span>
       </span>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.668.1">
          KMSAN
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.669.1">
         )
        </span>
       </span>
      </li>
      <li>
       <strong class="bold">
        <span class="koboSpan" id="kobo.670.1">
         Kernel Thread
        </span>
       </strong>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.671.1">
          Sanitizer
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.672.1">
         (
        </span>
       </span>
       <span class="No-Break">
        <strong class="bold">
         <span class="koboSpan" id="kobo.673.1">
          KTSAN
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.674.1">
         )
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.675.1">
     Sanitizers
    </span>
    <a id="_idIndexMarker947">
    </a>
    <span class="koboSpan" id="kobo.676.1">
     can automatically find many issues in our code.
    </span>
    <span class="koboSpan" id="kobo.676.2">
     Once
    </span>
    <a id="_idIndexMarker948">
    </a>
    <span class="koboSpan" id="kobo.677.1">
     we have found and debugged
    </span>
    <a id="_idIndexMarker949">
    </a>
    <span class="koboSpan" id="kobo.678.1">
     some bugs and can reproduce scenarios
    </span>
    <a id="_idIndexMarker950">
    </a>
    <span class="koboSpan" id="kobo.679.1">
     that lead to those specific bugs, it would be
    </span>
    <a id="_idIndexMarker951">
    </a>
    <span class="koboSpan" id="kobo.680.1">
     convenient to design some tests that cover those cases to avoid future changes in code that could lead to similar problems
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.681.1">
      or incidents.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.682.1">
     Let’s learn how to test multithreaded and asynchronous code in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.683.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-255">
    <a id="_idTextAnchor254">
    </a>
    <span class="koboSpan" id="kobo.684.1">
     Testing asynchronous code
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.685.1">
     Finally, let’s
    </span>
    <a id="_idIndexMarker952">
    </a>
    <span class="koboSpan" id="kobo.686.1">
     explore some techniques to test asynchronous code.
    </span>
    <span class="koboSpan" id="kobo.686.2">
     The examples
    </span>
    <a id="_idIndexMarker953">
    </a>
    <span class="koboSpan" id="kobo.687.1">
     shown in this section need
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.688.1">
      GoogleTest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.689.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.690.1">
      GoogleTest Mock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.691.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.692.1">
      gMock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.693.1">
     ) libraries to compile.
    </span>
    <span class="koboSpan" id="kobo.693.2">
     If you are unfamiliar with these libraries, please
    </span>
    <a id="_idIndexMarker954">
    </a>
    <span class="koboSpan" id="kobo.694.1">
     check the official documentation on how to install and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.695.1">
      use them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.696.1">
     As we know,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.697.1">
      unit testing
     </span>
    </strong>
    <span class="koboSpan" id="kobo.698.1">
     is the
    </span>
    <a id="_idIndexMarker955">
    </a>
    <span class="koboSpan" id="kobo.699.1">
     practice of writing small and isolated tests that verify the functionality and behavior of a single unit of code.
    </span>
    <span class="koboSpan" id="kobo.699.2">
     Unit testing helps to find and fix bugs, refactor and improve your code quality, document and communicate the underlying code design, and facilitate collaboration
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.700.1">
      and integration.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.701.1">
     This section will not cover the best way to group tests into logical and descriptive suites, or when you should use assertions or expectations to verify the values of different variables and tested methods outcomes.
    </span>
    <span class="koboSpan" id="kobo.701.2">
     The purpose of this section is to provide some guidelines on how to create unit tests to test asynchronous code.
    </span>
    <span class="koboSpan" id="kobo.701.3">
     Therefore, some previous knowledge
    </span>
    <a id="_idIndexMarker956">
    </a>
    <span class="koboSpan" id="kobo.702.1">
     about unit testing or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.703.1">
      test-driven development
     </span>
    </strong>
    <span class="koboSpan" id="kobo.704.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.705.1">
      TDD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.706.1">
     )
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.707.1">
      is desirable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.708.1">
     The main difficulty when dealing with asynchronous code is that it might execute in another thread, and usually without knowing when that will happen, or when it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.709.1">
      will complete.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.710.1">
     The main
    </span>
    <a id="_idIndexMarker957">
    </a>
    <span class="koboSpan" id="kobo.711.1">
     approach to follow when testing asynchronous code is to try to separate the functionality from multithreading, meaning that we might want to test the asynchronous code in a synchronous way, trying to execute it in one specific thread, removing context switching, threads creation and destruction, and other activities that might affect the result and timings on the tests.
    </span>
    <span class="koboSpan" id="kobo.711.2">
     Sometimes, timers are also used, waiting for a callback to be invoked
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.712.1">
      before timeout.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-256">
    <a id="_idTextAnchor255">
    </a>
    <span class="koboSpan" id="kobo.713.1">
     Testing a simple asynchronous function
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.714.1">
     Let’s start
    </span>
    <a id="_idIndexMarker958">
    </a>
    <span class="koboSpan" id="kobo.715.1">
     with a small example
    </span>
    <a id="_idIndexMarker959">
    </a>
    <span class="koboSpan" id="kobo.716.1">
     of testing an asynchronous operation.
    </span>
    <span class="koboSpan" id="kobo.716.2">
     This example shows a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.717.1">
      asyncFunc()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.718.1">
     function that is tested by running it asynchronously by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.719.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.720.1">
     , as shown in
    </span>
    <a href="B22219_07.xhtml#_idTextAnchor143">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.721.1">
        Chapter 7
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.722.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.723.1">
#include &lt;gtest/gtest.h&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
using namespace std::chrono_literals;
int asyncFunc() {
    std::this_thread::sleep_for(100ms);
    return 42;
}
TEST(AsyncTests, TestHandleAsyncOperation) {
    std::future&lt;int&gt; result = std::async(
                         std::launch::async,
                         asyncFunc);
    EXPECT_EQ(result.get(), 42);
}
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.724.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.725.1">
     returns
    </span>
    <a id="_idIndexMarker960">
    </a>
    <span class="koboSpan" id="kobo.726.1">
     a future that
    </span>
    <a id="_idIndexMarker961">
    </a>
    <span class="koboSpan" id="kobo.727.1">
     is used to retrieve the computed value.
    </span>
    <span class="koboSpan" id="kobo.727.2">
     In this case,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.728.1">
      asyncFunc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.729.1">
     just waits for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.730.1">
      100ms
     </span>
    </strong>
    <span class="koboSpan" id="kobo.731.1">
     before returning the value
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.732.1">
      42
     </span>
    </strong>
    <span class="koboSpan" id="kobo.733.1">
     .
    </span>
    <span class="koboSpan" id="kobo.733.2">
     If the asynchronous task runs properly, the test will pass as there is an expectation instruction checking that the returned value is in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.734.1">
      fact
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.735.1">
       42
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.736.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.737.1">
     There is only one test defined, using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.738.1">
      TEST()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.739.1">
     macro, where its first parameter is the test suite name (in this example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.740.1">
      AsyncTests
     </span>
    </strong>
    <span class="koboSpan" id="kobo.741.1">
     ) and the second parameter is the test
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.742.1">
      name (
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.743.1">
       TestHandleAsyncOperation
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.744.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.745.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.746.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.747.1">
     function, the GoogleTest library is initialized by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.748.1">
      ::testing::InitGoogleTest()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.749.1">
     .
    </span>
    <span class="koboSpan" id="kobo.749.2">
     This function parses the command line for the flags that
    </span>
    <a id="_idIndexMarker962">
    </a>
    <span class="koboSpan" id="kobo.750.1">
     GoogleTest recognizes.
    </span>
    <span class="koboSpan" id="kobo.750.2">
     Then,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.751.1">
      RUN_ALL_TESTS()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.752.1">
     is called, which collects and runs all tests and returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.753.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.754.1">
     if all tests are
    </span>
    <a id="_idIndexMarker963">
    </a>
    <span class="koboSpan" id="kobo.755.1">
     successful or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.756.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.757.1">
     otherwise.
    </span>
    <span class="koboSpan" id="kobo.757.2">
     This function originally was a macro, which is why its name is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.758.1">
      in uppercase.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-257">
    <a id="_idTextAnchor256">
    </a>
    <span class="koboSpan" id="kobo.759.1">
     Limiting test durations by using timeouts
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.760.1">
     One issue that could happen with this approach is that the asynchronous task can fail to be
    </span>
    <a id="_idIndexMarker964">
    </a>
    <span class="koboSpan" id="kobo.761.1">
     scheduled for any reason, take longer than expected to complete, or just not get completed for any reason.
    </span>
    <span class="koboSpan" id="kobo.761.2">
     To deal with this situation, a timer can be used, setting its timeout period to a reasonable value to give enough time for the test to complete successfully.
    </span>
    <span class="koboSpan" id="kobo.761.3">
     Therefore, if the timer times out, the test will fail.
    </span>
    <span class="koboSpan" id="kobo.761.4">
     The following example shows that approach by using a timed waiting on the future returned
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.762.1">
      by
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.763.1">
       std::async
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.764.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.765.1">
#include &lt;gtest/gtest.h&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
using namespace std::chrono;
using namespace std::chrono_literals;
int asyncFunc() {
    std::this_thread::sleep_for(100ms);
    return 42;
}
TEST(AsyncTest, TestTimeOut) {
    auto start = steady_clock::now();
    std::future&lt;int&gt; result = std::async(
                         std::launch::async,
                         asyncFunc);
    if (result.wait_for(200ms) ==
               std::future_status::timeout) {
        FAIL() &lt;&lt; "Test timed out!";
    }
    EXPECT_EQ(result.get(), 42);
    auto end = steady_clock::now();
    auto elapsed = duration_cast&lt;milliseconds&gt;(
                                end - start);
    EXPECT_LT(elapsed.count(), 200);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.766.1">
     Now, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.767.1">
      wait_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.768.1">
     function of the future object
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.769.1">
      result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.770.1">
     is called, waiting 200 ms for the asynchronous task to complete.
    </span>
    <span class="koboSpan" id="kobo.770.2">
     As the task will be completed in 100 ms, the timeout will
    </span>
    <a id="_idIndexMarker965">
    </a>
    <span class="koboSpan" id="kobo.771.1">
     not expire.
    </span>
    <span class="koboSpan" id="kobo.771.2">
     If for any reason
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.772.1">
      wait_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.773.1">
     is called with a value lower than 100 ms, it would time out and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.774.1">
      FAIL()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.775.1">
     macro will be called, making the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.776.1">
      test fail.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.777.1">
     The test continues running and checks if the returned value is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.778.1">
      42
     </span>
    </strong>
    <span class="koboSpan" id="kobo.779.1">
     as in the previous example, and then also checks if the time spent running the asynchronous task is less than the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.780.1">
      used timeout.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-258">
    <a id="_idTextAnchor257">
    </a>
    <span class="koboSpan" id="kobo.781.1">
     Testing callbacks
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.782.1">
     Testing
    </span>
    <a id="_idIndexMarker966">
    </a>
    <span class="koboSpan" id="kobo.783.1">
     callback is a relevant task, especially when
    </span>
    <a id="_idIndexMarker967">
    </a>
    <span class="koboSpan" id="kobo.784.1">
     implementing libraries and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.785.1">
      application programming interfaces
     </span>
    </strong>
    <span class="koboSpan" id="kobo.786.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.787.1">
      APIs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.788.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.788.2">
     The following example shows how to test that a callback has been called and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.789.1">
      its result:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.790.1">
#include &lt;gtest/gtest.h&gt;
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void asyncFunc(std::function&lt;void(int)&gt; callback) {
    std::thread([callback]() {
        std::this_thread::sleep_for(1s);
        callback(42);
    }).detach();
}
TEST(AsyncTest, TestCallback) {
    int result = 0;
    bool callback_called = false;
    auto callback = [&amp;](int value) {
        callback_called = true;
        result = value;
    };
    asyncFunc(callback);
    std::this_thread::sleep_for(2s);
    EXPECT_TRUE(callback_called);
    EXPECT_EQ(result, 42);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.791.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.792.1">
      TestCallback
     </span>
    </strong>
    <span class="koboSpan" id="kobo.793.1">
     test just defines a callback as a lambda function that accepts an argument.
    </span>
    <span class="koboSpan" id="kobo.793.2">
     This
    </span>
    <a id="_idIndexMarker968">
    </a>
    <span class="koboSpan" id="kobo.794.1">
     lambda function captures by reference the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.795.1">
      result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.796.1">
     variable where the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.797.1">
      value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.798.1">
     argument is stored, and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.799.1">
      callback_called
     </span>
    </strong>
    <span class="koboSpan" id="kobo.800.1">
     Boolean variable that by default is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.801.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.802.1">
     and set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.803.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.804.1">
     when the callback
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.805.1">
      is called.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.806.1">
     Then, the test calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.807.1">
      asyncFunc()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.808.1">
     function that spawns a thread that waits for one second before calling the callback and passing the value
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.809.1">
      42
     </span>
    </strong>
    <span class="koboSpan" id="kobo.810.1">
     .
    </span>
    <span class="koboSpan" id="kobo.810.2">
     The test waits for two seconds before checking if the callback has been called by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.811.1">
      EXPECT_TRUE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.812.1">
     macro and checking the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.813.1">
      callback_called
     </span>
    </strong>
    <span class="koboSpan" id="kobo.814.1">
     , and if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.815.1">
      result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.816.1">
     has the expected value
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.817.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.818.1">
       42
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.819.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-259">
    <a id="_idTextAnchor258">
    </a>
    <span class="koboSpan" id="kobo.820.1">
     Testing event-driven software
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.821.1">
     We saw in
    </span>
    <a href="B22219_09.xhtml#_idTextAnchor184">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.822.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.823.1">
     how to
    </span>
    <a id="_idIndexMarker969">
    </a>
    <span class="koboSpan" id="kobo.824.1">
     use
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.825.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.826.1">
     and its event queue to dispatch
    </span>
    <a id="_idIndexMarker970">
    </a>
    <span class="koboSpan" id="kobo.827.1">
     asynchronous tasks.
    </span>
    <span class="koboSpan" id="kobo.827.2">
     In event-driven programming, typically, we also need to test callbacks, as in the previous example.
    </span>
    <span class="koboSpan" id="kobo.827.3">
     We can set up the test to inject callbacks and validate the result after they are called.
    </span>
    <span class="koboSpan" id="kobo.827.4">
     The following example shows how to test asynchronous tasks in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.828.1">
      Boost.Asio program:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.829.1">
#include &lt;gtest/gtest.h&gt;
#include &lt;boost/asio.hpp&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void asyncFunc(boost::asio::io_context&amp; io_context,
               std::function&lt;void(int)&gt; callback) {
    io_context.post([callback]() {
        std::this_thread::sleep_for(100ms);
        callback(42);
    });
}
TEST(AsyncTest, BoostAsio) {
    boost::asio::io_context io_context;
    int result = 0;
    asyncFunc(io_context, [&amp;result](int value) {
        result = value;
    });
    std::jthread io_thread([&amp;io_context]() {
        io_context.run();
    });
    std::this_thread::sleep_for(150ms);
    EXPECT_EQ(result, 42);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.830.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.831.1">
      BoostAsio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.832.1">
     test starts by creating an I/O execution context object,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.833.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.834.1">
     , and
    </span>
    <a id="_idIndexMarker971">
    </a>
    <span class="koboSpan" id="kobo.835.1">
     passing it to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.836.1">
      asyncFunc()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.837.1">
     function together with a lambda function implementing a task or callback to run in the background.
    </span>
    <span class="koboSpan" id="kobo.837.2">
     This callback simply sets the value of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.838.1">
      result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.839.1">
     variable, captured by the lambda function, to the value passed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.840.1">
      to it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.841.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.842.1">
      asyncFunc()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.843.1">
     function
    </span>
    <a id="_idIndexMarker972">
    </a>
    <span class="koboSpan" id="kobo.844.1">
     just uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.845.1">
      io_context
     </span>
    </strong>
    <span class="koboSpan" id="kobo.846.1">
     to post a task that consists of a lambda function that calls the callback with the value
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.847.1">
      42
     </span>
    </strong>
    <span class="koboSpan" id="kobo.848.1">
     after waiting for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.849.1">
      100 ms.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.850.1">
     The test then just waits for 150 ms for the background task to finish and checks that the result value is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.851.1">
      42
     </span>
    </strong>
    <span class="koboSpan" id="kobo.852.1">
     to mark the test
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.853.1">
      as passed.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-260">
    <a id="_idTextAnchor259">
    </a>
    <span class="koboSpan" id="kobo.854.1">
     Mocking external resources
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.855.1">
     If the asynchronous code also depends on external resources, such as file access, network servers, timers, or other modules, we might need to mock them and avoid unwanted
    </span>
    <a id="_idIndexMarker973">
    </a>
    <span class="koboSpan" id="kobo.856.1">
     failures due to any resource issues translated into the tests.
    </span>
    <span class="koboSpan" id="kobo.856.2">
     Mocking and stubbing are techniques used to replace or modify the behavior of a real object or function with a fake or simplified one, for testing purposes.
    </span>
    <span class="koboSpan" id="kobo.856.3">
     This way, we can control the input and output of the asynchronous code and avoid side effects or interference from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.857.1">
      other factors.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.858.1">
     For example, if the tested code depends on a server, the server can fail to connect or execute its task, making the test fail.
    </span>
    <span class="koboSpan" id="kobo.858.2">
     In these cases, failures are due to resource issues, not due to the asynchronous code being tested, causing a false, and usually transient, failure.
    </span>
    <span class="koboSpan" id="kobo.858.3">
     We can mock external resources by using our own mock classes that mimic their interfaces.
    </span>
    <span class="koboSpan" id="kobo.858.4">
     Let’s see an example of how to use a mock class and use dependency injection to use that class
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.859.1">
      for testing.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.860.1">
     In this example, there is an external resource,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.861.1">
      AsyncTaskScheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.862.1">
     , whose
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.863.1">
      runTask()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.864.1">
     method is used to execute an asynchronous task.
    </span>
    <span class="koboSpan" id="kobo.864.2">
     As we only want to test the asynchronous task and remove any undesired side effects that the asynchronous task scheduler
    </span>
    <a id="_idIndexMarker974">
    </a>
    <span class="koboSpan" id="kobo.865.1">
     could generate, we can use a mock class mimicking the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.866.1">
      AsyncScheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.867.1">
     interface.
    </span>
    <span class="koboSpan" id="kobo.867.2">
     This class is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.868.1">
      MockTaskScheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.869.1">
     , which inherits from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.870.1">
      AsyncTaskScheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.871.1">
     and implements its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.872.1">
      runTask()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.873.1">
     base class method, where the task is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.874.1">
      run synchronously:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.875.1">
#include &lt;gtest/gtest.h&gt;
#include &lt;functional&gt;
class AsyncTaskScheduler {
   public:
    virtual int runTask(std::function&lt;int()&gt; task) = 0;
};
class MockTaskScheduler : public AsyncTaskScheduler {
   public:
    int runTask(std::function&lt;int()&gt; task) override {
        return task();
    }
};
TEST(AsyncTests, TestDependencyInjection) {
    MockTaskScheduler scheduler;
    auto task = []() -&gt; int {
        return 42;
    };
    int result = scheduler.runTask(task);
    EXPECT_EQ(result, 42);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.876.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.877.1">
      TestDependencyInjection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.878.1">
     test just creates a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.879.1">
      MockTaskScheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.880.1">
     object and
    </span>
    <a id="_idIndexMarker975">
    </a>
    <span class="koboSpan" id="kobo.881.1">
     a task in the form of a lambda function and uses the mock object to execute the task by running the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.882.1">
      runTask()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.883.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.883.2">
     Once the task runs,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.884.1">
      result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.885.1">
     will have the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.886.1">
      value
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.887.1">
       42
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.888.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.889.1">
     Instead of fully defining the mock class, we can also use the gMock library and mock only the needed methods.
    </span>
    <span class="koboSpan" id="kobo.889.2">
     This example shows gMock
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.890.1">
      in action:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.891.1">
#include &lt;gmock/gmock.h&gt;
#include &lt;gtest/gtest.h&gt;
#include &lt;functional&gt;
class AsyncTaskScheduler {
   public:
    virtual int runTask(std::function&lt;int()&gt; task) = 0;
};
class MockTaskScheduler : public AsyncTaskScheduler {
   public:
    MOCK_METHOD(int, runTask, (std::function&lt;int()&gt; task), (override));
};
TEST(AsyncTests, TestDependencyInjection) {
    using namespace testing;
    MockTaskScheduler scheduler;
    auto task = []() -&gt; int {
        return 42;
    };
    EXPECT_CALL(scheduler, runTask(_)).WillOnce(
        Invoke(task)
    );
    auto result = scheduler.runTask(task);
    EXPECT_EQ(result, 42);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.892.1">
     Now,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.893.1">
      MockTaskScheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.894.1">
     also inherits from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.895.1">
      AsyncTaskScheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.896.1">
     , where the interface
    </span>
    <a id="_idIndexMarker976">
    </a>
    <span class="koboSpan" id="kobo.897.1">
     is defined, but instead of overriding its methods, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.898.1">
      MOCK_METHOD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.899.1">
     macro is used instead, where the return type, the mocked method name, and its parameters
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.900.1">
      are passed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.901.1">
     Then, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.902.1">
      TestMockMethod
     </span>
    </strong>
    <span class="koboSpan" id="kobo.903.1">
     test uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.904.1">
      EXPECT_CALL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.905.1">
     macro to define an expected call to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.906.1">
      runTask()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.907.1">
     mocked method in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.908.1">
      MockTaskScheduler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.909.1">
     , which will happen only once and invoke the lambda function task, which returns the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.910.1">
      value
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.911.1">
       42
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.912.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.913.1">
     That call just happens in the next instruction where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.914.1">
      scheduler.runTask()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.915.1">
     is called, storing the returned value in the result.
    </span>
    <span class="koboSpan" id="kobo.915.2">
     The test finishes by checking if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.916.1">
      result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.917.1">
     is the expected value
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.918.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.919.1">
       42
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.920.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-261">
    <a id="_idTextAnchor260">
    </a>
    <span class="koboSpan" id="kobo.921.1">
     Testing exceptions and failures
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.922.1">
     Asynchronous
    </span>
    <a id="_idIndexMarker977">
    </a>
    <span class="koboSpan" id="kobo.923.1">
     tasks do not always succeed and generate a valid result.
    </span>
    <span class="koboSpan" id="kobo.923.2">
     Sometimes something can go wrong (network failures, timeouts, exceptions, etc.), and returning an error or throwing an exception is the way to let the user know about this situation.
    </span>
    <span class="koboSpan" id="kobo.923.3">
     We should simulate failures to ensure that the code handles
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.924.1">
      these gracefully.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.925.1">
     Testing errors or exceptions can be done in the usual way, by using a try-catch block and using assertions or expectations to check if an error is thrown and make the test succeed or fail.
    </span>
    <span class="koboSpan" id="kobo.925.2">
     GoogleTest also provides the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.926.1">
      EXPECT_ANY_THROW()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.927.1">
     macro that simplifies
    </span>
    <a id="_idIndexMarker978">
    </a>
    <span class="koboSpan" id="kobo.928.1">
     checking if an exception has happened.
    </span>
    <span class="koboSpan" id="kobo.928.2">
     Both approaches are shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.929.1">
      following example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.930.1">
#include &lt;gtest/gtest.h&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std::chrono_literals;
int asyncFunc(bool should_fail) {
    std::this_thread::sleep_for(100ms);
    if (should_fail) {
        throw std::runtime_error("Simulated failure");
    }
    return 42;
}
TEST(AsyncTest, TestAsyncFailure1) {
    try {
        std::future&lt;int&gt; result = std::async(
                             std::launch::async,
                             asyncFunc, true);
        result.get();
        FAIL() &lt;&lt; "No expected exception thrown";
    } catch (const std::exception&amp; e) {
        SUCCEED();
    }
}
TEST(AsyncTest, TestAsyncFailure2) {
    std::future&lt;int&gt; result = std::async(
                         std::launch::async,
                         asyncFunc, true);
    EXPECT_ANY_THROW(result.get());
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.931.1">
     Both
    </span>
    <a id="_idIndexMarker979">
    </a>
    <span class="koboSpan" id="kobo.932.1">
     the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.933.1">
      TestAsyncFailure1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.934.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.935.1">
      TestAsyncFailure2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.936.1">
     tests are very similar.
    </span>
    <span class="koboSpan" id="kobo.936.2">
     Both execute asynchronously the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.937.1">
      asyncFunc()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.938.1">
     function, which now accepts a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.939.1">
      should_fail
     </span>
    </strong>
    <span class="koboSpan" id="kobo.940.1">
     Boolean argument indicating whether the task should succeed and return the value
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.941.1">
      42
     </span>
    </strong>
    <span class="koboSpan" id="kobo.942.1">
     or fail and throw an exception.
    </span>
    <span class="koboSpan" id="kobo.942.2">
     Both tests make the task fail, with the difference being that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.943.1">
      TestAsyncFailure1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.944.1">
     uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.945.1">
      FAIL()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.946.1">
     macro if no exception
    </span>
    <a id="_idIndexMarker980">
    </a>
    <span class="koboSpan" id="kobo.947.1">
     is thrown, making the test fail, or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.948.1">
      SUCCEED()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.949.1">
     if an exception is caught by the try-catch block, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.950.1">
      TestAsyncFailure2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.951.1">
     uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.952.1">
      EXPECT_ANY_THROW()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.953.1">
     macro to check if an exception happens when trying to retrieve the result from the future result by calling its
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.954.1">
       get()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.955.1">
      method.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-262">
    <a id="_idTextAnchor261">
    </a>
    <span class="koboSpan" id="kobo.956.1">
     Testing multiple threads
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.957.1">
     When testing asynchronous software involving multiple threads in C++, one common and effective
    </span>
    <a id="_idIndexMarker981">
    </a>
    <span class="koboSpan" id="kobo.958.1">
     technique is using condition variables to synchronize the threads.
    </span>
    <span class="koboSpan" id="kobo.958.2">
     As we have seen in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.959.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.960.1">
     , condition variables allow threads to wait for certain conditions to be met before proceeding, making them essential for managing inter-thread communication
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.961.1">
      and coordination.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.962.1">
     Next is an example where multiple threads perform some tasks while the main thread waits for all other threads
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.963.1">
      to finish.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.964.1">
     Let’s start by defining some necessary global variables, such as the total number of threads (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.965.1">
      num_threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.966.1">
     ),
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.967.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.968.1">
     as an atomic variable that will increase each time the asynchronous task is invoked, and the condition variable,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.969.1">
      cv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.970.1">
     , and its associated mutex,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.971.1">
      mtx
     </span>
    </strong>
    <span class="koboSpan" id="kobo.972.1">
     , which will help to unblock the main thread once all asynchronous tasks have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.973.1">
      been completed:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.974.1">
#include &lt;gtest/gtest.h&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using namespace std::chrono_literals;
#define sync_cout std::osyncstream(std::cout)
std::condition_variable cv;
std::mutex mtx;
bool ready = false;
std::atomic&lt;unsigned&gt; counter = 0;
const std::size_t num_threads = 5;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.975.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.976.1">
      asyncTask()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.977.1">
     function will execute the asynchronous task (simply waiting for 100 ms in this example) before increasing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.978.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.979.1">
     atomic variable and notifying via the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.980.1">
      cv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.981.1">
     condition
    </span>
    <a id="_idIndexMarker982">
    </a>
    <span class="koboSpan" id="kobo.982.1">
     variable to the main thread that its work
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.983.1">
      is done:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.984.1">
void asyncTask(int id) {
    sync_cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; ": Starting work..."
</span><span class="koboSpan" id="kobo.984.2">              &lt;&lt; std::endl;
    std::this_thread::sleep_for(100ms);
    sync_cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; ": Work finished."
</span><span class="koboSpan" id="kobo.984.3">              &lt;&lt; std::endl;
    ++counter;
    cv.notify_one();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.985.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.986.1">
      TestMultipleThreads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.987.1">
     test will start by spawning a number of threads where each one will asynchronously run the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.988.1">
      asyncTask()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.989.1">
     task.
    </span>
    <span class="koboSpan" id="kobo.989.2">
     Then, it will wait, using a condition
    </span>
    <a id="_idIndexMarker983">
    </a>
    <span class="koboSpan" id="kobo.990.1">
     variable that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.991.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.992.1">
     has the same value as the number of threads, meaning that all background tasks have finished their work.
    </span>
    <span class="koboSpan" id="kobo.992.2">
     The condition variable sets a timeout of 150 ms using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.993.1">
      wait_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.994.1">
     function to limit the time the test can run but gives some room for all background tasks to be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.995.1">
      completed successfully:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.996.1">
TEST(AsyncTest, TestMultipleThreads) {
    std::vector&lt;std::jthread&gt; threads;
    for (int i = 0; i &lt; num_threads; ++i) {
        threads.emplace_back(asyncTask, i + 1);
    }
    {
        std::unique_lock&lt;std::mutex&gt; lock(mtx);
        cv.wait_for(lock, 150ms, [] {
            return counter == num_threads;
        });
        sync_cout &lt;&lt; "All threads have finished."
</span><span class="koboSpan" id="kobo.996.2">                  &lt;&lt; std::endl;
    }
    EXPECT_EQ(counter, num_threads);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.997.1">
     The test
    </span>
    <a id="_idIndexMarker984">
    </a>
    <span class="koboSpan" id="kobo.998.1">
     finishes by checking that indeed
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.999.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1000.1">
     has the same value
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1001.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1002.1">
       num_threads
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1003.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1004.1">
     Finally, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1005.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1006.1">
     function
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1007.1">
      is implemented:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1008.1">
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1009.1">
     As explained earlier, the program starts by initializing the GoogleTest library by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1010.1">
      ::testing::InitGoogleTest()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1011.1">
     and then calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1012.1">
      RUN_ALL_TESTS()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1013.1">
     to collect and run
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1014.1">
      all tests.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-263">
    <a id="_idTextAnchor262">
    </a>
    <span class="koboSpan" id="kobo.1015.1">
     Testing coroutines
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1016.1">
     With C++20, coroutines provide a new way to write and manage asynchronous code.
    </span>
    <span class="koboSpan" id="kobo.1016.2">
     Coroutine-based
    </span>
    <a id="_idIndexMarker985">
    </a>
    <span class="koboSpan" id="kobo.1017.1">
     code can be tested by using a similar approach to other asynchronous code, but with the subtle difference that coroutines can suspend and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1018.1">
      be resumed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1019.1">
     Let’s see an example with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1020.1">
      simple coroutine.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1021.1">
     We have seen in
    </span>
    <a href="B22219_08.xhtml#_idTextAnchor164">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1022.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1023.1">
     that coroutines have some boilerplate code to define their promise type and awaitable methods.
    </span>
    <span class="koboSpan" id="kobo.1023.2">
     Let’s start by implementing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1024.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1025.1">
     structure that will define the coroutine.
    </span>
    <span class="koboSpan" id="kobo.1025.2">
     Please revisit
    </span>
    <a href="B22219_08.xhtml#_idTextAnchor164">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1026.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1027.1">
     to fully understand
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1028.1">
      this code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1029.1">
     Let’s start by defining the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1030.1">
       Task
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1031.1">
      structure:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1032.1">
#include &lt;gtest/gtest.h&gt;
#include &lt;coroutine&gt;
#include &lt;exception&gt;
#include &lt;iostream&gt;
struct Task {
    struct promise_type;
    using handle_type =
              std::coroutine_handle&lt;promise_type&gt;;
    handle_type handle_;
    Task(handle_type h) : handle_(h) {}
    ~Task() {
        if (handle_) handle_.destroy();
    }
    // struct promise_type definition
    // and await methods
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1033.1">
     Inside
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1034.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1035.1">
     , we
    </span>
    <a id="_idIndexMarker986">
    </a>
    <span class="koboSpan" id="kobo.1036.1">
     define
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1037.1">
      promise_type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1038.1">
     , which describes how the coroutine is managed.
    </span>
    <span class="koboSpan" id="kobo.1038.2">
     This type provides certain predefined methods (hooks) that control how the values are returned, how the coroutine
    </span>
    <a id="_idIndexMarker987">
    </a>
    <span class="koboSpan" id="kobo.1039.1">
     is suspended, and how resources are managed once the coroutine
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1040.1">
      is completed:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1041.1">
struct Task {
    // ...
</span><span class="koboSpan" id="kobo.1041.2">    struct promise_type {
        int result_;
        std::exception_ptr exception_;
        Task get_return_object() {
            return Task(handle_type::from_promise(*this));
        }
        std::suspend_always initial_suspend() {
            return {};
        }
        std::suspend_always final_suspend() noexcept {
            return {};
        }
        void return_value(int value) {
            result_ = value;
        }
        void unhandled_exception() {
            exception_ = std::current_exception();
        }
    };
    // ....
</span><span class="koboSpan" id="kobo.1041.3">};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1042.1">
     Then, the methods used for controlling the suspension and resumption of the coroutine
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1043.1">
      are implemented:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1044.1">
struct Task {
    // ...
</span><span class="koboSpan" id="kobo.1044.2">    bool await_ready() const noexcept {
        return handle_.done();
    }
    void await_suspend(std::coroutine_handle&lt;&gt;
                           awaiting_handle) {
        handle_.resume();
        awaiting_handle.resume();
    }
    int await_resume() {
        if (handle_.promise().exception_) {
            std::rethrow_exception(
                handle_.promise().exception_);
        }
        return handle_.promise().result_;
    }
    int result() {
        if (handle_.promise().exception_) {
            std::rethrow_exception(
                    handle_.promise().exception_);
        }
        return handle_.promise().result_;
    }
    // ....
</span><span class="koboSpan" id="kobo.1044.3">};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1045.1">
     Having the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1046.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1047.1">
     structure in place, let’s define two coroutines, one that computes a valid value
    </span>
    <a id="_idIndexMarker988">
    </a>
    <span class="koboSpan" id="kobo.1048.1">
     and another that throws
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1049.1">
      an exception:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1050.1">
Task asyncFunc(int x) {
    co_return 2 * x;
}
Task asyncFuncWithException() {
    throw std::runtime_error("Exception from coroutine");
    co_return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1051.1">
     As test functions inside the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1052.1">
      TEST()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1053.1">
     macro in GoogleTest cannot directly be coroutines because
    </span>
    <a id="_idIndexMarker989">
    </a>
    <span class="koboSpan" id="kobo.1054.1">
     they don’t have a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1055.1">
      promise_type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1056.1">
     structure associated with them, we need to define some
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1057.1">
      helper functions:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1058.1">
Task testCoroutineHelper(int value) {
    co_return co_await asyncFunc(value);
}
Task testCoroutineWithExceptionHelper() {
    co_return co_await asyncFuncWithException();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1059.1">
     With that in place, we can now implement
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1060.1">
      the tests:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1061.1">
TEST(AsyncTest, TestCoroutine) {
    auto task = testCoroutineHelper(5);
    task.handle_.resume();
    EXPECT_EQ(task.result(), 10);
}
TEST(AsyncTest, TestCoroutineWithException) {
    auto task = testCoroutineWithExceptionHelper();
    EXPECT_THROW({
            task.handle_.resume();
            task.result();
        },
        std::runtime_error);
}
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1062.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1063.1">
      TestCoroutine
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1064.1">
     test defines a task using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1065.1">
      testCoroutineHelper()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1066.1">
     helper function
    </span>
    <a id="_idIndexMarker990">
    </a>
    <span class="koboSpan" id="kobo.1067.1">
     and passing the value
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1068.1">
      5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1069.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1069.2">
     When resuming the coroutine, it’s expected that it will return the value doubled, thus the value
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1070.1">
      10
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1071.1">
     , which is tested
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1072.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1073.1">
       EXPECT_EQ()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1074.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1075.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1076.1">
      TestCoroutineWithException
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1077.1">
     test uses a similar approach, but now using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1078.1">
      testCoroutineWithExceptionHelper()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1079.1">
     helper function, which will throw an exception when the coroutine is resumed.
    </span>
    <span class="koboSpan" id="kobo.1079.2">
     This is exactly what happens inside the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1080.1">
      EXPECT_THROW()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1081.1">
     assertion macro before checking that indeed the exception is of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1082.1">
      type
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1083.1">
       std::runtime_error
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1084.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-264">
    <a id="_idTextAnchor263">
    </a>
    <span class="koboSpan" id="kobo.1085.1">
     Stress testing
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1086.1">
     A race condition detector can be achieved by performing stress testing.
    </span>
    <span class="koboSpan" id="kobo.1086.2">
     For highly concurrent
    </span>
    <a id="_idIndexMarker991">
    </a>
    <span class="koboSpan" id="kobo.1087.1">
     or multi-threaded asynchronous code, stress testing is crucial.
    </span>
    <span class="koboSpan" id="kobo.1087.2">
     We can simulate high load with multiple asynchronous tasks to check if the system behaves correctly under stress.
    </span>
    <span class="koboSpan" id="kobo.1087.3">
     Also, it’s important to use random delays, thread interleaving, or stress-testing tools, to reduce deterministic conditions, increasing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1088.1">
      test coverage.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1089.1">
     The next example shows the implementation of a stress test that spawns 100 (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1090.1">
      total_nums
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1091.1">
     ) threads
    </span>
    <a id="_idIndexMarker992">
    </a>
    <span class="koboSpan" id="kobo.1092.1">
     that execute the asynchronous task where the atomic variable counter is increased with each run after a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1093.1">
      random wait:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1094.1">
#include &lt;gtest/gtest.h&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
std::atomic&lt;int&gt; counter(0);
const std::size_t total_runs = 100;
void asyncIncrement() {
    std::this_thread::sleep_for(std::chrono::milliseconds(rand() % 100));
    counter.fetch_add(1);
}
TEST(AsyncTest, StressTest) {
    std::vector&lt;std::thread&gt; threads;
    for (std::size_t i = 0; i &lt; total_runs; ++i) {
        threads.emplace_back(asyncIncrement);
    }
    for (auto&amp; thread : threads) {
        thread.join();
    }
    EXPECT_EQ(counter, total_runs);
}
int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1095.1">
     The test
    </span>
    <a id="_idIndexMarker993">
    </a>
    <span class="koboSpan" id="kobo.1096.1">
     succeeds if the counter has the same value as the total number
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1097.1">
      of threads.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-265">
    <a id="_idTextAnchor264">
    </a>
    <span class="koboSpan" id="kobo.1098.1">
     Parallelizing tests
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1099.1">
     To run test suites quicker we can parallelize the tests running in different threads, but tests
    </span>
    <a id="_idIndexMarker994">
    </a>
    <span class="koboSpan" id="kobo.1100.1">
     must be independent, each running in a specific thread as a synchronous single-threaded solution.
    </span>
    <span class="koboSpan" id="kobo.1100.2">
     Also, they need to set up and tear down any necessary objects without keeping the state from previous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1101.1">
      test runs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1102.1">
     When using CMake together with GoogleTest, we can run all detected tests in parallel by specifying the number of concurrent jobs we want to use with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1103.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.1104.1">
$ ctest –j &lt;num_jobs&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1105.1">
     All the
    </span>
    <a id="_idIndexMarker995">
    </a>
    <span class="koboSpan" id="kobo.1106.1">
     examples shown in this section are a small subset of what can be done for testing asynchronous code.
    </span>
    <span class="koboSpan" id="kobo.1106.2">
     We hope that these techniques provide enough insight and knowledge to develop further testing techniques that deal with specific scenarios you
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1107.1">
      might face.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-266">
    <a id="_idTextAnchor265">
    </a>
    <span class="koboSpan" id="kobo.1108.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1109.1">
     In this chapter, we learned about how to sanitize and test
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1110.1">
      asynchronous programs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1111.1">
     We started by learning how to sanitize code using sanitizers to help find multithreaded and asynchronous issues, such as race conditions, memory leaks, and use-after-scope errors, among many
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1112.1">
      other issues.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1113.1">
     Then, some testing techniques designed to deal with asynchronous software were described, using GoogleTest as the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1114.1">
      testing library.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1115.1">
     Using these tools and techniques helps detect and prevent undefined behavior, memory errors, and security vulnerabilities while ensuring that concurrent operations execute correctly, timing issues are handled properly, and code performs as expected under various conditions.
    </span>
    <span class="koboSpan" id="kobo.1115.2">
     This improves the overall program’s reliability
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1116.1">
      and stability.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1117.1">
     In the next chapter, we will learn about performance and optimization techniques that can be used to improve asynchronous programs’ runtime and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1118.1">
      resource usage.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-267">
    <a id="_idTextAnchor266">
    </a>
    <span class="koboSpan" id="kobo.1119.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1120.1">
       Sanitizers:
      </span>
     </span>
     <a href="https://github.com/google/sanitizers">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1121.1">
        https://github.com/google/sanitizers
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1122.1">
      Clang 20.0
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1123.1">
       ASan:
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/AddressSanitizer.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1124.1">
        https://clang.llvm.org/docs/AddressSanitizer.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1125.1">
      Clang 20.0 hardware-assisted
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1126.1">
       ASan:
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1127.1">
        https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1128.1">
      Clang 20.0
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1129.1">
       TSan:
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/ThreadSanitizer.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1130.1">
        https://clang.llvm.org/docs/ThreadSanitizer.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1131.1">
      Clang 20.0
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1132.1">
       MSan:
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/MemorySanitizer.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1133.1">
        https://clang.llvm.org/docs/MemorySanitizer.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1134.1">
      Clang 20.0
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1135.1">
       UBSan
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1136.1">
       :
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1137.1">
        https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1138.1">
      Clang 20.0
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1139.1">
       DataFlowSanitizer:
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/DataFlowSanitizer.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1140.1">
        https://clang.llvm.org/docs/DataFlowSanitizer.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1141.1">
      Clang 20.0
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1142.1">
       LSan:
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/LeakSanitizer.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1143.1">
        https://clang.llvm.org/docs/LeakSanitizer.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1144.1">
      Clang 20.0
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1145.1">
       RealtimeSanitizer:
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/RealtimeSanitizer.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1146.1">
        https://clang.llvm.org/docs/RealtimeSanitizer.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1147.1">
      Clang 20.0
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1148.1">
       SanitizerCoverage:
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1149.1">
        https://clang.llvm.org/docs/SanitizerCoverage.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1150.1">
      Clang 20.0
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1151.1">
       SanitizerStats:
      </span>
     </span>
     <a href="https://clang.llvm.org/docs/SanitizerStats.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1152.1">
        https://clang.llvm.org/docs/SanitizerStats.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1153.1">
      GCC:
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1154.1">
       Program Instrumentation
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1155.1">
        Options
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1156.1">
       :
      </span>
     </span>
     <a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1157.1">
        https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1158.1">
      Apple Developer:
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1159.1">
       Diagnosing memory, thread, and crash issues
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1160.1">
        early
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1161.1">
       :
      </span>
     </span>
     <a href="https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1162.1">
        https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1163.1">
      GCC:
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1164.1">
       Options for Debugging Your
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1165.1">
        Program
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1166.1">
       :
      </span>
     </span>
     <a href="https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1167.1">
        https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1168.1">
      OpenSSL:
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1169.1">
       Compiler Options Hardening Guide for C and
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1170.1">
        C++
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1171.1">
       :
      </span>
     </span>
     <a href="https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1172.1">
        https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1173.1">
      Memory error checking in C and C++: Comparing Sanitizers and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1174.1">
       Valgrind:
      </span>
     </span>
     <a href="https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1175.1">
        https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1176.1">
      The GNU C
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1177.1">
       Library:
      </span>
     </span>
     <a href="https://www.gnu.org/software/libc">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1178.1">
        https://www.gnu.org/software/libc
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1179.1">
      Sanitizers: Common
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1180.1">
       flags:
      </span>
     </span>
     <a href="https://github.com/google/sanitizers/wiki/SanitizerCommonFlags">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1181.1">
        https://github.com/google/sanitizers/wiki/SanitizerCommonFlags
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1182.1">
      AddressSanitizer
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1183.1">
       flags:
      </span>
     </span>
     <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1184.1">
        https://github.com/google/sanitizers/wiki/AddressSanitizerFlags
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1185.1">
      AddressSanitizer: A Fast Address Sanity
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1186.1">
       Checker:
      </span>
     </span>
     <a href="https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1187.1">
        https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1188.1">
      MemorySanitizer: Fast detector of uninitialized memory use in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1189.1">
       C++:
      </span>
     </span>
     <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43308.pdf">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1190.1">
        https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43308.pdf
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1191.1">
      Linux Kernel
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1192.1">
       Sanitizers:
      </span>
     </span>
     <a href="https://github.com/google/kernel-sanitizers">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1193.1">
        https://github.com/google/kernel-sanitizers
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1194.1">
      TSan
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1195.1">
       flags:
      </span>
     </span>
     <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1196.1">
        https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1197.1">
      TSan: Popular data
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1198.1">
       races:
      </span>
     </span>
     <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerPopularDataRaces">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1199.1">
        https://github.com/google/sanitizers/wiki/ThreadSanitizerPopularDataRaces
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1200.1">
      TSan report
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1201.1">
       format:
      </span>
     </span>
     <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1202.1">
        https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1203.1">
      TSan
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1204.1">
       algorithm:
      </span>
     </span>
     <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1205.1">
        https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1206.1">
      Address space layout
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1207.1">
       randomization:
      </span>
     </span>
     <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1208.1">
        https://en.wikipedia.org/wiki/Address_space_layout_randomization
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1209.1">
      GoogleTest User’s
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1210.1">
       Guide:
      </span>
     </span>
     <a href="https://google.github.io/googletest">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1211.1">
        https://google.github.io/googletest
       </span>
      </span>
     </a>
    </li>
   </ul>
  </div>
 </body></html>