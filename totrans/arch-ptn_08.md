# 事件驱动架构模式

为什么组织需要**事件驱动架构**（**EDA**）？全球的组织都在以敏捷的方式运营，并频繁地改变其结构。它们正在演变成为可以独立作为服务提供者和消费者的商业结构。这些服务提供者和消费者不一定存在于组织内部。一些商业服务外包给外部商业伙伴，而组织内部的其他商业服务正在寻求向外部组织提供其服务，除了内部业务线。所有这些新兴趋势都需要具有高度自主性的流程架构，换句话说，就是组织内部各种应用组件之间的高度松散耦合。对高度松散耦合架构的需求导致了EDA的演变。使用EDA，组织可以快速重组其结构，而无需改变其应用程序结构。现在，让我们开始探讨EDA的细节。

在广义上，事件指的是任何对组织/企业/最终用户感兴趣的状态变化。汽车中指示汽油低量的信号、手机铃声以及家中烟雾报警器的铃声都是我们在日常生活中遇到的某些真实世界事件的例子。通过以下图例的帮助，理解事件的概念更容易一些：

![图片](img/c2f95cf4-938d-4c8d-b0d0-964293edf98a.png)

该图描述了一个订单管理系统中的动作流程。一旦订单管理系统从网站或订单录入系统接收到订单，下一步就是通知其他系统关于该订单的信息。在这一步中，接收订单是一个事件。这个事件需要发布给其他可能对此事件感兴趣的系统。在这个例子中，可能对此事件感兴趣的其他系统是一个仓库管理系统，它会检查存储在仓库中的库存中的订单项以确保其可用性，以及一个财务系统，它会检查与订单相关的信用余额或支付机制。

每个系统都会依次向其他需要完成下一步订单处理的系统发布事件。因此，仓库系统可能会发布一个分配库存的事件，而财务系统可能会向运输系统发布一个支付验证的事件。运输系统随后将进行必要的安排，将订单发送给客户。在这个特定的事件流程中，这些是事件流程的一部分的组件系统。但根据每个步骤事件处理的结果，可能还有其他几个系统可以成为事件流程的一部分。例如，如果仓库管理系统检测到订单中放置的物品库存水平低，它将触发一个事件到采购系统以采购该物品。同样，如果财务系统检测到信用余额低或支付选项不正确，它将向客户发送电子邮件通知，告知信用余额低或支付未成功完成。

从这个例子中，我们了解到EDA的核心概念是**发布**/**订阅**。在先前的例子中，订单管理系统向两个已订阅该事件的感兴趣方发布订单事件，即仓库管理系统和财务系统。这两个系统随后将事件发布到运输系统等。在EDA模式背景下，有三个重要的定义如下：

+   **事件**：事件是由软件元素在运行时执行的操作，用于使某些信息（包括它发生的信息）可供潜在的非指定操作软件元素使用。

+   **发布者**：触发（或发布）一个事件就是执行它。可能触发事件的软件元素是发布者。可能使用事件信息的软件元素是订阅者。

+   **上下文**：在事件驱动设计中，上下文是在注册时由订阅者指定的布尔表达式，但在触发时评估，这样注册的动作只有在评估结果为真时才会执行。

事件驱动模式是一类近年来由于行业范式快速变化而获得大量关注的模式。许多人容易混淆**面向服务的架构**（SOA）和EDA模式。在下一节中，我们将尝试分析和理解两者之间的区别。

# 面向服务的架构和事件驱动架构（SOA与EDA）

世界各地的组织正在迅速改变其结构，并向按需商业模式转变。设置以网络为中心的商业结构趋势在增加，这将拥有自主的服务提供者和消费者。外包也非常突出，因为业务流程的许多部分也将外包给外部商业伙伴。组织内部存在的各个部门和业务单元正在承担服务提供者的角色。这些服务提供者的重点是越来越多地向外部市场实体提供服务。这要求组织足够敏捷，能够快速应对外部环境中的变化或事件。所有这些方面都要求从命令驱动、紧密耦合、服务驱动的SOA概念向更松散耦合的事件驱动模型转变。EDA是一种发布/订阅类型的模式。在EDA的背景下，发布者对订阅者一无所知，反之亦然。EDA模式中的组件耦合非常松散，它们之间只有消息的语义是共享的。现在，需要做出的决定是何时使用SOA和何时使用EDA。

由于它们的工作性质，人们普遍倾向于将EDA和SOA互换使用。但情况不应如此。这两个架构选项之间存在明显的区别。对于需要业务流程强凝聚力的场景，SOA是理想的架构选择。以下是一些命令/控制风格的SOA可能成为组织理想架构选择的场景：

+   如果存在组织内各种功能层级之间的垂直交互

+   如果存在功能请求和回复流程，例如人机对话，其中用户提出问题并等待答案

+   如果存在需要提交和回滚功能的交易性质流程

+   如果需要数据丰富化，以便以正式格式发布消息的全部内容

EDA是那些需要在各种流程之间实现松散耦合的组织的首选风格。EDA是联邦和自主处理环境中的架构选择。以下是一些EDA作为组织理想架构选择的场景：

+   如果存在属于流程链各层的横向通信

+   如果一个组织中有工作流程类型的流程

+   如果存在涉及组织跨职能边界的流程，例如，B2B流程

在架构中追求松散耦合始终为现代组织提供必要的灵活性和敏捷性。因此，在设计组织架构时应遵循的规则是尽可能使用松散耦合，只有在必要时才使用紧密耦合的架构选项。在做出架构设计选择时，还应考虑设计的其他方面，如性能、响应时间等。在一个典型的企业级组织中，以下图展示了与EDA和SOA架构相关的流程的分支和关系：

![图片](img/b39f1fe8-62e9-46e2-ab44-97553635e40e.png)

在图中，顶部的圆圈表示松散耦合的系统，这些系统是作为解耦点或事件的理想选择。在这些解耦点上，各个系统组件可以连接或断开，而不会改变连接的相邻系统。组织内部各个领域之间的数据交换仅在解耦点上发生，而不是在紧密耦合的系统较低层级上。在重用领域（如图底部所示），由于组件之间紧密集成，需要精细粒度的EDA实现来解耦。EDA实现越精细，IT系统的灵活性就越大，但这也将减少领域的重用范围。

在前面的图中，如果在解耦点使用Web服务技术，并结合如企业服务总线这样的通用基础设施骨干，建立异构系统之间的连接就非常容易。下游存在的系统不必仅仅是SOA；它们也可以是SOAP包装的遗留系统、**商业现货软件**（**COTS**）或其他如ERP等应用程序。以下图展示了EDA与SOA的集成。在这个图中，组件通过解耦点连接，这些解耦点是事件：

![图片](img/c4831894-3af5-4267-b849-3beb6c8a512f.png)

现在，我们已经清楚地了解了EDA和SOA之间的区别。在下一节中，我们将学习EDA模式的部分。这些组件应该是任何使用EDA模式的架构的一部分。

# 事件驱动模式的关键特性

如果一个系统中的组件发布和接受事件，你能将其视为EDA模式的一个例子吗？对这个问题的答案是明确的否定。在本节中，我们将检查EDA模式的特点。它们的主要特点如下：

+   **多播通信**：发布者或参与系统有向已订阅该事件的多系统发送事件的能力。换句话说，这不是单播通信，其中发送者只能向一个接收者发送数据。

+   **实时传输**：发布者将事件实时发布给订阅者。换句话说，这里涉及的处理或传输模式是实时，而不是批量处理。

+   **异步通信**：发布者在发送下一个事件之前不会等待接收者处理当前事件。

+   **细粒度通信**：发布者继续发布单个细粒度事件，而不是等待单个聚合事件。

+   **本体**：EDA 系统总是有一种根据事件的一些共同特征将事件分类为某种形式的组/层次结构的技术。这为订阅者提供了订阅特定事件或特定类别事件的灵活性。

# EDA 模式的组件

EDA 模式的核心组件如下：

+   事件规范

+   事件处理

+   事件工具

+   企业集成

+   源和目标

所有这些组件以及各种其他子组件总结在下图中：

![图片](img/dd43f4d5-37fc-42f8-be7f-bbb670fe9221.png)

任何电子设计自动化（EDA）的核心组件都是强大的元数据架构。事件元数据架构的核心组件包括以下内容：

+   **事件规范**：这些事件规范应提供给事件生成器、事件处理引擎和事件转换器。目前还没有行业认可的事件定义和处理标准；它们正处于发展阶段。

+   **事件处理**：这是一种处理和分析事件数据流的技术，目的是从中得出某种结论，例如，一个主要功能是预测气旋发生的天气预测系统。为了得出这个结论，系统应该考虑几个模式，如风速、流向方向、大气压力、含水量等。所有这些参数构成了事件数据，这些数据应由事件引擎处理，以便得出特定的结论。因此，任何事件处理所需的必要组件如下：

    +   事件引擎

    +   事件数据

+   **事件工具**：事件开发工具在事件处理方面提供了以下关键功能：

    +   定义事件规范

    +   定义事件处理规则

    +   管理事件订阅

它们还提供附加功能，如监控事件处理基础设施和事件流。

+   **企业集成**：这在 EDA 设计中扮演着关键角色。一些必要的集成服务包括以下内容：

    +   事件预处理

    +   事件通道传输

    +   服务调用

    +   发布和订阅

    +   企业信息访问

+   **来源和目标**：来源指的是生成事件的企业的组件。这可能指的是系统、服务、自动化代理，甚至是负责创建事件的人。目标指的是基于事件发生或基于事件结果执行动作的组件。事件来源和目标拓扑由多个参数控制，如下所示：

    +   事件流

    +   事件发生量

    +   来源和目标的位置等

事件流是EDA架构的一个重要组成部分。在下一节中，我们将看到事件流中存在的各种逻辑层。这些逻辑层组件需要仔细选择和设计，以确保EDA模式的成功实施。

# 事件流层

事件流中存在的四个逻辑层如下：

+   事件生成器

+   事件通道

+   事件处理

+   下游事件驱动活动

# 事件生成器

生成事件的来源被称为**事件生成器**。来源可以是应用程序、服务、业务流程、传感器、数据库，甚至是人类。一个生成的事件将通过事件过滤器进行显著性的评估，如果评估成功，则导致显著事件的生成。由于事件生成的来源多种多样，并非所有生成的事件都适合处理。对于此类事件，在将它们发送到事件通道之前，有必要确保它们被转换为兼容的格式。

# 事件通道

这充当了EDA的传输介质和消息骨干。它从事件生成器接收标准格式的事件并将它们发送到其他事件生成器、事件处理引擎和下游订阅者。

# 事件处理

一旦接收到事件，它们将根据存储在事件处理引擎中的某些规则进行处理和评估。根据评估结果，将启动特定的行动方案。事件规则是根据组织和其他相关方指定的标准创建的。事件处理可能导致多个行动方案，例如通知某个系统/机构、采取替代行动方案、启动业务流程等。

# 下游事件驱动活动

任何事件都可以触发一系列下游活动，这可能是对事件的响应。事件可以是事件处理引擎的推送通知或订阅者的拉取通知。在此上下文中，订阅者可以指应用程序、人类、服务或业务流程。

# 事件驱动模式的设计考虑因素

在本节中，我们将解释在选择架构实现前的EDA模式时需要考虑的各种设计因素。主要考虑因素如下：

+   **敏捷性**：敏捷性指的是应对环境快速变化的能力。在EDA模式中，组件是松散耦合的。这确保了某个组件的变化不会影响系统中的其他组件。因此，EDA模式提供的敏捷度很高，使其成为设计需要持续变化且无需停机时间的系统的理想选择。

+   **部署简便性**：EDA模式组件本质上是松散耦合的，这使得它们的部署非常容易。对于需要最大部署简便性的解决方案，事件代理拓扑比事件中介拓扑更好。这是因为事件中介拓扑中，事件中介和事件处理器之间存在相对紧密的耦合。

+   **可测试性**：由于需要特殊的测试客户端和测试工具来生成测试所需的事件，因此EDA模式组件的单元测试比较困难。

+   **性能**：EDA能够并行执行异步操作，这为架构提供了非常高的性能，无论涉及的消息排队和出队的时间滞后如何。

+   **可伸缩性**：由于组件高度解耦，EDA提供了高水平的可伸缩性。

+   **开发简便性**：由于模式的异步特性，使用此模式进行开发的简便性较低。

尽管EDA模式有明确的组件，但其实现风格根据系统功能类型和复杂度而变化。在下一节中，我们将了解EDA模式实现的多种风格。

# EDA模式的实现变体

EDA模式实现的多种风格如下：

+   简单事件处理模式

+   事件流处理模式

+   复杂事件处理模式

# 简单事件处理模式

这些模式用于测量与特定可测量条件变化相关的事件。这些模式用于需要触发实时工作流而没有任何其他约束或考虑的场景。在架构中使用简单事件处理模式时，不考虑滞后时间和与业务相关的成本。此类模式的使用场景可能包括通过传感器检测温度/压力变化。让我们借助本章开头使用的订单管理系统示例来解释简单事件处理。以下是重复的图表，供快速参考：

**![](img/76801b14-541a-4908-8882-62c6daffdd02.png)**

在这个例子中，订单进入订单管理系统后，第一个事件是触发对仓库管理系统进行库存水平检查的通知，以及对财务系统进行支付验证的通知。为了简化，我们只考虑一个事件流：与仓库管理（与库存检查相关）相关的事件。一旦订单进入仓库管理系统，订单中的项目就会使用库存检查服务与仓库中现有的库存进行核对。库存检查服务分配与订单中现有项目相关的库存，然后检查剩余库存以确定库存阈值的最佳水平。如果仓库中的库存低于可用阈值，库存检查服务会生成一个低库存阈值事件。此事件由以下图中所示的单个事件处理引擎接收。在此示例中，事件处理规则将启动两组事件来处理低库存阈值情况：第一组是重新订购库存的过程，第二组是发布事件供订阅者消费。在这个特定的例子中，订阅者是库存买家，还会生成一个通知给库存控制员。所有这些活动都在以下图中展示：

![图片](img/6cb4cc77-ec81-4c2a-8006-1ec92432f1a1.png)

# 事件流处理模式

在事件流处理中，发生的事件会被筛选出值得注意的部分，然后发送给订阅者。这种风格的使用是为了确保实时信息在企业内部和外部流动。这种模式促进了实时决策。

让我们通过本章中讨论的订单处理示例进一步演示这种类型的事件。在订单处理示例中，如果我们考虑仓库中的事件序列，RFID传感器会为每个离开仓库的产品生成一个事件。在这种情况下，例如，假设一个零售商希望在高档产品离开仓库时得到通知。为了满足这一要求，已经设计了一个本地事件过滤器，其中包含过滤掉价格低于$5,000的物品事件的规则。假设购买了一个价值$6,000的高价值物品。这个事件，即高价值事件，被重新格式化为标准事件格式，并放置在事件通道中。事件处理引擎接收事件，将其映射到仓库中高档产品离开的规则，并发布它。订阅了此事件的订阅者会收到它；在这个例子中，它可能是一个库存经理的仪表板。

# 复杂事件处理（CEP）模式

在CEP中，考虑简单事件和普通事件的组合，以判断是否发生了复杂事件。考虑的各种事件可能需要在长时间内评估。各种事件之间的相关性可能发生在多个维度上，如时间、因果和空间。为了进行这种评估，CEP需要以下组件：

+   事件解释器

+   事件模式定义

+   事件模式匹配

+   事件相关性技术

CEP通常用于响应业务中的异常，以及评估机会和威胁。

EDA模式有两种不同的风味或拓扑。每种拓扑只需要在特定场景中实现，因为它们的特性和特征不同。因此，了解这些拓扑非常重要，以便在它们的选择和实施方面做出明智的决定。在下一节中，我们将了解各种EDA模式拓扑。

# 事件驱动模式类型

事件驱动模式有两种拓扑类型：

+   事件中介拓扑模式

+   事件代理拓扑模式

当需要通过中央中介编排事件的一部分的多个步骤时，使用中介拓扑模式。当需要将多个事件链接在一起而不需要中央中介时，使用代理拓扑。接下来将讨论每种模式的架构和组件。

# 事件中介拓扑模式

中介拓扑模式用于设计需要一定程度的协调/编排以处理事件的系统/流程。这种场景的理想例子可以是订单处理示例，其中包含多个步骤，如订单录入、库存验证、财务验证等。所有这些步骤都需要一定程度的编排，以便评估它们是否可以串行或并行执行。中介拓扑中有四个主要组件：

+   事件队列

+   事件中介

+   事件通道

+   事件处理器

所有这些组件都在以下图中表示：

![图片](img/88f83ee2-ad29-448a-b57a-31d427e1c05a.png)

客户端发送一个事件，然后由事件队列接收。事件队列将事件传输到事件中介。事件中介接收事件并编排它。这是通过向各个事件通道发送额外的异步事件来完成的，这些事件通道随后将执行每个步骤。事件处理器从事件通道接收事件并应用业务逻辑来处理事件。在EDA中可以有任意数量的事件队列。事件队列可以实施为消息队列、Web服务组件或任何适合考虑的系统的其他形式。此模式提供了两种类型的事件：

+   **初始事件**：这指的是中介者接收到的原始事件

+   **处理事件**：这指的是由中介者生成并发送到事件处理组件的事件

事件中介者主要负责对初始事件中存在的各个步骤进行编排。为了执行初始事件中的每个步骤，事件中介者会将特定的处理事件发送到事件通道。这个处理事件被事件处理器接收并处理。事件通道用于将每个步骤关联的处理事件传递给事件处理器。事件通道可以是消息队列的形式，也可以是消息主题的形式。处理事件所需的应用逻辑存在于事件处理器中。事件处理器通常是高度解耦的架构组件，与系统中的特定任务相关联。

# 事件代理拓扑模式

事件代理拓扑模式用于事件流相对简单且不需要任何中央事件编排的场景。事件代理拓扑模式的主要组件如下：

+   代理

+   事件处理器

事件代理拓扑模式的组件在以下图中展示：

![图片](img/fa9ec3ff-a42b-429d-b0ca-a1d7e7fb6ed3.png)

事件代理组件包含所有事件通道，可以设计为集中式或联邦式。事件代理拓扑模式与事件中介者拓扑模式的主要区别在于缺少控制并编排事件的组件。而不是事件中介者，事件处理器执行处理和发布每个事件的角色，表明特定操作已完成。代理组件可以是集中式或联邦式，并包含事件流中使用的所有事件通道。代理组件中包含的事件通道可以是消息队列、消息主题或两者的组合。

在下一节中，我们将讨论一些事件驱动模式的变体。

# 集中辐射模式

集中辐射模式是事件代理拓扑模式的一种变体。在集中辐射架构中，中心作为集中式代理，辐射作为连接应用程序到中心的适配器。辐射与一个应用程序建立连接，并将应用程序数据转换为中心可以理解的格式。中心将传入的数据转换为目的地系统可以理解的格式，并相应地进行消息路由。存在单个中心使这种架构易于管理，但同时也限制了架构的可扩展性：

![图片](img/452ef8f6-375a-48fa-a625-07b7565fde3a.png)

为了克服这一限制，联邦中心辐射式架构的概念已经发展起来。在联邦中心辐射式架构中，存在多个中心。每个中心拥有本地元数据和规则，以及全局元数据。对全局元数据和规则的任何更改都会自动传播到其他本地中心。联邦中心辐射式架构通过促进中心的集中管理，提供了可扩展性和灵活性。

# 广播模式

在广播模式中，也称为**发布**/**订阅**广播模式，信息被发送到网络中所有存在的各方。只有感兴趣的各方接收消息；其他人丢弃消息。如果网络中的系统具有丢弃不需要消息的效率，那么这种模式非常适合设计此类系统。当涉及到在网络级别实现这种模式时，一种称为**用户数据报协议**（UDP）的**互联网协议**（IP）变体允许我们向网络中的所有计算机发送一条信息。这是适用于网络的广播事件模式的一种变体。

# 轮询模式

在此模式中，订阅者联系发布者以了解他们是否有任何感兴趣的内容。这很少使用，因为它涉及大量的系统资源浪费。想象一下，当订阅者没有新内容时，他们向发布者轮询50次。

事件驱动模式近年来在实现方式上略有不同，以适应不断变化的技术环境。在下一节中，我们将了解系统中事件驱动模式的实际实现。

# 系统或过程中的EDA模式实现

在本节中，我们将讨论在过程中实现事件驱动模式。涉及此实现的主要组件如下：

+   事件队列

+   事件日志

+   事件收集器

+   回复队列

+   读事件与写事件

本节将解释这些组件以及该架构的整体功能。此实现的核心组件是一个中心事件队列。所有事件在处理之前都插入到中心事件队列中。以下图展示了基于队列的架构：

![图片](img/0ef9c87b-9984-462f-b678-a4e7663a77df.png)

当事件被插入队列时，它们被放置在一定的顺序中，以便可以跟踪系统响应事件的顺序。

# 事件日志

需要对添加到中央事件队列的消息有一个备份和恢复机制。这是通过将所有事件细节写入事件日志来完成的，该日志通常放置在磁盘上。在系统崩溃的情况下，可以通过从事件日志中恢复其状态来重建系统的状态。因此，事件日志的主要目的是确保事件持久化。为了使备份机制更强大，可以备份事件日志，这相当于备份了系统的状态。这些备份副本也可以在它们实际部署到生产之前用于对新版本进行试点性能测试。以下是对事件日志的图表：

![图片](img/84fe5645-63b8-4de1-861e-63e08ec230d1.png)

# 事件收集器

事件请求来自不同的来源，它们以HTTP请求或其他格式通过网络形式到达系统。这些事件通过事件收集器从不同的来源收集。以下图表展示了带有收集器的EDA：

![图片](img/c72babfb-ba3a-4a0c-9bd3-8973a7590f18.png)

# 回复队列

在某些场景中，需要向事件请求发送响应。在这种情况下，需要有一个响应或回复队列来提供支持。以下图表展示了一个这样的例子。从图表中可以看出，响应需要发送回适当的事件收集器。例如，如果传入的请求是以HTTP格式发送的，并且是由HTTP收集器发送到事件队列的，那么响应必须通过HTTP收集器仅发送回源地址。这里需要注意的是，响应不会记录在事件日志中：

![图片](img/820bbc94-9076-48f0-a475-693ecbf2a219.png)

# 提高基于事件驱动架构（EDA）的过程/系统的性能

在持久化事件的情况下，所有推送到事件队列的事件都会持久化到事件日志中。这使得系统变慢。为了提高系统的性能，应该有一个机制来只持久化那些能够改变系统状态的事件，也就是说，读取事件不会改变系统的状态，而写入事件将会改变状态。因此，应该有一个机制来只持久化写入事件。

这可以通过事件收集器通过区分读取事件和写入事件来实现。还应该有单独的队列来处理读取和写入事件。使用这种机制，可以很容易地确保读取事件队列中的事件不被持久化，而只有写入事件队列中的事件被持久化。这一概念在以下图表中展示：

![图片](img/ff8a0d81-8b0e-4789-a5e9-91bdc7003a68.png)

在实践中，将会有三个队列：读取事件队列、写入事件队列和回复队列。尽管看起来很复杂，但从实现的角度来看，它相当简单。

从事件日志中重新创建系统状态是使用 EDA 系统的最重要好处。

大多数 EDA 模式实现都是以 COTS 产品和/或自建解决方案的形式完成的。在下一节中，我们将看到 IBM WebSphere MQ，这是市场上最突出的 EDA 产品之一。

# IBM WebSphere MQ

IBM WebSphere MQ 用于为应用程序提供消息支持。它具有在多种网络中传输消息的能力。当需要发送或接收消息时，应用程序可以连接到 IBM WebSphere MQ。IBM WebSphere MQ 可以处理不同类型的处理器、操作系统、子系统和其他通信协议，在系统之间传输消息时。另一个特性是在传输消息时，如果它发现处理器不可用，可以将消息放入队列，并在处理器或系统可用后再次传输。以下是 IBM WebSphere MQ 支持的不同操作模式，它被认为是一个消息和队列应用程序：

+   点对点传输

+   发布/订阅

+   文件传输

WebSphere MQ 的关键特性如下所述：

+   **消息传递**: 进程通过发送消息相互通信，而不是通过调用。

+   **队列**: 发送的消息被放置在队列中，然后按顺序处理，这样不同的进程可以独立工作，而无需任何直接连接和相关的开销。

+   **点对点**: 可以向一系列队列发送多播/广播消息。因此，发送者需要知道目标名称，但不必知道目标的位置。

+   **发布**/**订阅**: 所有对特定类型或类别的消息感兴趣的应用程序都将订阅由特定应用程序/进程发布的那些消息。

+   **多播**: 这加快了消息传输的速度。它使发布者能够同时向网络中的多个订阅者发送消息。

+   **遥测**: IBM WebSphere MQ Telemetry 设计用于支持设备消息传递。它建立设备与应用程序消息之间的连接。它提供了应用程序、互联网、服务等各种组件与仪器化设备网络之间的连接。IBM WebSphere MQ Telemetry 随带一个非常高效的协议，为通过网络连接的大量设备提供消息支持。此消息协议已发布，以便可以将其添加到设备中。

# EDA 的新兴趋势

在本节中，我们将探讨事件驱动架构模式领域的一些最新进展。

# 事件驱动微服务

大多数组织正在从目前分立的单体应用程序转向微服务的概念，以实现敏捷性并在市场上获得竞争优势。使用微服务时出现的一个主要问题是分布式数据管理。每个微服务都有自己的私有数据库。设计更新多个微服务在多个不同数据库中拥有的实体的业务事务是一个主要问题。这给维护数据库中现有数据的一致性带来了极大的困难。以下图表展示了这一点：

![图片](img/a1059d1a-2708-4a84-ac7f-a826fc3d0f33.png)

EDA为使用微服务时分布式数据库中出现的这个问题提供了一个解决方案。在EDA中，当有变化时，一个服务会发布事件。其他感兴趣的服务会订阅这些事件。一旦收到事件，服务通常会更新其自身状态，并发布更多事件，这些事件反过来可能被其他服务消费。事件驱动的方法提供了实现一致事务的功能。以下图表描述了EDA如何帮助实现多个服务使用的业务事务的一致性。图表中的示例是我们在本章开头使用的订单管理示例：

![图片](img/dd8608ed-b2f8-4df2-b5b1-4e25cce5b435.png)

# 复杂事件处理

近期，许多有趣的用例在复杂事件周围发展起来。统计函数，如事件相关性和聚合，以及计算算法正在应用于事件数据，以揭示有意义的模式，为多个领域/行业提供有价值的用例。其中一个突出的用例是在银行领域检测交易欺诈。另一个有希望的应用是天气预报，其中几个大气参数被关联起来以预测台风、地震等。世界上许多用于天气预报的指挥中心都是基于EDA运行的。

# 物联网（IoT）与EDA

物联网（IoT）指的是嵌入在计算设备中的所有对象的相互连接，这反过来又帮助它们发送和接收数据。在这种情况下，我们周围的任何物体都将变成智能物体，并且可以持续向已订阅接收其消息的其他物体发送消息。到2020年，预计将有3万亿个物体通过物联网相互连接。所有这些物体都通过EDA架构来运行。这表明EDA在未来几年具有巨大的潜力。

# 参考文献

[http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html](http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html)

[https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.5.0/com.ibm.mq.pro.doc/q001020_.htm](https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.5.0/com.ibm.mq.pro.doc/q001020_.htm)

# 摘要

在本章中，我们讨论了 EDA 模式的各个方面。我们首先介绍了事件和事件驱动模式的定义和描述。然后我们详细讨论了 EDA 的各种组件。EDA 模式有两种拓扑变体，每种变体根据系统需求都有特定的使用场景。这些模式和它们的组件都进行了详细讨论。

EDA 模式有多种变体。本章详细讨论了这些模式及其特性。EDA 模式在其工作中有多个层次，每个层次都包含特定的组件。本章讨论了这些层次及其组件。SOA 和 EDA 是相关概念，它们相互补充。本章详细讨论了它们的相似性、差异和使用场景。本章最后讨论了 EDA 领域的新兴趋势。
