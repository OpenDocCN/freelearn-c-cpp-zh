- en: Chapter 4. Preparing Optimizations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 准备优化
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Various levels of optimization
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的优化级别
- en: Writing your own LLVM pass
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的 LLVM 插件
- en: Running your own pass with the opt tool
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 opt 工具运行自己的插件
- en: Using another pass in a new pass
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新插件中使用另一个插件
- en: Registering a pass with pass manager
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插件管理器注册插件
- en: Writing an analysis pass
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个分析插件
- en: Writing an alias analysis pass
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写别名分析插件
- en: Using other analysis passes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其他分析插件
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Once the source code transformation completes, the output is in the LLVM IR
    form. This IR serves as a common platform for converting into assembly code, depending
    on the backend. However, before converting into an assembly code, the IR can be
    optimized to produce more effective code. The IR is in the SSA form, where every
    new assignment to a variable is a new variable itself—a classic case of an SSA
    representation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦源代码转换完成，输出将以 LLVM IR 形式呈现。这个 IR 作为将代码转换为汇编代码的通用平台，具体取决于后端。然而，在转换为汇编代码之前，IR
    可以被优化以生成更有效的代码。IR 是 SSA 形式，其中每个对变量的新赋值都是一个新变量——这是 SSA 表示的经典案例。
- en: In the LLVM infrastructure, a pass serves the purpose of optimizing LLVM IR.
    A pass runs over the LLVM IR, processes the IR, analyzes it, identifies the optimization
    opportunities, and modifies the IR to produce optimized code. The command-line
    interface **opt** is used to run optimization passes on LLVM IR.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 基础设施中，一个插件用于优化 LLVM IR。插件在 LLVM IR 上运行，处理 IR，分析它，识别优化机会，并修改 IR 以生成优化代码。命令行界面
    **opt** 用于在 LLVM IR 上运行优化插件。
- en: In the upcoming chapters, various optimization techniques will be discussed.
    Also, how to write and register a new optimization pass will be explored.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，将讨论各种优化技术。还将探讨如何编写和注册新的优化插件。
- en: Various levels of optimization
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的优化级别
- en: There are various levels of optimization, starting at 0 and going up to 3 (there
    is also `s` for space optimization). The code gets more and more optimized as
    the optimization level increases. Let's try to explore the various optimization
    levels.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 优化级别有多种，从 0 级开始，到 3 级结束（也有 `s` 用于空间优化）。随着优化级别的提高，代码的优化程度也越来越高。让我们尝试探索各种优化级别。
- en: Getting ready...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Various optimization levels can be understood by running the opt command-line
    interface on LLVM IR. For this, an example C program can first be converted to
    IR using the **Clang** frontend.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 LLVM IR 上运行 opt 命令行界面，可以理解不同的优化级别。为此，可以使用 **Clang** 前端首先将一个示例 C 程序转换为 IR。
- en: 'Open an `example.c` file and write the following code in it:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 `example.c` 文件，并在其中编写以下代码：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now convert this into LLVM IR using the `clang` command, as shown here:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以使用 `clang` 命令将其转换为 LLVM IR，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A new file, `example.ll`, will be generated, containing LLVM IR. This file will
    be used to demonstrate the various optimization levels available.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将生成一个新的文件，`example.ll`，其中包含 LLVM IR。此文件将用于演示可用的各种优化级别。
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Do the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'The opt command-line tool can be run on the IR-generated `example.ll` file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在生成的 IR 文件 `example.ll` 上运行 opt 命令行工具：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `–O0` syntax specifies the least optimization level.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`–O0` 语法指定了最低的优化级别。'
- en: 'Similarly, you can run other optimization levels:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，您可以运行其他优化级别：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The opt command-line interface takes the `example.ll` file as the input and
    runs the series of passes specified in each optimization level. It can repeat
    some passes in the same optimization level. To see which passes are being used
    in each optimization level, you have to add the `--debug-pass=Structure` command-line
    option with the previous opt commands.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: opt 命令行界面接受 `example.ll` 文件作为输入，并运行每个优化级别中指定的插件系列。它可以在同一优化级别中重复某些插件。要查看每个优化级别中使用的插件，您必须添加
    `--debug-pass=Structure` 命令行选项到之前的 opt 命令中。
- en: See Also
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: To know more on various other options that can be used with the opt tool, refer
    to [http://llvm.org/docs/CommandGuide/opt.html](http://llvm.org/docs/CommandGuide/opt.html)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于可以与 opt 工具一起使用的其他选项，请参阅 [http://llvm.org/docs/CommandGuide/opt.html](http://llvm.org/docs/CommandGuide/opt.html)
- en: Writing your own LLVM pass
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自己的 LLVM 插件
- en: All LLVM passes are subclasses of the `pass` class, and they implement functionality
    by overriding the virtual methods inherited from `pass`. LLVM applies a chain
    of analyses and transformations on the target program. A pass is an instance of
    the Pass LLVM class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有LLVM pass都是`pass`类的子类，它们通过重写从`pass`继承的虚方法来实现功能。LLVM对目标程序应用一系列分析和转换。pass是Pass
    LLVM类的实例。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s see how to write a pass. Let''s name the pass `function block counter`;
    once done, it will simply display the name of the function and count the basic
    blocks in that function when run. First, a `Makefile` needs to be written for
    the pass. Follow the given steps to write a `Makefile`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写一个pass。让我们把这个pass命名为`function block counter`；一旦完成，它将在运行时简单地显示函数的名称并计算该函数中的基本块数量。首先，需要为这个pass编写一个`Makefile`。按照以下步骤编写`Makefile`：
- en: 'Open a `Makefile` in the `llvm lib/Transform` folder:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`llvm lib/Transform`文件夹中打开一个`Makefile`：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Specify the path to the LLVM root folder and the library name, and make this
    pass a loadable module by specifying it in `Makefile`, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定LLVM根文件夹的路径和库名称，并在`Makefile`中指定它，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This `Makefile` specifies that all the `.cpp` files in the current directory
    are to be compiled and linked together in a shared object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Makefile`指定当前目录中的所有`.cpp`文件都要编译并链接成一个共享对象。
- en: How to do it…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Do the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a new `.cpp` file called `FuncBlockCount.cpp`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FuncBlockCount.cpp`的新`.cpp`文件：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this file, include some header files from LLVM:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，包含一些来自LLVM的头文件：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Include the `llvm` namespace to enable access to LLVM functions:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含`llvm`命名空间以启用对LLVM函数的访问：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then start with an anonymous namespace:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从匿名命名空间开始：
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next declare the pass:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来声明这个pass：
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then declare the pass identifier, which will be used by LLVM to identify the
    pass:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后声明pass标识符，LLVM将使用它来识别pass：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This step is one of the most important steps in writing a pass—writing a `run`
    function. Since this pass inherits `FunctionPass` and runs on a function, a `runOnFunction`
    is defined to be run on a function:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个步骤是编写一个pass过程中最重要的步骤之一——编写一个`run`函数。因为这个pass继承了`FunctionPass`并在函数上运行，所以定义了一个`runOnFunction`来在函数上运行：
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function prints the name of the function that is being processed.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数打印正在处理的函数的名称。
- en: 'The next step is to initialize the pass ID:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是初始化pass ID：
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, the pass needs to be registered, with a command-line argument and
    a name:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，需要注册这个pass，包括命令行参数和名称：
- en: '[PRE14]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Putting everything together, the entire code looks like this:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将所有内容组合起来，整个代码看起来像这样：
- en: '[PRE15]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: A simple `gmake` command compiles the file, so a new file `FuncBlockCount.so`
    is generated at the LLVM root directory. This shared object file can be dynamically
    loaded to the opt tool to run it on a piece of LLVM IR code. How to load and run
    it will be demonstrated in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`gmake`命令编译文件，因此会在LLVM根目录下生成一个新的文件`FuncBlockCount.so`。这个共享对象文件可以动态加载到opt工具中，以便在LLVM
    IR代码上运行。如何在下一节中加载和运行它将会演示。
- en: See also
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To know more on how a pass can be built from scratch, visit [http://llvm.org/docs/WritingAnLLVMPass.html](http://llvm.org/docs/WritingAnLLVMPass.html)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于如何从头开始构建pass的信息，请访问[http://llvm.org/docs/WritingAnLLVMPass.html](http://llvm.org/docs/WritingAnLLVMPass.html)
- en: Running your own pass with the opt tool
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用opt工具运行自己的pass
- en: The pass written in the previous recipe, *Writing your own LLVM pass*, is ready
    to be run on the LLVM IR. This pass needs to be loaded dynamically for the opt
    tool to recognize and execute it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中编写的pass，即*编写自己的LLVM pass*，已经准备好在LLVM IR上运行。这个pass需要动态加载，以便opt工具能够识别和执行它。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Do the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Write the C test code in the `sample.c` file, which we will convert into an
    `.ll` file in the next step:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sample.c`文件中编写C测试代码，我们将在下一步将其转换为`.ll`文件：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Convert the C test code into LLVM IR using the following command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将C测试代码转换为LLVM IR：
- en: '[PRE17]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will generate a `sample.ll` file.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成一个`sample.ll`文件。
- en: 'Run the new pass with the opt tool, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令使用opt工具运行新的pass：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output will look something like this:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As seen in the preceding code, the shared object loads dynamically into the
    opt command-line tool and runs the pass. It goes over the function and displays
    its name. It does not modify the IR. Further enhancement in the new pass is demonstrated
    in the next recipe.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，共享对象动态地加载到opt命令行工具中并运行pass。它遍历函数并显示其名称。它不修改IR。新pass的进一步增强将在下一菜谱中演示。
- en: See also
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To know more about the various types of the Pass class, visit [http://llvm.org/docs/WritingAnLLVMPass.html#pass-classes-and-requirements](http://llvm.org/docs/WritingAnLLVMPass.html#pass-classes-and-requirements)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于Pass类的各种类型的信息，请访问[http://llvm.org/docs/WritingAnLLVMPass.html#pass-classes-and-requirements](http://llvm.org/docs/WritingAnLLVMPass.html#pass-classes-and-requirements)
- en: Using another pass in a new pass
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在新pass中使用另一个pass
- en: A pass may require another pass to get some analysis data, heuristics, or any
    such information to decide on a further course of action. The pass may just require
    some analysis such as memory dependencies, or it may require the altered IR as
    well. The new pass that you just saw simply prints the name of the function. Let's
    see how to enhance it to count the basic blocks in a loop, which also demonstrates
    how to use other pass results.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个pass可能需要另一个pass来获取一些分析数据、启发式方法或任何此类信息以决定进一步的行动。该pass可能只需要一些分析，如内存依赖，或者它可能还需要修改后的IR。你刚刚看到的新的pass只是简单地打印出函数的名称。让我们看看如何增强它以计算循环中的基本块数量，这同时也展示了如何使用其他pass的结果。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code used in the previous recipe remains the same. Some modifications are
    required, however, to enhance it—as demonstrated in next section—so that it counts
    the number of basic blocks in the IR.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中使用的代码保持不变。然而，为了增强它——如下一节所示——以便它能够计算IR中的基本块数量，需要进行一些修改。
- en: How to do it…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The `getAnalysis` function is used to specify which other pass will be used:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAnalysis`函数用于指定将使用哪个其他pass：'
- en: 'Since the new pass will be counting the number of basic blocks, it requires
    loop information. This is specified using the `getAnalysis` loop function:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于新的pass将计算基本块的数量，它需要循环信息。这通过使用`getAnalysis`循环函数来指定：
- en: '[PRE20]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will call the `LoopInfo` pass to get information on the loop. Iterating
    through this object gives the basic block information:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将调用`LoopInfo` pass以获取有关循环的信息。遍历此对象提供了基本块信息：
- en: '[PRE21]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will go over the loop to count the basic blocks inside it. However, it
    counts only the basic blocks in the outermost loop. To get information on the
    innermost loop, recursive calling of the `getSubLoops` function will help. Putting
    the logic in a separate function and calling it recursively makes more sense:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将遍历循环以计算其内部的基本块数量。然而，它只计算最外层循环中的基本块。要获取最内层循环的信息，递归调用`getSubLoops`函数将有所帮助。将逻辑放入单独的函数并递归调用它更有意义：
- en: '[PRE22]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The newly modified pass now needs to run on a sample program. Follow the given
    steps to modify and run the sample program:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 新修改的pass现在需要在样本程序上运行。按照以下步骤修改并运行样本程序：
- en: 'Open the `sample.c` file and replace its content with the following program:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`sample.c`文件，并用以下程序替换其内容：
- en: '[PRE23]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Convert it into a `.ll` file using Clang:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Clang将其转换为`.ll`文件：
- en: '[PRE24]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the new pass on the previous sample program:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在先前的样本程序上运行新的pass：
- en: '[PRE25]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output will look something like this:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE26]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'The LLVM''s pass manager provides a debug pass option that gives us the chance
    to see which passes interact with our analyses and optimizations, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM的pass manager提供了一个调试pass选项，它给我们机会看到哪些pass与我们的分析和优化交互，如下所示：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Registering a pass with pass manager
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pass manager注册一个pass
- en: Until now, a new pass was a dynamic object that was run independently. The opt
    tool consists of a pipeline of such passes that are registered with the pass manager,
    and a part of LLVM. Let's see how to register our pass with the Pass Manager.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一个新的pass是一个独立运行的动态对象。opt工具由一系列这样的pass组成，这些pass已注册到pass manager和LLVM中。让我们看看如何将我们的pass注册到Pass
    Manager中。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `PassManager` class takes a list of passes, ensures that their prerequisites
    are set up correctly, and then schedules the passes to run efficiently. The Pass
    Manager does two main tasks to try to reduce the execution time of a series of
    passes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassManager`类接受一个pass列表，确保它们的先决条件设置正确，然后安排pass以高效运行。Pass Manager执行两个主要任务以尝试减少一系列pass的执行时间：'
- en: Shares the analysis results to avoid recomputing analysis results as much as
    possible
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享分析结果，以尽可能避免重新计算分析结果
- en: Pipelines the execution of passes to the program to get better cache and memory
    usage behavior out of a series of passes by pipelining the passes together
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过流水线传递的执行，将程序中的传递执行流水线化，以通过流水线传递来获得一系列传递更好的缓存和内存使用行为
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow the given steps to register a pass with Pass Manager:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按照给定步骤使用Pass Manager注册传递：
- en: 'Define a `DEBUG_TYPE` macro, specifying the debugging name in the `FuncBlockCount.cpp`
    file:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FuncBlockCount.cpp`文件中定义`DEBUG_TYPE`宏，指定调试名称：
- en: '[PRE28]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `FuncBlockCount` struct, specify the `getAnalysisUsage` syntax as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FuncBlockCount`结构中，指定`getAnalysisUsage`语法如下：
- en: '[PRE29]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now initialize the macros for initialization of the new pass:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在初始化新传递的宏：
- en: '[PRE30]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the `createFuncBlockCount` Pass function in the `LinkAllPasses.h` file,
    located at `include/llvm/`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在位于`include/llvm/`的`LinkAllPasses.h`文件中添加`createFuncBlockCount`传递函数：
- en: '[PRE31]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the declaration to the `Scalar.h` file, located at `include/llvm/Transforms`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将声明添加到位于`include/llvm/Transforms`的`Scalar.h`文件中：
- en: '[PRE32]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Also modify the constructor of the pass:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要修改传递的构造函数：
- en: '[PRE33]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `Scalar.cpp file`, located at `lib/Transforms/Scalar/`, add the initialization
    pass entry:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在位于`lib/Transforms/Scalar/`的`Scalar.cpp`文件中，添加初始化传递条目：
- en: '[PRE34]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add this initialization declaration to the `InitializePasses.h` file, which
    is located at `include/llvm/`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此初始化声明添加到位于`include/llvm/`的`InitializePasses.h`文件中：
- en: '[PRE35]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, add the `FuncBlockCount.cpp` filename to the `CMakeLists.txt` file,
    located at `lib/Transforms/Scalar/`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`FuncBlockCount.cpp`文件名添加到位于`lib/Transforms/Scalar/`的`CMakeLists.txt`文件中：
- en: '[PRE36]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Compile the LLVM with the `cmake` command as specified in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. LLVM Design and Use"), *LLVM Design and Use*. The Pass Manager will
    include this pass in the pass pipeline of the opt command-line tool. Also, this
    pass can be run in isolation from the command line:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指定在[第1章](part0015.xhtml#aid-E9OE1 "第1章。LLVM设计和使用")的`cmake`命令编译LLVM，*LLVM设计和使用*。Pass
    Manager将包括此传递在opt命令行工具的传递管道中。此外，此传递可以从命令行独立运行：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: See Also
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To know more about adding a pass in Pass Manager in simple steps, study the
    LoopInstSimplify pass at [http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Transforms/Scalar/LoopInstSimplify.cpp](http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Transforms/Scalar/LoopInstSimplify.cpp)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解如何在Pass Manager中简单步骤添加传递，请研究[http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Transforms/Scalar/LoopInstSimplify.cpp](http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Transforms/Scalar/LoopInstSimplify.cpp)中的LoopInstSimplify传递
- en: Writing an analysis pass
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写分析传递
- en: The analysis pass provides higher-level information about IR without actually
    changing the IR. The results that the analysis pass provides can be used by another
    analysis pass to compute its result. Also, once an analysis pass calculates the
    result, its result can be used several times by different passes until the IR
    on which this pass was run is changed. In this recipe, we will write an analysis
    pass that counts and outputs the number of opcodes used in a function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 分析传递提供了关于IR的高级信息，但实际上并不改变IR。分析传递提供的结果可以被另一个分析传递使用来计算其结果。此外，一旦分析传递计算出结果，其结果可以被不同的传递多次使用，直到运行此传递的IR被更改。在本食谱中，我们将编写一个分析传递，用于计算并输出函数中使用的指令码数量。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First of all, we write the test code on which we will be running our pass:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们编写将要运行传递的测试代码：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Transform this into a `.bc` file, which we will use as the input to the analysis
    pass:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为`.bc`文件，我们将将其用作分析传递的输入：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now create the file containing the pass source code in `llvm_root_dir/lib/Transforms/opcodeCounter`.
    Here, `opcodeCounter` is the directory we have created, and it is where our pass's
    source code will reside.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建包含传递源代码的文件，位于`llvm_root_dir/lib/Transforms/opcodeCounter`。在这里，`opcodeCounter`是我们创建的目录，我们的传递源代码将驻留于此。
- en: Make the necessary `Makefile` changes so that this pass can be compiled.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 进行必要的`Makefile`更改，以便此传递可以编译。
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Now let''s start writing the source code for our analysis pass:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始编写我们的分析传递的源代码：
- en: 'Include the necessary header files and use the `llvm` namespace:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件并使用`llvm`命名空间：
- en: '[PRE40]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create the structure defining the pass:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建定义传递的结构：
- en: '[PRE41]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Within the structure, create the necessary data structures to count the number
    of opcodes and to denote the pass ID of the pass:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结构中，创建必要的用于计算指令码数量和表示传递ID的数据结构：
- en: '[PRE42]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Within the preceding structure, write the code for the actual implementation
    of the pass, overloading the `runOnFunction` function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的结构中，编写过程的实际实现代码，重载`runOnFunction`函数：
- en: '[PRE43]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Write the code for registering the pass:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写注册过程的代码：
- en: '[PRE44]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Compile the pass using the `make` or `cmake` command.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`make`或`cmake`命令编译此过程。
- en: 'Run the pass on the test code using the opt tool to get the information on
    the number of opcodes present in the function:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用opt工具在测试代码上运行此过程，以获取函数中存在的操作码数量的信息：
- en: '[PRE45]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This analysis pass works on a function level, running once for each function
    in the program. Hence, we have inherited the `FunctionPass` function when declaring
    the `CountOpcodes : public FunctionPass` struct.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '此分析过程在函数级别上工作，为程序中的每个函数运行一次。因此，在声明`CountOpcodes : public FunctionPass`结构时，我们继承了`FunctionPass`函数。'
- en: 'The `opcodeCounter` function keeps a count of every opcode that has been used
    in the function. In the following for loops, we collect the opcodes from all the
    functions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`opcodeCounter`函数记录函数中使用的每个操作码的数量。在下面的循环中，我们从所有函数中收集操作码：'
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first `for` loop iterates over all the basic blocks present in the function,
    and the second for loop iterates over all the instructions present in the basic
    block.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`for`循环遍历函数中存在的所有基本块，第二个`for`循环遍历基本块中存在的所有指令。
- en: The code in the first `for` loop is the actual code that collects the opcodes
    and their numbers. The code below the `for` loops is meant for printing the results.
    As we have used a map to store the result, we iterate over it to print the pair
    of the opcode name and its number in the function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`for`循环中的代码是实际收集操作码及其数量的代码。`for`循环下面的代码是为了打印结果。由于我们使用映射来存储结果，我们遍历它以打印函数中操作码名称及其数量的配对。
- en: We return `false` because we are not modifying anything in the test code. The
    last two lines of the code are meant for registering this pass with the given
    name so that the opt tool can use this pass.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回`false`，因为我们没有在测试代码中修改任何内容。代码的最后两行是为了将此过程注册为给定名称，以便opt工具可以使用此过程。
- en: Finally, on execution of the test code, we get the output as different opcodes
    used in the function and their numbers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在执行测试代码时，我们得到函数中使用的不同操作码及其数量。
- en: Writing an alias analysis pass
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写别名分析过程
- en: Alias analysis is a technique by which we get to know whether two pointers point
    to the same location—that is, whether the same location can be accessed in more
    ways than one. By getting the results of this analysis, you can decide about further
    optimizations, such as common subexpression elimination. There are different ways
    and algorithms to perform alias analysis. In this recipe, we will not deal with
    these algorithms, but we will see how LLVM provides the infrastructure to write
    your own alias analysis pass. In this recipe, we will write an alias analysis
    pass to see how to get started with writing such a pass. We will not make use
    of any specific algorithm, but will return the `MustAlias` response in every case
    of the analysis.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 别名分析是一种技术，通过它我们可以知道两个指针是否指向同一位置——也就是说，是否可以通过多种方式访问同一位置。通过获取此分析的结果，您可以决定进一步的优化，例如公共子表达式消除。有不同方式和算法可以执行别名分析。在本配方中，我们不会处理这些算法，但我们将了解LLVM如何提供编写自己的别名分析过程的基础设施。在本配方中，我们将编写一个别名分析过程，以了解如何开始编写此类过程。我们不会使用任何特定算法，但在分析的每个情况下都会返回`MustAlias`响应。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Write the test code that will be the input for alias analysis. Here, we will
    take the `testcode.c` file used in the previous recipe as the test code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 编写用于别名分析的测试代码。在这里，我们将使用之前配方中使用的`testcode.c`文件作为测试代码。
- en: Make the necessary `Makefile` changes, make changes to register the pass by
    adding entries for the pass in `llvm/lib/Analysis/Analysis.cpp llvm/include/llvm/InitializePasses.h`,
    `llvm/include/llvm/LinkAllPasses.h`, `llvm/include/llvm/Analysis/Passes.h` and
    create a file in `llvm_source_dir/lib/Analysis/ named EverythingMustAlias.cpp`
    that will contain the source code for our pass.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 进行必要的`Makefile`更改，通过在`llvm/lib/Analysis/Analysis.cpp`、`llvm/include/llvm/InitializePasses.h`、`llvm/include/llvm/LinkAllPasses.h`和`llvm/include/llvm/Analysis/Passes.h`中添加过程条目来注册过程，并在`llvm_source_dir/lib/Analysis/`下创建一个名为`EverythingMustAlias.cpp`的文件，该文件将包含我们过程的源代码。
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Do the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Include the necessary header files and use the `llvm` namespace:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件并使用`llvm`命名空间：
- en: '[PRE47]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a structure for our pass by inheriting the `ImmutablePass` and `AliasAnalysis`
    classes:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过继承 `ImmutablePass` 和 `AliasAnalysis` 类来为我们的传递创建一个结构：
- en: '[PRE48]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Declare the data structures and constructor:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明数据结构和构造函数：
- en: '[PRE49]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Implement the `getAdjustedAnalysisPointer` function:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用于获取调整后的分析指针的 `getAdjustedAnalysisPointer` 函数：
- en: '[PRE50]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement the `initializePass` function to initialize the pass:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用于初始化传递的 `initializePass` 函数：
- en: '[PRE51]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Implement the `alias` function:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用于 `alias` 的函数：
- en: '[PRE52]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Register the pass:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册传递：
- en: '[PRE53]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Compile the pass using the `cmake` or `make` command.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cmake` 或 `make` 命令编译传递：
- en: 'Execute the test code using the `.so` file that is formed after compiling the
    pass:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编译传递后形成的 `.so` 文件执行测试代码：
- en: '[PRE54]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `AliasAnalysis` class gives the interface that the various alias analysis
    implementations should support. It exports the `AliasResult` and `ModRefResult`
    enums, representing the results of the `alias` and `modref` query respectively.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`AliasAnalysis` 类提供了各种别名分析实现应支持的接口。它导出 `AliasResult` 和 `ModRefResult` 枚举，分别表示
    `alias` 和 `modref` 查询的结果。'
- en: The `alias` method is used to check whether two memory objects are pointing
    to the same location or not. It takes two memory objects as the input and returns
    `MustAlias`, `PartialAlias`, `MayAlias`, or `NoAlias` as appropriate.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias` 方法用于检查两个内存对象是否指向同一位置。它接受两个内存对象作为输入，并返回适当的 `MustAlias`、`PartialAlias`、`MayAlias`
    或 `NoAlias`。'
- en: The `getModRefInfo` method returns the information on whether the execution
    of an instruction can read or modify a memory location. The pass in the preceding
    example works by returning the value `MustAlias` for every set of two pointers,
    as we have implemented it that way. Here, we have inherited the `ImmutablePasses`
    class, which suits our pass, as it is a very basic pass. We have inherited the
    `AliasAnalysis` pass, which provides the interface for our implementation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`getModRefInfo` 方法返回有关指令执行是否可以读取或修改内存位置的信息。前面示例中的传递通过为每一对指针返回值 `MustAlias`
    来工作，正如我们实现的那样。在这里，我们继承了 `ImmutablePasses` 类，它适合我们的传递，因为它是一个非常基础的传递。我们继承了 `AliasAnalysis`
    传递，它为我们提供了实现接口。'
- en: The `getAdjustedAnalysisPointer` function is used when a pass implements an
    analysis interface through multiple inheritance. If needed, it should override
    this to adjust the pointer as required for the specified pass information.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递通过多重继承实现分析接口时，使用 `getAdjustedAnalysisPointer` 函数。如果需要，它应该覆盖此方法以调整指针以满足指定的传递信息。
- en: The `initializePass` function is used to initialize the pass that contains the
    `InitializeAliasAnalysis` method, which should contain the actual implementation
    of the alias analysis.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializePass` 函数用于初始化包含 `InitializeAliasAnalysis` 方法的传递，该方法应包含实际的别名分析实现。'
- en: The `getAnalysisUsage` method is used to declare any dependency on other passes
    by explicitly calling the `AliasAnalysis::getAnalysisUsage` method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAnalysisUsage` 方法用于通过显式调用 `AliasAnalysis::getAnalysisUsage` 方法来声明对其他传递的任何依赖。'
- en: The `alias` method is used to determine whether two memory objects alias each
    other or not. It takes two memory objects as the input and returns the `MustAlias`,
    `PartialAlias`, `MayAlias`, or `NoAlias` responses as appropriate.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias` 方法用于确定两个内存对象是否相互别名。它接受两个内存对象作为输入，并返回适当的 `MustAlias`、`PartialAlias`、`MayAlias`
    或 `NoAlias` 响应。'
- en: The code following the `alias` method is meant for registering the pass. Finally,
    when we use this pass over the test code, we get 10 `MustAlias` responses (`100.0%`)
    as the result, as implemented in our pass.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias` 方法之后的代码用于注册传递。最后，当我们使用此传递覆盖测试代码时，我们得到 10 个 `MustAlias` 响应（`100.0%`），正如我们在传递中实现的那样。'
- en: See also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For a more detailed insight into LLVM alias analysis, refer to [http://llvm.org/docs/AliasAnalysis.html](http://llvm.org/docs/AliasAnalysis.html).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要更详细地了解 LLVM 别名分析，请参阅 [http://llvm.org/docs/AliasAnalysis.html](http://llvm.org/docs/AliasAnalysis.html)。
- en: Using other analysis passes
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他分析传递
- en: In this recipe, we will take a brief look into the other analysis passes that
    are provided by LLVM and can be used to get analysis information about a basic
    block, function, module, and so on. We will look into passes that have already
    been implemented in LLVM, and how we can use them for our purpose. We will not
    go through all the passes but take a look at only some of them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将简要了解由 LLVM 提供的其他分析传递，这些传递可以用于获取关于基本块、函数、模块等的分析信息。我们将查看已经实现在内的传递，以及我们如何为我们的目的使用它们。我们不会查看所有传递，而只会查看其中的一些。
- en: Getting ready…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: 'Write the test code in the `testcode1.c` file, which will be used for analysis
    purposes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `testcode1.c` 文件中编写测试代码，该文件将用于分析目的：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Convert the C code to bitcode format, using the following command line:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令行将 C 代码转换为位码格式：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How to do it…
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the steps given to use other analysis passes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 按照给出的步骤使用其他分析遍历：
- en: 'Use the alias analysis evaluator pass by passing `–aa-eval` as a command-line
    option to the opt tool:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `–aa-eval` 作为命令行选项传递给 opt 工具来使用别名分析评估遍历：
- en: '[PRE57]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Print the dominator tree information using the `–print-dom-info` command-line
    option along with opt:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `–print-dom-info` 命令行选项与 opt 一起打印支配树信息：
- en: '[PRE58]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Count the number of queries made by one pass to another using the `–count-aa`
    command-line option along with opt:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `–count-aa` 命令行选项与 opt 一起计算一个遍历对另一个遍历发出的查询次数：
- en: '[PRE59]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Print the alias sets in a program using the `-print-alias-sets` command-line
    option with opt:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `-print-alias-sets` 命令行选项在程序中打印别名集，带上 opt：
- en: '[PRE60]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first case, where we use the `-aa-eval` option, the opt tool runs the
    alias analysis evaluator pass, which outputs the analysis on the screen. It iterates
    through all pairs of pointers in the function and queries whether the two are
    aliases of each other or not.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，当我们使用 `-aa-eval` 选项时，opt 工具运行别名分析评估遍历，该遍历将分析输出到屏幕上。它遍历函数中所有指针对，并查询这两个指针是否是别名。
- en: Using the `-print-dom-info` option, the pass for printing the dominator tree
    is run, through which information about the dominator tree can be obtained.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-print-dom-info` 选项，运行打印支配树的遍历，通过这个遍历可以获得关于支配树的信息。
- en: In the third case, we execute the `opt -count-aa -basicaa –licm` command. The
    `count-aa` command option counts the number of queries made by the `licm` pass
    to the `basicaa` pass. This information is obtained by the count alias analysis
    pass using the opt tool.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三种情况下，我们执行 `opt -count-aa -basicaa –licm` 命令。`count-aa` 命令选项计算 `licm` 遍历对
    `basicaa` 遍历发出的查询次数。这个信息是通过 opt 工具的计数别名分析遍历获得的。
- en: To print all the alias sets within a program, we use the `- print-alias-sets`
    command-line option. In this case, it prints the alias sets obtained after analyzing
    with the `basicaa` pass.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印程序中的所有别名集，我们使用 `- print-alias-sets` 命令行选项。在这种情况下，它将打印出使用 `basicaa` 遍历分析后获得的别名集。
- en: See also
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to [http://llvm.org/docs/Passes.html#anal](http://llvm.org/docs/Passes.html#anal)
    to know about more passes not mentioned here.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下链接了解此处未提及的更多遍历：[http://llvm.org/docs/Passes.html#anal](http://llvm.org/docs/Passes.html#anal)。
