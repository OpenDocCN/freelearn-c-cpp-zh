- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cameras, Collisions, and Collectibles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While playing a game, the player doesn’t want to have to think about the camera
    and its placement. The camera should always follow the player’s character and
    anticipate what the player wants to achieve so it doesn’t obstruct the player’s
    vision.
  prefs: []
  type: TYPE_NORMAL
- en: In bigger games, full teams are tasked with producing the smoothest camera possible.
    In this chapter, we will attempt to do the same with some Godot Engine nodes.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we’ll stop the player from walking through walls and have a look
    at sprinkling collectibles, such as health and money, around our arena.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a camera that follows the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collisions with boulders and walls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision masks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating inherited scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As for every chapter, you can find the final code on the GitHub repository in
    the subfolder for this chapter at [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter9](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter9).
  prefs: []
  type: TYPE_NORMAL
- en: Making a camera that follows the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, our character can run around, but at some point, it will run
    off the screen and get lost forever. Our in-game camera should follow them around
    so the player knows where they are.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the Godot Engine has a pretty nice camera system that we can use. It
    can be a bit basic, but it is all we need, and with some extra nodes, we’ll be
    able to achieve a very smooth-moving camera.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a basic camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For 2D games, Godot provides the **Camera2D** node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `player.tscn` scene and add a `Player` node. This is all we need
    to make a basic camera that follows the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The player scene with an added Camera2D node](img/B19358_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The player scene with an added Camera2D node
  prefs: []
  type: TYPE_NORMAL
- en: But this basic camera feels a bit stiff; it starts and stops moving at exactly
    the moment the character does. This doesn’t feel very natural. Let’s see how to
    solve this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding drag margins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make the camera movement appear natural, we will use **drag margins**. Find
    and enable **Horizontal** and **Vertical** drag in the camera’s inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The drag margin settings for the Camera2D node in the inspector.](img/B19358_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The drag margin settings for the Camera2D node in the inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the camera only moves when the player exits a certain area in the middle
    of the screen. This is the margin within which nothing happens. If you enable
    **Draw Drag Margin** in the camera’s inspector, you can see the drag margins visualized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Showing the drag margins in the editor by enabling them in the
    Camera2D inspector](img/B19358_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Showing the drag margins in the editor by enabling them in the
    Camera2D inspector
  prefs: []
  type: TYPE_NORMAL
- en: 'With **Draw Drag Margin** enabled, you should be able to see the blue rectangles
    indicating when the camera will start moving:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The editor now shows the drag margins in light blue](img/B19358_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The editor now shows the drag margins in light blue
  prefs: []
  type: TYPE_NORMAL
- en: You can play a bit with the left, top, right, and bottom margins in the inspector.
    I chose to set them all to `0.1`, as seen in *Figure* *9**.2* earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Great, the drag margins already feel great. But the camera still starts and
    stops moving very abruptly and seems to lag behind the player. Let’s fix that
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Making the camera look ahead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The movement of the camera feels pretty great now. But there is something wrong;
    we need something more fundamental than nice, smooth movement. When the player
    moves, the camera drags behind, showing where the player has been and not where
    the player is going.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The camera lags behind the player and does not show where the
    player is going](img/B19358_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – The camera lags behind the player and does not show where the player
    is going
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not great; imagine running somewhere and only being able to look backward.
    What we actually want is for the camera to look ahead in the direction the player
    is moving. We can do this by, instead of tracking the player itself, tracking
    a point in front of the player. Basically, it is as if the player character is
    holding a selfie stick. So, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `Player` and call it `CameraPosition`. This will become the point
    we are going to track instead of the player itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now drag the camera we already made onto this `CameraPosition` so that it is
    a child of the new node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Put the Camera2D node under a separate node called CameraPosition](img/B19358_09_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Put the Camera2D node under a separate node called CameraPosition
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that the position of the `CameraPosition` is set to `(0, 0)` in the
    inspector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Make sure the Camera2D and CameraPosition nodes are at position
    (0, 0)](img/B19358_09_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Make sure the Camera2D and CameraPosition nodes are at position
    (0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: Add a script to the `CameraPosition` called `camera_position.gd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script will keep the position in front of the camera. We can do this based
    on the `velocity` that the player character has.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, we define an export variable that we can play with called `camera_distance`.
    This will be the distance in front of the player at which we will keep the camera
    while the player is moving.
  prefs: []
  type: TYPE_NORMAL
- en: With `_physics_process()`, which gets executed for each physics frame of the
    game, we calculate the position of the camera point. Remember that this position
    is relative to the `Player` node, so a position of `(0, 0)` is right where the
    player is.The idea is to take the direction in which the player is moving and
    multiply that by the `camera_distance`. The direction the player is moving in
    can be derived from the `velocity` of the player. So first, we get the player
    node using the `get_parent` function and cache it in the `_player` variable. This
    function returns the parent of a node, in this case, the `Player` node because
    the `CameraPosition` is a direct child of that node.
  prefs: []
  type: TYPE_NORMAL
- en: Then, to get the direction the player is moving in, we normalize this `velocity`
    vector. Normalizing a vector, as we saw in [*Chapter 7*](B19358_07.xhtml#_idTextAnchor523),
    means that you take the whole vector and make it of length `1`. So, the whole
    vector is `1` pixel long. This will leave us with the direction of the `velocity`
    without its length. Now we can easily scale this direction to whatever length
    we want by multiplying it with the `camera_distance` to define the `position`
    of the `CameraPosition`. If you run the game now, you’ll see that `CameraPosition`
    does what you want it to and makes the camera look ahead in the direction the
    character is moving. But it is still a bit janky, so let’s smooth that out one
    last time.
  prefs: []
  type: TYPE_NORMAL
- en: Smoothing out the look ahead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem now is that the camera starts moving very suddenly and abruptly
    stops. This happens because the `CameraPosition` we created jumps around quite
    quickly. To fix this problem, we should make the movement of the `CameraPosition`
    itself smooth.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a new exported variable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s change the `_process()` function of the `camera_position.gd` script
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: class_name Collectible
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _on_area_2d_body_entered(body):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: body.health += 5
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: queue_free()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'var position: Vector2 = Vector2(1, 1)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var target_position: Vector2 = Vector2(3, 5)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: position.lerp(target_position, 0.5)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
