- en: Handling Events and Delegates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事件和委托
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Handling events that have been implemented via virtual functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理通过虚拟函数实现的的事件
- en: Creating a delegate that is bound to a UFUNCTION
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个绑定到 UFUNCTION 的委托
- en: Unregistering a delegate
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消注册委托
- en: Creating a delegate that takes input parameters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个接受输入参数的委托
- en: Passing payload data with a delegate binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用委托绑定传递有效负载数据
- en: Creating a multicast delegate
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个多播委托
- en: Creating a custom Event
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个自定义事件
- en: Creating a Time of Day handler
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一天中时间的处理程序
- en: Creating a respawning pickup for a First Person Shooter
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为第一人称射击游戏创建一个重生拾取物品
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Unreal uses events to notify objects about things that happen in the game world
    in an efficient manner. Events and delegates are useful to ensure that these notifications
    can be issued in a way that minimizes class coupling, and allows arbitrary classes
    to subscribe to be notified.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal 使用事件以高效的方式通知对象关于游戏世界中发生的事情。事件和委托对于确保这些通知可以以最小化类耦合的方式发布非常有用，并允许任意类订阅以接收通知。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and their requirements
    can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml), *UE4
    Development Tools*, of this book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用 Unreal Engine 4，并使用 Visual Studio 2017 作为 IDE。有关如何安装这两款软件及其要求的说明，请参阅本书第
    1 章，*UE4 开发工具*，中的 [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml)。
- en: Handling events that have been implemented via virtual functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理通过虚拟函数实现的事件
- en: Some `Actor` and `Component` classes provided with Unreal include event handlers
    in the form of `virtual` functions. This recipe will show you how to customize
    those handlers by overriding the `virtual` functions in question.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal 提供的一些 `Actor` 和 `Component` 类包含事件处理程序，形式为 `virtual` 函数。这个示例将向你展示如何通过覆盖相关的
    `virtual` 函数来自定义这些处理程序。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create an empty `Actor` in the Editor. Call it `MyTriggerVolume`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个空的 `Actor`。命名为 `MyTriggerVolume`：
- en: '![](img/d1d05cdf-0c3c-4ae6-be67-354df71b2b43.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1d05cdf-0c3c-4ae6-be67-354df71b2b43.png)'
- en: 'Add the following code to the class header:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类头文件中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Because we are referencing a class that''s isn''t a part of our project already,
    we also need to add an `#include`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们在引用一个不属于我们项目的类，所以我们也需要添加一个 `#include`：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember to place the include above the `.generated.h` file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将包含文件放在 `.generated.h` 文件之上。
- en: 'Add the following script to the constructor to create the `BoxComponent`. This
    will trigger our events:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下脚本添加到构造函数中以创建 `BoxComponent`。这将触发我们的事件：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the implementation for the preceding additional functions to the `.cpp`
    file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面添加的额外函数的实现添加到 `.cpp` 文件中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compile your project and place an instance of `MyTriggerActor` into the level:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的项目并将 `MyTriggerActor` 的实例放置到关卡中：
- en: '![](img/e8b4d60a-7163-4710-a5c9-2556e1be3566.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8b4d60a-7163-4710-a5c9-2556e1be3566.png)'
- en: Trigger Volume placed in the level
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在关卡中放置触发体积
- en: You should see the lines around the object, indicating where collisions would
    take place. Feel free to move it around and/or adjust the properties as needed
    so that they fit where you want.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到围绕对象的线条，指示碰撞发生的位置。请随意移动它，以及/或者根据需要调整属性，以便它们适合你想要的位置。
- en: 'Then, verify that overlap/touch events are handled by walking into the volume
    and viewing the output that''s printed to the screen:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过进入体积并查看屏幕上打印的输出，验证重叠/触摸事件是否被处理：
- en: '![](img/22bfbd2a-71b3-4cd8-be0c-5a2d0de42001.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22bfbd2a-71b3-4cd8-be0c-5a2d0de42001.png)'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As always, we first declare a `UPROPERTY` to hold a reference to our component
    subobject. We then create two `UFUNCTION` declarations. These are marked as `virtual`
    and `override` so that the compiler understands that we want to replace the parent
    implementation, and that our function implementations can be replaced in turn.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先声明一个 `UPROPERTY` 来保存对组件子对象的引用。然后创建两个 `UFUNCTION` 声明。这些被标记为 `virtual`
    和 `override`，以便编译器理解我们想要替换父实现，并且我们的函数实现可以被替换。
- en: In the constructor for the object, we create the subobject using the `CreateDefaultSubobject`
    function. Afterwards, we set the extents (size) of the box via the `SetBoxExtent`
    function using a `FVector` holding the *X*, *Y*, and *Z* sizes we want the box
    to have, respectively.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象的构造函数中，我们使用 `CreateDefaultSubobject` 函数创建子对象。之后，我们通过 `SetBoxExtent` 函数设置盒子的范围（大小），使用一个包含我们想要盒子具有的
    *X*、*Y* 和 *Z* 大小的 `FVector`。
- en: In the implementation of the functions, we create an `FString` from some preset
    text and substitute some data parameters using the `FString::Printf` function.
    Note that the `Actor->GetName()` function returns an `FString` as well, and is
    dereferenced using the `*` operator before being passed into `FString::Printf`.
    Not doing this results in an error.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的实现中，我们使用 `FString::Printf` 函数从一些预设文本创建一个 `FString` 并用一些数据参数替换。请注意，`Actor->GetName()`
    函数也返回一个 `FString`，在传递给 `FString::Printf` 之前使用 `*` 运算符进行解引用。不这样做会导致错误。
- en: This `FString` is then passed to a global engine function, `AddOnScreenDebugMessage`,
    to display this information on the screen.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个 `FString` 被传递给全局引擎函数 `AddOnScreenDebugMessage`，以便在屏幕上显示此信息。
- en: The first argument of `-1` tells the engine that duplicate strings are allowed,
    the second parameter is the length of time the message should be displayed for
    in seconds, the third argument is the color, and the fourth is the actual string
    to print itself. While it would be possible to not create an additional variable
    and just put the information within the function call, it makes the code more
    difficult to read.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`-1` 作为第一个参数告诉引擎允许重复字符串，第二个参数是消息应显示的秒数，第三个参数是颜色，第四个是实际要打印的字符串。虽然可以不创建额外的变量，直接在函数调用中放置信息，但这会使代码更难以阅读。'
- en: Now, when a component of our actor overlaps something else, its `UpdateOverlaps`
    function will call `NotifyActorBeginOverlap`, and the virtual function dispatch
    will call our custom implementation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们的演员组件与另一个对象重叠时，其 `UpdateOverlaps` 函数将调用 `NotifyActorBeginOverlap`，而虚拟函数调度将调用我们的自定义实现。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Unreal''s documentation contains information on all of the variables and functions
    that all of their built-in classes have. For instance, the `Actor` class can be
    found at [https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/AActor/index.html](https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/AActor/index.html),
    as shown in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal 的文档包含了所有内置类中所有变量和函数的信息。例如，`Actor` 类可以在以下链接中找到：[https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/AActor/index.html](https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/AActor/index.html)，如下面的截图所示：
- en: '![](img/1790133f-4584-4b4b-8fa6-3fa534aa72b7.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1790133f-4584-4b4b-8fa6-3fa534aa72b7.png)'
- en: 'If you scroll down to the functions we used in this recipe, you can see more
    information on them (feel free to use *Ctrl* + *F* to find a particular item):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你滚动到这个配方中我们使用的函数，你可以看到更多关于它们的信息（请随意使用 *Ctrl* + *F* 来查找特定项目）：
- en: '![](img/9388a24b-1449-414c-bc5a-f8cb197f191f.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9388a24b-1449-414c-bc5a-f8cb197f191f.png)'
- en: On the left-most tab, you'll see some icons where the blue circle with the V
    inside it indicates that the function is `virtual` and can be overwritten in your
    own class. If you haven't gotten a chance to yet, it would also be a good idea
    to look at all of the events so that you are familiar with what's already been
    included.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在最左侧的选项卡上，你会看到一些图标，其中包含蓝色圆圈和 V 的图标表示该函数是 `virtual` 的，可以在你的类中重写。如果你还没有机会，查看所有的事件也是一个好主意，这样你就可以熟悉已经包含的内容了。
- en: Creating a delegate that is bound to a UFUNCTION
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个绑定到 UFUNCTION 的代理
- en: Pointers are great since we are able to assign them at runtime and can change
    where in memory they are pointing to. In addition to standard types, we can also
    create pointers to functions as well, but these raw function pointers are unsafe
    to use for a number of reasons. Delegates are a much safer version of function
    pointers that gives us the flexibility to call a function without knowing which
    function is assigned until the moment it is called. This flexibility is one of
    the main reasons to prefer delegates over static functions. This recipe shows
    you how to associate a `UFUNCTION` to a delegate so that it will be called when
    the delegate is executed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 指针很棒，因为我们能够在运行时分配它们，并且可以更改它们在内存中指向的位置。除了标准类型之外，我们还可以创建指向函数的指针，但这些原始函数指针由于多种原因而不安全使用。委托是函数指针的一个更安全的版本，它为我们提供了在不知道哪个函数被分配直到调用时的灵活性。这种灵活性是相对于静态函数而言选择委托的主要原因之一。本配方展示了如何将一个
    `UFUNCTION` 与委托关联，以便在委托执行时调用它。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure you've followed the previous recipe in order to create the `MyTriggerVolume`
    class because we will be using that to call our delegate.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经遵循了之前的配方来创建 `MyTriggerVolume` 类，因为我们将使用它来调用我们的委托。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Inside our Unreal project''s `GameMode` header, declare the delegate with the
    following macro, just before the class declaration:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 Unreal 项目 `GameMode` 头文件中，使用以下宏声明委托，就在类声明之前：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a new member to our game mode:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的游戏模式添加一个新成员：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a new `Actor` class called `DelegateListener`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Actor` 类，称为 `DelegateListener`：
- en: '![](img/44ea8a24-0a8b-447a-b937-7258cbb81cee.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44ea8a24-0a8b-447a-b937-7258cbb81cee.png)'
- en: 'Add the following to the declaration of that class:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到该类的声明中：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since the script doesn''t know what the `UPointLightComponent` class is, we
    will also need to add the following new `#include` above the generated `.h` file:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于脚本不知道 `UPointLightComponent` 类，我们还需要在生成的 `.h` 文件上方添加以下新的 `#include`：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the class implementation `.cpp` file, add the following code, in bold, to
    the constructor:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的实现文件 `.cpp` 中，将以下粗体代码添加到构造函数中：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside the `ADelegateListener::BeginPlay` implementation, add the following
    code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ADelegateListener::BeginPlay` 的实现中添加以下代码：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since the script does not know about the `UGameplayStatics` class or our `GameMode`
    in the `DelegateListener.cpp` file, add the following #includes:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '由于脚本不知道 `UGameplayStatics` 类或我们在 `DelegateListener.cpp` 文件中的 `GameMode`，在文件中添加以下
    #includes：'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, implement `EnableLight`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现 `EnableLight`：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Put the following code in our `NotifyActorBeginOverlap` function of `TriggerVolume`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码放入我们的 `TriggerVolume` 的 `NotifyActorBeginOverlap` 函数中：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Just like we previously included, be sure that you add the following code to
    your CPP file too so that the compiler knows about the class before we use it:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前包含的那样，确保你也将以下代码添加到你的 CPP 文件中，这样编译器在我们使用它之前就会知道这个类：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compile your game. Make sure that your game mode is set in the current level
    (refer to the *Instantiating an Actor using SpawnActor* recipe in [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml),
    *Actors and Components*, if you don''t know how), and drag a copy of your `MyTriggerVolume`
    out into the level. Also, drag a copy of `DelegateListener` out into the level,
    and place it about 100 units above a flat surface so that we can see the light
    when playing the game:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的游戏。确保你的游戏模式设置为当前关卡（如果你不知道如何设置，请参考[第4章](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml)，*实例化Actor使用SpawnActor*配方），并将你的
    `MyTriggerVolume` 的副本拖到关卡中。同样，将 `DelegateListener` 的副本拖到关卡中，并将其放置在平坦表面上方大约100个单位的位置，以便在游戏播放时可以看到光线：
- en: '![](img/2342fe47-0609-4ba6-a7c8-f06b193ea181.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2342fe47-0609-4ba6-a7c8-f06b193ea181.png)'
- en: The DelegateListener positioned above the ground plane
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 位于地面平面上的委托监听器
- en: 'When you hit Play and walk into the area covered by the Trigger volume, you
    should see the `PointLight` component, which we added to `DelegateListener`, turn
    on:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你按下播放并走进触发体积覆盖的区域时，你应该看到我们添加到 `DelegateListener` 中的 `PointLight` 组件被打开：
- en: '![](img/08d981f9-afb0-4702-93df-d93340ffdbc2.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08d981f9-afb0-4702-93df-d93340ffdbc2.png)'
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Inside our `GameMode` header, we declare a type of delegate that doesn't take
    any parameters, called `FStandardDelegateSignature`. We then create an instance
    of the delegate as a member of our `GameModeBase` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `GameMode` 头文件中，我们声明了一个不接受任何参数的委托类型，称为 `FStandardDelegateSignature`。然后我们创建了一个委托实例，作为我们的
    `GameModeBase` 类的一个成员。
- en: We add a `PointLight` component inside of the `DelegateListener` so that we
    have a visual representation of the delegate being executed that we can turn on
    later on. In the constructor, we initialize our `PointLight`, and then disable
    it. To make it easier to see, we also change the color to blue.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`DelegateListener`内部添加一个`PointLight`组件，以便我们有执行委托的可视表示，我们可以在以后将其打开。在构造函数中，我们初始化我们的`PointLight`，然后将其禁用。为了更容易看到，我们还将其颜色改为蓝色。
- en: We override `BeginPlay`. We first call the parent class's implementation of
    `BeginPlay()`. Then, we get the game world, retrieving the `GameMode` class using
    `GetGameMode()`. Casting the resulting `AGameMode*` to a pointer of our `GameMode`
    class requires the use of the `Cast` template function. We can then access the
    delegate instance member of the `GameMode` and bind our `EnableLight` function
    to the delegate so that it will be called when the delegate is executed. In this
    case, we are binding to `UFUNCTION()`, so we use `BindUObject`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写`BeginPlay`。我们首先调用父类的`BeginPlay()`实现。然后，我们获取游戏世界，使用`GetGameMode()`检索`GameMode`类。将结果`AGameMode*`转换为我们的`GameMode`类指针需要使用`Cast`模板函数。然后，我们可以访问`GameMode`的委托实例成员，并将我们的`EnableLight`函数绑定到委托，以便在委托执行时调用。在这种情况下，我们绑定到`UFUNCTION()`，因此使用`BindUObject`。
- en: If we had wanted to bind to a plain C++ class function, we would have used `BindRaw`.
    If we had wanted to bind to a static function, we would have used `BindStatic()`. If
    you're using these, you must be very careful and unbind them manually when an
    object is being destroyed. It's the same as using naked C++ memory allocation.
    When it comes to UE4, the general rule of thumb is to use a `UObject` wherever
    possible. It saves a lot of headaches!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要绑定到一个普通的C++类函数，我们会使用`BindRaw`。如果我们想要绑定到一个静态函数，我们会使用`BindStatic()`。如果您使用这些，您必须非常小心，并在对象被销毁时手动解除绑定。这就像使用裸露的C++内存分配一样。当涉及到UE4时，一般规则是在可能的情况下使用`UObject`。这可以节省很多麻烦！
- en: When `TriggerVolume` overlaps the player, it retrieves `GameMode`, then calls
    `ExecuteIfBound` on the delegate. `ExecuteIfBound` checks that there's a function
    bound to the delegate, and then invokes it for us. The `EnableLight` function
    enables the `PointLight` component when it's invoked by the delegate object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当`TriggerVolume`与玩家重叠时，它检索`GameMode`，然后对委托调用`ExecuteIfBound`。`ExecuteIfBound`检查是否有函数绑定到委托，然后为我们调用它。`EnableLight`函数在由委托对象调用时启用`PointLight`组件。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: The next recipe, *Unregistering a delegate,* shows you how to safely unregister
    your delegate binding in the event of the `Listener` being destroyed before the
    delegate is called
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个配方，*注销委托*，展示了在`Listener`在委托被调用之前被销毁的情况下如何安全地注销您的委托绑定
- en: To learn more about this and additional options for working with delegates,
    check out [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于此以及与委托一起工作的其他选项，请查看[https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates)。
- en: Unregistering a delegate
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注销委托
- en: Sometimes, it is necessary to remove a delegate binding. This is like setting
    a function pointer to `nullptr` so that it no longer references an object that
    has been deleted.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，需要移除一个委托绑定。这就像将函数指针设置为`nullptr`，这样它就不再引用已被删除的对象。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need to follow the previous recipe so that you have a delegate to unregister.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要遵循前面的配方，以便您有一个可以注销的委托。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `DelegateListener` class, add the following overridden function declaration:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DelegateListener`类中，添加以下重写函数声明：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Implement the function like this:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现函数如下：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe combines both of the previous recipes in this chapter so far. We
    override `EndPlay`, which is an event that's implemented as a virtual function,
    so that we can execute code when our `DelegateListener` leaves play.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方结合了到目前为止本章中的前两个配方。我们重写`EndPlay`，这是一个作为虚拟函数实现的的事件，这样我们就可以在`DelegateListener`离开游戏时执行代码。
- en: In that overridden implementation, we call the `Unbind()` method on the delegate,
    which unlinks the member function from the `DelegateListener` instance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在该重写实现中，我们调用委托上的`Unbind()`方法，这将解除成员函数与`DelegateListener`实例的链接。
- en: Without this being done, the delegate dangles like a pointer, leaving it in
    an invalid state when the `DelegateListener` leaves the game. Using `BindUObject()` helps
    avoid most of these situations, and just a few unfortunate timing situations could
    cause calls on objects to be marked for destruction. It is still a good practice
    to unbind delegates manually, even when using `BindUObject()`, because when these
    timing mishaps cause bugs, they're almost impossible to track down.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不这样做，代表者就像一个指针一样悬空，当 `DelegateListener` 离开游戏时，将其置于无效状态。使用 `BindUObject()`
    有助于避免大多数这些情况，但不幸的时机问题可能会导致对对象的调用被标记为销毁。即使在使用 `BindUObject()` 的情况下，手动解除代表者的绑定也是一个好的做法，因为这些时间错误导致的错误几乎无法追踪。
- en: Creating a delegate that takes input parameters
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个接受输入参数的代表者
- en: So far, the delegates that we've used haven't taken any input parameters. This
    recipe shows you how to change the signature of the delegate so that it accepts
    some input.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的代表者没有接受任何输入参数。这个配方展示了如何更改代表者的签名，使其能够接受一些输入。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you followed the recipe at the beginning of this chapter, which
    showed you how to create a `TriggerVolume` and the other infrastructure that we
    require for this recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你遵循了本章开头所示的配方，该配方展示了如何创建 `TriggerVolume` 和我们需要的其他基础设施。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Add a new delegate declaration to `GameMode`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameMode` 中添加一个新的代表者声明：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a new member to `GameMode`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `GameMode` 添加一个新成员：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a new `Actor` class called `ParamDelegateListener`. Add the following
    to the declaration:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Actor` 类，名为 `ParamDelegateListener`。在声明中添加以下内容：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the class implementation, add the following to the constructor:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类实现中，在构造函数中添加以下内容：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `ParamDelegateListener.cpp` file, add the following `#includes`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ParamDelegateListener.cpp` 文件中，添加以下 `#includes`：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside the `AParamDelegateListener::BeginPlay` implementation, add the following
    code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AParamDelegateListener::BeginPlay` 的实现中，添加以下代码：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lastly, implement `SetLightColor`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现 `SetLightColor`：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inside our `TriggerVolume`, in `NotifyActorBeginOverlap`, add the following
    new code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `TriggerVolume` 中，在 `NotifyActorBeginOverlap` 中添加以下新代码：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Save your script and then go back to the Unreal Editor and compile your code.
    Add the `MyTriggerVolume` and `ParamDelegateListener` objects to your scene and
    then run the game and confirm that the light starts off as white and, upon collision,
    changes to red:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本，然后回到 Unreal 编辑器并编译你的代码。将 `MyTriggerVolume` 和 `ParamDelegateListener`
    对象添加到场景中，然后运行游戏并确认灯光最初是白色的，并且在碰撞后变为红色：
- en: '![](img/64fa8763-941d-4e56-8d7f-3ca69f499653.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64fa8763-941d-4e56-8d7f-3ca69f499653.png)'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our new delegate signature uses a slightly different macro for declaration.
    Note the `_OneParam` suffix at the end of `DECLARE_DELEGATE_OneParam`. As you'd
    expect, we also need to specify what type our parameter will be. Just like when
    we created a delegate without parameters, we can create an instance of the delegate
    as a member of our `GameMode` class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新代表者签名使用了一个稍微不同的宏来声明。注意 `DECLARE_DELEGATE_OneParam` 结尾的 `_OneParam` 后缀。正如你所期望的，我们还需要指定我们的参数类型。就像我们创建一个没有参数的代表者一样，我们可以将代表者实例化为我们
    `GameMode` 类的一个成员。
- en: Delegate signatures can have either a global or class scope, but not a function
    body (as the documentation states). You can find more information about this at [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代表者签名可以是全局或类作用域，但不能是函数体（如文档所述）。你可以在 [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates)
    找到更多关于此的信息。
- en: Then, we create a new type of `DelegateListener`: one that is expecting a parameter
    to be passed into the function that it binds to the delegate. When we call the
    `ExecuteIfBound()` method for the delegate, we need to pass in the value that
    will be inserted into the function parameter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一种新的 `DelegateListener` 类型：它期望将参数传递到它绑定到代表者的函数中。当我们为代表者调用 `ExecuteIfBound()`
    方法时，我们需要传递将插入函数参数的值。
- en: Inside the function that we have bound, we use the parameter to set the color of
    our light. This means that `TriggerVolume` doesn't need to know anything about `ParamDelegateListener` to
    call functions on it. The delegate has allowed us to minimize coupling between
    the two classes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绑定的函数内部，我们使用参数来设置我们灯光的颜色。这意味着`TriggerVolume`不需要了解`ParamDelegateListener`的任何信息就可以调用它的函数。委托使我们能够最小化两个类之间的耦合。
- en: See also
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Unregistering a delegate* recipe shows you how to safely unregister your
    delegate binding in the event of the Listener being destroyed before the delegate
    is called
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注销委托*的配方展示了在监听器在委托被调用之前被销毁的情况下如何安全地注销你的委托绑定'
- en: Passing payload data with a delegate binding
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用委托绑定传递有效载荷数据
- en: With only minimal changes, parameters can be passed through to a delegate at
    creation time. This recipe shows you how to specify data to be always passed as
    parameters to a delegate invocation. The data is calculated when the binding is
    created, and doesn't change from that point forward.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 只需进行最小更改，参数就可以在创建时传递给委托。本配方展示了如何指定始终作为参数传递给委托调用的数据。数据在绑定创建时计算，并且从那时起不再改变。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you've followed the previous recipe. We will be extending the functionality
    of the previous recipe to pass additional creation-time parameters to our bound
    delegate function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经遵循了之前的配方。我们将扩展之前配方的功能，将额外的创建时参数传递给我们的绑定委托函数。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Inside your `AParamDelegateListener::BeginPlay` function, change the call to
    `BindUObject` to the following:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`AParamDelegateListener::BeginPlay`函数中，将`BindUObject`的调用更改为以下内容：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `ParamDelegateListener.h` file, change the declaration of `SetLightColor`
    to the following:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ParamDelegateListener.h`文件中，将`SetLightColor`的声明更改为以下内容：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alter the implementation of `SetLightColor`, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改`SetLightColor`的实现：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Compile and run your project. Verify that, when you walk into `TriggerVolume`,
    the light turns off because of the false payload parameter that was passed in
    when you bound the function.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行你的项目。验证当你走进`TriggerVolume`时，灯光因为你在绑定函数时传入的`false`有效载荷参数而关闭。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we bind the function to the delegate, we specify some additional data (in
    this case, a Boolean of value `false`). You can pass up to four "payload" variables
    in this fashion. They are applied to your function after any parameters are declared
    in the `DECLARE_DELEGATE_*` macro that you used.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将函数绑定到委托时，我们指定一些额外的数据（在这种情况下，一个值为`false`的布尔值）。你可以以这种方式传递最多四个“有效载荷”变量。它们在你在`DECLARE_DELEGATE_*`宏中声明的任何参数之后应用于你的函数。
- en: We change the function signature of our delegate so that it can accept the extra
    argument.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改委托的函数签名，使其能够接受额外的参数。
- en: Inside the function, we use the extra argument to turn the light on or off,
    depending on the value being `true` or `false` at compile time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们使用额外的参数根据编译时`true`或`false`的值来打开或关闭灯光。
- en: We don't need to change the call to `ExecuteIfBound`: the delegate system automatically
    applies the delegate parameters, which are passed in through `ExecuteIfBound` first.
    It then applies any payload parameters, which are always specified after the function
    reference in a call to `BindUObject`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要更改对`ExecuteIfBound`的调用：委托系统会自动应用通过`ExecuteIfBound`传入的委托参数，然后应用任何有效载荷参数，这些参数总是在调用`BindUObject`时在函数引用之后指定。
- en: See also
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Unregistering a delegate* recipe shows you how to safely unregister your
    delegate binding in the event of the Listener being destroyed before the delegate
    is called
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*注销委托*的配方展示了在监听器在委托被调用之前被销毁的情况下如何安全地注销你的委托绑定'
- en: Creating a multicast delegate
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个多播委托
- en: The standard delegates that we've used so far in this chapter are essentially
    function pointers : they allow you to call one particular function on one particular
    object instance. Multicast delegates are a collection of function pointers, each
    potentially on different objects, all of which will be invoked when the delegate
    is **broadcast**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用的标准委托本质上是指针函数：它们允许你在特定的对象实例上调用特定的函数。多播委托是一组函数指针，每个指针可能指向不同的对象，当委托被**广播**时，所有这些函数指针都将被调用。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you have followed the initial recipe in this chapter,
    *Handling events that have been implemented via virtual functions*, as it shows
    you how to create `TriggerVolume`, which is used to broadcast the multicast delegate.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设你已经遵循了本章的初始食谱，即 *通过虚拟函数实现的事件处理*，因为它展示了如何创建 `TriggerVolume`，该 `TriggerVolume`
    用于广播多播委托。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add a new delegate declaration to the `GameMode` header:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameMode` 头文件中添加一个新的委托声明：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a new `Actor` class called `MulticastDelegateListener`. Add the following
    to the declaration:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MulticastDelegateListener` 的新 `Actor` 类。在声明中添加以下内容：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the class implementation, add the following code to the constructor:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类实现中，将以下代码添加到构造函数中：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the `MulticastDelegateListener.cpp` file, add the following `#includes`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MulticastDelegateListener.cpp` 文件中，添加以下 `#includes`：
- en: '[PRE30]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inside the `MulticastDelegateListener::BeginPlay` implementation, add the following
    code:'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MulticastDelegateListener::BeginPlay` 的实现中，添加以下代码：
- en: '[PRE31]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement `ToggleLight`:'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `ToggleLight`：
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implement our `EndPlay` overridden function:'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现我们的 `EndPlay` 覆盖函数：
- en: '[PRE33]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following line to `TriggerVolume::NotifyActorBeginOverlap()`:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到 `TriggerVolume::NotifyActorBeginOverlap()`：
- en: '[PRE34]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile and load your project. Set the `GameMode` in your level as our cookbook
    game mode, and then drag four or five instances of `MulticastDelegateListener`
    into the scene.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并加载你的项目。将你的关卡中的 `GameMode` 设置为我们的食谱游戏模式，然后将四个或五个 `MulticastDelegateListener`
    实例拖入场景。
- en: 'Step into `TriggerVolume` to see all of the `MulticastDelegateListener` toggle
    their light''s visibility:'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `TriggerVolume` 以查看所有 `MulticastDelegateListener` 切换它们的光的可见性：
- en: '![](img/f53635e5-ef24-4ad9-beaa-9c3c07556083.png)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/f53635e5-ef24-4ad9-beaa-9c3c07556083.png)'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you might expect, the delegate type needs to be explicitly declared as a
    multicast delegate rather than a standard single-binding one. Our new `Listener`
    class is very similar to our original `DelegateListener`. The primary difference
    is that we need to store a reference to our delegate instance in `FDelegateHandle`.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所预期，委托类型需要显式声明为多播委托，而不是标准单绑定委托。我们新的 `Listener` 类与我们原始的 `DelegateListener`
    非常相似。主要区别是我们需要在 `FDelegateHandle` 中存储对委托实例的引用。
- en: When the actor is destroyed, we safely remove ourselves from the list of functions
    that are bound to the delegate by using the stored `FDelegateHandle` as a parameter to
    `Remove()`.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当演员被销毁时，我们使用存储的 `FDelegateHandle` 作为参数调用 `Remove()`，安全地从绑定到委托的函数列表中移除自己。
- en: The `Broadcast()` function is the multicast equivalent of `ExecuteIfBound()`.
    Unlike standard delegates, there is no need to check whether the delegate bound
    either in advance or with a call such as `ExecuteIfBound`. `Broadcast()` is safe
    to run, no matter how many functions are bound, or even if none are.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Broadcast()` 函数是 `ExecuteIfBound()` 的多播等效函数。与标准委托不同，无需提前或通过调用例如 `ExecuteIfBound`
    的方式检查委托是否已绑定。无论绑定多少函数，甚至如果没有绑定任何函数，`Broadcast()` 都是安全的。'
- en: When we have multiple instances of our multicast listener in the scene, they
    each register themselves with the multicast delegate that's implemented in the
    `GameMode`. Then, when the `TriggerVolume` overlaps a player, it broadcasts the
    delegate, and each Listener is notified, causing it to toggle the visibility of
    its associated point light.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当场景中有多个我们的多播监听器实例时，它们会分别将自己注册到在 `GameMode` 中实现的那个多播委托。然后，当 `TriggerVolume` 与玩家重叠时，它会广播委托，每个监听器都会收到通知，导致它切换其关联点光的可见性。
- en: Multicast delegates can take parameters in exactly the same way that a standard
    delegate can.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多播委托可以像标准委托一样接受参数。
- en: Creating a custom Event
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义事件
- en: Custom delegates are quite useful, but one of their limitations is that they
    can be broadcast externally by some other third-party class; that is, their `Execute`/`Broadcast`
    methods are publically accessible.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自定义委托非常有用，但它们的局限性之一是它们可以被某些其他第三方类外部广播；也就是说，它们的 `Execute`/`Broadcast` 方法是公开可访问的。
- en: At times, you may want a delegate that is externally assignable by other classes,
    but can only be broadcast by the class that contains them. This is the primary
    purpose of Events.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，你可能需要一个可以被其他类外部分配的委托，但只能由包含它们的类广播。这是事件的主要目的。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you've followed the initial recipe in this chapter so that you have
    the `MyTriggerVolume` and `Chapter_05GameModeBase` implementations.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你已经遵循了本章的初始食谱，以便你有 `MyTriggerVolume` 和 `Chapter_05GameModeBase` 的实现。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add the following event declaration macro to the header of your `MyTriggerVolume`
    class:'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将以下事件声明宏添加到 `MyTriggerVolume` 类的头部:'
- en: '[PRE35]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add an instance of the declared event signature to the class:'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将声明的事件签名的一个实例添加到类中:'
- en: '[PRE36]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In `AMyTriggerVolume::NotifyActorBeginOverlap`, add the following code:'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `AMyTriggerVolume::NotifyActorBeginOverlap` 中添加以下代码:'
- en: '[PRE37]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a new `Actor` class called `TriggerVolEventListener`:'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个新的 `Actor` 类称为 `TriggerVolEventListener`:'
- en: '![](img/e1b64847-e6d5-4921-b15a-d3b256e83a55.png)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/e1b64847-e6d5-4921-b15a-d3b256e83a55.png)'
- en: 'Add the following class members to its declaration:'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将以下类成员添加到其声明中:'
- en: '[PRE38]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Initialize `PointLight` in the class constructor:'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在类构造函数中初始化 `PointLight`:'
- en: '[PRE39]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Inside `BeginPlay`, add the following code:'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `BeginPlay` 中添加以下代码:'
- en: '[PRE40]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Lastly, implement `OnTriggerEvent()`:'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，实现 `OnTriggerEvent()`:'
- en: '[PRE41]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Compile your project and launch the editor. Create a level with the game mode
    set to our `Chapter_05GameModeBase`, and then drag an instance of `ATriggerVolEventListener`
    and `AMyTriggerVolume` out into the level.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的项目并启动编辑器。创建一个将游戏模式设置为我们的 `Chapter_05GameModeBase` 的关卡，然后将 `ATriggerVolEventListener`
    和 `AMyTriggerVolume` 的实例拖放到关卡中。
- en: 'Select `TriggerVolEventListener`, and you''ll see `TriggerVolEventListener`
    listed as a category in the Details panel, with the property as Trigger Event
    Source:'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '选择 `TriggerVolEventListener`，你会在详情面板中看到它作为一个类别列出，属性为触发事件源:'
- en: '![](img/d6cf0cd5-d3c1-493a-82ef-d8d32cf5b8ba.png)'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/d6cf0cd5-d3c1-493a-82ef-d8d32cf5b8ba.png)'
- en: The Trigger Vol Event Listener category
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 触发体积事件监听器类别
- en: 'Use the drop-down menu to select your instance of `AMyTriggerVolume` so that
    the Listener knows which event to bind to:'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用下拉菜单选择你的 `AMyTriggerVolume` 实例，以便监听器知道绑定哪个事件:'
- en: '![](img/b26436bd-dbff-45ea-a696-fe24e5d2b01a.png)'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/b26436bd-dbff-45ea-a696-fe24e5d2b01a.png)'
- en: 'Play your game and enter the trigger volume''s zone of effect. Verify that
    the color of your `EventListener` changes to green:'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '播放你的游戏并进入触发区域的效应区域。验证你的 `EventListener` 的颜色是否变为绿色:'
- en: '![](img/018dd943-a7f0-49a1-8002-9f0a09250bc2.png)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/018dd943-a7f0-49a1-8002-9f0a09250bc2.png)'
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As with all of the other types of delegate, Events require their own special
    macro function. The first parameter is the class that the event will be implemented
    into. This will be the only class able to call `Broadcast()`, so make sure it
    is the right one. The second parameter is the type name for our new event function
    signature. We add an instance of this type to our class. The Unreal documentation
    suggests `On<x>` as a naming convention.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与所有其他类型的委托一样，事件需要它们自己的特殊宏函数。第一个参数是事件将要实现的类。这将将是唯一能够调用 `Broadcast()` 的类，所以请确保它是正确的。第二个参数是我们新事件函数签名的类型名称。我们向我们的类添加这个类型的实例。Unreal
    文档建议使用 `On<x>` 作为命名约定。
- en: When something overlaps our `TriggerVolume`, we call `Broadcast()` on our own
    event instance. Inside the new class, we create a point light as a visual representation
    of the event being triggered.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当有东西与我们的 `TriggerVolume` 发生重叠时，我们在自己的事件实例上调用 `Broadcast()`。在新的类中，我们创建一个点光源作为触发事件的可视表示。
- en: We also create a pointer to `TriggerVolume` to listen to events. We mark the
    `UPROPERTY` as `EditAnywhere`, because this allows us to set it in the Editor
    rather than having to acquire the reference programmatically using `GetAllActorsOfClass`
    or something else.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还创建了一个指向 `TriggerVolume` 的指针来监听事件。我们将 `UPROPERTY` 标记为 `EditAnywhere`，因为这允许我们在编辑器中设置它，而不是必须通过
    `GetAllActorsOfClass` 或其他方式程序化地获取引用。
- en: Last is our event handler for when something enters the `TriggerVolume`. We
    create and initialize our point light in the constructor as usual. When the game
    starts, the Listener checks that our `TriggerVolume` reference is valid, and then
    binds our `OnTriggerEvent` function to the `TriggerVolume` event. Inside `OnTriggerEvent`,
    we change our light's color to green. When something enters `TriggerVolume`, it
    causes `TriggerVolume` to call a broadcast on its own event. Our `TriggerVolEventListener`
    then has its bound method invoked, changing our light's color.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后是我们的当有东西进入 `TriggerVolume` 的事件处理器。我们像往常一样在构造函数中创建和初始化我们的点光源。当游戏开始时，监听器会检查我们的
    `TriggerVolume` 引用是否有效，然后将我们的 `OnTriggerEvent` 函数绑定到 `TriggerVolume` 事件。在 `OnTriggerEvent`
    中，我们改变我们的灯光颜色为绿色。当有东西进入 `TriggerVolume` 时，它会导致 `TriggerVolume` 在其自己的事件上调用广播。然后我们的
    `TriggerVolEventListener` 调用其绑定方法，改变我们的灯光颜色。
- en: Creating a Time of Day handler
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个“一天中的时间”处理器
- en: This recipe shows you how to use the concepts that were introduced in the previous
    recipes to create an actor that informs other actors of the passage of time within
    your game.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本食谱展示了如何使用在前一个食谱中介绍的概念来创建一个通知其他演员游戏内时间流逝的演员。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new `Actor` class called `TimeOfDayHandler`, as shown in the following
    screenshot:'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Actor` 类，命名为 `TimeOfDayHandler`，如下截图所示：
- en: '![](img/67f4437f-f3c4-481a-88de-3544020d0d69.png)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/67f4437f-f3c4-481a-88de-3544020d0d69.png)'
- en: 'Add a multicast delegate declaration to the header:'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中添加一个多播委托声明：
- en: '[PRE42]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add an instance of our delegate to the class declaration in the `public` section:'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `public` 部分将我们的委托实例添加到类声明中：
- en: '[PRE43]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the following properties to the class:'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到类中：
- en: '[PRE44]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the initialization of these properties to the constructor:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些属性的初始化添加到构造函数中：
- en: '[PRE45]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Inside `Tick`, add the following code:'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Tick` 中添加以下代码：
- en: '[PRE46]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a new `Actor` class called `Clock`, as shown in the following screenshot:'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Actor` 类，命名为 `Clock`，如下截图所示：
- en: '![](img/45d5f742-3133-4c83-8c99-94081faaf7de.png)'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/45d5f742-3133-4c83-8c99-94081faaf7de.png)'
- en: 'Add the following properties to the class header:'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到类头中：
- en: '[PRE47]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Initialize and transform the components in the constructor:'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化和变换组件：
- en: '[PRE48]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add the following code to `BeginPlay`:'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `BeginPlay`：
- en: '[PRE49]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Lastly, implement `TimeChanged` as your event handler:'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现 `TimeChanged` 作为你的事件处理程序：
- en: '[PRE50]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Place an instance of `TimeOfDayHandler` and the `AClock` into your level. Then,
    play it to see the hands on the clock rotate:'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的级别中放置一个 `TimeOfDayHandler` 和 `AClock` 的实例。然后播放它，以查看时钟的指针旋转：
- en: '![](img/5441e608-52a9-4943-b354-09481e9006cb.png)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/5441e608-52a9-4943-b354-09481e9006cb.png)'
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`TimeOfDayHandler` contains a delegate that takes two parameters, hence the
    use of the `TwoParams` variant of the macro. Our class contains variables to store
    hours, minutes, and seconds, as well as `TimeScale`, which is an acceleration
    factor that''s used to speed up time for testing purposes. Inside the handler''s
    `Tick` function, we accumulate elapsed seconds based on the time elapsed since
    the last frame. We check if the elapsed seconds have gone over 60\. If so, we
    subtract 60, and increment `Minutes`. The same happens with `Minutes`: if they
    go over 60, we subtract 60, and increment `Hours`. If `Minutes` or `Hours` was
    updated, we broadcast our delegate to let any object that has subscribed to the
    delegate know that the time has changed.'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TimeOfDayHandler` 包含一个接受两个参数的委托，因此使用了宏的 `TwoParams` 变体。我们的类包含存储小时、分钟和秒的变量，以及
    `TimeScale`，这是一个用于测试目的加速时间的系数。在处理程序的 `Tick` 函数内部，我们根据自上一帧以来经过的时间累积已过秒数。我们检查已过秒数是否超过
    60。如果是这样，我们减去 60，并增加 `Minutes`。同样，对于 `Minutes`：如果它们超过 60，我们减去 60，并增加 `Hours`。如果
    `Minutes` 或 `Hours` 已更新，我们广播我们的委托，让任何已订阅委托的对象知道时间已更改。'
- en: The `Clock` actor uses a series of Scene components and Static meshes to build
    a mesh hierarchy that resembles a clock face. In the `Clock` constructor, we parent
    the components in the hierarchy and set their initial scale and rotations. In
    `BeginPlay`, the clock uses `GetAllActorsOfClass()` to fetch all of the time of
    day handlers in the level. If there's at least one `TimeOfDayHandler` in the level,
    the `Clock` accesses the first one, and subscribes to its `TimeChanged` event. When
    the `TimeChanged` event fires, the clock rotates the hour and minute hands based
    on how many hours and minutes the time is currently set at.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Clock` 演员使用一系列场景组件和静态网格来构建一个类似于时钟面的网格层次结构。在 `Clock` 构造函数中，我们将层次结构中的组件设置为父级，并设置它们的初始比例和旋转。在
    `BeginPlay` 中，时钟使用 `GetAllActorsOfClass()` 获取级别中所有的一天时间处理程序。如果级别中至少有一个 `TimeOfDayHandler`，则
    `Clock` 访问第一个，并订阅其 `TimeChanged` 事件。当 `TimeChanged` 事件触发时，时钟根据当前设置的小时和分钟旋转时针和分针。'
- en: Creating a respawning pickup for a First Person Shooter
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为第一人称射击游戏创建一个可重新生成的拾取物品
- en: This recipe shows you how to create a placeable pickup that will respawn after
    a certain amount of time, suitable as an ammo or other pickup for a **First Person
    Shooter** (**FPS**).
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本食谱展示了如何创建一个在一定时间后重新生成的拾取物品，适合作为**第一人称射击游戏**（**FPS**）的弹药或其他拾取物品。
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new `Actor` class called `Pickup`:'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Actor` 类，命名为 `Pickup`：
- en: '![](img/228a0cbd-6875-46c2-b5e4-3a5a883b9a4a.png)'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/228a0cbd-6875-46c2-b5e4-3a5a883b9a4a.png)'
- en: 'Declare the following delegate type in `Pickup.h`:'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Pickup.h` 中声明以下委托类型：
- en: '[PRE51]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add the following properties to the class header:'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到类头中：
- en: '[PRE52]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The class will be using the `ConstructorHelpers` struct, so we need to add
    the following `#include` to the `Pickup.cpp` file:'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类将使用`ConstructorHelpers`结构体，因此我们需要将以下`#include`添加到`Pickup.cpp`文件中：
- en: '[PRE53]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add the following code to the constructor:'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到构造函数中：
- en: '[PRE54]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Implement the overridden `NotifyActorBeginOverlap`:'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`NotifyActorBeginOverlap`的覆盖版本：
- en: '[PRE55]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a second `Actor` class called `PickupSpawner`:'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PickupSpawner`的第二个`Actor`类：
- en: '![](img/033b1225-911b-43b4-aa47-c543e95f44b4.png)'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/033b1225-911b-43b4-aa47-c543e95f44b4.png)'
- en: 'Add the following code to the class header:'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类头文件中：
- en: '[PRE56]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Initialize our root component in the constructor:'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化我们的根组件：
- en: '[PRE57]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Spawn a pickup when gameplay starts with the `SpawnPickup` function in `BeginPlay`:'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏开始时使用`BeginPlay`中的`SpawnPickup`函数生成拾取物：
- en: '[PRE58]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Implement `PickupCollected`:'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`PickupCollected`：
- en: '[PRE59]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create the following code for `SpawnPickup`:'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`SpawnPickup`创建以下代码：
- en: '[PRE60]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Compile and launch the editor, and then drag an instance of `PickupSpawner`
    out into the level. Walk into the pickup that''s represented by the spinning cube
    and verify that it spawns again 10 seconds later:'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并启动编辑器，然后将`PickupSpawner`实例拖放到关卡中。走进由旋转的立方体表示的拾取物，并验证它在10秒后再次生成：
- en: '![](img/b42458a5-3e4d-4621-a7a9-c0b284280dff.png)'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/b42458a5-3e4d-4621-a7a9-c0b284280dff.png)'
- en: The result of completing the recipe
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成配方后的结果
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As usual, we need to create a delegate inside our `Pickup` that our Spawner
    can subscribe to so that it knows when the player collects the pickup. The `Pickup`
    also contains a Static mesh as a visual representation, and a `RotatingMovementComponent`
    so that the mesh will spin as a way to attract the attention of the players. Inside
    the `Pickup` constructor, we load one of the engine's inbuilt meshes as our visual
    representation. We specify that the mesh will overlap with other objects, then
    set the rotation rate of our mesh at 10 units per second in the *X* and *Z* axes. When
    the player overlaps the `Pickup`, it fires off its `PickedUp` delegate from the
    first step.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如同往常一样，我们需要在`Pickup`内部创建一个委托，以便我们的生成器可以订阅，这样它就知道玩家何时收集拾取物。`Pickup`还包含一个静态网格作为视觉表示，以及一个`RotatingMovementComponent`，以便网格会旋转以吸引玩家的注意。在`Pickup`构造函数中，我们加载引擎内置的一个网格作为我们的视觉表示。我们指定网格将与其他对象重叠，然后在*X*和*Z*轴上将网格的旋转速率设置为每秒10个单位。当玩家与`Pickup`重叠时，它从第一步触发其`PickedUp`委托。
- en: The `PickupSpawner` used
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用的`PickupSpawner`：
- en: a Scene component to specify where to spawn the pickup actor. It has a function
    for doing so, and a tagged `UPROPERTY` reference to the currently spawned `Pickup`. In
    the `PickupSpawner` constructor, we initialize our components as always. When
    play begins, the Spawner runs its `SpawnPickup` function. This function spawns
    an instance of our `Pickup`, then binds `APickupSpawner::PickupCollected` to the
    `OnPickedUp` function on the new instance. It also stores a reference to that
    current instance.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个场景组件来指定拾取物演员的生成位置。它有一个执行此操作的功能，以及一个标记的`UPROPERTY`引用到当前生成的`Pickup`。在`PickupSpawner`构造函数中，我们像往常一样初始化我们的组件。当游戏开始时，生成器运行其`SpawnPickup`函数。此函数生成我们的`Pickup`实例，然后将`APickupSpawner::PickupCollected`绑定到新实例上的`OnPickedUp`函数。它还存储对该当前实例的引用。
- en: When `PickupCollected` runs after the player has overlapped the `Pickup`, a
    timer is created to respawn the pickup after 10 seconds. The existing delegate
    binding to the collected pickup is removed, and then the pickup is destroyed. After
    10 seconds, the timer fires, running `SpawnActor` again, which creates a new `Pickup`.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当玩家与`Pickup`重叠后`PickupCollected`运行时，会创建一个计时器，在10秒后重新生成拾取物。现有的绑定到已收集拾取物的委托被移除，然后销毁拾取物。10秒后，计时器触发，再次运行`SpawnActor`，创建一个新的`Pickup`。
