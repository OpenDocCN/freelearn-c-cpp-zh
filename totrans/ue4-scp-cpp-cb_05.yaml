- en: Handling Events and Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling events that have been implemented via virtual functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a delegate that is bound to a UFUNCTION
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unregistering a delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a delegate that takes input parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing payload data with a delegate binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multicast delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom Event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Time of Day handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a respawning pickup for a First Person Shooter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal uses events to notify objects about things that happen in the game world
    in an efficient manner. Events and delegates are useful to ensure that these notifications
    can be issued in a way that minimizes class coupling, and allows arbitrary classes
    to subscribe to be notified.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and their requirements
    can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml), *UE4
    Development Tools*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events that have been implemented via virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some `Actor` and `Component` classes provided with Unreal include event handlers
    in the form of `virtual` functions. This recipe will show you how to customize
    those handlers by overriding the `virtual` functions in question.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an empty `Actor` in the Editor. Call it `MyTriggerVolume`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d1d05cdf-0c3c-4ae6-be67-354df71b2b43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following code to the class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we are referencing a class that''s isn''t a part of our project already,
    we also need to add an `#include`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Remember to place the include above the `.generated.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following script to the constructor to create the `BoxComponent`. This
    will trigger our events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the implementation for the preceding additional functions to the `.cpp`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile your project and place an instance of `MyTriggerActor` into the level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8b4d60a-7163-4710-a5c9-2556e1be3566.png)'
  prefs: []
  type: TYPE_IMG
- en: Trigger Volume placed in the level
  prefs: []
  type: TYPE_NORMAL
- en: You should see the lines around the object, indicating where collisions would
    take place. Feel free to move it around and/or adjust the properties as needed
    so that they fit where you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, verify that overlap/touch events are handled by walking into the volume
    and viewing the output that''s printed to the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22bfbd2a-71b3-4cd8-be0c-5a2d0de42001.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, we first declare a `UPROPERTY` to hold a reference to our component
    subobject. We then create two `UFUNCTION` declarations. These are marked as `virtual`
    and `override` so that the compiler understands that we want to replace the parent
    implementation, and that our function implementations can be replaced in turn.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor for the object, we create the subobject using the `CreateDefaultSubobject`
    function. Afterwards, we set the extents (size) of the box via the `SetBoxExtent`
    function using a `FVector` holding the *X*, *Y*, and *Z* sizes we want the box
    to have, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation of the functions, we create an `FString` from some preset
    text and substitute some data parameters using the `FString::Printf` function.
    Note that the `Actor->GetName()` function returns an `FString` as well, and is
    dereferenced using the `*` operator before being passed into `FString::Printf`.
    Not doing this results in an error.
  prefs: []
  type: TYPE_NORMAL
- en: This `FString` is then passed to a global engine function, `AddOnScreenDebugMessage`,
    to display this information on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument of `-1` tells the engine that duplicate strings are allowed,
    the second parameter is the length of time the message should be displayed for
    in seconds, the third argument is the color, and the fourth is the actual string
    to print itself. While it would be possible to not create an additional variable
    and just put the information within the function call, it makes the code more
    difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when a component of our actor overlaps something else, its `UpdateOverlaps`
    function will call `NotifyActorBeginOverlap`, and the virtual function dispatch
    will call our custom implementation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unreal''s documentation contains information on all of the variables and functions
    that all of their built-in classes have. For instance, the `Actor` class can be
    found at [https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/AActor/index.html](https://api.unrealengine.com/INT/API/Runtime/Engine/GameFramework/AActor/index.html),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1790133f-4584-4b4b-8fa6-3fa534aa72b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you scroll down to the functions we used in this recipe, you can see more
    information on them (feel free to use *Ctrl* + *F* to find a particular item):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9388a24b-1449-414c-bc5a-f8cb197f191f.png)'
  prefs: []
  type: TYPE_IMG
- en: On the left-most tab, you'll see some icons where the blue circle with the V
    inside it indicates that the function is `virtual` and can be overwritten in your
    own class. If you haven't gotten a chance to yet, it would also be a good idea
    to look at all of the events so that you are familiar with what's already been
    included.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a delegate that is bound to a UFUNCTION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pointers are great since we are able to assign them at runtime and can change
    where in memory they are pointing to. In addition to standard types, we can also
    create pointers to functions as well, but these raw function pointers are unsafe
    to use for a number of reasons. Delegates are a much safer version of function
    pointers that gives us the flexibility to call a function without knowing which
    function is assigned until the moment it is called. This flexibility is one of
    the main reasons to prefer delegates over static functions. This recipe shows
    you how to associate a `UFUNCTION` to a delegate so that it will be called when
    the delegate is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure you've followed the previous recipe in order to create the `MyTriggerVolume`
    class because we will be using that to call our delegate.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside our Unreal project''s `GameMode` header, declare the delegate with the
    following macro, just before the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new member to our game mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Actor` class called `DelegateListener`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44ea8a24-0a8b-447a-b937-7258cbb81cee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following to the declaration of that class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the script doesn''t know what the `UPointLightComponent` class is, we
    will also need to add the following new `#include` above the generated `.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class implementation `.cpp` file, add the following code, in bold, to
    the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `ADelegateListener::BeginPlay` implementation, add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the script does not know about the `UGameplayStatics` class or our `GameMode`
    in the `DelegateListener.cpp` file, add the following #includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, implement `EnableLight`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the following code in our `NotifyActorBeginOverlap` function of `TriggerVolume`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we previously included, be sure that you add the following code to
    your CPP file too so that the compiler knows about the class before we use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile your game. Make sure that your game mode is set in the current level
    (refer to the *Instantiating an Actor using SpawnActor* recipe in [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml),
    *Actors and Components*, if you don''t know how), and drag a copy of your `MyTriggerVolume`
    out into the level. Also, drag a copy of `DelegateListener` out into the level,
    and place it about 100 units above a flat surface so that we can see the light
    when playing the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2342fe47-0609-4ba6-a7c8-f06b193ea181.png)'
  prefs: []
  type: TYPE_IMG
- en: The DelegateListener positioned above the ground plane
  prefs: []
  type: TYPE_NORMAL
- en: 'When you hit Play and walk into the area covered by the Trigger volume, you
    should see the `PointLight` component, which we added to `DelegateListener`, turn
    on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/08d981f9-afb0-4702-93df-d93340ffdbc2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside our `GameMode` header, we declare a type of delegate that doesn't take
    any parameters, called `FStandardDelegateSignature`. We then create an instance
    of the delegate as a member of our `GameModeBase` class.
  prefs: []
  type: TYPE_NORMAL
- en: We add a `PointLight` component inside of the `DelegateListener` so that we
    have a visual representation of the delegate being executed that we can turn on
    later on. In the constructor, we initialize our `PointLight`, and then disable
    it. To make it easier to see, we also change the color to blue.
  prefs: []
  type: TYPE_NORMAL
- en: We override `BeginPlay`. We first call the parent class's implementation of
    `BeginPlay()`. Then, we get the game world, retrieving the `GameMode` class using
    `GetGameMode()`. Casting the resulting `AGameMode*` to a pointer of our `GameMode`
    class requires the use of the `Cast` template function. We can then access the
    delegate instance member of the `GameMode` and bind our `EnableLight` function
    to the delegate so that it will be called when the delegate is executed. In this
    case, we are binding to `UFUNCTION()`, so we use `BindUObject`.
  prefs: []
  type: TYPE_NORMAL
- en: If we had wanted to bind to a plain C++ class function, we would have used `BindRaw`.
    If we had wanted to bind to a static function, we would have used `BindStatic()`. If
    you're using these, you must be very careful and unbind them manually when an
    object is being destroyed. It's the same as using naked C++ memory allocation.
    When it comes to UE4, the general rule of thumb is to use a `UObject` wherever
    possible. It saves a lot of headaches!
  prefs: []
  type: TYPE_NORMAL
- en: When `TriggerVolume` overlaps the player, it retrieves `GameMode`, then calls
    `ExecuteIfBound` on the delegate. `ExecuteIfBound` checks that there's a function
    bound to the delegate, and then invokes it for us. The `EnableLight` function
    enables the `PointLight` component when it's invoked by the delegate object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next recipe, *Unregistering a delegate,* shows you how to safely unregister
    your delegate binding in the event of the `Listener` being destroyed before the
    delegate is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about this and additional options for working with delegates,
    check out [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates).
  prefs: []
  type: TYPE_NORMAL
- en: Unregistering a delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is necessary to remove a delegate binding. This is like setting
    a function pointer to `nullptr` so that it no longer references an object that
    has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll need to follow the previous recipe so that you have a delegate to unregister.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `DelegateListener` class, add the following overridden function declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the function like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe combines both of the previous recipes in this chapter so far. We
    override `EndPlay`, which is an event that's implemented as a virtual function,
    so that we can execute code when our `DelegateListener` leaves play.
  prefs: []
  type: TYPE_NORMAL
- en: In that overridden implementation, we call the `Unbind()` method on the delegate,
    which unlinks the member function from the `DelegateListener` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Without this being done, the delegate dangles like a pointer, leaving it in
    an invalid state when the `DelegateListener` leaves the game. Using `BindUObject()` helps
    avoid most of these situations, and just a few unfortunate timing situations could
    cause calls on objects to be marked for destruction. It is still a good practice
    to unbind delegates manually, even when using `BindUObject()`, because when these
    timing mishaps cause bugs, they're almost impossible to track down.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a delegate that takes input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the delegates that we've used haven't taken any input parameters. This
    recipe shows you how to change the signature of the delegate so that it accepts
    some input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that you followed the recipe at the beginning of this chapter, which
    showed you how to create a `TriggerVolume` and the other infrastructure that we
    require for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new delegate declaration to `GameMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new member to `GameMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Actor` class called `ParamDelegateListener`. Add the following
    to the declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class implementation, add the following to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ParamDelegateListener.cpp` file, add the following `#includes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `AParamDelegateListener::BeginPlay` implementation, add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, implement `SetLightColor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our `TriggerVolume`, in `NotifyActorBeginOverlap`, add the following
    new code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your script and then go back to the Unreal Editor and compile your code.
    Add the `MyTriggerVolume` and `ParamDelegateListener` objects to your scene and
    then run the game and confirm that the light starts off as white and, upon collision,
    changes to red:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/64fa8763-941d-4e56-8d7f-3ca69f499653.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our new delegate signature uses a slightly different macro for declaration.
    Note the `_OneParam` suffix at the end of `DECLARE_DELEGATE_OneParam`. As you'd
    expect, we also need to specify what type our parameter will be. Just like when
    we created a delegate without parameters, we can create an instance of the delegate
    as a member of our `GameMode` class.
  prefs: []
  type: TYPE_NORMAL
- en: Delegate signatures can have either a global or class scope, but not a function
    body (as the documentation states). You can find more information about this at [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Delegates).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a new type of `DelegateListener`: one that is expecting a parameter
    to be passed into the function that it binds to the delegate. When we call the
    `ExecuteIfBound()` method for the delegate, we need to pass in the value that
    will be inserted into the function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function that we have bound, we use the parameter to set the color of
    our light. This means that `TriggerVolume` doesn't need to know anything about `ParamDelegateListener` to
    call functions on it. The delegate has allowed us to minimize coupling between
    the two classes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Unregistering a delegate* recipe shows you how to safely unregister your
    delegate binding in the event of the Listener being destroyed before the delegate
    is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing payload data with a delegate binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With only minimal changes, parameters can be passed through to a delegate at
    creation time. This recipe shows you how to specify data to be always passed as
    parameters to a delegate invocation. The data is calculated when the binding is
    created, and doesn't change from that point forward.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that you've followed the previous recipe. We will be extending the functionality
    of the previous recipe to pass additional creation-time parameters to our bound
    delegate function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside your `AParamDelegateListener::BeginPlay` function, change the call to
    `BindUObject` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ParamDelegateListener.h` file, change the declaration of `SetLightColor`
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Alter the implementation of `SetLightColor`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run your project. Verify that, when you walk into `TriggerVolume`,
    the light turns off because of the false payload parameter that was passed in
    when you bound the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we bind the function to the delegate, we specify some additional data (in
    this case, a Boolean of value `false`). You can pass up to four "payload" variables
    in this fashion. They are applied to your function after any parameters are declared
    in the `DECLARE_DELEGATE_*` macro that you used.
  prefs: []
  type: TYPE_NORMAL
- en: We change the function signature of our delegate so that it can accept the extra
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function, we use the extra argument to turn the light on or off,
    depending on the value being `true` or `false` at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to change the call to `ExecuteIfBound`: the delegate system automatically
    applies the delegate parameters, which are passed in through `ExecuteIfBound` first.
    It then applies any payload parameters, which are always specified after the function
    reference in a call to `BindUObject`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Unregistering a delegate* recipe shows you how to safely unregister your
    delegate binding in the event of the Listener being destroyed before the delegate
    is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multicast delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard delegates that we've used so far in this chapter are essentially
    function pointers : they allow you to call one particular function on one particular
    object instance. Multicast delegates are a collection of function pointers, each
    potentially on different objects, all of which will be invoked when the delegate
    is **broadcast**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that you have followed the initial recipe in this chapter,
    *Handling events that have been implemented via virtual functions*, as it shows
    you how to create `TriggerVolume`, which is used to broadcast the multicast delegate.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new delegate declaration to the `GameMode` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Actor` class called `MulticastDelegateListener`. Add the following
    to the declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class implementation, add the following code to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MulticastDelegateListener.cpp` file, add the following `#includes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `MulticastDelegateListener::BeginPlay` implementation, add the following
    code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `ToggleLight`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement our `EndPlay` overridden function:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line to `TriggerVolume::NotifyActorBeginOverlap()`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and load your project. Set the `GameMode` in your level as our cookbook
    game mode, and then drag four or five instances of `MulticastDelegateListener`
    into the scene.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Step into `TriggerVolume` to see all of the `MulticastDelegateListener` toggle
    their light''s visibility:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f53635e5-ef24-4ad9-beaa-9c3c07556083.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might expect, the delegate type needs to be explicitly declared as a
    multicast delegate rather than a standard single-binding one. Our new `Listener`
    class is very similar to our original `DelegateListener`. The primary difference
    is that we need to store a reference to our delegate instance in `FDelegateHandle`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the actor is destroyed, we safely remove ourselves from the list of functions
    that are bound to the delegate by using the stored `FDelegateHandle` as a parameter to
    `Remove()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Broadcast()` function is the multicast equivalent of `ExecuteIfBound()`.
    Unlike standard delegates, there is no need to check whether the delegate bound
    either in advance or with a call such as `ExecuteIfBound`. `Broadcast()` is safe
    to run, no matter how many functions are bound, or even if none are.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we have multiple instances of our multicast listener in the scene, they
    each register themselves with the multicast delegate that's implemented in the
    `GameMode`. Then, when the `TriggerVolume` overlaps a player, it broadcasts the
    delegate, and each Listener is notified, causing it to toggle the visibility of
    its associated point light.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Multicast delegates can take parameters in exactly the same way that a standard
    delegate can.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a custom Event
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom delegates are quite useful, but one of their limitations is that they
    can be broadcast externally by some other third-party class; that is, their `Execute`/`Broadcast`
    methods are publically accessible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At times, you may want a delegate that is externally assignable by other classes,
    but can only be broadcast by the class that contains them. This is the primary
    purpose of Events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you've followed the initial recipe in this chapter so that you have
    the `MyTriggerVolume` and `Chapter_05GameModeBase` implementations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following event declaration macro to the header of your `MyTriggerVolume`
    class:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an instance of the declared event signature to the class:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `AMyTriggerVolume::NotifyActorBeginOverlap`, add the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `Actor` class called `TriggerVolEventListener`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e1b64847-e6d5-4921-b15a-d3b256e83a55.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add the following class members to its declaration:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize `PointLight` in the class constructor:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `BeginPlay`, add the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, implement `OnTriggerEvent()`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile your project and launch the editor. Create a level with the game mode
    set to our `Chapter_05GameModeBase`, and then drag an instance of `ATriggerVolEventListener`
    and `AMyTriggerVolume` out into the level.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select `TriggerVolEventListener`, and you''ll see `TriggerVolEventListener`
    listed as a category in the Details panel, with the property as Trigger Event
    Source:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6cf0cd5-d3c1-493a-82ef-d8d32cf5b8ba.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The Trigger Vol Event Listener category
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the drop-down menu to select your instance of `AMyTriggerVolume` so that
    the Listener knows which event to bind to:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b26436bd-dbff-45ea-a696-fe24e5d2b01a.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Play your game and enter the trigger volume''s zone of effect. Verify that
    the color of your `EventListener` changes to green:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/018dd943-a7f0-49a1-8002-9f0a09250bc2.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As with all of the other types of delegate, Events require their own special
    macro function. The first parameter is the class that the event will be implemented
    into. This will be the only class able to call `Broadcast()`, so make sure it
    is the right one. The second parameter is the type name for our new event function
    signature. We add an instance of this type to our class. The Unreal documentation
    suggests `On<x>` as a naming convention.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When something overlaps our `TriggerVolume`, we call `Broadcast()` on our own
    event instance. Inside the new class, we create a point light as a visual representation
    of the event being triggered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also create a pointer to `TriggerVolume` to listen to events. We mark the
    `UPROPERTY` as `EditAnywhere`, because this allows us to set it in the Editor
    rather than having to acquire the reference programmatically using `GetAllActorsOfClass`
    or something else.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Last is our event handler for when something enters the `TriggerVolume`. We
    create and initialize our point light in the constructor as usual. When the game
    starts, the Listener checks that our `TriggerVolume` reference is valid, and then
    binds our `OnTriggerEvent` function to the `TriggerVolume` event. Inside `OnTriggerEvent`,
    we change our light's color to green. When something enters `TriggerVolume`, it
    causes `TriggerVolume` to call a broadcast on its own event. Our `TriggerVolEventListener`
    then has its bound method invoked, changing our light's color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a Time of Day handler
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to use the concepts that were introduced in the previous
    recipes to create an actor that informs other actors of the passage of time within
    your game.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `Actor` class called `TimeOfDayHandler`, as shown in the following
    screenshot:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/67f4437f-f3c4-481a-88de-3544020d0d69.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add a multicast delegate declaration to the header:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an instance of our delegate to the class declaration in the `public` section:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following properties to the class:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the initialization of these properties to the constructor:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `Tick`, add the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `Actor` class called `Clock`, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45d5f742-3133-4c83-8c99-94081faaf7de.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add the following properties to the class header:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize and transform the components in the constructor:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to `BeginPlay`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, implement `TimeChanged` as your event handler:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Place an instance of `TimeOfDayHandler` and the `AClock` into your level. Then,
    play it to see the hands on the clock rotate:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5441e608-52a9-4943-b354-09481e9006cb.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TimeOfDayHandler` contains a delegate that takes two parameters, hence the
    use of the `TwoParams` variant of the macro. Our class contains variables to store
    hours, minutes, and seconds, as well as `TimeScale`, which is an acceleration
    factor that''s used to speed up time for testing purposes. Inside the handler''s
    `Tick` function, we accumulate elapsed seconds based on the time elapsed since
    the last frame. We check if the elapsed seconds have gone over 60\. If so, we
    subtract 60, and increment `Minutes`. The same happens with `Minutes`: if they
    go over 60, we subtract 60, and increment `Hours`. If `Minutes` or `Hours` was
    updated, we broadcast our delegate to let any object that has subscribed to the
    delegate know that the time has changed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Clock` actor uses a series of Scene components and Static meshes to build
    a mesh hierarchy that resembles a clock face. In the `Clock` constructor, we parent
    the components in the hierarchy and set their initial scale and rotations. In
    `BeginPlay`, the clock uses `GetAllActorsOfClass()` to fetch all of the time of
    day handlers in the level. If there's at least one `TimeOfDayHandler` in the level,
    the `Clock` accesses the first one, and subscribes to its `TimeChanged` event. When
    the `TimeChanged` event fires, the clock rotates the hour and minute hands based
    on how many hours and minutes the time is currently set at.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a respawning pickup for a First Person Shooter
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to create a placeable pickup that will respawn after
    a certain amount of time, suitable as an ammo or other pickup for a **First Person
    Shooter** (**FPS**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `Actor` class called `Pickup`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/228a0cbd-6875-46c2-b5e4-3a5a883b9a4a.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Declare the following delegate type in `Pickup.h`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following properties to the class header:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The class will be using the `ConstructorHelpers` struct, so we need to add
    the following `#include` to the `Pickup.cpp` file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the constructor:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the overridden `NotifyActorBeginOverlap`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a second `Actor` class called `PickupSpawner`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/033b1225-911b-43b4-aa47-c543e95f44b4.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add the following code to the class header:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize our root component in the constructor:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Spawn a pickup when gameplay starts with the `SpawnPickup` function in `BeginPlay`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `PickupCollected`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following code for `SpawnPickup`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile and launch the editor, and then drag an instance of `PickupSpawner`
    out into the level. Walk into the pickup that''s represented by the spinning cube
    and verify that it spawns again 10 seconds later:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b42458a5-3e4d-4621-a7a9-c0b284280dff.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The result of completing the recipe
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, we need to create a delegate inside our `Pickup` that our Spawner
    can subscribe to so that it knows when the player collects the pickup. The `Pickup`
    also contains a Static mesh as a visual representation, and a `RotatingMovementComponent`
    so that the mesh will spin as a way to attract the attention of the players. Inside
    the `Pickup` constructor, we load one of the engine's inbuilt meshes as our visual
    representation. We specify that the mesh will overlap with other objects, then
    set the rotation rate of our mesh at 10 units per second in the *X* and *Z* axes. When
    the player overlaps the `Pickup`, it fires off its `PickedUp` delegate from the
    first step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `PickupSpawner` used
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a Scene component to specify where to spawn the pickup actor. It has a function
    for doing so, and a tagged `UPROPERTY` reference to the currently spawned `Pickup`. In
    the `PickupSpawner` constructor, we initialize our components as always. When
    play begins, the Spawner runs its `SpawnPickup` function. This function spawns
    an instance of our `Pickup`, then binds `APickupSpawner::PickupCollected` to the
    `OnPickedUp` function on the new instance. It also stores a reference to that
    current instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When `PickupCollected` runs after the player has overlapped the `Pickup`, a
    timer is created to respawn the pickup after 10 seconds. The existing delegate
    binding to the collected pickup is removed, and then the pickup is destroyed. After
    10 seconds, the timer fires, running `SpawnActor` again, which creates a new `Pickup`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
