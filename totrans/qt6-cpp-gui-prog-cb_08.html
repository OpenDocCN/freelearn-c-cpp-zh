<html><head></head><body>
<div id="_idContainer123">
<h1 class="chapter-number" id="_idParaDest-170"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-171"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.2.1">Threading Basics –Asynchronous Programming</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Most modern software runs its processes in parallel and offloads tasks to different threads to take advantage of modern CPU multicore architecture. </span><span class="koboSpan" id="kobo.3.2">This way, software can be more efficient by running multiple processes simultaneously without affecting performance. </span><span class="koboSpan" id="kobo.3.3">In this chapter, we will learn how to make</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.4.1"> use of </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">threads</span></strong><span class="koboSpan" id="kobo.6.1"> to boost our Qt 6 application’s performance </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">and efficiency.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">This chapter will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">following recipes:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Using threads</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">QObject</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.12.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">QThread</span></strong></span></li>
<li><span class="koboSpan" id="kobo.14.1">Data protection and sharing data </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">between threads</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Working with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.17.1">QRunnable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.18.1"> processes</span></span></li>
</ul>
<h1 id="_idParaDest-172"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">The technical requirements for this chapter include Qt 6.6.1 and Qt Creator 12.0.2. </span><span class="koboSpan" id="kobo.20.2">All the code used in this chapter can be downloaded from the following GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">repository: </span></span><a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter08"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter08</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.24.1">Using threads</span></h1>
<p><span class="koboSpan" id="kobo.25.1">Qt 6 provides</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.26.1"> multiple methods to create and use threads. </span><span class="koboSpan" id="kobo.26.2">You can choose between high-level methods and low-level ones. </span><span class="koboSpan" id="kobo.26.3">High-level methods are much easier to get started but are limited in what you can do with them. </span><span class="koboSpan" id="kobo.26.4">Conversely, low-level methods are more flexible but not beginner-friendly. </span><span class="koboSpan" id="kobo.26.5">In this recipe, we will learn how to use one of the high-level methods to easily create a multithreading Qt </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">6 application.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.28.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.29.1">Let’s learn how to create multithreading applications by following </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.31.1">Create a </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">Qt widget application</span></strong><span class="koboSpan" id="kobo.33.1"> and </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.34.1">open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">main.cpp</span></strong><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">Then, add the following headers at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">the file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.38.1">
#include &lt;QFuture&gt;
#include &lt;QtConcurrent/QtConcurrent&gt;
#include &lt;QFutureWatcher&gt;
#include &lt;QThread&gt;
#include &lt;QDebug&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.39.1">Then, create</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.40.1"> a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">printText()</span></strong><span class="koboSpan" id="kobo.42.1"> before the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">main()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.44.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.45.1">
void printText(QString text, int count) {
    for (int i = 0; i &lt; count; ++i)
        qDebug() &lt;&lt; text &lt;&lt; QThread::currentThreadId();
    qDebug() &lt;&lt; text &lt;&lt; "Done";
}</span></pre></li> <li><span class="koboSpan" id="kobo.46.1">After that, add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">main()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.49.1">
int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
</span><strong class="bold"><span class="koboSpan" id="kobo.50.1">    printText("A", 100);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.51.1">    printText("B", 100);</span></strong><span class="koboSpan" id="kobo.52.1">
    return a.exec();
}</span></pre></li> <li><span class="koboSpan" id="kobo.53.1">If you build and run the program now, you should see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">A</span></strong><span class="koboSpan" id="kobo.55.1"> gets printed first before </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">B</span></strong><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">Note that their thread IDs are all the same. </span><span class="koboSpan" id="kobo.57.3">This is because we are running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">printText()</span></strong><span class="koboSpan" id="kobo.59.1"> functions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">main thread:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.61.1">
...
</span><span class="koboSpan" id="kobo.61.2">"A" 0x2b82c
"A" 0x2b82c
"A" 0x2b82c
"A" Done
...
</span><span class="koboSpan" id="kobo.61.3">"B" 0x2b82c
"B" 0x2b82c
"B" 0x2b82c
"B" Done</span></pre></li> <li><span class="koboSpan" id="kobo.62.1">To separate them</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.63.1"> into different threads, let’s use a high-level class provided by Qt 6 called </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">QFuture</span></strong><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">Comment out the two </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">printText()</span></strong><span class="koboSpan" id="kobo.67.1"> functions in </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">main()</span></strong><span class="koboSpan" id="kobo.69.1"> and use the following </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">code instead:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.71.1">
    QFuture&lt;void&gt; f1 = QtConcurrent::run(printText, QString("A"), 100);
    QFuture&lt;void&gt; f2 = QtConcurrent::run(printText, QString("B"), 100);
    QFuture&lt;void&gt; f3 = QtConcurrent::run(printText, QString("C"), 100);
    f1.waitForFinished();
    f2.waitForFinished();
    f3.waitForFinished();</span></pre></li> <li><span class="koboSpan" id="kobo.72.1">If you build and run the program again, you should see something like the following being printed out on the debug window, which means that the three </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">printText()</span></strong><span class="koboSpan" id="kobo.74.1"> functions now run </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">in parallel:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.76.1">
...
</span><span class="koboSpan" id="kobo.76.2">"A" 0x271ec
"C" 0x26808
"B" 0x27a40
"A" 0x271ec
"C" Done
"B" 0x27a40
"A" Done
"B" Done</span></pre></li> <li><span class="koboSpan" id="kobo.77.1">We can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">QFutureWatcher</span></strong><span class="koboSpan" id="kobo.79.1"> class to notify a </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">QObject</span></strong><span class="koboSpan" id="kobo.81.1"> class through a</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.82.1"> signals and slots mechanism. </span><span class="koboSpan" id="kobo.82.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">QFutureWatcher</span></strong><span class="koboSpan" id="kobo.84.1"> class allows us to monitor </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">QFuture</span></strong><span class="koboSpan" id="kobo.86.1"> using signals </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">and slots:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.88.1">
    QFuture&lt;void&gt; f1 = QtConcurrent::run(printText, QString("A"), 100);
    QFuture&lt;void&gt; f2 = QtConcurrent::run(printText, QString("B"), 100);
    QFuture&lt;void&gt; f3 = QtConcurrent::run(printText, QString("C"), 100);
    </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">QFutureWatcher&lt;void&gt; futureWatcher;</span></strong><span class="koboSpan" id="kobo.90.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">QObject::connect(&amp;futureWatcher,</span></strong><span class="koboSpan" id="kobo.92.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">QFutureWatcher&lt;void&gt;::finished, &amp;w, MainWindow::mySlot);</span></strong><span class="koboSpan" id="kobo.94.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">futureWatcher.setFuture(f1);</span></strong><span class="koboSpan" id="kobo.96.1">
    f1.waitForFinished();
    f2.waitForFinished();
    f3.waitForFinished();</span></pre></li> <li><span class="koboSpan" id="kobo.97.1">After that, open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">mainwindow.h</span></strong><span class="koboSpan" id="kobo.99.1"> and declare the </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">slot function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.101.1">
public slots:
    void mySlot();</span></pre></li> <li><span class="koboSpan" id="kobo.102.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">mySlot()</span></strong><span class="koboSpan" id="kobo.104.1"> function looks like this </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">mainwindow.cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.108.1">
void MainWindow::mySlot() {
    qDebug() &lt;&lt; "Done!" </span><span class="koboSpan" id="kobo.108.2">&lt;&lt; QThread::currentThreadId();
}</span></pre></li> <li><span class="koboSpan" id="kobo.109.1">If you build and run</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.110.1"> the program again, this time, you will see results </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.112.1">
...
</span><span class="koboSpan" id="kobo.112.2">"A" 0x271ec
"C" 0x26808
"B" 0x27a40
"A" 0x271ec
"C" Done
"B" 0x27a40
"A" Done
"B" Done
</span><strong class="bold"><span class="koboSpan" id="kobo.113.1">Done! </span><span class="koboSpan" id="kobo.113.2">0x27ac0</span></strong></pre></li> <li><span class="koboSpan" id="kobo.114.1">Even though </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">QFutureWatcher</span></strong><span class="koboSpan" id="kobo.116.1"> is linked to </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">f1</span></strong><span class="koboSpan" id="kobo.118.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">Done!</span></strong><span class="koboSpan" id="kobo.120.1"> message only gets printed after all of the threads have finished executing. </span><span class="koboSpan" id="kobo.120.2">This is because </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">mySlot()</span></strong><span class="koboSpan" id="kobo.122.1"> runs in the main thread, proven by the thread ID shown in the debug window alongside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">Done!</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.124.1"> message.</span></span></li>
</ol>
<h2 id="_idParaDest-175"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.125.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.126.1">By default, there is a main thread (also known as a GUI thread) in any Qt 6 application. </span><span class="koboSpan" id="kobo.126.2">Other threads that you create are</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.127.1"> called the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.128.1">worker threads</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">GUI-related classes, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">QWidget</span></strong><span class="koboSpan" id="kobo.132.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">QPixmap</span></strong><span class="koboSpan" id="kobo.134.1">, can only exist in the main thread, so you must be extra careful when dealing with </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">these classes.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">QFuture</span></strong><span class="koboSpan" id="kobo.137.1"> is a high-level class that deals </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.138.1">with </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.139.1">asynchronous computation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">QFutureWatcher</span></strong><span class="koboSpan" id="kobo.143.1"> class to let </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">QFuture</span></strong><span class="koboSpan" id="kobo.145.1"> interact with signals and slots. </span><span class="koboSpan" id="kobo.145.2">You can even use </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.146.1">this to display the progress of the operation on a </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">progress bar.</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.148.1">QObject and QThread</span></h1>
<p><span class="koboSpan" id="kobo.149.1">Next, we want to</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.150.1"> explore some</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.151.1"> other methods so that we can use threads in Qt 6 applications. </span><span class="koboSpan" id="kobo.151.2">Qt 6 provides a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">QThread</span></strong><span class="koboSpan" id="kobo.153.1">, which gives you more control over how you create and execute a thread. </span><span class="koboSpan" id="kobo.153.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">QThread</span></strong><span class="koboSpan" id="kobo.155.1"> object begins to execute its event loops in a thread by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">run()</span></strong><span class="koboSpan" id="kobo.157.1"> function. </span><span class="koboSpan" id="kobo.157.2">In this example, we will learn how to make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">QObject</span></strong><span class="koboSpan" id="kobo.159.1"> class work together asynchronously through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Qthread</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1"> class.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.162.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.163.1">Let’s get started by performing the </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.165.1">Create a new Qt widget application project. </span><span class="koboSpan" id="kobo.165.2">Then, go to </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">File</span></strong><span class="koboSpan" id="kobo.167.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">New File or Project...</span></strong><span class="koboSpan" id="kobo.169.1"> and create a </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">C++ </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.171.1">Class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.172.1"> file:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer121">
<span class="koboSpan" id="kobo.173.1"><img alt="Figure 8.1 – Create a new C++ class" src="image/B20976_08_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.174.1">Figure 8.1 – Create a new C++ class</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.175.1">After that, name</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.176.1"> the </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.177.1">new class </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">MyWorker</span></strong><span class="koboSpan" id="kobo.179.1"> and make it inherit from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">QObject</span></strong><span class="koboSpan" id="kobo.181.1"> class. </span><span class="koboSpan" id="kobo.181.2">Don’t forget to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">QObject</span></strong><span class="koboSpan" id="kobo.183.1"> class by default </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">as well:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer122">
<span class="koboSpan" id="kobo.185.1"><img alt="Figure 8.2 – Define the MyWorker C++ class" src="image/B20976_08_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.186.1">Figure 8.2 – Define the MyWorker C++ class</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.187.1">Once you have created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">MyWorker</span></strong><span class="koboSpan" id="kobo.189.1"> class, open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">myworker.h</span></strong><span class="koboSpan" id="kobo.191.1"> and add the following headers at </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">the top:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.193.1">
#include &lt;QObject&gt;
#include &lt;QDebug&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.194.1">After that, add the following signals and slot functions to the file </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">as well:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.196.1">
signals:
    void showResults(int res);
    void doneProcess();
public slots:
    void process();</span></pre></li> <li><span class="koboSpan" id="kobo.197.1">Next, open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">myworker.cpp</span></strong><span class="koboSpan" id="kobo.199.1"> and implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">process()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.201.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.202.1">
void MyWorker::process() {
    int result = 0;
    for (int i = 0; i &lt; 2000000000; ++i) {
    result += 1;
    }
    emit showResults(result);
    emit doneProcess();
}</span></pre></li> <li><span class="koboSpan" id="kobo.203.1">After that, open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">mainwindow.h</span></strong><span class="koboSpan" id="kobo.205.1"> and add the following headers at </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">the top:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.207.1">
#include &lt;QDebug&gt;
#include &lt;QThread&gt;
#include "myworker.h"</span></pre></li> <li><span class="koboSpan" id="kobo.208.1">Then, declare a</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.209.1"> slot </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.210.1">function, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.212.1">
public slots:
    void handleResults(int res);</span></pre></li> <li><span class="koboSpan" id="kobo.213.1">Once you’re done, open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">mainwindow.cpp</span></strong><span class="koboSpan" id="kobo.215.1"> and implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">handResults()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.217.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.218.1">
void MainWindow::handleResults(int res) {
    qDebug() &lt;&lt; "Handle results" &lt;&lt; res;
}</span></pre></li> <li><span class="koboSpan" id="kobo.219.1">Lastly, we will add the following code to the class constructor of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">MainWindow</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.221.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.222.1">
MainWindow::MainWindow(QWidget *parent) :     QMainWindow(parent), ui(new Ui::MainWindow){
    ui-&gt;setupUi(this);
    QThread* workerThread = new QThread;
    MyWorker *workerObject = new MyWorker;
    workerObject-&gt;moveToThread(workerThread);
    connect(workerThread, &amp;QThread::started,  workerObject, &amp;MyWorker::process);
    connect(workerObject, &amp;MyWorker::doneProcess,  workerThread, &amp;QThread::quit);
    connect(workerObject, &amp;MyWorker::doneProcess, workerObject, &amp;MyWorker::deleteLater);
    connect(workerObject, &amp;MyWorker::showResults, this, &amp;MainWindow::handleResults);
    connect(workerThread, &amp;QThread::finished, workerObject, &amp;MyWorker::deleteLater);
    workerThread-&gt;start();
}</span></pre></li> <li><span class="koboSpan" id="kobo.223.1">Build and run the program now. </span><span class="koboSpan" id="kobo.223.2">You should see that the main window pops out and does nothing for </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.224.1">a </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.225.1">couple of seconds before a line of message is printed on the </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">debug window:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.227.1">
Final result: 2000000000</span></pre></li> <li><span class="koboSpan" id="kobo.228.1">The result was calculated in a separate thread, which is why the main window can display smoothly and can even be moved around by a mouse during the calculation. </span><span class="koboSpan" id="kobo.228.2">To see the difference when running the calculation on the main thread, let’s comment out some of the code and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">process()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.230.1">function directly:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.231.1">
    //QThread* workerThread = new QThread;
    MyWorker *workerObject = new MyWorker;
    //workerObject-&gt;moveToThread(workerThread);
    //connect(workerThread, &amp;QThread::started, workerObject, &amp;MyWorker::process);
    //connect(workerObject, &amp;MyWorker::doneProcess, workerThread, &amp;QThread::quit);
    connect(workerObject, &amp;MyWorker::doneProcess, workerObject, &amp;MyWorker::deleteLater);
    connect(workerObject, &amp;MyWorker::showResults, this, &amp;MainWindow::handleResults);
    //connect(workerThread, &amp;QThread::finished, workerObject, &amp;MyWorker::deleteLater);
    //workerThread-&gt;start();
    </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">workerObject-&gt;process();</span></strong></pre></li> <li><span class="koboSpan" id="kobo.233.1">Build and run the project now. </span><span class="koboSpan" id="kobo.233.2">This time, the main window will only appear on the screen once the calculation has been done. </span><span class="koboSpan" id="kobo.233.3">This is because the calculation was blocking the </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.234.1">main </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.235.1">thread (or GUI thread) and prevented the main window from </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">being displayed.</span></span></li>
</ol>
<h2 id="_idParaDest-178"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.237.1">How it works…</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">QThread</span></strong><span class="koboSpan" id="kobo.239.1"> is an alternative method to run a process asynchronously, besides using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">QFuture</span></strong><span class="koboSpan" id="kobo.241.1"> class. </span><span class="koboSpan" id="kobo.241.2">It gives us more control compared with </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">QFuture</span></strong><span class="koboSpan" id="kobo.243.1">, which we will demonstrate in the </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">following recipe.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">Do note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">QObject</span></strong><span class="koboSpan" id="kobo.247.1"> class that gets moved to the working thread cannot have any parent, as Qt is designed in such a way that an entire object tree must exist in the same thread. </span><span class="koboSpan" id="kobo.247.2">Therefore, all of the children of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">QObject</span></strong><span class="koboSpan" id="kobo.249.1"> class will also be moved to the working thread when you </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">moveToThread()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">Use a signals and slots mechanism if you want your working thread to communicate with the main thread. </span><span class="koboSpan" id="kobo.253.2">We use the started signal that’s provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">QThread</span></strong><span class="koboSpan" id="kobo.255.1"> class to inform our working object to start the calculation, since the working thread has already </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">been created.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">Then, when the calculation</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.258.1"> has</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.259.1"> been completed, we emit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">showResult</span></strong><span class="koboSpan" id="kobo.261.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">doneProcess</span></strong><span class="koboSpan" id="kobo.263.1"> signals to inform the thread to quit, while passing the final result to the main thread for it to </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">be printed.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Lastly, we also use the signals and slots mechanism to safely delete both the working thread and working object when everything </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">is done.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.267.1">Data protection and sharing data between threads</span></h1>
<p><span class="koboSpan" id="kobo.268.1">Even though </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.269.1">multithreading</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.270.1"> makes processes run </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.271.1">asynchronously, there will be times when threads must stop and wait for other threads. </span><span class="koboSpan" id="kobo.271.2">This usually happens when both threads modify the same variable simultaneously. </span><span class="koboSpan" id="kobo.271.3">It is common to force threads to wait for one another to protect shared resources, such as data. </span><span class="koboSpan" id="kobo.271.4">Qt 6 also provides both low-level methods and high-level mechanisms to </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">synchronize threads.</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.273.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.274.1">We will continue to use the code from the previous example project, since we have already established a working program </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">with multithreading:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.276.1">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">myworker.h</span></strong><span class="koboSpan" id="kobo.278.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">following header:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.280.1">
#include &lt;QObject&gt;
#include &lt;QDebug&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.281.1">#include &lt;QMutex&gt;</span></strong></pre></li> <li><span class="koboSpan" id="kobo.282.1">Then, we will add two new variables and make some changes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">class constructor:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.284.1">
public:
    explicit MyWorker</span><strong class="bold"><span class="koboSpan" id="kobo.285.1">(QMutex *mutex);</span></strong><span class="koboSpan" id="kobo.286.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">int* myInputNumber;</span></strong><span class="koboSpan" id="kobo.288.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">QMutex* myMutex;</span></strong><span class="koboSpan" id="kobo.290.1">
signals:
    void showResults(int res);
    void doneProcess();</span></pre></li> <li><span class="koboSpan" id="kobo.291.1">After that, open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">myworker.cpp</span></strong><span class="koboSpan" id="kobo.293.1"> and change the class constructor to look like the following code. </span><span class="koboSpan" id="kobo.293.2">We no longer require the parent input, since the object will not have </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">a parent:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.295.1">
MyWorker::MyWorker</span><strong class="bold"><span class="koboSpan" id="kobo.296.1">(QMutex *mutex)</span></strong><span class="koboSpan" id="kobo.297.1"> {
    </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">myMutex = mutex;</span></strong><span class="koboSpan" id="kobo.299.1">
}</span></pre></li> <li><span class="koboSpan" id="kobo.300.1">We will also change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">process()</span></strong><span class="koboSpan" id="kobo.302.1"> function to look </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.304.1">
void MyWorker::process() {
    myMutex-&gt;lock();
    for (int i = 1; i &lt; 100000; ++i){
    *myInputNumber += i * i + 2 * i + 3 * i;
    }
    myMutex-&gt;unlock();
    emit showResults(*myInputNumber);
    emit doneProcess();
}</span></pre></li> <li><span class="koboSpan" id="kobo.305.1">Once you’re</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.306.1"> done, open</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.307.1"> up </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">mainwindow.cpp</span></strong><span class="koboSpan" id="kobo.309.1"> and make some changes to </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">the code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.311.1">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
    ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    int myNumber = 5;
    QMutex* newMutex = new QMutex;
    QThread* workerThread = new QThread;
    QThread* workerThread2 = new QThread;
    QThread* workerThread3 = new QThread;
    MyWorker *workerObject = new MyWorker(newMutex);
    MyWorker *workerObject2 = new MyWorker(newMutex);
    MyWorker *workerObject3 = new MyWorker(newMutex);</span></pre></li> <li><span class="koboSpan" id="kobo.312.1">After that, we will set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">myInputNumber</span></strong><span class="koboSpan" id="kobo.314.1"> variable of the worker object to </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">myNumber</span></strong><span class="koboSpan" id="kobo.316.1">. </span><span class="koboSpan" id="kobo.316.2">Note that we are referencing its pointer instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">the value:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.318.1">
    workerObject-&gt;myInputNumber = &amp;myNumber;
    workerObject-&gt;moveToThread(workerThread);
    connect(workerThread, &amp;QThread::started, workerObject, &amp;MyWorker::process);
    connect(workerObject, &amp;MyWorker::doneProcess, workerThread, &amp;QThread::quit);
    connect(workerObject, &amp;MyWorker::doneProcess, workerObject, &amp;MyWorker::deleteLater);
    connect(workerObject, &amp;MyWorker::showResults, this, &amp;MainWindow::handleResults);
    connect(workerThread, &amp;QThread::finished, workerObject, &amp;MyWorker::deleteLater);</span></pre></li> <li><span class="koboSpan" id="kobo.319.1">Repeat the </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.320.1">previous</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.321.1"> step twice more to set </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">workerObject2</span></strong><span class="koboSpan" id="kobo.323.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">workerThread2</span></strong><span class="koboSpan" id="kobo.325.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">workerObject3</span></strong><span class="koboSpan" id="kobo.327.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">workerThread3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.331.1">
    workerObject2-&gt;myInputNumber = &amp;myNumber;
    workerObject2-&gt;moveToThread(workerThread2);
    connect(workerThread2, &amp;QThread::started, workerObject2, &amp;MyWorker::process);
    connect(workerObject2, &amp;MyWorker::doneProcess, workerThread2, &amp;QThread::quit);
    connect(workerObject2, &amp;MyWorker::doneProcess, workerObject2, &amp;MyWorker::deleteLater);
    connect(workerObject2, &amp;MyWorker::showResults, this, &amp;MainWindow::handleResults);
    connect(workerThread2, &amp;QThread::finished, workerObject2, &amp;MyWorker::deleteLater);
    workerObject3-&gt;myInputNumber = &amp;myNumber;
    workerObject3-&gt;moveToThread(workerThread3);
    connect(workerThread3, &amp;QThread::started, workerObject3, &amp;MyWorker::process);
    connect(workerObject3, &amp;MyWorker::doneProcess, workerThread3, &amp;QThread::quit);
    connect(workerObject3, &amp;MyWorker::doneProcess, workerObject3, &amp;MyWorker::deleteLater);
    connect(workerObject3, &amp;MyWorker::showResults, this, &amp;MainWindow::handleResults);
    connect(workerThread3, &amp;QThread::finished, workerObject3, &amp;MyWorker::deleteLater);</span></pre></li> <li><span class="koboSpan" id="kobo.332.1">Finally, we will start running those threads by </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">start()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.336.1">
    workerThread-&gt;start();
    workerThread2-&gt;start();
    workerThread3-&gt;start();</span></pre></li> <li><span class="koboSpan" id="kobo.337.1">If you build and run the program now, you should see a consistent result, no matter how </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.338.1">many </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.339.1">times you </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">run it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.341.1">
Final result: -553579035
Final result: -1107158075
Final result: -1660737115</span></pre></li> <li><span class="koboSpan" id="kobo.342.1">We get results every time we run the program because the mutex lock ensures that only one of the threads can modify the data while other threads await their completion. </span><span class="koboSpan" id="kobo.342.2">To see the difference without mutex locking, let’s comment out </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">the code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.344.1">
void MyWorker::process() {
    </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">//myMutex-&gt;lock();</span></strong><span class="koboSpan" id="kobo.346.1">
    for (int i = 1; i &lt; 100000; ++i) {
        *myInputNumber += i * i + 2 * i + 3 * i;
        }
    </span><strong class="bold"><span class="koboSpan" id="kobo.347.1">//myMutex-&gt;unlock();</span></strong><span class="koboSpan" id="kobo.348.1">
    emit showResults(*myInputNumber);
    emit doneProcess();
}</span></pre></li> <li><span class="koboSpan" id="kobo.349.1">Build and run the program again. </span><span class="koboSpan" id="kobo.349.2">This time, you will get a very different result when you run the program. </span><span class="koboSpan" id="kobo.349.3">For example, I’ve obtained the following results when running it</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.350.1"> on </span><a id="_idIndexMarker564"/><span class="No-Break"><span class="koboSpan" id="kobo.351.1">three occasions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.352.1">
1st time:
Final result: -589341102
Final result: 403417142
Final result: -978935318
2nd time:
Final result: 699389030
Final result: -175723048
Final result: 1293365532
3rd time:
Final result: 1072831160
Final result: 472989964
Final result: -534842088</span></pre></li> <li><span class="koboSpan" id="kobo.353.1">This happens because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">myNumber</span></strong><span class="koboSpan" id="kobo.355.1"> data is manipulated by all the threads simultaneously in a random order, due to the nature of parallel computation. </span><span class="koboSpan" id="kobo.355.2">By locking the mutex, we make sure that the data can only be modified by a single thread and, hence, eliminate </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">this issue.</span></span></li>
</ol>
<h2 id="_idParaDest-181"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.357.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.358.1">Qt 6 provides two classes, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">QMutex</span></strong><span class="koboSpan" id="kobo.360.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">QReadWriteLock</span></strong><span class="koboSpan" id="kobo.362.1">, for data protection when multiple threads access and modify the same data. </span><span class="koboSpan" id="kobo.362.2">We only used </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">QMutex</span></strong><span class="koboSpan" id="kobo.364.1"> in the previous example, but both classes are very similar in nature. </span><span class="koboSpan" id="kobo.364.2">The only difference is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">QReadWriteLock</span></strong><span class="koboSpan" id="kobo.366.1"> allows data to be read simultaneously by other threads while the data is written. </span><span class="koboSpan" id="kobo.366.2">Unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">QMutex</span></strong><span class="koboSpan" id="kobo.368.1">, it separates the read and write states, but only one can occur at a time (either lock for read or lock for write), and not both. </span><span class="koboSpan" id="kobo.368.2">For complex functions and statements, use the high-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">QMutexLocker</span></strong><span class="koboSpan" id="kobo.370.1"> class instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">QMutex</span></strong><span class="koboSpan" id="kobo.372.1"> for simplifying the code and </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">easier debugging.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">The downside of this method is that all of the other threads will stand idle while the data is modified by a single thread. </span><span class="koboSpan" id="kobo.374.2">It is best not to share data with multiple threads unless there is no other</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.375.1"> way</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.376.1"> to do so, as it will halt the other threads and defeat the object of </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">parallel computation.</span></span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.378.1">Working with QRunnable processes</span></h1>
<p><span class="koboSpan" id="kobo.379.1">In this recipe, we </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.380.1">will learn how to use another type of high-level method to easily create a multithreading Qt 6 application. </span><span class="koboSpan" id="kobo.380.2">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">QRunnable</span></strong><span class="koboSpan" id="kobo.382.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">QThreadPool</span></strong><span class="koboSpan" id="kobo.384.1"> classes in </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">this recipe.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.386.1">How to do it…</span></h2>
<ol>
<li><span class="koboSpan" id="kobo.387.1">Create a new Qt widget application project and then a new C++ class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">MyProcess</span></strong><span class="koboSpan" id="kobo.389.1">, which inherits the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">QRunnable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.391.1"> class.</span></span></li>
<li><span class="koboSpan" id="kobo.392.1">Next, open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">myprocess.h</span></strong><span class="koboSpan" id="kobo.394.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">following headers:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.396.1">
#include &lt;QRunnable&gt;
#include &lt;QDebug&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.397.1">Then, declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">run()</span></strong><span class="koboSpan" id="kobo.399.1"> function, </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.401.1">
class MyProcess : public QRunnable {
    public:
            MyProcess();
            </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">void run();</span></strong><span class="koboSpan" id="kobo.403.1">
};</span></pre></li> <li><span class="koboSpan" id="kobo.404.1">After that, open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">myprocess.cpp</span></strong><span class="koboSpan" id="kobo.406.1"> and define the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">run()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.408.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.409.1">
void MyProcess::run() {
    int myNumber = 0;
    for (int i = 0; i &lt; 100000000; ++i) {
    myNumber += i;
    }
    qDebug() &lt;&lt; myNumber;
}</span></pre></li> <li><span class="koboSpan" id="kobo.410.1">Once you’re done, add the following headers </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">mainwindow.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.414.1">
#include &lt;QMainWindow&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.415.1">#include &lt;QThreadPool&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.416.1">#include "myprocess.h"</span></strong></pre></li> <li><span class="koboSpan" id="kobo.417.1">After that, we will</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.418.1"> implement the class constructor by adding the </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.420.1">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
    ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    MyProcess* process = new MyProcess;
    MyProcess* process2 = new MyProcess;
    MyProcess* process3 = new MyProcess;
    MyProcess* process4 = new MyProcess;
    QThreadPool::globalInstance()-&gt;start(process);
    QThreadPool::globalInstance()-&gt;start(process2);
    QThreadPool::globalInstance()-&gt;start(process3);
    QThreadPool::globalInstance()-&gt;start(process4);
    qDebug() &lt;&lt; QThreadPool::globalInstance()-       &gt;activeThreadCount();
}</span></pre></li> <li><span class="koboSpan" id="kobo.421.1">Now, build and run the project. </span><span class="koboSpan" id="kobo.421.2">You should see that the processes are successfully run in different threads where the active thread count </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">is four.</span></span></li>
<li><span class="koboSpan" id="kobo.423.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">QThreadPool</span></strong><span class="koboSpan" id="kobo.425.1"> class automatically deactivates threads when its last process has been executed. </span><span class="koboSpan" id="kobo.425.2">Let’s try and prove that by pausing the program for three seconds and printing out the active thread </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">count again:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.427.1">
    qDebug() &lt;&lt; QThreadPool::globalInstance()-&gt;activeThreadCount();
    </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">this-&gt;thread()-&gt;sleep(3);</span></strong><span class="koboSpan" id="kobo.429.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">qDebug() &lt;&lt; QThreadPool::globalInstance()-&gt;activeThreadCount();</span></strong></pre></li> <li><span class="koboSpan" id="kobo.431.1">Build and run the program again. </span><span class="koboSpan" id="kobo.431.2">This time, you should see that the active thread count is </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.432.1">four, and then, after three seconds, the active thread count becomes zero. </span><span class="koboSpan" id="kobo.432.2">This is because all of the processes have </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">been executed.</span></span></li>
</ol>
<h2 id="_idParaDest-184"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.434.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.435.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">QRunnable</span></strong><span class="koboSpan" id="kobo.437.1"> class works hand in hand with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">QThreadPool</span></strong><span class="koboSpan" id="kobo.439.1"> class, which manages a collection of threads. </span><span class="koboSpan" id="kobo.439.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">QThreadPool</span></strong><span class="koboSpan" id="kobo.441.1"> class automatically manages and recycles individual </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">QThreads</span></strong><span class="koboSpan" id="kobo.443.1"> objects to avoid creating and destroying threads too frequently, which helps in reducing </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">computing costs.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">To use </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">QThreadPool</span></strong><span class="koboSpan" id="kobo.447.1">, you must sub-class the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">QRunnable</span></strong><span class="koboSpan" id="kobo.449.1"> object and implement the virtual function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">run()</span></strong><span class="koboSpan" id="kobo.451.1">. </span><span class="koboSpan" id="kobo.451.2">By default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">QThreadPool</span></strong><span class="koboSpan" id="kobo.453.1"> will automatically delete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">QRunnable</span></strong><span class="koboSpan" id="kobo.455.1"> object when the last thread exits the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">run</span></strong><span class="koboSpan" id="kobo.457.1"> function. </span><span class="koboSpan" id="kobo.457.2">You can change this behavior by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">setAutoDelete()</span></strong><span class="koboSpan" id="kobo.459.1"> to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">autoDelete</span></strong><span class="koboSpan" id="kobo.461.1"> variable </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">By default, threads that are unused for more than 30 seconds will expire. </span><span class="koboSpan" id="kobo.465.2">You can change this duration by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">setExpiryTimeout()</span></strong><span class="koboSpan" id="kobo.467.1"> before the thread runs. </span><span class="koboSpan" id="kobo.467.2">Otherwise, there will be no effect on the </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">timeout setting.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">You can also set the </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.470.1">maximum number of threads that can be used by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">setMaxThreadCount()</span></strong><span class="koboSpan" id="kobo.472.1">. </span><span class="koboSpan" id="kobo.472.2">To get the total number of currently active threads, simply </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">activeThreadCount()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">.</span></span></p>
</div>
</body></html>