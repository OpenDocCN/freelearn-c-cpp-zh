["```cpp\nTEMPLATE = subdirs \n\nSUBDIRS += \\ \n    gallery-core \n\n```", "```cpp\nQT       += sql \nQT       -= gui \n\nTARGET = gallery-core \nTEMPLATE = lib \n\nDEFINES += GALLERYCORE_LIBRARY \nSOURCES += Album.cpp \nHEADERS += Album.h\\ \n        gallery-core_global.h \n\nunix { \n    target.path = /usr/lib \n    INSTALLS += target \n} \n\n```", "```cpp\n#include <QtCore/qglobal.h> \n\n#if defined(GALLERYCORE_LIBRARY) \n#  define GALLERYCORESHARED_EXPORT Q_DECL_EXPORT \n#else \n#  define GALLERYCORESHARED_EXPORT Q_DECL_IMPORT \n#endif \n\n```", "```cpp\n#ifndef ALBUM_H \n#define ALBUM_H \n\n#include \"gallery-core_global.h\" \n\nclass GALLERYCORESHARED_EXPORT Album \n{ \n\npublic: \n    Album(); \n}; \n\n#endif // ALBUM_H \n\n```", "```cpp\n#include <QString> \n\n#include \"gallery-core_global.h\" \n\nclass GALLERYCORESHARED_EXPORT Album \n{ \npublic: \n    explicit Album(const QString& name = \"\"); \n\n    int id() const; \n    void setId(int id); \n    QString name() const; \n    void setName(const QString& name); \n\nprivate: \n    int mId; \n    QString mName; \n}; \n\n```", "```cpp\nAlbum::Album(const QString& name) : \n    mId(-1), \n    mName(name) \n{ \n} \n\n```", "```cpp\n#include <QUrl> \n#include <QString> \n\n#include \"gallery-core_global.h\" \n\nclass GALLERYCORESHARED_EXPORT Picture \n{ \npublic: \n    Picture(const QString& filePath = \"\"); \n    Picture(const QUrl& fileUrl); \n\n    int id() const; \n    void setId(int id); \n\n    int albumId() const; \n    void setAlbumId(int albumId); \n\n    QUrl fileUrl() const; \n    void setFileUrl(const QUrl& fileUrl); \nprivate: \n    int mId; \n    int mAlbumId; \n    QUrl mFileUrl; \n}; \n\n```", "```cpp\n#include \"Picture.h\" \nPicture::Picture(const QString& filePath) : \n    Picture(QUrl::fromLocalFile(filePath)) \n{ \n} \n\nPicture::Picture(const QUrl& fileUrl) : \n    mId(-1), \n    mAlbumId(-1), \n    mFileUrl(fileUrl) \n{ \n} \n\nQUrl Picture::fileUrl() const \n{ \n    return mFileUrl; \n} \n\nvoid Picture::setFileUrl(const QUrl& fileUrl) \n{ \n    mFileUrl = fileUrl; \n} \n\n```", "```cpp\n#include <QString> \n\nclass QSqlDatabase; \n\nconst QString DATABASE_FILENAME = \"gallery.db\"; \n\nclass DatabaseManager \n{ \npublic: \n    static DatabaseManager& instance(); \n    ~DatabaseManager(); \n\nprotected: \n    DatabaseManager(const QString& path = DATABASE_FILENAME); \n    DatabaseManager& operator=(const DatabaseManager& rhs); \n\nprivate: \n    QSqlDatabase* mDatabase; \n}; \n\n```", "```cpp\n#include \"DatabaseManager.h\" \n\n#include <QSqlDatabase> \n\nDatabaseManager& DatabaseManager::instance() \n{ \n    static DatabaseManager singleton; \n    return singleton; \n} \n\nDatabaseManager::DatabaseManager(const QString& path) : \n    mDatabase(new QSqlDatabase(QSqlDatabase::addDatabase(\"QSQLITE\"))) \n{ \n    mDatabase->setDatabaseName(path); \n    mDatabase->open(); \n} \n\nDatabaseManager::~DatabaseManager() \n{ \n    mDatabase->close(); \n    delete mDatabase; \n} \n\n```", "```cpp\nclass QSqlDatabase; \n\nclass AlbumDao \n{ \npublic: \n    AlbumDao(QSqlDatabase& database); \n    void init() const; \n\nprivate: \n    QSqlDatabase& mDatabase; \n}; \n\n```", "```cpp\n#include <QSqlDatabase> \n#include <QSqlQuery> \n\n#include \"DatabaseManager.h\" \n\nAlbumDao::AlbumDao(QSqlDatabase& database) : \n    mDatabase(database) \n{ \n} \n\nvoid AlbumDao::init() const \n{ \n    if (!mDatabase.tables().contains(\"albums\")) { \n        QSqlQuery query(mDatabase); \n        query.exec(\"CREATE TABLE albums (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)\"); \n    } \n} \n\n```", "```cpp\n// In DatabaseManager.h \n#include \"AlbumDao.h\" \n\n... \n\nprivate: \n    QSqlDatabase* mDatabase; \n\npublic: \n    const AlbumDao albumDao; \n}; \n\n// In DatabaseManager.cpp \nDatabaseManager::DatabaseManager(const QString& path) : \n    mDatabase(new QSqlDatabase(QSqlDatabase::addDatabase(\"QSQLITE\"))), \n    albumDao(*mDatabase) \n{ \n    mDatabase->setDatabaseName(path); \n    mDatabase->open(); \n\n    albumDao.init(); \n} \n\n```", "```cpp\n// In AlbumDao.h \nclass QSqlDatabase; \nclass Album; \n\nclass AlbumDao \n{ \npublic: \n    AlbumDao(QSqlDatabase& database); \n    void init() const; \n\n    void addAlbum(Album& album) const; \n    ... \n}; \n\n// In AlbumDao.cpp \n\n#include <QSqlDatabase> \n#include <QSqlQuery> \n#include <QVariant> \n\n... \n\nvoid AlbumDao::addAlbum(Album& album) const \n{ \n    QSqlQuery query(mDatabase); \n    query.prepare(\"INSERT INTO albums (name) VALUES (:name)\"); \n    query.bindValue(\":name\", album.name()); \n    query.exec(); \n    album.setId(query.lastInsertId().toInt()); \n} \n\n```", "```cpp\n// In AlbumDao.h \n#include <QVector> \n\n    ... \n    void addAlbum(Album& album) const; \n    void updateAlbum(const Album& album) const; \n    void removeAlbum(int id) const; \n    QVector<Album*> albums() const; \n    ... \n}; \n\n// In AlbumDao.cpp \nQVector<Album*> AlbumDao::albums() const \n{ \n    QSqlQuery query(\"SELECT * FROM albums\", mDatabase); \n    query.exec(); \n    QVector<Album*> list; \n    while(query.next()) { \n        Album* album = new Album(); \n        album->setId(query.value(\"id\").toInt()); \n        album->setName(query.value(\"name\").toString()); \n        list.append(album); \n    } \n    return list; \n} \n\n```", "```cpp\n// In PictureDao.h \n#include <QVector> \n\nclass QSqlDatabase; \nclass Picture; \n\nclass PictureDao \n{ \npublic: \n    explicit PictureDao(QSqlDatabase& database); \n    void init() const; \n\n    void addPictureInAlbum(int albumId, Picture& picture) const; \n    void removePicture(int id) const; \n    void removePicturesForAlbum(int albumId) const; \n    QVector<Picture*> picturesForAlbum(int albumId) const; \n\nprivate: \n    QSqlDatabase& mDatabase; \n}; \n\n// In PictureDao.cpp \nvoid PictureDao::init() const \n{ \n    if (!mDatabase.tables().contains(\"pictures\")) { \n        QSqlQuery query(mDatabase); \n        query.exec(QString(\"CREATE TABLE pictures\") \n        + \" (id INTEGER PRIMARY KEY AUTOINCREMENT, \" \n        + \"album_id INTEGER, \" \n        + \"url TEXT)\"); \n    } \n} \n\n```", "```cpp\nQVector<Album*> list; \nwhile(query.next()) { \n    Album* album = new Album(); \n    album->setId(query.value(\"id\").toInt()); \n    album->setName(query.value(\"name\").toString()); \n    list.append(album); \n} \nreturn list; \n\n```", "```cpp\n#include <memory> \nvoid foo() \n{ \n    Album* albumPointer = new Album(); \n    std::unique_ptr<Album> album(albumPointer); \n    album->setName(\"Unique Album\"); \n} \n\n```", "```cpp\nvoid foo() \n{ \n    std::unique_ptr<Album> album(new Album()); \n    bar(std::move(album)); \n} \n\nvoid bar(std::unique_ptr<Album> barAlbum) \n{ \n   qDebug() << \"Album name\" << barAlbum->name(); \n} \n\n```", "```cpp\nvoid bar(std::unique_ptr<Album>& barAlbum); \n\n```", "```cpp\n#include <memory> \nvoid foo() \n{ \n    std::shared_ptr<Album> album(new Album()); // ref counter = 1 \n    bar(album); // ref counter = 2 \n} // ref counter = 0 \n\nvoid bar(std::shared_ptr<Album> barAlbum) \n{ \n   qDebug() << \"Album name\" << barAlbum->name(); \n} // ref counter = 1 \n\n```", "```cpp\n#include <memory> \nvoid foo() \n{ \n    std::shared_ptr<Album> album(new Album()); // ref counter = 1 \n    bar(std::weak_ptr<Album>(album)); // ref counter = 1 \n} // ref counter = 0 \n\nvoid bar(std::weak_ptr<Album> barAlbum) \n{ \n   qDebug() << \"Album name\" << barAlbum->name(); \n} // ref counter = 1 \n\n```", "```cpp\nunique_ptr<Album> album = make_unique<Album>(); \n\n```", "```cpp\nfoo(new Album(), new Picture()) \n\n```", "```cpp\nfoo(make_unique<Album>(), make_unique<Picture>()) \n\n```", "```cpp\nauto album = make_unique<Album>() \n\n```", "```cpp\n// In AlbumDao.h \nstd::unique_ptr<std::vector<std::unique_ptr<Album>>> albums() const; \n\n// In AlbumDao.cpp \nunique_ptr<vector<unique_ptr<Album>>> AlbumDao::albums() const \n{ \n    QSqlQuery query(\"SELECT * FROM albums\", mDatabase); \n    query.exec(); \n    unique_ptr<vector<unique_ptr<Album>>> list(new vector<unique_ptr<Album>>()); \n    while(query.next()) { \n        unique_ptr<Album> album(new Album()); \n        album->setId(query.value(\"id\").toInt()); \n        album->setName(query.value(\"name\").toString()); \n        list->push_back(move(album)); \n    } \n    return list; \n} \n\n```", "```cpp\n#include <QAbstractListModel> \n#include <QHash> \n#include <vector> \n#include <memory> \n\n#include \"gallery-core_global.h\" \n#include \"Album.h\" \n#include \"DatabaseManager.h\" \n\nclass GALLERYCORESHARED_EXPORT AlbumModel : public QAbstractListModel \n{ \n    Q_OBJECT \npublic: \n\n    enum Roles { \n        IdRole = Qt::UserRole + 1, \n        NameRole, \n    }; \n\n    AlbumModel(QObject* parent = 0); \n\n    QModelIndex addAlbum(const Album& album); \n\n    int rowCount(const QModelIndex& parent = QModelIndex()) const override; \n    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override; \n    bool setData(const QModelIndex& index, const QVariant& value, int role) override; \n    bool removeRows(int row, int count, const QModelIndex& parent) override; \n    QHash<int, QByteArray> roleNames() const override; \n\nprivate: \n    bool isIndexValid(const QModelIndex& index) const; \n\nprivate: \n    DatabaseManager& mDb; \n    std::unique_ptr<std::vector<std::unique_ptr<Album>>> mAlbums; \n}; \n\n```", "```cpp\nAlbumModel::AlbumModel(QObject* parent) : \n    QAbstractListModel(parent), \n    mDb(DatabaseManager::instance()), \n    mAlbums(mDb.albumDao.albums()) \n{ \n} \n\n```", "```cpp\nint AlbumModel::rowCount(const QModelIndex& parent) const \n{ \n    return mAlbums->size(); \n} \n\n```", "```cpp\nQVariant AlbumModel::data(const QModelIndex& index, int role) const \n{ \n    if (!isIndexValid(index)) { \n        return QVariant(); \n    } \n    const Album& album = *mAlbums->at(index.row()); \n\n    switch (role) { \n        case Roles::IdRole: \n            return album.id(); \n\n        case Roles::NameRole: \n        case Qt::DisplayRole: \n            return album.name(); \n\n        default: \n            return QVariant(); \n    } \n} \n\n```", "```cpp\nQHash<int, QByteArray> AlbumModel::roleNames() const \n{ \n    QHash<int, QByteArray> roles; \n    roles[Roles::IdRole] = \"id\"; \n    roles[Roles::NameRole] = \"name\"; \n    return roles; \n} \n\n```", "```cpp\nQModelIndex AlbumModel::addAlbum(const Album& album) \n{ \n    int rowIndex = rowCount(); \n    beginInsertRows(QModelIndex(), rowIndex, rowIndex); \n    unique_ptr<Album> newAlbum(new Album(album)); \n    mDb.albumDao.addAlbum(*newAlbum); \n    mAlbums->push_back(move(newAlbum)); \n    endInsertRows(); \n    return index(rowIndex, 0); \n} \n\n```", "```cpp\nbool AlbumModel::setData(const QModelIndex& index, const QVariant& value, int role) \n{ \n    if (!isIndexValid(index) \n            || role != Roles::NameRole) { \n        return false; \n    } \n    Album& album = *mAlbums->at(index.row()); \n    album.setName(value.toString()); \n    mDb.albumDao.updateAlbum(album); \n    emit dataChanged(index, index); \n    return true; \n} \n\n```", "```cpp\nbool AlbumModel::removeRows(int row, int count, const QModelIndex& parent) \n{ \n    if (row < 0 \n            || row >= rowCount() \n            || count < 0 \n            || (row + count) > rowCount()) { \n        return false; \n    } \n    beginRemoveRows(parent, row, row + count - 1); \n    int countLeft = count; \n    while (countLeft--) { \n        const Album& album = *mAlbums->at(row + countLeft); \n        mDb.albumDao.removeAlbum(album.id()); \n    } \n    mAlbums->erase(mAlbums->begin() + row, \n                  mAlbums->begin() + row + count); \n    endRemoveRows(); \n    return true; \n} \n\n```", "```cpp\n#include <memory> \n#include <vector> \n\n#include <QAbstractListModel> \n\n#include \"gallery-core_global.h\" \n#include \"Picture.h\" \n\nclass Album; \nclass DatabaseManager; \nclass AlbumModel; \n\nclass GALLERYCORESHARED_EXPORT PictureModel : public QAbstractListModel \n{ \n    Q_OBJECT \npublic: \n\n    enum PictureRole { \n        FilePathRole = Qt::UserRole + 1 \n    }; \n    PictureModel(const AlbumModel& albumModel, QObject* parent = 0); \n\n    QModelIndex addPicture(const Picture& picture); \n\n    int rowCount(const QModelIndex& parent = QModelIndex()) const override; \n    QVariant data(const QModelIndex& index, int role) const override; \n    bool removeRows(int row, int count, const QModelIndex& parent) override; \n\n    void setAlbumId(int albumId); \n    void clearAlbum(); \n\npublic slots: \n    void deletePicturesForAlbum(); \n\nprivate: \n    void loadPictures(int albumId); \n    bool isIndexValid(const QModelIndex& index) const; \n\nprivate: \n    DatabaseManager& mDb; \n    int mAlbumId; \n    std::unique_ptr<std::vector<std::unique_ptr<Picture>>> mPictures; \n}; \n\n```", "```cpp\nPictureModel::PictureModel(const AlbumModel& albumModel, QObject* parent) : \n    QAbstractListModel(parent), \n    mDb(DatabaseManager::instance()), \n    mAlbumId(-1), \n    mPictures(new vector<unique_ptr<Picture>>()) \n{ \n    connect(&albumModel, &AlbumModel::rowsRemoved, \n            this, &PictureModel::deletePicturesForAlbum); \n} \n\n```", "```cpp\nvoid PictureModel::setAlbumId(int albumId) \n{ \n    beginResetModel(); \n    mAlbumId = albumId; \n    loadPictures(mAlbumId); \n    endResetModel(); \n} \n\n```", "```cpp\nvoid PictureModel::loadPictures(int albumId) \n{ \n    if (albumId <= 0) { \n         mPictures.reset(new vector<unique_ptr<Picture>>()); \n        return; \n    } \n    mPictures = mDb.pictureDao.picturesForAlbum(albumId); \n} \n\n```"]