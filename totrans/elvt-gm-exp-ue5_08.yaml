- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Creating User Interfaces with UMG
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UMG 创建用户界面
- en: In the previous chapter, we learned about general-purpose utilities that allow
    you to properly structure and organize the code and assets in your project by
    using blueprint function libraries, actor components, and interfaces.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了通用实用工具，这些工具允许你通过使用蓝图功能库、演员组件和接口来正确地结构和组织项目中的代码和资产。
- en: In this chapter, we will dive into the topic of game **User Interfaces** (**UIs**),
    which are present in almost every video game. The game UI is one of the main ways
    in which to show information to the player, such as how many lives they have left,
    how many bullets are in their weapon, which weapon they are carrying, and more.
    It also allows the player to interact with the game by choosing whether to continue
    the game, create a new game, choose which level they want to play in, and more.
    This is shown to the player mostly in the form of images and text.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨游戏**用户界面**（**UIs**）的主题，这些界面几乎存在于每款视频游戏中。游戏用户界面是向玩家展示信息的主要方式之一，例如他们剩下多少生命，他们的武器中有多少子弹，他们携带的武器是什么，等等。它还允许玩家通过选择是否继续游戏、创建新游戏、选择他们想要玩哪个关卡等方式与游戏互动。这主要以图像和文本的形式呈现给玩家。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Game UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏用户界面
- en: UMG basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMG 基础
- en: Introducing anchors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍锚点
- en: Understanding progress bars
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解进度条
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The project for this chapter can be found in the Chapter08 folder of the code
    bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的 Chapter08 文件夹中找到，该代码包可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: Game UI
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏用户界面
- en: 'Usually, UIs are added on top of the rendering of the game, which means that
    they are in front of everything else you see in the game and behave as layers
    (you can add them on top of one another just like in Photoshop). However, there
    is an exception to this: *diegetic UI*. This type of UI isn’t layered onto the
    game’s screen but rather exists inside the game itself. A great example of this
    can be found in the game *Dead Space*, where you control a character in a third-person
    view, and can see their health points by looking at the contraption attached to
    their back, inside the game world.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，用户界面是添加在游戏渲染之上，这意味着它们位于游戏中所见到的其他所有内容之前，并作为层（你可以在它们之上添加，就像在 Photoshop 中一样）。然而，这里有一个例外：*情境用户界面*。这种类型的用户界面不是叠加在游戏屏幕上，而是存在于游戏本身之中。一个很好的例子可以在游戏
    *Dead Space* 中找到，在那里你以第三人称视角控制一个角色，可以通过查看他们背部连接的装置来查看他们的健康点数，这个装置位于游戏世界中。
- en: 'There are usually two different types of game UI: **menus** and **HUDs**.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有两种不同类型的游戏用户界面：**菜单**和**头戴式显示器（HUD）**。
- en: Menus are UI panels that allow the player to interact with them, either by pressing
    a button or a key on their input device.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单是允许玩家通过按按钮或输入设备上的键与之交互的用户界面面板。
- en: 'This can be done in the form of many different menus, including the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过许多不同的菜单形式来完成，包括以下内容：
- en: Main menus, where the player can choose whether to continue the game, create
    a new game, exit the game, and more
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主菜单，玩家可以选择是否继续游戏、创建新游戏、退出游戏等
- en: Level select menus, where the player can choose which level to play
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡选择菜单，玩家可以选择要玩哪个关卡
- en: Many other options
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多其他选项
- en: HUDs are UI panels that are present during gameplay. They give the player information
    that they should always know, such as how many lives they have left, which special
    abilities they can use, and more.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 头戴式显示器（HUD）是在游戏过程中存在的用户界面面板。它们向玩家提供他们应该始终知道的信息，例如他们剩下多少生命，他们可以使用哪些特殊能力，等等。
- en: In this chapter, we will be covering game UI and how to make both a menu and
    a HUD for our game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍游戏用户界面以及如何为我们自己的游戏制作菜单和头戴式显示器（HUD）。
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: We won’t be covering diegetic UI here, as it is beyond the scope of this book.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里介绍情境用户界面，因为它超出了本书的范围。
- en: So, how do we go about creating a game UI in UE5? The main way to do it is by
    using **Unreal Motion Graphics** (**UMG**), which is the tool that allows you
    to make a game UI (also called widgets in UE5 terms), featuring menus and HUDs,
    and add them to the screen.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在 UE5 中创建游戏 UI 呢？主要方式是使用 **Unreal Motion Graphics** （**UMG**），这是一个允许您制作游戏
    UI（在 UE5 术语中也称为小部件）的工具，具有菜单和 HUD 功能，并将它们添加到屏幕上。
- en: Let’s jump into this topic in the following section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中深入探讨这个主题。
- en: UMG basics
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG 基础
- en: In UE5, the main way to create a game UI is by using the `Graph` tab.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE5 中，创建游戏 UI 的主要方式是使用 `Graph` 选项卡。
- en: Widgets are the way UE5 allows you to represent a game UI. Widgets can be basic
    UI elements such as `Image` elements, but they can also be combined to create
    more complex and complete widgets, such as menus and HUDs, which is exactly what
    we will be doing in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件是 UE5 允许您表示游戏 UI 的方式。小部件可以是基本的 UI 元素，如 `Image` 元素，但它们也可以组合起来创建更复杂和完整的小部件，如菜单和
    HUD，这正是我们在本章中将要做的。
- en: In the following exercise, let’s create our first widget in UE5 using the UMG
    tool.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，让我们使用 UMG 工具在 UE5 中创建我们的第一个小部件。
- en: Exercise 8.01 – creating a Widget Blueprint
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.01 – 创建 Widget Blueprint
- en: In this exercise, we will be creating our first Widget Blueprint. Additionally,
    we will be learning about the basic elements of UMG and how we can use them to
    create a game UI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建我们的第一个 Widget Blueprint。此外，我们还将了解 UMG 的基本元素以及我们如何使用它们来创建游戏 UI。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: In order to create our first widget, open the editor, go to the **ThirdPersonCPP
    -> Blueprints** folder inside the **Content Browser** section, and *right-click*.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建我们的第一个小部件，打开编辑器，转到 **Content Browser** 部分的 **ThirdPersonCPP -> Blueprints**
    文件夹，然后 *右键单击*。
- en: Go to the very last section, **User Interface**, and select **Widget Blueprint**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到最后一部分，**用户界面**，并选择 **Widget Blueprint**。
- en: 'After that, select **UserWidget** from the list of parent classes available:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从可用的父类列表中选择 **UserWidget**：
- en: '![Figure 8.1 – Selecting the UserWidget parent class ](img/Figure_8.01_B18531.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 选择 UserWidget 父类](img/Figure_8.01_B18531.jpg)'
- en: Figure 8.1 – Selecting the UserWidget parent class
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 选择 UserWidget 父类
- en: Selecting this option will create a new `Widget Blueprint` asset, which is the
    name of a widget asset in UE5.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项将创建一个新的 `Widget Blueprint` 资产，这是 UE5 中小部件资产的名称。
- en: 'Name this widget `TestWidget` and open it. You will see the interface for editing
    a Widget Blueprint, where you’ll be creating your own widgets and UI. Here’s a
    breakdown of all the tabs present in this window:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此小部件命名为 `TestWidget` 并打开它。您将看到编辑 Widget Blueprint 的界面，在这里您将创建自己的小部件和 UI。以下是此窗口中所有标签的概述：
- en: '![Figure 8.2 – The Widget Blueprint editor broken down into six windows ](img/Figure_8.02_B18531.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 将 Widget Blueprint 编辑器分解为六个窗口](img/Figure_8.02_B18531.jpg)'
- en: Figure 8.2 – The Widget Blueprint editor broken down into six windows
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 将 Widget Blueprint 编辑器分解为六个窗口
- en: 'The details about the tabs in the preceding screenshot are listed as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个截图中的标签详情如下：
- en: '`Button` elements, `Text Box` elements, `Image` elements, `Slider` elements,
    `Check Box` elements, and more.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮` 元素、`文本框` 元素、`图像` 元素、`滑块` 元素、`复选框` 元素等。'
- en: '**Hierarchy** – This tab shows you all the UI elements currently present in
    your widget. As you can see, currently, we only have a **Canvas Panel** element
    in our hierarchy.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次结构** – 此选项卡显示您当前小部件中所有 UI 元素。如您所见，目前我们的层次结构中只有一个 **Canvas Panel** 元素。'
- en: '**Designer** – This tab shows you how your widget looks visually, according
    to the elements present in the hierarchy, and how they’re laid out. Because the
    only element we currently have in our widget doesn’t have a visual representation,
    this tab is currently empty.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计师** – 此选项卡显示您的 widget 根据层次结构中存在的元素的外观，以及它们的布局方式。因为目前我们 widget 中唯一没有视觉表示的元素，所以此选项卡目前为空。'
- en: '**Details** – This tab shows you the properties of the UI element you have
    currently selected. If you select the existing **Canvas Panel** element, all the
    options in the preceding screenshot should appear.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详细信息** – 此选项卡显示您当前所选 UI 元素的属性。如果您选择现有的 **Canvas Panel** 元素，前一个截图中的所有选项都应出现。'
- en: Because this asset is a `Widget Blueprint` asset, these two buttons allow you
    to switch between the **Designer** view, which is the one presented in the screenshot,
    and the **Graph** view, which looks exactly like the window of a normal blueprint
    class.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为这个资产是一个`Widget Blueprint`资产，这两个按钮允许你在**设计器**视图和**图形**视图之间切换，后者看起来就像一个正常蓝图类的窗口。
- en: Now, let’s look at some of the available UI elements in our `Canvas Panel` element.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们`Canvas Panel`元素中可用的UI元素。
- en: 'Usually, **Canvas Panel** elements are added to the root of Widget Blueprints
    because they allow you to drag a UI element to any position you want in the **Designer**
    tab. This way, you can lay out these elements as you wish: at the center of the
    screen, in the upper-left corner, at the bottom center of the screen, and more.
    Now, let’s drag another very important UI element into our widget: a **Button**
    element. In order to add a **Canvas Panel** element to your widget, go to the
    **Panel** category inside the **Palette** window and drag a **Canvas Panel** element
    into your widget’s root inside the **Hierarchy** window (the first piece of text
    that says **[TestWidget]**) or inside the **Designer** window:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，**Canvas Panel**元素被添加到Widget Blueprints的根目录，因为它们允许你在**设计器**选项卡中将UI元素拖动到任何你想要的位置。这样，你可以按你的意愿布局这些元素：屏幕中心、左上角、屏幕底部中心等。现在，让我们将另一个非常重要的UI元素拖动到我们的组件中：一个**按钮**元素。为了将**Canvas
    Panel**元素添加到你的组件中，请转到**调色板**窗口中的**面板**类别，并将**Canvas Panel**元素拖动到**层次结构**窗口中你的组件根目录（即第一个文本**[TestWidget]**）或**设计器**窗口中：
- en: '![Figure 8.3 – Dragging the Canvas Panel element into the Hierarchy window
    ](img/Figure_8.03_B18531.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 将Canvas Panel元素拖动到层次结构窗口](img/Figure_8.03_B18531.jpg)'
- en: Figure 8.3 – Dragging the Canvas Panel element into the Hierarchy window
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 将Canvas Panel元素拖动到层次结构窗口
- en: 'In the **Palette** tab, find the **Button** element and drag it into the **Designer**
    window (hold the left mouse button while you drag):'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**调色板**选项卡中，找到**按钮**元素并将其拖动到**设计器**窗口中（在拖动时按住鼠标左键）：
- en: '![Figure 8.4 – A Button element being dragged from the Palette window into
    the Designer window ](img/Figure_8.04_B18531.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 将按钮元素从调色板窗口拖动到设计器窗口](img/Figure_8.04_B18531.jpg)'
- en: Figure 8.4 – A Button element being dragged from the Palette window into the
    Designer window
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 将按钮元素从调色板窗口拖动到设计器窗口
- en: 'Once you have done this, you’ll be able to resize the button to the size you
    want by dragging the little white dots around it (keep in mind that you’ll only
    be able to do this to an element that is inside a **Canvas Panel** element):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，你可以通过拖动围绕按钮的白色点来调整按钮的大小到你想要的大小（请注意，你只能对位于**Canvas Panel**元素内部的元素执行此操作）：
- en: '![Figure 8.5 – The result of resizing a UI element using the white dots around
    it ](img/Figure_8.05_B18531.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 使用围绕UI元素的白色点调整大小后的结果](img/Figure_8.05_B18531.jpg)'
- en: Figure 8.5 – The result of resizing a UI element using the white dots around
    it
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 使用围绕UI元素的白色点调整大小后的结果
- en: Another way for you to drag elements inside each other in a widget is to drag
    them inside the **Hierarchy** tab instead of the **Designer** tab.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将元素拖动到**层次结构**选项卡而不是**设计器**选项卡来在组件内部拖动元素。
- en: 'Now drag a `Text` element inside our **Button** element, but this time, use
    the **Hierarchy** tab:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将一个`Text`元素拖动到我们的**Button**元素内部，但这次，使用**层次结构**选项卡：
- en: '![Figure 8.6 – Dragging a Text element from the Palette window into the Hierarchy
    window ](img/Figure_8.06_B18531.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 将文本元素从调色板窗口拖动到层次结构窗口](img/Figure_8.06_B18531.jpg)'
- en: Figure 8.6 – Dragging a Text element from the Palette window into the Hierarchy
    window
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 将文本元素从调色板窗口拖动到层次结构窗口
- en: '`Text` elements can contain text specified by you with a certain size and font
    that you can modify in the `Details` panel. After you’ve dragged the `Text` element
    inside the `Button` element using the `Hierarchy` tab, this is what the `Designer`
    tab should look like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text`元素可以包含你指定的文本，具有特定的尺寸和字体，你可以在`详细信息`面板中修改这些设置。在您使用`层次结构`选项卡将`Text`元素拖动到`Button`元素内部后，`设计器`选项卡应该看起来是这样的：'
- en: '![Figure 8.7 – The Button element in the Designer tab, after adding a Text
    element as its child ](img/Figure_8.07_B18531.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 在添加文本元素作为其子元素后，设计器选项卡中的按钮元素](img/Figure_8.07_B18531.jpg)'
- en: Figure 8.7 – The Button element in the Designer tab, after adding a Text element
    as its child
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 在添加文本元素作为其子元素后，设计器选项卡中的按钮元素
- en: Let’s change a few properties of the preceding `Text` block.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改前面`文本`块的一些属性。
- en: 'Select it in either the `Hierarchy` tab or the **Designer** tab, and take a
    look at the **Details** panel:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`层次结构`选项卡或**设计师**选项卡中选择它，并查看**详细信息**面板：
- en: '![Figure 8.8 – The Details panel, showing the properties of the Text element
    we added ](img/Figure_8.08_B18531.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 显示我们添加的文本元素的属性的详细信息面板](img/Figure_8.08_B18531.jpg)'
- en: Figure 8.8 – The Details panel, showing the properties of the Text element we
    added
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 显示我们添加的文本元素的属性的详细信息面板
- en: 'Here, you’ll find several properties that you can edit to your liking. For
    now, we just want to focus on two of them: the content of the text and its color
    and opacity.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将找到几个可以编辑的属性。现在，我们只想关注其中两个：文本内容和其颜色和透明度。
- en: 'Update the **Content** tab of the **Text** **element** from **Text Block**
    to **Button 1**:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**文本****元素**的**内容**选项卡从**文本块**更新为**按钮1**：
- en: '![Figure 8.9 – Changing the Text property of the Text element to Button 1 ](img/Figure_8.09_B18531.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 将文本元素的文本属性更改为按钮1](img/Figure_8.09_B18531.jpg)'
- en: Figure 8.9 – Changing the Text property of the Text element to Button 1
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 将文本元素的文本属性更改为按钮1
- en: Next, let’s change the `Color and Opacity` property setting from `White` to
    `Black`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将`颜色和透明度`属性设置从`白色`更改为`黑色`。
- en: Click on the `Color` property in UE5\. It allows you to input colors in many
    different ways, including a color wheel, **Saturation** and **Value** bars, **RGB**
    and **HSV** value sliders, and more.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE5中点击`颜色`属性。它允许您以多种方式输入颜色，包括颜色轮、**饱和度**和**值**条、**RGB**和**HSV**值滑块等。
- en: 'For now, change the color from white to black by dragging the **Value** bar
    (the one that goes from white to black from top to bottom) all the way to the
    bottom and then pressing **OK**:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将**值**条（从上到下从白色到黑色的条）拖动到底部，然后按**确定**来将颜色从白色更改为黑色：
- en: '![Figure 8.10 – Selecting the color black in the Color Picker window ](img/Figure_8.10_B18531.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – 在颜色选择器窗口中选择黑色](img/Figure_8.10_B18531.jpg)'
- en: Figure 8.10 – Selecting the color black in the Color Picker window
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 在颜色选择器窗口中选择黑色
- en: 'After these changes, this is what the button should look like:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过这些更改后，按钮应该看起来是这样的：
- en: '![Figure 8.11 – The Button element after we change the Text element’s Text
    property and its color ](img/Figure_8.11_B18531.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 改变文本元素的文本属性及其颜色后的按钮元素](img/Figure_8.11_B18531.jpg)'
- en: Figure 8.11 – The Button element after we change the Text element’s Text property
    and its color
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 改变文本元素的文本属性及其颜色后的按钮元素
- en: And with that, we conclude our first exercise of this chapter. You now know
    some of the essential basics of UMG, such as how to add `Button` and `Text` elements
    to your widgets.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了本章的第一个练习。您现在已经了解了一些UMG的基本知识，例如如何将`按钮`和`文本`元素添加到您的组件中。
- en: Before we jump into our next exercise, first, let’s learn about anchors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行下一个练习之前，首先，让我们来了解一下锚点。
- en: Introducing anchors
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍锚点
- en: As you might be aware, video games are played on many different screen sizes
    with many different resolutions. Because of that, it is important to make sure
    that the menus you create can adapt to all these different resolutions effectively.
    That is the main purpose of **Anchors**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，视频游戏可以在许多不同尺寸和分辨率的屏幕上玩。因此，确保您创建的菜单可以有效地适应所有这些不同的分辨率非常重要。这就是**锚点**的主要目的。
- en: Anchors allow you to specify how you want a UI element’s size to adapt as the
    screen resolution changes by specifying the proportion of the screen you want
    it to occupy. Using anchors, you can always have a UI element in the upper-left
    corner of the screen, or always occupying half of the screen, no matter the size
    and resolution of that screen.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点允许您通过指定屏幕所占比例来指定UI元素的大小如何适应屏幕分辨率的改变。使用锚点，您可以始终使UI元素位于屏幕的左上角，或者始终占据屏幕的一半，无论屏幕的大小和分辨率如何。
- en: 'As the size of the screen or resolution changes, your widget will scale and
    move relative to its anchor. Only elements that are direct children of a `Canvas
    Panel` element can have an anchor, which you can visualize through the `Designer`
    tab) when you select said element:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕大小或分辨率改变时，您的小部件将相对于其锚点进行缩放和移动。只有`Canvas Panel`元素的直接子元素才能有锚点，您可以通过`设计师`选项卡中的`锚点`可视化（当选择该元素时）：
- en: '![Figure 8.12 – The Anchor Medallion in the upper-left corner of the outline,
    as shown in the Designer window ](img/Figure_8.12_B18531.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – 如设计师窗口中所示，轮廓左上角的锚定奖牌](img/Figure_8.12_B18531.jpg)'
- en: Figure 8.12 – The Anchor Medallion in the upper-left corner of the outline,
    as shown in the Designer window
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 如设计师窗口中所示，轮廓左上角的锚定奖牌
- en: By default, the anchor is collapsed into the upper-left corner, which means
    that you won’t have much control over how the button is scaled as the resolution
    changes. Let’s change that in the next exercise.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，锚点折叠到左上角，这意味着当分辨率变化时，你将无法对按钮的缩放进行太多控制。让我们在下一个练习中改变这一点。
- en: Exercise 8.02 – editing UMG anchors
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.02 – 编辑 UMG 锚点
- en: In this exercise, we will be changing the anchors in our widget in order to
    have our button’s size and shape adapt to a wide range of screen resolutions and
    sizes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将更改小部件中的锚点，以便按钮的大小和形状能够适应广泛的屏幕分辨率和尺寸。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Select the button we created in the previous exercise. Then, head to the `Anchor`
    presets, which will align the UI element according to the pivots shown.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择上一个练习中创建的按钮。然后，转到 `Anchor` 预设，这将根据显示的轴心对齐 UI 元素。
- en: We’ll want to have our button centered on the screen.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望按钮位于屏幕中心。
- en: 'Click on the pivot that’s at the center of the screen:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕中心的轴心：
- en: '![Figure 8.13 – The button’s Anchors property, with the center Anchor preset
    outlined in a box ](img/Figure_8.13_B18531.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 – 按钮的锚点属性，中心锚点预设用框突出显示](img/Figure_8.13_B18531.jpg)'
- en: Figure 8.13 – The button’s Anchors property, with the center Anchor preset outlined
    in a box
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 按钮的锚点属性，中心锚点预设用框突出显示
- en: 'You’ll see that our Anchor Medallion has now changed places:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我们的锚定奖牌现在已经改变了位置：
- en: '![Figure 8.14 – The Anchor Medallion after we change the button’s Anchor property
    to the center ](img/Figure_8.14_B18531.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.14 – 我们将按钮的锚点属性更改为中心后，锚定奖牌](img/Figure_8.14_B18531.jpg)'
- en: Figure 8.14 – The Anchor Medallion after we change the button’s Anchor property
    to the center
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – 我们将按钮的锚点属性更改为中心后，锚定奖牌
- en: Now that the Anchor Medallion is at the center of the screen, we still won’t
    have much control over how the button will scale across different resolutions,
    but at least we know that it’ll scale relative to the center of the screen.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，锚定奖牌位于屏幕中心，我们仍然无法对按钮在不同分辨率下的缩放进行太多控制，但至少我们知道它将相对于屏幕中心进行缩放。
- en: In order to have our button centered on the screen, we’ll have to change the
    button’s position to be at the center of the screen, too.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使按钮居中在屏幕上，我们必须将按钮的位置也移动到屏幕中心。
- en: 'Repeat the previous step of picking the center anchor, but this time, before
    you select it, hold the *Ctrl* key in order to snap the button’s position to this
    anchor. After you click on it, release the *Ctrl* key. You should see a result
    similar to the following screenshot:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复先前的步骤选择中心锚点，但这次，在您选择它之前，请按住 *Ctrl* 键以将按钮的位置固定到该锚点。点击后，释放 *Ctrl* 键。你应该会看到类似于以下截图的结果：
- en: '![Figure 8.15 – The Button element being moved near its selected anchor in
    the center ](img/Figure_8.15_B18531.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.15 – 按钮元素被移动到其选定的中心锚点附近](img/Figure_8.15_B18531.jpg)'
- en: Figure 8.15 – The Button element being moved near its selected anchor in the
    center
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – 按钮元素被移动到其选定的中心锚点附近
- en: As you can see from the preceding screenshot, our button has changed position,
    but it isn’t properly centered on the screen yet. That is because of its alignment.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们的按钮已经改变了位置，但还没有正确居中在屏幕上。这是因为其对齐方式。
- en: 'The `Alignment` property is of the `Vector2D` type (a tuple with two `float`
    properties: `X` and `Y`) and dictates the center of the UI element relative to
    its total size. By default, it’s set to `(0,0)`, meaning the center of the element
    is its upper-left corner, which explains the result in the preceding screenshot.
    It can go all the way to `(1,1)`, which is the lower-right corner. In this case,
    given that we want the alignment to center the button, we want it to be `(0.5,
    0.5)`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Alignment` 属性是 `Vector2D` 类型（一个包含两个 `float` 属性的元组：`X` 和 `Y`），它决定了 UI 元素相对于其总大小的中心。默认情况下，它设置为
    `(0,0)`，这意味着元素的中心是其左上角，这解释了前面的截图中的结果。它可以一直延伸到 `(1,1)`，即右下角。在这种情况下，由于我们希望对齐以居中按钮，我们希望它为
    `(0.5, 0.5)`。'
- en: 'In order to update a UI element’s alignment when picking an `Anchor` point,
    you have to hold the *Shift* key and repeat the previous step. Alternately, to
    update both the position and the alignment of the button, picking the center `Anchor`
    point while holding both the *Ctrl* and *Shift* keys will do the job. The following
    screenshot should then be the result:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在选取“锚点”时更新 UI 元素的对齐方式，您必须按住 *Shift* 键并重复上一步。或者，为了同时更新按钮的位置和对齐方式，在按住 *Ctrl*
    和 *Shift* 键的同时选择中心“锚点”即可完成任务。接下来的截图将是结果：
- en: '![Figure 8.16 – The Button element being centered relative to its selected
    Anchor point in the center ](img/Figure_8.16_B18531.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.16 – 按钮元素相对于其选定的中心锚点居中](img/Figure_8.16_B18531.jpg)'
- en: Figure 8.16 – The Button element being centered relative to its selected Anchor
    point in the center
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 按钮元素相对于其选定的中心锚点居中
- en: At this point, when changing the resolution of the screen, we know that this
    button will always remain at the center of the screen. However, in order to maintain
    the button’s size relative to the resolution, we’ll need to make a few more modifications.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，当更改屏幕分辨率时，我们知道这个按钮将始终保持在屏幕中心。然而，为了保持按钮相对于分辨率的大小，我们还需要进行一些修改。
- en: 'Drag the lower-right *petal* of the Anchor Medallion all the way to the lower-right
    corner of the button:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将锚章的右下 *花瓣* 拖动到按钮的右下角：
- en: '![Figure 8.17 – Dragging the lower-right petal of the Anchor Medallion to update
    the Button element’s Anchor point ](img/Figure_8.17_B18531.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.17 – 拖动锚章的右下角以更新按钮元素的锚点](img/Figure_8.17_B18531.jpg)'
- en: Figure 8.17 – Dragging the lower-right petal of the Anchor Medallion to update
    the Button element’s Anchor point
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – 拖动锚章的右下角以更新按钮元素的锚点
- en: 'Drag the upper-left *petal* of the Anchor Medallion all the way to the upper-left
    corner of the button:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将锚章的左上 *花瓣* 拖动到按钮的左上角：
- en: '![Figure 8.18 – Dragging the upper-left petal of the Anchor Medallion to update
    the Button element’s Anchor ](img/Figure_8.18_B18531.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.18 – 拖动锚章的左上角以更新按钮元素的锚点](img/Figure_8.18_B18531.jpg)'
- en: Figure 8.18 – Dragging the upper-left petal of the Anchor Medallion to update
    the Button element’s Anchor
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – 拖动锚章的左上角以更新按钮元素的锚点
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The percentages you see around the button when changing the `Anchor` point are
    the space the element is occupying on the screen, shown as a percentage. For instance,
    looking at the preceding screenshot, we can see that the button is occupying `11.9%`
    of the widget’s space on the *X* coordinate and `8.4%` of the widget’s space on
    the *Y* coordinate.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改“锚点”时，您在按钮周围看到的百分比是元素在屏幕上占用的空间，以百分比表示。例如，查看前面的截图，我们可以看到按钮在 *X* 坐标上占用了小部件空间的
    `11.9%`，在 *Y* 坐标上占用了小部件空间的 `8.4%`。
- en: You can set the size of a UI element to the size of its anchor by holding the
    *Ctrl* key while moving the Anchor Medallion *petals*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在移动锚章 *花瓣* 时按住 *Ctrl* 键来设置 UI 元素的大小为其锚点的大小。
- en: Now our button will, finally, adapt to varying screen sizes and resolutions
    due to these changes to its anchor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的按钮将最终适应不同的屏幕尺寸和分辨率，因为这些对其锚点的更改。
- en: 'Additionally, you can use the `Details` panel to manually edit all of the properties
    we just edited by using the Anchor Medallion and moving the button:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用“详细信息”面板手动编辑我们刚刚使用锚章和移动按钮所编辑的所有属性：
- en: '![Figure 8.19 – The properties we changed using the Anchor Medallion, as shown
    in the Details window ](img/Figure_8.19_B18531.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.19 – 使用锚章更改的属性，如图所示在详细信息窗口中](img/Figure_8.19_B18531.jpg)'
- en: Figure 8.19 – The properties we changed using the Anchor Medallion, as shown
    in the Details window
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 – 使用锚章更改的属性，如图所示在详细信息窗口中
- en: Lastly, we need to know how we can visualize our widget with different resolutions
    in the `Designer` tab.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要了解如何在“设计器”选项卡中用不同的分辨率可视化我们的小部件。
- en: 'Drag the double arrow in the lower-right corner of the outlined box inside
    the `Designer` tab:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“设计器”选项卡内，拖动轮廓框右下角的双向箭头：
- en: '![Figure 8.20 – The double arrow in the lower-right corner of the outlined
    box inside the Designer tab ](img/Figure_8.20_B18531.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.20 – 设计器选项卡内轮廓框右下角的双向箭头](img/Figure_8.20_B18531.jpg)'
- en: Figure 8.20 – The double arrow in the lower-right corner of the outlined box
    inside the Designer tab
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 – 设计器选项卡内轮廓框右下角的双向箭头
- en: 'By dragging the double arrow, you can resize the canvas to any screen resolution
    you want. In the following screenshot, you’ll see the most used resolutions for
    a variety of devices, and you can preview your widget in each of them:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拖动双箭头，你可以将画布调整到你想要的任何屏幕分辨率。在下面的屏幕截图中，你会看到各种设备最常用的分辨率，并且可以在每个分辨率中预览你的widget：
- en: '![Figure 8.21 – The resolutions we can choose to preview in the Designer window
    ](img/Figure_8.21_B18531.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图8.21 – 我们可以在设计器窗口中预览的分辨率](img/Figure_8.21_B18531.jpg)'
- en: Figure 8.21 – The resolutions we can choose to preview in the Designer window
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 我们可以在设计器窗口中预览的分辨率
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find a full reference to UMG’s anchors at [https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors)找到UMG锚点的完整参考。
- en: And that concludes our exercise. You’ve learned about anchors and how to adapt
    your widgets to varying screen sizes and resolutions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的练习就结束了。你已经了解了锚点以及如何使你的widget适应不同的屏幕尺寸和分辨率。
- en: Now that we’ve learned about some of the basics of UMG, let’s see how we can
    create a widget C++ class for this Widget Blueprint. That is what we’re going
    to do in the next exercise.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些UMG的基本知识，让我们看看我们如何为这个Widget蓝图创建一个widget C++类。这就是我们将在下一个练习中要做的。
- en: Exercise 8.03 – creating the RestartWidget C++ class
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.03 – 创建RestartWidget C++类
- en: In this exercise, we will learn how to create a widget C++ class, which the
    Widget Blueprint that we created will inherit from. It will get added to the screen
    when the player dies in our **Dodgeball** game so that the player can have the
    option to restart the level. This widget will have a button that will restart
    the level when the player clicks on it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何创建一个widget C++类，这个类将是我们创建的Widget蓝图所继承的。当玩家在我们的**躲避球**游戏中死亡时，它将被添加到屏幕上，以便玩家可以选择重新开始关卡。这个widget将有一个按钮，当玩家点击它时，将重新开始关卡。
- en: The first step of this exercise will be adding the UMG-related modules to our
    project. Unreal Engine comprises several different modules, and in each project,
    you have to specify which ones you’re going to use. Our project came with a few
    general modules when the source code files were generated, but we’ll need to add
    a few more.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的第一步是将与UMG相关的模块添加到我们的项目中。虚幻引擎包含几个不同的模块，在每一个项目中，你必须指定你打算使用哪些模块。当生成源代码文件时，我们的项目附带了一些通用模块，但我们需要添加更多。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: Open the `Dodgeball.build.cs` file, which is a C# file and not a C++ file, located
    inside your project’s `Source` folder.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于项目`Source`文件夹中的`Dodgeball.build.cs`文件，这是一个C#文件，而不是C++文件。
- en: 'Open the file, and you’ll find the `AddRange` function from the `PublicDependency
    ModuleNames` property being called. This is the function that tells the engine
    which modules this project intends to use. As a parameter, an array of strings
    is sent, with the names of all the intended modules for the project. Given that
    we intend on using UMG, we’ll need to add the UMG-related modules: `UMG`, `Slate`,
    and `SlateCore`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件，你会找到从`PublicDependency ModuleNames`属性调用的`AddRange`函数。这个函数告诉引擎该项目打算使用哪些模块。作为一个参数，发送一个字符串数组，包含项目所有打算使用的模块的名称。鉴于我们打算使用UMG，我们需要添加与UMG相关的模块：`UMG`、`Slate`和`SlateCore`：
- en: '[PRE0]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we’ve notified the engine that we’ll be using the UMG modules, let’s
    create our widget C++ class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通知引擎我们将使用UMG模块，让我们创建我们的widget C++类：
- en: Open the Unreal Editor interface.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开虚幻编辑器界面。
- en: Right-click on the **Content Browser** section and select **New C++ Class**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**内容浏览器**部分，并选择**新建C++类**。
- en: Set the **Show All Classes** checkbox to **true**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**显示所有类**复选框设置为**true**。
- en: Search for the `UserWidget` class and choose that as the new class’s parent
    class.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`UserWidget`类，并将其作为新类的父类选择。
- en: Name the new C++ class `RestartWidget`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的C++类命名为`RestartWidget`。
- en: After the files have been opened in Visual Studio, start making modifications
    to our widget C++ class, as mentioned in the next steps.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开文件后，按照以下步骤开始修改我们的widget C++类。
- en: 'The first thing we’ll add to this class is a `public` `class UButton*` property,
    called `RestartButton`, which represents the button the player will press in order
    to restart the level. You will want it to be bound to a button in the blueprint
    class that inherits from this class, by using the `UPROPERTY` macro with the `BindWidget`
    meta tag. This will force that Widget Blueprint to have a `Button` element, called
    `RestartButton`, that we can access in C++ through this property and then freely
    edit its properties, such as its size and position, in the blueprint:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先添加到这个类的一个`public` `class UButton*`属性，称为`RestartButton`，它代表玩家将按下的按钮以重新启动级别。你希望它通过使用带有`BindWidget`元标签的`UPROPERTY`宏绑定到继承自这个类的蓝图类中的一个按钮，这将强制Widget蓝图具有一个名为`RestartButton`的`Button`元素，我们可以通过这个属性在C++中访问它，然后自由编辑其属性，如大小和位置，在蓝图中进行编辑：
- en: '[PRE1]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Using the `BindWidget` meta tag will cause a compilation error if the Widget
    Blueprint that inherits from this C++ class doesn’t have an element with the same
    type and name. If you don’t want this to happen, you will have to mark `UPROPERTY`
    as an optional `BindWidget` like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BindWidget`元标签，如果继承自这个C++类的Widget蓝图没有具有相同类型和名称的元素，将会导致编译错误。如果你不希望发生这种情况，你必须将`UPROPERTY`标记为可选的`BindWidget`，如下所示：
- en: '`UPROPERTY(meta = (BindWidget, OptionalWidget = true))`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPROPERTY(meta = (BindWidget, OptionalWidget = true))`'
- en: This will make it so that binding this property is optional and doesn’t cause
    a compilation error when compiling the Widget Blueprint.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将使得绑定此属性是可选的，并且在编译Widget蓝图时不会导致编译错误。
- en: Next, we’re going to add the function that will be called when the player clicks
    on the `RestartButton` property, which will restart the level. We will be doing
    this using the `GameplayStatics` object’s `OpenLevel` function and then sending
    the name of the current level.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个函数，当玩家点击`RestartButton`属性时将被调用，这将重新启动级别。我们将使用`GameplayStatics`对象的`OpenLevel`函数，然后发送当前级别的名称。
- en: 'In the widget class’s header file, add a declaration for a `protected` function
    called `OnRestartClicked` that returns nothing and receives no parameters. This
    function must be marked as `UFUNCTION`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在小部件类的头文件中，添加一个名为`OnRestartClicked`的`protected`函数的声明，该函数不返回任何内容，也不接收任何参数。这个函数必须标记为`UFUNCTION`：
- en: '[PRE2]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the class’s source file, add an `include` for the `GameplayStatics` object:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中，添加对`GameplayStatics`对象的`include`：
- en: '[PRE3]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, add an implementation for our `OnRestartClicked` function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为我们的`OnRestartClicked`函数添加一个实现：
- en: '[PRE4]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside this implementation, call the `GameplayStatics` object’s `OpenLevel`
    function. This function receives, as parameters, a world context object, which
    will be the `this` pointer, and the name of the level, which we’ll have to fetch
    using the `GameplayStatics` object’s `GetCurrentLevelName` function. Additionally,
    this last function must receive a world context object, which will also be the
    `this` pointer:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个实现内部，调用`GameplayStatics`对象的`OpenLevel`函数。这个函数接收一个世界上下文对象作为参数，这将是指针`this`，以及级别的名称，我们将使用`GameplayStatics`对象的`GetCurrentLevelName`函数来获取。此外，这个最后的函数也必须接收一个世界上下文对象，这也会是指针`this`：
- en: '[PRE5]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The call to the `GameplayStatics` object’s `GetCurrentLevelName` function must
    be preceded with `*` because it returns an `FString` type, UE5’s string type,
    and must be dereferenced in order to be passed to the `FName` constructor.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`GameplayStatics`对象`GetCurrentLevelName`函数之前必须加上`*`，因为它返回一个`FString`类型，UE5的字符串类型，并且必须解引用才能传递给`FName`构造函数。
- en: 'The next step will be to bind this function in such a way that it is called
    when the player presses the `RestartButton` property:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是将此函数绑定，以便在玩家按下`RestartButton`属性时调用：
- en: 'In order to do this, we’ll have to override a function that belongs to the
    `UserWidget` class, called `NativeOnInitialized`. This function is only called
    once, similarly to the actor’s `BeginPlay` function, which makes it appropriate
    to do our setup. Add a declaration for the `public` `NativeOnInitialized` function
    with both the `virtual` and `override` keywords in our widget class’s header file:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们不得不覆盖属于`UserWidget`类的一个函数，名为`NativeOnInitialized`。这个函数只调用一次，类似于演员的`BeginPlay`函数，这使得它适合进行我们的设置。在我们的小部件类头文件中添加一个`public`
    `NativeOnInitialized`函数的声明，并使用`virtual`和`override`关键字：
- en: '[PRE6]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, in the class’s source file, add the implementation of this function.
    Inside it, call its `Super` function and add an `if` statement that checks whether
    our `RestartButton` property is different from `nullptr`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在类的源文件中，添加此函数的实现。在其内部，调用其`Super`函数并添加一个`if`语句，检查我们的`RestartButton`属性是否与`nullptr`不同：
- en: '[PRE7]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the `if` statement is true, we’ll want to bind our `OnRestartClicked` function
    to the button’s `OnClicked` event. We can do this by accessing the button’s `OnClicked`
    property and calling its `AddDynamic` function. This sends, as parameters, the
    object we want to call that function on, the `this` pointer, and a pointer to
    the function to be called, that is, the `OnRestartClicked` function:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`if`语句为真，我们将想要将我们的`OnRestartClicked`函数绑定到按钮的`OnClicked`事件。我们可以通过访问按钮的`OnClicked`属性并调用其`AddDynamic`函数来实现这一点。这会将我们想要调用该函数的对象、`this`指针以及要调用的函数的指针（即`OnRestartClicked`函数）作为参数发送：
- en: '[PRE8]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because we’re accessing functions related to the `Button` class, we’ll also
    have to include it:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们要访问与`Button`类相关的函数，所以我们还需要包含它：
- en: '[PRE9]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A button’s `OnClicked` event will be called when the player presses and releases
    that button with the mouse. There are other events related to the button, including
    the `OnPressed` event (when the player presses the button), the `OnReleased` event
    (when the player releases the button), and the `OnHover` and `OnUnhover` events
    (when the player, respectively, starts and stops hovering the mouse over that
    button).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下并释放鼠标按钮时，将调用按钮的`OnClicked`事件。还有其他与按钮相关的事件，包括`OnPressed`事件（当玩家按下按钮时），`OnReleased`事件（当玩家释放按钮时），以及`OnHover`和`OnUnhover`事件（当玩家分别开始和停止将鼠标悬停在按钮上时）。
- en: The `AddDynamic` function must receive, as a parameter, a pointer to a function
    marked with the `UFUNCTION` macro. If it doesn’t, you will get an error when calling
    that function. This is why we marked the `OnRestartClicked` function with the
    `UFUNCTION` macro.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDynamic`函数必须接收一个参数，该参数是一个带有`UFUNCTION`宏标记的函数的指针。如果不是这样，调用该函数时将出现错误。这就是为什么我们用`UFUNCTION`宏标记了`OnRestartClicked`函数。'
- en: After you’ve done these steps, compile your changes and open the editor.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，编译你的更改并打开编辑器。
- en: Open the `TestWidget` Widget Blueprint that you created earlier. We’ll want
    to associate this Widget Blueprint with the `RestartWidget` class we just created,
    so we need to reparent it.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你之前创建的`TestWidget` Widget蓝图。我们想要将此Widget蓝图与刚刚创建的`RestartWidget`类关联起来，因此我们需要将其重置父类。
- en: 'From the Widget Blueprint’s `RestartWidget` C++ class as its new parent class:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Widget蓝图的新父类`RestartWidget`的C++类：
- en: '![Figure 8.22 – Reparenting the TestWidget’s class to RestartWidget ](img/Figure_8.22_B18531.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图8.22 – 将TestWidget的类重置为RestartWidget](img/Figure_8.22_B18531.jpg)'
- en: Figure 8.22 – Reparenting the TestWidget’s class to RestartWidget
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 将TestWidget的类重置为RestartWidget
- en: 'You’ll notice that the Widget Blueprint now has a compilation error related
    to the `BindWidget` meta tag that we created in the C++ class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，Widget蓝图现在有一个与我们在C++类中创建的`BindWidget`元标签相关的编译错误：
- en: '![Figure 8.23 – Compiler errors after setting the parent class to the RestartWidget
    class ](img/Figure_8.23_B18531.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图8.23 – 将父类设置为RestartWidget类后的编译错误](img/Figure_8.23_B18531.jpg)'
- en: Figure 8.23 – Compiler errors after setting the parent class to the RestartWidget
    class
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – 将父类设置为RestartWidget类后的编译错误
- en: This is caused by the fact that the C++ class couldn’t find a `Button` property
    called `RestartButton`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为C++类找不到名为`RestartButton`的`Button`属性。
- en: 'In order to fix this, we’ll need to rename our `Button` element inside the
    Widget Blueprint to `RestartButton`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，我们需要将Widget蓝图中的`Button`元素重命名为`RestartButton`：
- en: '![Figure 8.24 – Renaming the Button element to RestartButton ](img/Figure_8.24_B18531.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图8.24 – 将Button元素重命名为RestartButton](img/Figure_8.24_B18531.jpg)'
- en: Figure 8.24 – Renaming the Button element to RestartButton
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 – 将Button元素重命名为RestartButton
- en: After you’ve done this, close the Widget Blueprint and change its name from
    `TestWidget` to `BP_RestartWidget`, the same way you just did in the previous
    step.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，关闭Widget蓝图，并将其名称从`TestWidget`更改为`BP_RestartWidget`，就像你在上一步中做的那样。
- en: That concludes the creation of our widget class. Now, you understand how to
    connect a widget C++ class to a Widget Blueprint, which is a very important step
    toward handling game UI in UE5.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的widget类的创建。现在，你理解了如何将widget C++类连接到Widget蓝图，这是处理UE5游戏UI的重要一步。
- en: The next thing we need to do is create our `Player Controller` C++ class, which
    will be responsible for instantiating our `RestartWidget` class and adding it
    to the screen. We will be doing this in the following exercise.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是创建我们的`Player Controller` C++类，它将负责实例化我们的`RestartWidget`类并将其添加到屏幕上。我们将在以下练习中完成这项工作。
- en: Exercise 8.04 – creating the logic for adding the RestartWidget class to the
    screen
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.04 – 创建将RestartWidget类添加到屏幕的逻辑
- en: In this exercise, we will create the logic responsible for adding our newly
    created `RestartWidget` class to the screen. It will appear on the screen when
    the player dies so that they have the option to restart the level.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建负责将我们新创建的`RestartWidget`类添加到屏幕上的逻辑。当玩家死亡时，它将出现在屏幕上，以便他们有重新开始关卡的选择。
- en: 'In order to do this, we’ll have to create a new `Player Controller` C++ class,
    which you can do by following these steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要创建一个新的`Player Controller` C++类，您可以通过以下步骤来完成：
- en: Open the Unreal Editor interface.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Unreal编辑器界面。
- en: '*Right-click* on the `Content Browser` section and select `New C++ Class`.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`部分*右键单击*并选择`New C++ Class`。
- en: Search for the `Player Controller` class and choose that as the new class’s
    parent class.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索中查找`Player Controller`类，并将其作为新类的父类选择。
- en: Name the new C++ class `DodgeballPlayerController`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的C++类命名为`DodgeballPlayerController`。
- en: Open the class’s files in Visual Studio.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开该类的文件。
- en: When our player runs out of health points, the `DodgeballCharacter` class will
    access this `Player Controller` class and call a function that will add the `RestartWidget`
    class to the screen. Follow these next steps in order to make this happen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的玩家耗尽生命值时，`DodgeballCharacter`类将访问这个`Player Controller`类并调用一个函数，该函数将`RestartWidget`类添加到屏幕上。按照以下步骤进行操作以实现这一点。
- en: In order to know the class of the widget to add to the screen (which will be
    a Widget Blueprint asset and not a Widget C++ class), we’ll need to use the `TSubclassOf`
    type.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道要添加到屏幕上的小部件的类（这将是一个Widget Blueprint资产，而不是Widget C++类），我们需要使用`TSubclassOf`类型。
- en: 'In the class’s header file, add a `public` `TSubclassOf<class URestartWidget>`
    property called `BP_RestartWidget`. Be sure to make it a `UPROPERTY` function
    with the `EditDefaultsOnly` tag so that we can edit it in the blueprint class:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的头文件中，添加一个名为`BP_RestartWidget`的`public` `TSubclassOf<class URestartWidget>`属性。确保将其制作成一个带有`EditDefaultsOnly`标记的`UPROPERTY`函数，这样我们就可以在蓝图类中编辑它：
- en: '[PRE10]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In order to instantiate this widget and add it to the screen, we’ll need to
    save a reference to it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实例化这个小部件并将其添加到屏幕上，我们需要保存对其的引用。
- en: 'Add a new `private` variable of the `class URestartWidget*` type and call it
    `RestartWidget`. Be sure to make it a `UPROPERTY` function with no tags:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`private`变量，类型为`class URestartWidget*`，并将其命名为`RestartWidget`。确保将其制作成一个不带标记的`UPROPERTY`函数：
- en: '[PRE11]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although this property isn’t supposed to be editable in a blueprint class, we
    have to make this reference a `UPROPERTY` function; otherwise, the garbage collector
    will destroy the contents of this variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个属性不应该在蓝图类中可编辑，但我们必须将这个引用做成一个`UPROPERTY`函数；否则，垃圾收集器将销毁这个变量的内容。
- en: The next thing we need is a function responsible for adding our widget to the
    screen.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要的是一个负责将我们的小部件添加到屏幕上的函数。
- en: 'Add a declaration for a `public` function that returns nothing and receives
    no parameters, called `ShowRestartWidget`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`ShowRestartWidget`的`public`函数声明，该函数不返回任何内容，也不接收任何参数：
- en: '[PRE12]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, head to our class’s source file. First, add an `include` to the `RestartWidget`
    class:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到我们的类源文件。首先，向`RestartWidget`类添加一个`include`：
- en: '[PRE13]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, add the implementation of our `ShowRestartWidget` function, where we’ll
    start by checking whether our `BP_RestartWidget` variable is not a `nullptr` variable:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加我们的`ShowRestartWidget`函数的实现，我们将首先检查我们的`BP_RestartWidget`变量是否不是一个`nullptr`变量：
- en: '[PRE14]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If that variable is valid (different from `nullptr`), we want to pause the
    game using the `SetPause` function of **Player Controller**. This will ensure
    that the game stops until the player decides to do something (which, in our case,
    will be pressing the button that restarts the level):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该变量有效（不同于`nullptr`），我们想使用**Player Controller**的`SetPause`函数暂停游戏。这将确保游戏停止，直到玩家决定做某事（在我们的情况下，将按下重新开始关卡按钮）：
- en: '[PRE15]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next thing we’ll do is change the input mode. In UE5, there are three input
    modes: `Game Only`, `Game and UI`, and `UI Only`. If your Input mode includes
    `Game`, that means that the player character and the player controller will receive
    inputs through the input actions. If your `Input` mode includes `UI`, that means
    that the widgets that are on the screen will receive inputs from the player. When
    we show this widget on the screen, we won’t want the player character to receive
    any input.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要更改输入模式。在 UE5 中，有三个输入模式：`Game Only`、`Game and UI` 和 `UI Only`。如果你的输入模式包括
    `Game`，这意味着玩家角色和玩家控制器将通过输入动作接收输入。如果你的 `Input` 模式包括 `UI`，这意味着屏幕上的小部件将接收来自玩家的输入。当我们在这个屏幕上显示这个小部件时，我们不想让玩家角色接收任何输入。
- en: 'Hence, update to the `UI Only` `Input` mode. You can do this by calling the
    `Player Controller` `SetInputMode` function and passing the `FInputModeUIOnly`
    type as a parameter:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，更新到 `UI Only` `Input` 模式。你可以通过调用 `Player Controller` 的 `SetInputMode` 函数并将
    `FInputModeUIOnly` 类型作为参数传递来实现这一点：
- en: '[PRE16]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Following this, we want to show the mouse cursor so that the player can see
    which button they are hovering the mouse on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们想要显示鼠标光标，以便玩家可以看到他们正在悬停的按钮。
- en: 'We will do this by setting the `Player Controller` `bShowMouseCursor` property
    to `true`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过将 `Player Controller` 的 `bShowMouseCursor` 属性设置为 `true` 来实现这一点：
- en: '[PRE17]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can actually instantiate our widget using the `Player Controller`’s
    `CreateWidget` function, passing as a template parameter the C++ Widget class,
    which, in our case, is `RestartWidget`. Then, as normal parameters, we will pass
    Owning Player, which is the `Player Controller` class that owns this widget and
    that we’ll send using the `this` pointer, and the widget class, which will be
    our `BP_RestartWidget` property:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `Player Controller` 的 `CreateWidget` 函数实际实例化我们的小部件，将 C++ 小部件类作为模板参数传递，在我们的例子中是
    `RestartWidget`。然后，作为正常参数，我们将传递拥有者玩家，即拥有这个小部件并使用 `this` 指针发送的 `Player Controller`
    类，以及小部件类，这将是我们的 `BP_RestartWidget` 属性：
- en: '[PRE18]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After we instantiate the widget, we’ll want to add it to the screen, using
    the widget’s `AddToViewport` function:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例化小部件后，我们将使用小部件的 `AddToViewport` 函数将其添加到屏幕上：
- en: '[PRE19]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That concludes our `ShowRestartWidget` function. However, we also need to create
    the function that will remove the `RestartWidget` class from the screen. In the
    class’s header file, add a declaration for a function just like the `ShowRestartWidget`
    function, but this time called `HideRestartWidget`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就完成了我们的 `ShowRestartWidget` 函数。然而，我们还需要创建一个函数来从屏幕上移除 `RestartWidget` 类。在类的头文件中，添加一个与
    `ShowRestartWidget` 函数类似的函数声明，但这次命名为 `HideRestartWidget`：
- en: '[PRE20]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the class’s source file, add the implementation for the `HideRestartWidget`
    function:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件中，添加 `HideRestartWidget` 函数的实现：
- en: '[PRE21]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first thing we should do in this function is to remove the widget from
    the screen by calling its `RemoveFromParent` function, and destroy it using the
    `Destruct` function:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们应该做的第一件事是通过调用其 `RemoveFromParent` 函数从小部件上移除它，并使用 `Destruct` 函数销毁它：
- en: '[PRE22]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we want to unpause the game using the `SetPause` function we used in
    the previous function:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们想要使用之前函数中使用的 `SetPause` 函数来暂停游戏：
- en: '[PRE23]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, let’s set the `Input` mode to `Game Only` and hide the mouse cursor
    in the same way we did in the previous function (this time, we pass the `FInputModeGameOnly`
    type instead):'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将输入模式设置为 `Game Only`，并以与之前函数相同的方式隐藏鼠标光标（这次，我们传递的是 `FInputModeGameOnly`
    类型）：
- en: '[PRE24]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And that concludes the logic for our `Player Controller` C++ class. The next
    thing we should do is call the function that will add our widget to the screen.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了 `Player Controller` C++ 类的逻辑。接下来，我们应该调用将小部件添加到屏幕上的函数。
- en: 'Go to the `DodgeballCharacter` class’s source file and add the `include` keyword
    to our newly created `DodgeballPlayerController` class:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `DodgeballCharacter` 类的源文件，并将 `include` 关键字添加到我们新创建的 `DodgeballPlayerController`
    类中：
- en: '[PRE25]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Within the `DodgeballCharacter` class’s implementation of the `OnDeath_Implementation`
    function, replace the call to the `QuitGame` function with the following:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DodgeballCharacter` 类的 `OnDeath_Implementation` 函数实现中，将调用 `QuitGame` 函数替换为以下内容：
- en: 'Get the character’s player controller using the `GetController` function. You’ll
    want to save the result in a variable of the `DodgeballPlayerController*` type,
    called `PlayerController`. Because the function will return a variable of the
    `Controller` type, you’ll also need to cast it to our `PlayerController` class:'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GetController` 函数获取角色的玩家控制器。您需要将结果保存到名为 `PlayerController` 的 `DodgeballPlayerController*`
    类型的变量中，因为该函数将返回 `Controller` 类型的变量，所以您还需要将其转换为我们的 `PlayerController` 类：
- en: '[PRE26]'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Check whether the `PlayerController` variable is valid. If it is, call its
    `ShowRestartWidget` function:'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 `PlayerController` 变量是否有效。如果是，调用其 `ShowRestartWidget` 函数：
- en: '[PRE27]'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After these modifications, the last thing left for us to do is to call the function
    that will hide our widget from the screen. Open the `RestartWidget` class’s source
    file and implement the following modifications.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些修改之后，我们最后要做的就是调用一个函数，该函数将隐藏我们的小部件。打开 `RestartWidget` 类的源文件并实现以下修改。
- en: 'Add an `include` to the `DodgeballPlayerController` class, which contains the
    function that we will be calling:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `DodgeballPlayerController` 类添加一个 `include`，其中包含我们将要调用的函数：
- en: '[PRE28]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside the `OnRestartClicked` function implementation, before the call to the
    `OpenLevel` function, we must fetch the widget’s `OwningPlayer`, which is of the
    `PlayerController` type, using the `GetOwningPlayer` function, and cast it to
    the `DodgeballPlayerController` class:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnRestartClicked` 函数实现中，在调用 `OpenLevel` 函数之前，我们必须使用 `GetOwningPlayer` 函数获取小部件的
    `OwningPlayer`，它属于 `PlayerController` 类型，并将其转换为 `DodgeballPlayerController` 类：
- en: '[PRE29]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, if the `PlayerController` variable is valid, we call its `HideRestartWidget`
    function:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果 `PlayerController` 变量有效，我们调用其 `HideRestartWidget` 函数：
- en: '[PRE30]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After you’ve followed all these steps, close the editor, compile your changes,
    and open the editor again.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些步骤后，关闭编辑器，编译您的更改，然后再次打开编辑器。
- en: You have now concluded this exercise. We have added all the necessary logic
    to add our `RestartWidget` class to the screen. The only thing left for us to
    do is create the blueprint class of our newly created `DodgeballPlayerController`
    class, which we’ll be doing in the next exercise.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经完成了这个练习。我们已经添加了所有必要的逻辑，将我们的 `RestartWidget` 类添加到屏幕上。我们接下来要做的就是创建我们新创建的
    `DodgeballPlayerController` 类的蓝图类，我们将在下一个练习中完成这个任务。
- en: Exercise 8.05 – setting up the DodgeballPlayerController blueprint class
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.05 – 设置 DodgeballPlayerController 蓝图类
- en: In this exercise, we will be creating the blueprint class for `DodgeballPlayerController`
    in order to specify which widget we want to add to the screen. Then, we will tell
    UE5 to use this blueprint class when the game starts.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建 `DodgeballPlayerController` 的蓝图类，以指定我们想要添加到屏幕上的小部件。然后，我们将告诉 UE5
    在游戏开始时使用这个蓝图类。
- en: 'In order to do that, follow these steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请按照以下步骤操作：
- en: Go to the **ThirdPersonCPP -> Blueprints** directory in the **Content Browser**
    section, right-click on it, and create a new blueprint class.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **内容浏览器** 部分的 **ThirdPersonCPP -> Blueprints** 目录中，右键单击它，创建一个新的蓝图类。
- en: Search for the **DodgeballPlayerController** class and select it as the parent
    class.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 **DodgeballPlayerController** 类并将其作为父类选择。
- en: Rename this blueprint class to `BP_DodgeballPlayerController`. After that, open
    this blueprint asset.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个蓝图类重命名为 `BP_DodgeballPlayerController`。之后，打开这个蓝图资产。
- en: Go to its `Class Defaults` tab and set the class’s `BP_RestartWidget` property
    to the `BP_RestartWidget` Widget Blueprint we created.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到其 `Class Defaults` 选项卡，并将类的 `BP_RestartWidget` 属性设置为创建的 `BP_RestartWidget`
    Widget 蓝图。
- en: Now, the only thing left for us to do is to make sure that this `Player Controller`
    blueprint class is being used in the game.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们最后要做的就是确保这个 `Player Controller` 蓝图类在游戏中被使用。
- en: In order to do this, we’ll have to follow a few more steps.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们还需要遵循几个额外的步骤。
- en: Go to the `ThirdPersonCPP` -> `Blueprints` directory in the `DodgeballGameMode`
    class and select it as the parent class. Then, rename this `Blueprint` class to
    `BP_DodgeballGameMode`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ThirdPersonCPP` -> `Blueprints` 目录中的 `DodgeballGameMode` 类中，选择它作为父类。然后，将这个
    `Blueprint` 类重命名为 `BP_DodgeballGameMode`。
- en: This class is responsible for telling the game which classes to use for each
    element of the game, such as which `Player Controller` class to use, among other
    things.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类负责告诉游戏每个游戏元素使用哪些类，例如使用哪个 `Player Controller` 类，以及其他一些内容。
- en: 'Open the asset, go to its `PlayerControllerClass` property to the `BP_DodgeballPlayerController`
    class we just created:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开资产，转到其 `PlayerControllerClass` 属性到我们刚刚创建的 `BP_DodgeballPlayerController` 类：
- en: '![Figure 8.25 – Setting the PlayerControllerClass property to BP_DodgeballPlayerController
    ](img/Figure_8.25_B18531.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图8.25 – 将PlayerControllerClass属性设置为BP_DodgeballPlayerController](img/Figure_8.25_B18531.jpg)'
- en: Figure 8.25 – Setting the PlayerControllerClass property to BP_DodgeballPlayerController
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 – 将PlayerControllerClass属性设置为BP_DodgeballPlayerController
- en: Close the asset and select the **Blueprints** drop-down option inside the editor
    toolbar that is at the top of the **Level Viewport** window. From there, select
    the second **Game Mode** option, inside the **World Override** category (which
    should, currently, be set to **DodgeballGameMode**), **-> Select GameModeBase
    Class -> BP_DodgeballGameMode**. This will tell the editor to use this new **Game
    Mode** option in the current level.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭资产并选择编辑器工具栏顶部的**Blueprints**下拉选项，该工具栏位于**Level Viewport**窗口的顶部。从那里，选择**World
    Override**类别中的第二个**Game Mode**选项（当前应设置为**DodgeballGameMode**），**-> 选择GameModeBase类
    -> BP_DodgeballGameMode**。这将告诉编辑器在当前关卡中使用这个新的**Game Mode**选项。
- en: Note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Additionally, you can set the **Game Mode** option inside the **Project Settings**
    category, which will tell the editor to use that **Game Mode** option on all levels.
    However, if a level overrides this option by setting the **Game Mode** option
    in the **World Override** category, that option will be ignored.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以在**Project Settings**类别中设置**Game Mode**选项，这将告诉编辑器在所有关卡中使用该**Game Mode**选项。然而，如果一个关卡通过在**World
    Override**类别中设置**Game Mode**选项来覆盖此选项，则该选项将被忽略。
- en: 'Now, play the game and let your character get hit by a dodgeball `three` times.
    After the third time, you should see the game get paused and show `BP_RestartWidget`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩一下游戏，让你的角色被躲避球击中`三次`。第三次击中后，你应该看到游戏暂停并显示`BP_RestartWidget`：
- en: '![Figure 8.26 – Our BP_RestartWidget property being added to the screen after
    the player runs out of health points ](img/Figure_8.26_B18531.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图8.26 – 玩家耗尽健康点数后，我们的BP_RestartWidget属性被添加到屏幕上](img/Figure_8.26_B18531.jpg)'
- en: Figure 8.26 – Our BP_RestartWidget property being added to the screen after
    the player runs out of health points
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26 – 玩家耗尽健康点数后，我们的BP_RestartWidget属性被添加到屏幕上
- en: 'And when you click on `Button 1` using your mouse, you should see the level
    reset to its initial state:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用鼠标点击`按钮1`时，你应该看到关卡重置到其初始状态：
- en: '![Figure 8.27 – The level restarts after the player presses the button shown
    in the previous screenshot ](img/Figure_8.27_B18531.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图8.27 – 玩家按下前一个屏幕截图中的按钮后关卡重新开始](img/Figure_8.27_B18531.jpg)'
- en: Figure 8.27 – The level restarts after the player presses the button shown in
    the previous screenshot
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27 – 玩家按下前一个屏幕截图中的按钮后关卡重新开始
- en: And that concludes our exercise. Now you know how to create widgets and show
    them in your game. This is another crucial step in your journey toward becoming
    a skilled game developer.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的练习就结束了。现在你知道了如何创建小部件并在游戏中显示它们。这是你成为熟练游戏开发者旅程中的另一个关键步骤。
- en: Before we move on to the next exercise, in the next section, let’s take a look
    at progress bars.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节练习之前，让我们先看看进度条。
- en: Understanding progress bars
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解进度条
- en: One of the ways that video games can represent character stats such as health,
    stamina, and more is through **Progress Bars**, which are what we’ll use to communicate
    to the player how much health their character has. Essentially, progress bars
    are a shape, usually rectangular, that can be filled and emptied in order to show
    the player how a specific stat is progressing. If you want to show the player
    that their character’s health is only half its maximum value, you could do this
    by showing the progress bar as half full. In this section, that is exactly what
    we’ll be doing. This progress bar will be the only element in our **Dodgeball**
    game’s HUD.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏可以通过**进度条**来表示角色统计数据，如健康、耐力等，这是我们用来向玩家传达角色健康值的方法。本质上，进度条是一个形状，通常是矩形，可以通过填充和清空来显示玩家特定统计数据的变化。如果你想向玩家显示角色的健康值只有最大值的一半，你可以通过显示进度条为半满来实现。在本节中，这正是我们将要做的。这个进度条将是我们的**躲避球**游戏HUD中的唯一元素。
- en: In order to create this `ThirdPersonCPP` -> `Blueprints` directory inside the
    `Widget Blueprint` class from the `User Interface` category. Then, select `BP_HUDWidget`.
    After that, open the new Widget Blueprint.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`User Interface`类中的`Widget Blueprint`类别内创建`ThirdPersonCPP` -> `Blueprints`目录。然后，选择`BP_HUDWidget`。之后，打开新的Widget
    Blueprint。
- en: Add a `Canvas Panel` element to the root of this widget, just like we did in
    *step 6* of *Exercise 8.01 – improving the RestartWidget class*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Canvas Panel`元素添加到该小部件的根目录，就像我们在*练习8.01 – 改进RestartWidget类*中的第6步所做的那样。
- en: 'In UE5, progress bars are just another UI element, such as `Button` elements
    and `Text` elements, which means we can drag them from the **Palette** tab into
    our **Designer** tab. Take a look at the following example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE5中，进度条只是另一个UI元素，例如`Button`元素和`Text`元素，这意味着我们可以从**调色板**选项卡将它们拖动到我们的**设计器**选项卡。看看以下示例：
- en: '![Figure 8.28 – Dragging a Progress Bar element into the Designer window ](img/Figure_8.28_B18531.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图8.28 – 将进度条元素拖动到设计器窗口中](img/Figure_8.28_B18531.jpg)'
- en: Figure 8.28 – Dragging a Progress Bar element into the Designer window
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28 – 将进度条元素拖动到设计器窗口中
- en: 'At first, this progress bar might look similar to a button; however, it contains
    two specific properties that are important for a progress bar:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，这个进度条可能看起来像按钮；然而，它包含两个对进度条很重要的特定属性：
- en: '`0` to `1`.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`到`1`。'
- en: '**Bar Fill Type** – This allows you to specify how you want this progress bar
    to fill (from left to right, top to bottom, and so on):'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条形填充类型** – 这允许你指定你希望此进度条如何填充（从左到右、从上到下等）：'
- en: '![Figure 8.29 – The progress bar’s Percent and Bar Fill Type properties ](img/Figure_8.29_B18531.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图8.29 – 进度条的百分比和条形填充类型属性](img/Figure_8.29_B18531.jpg)'
- en: Figure 8.29 – The progress bar’s Percent and Bar Fill Type properties
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29 – 进度条的百分比和条形填充类型属性
- en: 'If you set the `0.5`, the progress bar will be updated accordingly to fill
    half of its length:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设置为`0.5`，进度条将相应地更新以填充其长度的一半：
- en: '![Figure 8.30 – The progress bar filled halfway to the right ](img/Figure_8.30_B18531.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图8.30 – 进度条填充到右侧的一半](img/Figure_8.30_B18531.jpg)'
- en: Figure 8.30 – The progress bar filled halfway to the right
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.30 – 进度条填充到右侧的一半
- en: Before you continue, set the `1`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，设置`1`。
- en: 'Now, let’s change the progress bar’s color from blue (its default color) to
    red. In order to do this, go to the `RGB(1,0,0)`):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们将进度条的颜色从蓝色（其默认颜色）更改为红色。为了做到这一点，转到`RGB(1,0,0)`):'
- en: '![Figure 8.31 – The progress bar’s color being changed to red ](img/Figure_8.31_B18531.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图8.31 – 进度条的颜色被更改为红色](img/Figure_8.31_B18531.jpg)'
- en: Figure 8.31 – The progress bar’s color being changed to red
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31 – 进度条的颜色被更改为红色
- en: After you’ve done this, your progress bar should now use red as its fill color.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，你的进度条现在应使用红色作为其填充颜色。
- en: 'To conclude our progress bar’s setup, let’s update its position, size, and
    anchors. Follow these steps to achieve this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的进度条设置，让我们更新其位置、大小和锚点。按照以下步骤操作以实现这一点：
- en: In the `X` axis, and `0.083` on the `Y` axis
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`X`轴上，和`Y`轴上的`0.083`
- en: '`0.208` on the `X` axis, and `0.116` on the `Y` axis'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0.208`在`X`轴上，`0.116`在`Y`轴上'
- en: Set the `0`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`0`。
- en: 'Your progress bar should now look like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你的进度条现在应该看起来像这样：
- en: '![Figure 8.32 – The progress bar after all the modifications in this section
    have been completed  ](img/Figure_8.32_B18531.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图8.32 – 完成本节所有修改后的进度条](img/Figure_8.32_B18531.jpg)'
- en: Figure 8.32 – The progress bar after all the modifications in this section have
    been completed
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.32 – 完成本节所有修改后的进度条
- en: And with that, we can conclude the topic of progress bars. Our next step is
    going to be to add all the logic necessary to use this progress bar as a health
    bar, by updating its **Percent** property alongside the player character’s health.
    In the next exercise, we’ll do exactly that.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们可以得出进度条的主题。我们的下一步是添加所有必要的逻辑，以便将此进度条用作生命值条，通过更新其**百分比**属性与玩家角色的生命值一起更新。在下一个练习中，我们将做正是这样的事情。
- en: Exercise 8.06 – creating the health bar C++ logic
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.06 – 创建生命值条的C++逻辑
- en: In this exercise, we will be adding all the necessary C++ logic to update the
    progress bar inside our HUD as the player character’s health changes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将添加所有必要的C++逻辑来更新HUD中的进度条，随着玩家角色的生命值变化。
- en: 'In order to do this, follow these steps:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请按照以下步骤操作：
- en: Open the editor and create a new C++ class that inherits from `UserWidget`,
    similar to how we did in *Exercise 8.03 – creating the RestartWidget C++ class*.
    However, this time, call it `HUDWidget`. This will be the C++ class that will
    be used for our HUD widget.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器并创建一个新的C++类，该类从`UserWidget`继承，类似于我们在*练习8.03 – 创建RestartWidget C++类*中所做的那样。然而，这次，将其命名为`HUDWidget`。这将是我们用于HUD小部件的C++类。
- en: 'In the `HUDWidget` class’s header file, add a new `public` property of the
    `class UProgressBar*` type called `HealthBar`. This type is used to represent
    a progress bar, like the one we created in the previous section, in C++. Be sure
    to declare this property as a `UPROPERTY` function with the `BindWidget` tag:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HUDWidget` 类的头文件中，添加一个新的 `public` 属性，类型为 `class UProgressBar*`，名为 `HealthBar`。这个类型用于在
    C++ 中表示进度条，就像我们在上一节中创建的那样。确保将这个属性声明为带有 `BindWidget` 标签的 `UPROPERTY` 函数：
- en: '[PRE31]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add a declaration for a `public` function, called `UpdateHealthPercent`, which
    returns nothing and receives a `float HealthPercent` property as a parameter.
    This function will be called in order to update the **Percent** property of our
    progress bar:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `UpdateHealthPercent` 的 `public` 函数声明，该函数不返回任何内容，并接收一个 `float HealthPercent`
    属性作为参数。这个函数将被调用来更新我们进度条上的 **Percent** 属性：
- en: '[PRE32]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `HUDWidget` class’s source file, add the implementation for the `UpdateHealthPercent`
    function, which will call the `HealthBar` property’s `SetPercent` function, passing
    the `HealthPercent` property as a parameter:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HUDWidget` 类的源文件中，添加 `UpdateHealthPercent` 函数的实现，该函数将调用 `HealthBar` 属性的 `SetPercent`
    函数，并将 `HealthPercent` 属性作为参数传递：
- en: '[PRE33]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because we’ll be using the `ProgressBar` C++ class, we’ll need to add an `include`
    to it at the top of the class’s source file:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将使用 `ProgressBar` C++ 类，所以需要在类的源文件顶部添加一个 `include`：
- en: '[PRE34]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next step will be to add all the necessary logic to our `Player Controller`
    class, which is responsible for adding the `HUDWidget` class to the screen. Implement
    the following steps in order to achieve this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在我们的 `Player Controller` 类中添加所有必要的逻辑，该类负责将 `HUDWidget` 类添加到屏幕上。按照以下步骤实现：
- en: Inside the `DodgeballPlayerController` class’s header file, add a `public` property
    of the `TSubclassOf<class UHUDWidget>` type, called `BP_HUDWidget`. Be sure to
    mark it as a `UPROPERTY` function with the `EditDefaultsOnly` tag.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DodgeballPlayerController` 类的头文件中，添加一个 `public` 属性，类型为 `TSubclassOf<class
    UHUDWidget>`，名为 `BP_HUDWidget`。确保将其标记为带有 `EditDefaultsOnly` 标签的 `UPROPERTY` 函数。
- en: 'This property will allow us to specify, in the `DodgeballPlayerController`
    blueprint class, which widget we want to use as our HUD:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性将允许我们在 `DodgeballPlayerController` 蓝图类中指定我们想要用作 HUD 的小部件：
- en: '[PRE35]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add another property, this time `private`, of the `class UHUDWidget*` type,
    called `HUDWidget`. Mark it as a `UPROPERTY` function, but without any tags:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个属性，这次是 `private` 的，类型为 `class UHUDWidget*`，名为 `HUDWidget`。将其标记为 `UPROPERTY`
    函数，但不带任何标签：
- en: '[PRE36]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add a `protected` declaration for the `BeginPlay` function, and mark it as
    both `virtual` and `override`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `BeginPlay` 函数添加一个 `protected` 声明，并将其标记为 `virtual` 和 `override`：
- en: '[PRE37]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Add a declaration for a new `public` function, called `UpdateHealthPercent`,
    which returns nothing and receives `float HealthPercent` as a parameter.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为一个新的 `public` 函数添加声明，名为 `UpdateHealthPercent`，该函数不返回任何内容，并接收 `float HealthPercent`
    作为参数。
- en: 'This function will be called by our player character class in order to update
    the health bar in our HUD:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将由我们的玩家角色类调用，以更新我们 HUD 中的健康条：
- en: '[PRE38]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now head over to the `DodgeballPlayerController` class’s source file. Start
    by adding an `include` to our `HUDWidget` class:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到 `DodgeballPlayerController` 类的源文件。首先添加对 `HUDWidget` 类的 `include`：
- en: '[PRE39]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, add the implementation for the `BeginPlay` function, where we’ll start
    by calling the `Super` object’s `BeginPlay` function:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加 `BeginPlay` 函数的实现，我们首先调用 `Super` 对象的 `BeginPlay` 函数：
- en: '[PRE40]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that function call, check whether the `BP_HUDWidget` property is valid.
    If it is, call the `CreateWidget` function with the `UHUDWidget` template parameter
    and pass `Owning Player`, `this`, and the `BP_HUDWidget` widget class, as parameters.
    Be sure to set the `HUDWidget` property to the return value of this function call:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个函数调用之后，检查 `BP_HUDWidget` 属性是否有效。如果是，使用 `UHUDWidget` 模板参数调用 `CreateWidget`
    函数，并传递 `Owning Player`、`this` 和 `BP_HUDWidget` 小部件类作为参数。确保将 `HUDWidget` 属性设置为这个函数调用的返回值：
- en: '[PRE41]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After setting the `HUDWidget` property, call its `AddToViewport` function:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置 `HUDWidget` 属性后，调用其 `AddToViewport` 函数：
- en: '[PRE42]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Lastly, add the implementation for the `UpdateHealthPercent` function, where
    we’ll check whether the `HUDWidget` property is valid. If it is, call its `UpdateHealthPercent`
    function and pass the `HealthPercent` property as a parameter:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加 `UpdateHealthPercent` 函数的实现，我们将检查 `HUDWidget` 属性是否有效。如果是，调用带有 `UHUDWidget`
    模板参数的 `CreateWidget` 函数，并传递 `Owning Player`、`this` 和 `BP_HUDWidget` 小部件类作为参数。确保将
    `HUDWidget` 属性设置为这个函数调用的返回值：
- en: '[PRE43]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we’ve added the logic responsible for adding the HUD to the screen
    and allowing it to be updated, we’ll need to make some modifications to the other
    classes. Follow the next steps in order to do so.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了负责将HUD添加到屏幕并允许其更新的逻辑，我们需要对其他类进行一些修改。按照以下步骤进行操作。
- en: Currently, our `Health` interface, which we created in the previous chapter,
    only has the `OnDeath` event, which is called whenever an object runs out of health
    points. In order to update our health bar every time the player takes damage,
    we need to allow our `HealthInterface` class to notify an object whenever that
    happens.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们在上一章中创建的`Health`接口，只包含`OnDeath`事件，该事件在对象健康点耗尽时被调用。为了在玩家每次受到伤害时更新我们的生命条，我们需要允许我们的`HealthInterface`类在发生这种情况时通知对象。
- en: 'Open the `HealthInterface` class’s header file and add a declaration similar
    to the one we did for the `OnDeath` event in *Exercise 7.04 – creating the HealthInterface
    class*, but this time for the `OnTakeDamage` event. This event will be called
    whenever an object takes damage:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`HealthInterface`类的头文件，并添加一个类似于我们在*练习7.04 – 创建HealthInterface类*中为`OnDeath`事件所做的声明的声明，但这次是为`OnTakeDamage`事件。此事件将在对象受到伤害时被调用：
- en: '[PRE44]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that we have added this event to our `Interface` class, let’s add the logic
    that calls that event: open the `HealthComponent` class’s source file and, inside
    its implementation of the `LoseHealth` function, after subtracting the `Amount`
    property from the `Health` property, check whether the `Owner` implements the
    `Health` interface and, if it does, call its `OnTakeDamage` event. Do this the
    same way we already did later in that same function for our `OnDeath` event, but
    this time, simply change the name of the event to `OnTakeDamage`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将此事件添加到我们的`Interface`类中，让我们添加调用该事件的逻辑：打开`HealthComponent`类的源文件，在其`LoseHealth`函数的实现中，在从`Health`属性中减去`Amount`属性之后，检查`Owner`是否实现了`Health`接口，如果是，则调用其`OnTakeDamage`事件。像我们在该函数中稍后已经做的那样，以相同的方式进行此操作，但这次，只需将事件名称更改为`OnTakeDamage`：
- en: '[PRE45]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because our health bar will require the player character’s health points as
    a percentage, we need to perform the following steps.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的生命条将需要玩家角色的健康点数作为百分比，我们需要执行以下步骤。
- en: 'Add a `public` function to our `HealthComponent` class that returns just that:
    in the `HealthComponent` class’s header file, add a declaration for a `FORCEINLINE`
    function that returns a `float` property. This function should be called `GetHealthPercent`
    and be a `const` function. Its implementation will simply consist of returning
    the `Health` property divided by `100`, which we will assume is the maximum amount
    of health points an object can have in our game:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`HealthComponent`类中添加一个`public`函数，它返回的就是这个：在`HealthComponent`类的头文件中，添加一个声明为`FORCEINLINE`的函数的声明，该函数返回一个`float`属性。这个函数应该被称为`GetHealthPercent`，并且是一个`const`函数。其实现将简单地返回`Health`属性除以`100`，我们假设这是游戏中对象可以拥有的最大健康点数：
- en: '[PRE46]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now go to the `DodgeballCharacter` class’s header file and add a declaration
    for a `public` `virtual` function called `OnTakeDamage_Implementation`, which
    returns nothing and receives no parameters. Mark it as `virtual` and `override`:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到`DodgeballCharacter`类的头文件，并添加一个名为`OnTakeDamage_Implementation`的`public`
    `virtual`函数的声明，该函数不返回任何内容，也不接收任何参数。将其标记为`virtual`和`override`：
- en: '[PRE47]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `DodgeballCharacter` class’s source file, add an implementation for
    the `OnTakeDamage_Implementation` function we just declared. Copy the content
    of the `OnDeath_Implementation` function to this new function’s implementation,
    but make this change: instead of calling the `ShowRestartWidget` function of `PlayerController`,
    call its `UpdateHealthPercent` function, and pass the return value of the `HealthComponent`
    property’s `GetHealthPercent` function as a parameter:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DodgeballCharacter`类的源文件中，为刚刚声明的`OnTakeDamage_Implementation`函数添加一个实现。将`OnDeath_Implementation`函数的内容复制到这个新函数的实现中，但进行以下更改：不是调用`PlayerController`的`ShowRestartWidget`函数，而是调用其`UpdateHealthPercent`函数，并将`HealthComponent`属性`GetHealthPercent`函数的返回值作为参数传递：
- en: '[PRE48]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This concludes this exercise’s code setup. After you’ve done these changes,
    compile your code, open the editor, and perform the following steps.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了这个练习的代码设置。完成这些更改后，编译你的代码，打开编辑器，并执行以下步骤。
- en: Open the `BP_HUDWidget` Widget Blueprint and reparent it to the `HUDWidget`
    class, in the same way you did in *Exercise 8.03 – creating the RestartWidget
    C++ class*.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_HUDWidget` Widget Blueprint，并将其重新父类设置为`HUDWidget`类，就像你在*练习8.03 – 创建RestartWidget
    C++类*中所做的那样。
- en: This should cause a compilation error, which you’ll be able to fix by renaming
    our progress bar element to `HealthBar`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将导致编译错误，你可以通过将我们的进度条元素重命名为 `HealthBar` 来修复它。
- en: 'Close this Widget Blueprint, open the `BP_DodgeballPlayerController` blueprint
    class, and set its `BP_HUDWidget` property to the `BP_HUDWidget` Widget Blueprint:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭此 Widget Blueprint，打开 `BP_DodgeballPlayerController` 蓝图类，并将其 `BP_HUDWidget`
    属性设置为 `BP_HUDWidget` Widget Blueprint：
- en: '![Figure 8.33 – Setting the BP_HUDWidget property to BP_HUDWidget ](img/Figure_8.33_B18531.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.33 – 设置 BP_HUDWidget 属性为 BP_HUDWidget](img/Figure_8.33_B18531.jpg)'
- en: Figure 8.33 – Setting the BP_HUDWidget property to BP_HUDWidget
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.33 – 设置 BP_HUDWidget 属性为 BP_HUDWidget
- en: 'After you’ve done these changes, play the level. You should notice the **Health
    Bar** progress bar in the upper-left corner of the screen:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些更改后，玩这个关卡。你应该注意到屏幕左上角的 **Health Bar** 进度条：
- en: '![Figure 8.34 – The progress bar showing in the upper-left corner of the screen
    ](img/Figure_8.34_B18531.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.34 – 进度条显示在屏幕的左上角](img/Figure_8.34_B18531.jpg)'
- en: Figure 8.34 – The progress bar showing in the upper-left corner of the screen
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.34 – 进度条显示在屏幕的左上角
- en: 'When the player character gets hit by a dodgeball, you should notice the `Health
    Bar` progress bar being emptied:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家角色被躲避球击中时，你应该注意到 `Health Bar` 进度条正在被清空：
- en: '![Figure 8.35 – The progress bar being emptied as the player character loses
    health points ](img/Figure_8.35_B18531.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.35 – 当玩家角色失去生命值时，进度条正在被清空](img/Figure_8.35_B18531.jpg)'
- en: Figure 8.35 – The progress bar being emptied as the player character loses health
    points
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.35 – 当玩家角色失去生命值时，进度条正在被清空
- en: And with that, we conclude this exercise. You’ve learned all the necessary steps
    in order to add a HUD to the screen and update it during the game.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了这个练习。你已经学会了添加 HUD 到屏幕并在游戏过程中更新它的所有必要步骤。
- en: Activity 8.01 – improving the RestartWidget class
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.01 – 改进 RestartWidget 类
- en: In this activity, we will be adding a `RestartWidget` class that reads **Game
    Over** in order for the player to know that they just lost the game; adding an
    **Exit** button, which will allow the player to exit the game; and also updating
    the text of our existing button to **Restart** so that the players know what should
    happen when they click on that button.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将添加一个 `RestartWidget` 类，它读取 **Game Over**，以便玩家知道他们刚刚输掉了游戏；添加一个 **退出**
    按钮，允许玩家退出游戏；并且更新现有按钮的文本为 **重启**，以便玩家知道当他们点击该按钮时会发生什么。
- en: 'The following steps will help you complete this activity:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此活动：
- en: Open the `BP_RestartWidget` Widget Blueprint.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `BP_RestartWidget` Widget Blueprint。
- en: Drag a new `Text` element into the existing `Canvas Panel` element.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的 `Text` 元素拖放到现有的 `Canvas Panel` 元素中。
- en: 'Modify the `Text` element’s properties:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `Text` 元素的属性：
- en: Expand the `0.291` on the `X` axis and `0.115` on the `Y` axis. Then, set its
    `0.708` on the `X` axis and `0.255` on the `Y` axis.
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `X` 轴上展开 `0.291` 和在 `Y` 轴上展开 `0.115`。然后，将其 `X` 轴上的 `0.708` 和 `Y` 轴上的 `0.255`
    设置。
- en: Set the `0`.
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `0`。
- en: Set the `GAME OVER`.
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `GAME OVER`。
- en: Set the `RGBA(1.0, 0.082, 0.082, 1.0)`.
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `RGBA(1.0, 0.082, 0.082, 1.0)`。
- en: Expand the `100`.
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开 `100`。
- en: Set the **Justification** property to **Align Text Center**.
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **对齐方式** 属性设置为 **居中对齐文本**。
- en: Select the other `Text` element inside the `RestartButton` property, and change
    its `Restart`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `RestartButton` 属性内的另一个 `Text` 元素，并将其 `Restart` 更改。
- en: Duplicate the `RestartButton` property and change the copy’s name to `ExitButton`.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 `RestartButton` 属性，并将复制品的名称更改为 `ExitButton`。
- en: Change the `Text` element inside the `ExitButton` property to `Exit`.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ExitButton` 属性内的 `Text` 元素更改为 `Exit`。
- en: Expand the `ExitButton` property, and set its `0.425` on the *X* axis and `0.615`
    on the *Y* axis. Then, set its `0.574` on the *X* axis and `0.725` on the *Y*
    axis.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 `ExitButton` 属性，并将其 `X` 轴上的 `0.425` 和 `Y` 轴上的 `0.615` 设置。然后，将其 `X` 轴上的 `0.574`
    和 `Y` 轴上的 `0.725` 设置。
- en: Set the `ExitButton` properties of `0`.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `ExitButton` 属性为 `0`。
- en: 'After you’ve done these changes, we’ll need to add the logic responsible for
    handling the `ExitButton` property click, which will exit the game:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些更改后，我们需要添加处理 `ExitButton` 属性点击的逻辑，这将退出游戏：
- en: Save the changes made to the `BP_RestartWidget` Widget Blueprint and open the
    `RestartWidget` class’s header file in Visual Studio. In this file, add a declaration
    for a `protected` function called `OnExitClicked` that returns nothing and receives
    no parameters. Be sure to mark it as`UFUNCTION`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存对 `BP_RestartWidget` Widget 蓝图的更改，并在 Visual Studio 中打开 `RestartWidget` 类的头文件。在这个文件中，添加一个名为
    `OnExitClicked` 的 `protected` 函数声明，该函数不返回任何内容，也不接收任何参数。确保将其标记为 `UFUNCTION`。
- en: Duplicate the existing `RestartButton` property, but call it `ExitButton` instead.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制现有的 `RestartButton` 属性，但将其命名为 `ExitButton`。
- en: Inside the `RestartWidget` class’s source file, add an implementation for the
    `OnExitClicked` function. Copy the contents of the `OnBeginOverlap` function from
    inside the `VictoryBox` class’s source file into the `OnExitClicked` function,
    but remove the cast being done to the `DodgeballCharacter` class.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestartWidget` 类的源文件中，为 `OnExitClicked` 函数添加一个实现。将 `VictoryBox` 类源文件中的 `OnBeginOverlap`
    函数的内容复制到 `OnExitClicked` 函数中，但移除对 `DodgeballCharacter` 类的转换。
- en: In the `NativeOnInitialized` function implementation, bind the `OnExitClicked`
    function we created to the `OnClicked` event of the `ExitButton` property, in
    the same way that we did for the `RestartButton` property in *Exercise 8.03 –
    creating the RestartWidget C++ class*.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NativeOnInitialized` 函数实现中，将我们创建的 `OnExitClicked` 函数绑定到 `ExitButton` 属性的
    `OnClicked` 事件，就像我们在 *练习 8.03 – 创建 RestartWidget C++ 类* 中对 `RestartButton` 属性所做的那样。
- en: And that concludes our code setup for this activity. Compile your changes, and
    open the editor. Then, open the `BP_RestartWidget` property and compile it just
    to make sure there are no compilation errors due to the `BindWidget` tags.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了这个活动的代码设置。编译你的更改，并打开编辑器。然后，打开 `BP_RestartWidget` 属性并编译它，以确保没有由于 `BindWidget`
    标签导致的编译错误。
- en: 'Once you’ve done this, play the level again, let the player character be hit
    by three dodgeballs, and notice the `Restart` widget appear with our new modifications:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，再次播放关卡，让玩家角色被三个躲避球击中，并注意 `Restart` 控件会显示我们的新修改：
- en: '![Figure 8.36 – The updated BP_RestartWidget property being shown after the
    player runs out of health points ](img/Figure_8.36_B18531.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.36 – 玩家健康值耗尽后显示的更新后的 BP_RestartWidget 属性](img/Figure_8.36_B18531.jpg)'
- en: Figure 8.36 – The updated BP_RestartWidget property being shown after the player
    runs out of health points
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.36 – 玩家健康值耗尽后显示的更新后的 BP_RestartWidget 属性
- en: If you press the `Restart` button, you should be able to replay the level, and
    if you press the `Exit` button, the game should end.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下“重启”按钮，你应该能够重新播放关卡，如果你按下“退出”按钮，游戏应该结束。
- en: And that concludes our activity. You’ve consolidated the basics of using a **Widget
    blueprint** and changing its element’s properties. Now you are ready to start
    making your own menus.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了这个活动。你已经巩固了使用 **Widget 蓝图** 和更改其元素属性的基础知识。现在你可以开始制作自己的菜单了。
- en: Note
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在 GitHub 上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: Summary
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this chapter concluded, you have now learned how to make a game UI in UE5,
    understanding things such as menus and HUDs. You’ve seen how to manipulate a Widget
    Blueprint’s UI elements, including Button elements, Text elements, and Progress
    Bar elements; work with anchors effectively, which is instrumental in allowing
    your game UI to adapt elegantly to multiple screens; listen to mouse events in
    C++, such as the `OnClick` event, and use that to create your own game logic;
    and how to add the widgets you create to the screen, either at specific events
    or have them present at all times.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束后，你现在已经学会了如何在 UE5 中制作游戏 UI，理解了菜单和 HUD 等内容。你看到了如何操作 Widget 蓝图的 UI 元素，包括按钮元素、文本元素和进度条元素；有效地使用锚点，这对于你的游戏
    UI 优雅地适应多个屏幕至关重要；在 C++ 中监听鼠标事件，如 `OnClick` 事件，并使用它来创建自己的游戏逻辑；以及如何将你创建的控件添加到屏幕上，无论是在特定事件中添加还是在任何时候都显示。
- en: In the next chapter, we’ll be taking a look at polishing our **Dodgeball** game
    by adding audiovisual elements, such as sound and particle effects, as well as
    making a new level.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加音视频元素，如声音和粒子效果，以及制作新关卡，来完善我们的**躲避球**游戏。
