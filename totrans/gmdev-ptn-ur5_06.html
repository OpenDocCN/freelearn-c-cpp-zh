<html><head></head><body>
<div id="_idContainer124">
<h1 class="chapter-number" id="_idParaDest-76"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.2.1">Clean Communication  – Interface and Event Observer Patterns</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will explore two design patterns that allow us to improve how actors communicate with each other. </span><span class="koboSpan" id="kobo.3.2">Utilizing the interface and event observer patterns to allow us to build better, cleaner communication solutions, reducing memory and processing cost of communication. </span><span class="koboSpan" id="kobo.3.3">To explore these, we will expand on the RTS game by implementing a health component that can be added to any actor. </span><span class="koboSpan" id="kobo.3.4">We will start by looking at interfaces in C++, following the concepts of the interface design pattern, and then explore the event observer pattern, with an exploration of Event Dispatchers in Blueprint and the implementation of event delegates </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">in C++.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Interfacing communication across classes </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">in UE5</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Implementing event delegate communication </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">across UE5</span></span></li>
</ul>
<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.11.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.12.1">In this chapter, we will bring together the isolated systems we have built in previous chapters. </span><span class="koboSpan" id="kobo.12.2">Presuming you have followed along, you should be able to tie it all together in </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">If you want to jump straight in at this point, you can download the </span><strong class="source-inline"><span class="koboSpan" id="kobo.15.1">chapter6</span></strong><span class="koboSpan" id="kobo.16.1"> branch from GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">at </span></span><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter06"><span class="No-Break"><span class="koboSpan" id="kobo.18.1">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter06</span></span></a></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.19.1">Interfacing communication across classes in UE5</span></h1>
<p><span class="koboSpan" id="kobo.20.1">Interfaces are </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.21.1">a class that facilitates communication between different classes, without either class being aware of the other’s type. </span><span class="koboSpan" id="kobo.21.2">An interface class</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.22.1"> holds a set of common functions that can be implemented on any class </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">through polymorphism.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">To abstract this, let’s </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.25.1">think about a ridiculous situation where you have a stack of pages, and you are asked to verify that it is indeed a copy of </span><em class="italic"><span class="koboSpan" id="kobo.26.1">War and Peace</span></em><span class="koboSpan" id="kobo.27.1"> that is just missing the cover. </span><span class="koboSpan" id="kobo.27.2">The only way to be truly sure is to compare each word on every page with a verified copy. </span><span class="koboSpan" id="kobo.27.3">This is time-consuming and along the lines of what Unreal Engine does when casting a class to </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">another type.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.29.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.30.1">This isn’t exactly what the engine does. </span><span class="koboSpan" id="kobo.30.2">There are efficiencies built in that speed this process up, ensuring that it is not the entire class that is checked, but the point still remains that casting can </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">be needless.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">If we dig deeper into this hypothetical, knowing why you were asked to verify the book’s nature can make a big difference. </span><span class="koboSpan" id="kobo.32.2">If it was to verify the book’s integrity, then there is no way around it, but if the request was just to see whether a certain chapter existed, then we don’t need to do all that much work. </span><span class="koboSpan" id="kobo.32.3">Instead, we just need to look at the contents page, skip to the requested chapter, and read from there. </span><span class="koboSpan" id="kobo.32.4">This is what an interface does; it’s like the contents page of a book. </span><span class="koboSpan" id="kobo.32.5">The book promises that the required chapter will be in the area signposted by the </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">contents page.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">One of the most-used solutions to build cleaner methods of communication between two actors is to implement Blueprint interfaces, which remove the need to cast to an actor’s specific class, allowing you to use an actor reference instead. </span><span class="koboSpan" id="kobo.34.2">Let’s take a deeper look at Blueprint interfaces before we move on to interfaces </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">in C++.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.36.1">Blueprint interfaces</span></h2>
<p><span class="koboSpan" id="kobo.37.1">We’ve previously made </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.38.1">use of a </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">Blueprint interface</span></strong><span class="koboSpan" id="kobo.40.1"> in </span><a href="B18297_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.41.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.42.1"> while improving the cascading cast chain problem, at which point we created a Blueprint interface, set up a function definition, and used it as a callable event on the various weapon Blueprints. </span><span class="koboSpan" id="kobo.42.2">The event was then called from the character Blueprint, allowing it to call the event on an attached weapon (a child actor component) without needing to cast the reference to a specific class, improving the efficiency of the system as well as reducing the </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">memory impact.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">So, from </span><a href="B18297_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.45.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.46.1">, we already know how to create a Blueprint interface, create functions within the interface, and call them as events, but let’s look at a few of the features of a Blueprint interface that we haven’t </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">encountered yet.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Let’s explore this using a new interface. </span><span class="koboSpan" id="kobo.48.2">Go ahead and create a new Blueprint interface asset, and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">BI_Test</span></strong><span class="koboSpan" id="kobo.50.1">, as this is only a temporary class for </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">exploration purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Before we add any functions, let’s take </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.53.1">a look at the various settings by clicking on </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">Class Settings</span></strong><span class="koboSpan" id="kobo.55.1"> from the top menu, which will change the details panel to show a range of variables associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">Blueprint class.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.57.1"><img alt="Figure 6.1 – The Blueprint interface Class Settings showing in the Details panel" src="image/Figure_06.01_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.58.1">Figure 6.1 – The Blueprint interface Class Settings showing in the Details panel</span></p>
<p><span class="koboSpan" id="kobo.59.1">The two most beneficial settings </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.60.1">when building systems are </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">Blueprint Display Name</span></strong><span class="koboSpan" id="kobo.62.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">Blueprint Description</span></strong><span class="koboSpan" id="kobo.64.1">, as both provide improvements to the user experience when working with Blueprint Interfaces. </span><span class="koboSpan" id="kobo.64.2">Without these being set, Unreal will display only the asset name and provide no description, which, while okay for a solo developer in the moment, is less helpful later in development or when working with </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">other people.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">In order to see the settings working for yourself, we suggest creating and using a test Blueprint class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">BP_Test</span></strong><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">This can then be deleted once you are confident you understand </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">the settings.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Let’s take a look at how we set these up and what effect they have on the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">user experience.</span></span></p>
<h3><span class="koboSpan" id="kobo.72.1">Blueprint Display Name</span></h3>
<p><span class="koboSpan" id="kobo.73.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">Blueprint Display Name</span></strong><span class="koboSpan" id="kobo.75.1"> setting</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.76.1"> provides a string input to allow you to define how the interface appears in the </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">Class Settings</span></strong><span class="koboSpan" id="kobo.78.1"> of a Blueprint class when the interface has </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">been implemented.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.80.1"><img alt="Figure 6.2 – Class Settings of a Blueprint ﻿class with an implement interface with and without a Blueprint Display Name" src="image/Figure_06.02_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.81.1">Figure 6.2 – Class Settings of a Blueprint class with an implement interface with and without a Blueprint Display Name</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.82.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.83.1">.2</span></em><span class="koboSpan" id="kobo.84.1"> shows the comparison between the class settings of a Blueprint class for the end user when implementing an interface with or without a </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">Blueprint Display Name</span></strong><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">Here, the Blueprint interface class </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">BI_Test</span></strong><span class="koboSpan" id="kobo.88.1">, in the left image, does not have a </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">Blueprint Display Name</span></strong><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">For the right image, the </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">Blueprint Display Name</span></strong><span class="koboSpan" id="kobo.92.1"> has been set to </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Test Blueprint Interface</span></strong><span class="koboSpan" id="kobo.94.1"> which is then displayed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">implemented interfaces</span></strong><span class="koboSpan" id="kobo.96.1"> list when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">BI_Test Blueprint</span></strong><span class="koboSpan" id="kobo.98.1"> interface has been selected from the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.99.1">Add</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.100.1"> dropdown.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.101.1"><img alt="Figure 6.3 – The Blueprint Options rollout of BI_Test with the Blueprint Display Name set." src="image/Figure_06.03_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.102.1">Figure 6.3 – The Blueprint Options rollout of BI_Test with the Blueprint Display Name set.</span></p>
<p><span class="koboSpan" id="kobo.103.1">This allows us, as </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.104.1">systems designers, to maintain core naming conventions whilst ensuring that it is always clear what interface has been used in a format suitable for designers and other </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">team members.</span></span></p>
<h3><span class="koboSpan" id="kobo.106.1">Blueprint Description</span></h3>
<p><span class="koboSpan" id="kobo.107.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">Blueprint Description</span></strong><span class="koboSpan" id="kobo.109.1"> setting</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.110.1"> provides a string input, allowing you to define the mouseover hint when choosing an interface to implement, from the </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">Add</span></strong><span class="koboSpan" id="kobo.112.1"> drop-down menu in the class settings of a </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">Blueprint class.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.114.1"><img alt="Figure 6.4 – The class settings’ Add dropdown when selecting an interface to implement, with a Blueprint description" src="image/Figure_06.04_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.115.1">Figure 6.4 – The class settings’ Add dropdown when selecting an interface to implement, with a Blueprint description</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.116.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.117.1">.4</span></em><span class="koboSpan" id="kobo.118.1"> shows </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.119.1">a comparison between the </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Add</span></strong><span class="koboSpan" id="kobo.121.1"> dropdown for the end user in </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">Class Settings</span></strong><span class="koboSpan" id="kobo.123.1"> when selecting an interface to implement with and without a Blueprint description. </span><span class="koboSpan" id="kobo.123.2">Here, the Blueprint interface class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">BI_Test</span></strong><span class="koboSpan" id="kobo.125.1">, on the left-hand side of </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.126.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.127.1">.4</span></em><span class="koboSpan" id="kobo.128.1">, does not have a Blueprint description. </span><span class="koboSpan" id="kobo.128.2">On the right-hand side, the Blueprint description has been set to </span><strong class="bold"><span class="koboSpan" id="kobo.129.1">A test interface for exploring the Blueprint Options of a Blueprint interface</span></strong><span class="koboSpan" id="kobo.130.1">, which is then displayed when the mouse is held over </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">BI_Test</span></strong><span class="koboSpan" id="kobo.132.1"> in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.133.1">Add</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1"> dropdown.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.135.1"><img alt="Figure 6.5 – The Blueprint Options rollout of BI_Test with the Blueprint Description set" src="image/Figure_06.05_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.136.1">Figure 6.5 – The Blueprint Options rollout of BI_Test with the Blueprint Description set</span></p>
<p><span class="koboSpan" id="kobo.137.1">This allows us </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.138.1">to make it clear, when selecting an interface, what it should be used for. </span><span class="koboSpan" id="kobo.138.2">The messages can include specifics such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">Required on all classes required to interact with doors</span></strong><span class="koboSpan" id="kobo.140.1"> or more general messages, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">Adds functions for shooting weapons</span></strong><span class="koboSpan" id="kobo.142.1">. </span><span class="koboSpan" id="kobo.142.2">The key here is to make sure the description helps other users identify what the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">interface provides.</span></span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.144.1">Interface events versus functions</span></h2>
<p><span class="koboSpan" id="kobo.145.1">When adding </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.146.1">functions to a Blueprint interface </span><em class="italic"><span class="koboSpan" id="kobo.147.1">functions</span></em><span class="koboSpan" id="kobo.148.1"> list, it can result </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.149.1">in either a function or an event when implemented into a </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">Blueprint class.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">BI_Test</span></strong><span class="koboSpan" id="kobo.153.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">BP_Test</span></strong><span class="koboSpan" id="kobo.155.1"> classes, we can explore the differences in a safe space. </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">Let’s begin:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.157.1">Let’s start by adding two functions using the </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">+Add</span></strong><span class="koboSpan" id="kobo.159.1"> button; name these </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">ExampleEvent</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.161.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">ExampleFunction</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.164.1">Select </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">ExampleFunction</span></strong><span class="koboSpan" id="kobo.166.1"> from the </span><em class="italic"><span class="koboSpan" id="kobo.167.1">functions</span></em><span class="koboSpan" id="kobo.168.1"> list, and add an output variable to the </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">Outputs</span></strong><span class="koboSpan" id="kobo.170.1"> list by clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">+</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.172.1">icon.</span></span></li>
<li><span class="koboSpan" id="kobo.173.1">Name the new variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">BoolOutput</span></strong><span class="koboSpan" id="kobo.175.1">, and set the type </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.177.1">Boolean</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.179.1">This will have created both an event, and a function for use in a Blueprint. </span><span class="koboSpan" id="kobo.179.2">Once you add an output variable, the function will behave as a Blueprint function, and without any outputs, it will act as </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">an event.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<span class="koboSpan" id="kobo.181.1"><img alt="Figure 6.6 – An interface function and interface event in a Blueprint class" src="image/Figure_06.06_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.182.1">Figure 6.6 – An interface function and interface event in a Blueprint class</span></p>
<p><span class="koboSpan" id="kobo.183.1">Note how the icon is different for a function (a gray icon) and an event (a yellow icon). </span><span class="koboSpan" id="kobo.183.2">This isn’t the only difference; adding logic to a function works differently to an event. </span><span class="koboSpan" id="kobo.183.3">Double-clicking on the</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.184.1"> event will result in an event node being</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.185.1"> added to the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.186.1">Event Graph</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<span class="koboSpan" id="kobo.188.1"><img alt="Figure 6.7 – An interface event when added to the Event Graph" src="image/Figure_06.07_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Figure 6.7 – An interface event when added to the Event Graph</span></p>
<p><span class="koboSpan" id="kobo.190.1">Double-clicking on the function will result in a new tab opening with the function graph, including a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.191.1">Return Node</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<span class="koboSpan" id="kobo.193.1"><img alt="Figure 6.8 – An interface function with Return Node" src="image/Figure_06.08_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.194.1">Figure 6.8 – An interface function with Return Node</span></p>
<p><span class="koboSpan" id="kobo.195.1">When calling an interface function or event, they will appear slightly different in the Blueprint graph. </span><span class="koboSpan" id="kobo.195.2">The main differences are the icon and the inclusion of output exec pins (the white outlined arrows on the right-hand side of </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">the node):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<span class="koboSpan" id="kobo.197.1"><img alt="Figure 6.9 – A comparison of interface event and interface Function nodes in a Blueprint graph" src="image/Figure_06.09_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">Figure 6.9 – A comparison of interface event and interface Function nodes in a Blueprint graph</span></p>
<p><span class="koboSpan" id="kobo.199.1">There are two</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.200.1"> other possible visual results for Blueprint nodes from</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.201.1"> interface functions; these are compact nodes that occur when a Blueprint interface function has a </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">Compact </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.203.1">Node Title</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">To test these out, create</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.206.1"> two new functions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">BI_Test</span></strong><span class="koboSpan" id="kobo.208.1"> Blueprint interface; call these </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">ExampleCompactedEvent</span></strong><span class="koboSpan" id="kobo.210.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">ExampleCompactedFunction</span></strong><span class="koboSpan" id="kobo.212.1">, adding a Boolean variable to the output list as before. </span><span class="koboSpan" id="kobo.212.2">This time, however, set the Compact Node title of each function. </span><span class="koboSpan" id="kobo.212.3">For now, duplicate the function names with spaces between </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">the words.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<span class="koboSpan" id="kobo.214.1"><img alt="Figure 6.10 – Compacted node examples of an interface event and interface ﻿function on a Blueprint graph" src="image/Figure_06.10_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.215.1">Figure 6.10 – Compacted node examples of an interface event and interface function on a Blueprint graph</span></p>
<p><span class="koboSpan" id="kobo.216.1">Compact nodes, when </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.217.1">placed, appear as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.218.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.219.1">.10</span></em><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">Compact nodes don’t have titles or pin names; these are not commonly used when working in Blueprint but are available </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">if desired.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.222.1">Interfaces in C++</span></h2>
<p><span class="koboSpan" id="kobo.223.1">In C++, things get a </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.224.1">little weird. </span><span class="koboSpan" id="kobo.224.2">The original core of Unreal is closer to Objective C than C++, and it shows the most when dealing with interfaces. </span><span class="koboSpan" id="kobo.224.3">It is advised that interfaces should be made from the editor, as there is so little that we need to add to the file from the template that typing it all out from scratch is a waste </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">of time.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">In the editor, open the section of your content for C++ classes. </span><span class="koboSpan" id="kobo.226.2">Right-click and add a new C++ class. </span><span class="koboSpan" id="kobo.226.3">When selecting what parent to inherit from, scroll to the bottom of the common classes and choose the </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">Unreal Interface</span></strong><span class="koboSpan" id="kobo.228.1">. </span><span class="koboSpan" id="kobo.228.2">This will create a new header file, like the </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">following template:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.230.1">Unreal interface template project specific elements replaced with tokens</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.231.1">
#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "&lt;class name&gt;.generated.h"
UINTERFACE(MinimalAPI)
class U&lt;class name&gt; : public UInterface
{
    GENERATED_BODY()
};
class &lt;module name&gt;_API I&lt;class name&gt;
{
    GENERATED_BODY()
public:
}</span></pre> <p><span class="koboSpan" id="kobo.232.1">As you can see in the template, there are two classes in the same header file. </span><span class="koboSpan" id="kobo.232.2">The top class is created with your chosen class name, prefixed with a </span><em class="italic"><span class="koboSpan" id="kobo.233.1">U</span></em><span class="koboSpan" id="kobo.234.1">. </span><span class="koboSpan" id="kobo.234.2">This inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">UInterface</span></strong><span class="koboSpan" id="kobo.236.1"> class and allows your class to become part of the Unreal interface system, working with functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">UKismetSystemLibrary::DoesImplementInterface</span></strong><span class="koboSpan" id="kobo.238.1">. </span><span class="koboSpan" id="kobo.238.2">The second class extends your module and has a similar name, except it starts with an </span><em class="italic"><span class="koboSpan" id="kobo.239.1">I</span></em><span class="koboSpan" id="kobo.240.1"> instead. </span><span class="koboSpan" id="kobo.240.2">This is the class you should add public functions to and </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">multi-inherit from.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">When calling a </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.243.1">function from an interface, it is assumed that the reference held is not for the correct type of class and, instead, is most likely an </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">AActor*</span></strong><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">If this is not the case, then the interface provides no benefit, and the communication strategy should be rethought. </span><span class="koboSpan" id="kobo.245.3">Unreal provides a few ways of calling functions via interfaces. </span><span class="koboSpan" id="kobo.245.4">The two main methods are casting to the interface as a type and calling the instance of the function, or statically calling the function. </span><span class="koboSpan" id="kobo.245.5">Casting to the interface type is exactly as it sounds and would involve something </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">like this:</span></span></p>
<pre class="source-code">
<strong class="source-inline"><span class="koboSpan" id="kobo.247.1">if(IInterface* cachedRef = Cast&lt;IInterface&gt;(actorRef))</span></strong>
<strong class="source-inline"><span class="koboSpan" id="kobo.248.1">{ cachedRef-&gt;Function(arg1); }</span></strong></pre> <p><span class="koboSpan" id="kobo.249.1">Note how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Cast</span></strong><span class="koboSpan" id="kobo.251.1"> returns the casted pointer and a boolean value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">if</span></strong><span class="koboSpan" id="kobo.253.1"> statement. </span><span class="koboSpan" id="kobo.253.2">This works because an </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">if</span></strong><span class="koboSpan" id="kobo.255.1"> on a pointer in Unreal will automatically check whether the pointer is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">nullptr</span></strong><span class="koboSpan" id="kobo.257.1">. </span><span class="koboSpan" id="kobo.257.2">However, it does still use a cast, no matter how small it may be. </span><span class="koboSpan" id="kobo.257.3">It is faster to use a static function call such as </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">the following:</span></span></p>
<pre class="source-code">
<strong class="source-inline"><span class="koboSpan" id="kobo.259.1">IInterface::Execute_Function(actorRef, arg1);</span></strong></pre> <p><span class="koboSpan" id="kobo.260.1">As you can see, this gets to the function call much faster and with less temporary variables declared. </span><span class="koboSpan" id="kobo.260.2">The trade-off is the security of the call. </span><span class="koboSpan" id="kobo.260.3">In this method, we assume that </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">actorRef</span></strong><span class="koboSpan" id="kobo.262.1"> implements the interface that we call the function from. </span><span class="koboSpan" id="kobo.262.2">This assumption means that if the class in question doesn’t implement the needed interface we will get a logic error. </span><span class="koboSpan" id="kobo.262.3">The</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.263.1"> solution is to either design in a way that avoids this situation or to check for the interface without casting to it, using the aforementioned </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">DoesImplementInterface</span></strong><span class="koboSpan" id="kobo.265.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">UKismetSystemLibrary</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">So, with these general concepts in mind, let’s look at creating our own interface </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">in C++.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.271.1">Building an example interface communication</span></h2>
<p><span class="koboSpan" id="kobo.272.1">To implement something</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.273.1"> like the preceding example where actors can be flammable, we can start with an interface called </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">IFlammable</span></strong><span class="koboSpan" id="kobo.275.1"> that will need a public virtual function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Ignite</span></strong><span class="koboSpan" id="kobo.277.1">. </span><span class="koboSpan" id="kobo.277.2">This would look like </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">the following:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.279.1">Iflammable.h</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.280.1">
#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "flammable.generated.h"
UINTERFACE(MinimalAPI)
class UFlammable : public UInterface
{
    GENERATED_BODY()
};
class EXAMPLE_API IFlammable
{
    GENERATED_BODY()
public:
    virtual void Ignite();
}</span></pre> <p><span class="koboSpan" id="kobo.281.1">To implement</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.282.1"> this in other classes, you simply need to use polymorphism and override the interface functions. </span><span class="koboSpan" id="kobo.282.2">The following example shows a tree actor multi-inheriting from the interface to </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">implement it:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.284.1">Excerpt from possible example flammable interface usage Tree.h</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
#include "flammable.h"
UCLASS()
class Example_API ATree : public AActor, public IFlammable
{
    //other code
public:
    void Ignite() override;
}</span></pre> <p><span class="koboSpan" id="kobo.286.1">On the calling side, if we had a flaming torch, we could add the following code to the collision handler for a collider around the </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">flame particle:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.288.1">Excerpt from possible flammable interface usage</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
if(UKismetSystemLibrary::DoesImplementInterface(otherActor,     UFlammable::StaticClass()))
{
    IFlammable::Execute_Ignite(otherActor);
}</span></pre> <p><span class="koboSpan" id="kobo.290.1">This code will let the torch ignite anything that is flammable and ignore everything that is not, without causing any errors or needing to do any </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">unnecessary casting.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">Interfaces, both in</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.293.1"> Blueprint and C++, offer us key benefits in keeping communication clean and efficient, allowing us to bundle up function names for use on implementing classes. </span><span class="koboSpan" id="kobo.293.2">Now that we’ve explored the benefits and the process to create both types of interface, we can look at another anonymous communication method – </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">events.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.295.1">Implementing event delegate communication across UE5</span></h1>
<p><span class="koboSpan" id="kobo.296.1">The other </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.297.1">form of anonymous communication is the event delegate. </span><span class="koboSpan" id="kobo.297.2">Delegates are essentially function pointers that allow us to change the flow of logic dynamically at runtime. </span><span class="koboSpan" id="kobo.297.3">When invoked, they allow a signal to be sent to potentially several other parts of a program, without the sender knowing where the signal has gone. </span><span class="koboSpan" id="kobo.297.4">Using these as part of an event-driven approach is called an </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">event delegate.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Event delegates can be compared to a radio station. </span><span class="koboSpan" id="kobo.299.2">The delegate exists as the station, transmitting a signal into the air when it is told to. </span><span class="koboSpan" id="kobo.299.3">Then, there are radios that can choose to subscribe to the station, receiving the signal. </span><span class="koboSpan" id="kobo.299.4">This forms a one-to-many relationship, with one-way communication. </span><span class="koboSpan" id="kobo.299.5">The radios cannot send messages back to the station, and the station does not know how many radios are </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">tuned in.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">Like when we explored interfaces, let’s begin with the Blueprint implementation before moving on to the more complex </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">C++ approach.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.303.1">Event delegates in Blueprint</span></h2>
<p><span class="koboSpan" id="kobo.304.1">In Blueprint, delegates are made simple </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.305.1">with one variant exposed. </span><span class="koboSpan" id="kobo.305.2">These are called </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.306.1">Event Dispatchers. </span><span class="koboSpan" id="kobo.306.2">They do, however, function in the </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">expected way.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">Event Dispatchers need to be created in the class that will do the broadcasting (the radio station as such). </span><span class="koboSpan" id="kobo.308.2">We do this by clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">+</span></strong><span class="koboSpan" id="kobo.310.1"> symbol in the </span><strong class="bold"><span class="koboSpan" id="kobo.311.1">EVENT DISPATCHERS</span></strong><span class="koboSpan" id="kobo.312.1"> dropdown of the </span><strong class="bold"><span class="koboSpan" id="kobo.313.1">My </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.314.1">Blueprint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.315.1"> tab.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<span class="koboSpan" id="kobo.316.1"><img alt="Figure 6.11 – The Event Dispatchers rollout within the My Blueprint tab" src="image/Figure_06.11_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.317.1">Figure 6.11 – The Event Dispatchers rollout within the My Blueprint tab</span></p>
<p><span class="koboSpan" id="kobo.318.1">An Event Dispatcher</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.319.1"> can have a series of inputs like any event in Blueprint. </span><span class="koboSpan" id="kobo.319.2">These are added at the top of the </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">Details</span></strong><span class="koboSpan" id="kobo.321.1"> tab. </span><span class="koboSpan" id="kobo.321.2">You can also use the </span><strong class="bold"><span class="koboSpan" id="kobo.322.1">Copy signature from</span></strong><em class="italic"> </em><span class="koboSpan" id="kobo.323.1">dropdown to select an existing event in the current Blueprint. </span><span class="koboSpan" id="kobo.323.2">This will duplicate all of the inputs from that event in the </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">Event Dispatcher.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer116">
<span class="koboSpan" id="kobo.325.1"><img alt="Figure 6.12 – Event Dispatcher variables and the Copy ﻿signature﻿ from dropdown" src="image/Figure_06.12_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.326.1">Figure 6.12 – Event Dispatcher variables and the Copy signature from dropdown</span></p>
<p><span class="koboSpan" id="kobo.327.1">A Blueprint </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.328.1">can respond to its own dispatcher in the same way that any listening delegate can respond. </span><span class="koboSpan" id="kobo.328.2">The dispatcher needs to be bound to an event, which then performs the </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">desired response.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">This is why, if you drag and drop the dispatcher from the Event Dispatchers list, onto the Blueprint graph, you will be presented with a popup containing </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">Call</span></strong><span class="koboSpan" id="kobo.332.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">Bind</span></strong><span class="koboSpan" id="kobo.334.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">Unbind</span></strong><span class="koboSpan" id="kobo.336.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.337.1">Unbind all</span></strong><span class="koboSpan" id="kobo.338.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">Event</span></strong><span class="koboSpan" id="kobo.340.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.342.1">Assign</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer117">
<span class="koboSpan" id="kobo.344.1"><img alt="Figure 6.13 – The Event Dispatcher popup when dragged onto the Blueprint graph" src="image/Figure_06.13_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.345.1">Figure 6.13 – The Event Dispatcher popup when dragged onto the Blueprint graph</span></p>
<p><span class="koboSpan" id="kobo.346.1">These options are </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.347.1">available wherever you choose to respond to a dispatcher (with the exception of an event). </span><span class="koboSpan" id="kobo.347.2">However, you will typically access them via the normal popup to create Blueprint nodes when dragging out from an object, which holds the dispatcher as </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">a reference.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer118">
<span class="koboSpan" id="kobo.349.1"><img alt="Figure 6.14 – The Blueprint context popup when searching for an Event Dispatcher by name, after dragging from a reference to a class that holds the Event Dispatcher" src="image/Figure_06.14_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.350.1">Figure 6.14 – The Blueprint context popup when searching for an Event Dispatcher by name, after dragging from a reference to a class that holds the Event Dispatcher</span></p>
<p><span class="koboSpan" id="kobo.351.1">Let’s explore each of the options we are presented with from these popups so that you know when and how to </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">use them.</span></span></p>
<h3><span class="koboSpan" id="kobo.353.1">Call</span></h3>
<p><span class="koboSpan" id="kobo.354.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">Call</span></strong><span class="koboSpan" id="kobo.356.1"> option </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.357.1">activates the Event Dispatcher, sending the message to any subscribed delegates that are listening for the event. </span><span class="koboSpan" id="kobo.357.2">This is typically used on the Blueprint that has the event, but can be called from a separate Blueprint that has a direct reference to the actor with </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">the dispatcher.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer119">
<span class="koboSpan" id="kobo.359.1"><img alt="Figure 6.15 – A call dispatcher node with two variable inputs (Float and Bool)" src="image/Figure_06.15_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.360.1">Figure 6.15 – A call dispatcher node with two variable inputs (Float and Bool)</span></p>
<p><span class="koboSpan" id="kobo.361.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.362.1">Bind</span></strong><span class="koboSpan" id="kobo.363.1"> option is </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.364.1">used to identify which event should be run when the dispatcher is called; when used, the associated event is added to the list of events associated with the dispatcher. </span><span class="koboSpan" id="kobo.364.2">In Blueprint, the red line between the </span><strong class="bold"><span class="koboSpan" id="kobo.365.1">Bind Event to</span></strong><span class="koboSpan" id="kobo.366.1"> node and the </span><strong class="bold"><span class="koboSpan" id="kobo.367.1">Event</span></strong><span class="koboSpan" id="kobo.368.1"> node indicates which event it is to be </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">bound to.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer120">
<span class="koboSpan" id="kobo.370.1"><img alt="Figure 6.16 – A bind event node connected to a custom event ﻿that will be run when the Event Dispatcher is called" src="image/Figure_06.16_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.371.1">Figure 6.16 – A bind event node connected to a custom event that will be run when the Event Dispatcher is called</span></p>
<p><span class="koboSpan" id="kobo.372.1">This can be</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.373.1"> replaced by using a </span><strong class="bold"><span class="koboSpan" id="kobo.374.1">Create Event</span></strong><span class="koboSpan" id="kobo.375.1"> node, which can create a function or event with a matching signature (the same variables) or point toward an existing event. </span><span class="koboSpan" id="kobo.375.2">These are often used to try to keep the Blueprint graph tidy but are required to link to a function, as opposed to </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">an event.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer121">
<span class="koboSpan" id="kobo.377.1"><img alt="Figure 6.17–A bind event node connected to a Create Event node" src="image/Figure_06.17_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.378.1">Figure 6.17–A bind event node connected to a Create Event node</span></p>
<h3><span class="koboSpan" id="kobo.379.1">Unbind and Unbind all</span></h3>
<p><span class="koboSpan" id="kobo.380.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">Unbind</span></strong><span class="koboSpan" id="kobo.382.1"> node </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.383.1">does the opposite of the bind node. </span><span class="koboSpan" id="kobo.383.2">When using </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">Unbind</span></strong><span class="koboSpan" id="kobo.385.1">, the event is removed from the list of events associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">Event Dispatcher.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">Unbind all</span></strong><span class="koboSpan" id="kobo.389.1"> option</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.390.1"> does the same, but instead of just removing the linked event, it removes all events, nullifying the dispatcher from communicating with anything until another event is associated using a bind </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">event node.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer122">
<span class="koboSpan" id="kobo.392.1"><img alt="Figure 6.18 – The Unbind Event node, connected to a custom event, and an Unbind all Events node" src="image/Figure_06.18_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.393.1">Figure 6.18 – The Unbind Event node, connected to a custom event, and an Unbind all Events node</span></p>
<p><span class="koboSpan" id="kobo.394.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.395.1">Bind</span></strong><span class="koboSpan" id="kobo.396.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">Unbind</span></strong><span class="koboSpan" id="kobo.398.1"> nodes allow us to dynamically link and unlink different events or functions to an Event Dispatcher, allowing us full control over what responds to a dispatcher at any point in </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">the game.</span></span></p>
<h3><span class="koboSpan" id="kobo.400.1">Event and Assign</span></h3>
<p><span class="koboSpan" id="kobo.401.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">Event</span></strong><span class="koboSpan" id="kobo.403.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.404.1">Assign</span></strong><span class="koboSpan" id="kobo.405.1"> options</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.406.1"> exist to help you create the nodes required to respond to an </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">Event Dispatcher.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.409.1">Event</span></strong><span class="koboSpan" id="kobo.410.1"> option creates a </span><strong class="bold"><span class="koboSpan" id="kobo.411.1">Custom Event</span></strong><span class="koboSpan" id="kobo.412.1"> node with a matching signature, ready for you to connect to a bind event </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">node later.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.415.1">Assign</span></strong><span class="koboSpan" id="kobo.416.1"> option </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.417.1">creates both the Bind Event node and the matching custom event node, which can save a little bit of time when creating </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">Blueprint logic.</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">Now that we have a grasp of the Blueprint implementation of events, let’s move on to exploring the </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">C++ implementation.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.421.1">Event delegates in C++</span></h2>
<p><span class="koboSpan" id="kobo.422.1">In C++, event delegates </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.423.1">are a little more complicated, but with that comes more control. </span><span class="koboSpan" id="kobo.423.2">For starters, there are a few different properties you can give each delegate before making events out of it. </span><span class="koboSpan" id="kobo.423.3">Let’s take a look </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">at them:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">DYNAMIC</span></strong><span class="koboSpan" id="kobo.426.1">: This </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.427.1">delegate can be serialized into the editor for easy </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">Blueprint binding</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">MULTICAST</span></strong><span class="koboSpan" id="kobo.430.1">: This </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.431.1">delegate can have multiple listeners at once and removes the ability to have a </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">return value</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">SPARSE</span></strong><span class="koboSpan" id="kobo.434.1">: This</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.435.1"> delegate will not take up 1 byte in memory until it is subscribed to (this does make it slower to use, but it is more efficient for delegates that are rarely bound, such as a </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">marketplace tool)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.437.1">After deciding how the delegate should behave, you need to declare it as a new type. </span><span class="koboSpan" id="kobo.437.2">This is described by the following pattern in </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">all caps:</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">DECLARE_&lt;properties&gt;_DELEGATE_&lt;parameter amount&gt;(&lt;TypeName&gt;, &lt;arg1 type&gt;, &lt;arg1 </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">name&gt;… );</span></strong></span></p>
<p><span class="koboSpan" id="kobo.441.1">An example of this could be </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">as follows:</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FExampleSignature, float, number, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">AActor*, actorRef);</span></strong></span></p>
<p><span class="koboSpan" id="kobo.445.1">This delegate will be serialized into the editor, with possibly multiple bound functions. </span><span class="koboSpan" id="kobo.445.2">Each bound function will have two arguments of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">float</span></strong><span class="koboSpan" id="kobo.447.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">AActor*</span></strong><span class="koboSpan" id="kobo.449.1">. </span><span class="koboSpan" id="kobo.449.2">This is the closest in behavior to a Blueprint </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">Event Dispatcher.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">There is also another type of delegate called an event. </span><span class="koboSpan" id="kobo.451.2">This is a version of a multicast delegate, where the first argument is the owning type, only that type can have events as members, and only the defining object can broadcast the events. </span><span class="koboSpan" id="kobo.451.3">With this extra security, you can expose events as public without fear that a different class will broadcast the event. </span><span class="koboSpan" id="kobo.451.4">However, with that comes extra design challenges to make your systems work in a </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">clean manner.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.453.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.454.1">From this point on, all event delegates used will be dynamic multicast to avoid confusion. </span><span class="koboSpan" id="kobo.454.2">This is not necessarily the best strategy, but it is a good starting point to then modify and restrict behavior later </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">That is how to define a new delegate type and create a new instance of a delegate from the type. </span><span class="koboSpan" id="kobo.456.2">To make delegates do something, you also need to know how to bind functions to them and fire them. </span><span class="koboSpan" id="kobo.456.3">This will change, depending on what properties were given to the event in </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">it’s declaration.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">Working our way through the different properties that a delegate has, we can see that non-dynamic delegates have eight different functions that can bind listening functions to them for each single and multicast. </span><span class="koboSpan" id="kobo.458.2">It is recommended that you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">BindUObject</span></strong><span class="koboSpan" id="kobo.460.1"> function for single-cast delegates and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">AddUObject</span></strong><span class="koboSpan" id="kobo.462.1"> function for multicast delegates. </span><span class="koboSpan" id="kobo.462.2">These both take a reference </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">UObject*</span></strong><span class="koboSpan" id="kobo.464.1"> as a first argument and a function address as the second, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">style: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">&amp;ClassName::FunctionName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">For dynamic delegates, there is less choice; single-cast dynamic delegates should use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">BindDynamic</span></strong><span class="koboSpan" id="kobo.470.1"> function, and for multicast, it is advised you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">AddUniqueDynamic</span></strong><span class="koboSpan" id="kobo.472.1"> function, both with the same arguments as the non-dynamic delegates mentioned previously. </span><span class="koboSpan" id="kobo.472.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">AddDynamic()</span></strong><span class="koboSpan" id="kobo.474.1"> function is ok to use with multicast dynamic delegates if you know the instance of the function has not already been bound to this delegate, otherwise it can be bound multiple times to the same </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">event dispatcher.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">Finally, to call delegates if they are single-cast, you should use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">ExecuteIfBound()</span></strong><span class="koboSpan" id="kobo.478.1"> member function on the delegate, passing through arguments as necessary. </span><span class="koboSpan" id="kobo.478.2">For any multicast delegates, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">Broadcast</span></strong><span class="koboSpan" id="kobo.480.1"> member function. </span><span class="koboSpan" id="kobo.480.2">We will use a lot of multicast dynamic delegates when prototyping, as they offer the greatest flexibility to hook </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.481.1">more listeners in as needed, leading us to make heavy use of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Broadcast</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.483.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">With the core concepts of delegates in C++ covered, let’s move on to creating our own </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">event delegate.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.486.1">Building a useful delegate tool</span></h2>
<p><span class="koboSpan" id="kobo.487.1">Let’s now look at building a</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.488.1"> useful class you can drop into any project. </span><span class="koboSpan" id="kobo.488.2">We will build on top of the damage system already present inside Unreal Engine. </span><span class="koboSpan" id="kobo.488.3">This utilizes a combination of an interface and the polymorphic nature of the engine, allowing you to deal damage to any actor and respond to damage from any actor. </span><span class="koboSpan" id="kobo.488.4">As an extension, we will look at making a Health Component that can sit on any actor, bind itself into this damage system automatically, and provide a couple of useful endpoints for any gameplay system to </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">run with.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">To start with, we need a new C++ class, so head to your C++ folder in the editor and make a new class based on </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">Actor Component</span></strong><span class="koboSpan" id="kobo.492.1">. </span><span class="koboSpan" id="kobo.492.2">Actor components are components for logic, as they have no associated rendering or transform within </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">the world.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.494.1">Useful tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.495.1">If you are using Rider 2022 or later, then a right-click on your module base folder will give you the option to </span><strong class="bold"><span class="koboSpan" id="kobo.496.1">Add an Unreal Class</span></strong><span class="koboSpan" id="kobo.497.1">. </span><span class="koboSpan" id="kobo.497.2">In the popup, you can select an actor component, and it will function the same way but without the need for the engine to </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">be running.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">The first thing</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.500.1"> to think about is what delegate definitions we will need. </span><span class="koboSpan" id="kobo.500.2">The obvious one is for when the component has run out of health and needs to let the owning actor know that it has died. </span><span class="koboSpan" id="kobo.500.3">This could probably pass through a reference to the controller that instigated the chain so that, eventually, the game mode can attribute points to the </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">correct controller:</span></span></p>
<pre class="source-code">
<strong class="source-inline"><span class="koboSpan" id="kobo.502.1">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FHealthDeadSignature, AController*, instigator);</span></strong></pre> <p><span class="koboSpan" id="kobo.503.1">The next useful piece of information to pass out to the component would be a signal whenever damage is dealt. </span><span class="koboSpan" id="kobo.503.2">There are a lot of options for what data to pass through. </span><span class="koboSpan" id="kobo.503.3">For instance, if the target is more of a </span><em class="italic"><span class="koboSpan" id="kobo.504.1">Call of Duty</span></em><span class="koboSpan" id="kobo.505.1">-style game, you probably want to know what direction the damage was received from to feed that back to the player via some form of UI. </span><span class="koboSpan" id="kobo.505.2">In this instance, we will pass through information about the new and maximum health values, along with the change that just happened. </span><span class="koboSpan" id="kobo.505.3">This will let us update UI health bars and possibly spawn some damage numbers into </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">the world:</span></span></p>
<pre class="source-code">
<strong class="source-inline"><span class="koboSpan" id="kobo.507.1">DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams(FHealthDamagedSignature, float, newHealth, float, maxHealth, float, healthChange);</span></strong></pre> <p><span class="koboSpan" id="kobo.508.1">We can then look at the header definitions. </span><span class="koboSpan" id="kobo.508.2">The only items that need to be public are the constructor and one of each delegate type declared previously. </span><span class="koboSpan" id="kobo.508.3">In the protected section, we need some float variables to track the current and maximum health. </span><span class="koboSpan" id="kobo.508.4">These are marked as protected so that the reflection specified in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">UPROPERTY</span></strong><span class="koboSpan" id="kobo.510.1"> tag will work with the editor. </span><span class="koboSpan" id="kobo.510.2">Along with these, we’ll use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">BeginPlay</span></strong><span class="koboSpan" id="kobo.512.1"> override to set up some automatic behavior. </span><span class="koboSpan" id="kobo.512.2">Lastly, we’ll add a handler function to the private section. </span><span class="koboSpan" id="kobo.512.3">This will be used to hook into the damage interface system already present inside the actor this component is attached to. </span><span class="koboSpan" id="kobo.512.4">With</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.513.1"> that all written out, the class definition should look a little </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.515.1">HealthComponent.h class definition</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.516.1">
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class &lt;module name&gt;_API UHealthComponent : public UActorComponent
{
    GENERATED_BODY()
public:
    UHealthComponent();
    UPROPERTY(BlueprintAssignable)
    FHealthDeadSignature OnHealthDead;
    UPROPERTY(BlueprintAssignable)
    FHealthDamagedSignature OnHealthDamaged;
protected:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float _MaxHealth;
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    float _CurrentHealth;
    virtual void BeginPlay() override;
private:
    UFUNCTION()
    void DamageTaken(AActor* damagedActor, float damage,
        const UDamageType* dmgType, AController* instigator,
        AActor* causer);
};</span></pre> <p><span class="koboSpan" id="kobo.517.1">After generating the definitions for these functions, we can add a default value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">maxHealth</span></strong><span class="koboSpan" id="kobo.519.1"> into the constructor of maybe </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">100.f</span></strong><span class="koboSpan" id="kobo.521.1">, but this line isn’t too important. </span><span class="koboSpan" id="kobo.521.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">BeginPlay</span></strong><span class="koboSpan" id="kobo.523.1"> override needs to bind our private </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">DamageTaken</span></strong><span class="koboSpan" id="kobo.525.1"> function to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">OnTakeAnyDamage</span></strong><span class="koboSpan" id="kobo.527.1"> event </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.528.1">of the owning actor it is attached to, as well as setting the initial value </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">_CurrentHealth</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.532.1">HealthComponent.cpp Constructor and BeginPlay</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.533.1">
UHealthComponent::UHealthComponent()
{
    _MaxHealth = 100.f;
}
void UHealthComponent::BeginPlay()
{
    Super::BeginPlay();
    _CurrentHealth = _MaxHealth;
    GetOwner()-&gt;OnTakeAnyDamage.AddDynamic         (this, &amp;UHealthComponent::DamageTaken);
}</span></pre> <p><span class="koboSpan" id="kobo.534.1">Then, the logic for how damage is taken and how the events are fired will all go into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">DamageTaken</span></strong><span class="koboSpan" id="kobo.536.1"> function. </span><span class="koboSpan" id="kobo.536.2">Note the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">FMath::Min</span></strong><span class="koboSpan" id="kobo.538.1"> to make sure the damage received never goes beyond the amount of health remaining. </span><span class="koboSpan" id="kobo.538.2">This could be easily altered to allow for </span><em class="italic"><span class="koboSpan" id="kobo.539.1">Doom</span></em><span class="koboSpan" id="kobo.540.1">-style forgiveness mechanics, where the player cannot be taken from &gt;1% health to 0% in one hit and can only die from 1% health. </span><span class="koboSpan" id="kobo.540.2">Alternatively, it could be removed to allow for overkill calculations if that matters </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">for gameplay:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.542.1">HealthComponent.cpp DamageTaken function</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.543.1">
UHealthComponent::DamageTaken(AActor* damagedActor,
    float damage, const UDamageType* dmgType,
    AController* instigator, AActor* causer)
{
    float change = FMath::Min(damage, _CurrentHealth);
    _CurrentHealth -= change;
    OnHealthDamaged.Broadcast(_CurrentHealth, _MaxHealth,
    change);
    if(_CurrentHealth == 0.f)
    {
        OnHealthDead.Broadcast(instigator);
}
}</span></pre> <p><span class="koboSpan" id="kobo.544.1">To make use of this component, you can now go to any actor and add this component to its hierarchy. </span><span class="koboSpan" id="kobo.544.2">It will automatically bind itself, and we have built in two events that can be bound to Blueprint and </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">C++ functi</span><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.546.1">ons.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">In the example </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.548.1">project, add the health component to the enemy unit </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">Blueprint Editor</span></strong><span class="koboSpan" id="kobo.550.1">. </span><span class="koboSpan" id="kobo.550.2">Create a listener for the </span><strong class="bold"><span class="koboSpan" id="kobo.551.1">OnHealthDead</span></strong><span class="koboSpan" id="kobo.552.1"> event by selecting the new component in the </span><strong class="bold"><span class="koboSpan" id="kobo.553.1">Hierarchy</span></strong><span class="koboSpan" id="kobo.554.1"> panel and clicking the plus button next to the event in the </span><strong class="bold"><span class="koboSpan" id="kobo.555.1">Details</span></strong><span class="koboSpan" id="kobo.556.1"> &gt; </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.557.1">Events</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.558.1"> panel.</span></span></p>
<p><span class="koboSpan" id="kobo.559.1">Link up the Blueprint functions in the red comment block marked </span><strong class="bold"><span class="koboSpan" id="kobo.560.1">Handle Unit Death</span></strong><span class="koboSpan" id="kobo.561.1"> as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.562.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.563.1">.19</span></em><span class="koboSpan" id="kobo.564.1">, and you will see that because the player has been built with the damage system in mind, you can now move about and destroy </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">enemy units.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer123">
<span class="koboSpan" id="kobo.566.1"><img alt="Figure 6.19  – The fully linked up event" src="image/Figure_06.19_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.567.1">Figure 6.19  – The fully linked up event</span></p>
<p><span class="koboSpan" id="kobo.568.1">This </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.569.1">functional example shows how event delegates can be used to communicate anonymously, thereby removing the need for object references everywhere. </span><span class="koboSpan" id="kobo.569.2">Using this communication method effectively helps to reduce the coupling of code bases, making them easier to maintain over time as more </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">are added.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.571.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.572.1">This chapter covers the two main methods of cleaning up communication in a code base. </span><span class="koboSpan" id="kobo.572.2">We have covered functional examples of how to use both interfaces and event delegates within our C++ setup, as well as the technical setup, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">U</span></strong><span class="koboSpan" id="kobo.574.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">I</span></strong><span class="koboSpan" id="kobo.576.1"> prefixes of an interface properly, and what each of the characteristics of a delegate mean. </span><span class="koboSpan" id="kobo.576.2">Now that the functional understanding is sorted, the next step should be to practice with these tools to get a better understanding of how they affect the code base. </span><span class="koboSpan" id="kobo.576.3">We will do this in the next chapter by looking at how we deploy both interfaces and event delegates with function calls, achieving a perfectly decoupled system where communication is as anonymous as possible. </span><span class="koboSpan" id="kobo.576.4">This naturally creates modular code design, allowing for much easier cohesion </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">within teams.</span></span></p>
</div>
</body></html>