<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-76"><a id="_idTextAnchor076"/>6</h1>
<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>Clean Communication  – Interface and Event Observer Patterns</h1>
<p>In this chapter, we will explore two design patterns that allow us to improve how actors communicate with each other. Utilizing the interface and event observer patterns to allow us to build better, cleaner communication solutions, reducing memory and processing cost of communication. To explore these, we will expand on the RTS game by implementing a health component that can be added to any actor. We will start by looking at interfaces in C++, following the concepts of the interface design pattern, and then explore the event observer pattern, with an exploration of Event Dispatchers in Blueprint and the implementation of event delegates in C++.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Interfacing communication across classes in UE5</li>
<li>Implementing event delegate communication across UE5</li>
</ul>
<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/>Technical requirements</h1>
<p>In this chapter, we will bring together the isolated systems we have built in previous chapters. Presuming you have followed along, you should be able to tie it all together in this chapter.</p>
<p>If you want to jump straight in at this point, you can download the <code>chapter6</code> branch from GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter06">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter06</a></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor079"/>Interfacing communication across classes in UE5</h1>
<p>Interfaces are <a id="_idIndexMarker214"/>a class that facilitates communication between different classes, without either class being aware of the other’s type. An interface class<a id="_idIndexMarker215"/> holds a set of common functions that can be implemented on any class through polymorphism.</p>
<p>To abstract this, let’s <a id="_idIndexMarker216"/>think about a ridiculous situation where you have a stack of pages, and you are asked to verify that it is indeed a copy of <em class="italic">War and Peace</em> that is just missing the cover. The only way to be truly sure is to compare each word on every page with a verified copy. This is time-consuming and along the lines of what Unreal Engine does when casting a class to another type.</p>
<p class="callout-heading">Important note</p>
<p class="callout">This isn’t exactly what the engine does. There are efficiencies built in that speed this process up, ensuring that it is not the entire class that is checked, but the point still remains that casting can be needless.</p>
<p>If we dig deeper into this hypothetical, knowing why you were asked to verify the book’s nature can make a big difference. If it was to verify the book’s integrity, then there is no way around it, but if the request was just to see whether a certain chapter existed, then we don’t need to do all that much work. Instead, we just need to look at the contents page, skip to the requested chapter, and read from there. This is what an interface does; it’s like the contents page of a book. The book promises that the required chapter will be in the area signposted by the contents page.</p>
<p>One of the most-used solutions to build cleaner methods of communication between two actors is to implement Blueprint interfaces, which remove the need to cast to an actor’s specific class, allowing you to use an actor reference instead. Let’s take a deeper look at Blueprint interfaces before we move on to interfaces in C++.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/>Blueprint interfaces</h2>
<p>We’ve previously made <a id="_idIndexMarker217"/>use of a <strong class="bold">Blueprint interface</strong> in <a href="B18297_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a> while improving the cascading cast chain problem, at which point we created a Blueprint interface, set up a function definition, and used it as a callable event on the various weapon Blueprints. The event was then called from the character Blueprint, allowing it to call the event on an attached weapon (a child actor component) without needing to cast the reference to a specific class, improving the efficiency of the system as well as reducing the memory impact.</p>
<p>So, from <a href="B18297_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, we already know how to create a Blueprint interface, create functions within the interface, and call them as events, but let’s look at a few of the features of a Blueprint interface that we haven’t encountered yet.</p>
<p>Let’s explore this using a new interface. Go ahead and create a new Blueprint interface asset, and call it <code>BI_Test</code>, as this is only a temporary class for exploration purposes.</p>
<p>Before we add any functions, let’s take <a id="_idIndexMarker218"/>a look at the various settings by clicking on <strong class="bold">Class Settings</strong> from the top menu, which will change the details panel to show a range of variables associated with the Blueprint class.</p>
<div><div><img alt="Figure 6.1 – The Blueprint interface Class Settings showing in the Details panel" src="img/Figure_06.01_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The Blueprint interface Class Settings showing in the Details panel</p>
<p>The two most beneficial settings <a id="_idIndexMarker219"/>when building systems are <strong class="bold">Blueprint Display Name</strong> and <strong class="bold">Blueprint Description</strong>, as both provide improvements to the user experience when working with Blueprint Interfaces. Without these being set, Unreal will display only the asset name and provide no description, which, while okay for a solo developer in the moment, is less helpful later in development or when working with other people.</p>
<p>In order to see the settings working for yourself, we suggest creating and using a test Blueprint class, <code>BP_Test</code>. This can then be deleted once you are confident you understand the settings.</p>
<p>Let’s take a look at how we set these up and what effect they have on the user experience.</p>
<h3>Blueprint Display Name</h3>
<p>The <strong class="bold">Blueprint Display Name</strong> setting<a id="_idIndexMarker220"/> provides a string input to allow you to define how the interface appears in the <strong class="bold">Class Settings</strong> of a Blueprint class when the interface has been implemented.</p>
<div><div><img alt="Figure 6.2 – Class Settings of a Blueprint ﻿class with an implement interface with and without a Blueprint Display Name" src="img/Figure_06.02_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Class Settings of a Blueprint class with an implement interface with and without a Blueprint Display Name</p>
<p><em class="italic">Figure 6</em><em class="italic">.2</em> shows the comparison between the class settings of a Blueprint class for the end user when implementing an interface with or without a <code>BI_Test</code>, in the left image, does not have a <code>implemented interfaces</code> list when the <code>BI_Test Blueprint</code> interface has been selected from the <strong class="bold">Add</strong> dropdown.</p>
<div><div><img alt="Figure 6.3 – The Blueprint Options rollout of BI_Test with the Blueprint Display Name set." src="img/Figure_06.03_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The Blueprint Options rollout of BI_Test with the Blueprint Display Name set.</p>
<p>This allows us, as <a id="_idIndexMarker221"/>systems designers, to maintain core naming conventions whilst ensuring that it is always clear what interface has been used in a format suitable for designers and other team members.</p>
<h3>Blueprint Description</h3>
<p>The <strong class="bold">Blueprint Description</strong> setting<a id="_idIndexMarker222"/> provides a string input, allowing you to define the mouseover hint when choosing an interface to implement, from the <strong class="bold">Add</strong> drop-down menu in the class settings of a Blueprint class.</p>
<div><div><img alt="Figure 6.4 – The class settings’ Add dropdown when selecting an interface to implement, with a Blueprint description" src="img/Figure_06.04_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The class settings’ Add dropdown when selecting an interface to implement, with a Blueprint description</p>
<p><em class="italic">Figure 6</em><em class="italic">.4</em> shows <a id="_idIndexMarker223"/>a comparison between the <code>BI_Test</code>, on the left-hand side of <em class="italic">Figure 6</em><em class="italic">.4</em>, does not have a Blueprint description. On the right-hand side, the Blueprint description has been set to <code>BI_Test</code> in the <strong class="bold">Add</strong> dropdown.</p>
<div><div><img alt="Figure 6.5 – The Blueprint Options rollout of BI_Test with the Blueprint Description set" src="img/Figure_06.05_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The Blueprint Options rollout of BI_Test with the Blueprint Description set</p>
<p>This allows us <a id="_idIndexMarker224"/>to make it clear, when selecting an interface, what it should be used for. The messages can include specifics such as <code>Required on all classes required to interact with doors</code> or more general messages, such as <code>Adds functions for shooting weapons</code>. The key here is to make sure the description helps other users identify what the interface provides.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>Interface events versus functions</h2>
<p>When adding <a id="_idIndexMarker225"/>functions to a Blueprint interface <em class="italic">functions</em> list, it can result <a id="_idIndexMarker226"/>in either a function or an event when implemented into a Blueprint class.</p>
<p>Using the <code>BI_Test</code> and <code>BP_Test</code> classes, we can explore the differences in a safe space. Let’s begin:</p>
<ol>
<li>Let’s start by adding two functions using the <code>ExampleEvent</code> and <code>ExampleFunction</code>.</li>
<li>Select <code>ExampleFunction</code> from the <em class="italic">functions</em> list, and add an output variable to the <strong class="bold">Outputs</strong> list by clicking the <strong class="bold">+</strong> icon.</li>
<li>Name the new variable <code>BoolOutput</code>, and set the type to <strong class="bold">Boolean</strong>.</li>
</ol>
<p>This will have created both an event, and a function for use in a Blueprint. Once you add an output variable, the function will behave as a Blueprint function, and without any outputs, it will act as an event.</p>
<div><div><img alt="Figure 6.6 – An interface function and interface event in a Blueprint class" src="img/Figure_06.06_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – An interface function and interface event in a Blueprint class</p>
<p>Note how the icon is different for a function (a gray icon) and an event (a yellow icon). This isn’t the only difference; adding logic to a function works differently to an event. Double-clicking on the<a id="_idIndexMarker227"/> event will result in an event node being<a id="_idIndexMarker228"/> added to the <strong class="bold">Event Graph</strong>:</p>
<div><div><img alt="Figure 6.7 – An interface event when added to the Event Graph" src="img/Figure_06.07_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – An interface event when added to the Event Graph</p>
<p>Double-clicking on the function will result in a new tab opening with the function graph, including a <strong class="bold">Return Node</strong>.</p>
<div><div><img alt="Figure 6.8 – An interface function with Return Node" src="img/Figure_06.08_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – An interface function with Return Node</p>
<p>When calling an interface function or event, they will appear slightly different in the Blueprint graph. The main differences are the icon and the inclusion of output exec pins (the white outlined arrows on the right-hand side of the node):</p>
<div><div><img alt="Figure 6.9 – A comparison of interface event and interface Function nodes in a Blueprint graph" src="img/Figure_06.09_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – A comparison of interface event and interface Function nodes in a Blueprint graph</p>
<p>There are two<a id="_idIndexMarker229"/> other possible visual results for Blueprint nodes from<a id="_idIndexMarker230"/> interface functions; these are compact nodes that occur when a Blueprint interface function has a <strong class="bold">Compact </strong><strong class="bold">Node Title</strong>.</p>
<p>To test these out, create<a id="_idIndexMarker231"/> two new functions in the <code>BI_Test</code> Blueprint interface; call these <code>ExampleCompactedEvent</code> and <code>ExampleCompactedFunction</code>, adding a Boolean variable to the output list as before. This time, however, set the Compact Node title of each function. For now, duplicate the function names with spaces between the words.</p>
<div><div><img alt="Figure 6.10 – Compacted node examples of an interface event and interface ﻿function on a Blueprint graph" src="img/Figure_06.10_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Compacted node examples of an interface event and interface function on a Blueprint graph</p>
<p>Compact nodes, when <a id="_idIndexMarker232"/>placed, appear as shown in <em class="italic">Figure 6</em><em class="italic">.10</em>. Compact nodes don’t have titles or pin names; these are not commonly used when working in Blueprint but are available if desired.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Interfaces in C++</h2>
<p>In C++, things get a <a id="_idIndexMarker233"/>little weird. The original core of Unreal is closer to Objective C than C++, and it shows the most when dealing with interfaces. It is advised that interfaces should be made from the editor, as there is so little that we need to add to the file from the template that typing it all out from scratch is a waste of time.</p>
<p>In the editor, open the section of your content for C++ classes. Right-click and add a new C++ class. When selecting what parent to inherit from, scroll to the bottom of the common classes and choose the <strong class="bold">Unreal Interface</strong>. This will create a new header file, like the following template:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Unreal interface template project specific elements replaced with tokens</p>
<pre class="source-code">
#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "&lt;class name&gt;.generated.h"
UINTERFACE(MinimalAPI)
class U&lt;class name&gt; : public UInterface
{
    GENERATED_BODY()
};
class &lt;module name&gt;_API I&lt;class name&gt;
{
    GENERATED_BODY()
public:
}</pre> <p>As you can see in the template, there are two classes in the same header file. The top class is created with your chosen class name, prefixed with a <em class="italic">U</em>. This inherits from the <code>UInterface</code> class and allows your class to become part of the Unreal interface system, working with functions such as <code>UKismetSystemLibrary::DoesImplementInterface</code>. The second class extends your module and has a similar name, except it starts with an <em class="italic">I</em> instead. This is the class you should add public functions to and multi-inherit from.</p>
<p>When calling a <a id="_idIndexMarker234"/>function from an interface, it is assumed that the reference held is not for the correct type of class and, instead, is most likely an <code>AActor*</code>. If this is not the case, then the interface provides no benefit, and the communication strategy should be rethought. Unreal provides a few ways of calling functions via interfaces. The two main methods are casting to the interface as a type and calling the instance of the function, or statically calling the function. Casting to the interface type is exactly as it sounds and would involve something like this:</p>
<pre class="source-code">
<code>if(IInterface* cachedRef = Cast&lt;IInterface&gt;(actorRef))</code>
<code>{ cachedRef-&gt;Function(arg1); }</code></pre> <p>Note how the <code>Cast</code> returns the casted pointer and a boolean value for the <code>if</code> statement. This works because an <code>if</code> on a pointer in Unreal will automatically check whether the pointer is not <code>nullptr</code>. However, it does still use a cast, no matter how small it may be. It is faster to use a static function call such as the following:</p>
<pre class="source-code">
<code>IInterface::Execute_Function(actorRef, arg1);</code></pre> <p>As you can see, this gets to the function call much faster and with less temporary variables declared. The trade-off is the security of the call. In this method, we assume that <code>actorRef</code> implements the interface that we call the function from. This assumption means that if the class in question doesn’t implement the needed interface we will get a logic error. The<a id="_idIndexMarker235"/> solution is to either design in a way that avoids this situation or to check for the interface without casting to it, using the aforementioned <code>DoesImplementInterface</code> function in <code>UKismetSystemLibrary</code>.</p>
<p>So, with these general concepts in mind, let’s look at creating our own interface in C++.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/>Building an example interface communication</h2>
<p>To implement something<a id="_idIndexMarker236"/> like the preceding example where actors can be flammable, we can start with an interface called <code>IFlammable</code> that will need a public virtual function called <code>Ignite</code>. This would look like the following:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Iflammable.h</p>
<pre class="source-code">
#include "CoreMinimal.h"
#include "UObject/Interface.h"
#include "flammable.generated.h"
UINTERFACE(MinimalAPI)
class UFlammable : public UInterface
{
    GENERATED_BODY()
};
class EXAMPLE_API IFlammable
{
    GENERATED_BODY()
public:
    virtual void Ignite();
}</pre> <p>To implement<a id="_idIndexMarker237"/> this in other classes, you simply need to use polymorphism and override the interface functions. The following example shows a tree actor multi-inheriting from the interface to implement it:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Excerpt from possible example flammable interface usage Tree.h</p>
<pre class="source-code">
#include "flammable.h"
UCLASS()
class Example_API ATree : public AActor, public IFlammable
{
    //other code
public:
    void Ignite() override;
}</pre> <p>On the calling side, if we had a flaming torch, we could add the following code to the collision handler for a collider around the flame particle:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Excerpt from possible flammable interface usage</p>
<pre class="source-code">
if(UKismetSystemLibrary::DoesImplementInterface(otherActor,     UFlammable::StaticClass()))
{
    IFlammable::Execute_Ignite(otherActor);
}</pre> <p>This code will let the torch ignite anything that is flammable and ignore everything that is not, without causing any errors or needing to do any unnecessary casting.</p>
<p>Interfaces, both in<a id="_idIndexMarker238"/> Blueprint and C++, offer us key benefits in keeping communication clean and efficient, allowing us to bundle up function names for use on implementing classes. Now that we’ve explored the benefits and the process to create both types of interface, we can look at another anonymous communication method – events.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Implementing event delegate communication across UE5</h1>
<p>The other <a id="_idIndexMarker239"/>form of anonymous communication is the event delegate. Delegates are essentially function pointers that allow us to change the flow of logic dynamically at runtime. When invoked, they allow a signal to be sent to potentially several other parts of a program, without the sender knowing where the signal has gone. Using these as part of an event-driven approach is called an event delegate.</p>
<p>Event delegates can be compared to a radio station. The delegate exists as the station, transmitting a signal into the air when it is told to. Then, there are radios that can choose to subscribe to the station, receiving the signal. This forms a one-to-many relationship, with one-way communication. The radios cannot send messages back to the station, and the station does not know how many radios are tuned in.</p>
<p>Like when we explored interfaces, let’s begin with the Blueprint implementation before moving on to the more complex C++ approach.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>Event delegates in Blueprint</h2>
<p>In Blueprint, delegates are made simple <a id="_idIndexMarker240"/>with one variant exposed. These are called <a id="_idIndexMarker241"/>Event Dispatchers. They do, however, function in the expected way.</p>
<p>Event Dispatchers need to be created in the class that will do the broadcasting (the radio station as such). We do this by clicking the <strong class="bold">+</strong> symbol in the <strong class="bold">EVENT DISPATCHERS</strong> dropdown of the <strong class="bold">My </strong><strong class="bold">Blueprint</strong> tab.</p>
<div><div><img alt="Figure 6.11 – The Event Dispatchers rollout within the My Blueprint tab" src="img/Figure_06.11_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – The Event Dispatchers rollout within the My Blueprint tab</p>
<p>An Event Dispatcher<a id="_idIndexMarker242"/> can have a series of inputs like any event in Blueprint. These are added at the top of the <strong class="bold">Details</strong> tab. You can also use the <strong class="bold">Copy signature from</strong><em class="italic"> </em>dropdown to select an existing event in the current Blueprint. This will duplicate all of the inputs from that event in the Event Dispatcher.</p>
<div><div><img alt="Figure 6.12 – Event Dispatcher variables and the Copy ﻿signature﻿ from dropdown" src="img/Figure_06.12_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Event Dispatcher variables and the Copy signature from dropdown</p>
<p>A Blueprint <a id="_idIndexMarker243"/>can respond to its own dispatcher in the same way that any listening delegate can respond. The dispatcher needs to be bound to an event, which then performs the desired response.</p>
<p>This is why, if you drag and drop the dispatcher from the Event Dispatchers list, onto the Blueprint graph, you will be presented with a popup containing <strong class="bold">Call</strong>, <strong class="bold">Bind</strong>, <strong class="bold">Unbind</strong>, <strong class="bold">Unbind all</strong>, <strong class="bold">Event</strong>, and <strong class="bold">Assign</strong>.</p>
<div><div><img alt="Figure 6.13 – The Event Dispatcher popup when dragged onto the Blueprint graph" src="img/Figure_06.13_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – The Event Dispatcher popup when dragged onto the Blueprint graph</p>
<p>These options are <a id="_idIndexMarker244"/>available wherever you choose to respond to a dispatcher (with the exception of an event). However, you will typically access them via the normal popup to create Blueprint nodes when dragging out from an object, which holds the dispatcher as a reference.</p>
<div><div><img alt="Figure 6.14 – The Blueprint context popup when searching for an Event Dispatcher by name, after dragging from a reference to a class that holds the Event Dispatcher" src="img/Figure_06.14_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – The Blueprint context popup when searching for an Event Dispatcher by name, after dragging from a reference to a class that holds the Event Dispatcher</p>
<p>Let’s explore each of the options we are presented with from these popups so that you know when and how to use them.</p>
<h3>Call</h3>
<p>The <strong class="bold">Call</strong> option <a id="_idIndexMarker245"/>activates the Event Dispatcher, sending the message to any subscribed delegates that are listening for the event. This is typically used on the Blueprint that has the event, but can be called from a separate Blueprint that has a direct reference to the actor with the dispatcher.</p>
<div><div><img alt="Figure 6.15 – A call dispatcher node with two variable inputs (Float and Bool)" src="img/Figure_06.15_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – A call dispatcher node with two variable inputs (Float and Bool)</p>
<p>The <strong class="bold">Bind</strong> option is <a id="_idIndexMarker246"/>used to identify which event should be run when the dispatcher is called; when used, the associated event is added to the list of events associated with the dispatcher. In Blueprint, the red line between the <strong class="bold">Bind Event to</strong> node and the <strong class="bold">Event</strong> node indicates which event it is to be bound to.</p>
<div><div><img alt="Figure 6.16 – A bind event node connected to a custom event ﻿that will be run when the Event Dispatcher is called" src="img/Figure_06.16_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – A bind event node connected to a custom event that will be run when the Event Dispatcher is called</p>
<p>This can be<a id="_idIndexMarker247"/> replaced by using a <strong class="bold">Create Event</strong> node, which can create a function or event with a matching signature (the same variables) or point toward an existing event. These are often used to try to keep the Blueprint graph tidy but are required to link to a function, as opposed to an event.</p>
<div><div><img alt="Figure 6.17–A bind event node connected to a Create Event node" src="img/Figure_06.17_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17–A bind event node connected to a Create Event node</p>
<h3>Unbind and Unbind all</h3>
<p>The <strong class="bold">Unbind</strong> node <a id="_idIndexMarker248"/>does the opposite of the bind node. When using <strong class="bold">Unbind</strong>, the event is removed from the list of events associated with the Event Dispatcher.</p>
<p>The <strong class="bold">Unbind all</strong> option<a id="_idIndexMarker249"/> does the same, but instead of just removing the linked event, it removes all events, nullifying the dispatcher from communicating with anything until another event is associated using a bind event node.</p>
<div><div><img alt="Figure 6.18 – The Unbind Event node, connected to a custom event, and an Unbind all Events node" src="img/Figure_06.18_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – The Unbind Event node, connected to a custom event, and an Unbind all Events node</p>
<p>The <strong class="bold">Bind</strong> and <strong class="bold">Unbind</strong> nodes allow us to dynamically link and unlink different events or functions to an Event Dispatcher, allowing us full control over what responds to a dispatcher at any point in the game.</p>
<h3>Event and Assign</h3>
<p>The <strong class="bold">Event</strong> and <strong class="bold">Assign</strong> options<a id="_idIndexMarker250"/> exist to help you create the nodes required to respond to an Event Dispatcher.</p>
<p>The <strong class="bold">Event</strong> option creates a <strong class="bold">Custom Event</strong> node with a matching signature, ready for you to connect to a bind event node later.</p>
<p>The <strong class="bold">Assign</strong> option <a id="_idIndexMarker251"/>creates both the Bind Event node and the matching custom event node, which can save a little bit of time when creating Blueprint logic.</p>
<p>Now that we have a grasp of the Blueprint implementation of events, let’s move on to exploring the C++ implementation.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/>Event delegates in C++</h2>
<p>In C++, event delegates <a id="_idIndexMarker252"/>are a little more complicated, but with that comes more control. For starters, there are a few different properties you can give each delegate before making events out of it. Let’s take a look at them:</p>
<ul>
<li><code>DYNAMIC</code>: This <a id="_idIndexMarker253"/>delegate can be serialized into the editor for easy Blueprint binding</li>
<li><code>MULTICAST</code>: This <a id="_idIndexMarker254"/>delegate can have multiple listeners at once and removes the ability to have a return value</li>
<li><code>SPARSE</code>: This<a id="_idIndexMarker255"/> delegate will not take up 1 byte in memory until it is subscribed to (this does make it slower to use, but it is more efficient for delegates that are rarely bound, such as a marketplace tool)</li>
</ul>
<p>After deciding how the delegate should behave, you need to declare it as a new type. This is described by the following pattern in all caps:</p>
<p><code>DECLARE_&lt;properties&gt;_DELEGATE_&lt;parameter amount&gt;(&lt;TypeName&gt;, &lt;arg1 type&gt;, &lt;arg1 </code><code>name&gt;… );</code></p>
<p>An example of this could be as follows:</p>
<p><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FExampleSignature, float, number, </code><code>AActor*, actorRef);</code></p>
<p>This delegate will be serialized into the editor, with possibly multiple bound functions. Each bound function will have two arguments of type <code>float</code> and <code>AActor*</code>. This is the closest in behavior to a Blueprint Event Dispatcher.</p>
<p>There is also another type of delegate called an event. This is a version of a multicast delegate, where the first argument is the owning type, only that type can have events as members, and only the defining object can broadcast the events. With this extra security, you can expose events as public without fear that a different class will broadcast the event. However, with that comes extra design challenges to make your systems work in a clean manner.</p>
<p class="callout-heading">Important note</p>
<p class="callout">From this point on, all event delegates used will be dynamic multicast to avoid confusion. This is not necessarily the best strategy, but it is a good starting point to then modify and restrict behavior later as needed.</p>
<p>That is how to define a new delegate type and create a new instance of a delegate from the type. To make delegates do something, you also need to know how to bind functions to them and fire them. This will change, depending on what properties were given to the event in it’s declaration.</p>
<p>Working our way through the different properties that a delegate has, we can see that non-dynamic delegates have eight different functions that can bind listening functions to them for each single and multicast. It is recommended that you use the <code>BindUObject</code> function for single-cast delegates and the <code>AddUObject</code> function for multicast delegates. These both take a reference <code>UObject*</code> as a first argument and a function address as the second, in the style: <code>&amp;ClassName::FunctionName</code>.</p>
<p>For dynamic delegates, there is less choice; single-cast dynamic delegates should use the <code>BindDynamic</code> function, and for multicast, it is advised you use the <code>AddUniqueDynamic</code> function, both with the same arguments as the non-dynamic delegates mentioned previously. The <code>AddDynamic()</code> function is ok to use with multicast dynamic delegates if you know the instance of the function has not already been bound to this delegate, otherwise it can be bound multiple times to the same event dispatcher.</p>
<p>Finally, to call delegates if they are single-cast, you should use the <code>ExecuteIfBound()</code> member function on the delegate, passing through arguments as necessary. For any multicast delegates, use the <code>Broadcast</code> member function. We will use a lot of multicast dynamic delegates when prototyping, as they offer the greatest flexibility to hook <a id="_idIndexMarker256"/>more listeners in as needed, leading us to make heavy use of the <code>Broadcast</code> function.</p>
<p>With the core concepts of delegates in C++ covered, let’s move on to creating our own event delegate.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>Building a useful delegate tool</h2>
<p>Let’s now look at building a<a id="_idIndexMarker257"/> useful class you can drop into any project. We will build on top of the damage system already present inside Unreal Engine. This utilizes a combination of an interface and the polymorphic nature of the engine, allowing you to deal damage to any actor and respond to damage from any actor. As an extension, we will look at making a Health Component that can sit on any actor, bind itself into this damage system automatically, and provide a couple of useful endpoints for any gameplay system to run with.</p>
<p>To start with, we need a new C++ class, so head to your C++ folder in the editor and make a new class based on <strong class="bold">Actor Component</strong>. Actor components are components for logic, as they have no associated rendering or transform within the world.</p>
<p class="callout-heading">Useful tip</p>
<p class="callout">If you are using Rider 2022 or later, then a right-click on your module base folder will give you the option to <strong class="bold">Add an Unreal Class</strong>. In the popup, you can select an actor component, and it will function the same way but without the need for the engine to be running.</p>
<p>The first thing<a id="_idIndexMarker258"/> to think about is what delegate definitions we will need. The obvious one is for when the component has run out of health and needs to let the owning actor know that it has died. This could probably pass through a reference to the controller that instigated the chain so that, eventually, the game mode can attribute points to the correct controller:</p>
<pre class="source-code">
<code>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FHealthDeadSignature, AController*, instigator);</code></pre> <p>The next useful piece of information to pass out to the component would be a signal whenever damage is dealt. There are a lot of options for what data to pass through. For instance, if the target is more of a <em class="italic">Call of Duty</em>-style game, you probably want to know what direction the damage was received from to feed that back to the player via some form of UI. In this instance, we will pass through information about the new and maximum health values, along with the change that just happened. This will let us update UI health bars and possibly spawn some damage numbers into the world:</p>
<pre class="source-code">
<code>DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams(FHealthDamagedSignature, float, newHealth, float, maxHealth, float, healthChange);</code></pre> <p>We can then look at the header definitions. The only items that need to be public are the constructor and one of each delegate type declared previously. In the protected section, we need some float variables to track the current and maximum health. These are marked as protected so that the reflection specified in the <code>UPROPERTY</code> tag will work with the editor. Along with these, we’ll use a <code>BeginPlay</code> override to set up some automatic behavior. Lastly, we’ll add a handler function to the private section. This will be used to hook into the damage interface system already present inside the actor this component is attached to. With<a id="_idIndexMarker259"/> that all written out, the class definition should look a little like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">HealthComponent.h class definition</p>
<pre class="source-code">
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class &lt;module name&gt;_API UHealthComponent : public UActorComponent
{
    GENERATED_BODY()
public:
    UHealthComponent();
    UPROPERTY(BlueprintAssignable)
    FHealthDeadSignature OnHealthDead;
    UPROPERTY(BlueprintAssignable)
    FHealthDamagedSignature OnHealthDamaged;
protected:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float _MaxHealth;
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    float _CurrentHealth;
    virtual void BeginPlay() override;
private:
    UFUNCTION()
    void DamageTaken(AActor* damagedActor, float damage,
        const UDamageType* dmgType, AController* instigator,
        AActor* causer);
};</pre> <p>After generating the definitions for these functions, we can add a default value for <code>maxHealth</code> into the constructor of maybe <code>100.f</code>, but this line isn’t too important. The <code>BeginPlay</code> override needs to bind our private <code>DamageTaken</code> function to the <code>OnTakeAnyDamage</code> event <a id="_idIndexMarker260"/>of the owning actor it is attached to, as well as setting the initial value for <code>_CurrentHealth</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">HealthComponent.cpp Constructor and BeginPlay</p>
<pre class="source-code">
UHealthComponent::UHealthComponent()
{
    _MaxHealth = 100.f;
}
void UHealthComponent::BeginPlay()
{
    Super::BeginPlay();
    _CurrentHealth = _MaxHealth;
    GetOwner()-&gt;OnTakeAnyDamage.AddDynamic         (this, &amp;UHealthComponent::DamageTaken);
}</pre> <p>Then, the logic for how damage is taken and how the events are fired will all go into the <code>DamageTaken</code> function. Note the use of <code>FMath::Min</code> to make sure the damage received never goes beyond the amount of health remaining. This could be easily altered to allow for <em class="italic">Doom</em>-style forgiveness mechanics, where the player cannot be taken from &gt;1% health to 0% in one hit and can only die from 1% health. Alternatively, it could be removed to allow for overkill calculations if that matters for gameplay:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">HealthComponent.cpp DamageTaken function</p>
<pre class="source-code">
UHealthComponent::DamageTaken(AActor* damagedActor,
    float damage, const UDamageType* dmgType,
    AController* instigator, AActor* causer)
{
    float change = FMath::Min(damage, _CurrentHealth);
    _CurrentHealth -= change;
    OnHealthDamaged.Broadcast(_CurrentHealth, _MaxHealth,
    change);
    if(_CurrentHealth == 0.f)
    {
        OnHealthDead.Broadcast(instigator);
}
}</pre> <p>To make use of this component, you can now go to any actor and add this component to its hierarchy. It will automatically bind itself, and we have built in two events that can be bound to Blueprint and C++ functi<a id="_idTextAnchor088"/>ons.</p>
<p>In the example <a id="_idIndexMarker261"/>project, add the health component to the enemy unit <strong class="bold">Blueprint Editor</strong>. Create a listener for the <strong class="bold">OnHealthDead</strong> event by selecting the new component in the <strong class="bold">Hierarchy</strong> panel and clicking the plus button next to the event in the <strong class="bold">Details</strong> &gt; <strong class="bold">Events</strong> panel.</p>
<p>Link up the Blueprint functions in the red comment block marked <strong class="bold">Handle Unit Death</strong> as shown in <em class="italic">Figure 6</em><em class="italic">.19</em>, and you will see that because the player has been built with the damage system in mind, you can now move about and destroy enemy units.</p>
<div><div><img alt="Figure 6.19  – The fully linked up event" src="img/Figure_06.19_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.19  – The fully linked up event</p>
<p>This <a id="_idIndexMarker262"/>functional example shows how event delegates can be used to communicate anonymously, thereby removing the need for object references everywhere. Using this communication method effectively helps to reduce the coupling of code bases, making them easier to maintain over time as more are added.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor089"/>Summary</h1>
<p>This chapter covers the two main methods of cleaning up communication in a code base. We have covered functional examples of how to use both interfaces and event delegates within our C++ setup, as well as the technical setup, using the <code>U</code> and <code>I</code> prefixes of an interface properly, and what each of the characteristics of a delegate mean. Now that the functional understanding is sorted, the next step should be to practice with these tools to get a better understanding of how they affect the code base. We will do this in the next chapter by looking at how we deploy both interfaces and event delegates with function calls, achieving a perfectly decoupled system where communication is as anonymous as possible. This naturally creates modular code design, allowing for much easier cohesion within teams.</p>
</div>
</body></html>