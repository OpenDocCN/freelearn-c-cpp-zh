["```cpp\n\nMODULE Gcd;\nPROCEDURE GCD(a, b: INTEGER) : INTEGER;\nVAR t: INTEGER;\nBEGIN\n  IF b = 0 THEN\n    RETURN a;\n  END;\n  WHILE b # 0 DO\n    t := a MOD b;\n    a := b;\n    b := t;\n  END;\n  RETURN a;\nEND GCD;\nEND Gcd.\n```", "```cpp\n\ncompilationUnit\n  : \"MODULE\" identifier \";\" ( import )* block identifier \".\" ;\nImport : ( \"FROM\" identifier )? \"IMPORT\" identList \";\" ;\nBlock\n  : ( declaration )* ( \"BEGIN\" statementSequence )? \"END\" ;\n```", "```cpp\n\ndeclaration\n  : \"CONST\" ( constantDeclaration \";\" )*\n  | \"VAR\" ( variableDeclaration \";\" )*\n  | procedureDeclaration \";\" ;\n```", "```cpp\n\nconstantDeclaration : identifier \"=\" expression ;\n```", "```cpp\n\nvariableDeclaration : identList \":\" qualident ;\nqualident : identifier ( \".\" identifier )* ;\nidentList : identifier ( \",\" identifier)* ;\n```", "```cpp\n\nprocedureDeclaration\n  : \"PROCEDURE\" identifier ( formalParameters )? \";\"\n    block identifier ;\nformalParameters\n  : \"(\" ( formalParameterList )? \")\" ( \":\" qualident )? ;\nformalParameterList\n  : formalParameter (\";\" formalParameter )* ;\nformalParameter : ( \"VAR\" )? identList \":\" qualident ;\n```", "```cpp\n\nstatementSequence\n  : statement ( \";\" statement )* ;\n```", "```cpp\n\nstatement\n  : qualident ( \":=\" expression | ( \"(\" ( expList )? \")\" )? )\n  | ifStatement | whileStatement | \"RETURN\" ( expression )? ;\n```", "```cpp\n\nifStatement\n  : \"IF\" expression \"THEN\" statementSequence\n    ( \"ELSE\" statementSequence )? \"END\" ;\n```", "```cpp\n\nwhileStatement\n  : \"WHILE\" expression \"DO\" statementSequence \"END\" ;\n```", "```cpp\n\nexpList\n  : expression ( \",\" expression )* ;\nexpression\n  : simpleExpression ( relation simpleExpression )? ;\nrelation\n  : \"=\" | \"#\" | \"<\" | \"<=\" | \">\" | \">=\" ;\nsimpleExpression\n  : ( \"+\" | \"-\" )? term ( addOperator term )* ;\naddOperator\n  : \"+\" | \"-\" | \"OR\" ;\nterm\n  : factor ( mulOperator factor )* ;\nmulOperator\n  : \"*\" | \"/\" | \"DIV\" | \"MOD\" | \"AND\" ;\nfactor\n  : integer_literal | \"(\" expression \")\" | \"NOT\" factor\n  | qualident ( \"(\" ( expList )? \")\" )? ;\n```", "```cpp\n\n#ifndef DIAG\n#define DIAG(ID, Level, Msg)\n#endif\nDIAG(err_sym_declared, Error, \"symbol {0} already declared\")\n#undef DIAG\n```", "```cpp\n\n#ifndef TINYLANG_BASIC_DIAGNOSTIC_H\n#define TINYLANG_BASIC_DIAGNOSTIC_H\n#include \"tinylang/Basic/LLVM.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <utility>\nnamespace tinylang {\n```", "```cpp\n\nnamespace diag {\nenum {\n#define DIAG(ID, Level, Msg) ID,\n#include \"tinylang/Basic/Diagnostic.def\"\n};\n} // namespace diag\n```", "```cpp\n\nclass DiagnosticsEngine {\n  static const char *getDiagnosticText(unsigned DiagID);\n  static SourceMgr::DiagKind\n  getDiagnosticKind(unsigned DiagID);\n```", "```cpp\n\n  SourceMgr &SrcMgr;\n  unsigned NumErrors;\npublic:\n  DiagnosticsEngine(SourceMgr &SrcMgr)\n      : SrcMgr(SrcMgr), NumErrors(0) {}\n  unsigned nunErrors() { return NumErrors; }\n```", "```cpp\n\n  template <typename... Args>\n  void report(SMLoc Loc, unsigned DiagID,\n              Args &&... Arguments) {\n    std::string Msg =\n        llvm::formatv(getDiagnosticText(DiagID),\n                      std::forward<Args>(Arguments)...)\n            .str();\n    SourceMgr::DiagKind Kind = getDiagnosticKind(DiagID);\n    SrcMgr.PrintMessage(Loc, Kind, Msg);\n    NumErrors += (Kind == SourceMgr::DK_Error);\n  }\n};\n} // namespace tinylang\n#endif\n```", "```cpp\n\n#include \"tinylang/Basic/Diagnostic.h\"\nusing namespace tinylang;\nnamespace {\nconst char *DiagnosticText[] = {\n#define DIAG(ID, Level, Msg) Msg,\n#include \"tinylang/Basic/Diagnostic.def\"\n};\n```", "```cpp\n\nSourceMgr::DiagKind DiagnosticKind[] = {\n#define DIAG(ID, Level, Msg) SourceMgr::DK_##Level,\ninclude \"tinylang/Basic/Diagnostic.def\"\n};\n} // namespace\n```", "```cpp\n\nconst char *\nDiagnosticsEngine::getDiagnosticText(unsigned DiagID) {\n  return DiagnosticText[DiagID];\n}\nSourceMgr::DiagKind\nDiagnosticsEngine::getDiagnosticKind(unsigned DiagID) {\n  return DiagnosticKind[DiagID];\n}\n```", "```cpp\n\n#ifndef TOK\n#define TOK(ID)\n#endif\n#ifndef PUNCTUATOR\n#define PUNCTUATOR(ID, SP) TOK(ID)\n#endif\n#ifndef KEYWORD\n#define KEYWORD(ID, FLAG) TOK(kw_ ## ID)\n#endif\nTOK(unknown)\nTOK(eof)\nTOK(identifier)\nTOK(integer_literal)\nPUNCTUATOR(plus,                \"+\")\nPUNCTUATOR(minus,               \"-\")\n// …\nKEYWORD(BEGIN                       , KEYALL)\nKEYWORD(CONST                       , KEYALL)\n// …\n#undef KEYWORD\n#undef PUNCTUATOR\n#undef TOK\n```", "```cpp\n\n#ifndef TINYLANG_BASIC_TOKENKINDS_H\n#define TINYLANG_BASIC_TOKENKINDS_H\nnamespace tinylang {\n  namespace tok {\n    enum TokenKind : unsigned short {\n#define TOK(ID) ID,\n#include \"TokenKinds.def\"\n      NUM_TOKENS\n    };\n```", "```cpp\n\n    const char *getTokenName(TokenKind Kind);\n    const char *getPunctuatorSpelling(TokenKind Kind);\n    const char *getKeywordSpelling(TokenKind Kind);\n  }\n}\n#endif\n```", "```cpp\n\n#include \"tinylang/Basic/TokenKinds.h\"\n#include \"llvm/Support/ErrorHandling.h\"\nusing namespace tinylang;\nstatic const char * const TokNames[] = {\n#define TOK(ID) #ID,\n#define KEYWORD(ID, FLAG) #ID,\n#include \"tinylang/Basic/TokenKinds.def\"\n  nullptr\n};\n```", "```cpp\n\n    const char *tok::getTokenName(TokenKind Kind) {\n      return TokNames[Kind];\n    }\n    ```", "```cpp\n\nconst char *tok::getPunctuatorSpelling(TokenKind Kind) {\n  switch (Kind) {\n#define PUNCTUATOR(ID, SP) case ID: return SP;\n#include \"tinylang/Basic/TokenKinds.def\"\n    default: break;\n  }\n  return nullptr;\n}\nconst char *tok::getKeywordSpelling(TokenKind Kind) {\n  switch (Kind) {\n#define KEYWORD(ID, FLAG) case kw_ ## ID: return #ID;\n#include \"tinylang/Basic/TokenKinds.def\"\n    default: break;\n  }\n  return nullptr;\n}\n```", "```cpp\n\nclass Token {\n  friend class Lexer;\n  const char *Ptr;\n  size_t Length;\n  tok::TokenKind Kind;\npublic:\n  tok::TokenKind getKind() const { return Kind; }\n  size_t getLength() const { return Length; }\n```", "```cpp\n\n  SMLoc getLocation() const {\n    return SMLoc::getFromPointer(Ptr);\n  }\n```", "```cpp\n\n  StringRef getIdentifier() {\n    assert(is(tok::identifier) &&\n           \"Cannot get identfier of non-identifier\");\n    return StringRef(Ptr, Length);\n  }\n  StringRef getLiteralData() {\n    assert(isOneOf(tok::integer_literal,\n                   tok::string_literal) &&\n           \"Cannot get literal data of non-literal\");\n    return StringRef(Ptr, Length);\n  }\n};\n```", "```cpp\n\n        case '<':\n          if (*(CurPtr + 1) == '=')\n            formTokenWithChars(token, CurPtr + 2,\n                               tok::lessequal);\n          else\n            formTokenWithChars(token, CurPtr + 1, tok::less);\n          break;\n    ```", "```cpp\n\n    class KeywordFilter {\n      llvm::StringMap<tok::TokenKind> HashTable;\n      void addKeyword(StringRef Keyword,\n                      tok::TokenKind TokenCode);\n    public:\n      void addKeywords();\n    ```", "```cpp\n      tok::TokenKind getKeyword(\n          StringRef Name,\n          tok::TokenKind DefaultTokenCode = tok::unknown) {\n        auto Result = HashTable.find(Name);\n        if (Result != HashTable.end())\n          return Result->second;\n        return DefaultTokenCode;\n      }\n    };\n    ```", "```cpp\n    void KeywordFilter::addKeyword(StringRef Keyword,\n                                   tok::TokenKind TokenCode) {\n      HashTable.insert(std::make_pair(Keyword, TokenCode));\n    }\n    void KeywordFilter::addKeywords() {\n    #define KEYWORD(NAME, FLAGS)                               \\\n      addKeyword(StringRef(#NAME), tok::kw_##NAME);\n    #include \"tinylang/Basic/TokenKinds.def\"\n    }\n    ```", "```cpp\n\nifStatement\n  : \"IF\" expression \"THEN\" statementSequence\n    ( \"ELSE\" statementSequence )? \"END\" ;\n```", "```cpp\n\nvoid Parser::parseIfStatement() {\n  consume(tok::kw_IF);\n  parseExpression();\n  consume(tok::kw_THEN);\n  parseStatementSequence();\n  if (Tok.is(tok::kw_ELSE)) {\n    advance();\n    parseStatementSequence();\n  }\n  consume(tok::kw_END);\n}\n```", "```cpp\n\nexpression : expression \"+\" term ;\n```", "```cpp\n\nVoid Parser::parseExpression() {\n  parseExpression();\n  consume(tok::plus);\n  parseTerm();\n}\n```", "```cpp\n\nusingStmt : \"using\" (ident \"=\")? ident \";\"\n```", "```cpp\n\nusingStmt : \"using\" ( ident \"=\" ident | ident ) \";\" ;\n```", "```cpp\n\nusingStmt : \"using\" ident (\"=\" ident)? \";\" ;\n```", "```cpp\n\nif (Tok.is(tok::ident) && Lex.peek(0).is(tok::equal)) {\n  advance();\n  consume(tok::equal);\n}\nconsume(tok::ident);\n```", "```cpp\n\nbool Parser::parseIfStatement() {\n  auto _errorhandler = [this] {\n    return skipUntil(tok::semi, tok::kw_ELSE, tok::kw_END);\n  };\n  if (consume(tok::kw_IF))\n    return _errorhandler();\n  if (parseExpression(E))\n    return _errorhandler();\n  if (consume(tok::kw_THEN))\n    return _errorhandler();\n  if (parseStatementSequence(IfStmts))\n    return _errorhandler();\n  if (Tok.is(tok::kw_ELSE)) {\n    advance();\n    if (parseStatementSequence(ElseStmts))\n      return _errorhandler();\n  }\n  if (expect(tok::kw_END))\n    return _errorhandler();\n  return false;\n}\n```", "```cpp\n\nVAR B, X: INTEGER;\n```", "```cpp\n\nPROCEDURE Proc;\nVAR B: BOOLEAN;\nBEGIN\n  (* Statements *)\nEND Proc;\n```", "```cpp\n\n#ifndef TINYLANG_SEMA_SCOPE_H\n#define TINYLANG_SEMA_SCOPE_H\n#include \"tinylang/Basic/LLVM.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\nnamespace tinylang {\nclass Decl;\nclass Scope {\n  Scope *Parent;\n  StringMap<Decl *> Symbols;\npublic:\n  Scope(Scope *Parent = nullptr) : Parent(Parent) {}\n  bool insert(Decl *Declaration);\n  Decl *lookup(StringRef Name);\n  Scope *getParent() { return Parent; }\n};\n} // namespace tinylang\n#endif\n```", "```cpp\n\n#include \"tinylang/Sema/Scope.h\"\n#include \"tinylang/AST/AST.h\"\nusing namespace tinylang;\nbool Scope::insert(Decl *Declaration) {\n  return Symbols\n      .insert(std::pair<StringRef, Decl *>(\n          Declaration->getName(), Declaration))\n      .second;\n}\n```", "```cpp\n\nDecl *Scope::lookup(StringRef Name) {\n  Scope *S = this;\n  while (S) {\n    StringMap<Decl *>::const_iterator I =\n        S->Symbols.find(Name);\n    if (I != S->Symbols.end())\n      return I->second;\n    S = S->getParent();\n  }\n  return nullptr;\n}\n```", "```cpp\n\nclass Decl {\npublic:\n  enum DeclKind { DK_Module, DK_Const, DK_Type,\n                  DK_Var, DK_Param, DK_Proc };\nprivate:\n  const DeclKind Kind;\npublic:\n  DeclKind getKind() const { return Kind; }\n};\n```", "```cpp\n\nstatic bool classof(const Decl *D) {\n  return D->getKind() == DK_Var;\n}\n```", "```cpp\n\nclass Decl {\npublic:\n  enum DeclKind { DK_Module, DK_Const, DK_Type,\n                  DK_Var, DK_Param, DK_Proc };\nprivate:\n  const DeclKind Kind;\nprotected:\n  Decl *EnclosingDecL;\n  SMLoc Loc;\n  StringRef Name;\npublic:\n  Decl(DeclKind Kind, Decl *EnclosingDecL, SMLoc Loc,\n       StringRef Name)\n      : Kind(Kind), EnclosingDecL(EnclosingDecL), Loc(Loc),\n        Name(Name) {}\n  DeclKind getKind() const { return Kind; }\n  SMLoc getLocation() { return Loc; }\n  StringRef getName() { return Name; }\n  Decl *getEnclosingDecl() { return EnclosingDecL; }\n};\n```", "```cpp\n\nclass TypeDeclaration;\nclass VariableDeclaration : public Decl {\n  TypeDeclaration *Ty;\npublic:\n  VariableDeclaration(Decl *EnclosingDecL, SMLoc Loc,\n                      StringRef Name, TypeDeclaration *Ty)\n      : Decl(DK_Var, EnclosingDecL, Loc, Name), Ty(Ty) {}\n  TypeDeclaration *getType() { return Ty; }\n  static bool classof(const Decl *D) {\n    return D->getKind() == DK_Var;\n  }\n};\n```", "```cpp\n\nbool Parser::parseVariableDeclaration(DeclList &Decls) {\n  auto _errorhandler = [this] {\n    while (!Tok.is(tok::semi)) {\n      advance();\n      if (Tok.is(tok::eof)) return true;\n    }\n    return false;\n  };\n  Decl *D = nullptr; IdentList Ids;\n  if (parseIdentList(Ids)) return _errorhandler();\n  if (consume(tok::colon)) return _errorhandler();\n  if (parseQualident(D)) return _errorhandler();\n  Actions.actOnVariableDeclaration(Decls, Ids, D);\n  return false;\n}\n```", "```cpp\n\nvoid Sema::actOnVariableDeclaration(DeclList &Decls,\n                                    IdentList &Ids,\n                                    Decl *D) {\n  if (TypeDeclaration *Ty = dyn_cast<TypeDeclaration>(D)) {\n    for (auto &[Loc, Name] : Ids) {\n      auto *Decl = new VariableDeclaration(CurrentDecl, Loc,\n                                           Name, Ty);\n      if (CurrentScope->insert(Decl))\n        Decls.push_back(Decl);\n      else\n        Diags.report(Loc, diag::err_symbold_declared, Name);\n    }\n  } else if (!Ids.empty()) {\n    SMLoc Loc = Ids.front().first;\n    Diags.report(Loc, diag::err_vardecl_requires_type);\n  }\n}\n```", "```cpp\n\nvoid Sema::enterScope(Decl *D) {\n  CurrentScope = new Scope(CurrentScope);\n  CurrentDecl = D;\n}\nvoid Sema::leaveScope() {\n  Scope *Parent = CurrentScope->getParent();\n  delete CurrentScope;\n  CurrentScope = Parent;\n  CurrentDecl = CurrentDecl->getEnclosingDecl();\n}\n```", "```cpp\n\nclass EnterDeclScope {\n  Sema &Semantics;\npublic:\n  EnterDeclScope(Sema &Semantics, Decl *D)\n      : Semantics(Semantics) {\n    Semantics.enterScope(D);\n  }\n  ~EnterDeclScope() { Semantics.leaveScope(); }\n};\n```", "```cpp\n\nbool Parser::parseProcedureDeclaration(/* … */) {\n  /* … */\n  if (consume(tok::kw_PROCEDURE)) return _errorhandler();\n  if (expect(tok::identifier)) return _errorhandler();\n  ProcedureDeclaration *D =\n      Actions.actOnProcedureDeclaration(\n          Tok.getLocation(), Tok.getIdentifier());\n  EnterDeclScope S(Actions, D);\n  /* … */\n}\n```", "```cpp\n\nProcedureDeclaration *\nSema::actOnProcedureDeclaration(SMLoc Loc, StringRef Name) {\n  ProcedureDeclaration *P =\n      new ProcedureDeclaration(CurrentDecl, Loc, Name);\n  if (!CurrentScope->insert(P))\n    Diags.report(Loc, diag::err_symbold_declared, Name);\n  return P;\n}\n```", "```cpp\n\nvoid Sema::actOnProcedureDeclaration(\n    ProcedureDeclaration *ProcDecl, SMLoc Loc,\n    StringRef Name, FormalParamList &Params, Decl *RetType,\n    DeclList &Decls, StmtList &Stmts) {\n  if (Name != ProcDecl->getName()) {\n    Diags.report(Loc, diag::err_proc_identifier_not_equal);\n    Diags.report(ProcDecl->getLocation(),\n                 diag::note_proc_identifier_declaration);\n  }\n  ProcDecl->setDecls(Decls);\n  ProcDecl->setStmts(Stmts);\n  auto *RetTypeDecl =\n      dyn_cast_or_null<TypeDeclaration>(RetType);\n  if (!RetTypeDecl && RetType)\n    Diags.report(Loc, diag::err_returntype_must_be_type,\n                 Name);\n  else\n    ProcDecl->setRetType(RetTypeDecl);\n}\n```", "```cpp\n\nvoid Sema::initialize() {\n  CurrentScope = new Scope();\n  CurrentDecl = nullptr;\n  IntegerType =\n      new TypeDeclaration(CurrentDecl, SMLoc(), \"INTEGER\");\n  BooleanType =\n      new TypeDeclaration(CurrentDecl, SMLoc(), \"BOOLEAN\");\n  TrueLiteral = new BooleanLiteral(true, BooleanType);\n  FalseLiteral = new BooleanLiteral(false, BooleanType);\n  TrueConst = new ConstantDeclaration(CurrentDecl, SMLoc(),\n                                      \"TRUE\", TrueLiteral);\n  FalseConst = new ConstantDeclaration(\n      CurrentDecl, SMLoc(), \"FALSE\", FalseLiteral);\n  CurrentScope->insert(IntegerType);\n  CurrentScope->insert(BooleanType);\n  CurrentScope->insert(TrueConst);\n  CurrentScope->insert(FalseConst);\n}\n```", "```cpp\n\n#include \"tinylang/Basic/Diagnostic.h\"\n#include \"tinylang/Basic/Version.h\"\n#include \"tinylang/Parser/Parser.h\"\n#include \"llvm/Support/InitLLVM.h\"\n#include \"llvm/Support/raw_ostream.h\"\nusing namespace tinylang;\nint main(int argc_, const char **argv_) {\n  llvm::InitLLVM X(argc_, argv_);\n  llvm::SmallVector<const char *, 256> argv(argv_ + 1,\n                                            argv_ + argc_);\n  llvm::outs() << \"Tinylang \"\n               << tinylang::getTinylangVersion() << \"\\n\";\n  for (const char *F : argv) {\n    llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>\n        FileOrErr = llvm::MemoryBuffer::getFile(F);\n    if (std::error_code BufferError =\n            FileOrErr.getError()) {\n      llvm::errs() << \"Error reading \" << F << \": \"\n                   << BufferError.message() << \"\\n\";\n      continue;\n    }\n    llvm::SourceMgr SrcMgr;\n    DiagnosticsEngine Diags(SrcMgr);\n    SrcMgr.AddNewSourceBuffer(std::move(*FileOrErr),\n                              llvm::SMLoc());\n    auto TheLexer = Lexer(SrcMgr, Diags);\n    auto TheSema = Sema(Diags);\n    auto TheParser = Parser(TheLexer, TheSema);\n    TheParser.parse();\n  }\n}\n```", "```cpp\n\n$ tinylang Gcd.mod\n```"]