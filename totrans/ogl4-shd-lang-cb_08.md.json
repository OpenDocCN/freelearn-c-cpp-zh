["```cpp\nGLfloat border[]={1.0f,0.0f,0.0f,0.0f}; \n\n//The shadowmap texture \nGLuint depthTex; \nglGenTextures(1,&depthTex); \nglBindTexture(GL_TEXTURE_2D,depthTex); \nglTexStorage2D(GL_TEXTURE_2D, 1, GL_DEPTH_COMPONENT24, \n               shadowMapWidth, shadowMapHeight); \nglTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, \n                GL_NEAREST); \nglTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, \n                GL_NEAREST); \nglTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S, \n                GL_CLAMP_TO_BORDER); \nglTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T, \n                GL_CLAMP_TO_BORDER); \nglTexParameterfv(GL_TEXTURE_2D,GL_TEXTURE_BORDER_COLOR, \n                 border); \n\nglTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_COMPARE_MODE, \n                GL_COMPARE_REF_TO_TEXTURE); \nglTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_COMPARE_FUNC, \n                GL_LESS); \n\n//Assign the shadow map to texture unit 0 \nglActiveTexture(GL_TEXTURE0); \nglBindTexture(GL_TEXTURE_2D,depthTex); \n\n//Create and set up the FBO \nglGenFramebuffers(1,&shadowFBO); \nglBindFramebuffer(GL_FRAMEBUFFER,shadowFBO); \nglFramebufferTexture2D(GL_FRAMEBUFFER,GL_DEPTH_ATTACHMENT, \n                       GL_TEXTURE_2D,depthTex,0); \nGLenum drawBuffers[]={GL_NONE}; \nglDrawBuffers(1,drawBuffers); \n// Revert to the default framebuffer for now \nglBindFramebuffer(GL_FRAMEBUFFER,0); \n```", "```cpp\nlayout (location=0) in vec3 VertexPosition; \nlayout (location=1) in vec3 VertexNormal; \n\nout vec3 Normal;     \nout vec3 Position;    \n\n// Coordinate to be used for shadow map lookup \nout vec4 ShadowCoord; \n\nuniform mat4 ModelViewMatrix; \nuniform mat3 NormalMatrix; \nuniform mat4 MVP; \nuniform mat4 ShadowMatrix; \n\nvoid main() {\n    Position = (ModelViewMatrix *  \n                vec4(VertexPosition,1.0)).xyz; \n    Normal = normalize( NormalMatrix * VertexNormal ); \n\n    // ShadowMatrix converts from modeling coordinates \n    // to shadow map coordinates. \n    ShadowCoord =ShadowMatrix * vec4(VertexPosition,1.0); \n\n    gl_Position = MVP * vec4(VertexPosition,1.0); \n}\n```", "```cpp\n// Declare any uniforms needed for your shading model \nuniform sampler2DShadow ShadowMap; \n\nin vec3 Position; \nin vec3 Normal; \nin vec4 ShadowCoord; \n\nlayout (location = 0) out vec4 FragColor; \n\nvec3 diffAndSpec() {\n   // Compute only the diffuse and specular components of \n   // the shading model. \n} \n\nsubroutine void RenderPassType(); \nsubroutine uniform RenderPassType RenderPass; \n\nsubroutine (RenderPassType) \nvoid shadeWithShadow() {\n  vec3 ambient = ...; // compute ambient component here \n  vec3 diffSpec = diffAndSpec(); \n\n  // Do the shadow-map look-up \n  float shadow = textureProj(ShadowMap, ShadowCoord); \n\n  // If the fragment is in shadow, use ambient light only. \n  FragColor = vec4(diffSpec * shadow + ambient, 1.0); \n} \nsubroutine (RenderPassType) \nvoid recordDepth() {\n    // Do nothing, depth will be written automatically \n} \n\nvoid main() { \n  // This will call either shadeWithShadow or recordDepth \n  RenderPass(); \n} \n```", "```cpp\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,  \n                GL_LINEAR); \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,      \n                GL_LINEAR); \n```", "```cpp\nsubroutine (RenderPassType) \nvoid shadeWithShadow() {\n  vec3 ambient = vec3(0.2); \n  vec3 diffSpec = diffAndSpec(); \n\n  // The sum of the comparisons with nearby texels \n  float sum = 0; \n\n  // Sum contributions from texels around ShadowCoord \n  sum += textureProjOffset(ShadowMap, ShadowCoord,  \n                           ivec2(-1,-1)); \n  sum += textureProjOffset(ShadowMap, ShadowCoord,  \n                           ivec2(-1,1)); \n  sum += textureProjOffset(ShadowMap, ShadowCoord,  \n                           ivec2(1,1)); \n  sum += textureProjOffset(ShadowMap, ShadowCoord,  \n                           ivec2(1,-1)); \n  float shadow = sum * 0.25; \n\n  FragColor = vec4(ambient + diffSpec * shadow,1.0); \n} \n```", "```cpp\nvoid buildOffsetTex(int size, int samplesU, int samplesV) {\n  int samples = samplesU * samplesV; \n  int bufSize = size * size * samples * 2; \n  float *data = new float[bufSize]; \n\n  for( int i = 0; i< size; i++ ) { \n    for(int j = 0; j < size; j++ ) { \n      for( int k = 0; k < samples; k += 2 ) { \n        int x1,y1,x2,y2; \n        x1 = k % (samplesU); \n        y1 = (samples - 1 - k) / samplesU; \n        x2 = (k+1) % samplesU; \n        y2 = (samples - 1 - k - 1) / samplesU; \n\n        glm::vec4 v; \n        // Center on grid and jitter \n        v.x = (x1 + 0.5f) + jitter(); \n        v.y = (y1 + 0.5f) + jitter(); \n        v.z = (x2 + 0.5f) + jitter(); \n        v.w = (y2 + 0.5f) + jitter(); \n        // Scale between 0 and 1 \n        v.x /= samplesU; \n        v.y /= samplesV; \n        v.z /= samplesU; \n        v.w /= samplesV; \n        // Warp to disk \n        int cell = ((k/2) * size * size + j *  \n                    size + i) * 4; \n        data[cell+0] = glm::sqrt(v.y) * glm::cos(glm::two_pi<float>\n        ()*v.x); \n        data[cell+1] = glm::sqrt(v.y) * glm::sin(glm::two_pi<float>\n        ()*v.x); \n        data[cell+2] = glm::sqrt(v.w) * glm::cos(glm::two_pi<float>\n        ()*v.z); \n        data[cell+3] = glm::sqrt(v.w) * glm::sin(glm::two_pi<float>\n        ()*v.z); \n      } \n    } \n  } \n\n  glActiveTexture(GL_TEXTURE1); \n  GLuint texID; \n  glGenTextures(1, &texID); \n\n  glBindTexture(GL_TEXTURE_3D, texID); \n  glTexStorage3D(GL_TEXTURE_3D, 1, GL_RGBA32F, size, size, \n                 samples/2); \n  glTexSubImage3D(GL_TEXTURE_3D, 0, 0, 0, 0, size, size,  \n                 samples/2, GL_RGBA, GL_FLOAT, data); \n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER,  \n                    GL_NEAREST); \n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER,  \n                    GL_NEAREST); \n\n  delete [] data; \n} \n\n// Return random float between -0.5 and 0.5 \nfloat jitter() { \n  static std::default_random_engine generator;\n  static std::uniform_real_distribution<float> distrib(-0.5f, 0.5f); \n  return distrib(generator); \n}\n```", "```cpp\nuniform sampler3D OffsetTex; \nuniform vec3 OffsetTexSize; // (width, height, depth) \nuniform float Radius;\n```", "```cpp\nsubroutine (RenderPassType) \nvoid shadeWithShadow() {\n  vec3 ambient = vec3(0.2); \n  vec3 diffSpec = diffAndSpec(); \n\n  ivec3 offsetCoord; \n  offsetCoord.xy = ivec2( mod( gl_FragCoord.xy,  \n                         OffsetTexSize.xy ) ); \n\n  float sum = 0.0; \n  int samplesDiv2 = int(OffsetTexSize.z); \n  vec4 sc = ShadowCoord; \n\n  for( int i = 0 ; i< 4; i++ ) { \n    offsetCoord.z = i; \n    vec4 offsets = texelFetch(OffsetTex,offsetCoord,0) *  \n                       Radius * ShadowCoord.w; \n\n    sc.xy = ShadowCoord.xy + offsets.xy; \n    sum += textureProj(ShadowMap, sc); \n    sc.xy = ShadowCoord.xy + offsets.zw; \n    sum += textureProj(ShadowMap, sc); \n  } \n  float shadow = sum / 8.0; \n\n  if( shadow != 1.0 && shadow != 0.0 ) { \n    for( int i = 4; i< samplesDiv2; i++ ) { \n      offsetCoord.z = i; \n      vec4 offsets =  \n        texelFetch(OffsetTex, offsetCoord,0) * \n                   Radius * ShadowCoord.w; \n\n      sc.xy = ShadowCoord.xy + offsets.xy; \n      sum += textureProj(ShadowMap, sc); \n      sc.xy = ShadowCoord.xy + offsets.zw; \n      sum += textureProj(ShadowMap, sc); \n    } \n    shadow = sum / float(samplesDiv2 * 2.0); \n  } \n  FragColor = vec4(diffSpec * shadow + ambient, 1.0); \n}\n```", "```cpp\nglGenFramebuffers(1, &colorDepthFBO); \nglBindFramebuffer(GL_FRAMEBUFFER, colorDepthFBO); \nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,  \n                          GL_RENDERBUFFER, depthBuf); \nglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,  \n                          GL_RENDERBUFFER, ambBuf); \nglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1,  \n                       GL_TEXTURE_2D, diffSpecTex, 0); \n```", "```cpp\nGLenum drawBuffers[] = {GL_COLOR_ATTACHMENT0,  \n                        GL_COLOR_ATTACHMENT1}; \nglDrawBuffers(2, drawBuffers); \n```", "```cpp\nlayout( location = 0 ) out vec4 Ambient; \nlayout( location = 1 ) out vec4 DiffSpec; \n\nvoid shade( ) {\n  // Compute the shading model, and separate out the ambient \n  // component. \n  Ambient = ...;   // Ambient \n  DiffSpec = ...;  // Diffuse + specular \n} \nvoid main() { shade(); } \n```", "```cpp\nglClear(GL_STENCIL_BUFFER_BIT); \nglEnable(GL_STENCIL_TEST); \nglStencilFunc(GL_ALWAYS, 0, 0xffff); \nglStencilOpSeparate(GL_FRONT, GL_KEEP, GL_KEEP, GL_INCR_WRAP); \nglStencilOpSeparate(GL_BACK, GL_KEEP, GL_KEEP, GL_DECR_WRAP);\n```", "```cpp\nglBindFramebuffer(GL_READ_FRAMEBUFFER, colorDepthFBO);  \nglBindFramebuffer(GL_DRAW_FRAMEBUFFER,0); \nglBlitFramebuffer(0,0,width,height,0,0,width,height, \n           GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT, GL_NEAREST); \n```", "```cpp\nglColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);  \nglDepthMask(GL_FALSE); \n```", "```cpp\nlayout( triangles_adjacency ) in; \nlayout( triangle_strip, max_vertices = 18 ) out; \n\nin vec3 VPosition[]; \nin vec3 VNormal[]; \n\nuniform vec4 LightPosition;  // Light position (eye coords) \nuniform mat4 ProjMatrix;     // Proj. matrix (infinite far plane) \n\nbool facesLight( vec3 a, vec3 b, vec3 c ) {\n  vec3 n = cross( b - a, c - a ); \n  vec3 da = LightPosition.xyz - a; \n  vec3 db = LightPosition.xyz - b; \n  vec3 dc = LightPosition.xyz - c; \n  return dot(n, da) > 0 || dot(n, db) > 0 || dot(n, dc) > 0;  \n} \n\nvoid emitEdgeQuad( vec3 a, vec3 b ) { \n  gl_Position = ProjMatrix * vec4(a, 1); \n  EmitVertex();   \n  gl_Position = ProjMatrix * vec4(a - LightPosition.xyz, 0); \n  EmitVertex(); \n  gl_Position = ProjMatrix * vec4(b, 1); \n  EmitVertex(); \n  gl_Position = ProjMatrix * vec4(b - LightPosition.xyz, 0); \n  EmitVertex(); \n  EndPrimitive(); \n} \n\nvoid main() {\n  if( facesLight(VPosition[0], VPosition[2], VPosition[4]) ) { \n    if( ! facesLight(VPosition[0],VPosition[1],VPosition[2]) )  \n       emitEdgeQuad(VPosition[0],VPosition[2]); \n    if( ! facesLight(VPosition[2],VPosition[3],VPosition[4]) )  \n       emitEdgeQuad(VPosition[2],VPosition[4]); \n    if( ! facesLight(VPosition[4],VPosition[5],VPosition[0]) )  \n       emitEdgeQuad(VPosition[4],VPosition[0]); \n  } \n} \n```", "```cpp\nglStencilFunc(GL_EQUAL, 0, 0xffff); \nglStencilOp(GL_KEEP, GL_KEEP, GL_KEEP); \n```", "```cpp\nglEnable(GL_BLEND);           \nglBlendFunc(GL_ONE,GL_ONE); \n```", "```cpp\nlayout(binding = 0) uniform sampler2D DiffSpecTex; \nlayout(location = 0) out vec4 FragColor; \n\nvoid main() { \n  vec4 diffSpec = texelFetch(DiffSpecTex, ivec2(gl_FragCoord), 0); \n  FragColor = vec4(diffSpec.xyz, 1); \n} \n```"]