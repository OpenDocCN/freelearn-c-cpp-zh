- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigating through the Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will revisit the concepts of a file, which were discussed
    briefly in [*Chapter 1*](B20833_01.xhtml#_idTextAnchor014). You will learn in
    detail about the **filesystem** (**FS**) in Linux and its specifics. We will not
    go to certain filesystem implementations, as you will see there’re many, but we
    will establish the fundamentals of working with them. You will learn more about
    Linux’s FS hierarchy – its partitions, object types, and some frequently used
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: You will get familiar with the `string_views`. Some of the operations you learn
    about here will be revisited again in [*Chapter 5*](B20833_05.xhtml#_idTextAnchor075),
    when we will discuss error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, you will learn hands-on about the fundamental **inter-process
    communication** (**IPC**) mechanism known as **pipes**. We will also discuss signals
    as system entities and their impact on communication. If you’re unfamiliar with
    data transfers between processes, then this is where you should start. If you
    are experienced, then you may notice that the code could be much more complicated
    – implementing server-client applications with pipes, for example. We are aware
    of that, but we believe that the examples are a good basis to start from – additional
    scalability of this mechanism has unwanted knock-on effects. We discuss this more
    in [*Chapter 7*](B20833_07.xhtml#_idTextAnchor101).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Going through Linux’s filesystem fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing filesystem operations with C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPC through anonymous pipes and named pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Briefly observing the signal handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to run the code examples, the reader must prepare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Linux-based system capable of compiling and executing C and C++20 (for example,
    Linux Mint 21):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gcc12.2** compiler: [https://gcc.gnu.org/git/gcc.git gcc-source](https://gcc.gnu.org/git/gcc.gitgcc-source)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**g++** with **-std=c++2a** flags for the C++ code'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gcc** without flags for the C code'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For all the examples, you can alternatively use [https://godbolt.org/.](https://godbolt.org/%0D)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code examples could be found here: [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%203](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%203)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going through Linux’s filesystem fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We went through some of the Unix (and Linux) filesystem definitions in [*Chapter
    1*](B20833_01.xhtml#_idTextAnchor014). Let’s see how they really matter in the
    bigger picture of system programming. You probably remember what types of files
    there are in the Linux system – regular files, directories, special files, links,
    sockets, and named pipes. We are going to deal with most of them in this chapter
    and learn about what purpose they serve. One way to think about files in Unix,
    including Linux, is the following simple statement:'
  prefs: []
  type: TYPE_NORMAL
- en: “*On a UNIX system, everything is a file; if something is not a file, it is*
    *a process.*”
  prefs: []
  type: TYPE_NORMAL
- en: So, everything that’s not a process has an API, which includes file operation
    system calls. Let’s agree that a file is the main instrument for the logical organization
    of data. Then there must be something that is the main instrument for file organization.
    Well, this is where the file management system, or simply the FS, comes into play.
    It looks after the files’ layout on the physical medium – the `open()`, `write()`),
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The FS also allows the user to forget the hardware’s specifics for a moment
    and focus on data operations, as well as using the FS like an ordered catalog.
    It helps with the files’ structure and data visualization on the UI or CLI, access
    permissions, and the effective usage of resources. While the user has the chance
    to focus on file creation, deletion, modifications, and sharing, the FS cares
    more about data accuracy, device driver error handling, multiple user accesses,
    and so on. This is an important point, as we will observe some error states later
    in the book – for example, in [*Chapter 5*](B20833_05.xhtml#_idTextAnchor075),
    where the FS is the entity that creates the exception cases. And it also affects
    task scheduling, as we mentioned earlier. Let’s look at the FS structure and its
    specifics in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Linux’s FS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to mention that there are many kinds of FSs. Each of them suits its
    own purposes, as the user experience implies multiple preferences, and not all
    of them exist together. Linux has the strength to support over 100 FSes. A combination
    of them can run simultaneously on a single system. This provides an opportunity
    for the user to operate with them optimally and benefit from all of them. If the
    FS is required just to organize the file structure, then an ordinary one could
    do the trick – for example, `ext2` or `FAT`. If we want file consistency and less
    error-prone operations, then a `ext4`, `ReiserFS`, or `XFS`. For online data stores,
    `NFS` and `CIFS`, might come in handy. Large files and a large number of small
    files require specific management, too, so `ZFS` and `btrfs`, are useful. Last,
    but not least, there are FSes that are not backed by physical storage but represent
    entities in the `proc`, `sys`, `ram`, and `tmp`. However, at an abstract level,
    the file operations seem to be the same. So, we can have a unified interface.
    It not only allows system programmers to use the different FSes in the same way
    but also allows the OS’s UI to visualize the file structure – all of the files
    and directories – under the same FS tree. Linux realizes this through the **virtual
    filesystem** (**VFS**). It is also referred to as **virtual FS switch** – a layer
    residing in the kernel, providing a generic interface for the programs. Before
    we go into detail, let’s see how it looks from a design standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – A VFS software layer in Linux kernel](img/Figure_3.1_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – A VFS software layer in Linux kernel
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the VFS is object-oriented. This will not help us much with C++
    code, unfortunately. Still, it is a good example of object-oriented programming
    in C, as the objects are actually of a `struct` type, containing file data and
    function pointers to the file operations. We will talk about those objects a bit
    later in the chapter. Let’s look at the directory structure and standardized partitioning
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Directory structure and partitioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The directory structure in Linux is well presented in the `#!`. You can read
    more about them by executing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting back to the FS structure – it starts with the `root` directory, denoted
    with `/`. The `root` FS is mounted on that directory in the early stages of the
    system’s boot sequence. Every other FS is mounted during the OS startup or even
    later during normal operations. You can check your own configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It provides information about the *mount points* and the respective FS types.
    Outside this file, the FSes will be visible in the system as separate directories
    with their exact paths. Every one of them can be accessed through the `root` directory.
    An important point is that `/` and `/root` are different directories, as the first
    is the `root` directory and the latter is the home directory of the *root user*.
    Some other important partitions and directories are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/bin`: Includes common user executables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/boot`: Includes the Linux system startup files, the static part of the kernel,
    and the bootloader configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev`: Includes references to all peripheral hardware, which is represented
    through files with a special file type, `''c''` or `''b''`, and they provide access
    to the real devices. We mentioned these special file types in [*Chapter 1*](B20833_01.xhtml#_idTextAnchor014).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc`: Includes the system configuration files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home`: This is the top-level directory, which is available for user files,
    and all users have their respective common subdirectory there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib`: This includes shared library files that are needed to start the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt`: The temporary mount point for external FSes. It makes a good combination
    with `/media`, where media devices such as USB flash drives are mounted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/opt`: This consists of optional files and third-party software applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc`: This contains information about the system resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp`: This is a temporary directory used by the OS and several programs for
    temporal storage – it will be cleaned up after reboot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sbin`: This includes the system binary files, usually utilized by the system
    administrator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr`: This includes read-only files most of the time, but there are exceptions.
    It is for programs, libraries and binaries, *man* files, and documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var`: This includes variable data files – usually log files, database files,
    archived e-mails, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get back to **mount points** and **FS partitions**. As not many people
    are familiar with those, we will take the opportunity to briefly explain them.
    A good reason for this is that, as already mentioned, system programmers work
    with many FSes at a time, and some of them are related to network drives or different
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Linux does not assign a letter to a partition as Windows does; therefore, you
    can easily confuse a separate device for a simple directory. Most of the time,
    this shouldn’t be a big deal, but it might become a problem when you care about
    resource management, resiliency, and security. For example, vehicles overall have
    strict requirements for hardware durability, which extends to 10-15 years of serviceability.
    With this in mind, you must be aware of a device’s characteristics, especially
    if you write on it frequently or fill its entire space meaninglessly. The way
    an FS manages the data is also crucial to a peripheral’s memory exhaustion in
    time, so this choice is important.
  prefs: []
  type: TYPE_NORMAL
- en: '`fstab` shows where FSes are mounted, but it also describes something else.
    First of all, let’s remember that **FS partitions** have the purpose of separating
    a single device – a hard drive, for example – into multiple partitions. This is
    used mostly in embedded systems with safety requirements. However, Linux also
    provides **Logical Volume Manager** (**LVM**), which allows flexible setups. In
    other words, FSes can easily get shrunk or enlarged, which is preferable on larger-scale
    systems.'
  prefs: []
  type: TYPE_NORMAL
- en: The creation of multiple FSs serves not only as a user data grouping tool but
    also allows other partitions to remain intact if one goes out due to failure.
    Another usage is when a device’s storage is unavailable – often, it’s just full
    of data. The entire system might stop working because it also relies on storage
    space. Therefore, it is better to fill only a single FS entirely and raise an
    error. The other FS will be left intact, and the system will continue working.
    From that point of view, it is a secure and robust solution. Just keep in mind
    that it doesn’t protect you from overall device failure. For that reason, many
    network storage devices rely on a **Redundant Array of Inexpensive Disks** (**RAID**).
    We will not deal with it here, but we encourage you to read more about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you probably observed some additional data in the `fstab` output earlier.
    Except for the **root partition**, we actually divide the partition types into
    **data** and **swap** partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The data partition**: This includes the root partition, together with all
    necessary information for system startup and normal run. It also includes standard
    data on Linux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swap` in `fstab`, and it provides the system with the option to move data
    from the main memory to the NVM in cases of memory overflow. It is visible only
    to the system itself. This doesn’t mean you should overflow your RAM, but just
    keep it for extra flexibility in order to not compromise the system’s availability.
    Just remember, the NVM is much slower than the main memory chips!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The system administrator generally configures the partitions’ layout. Sometimes,
    one partition is spread across multiple NVM devices. This design is strictly related
    to the system’s purpose. Once the partitions are available to you as a user, you
    can only add more. We strongly discourage you from changing their properties unless
    you’re well aware of what you’re doing and why.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about the `df` command. In our case, this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is easy to see the relationship between the FS type and the mount point,
    for example, the `Filesystem` and `Mounted on` columns. We will not go into more
    detail on this, but we encourage you to read more about the `parted` tool, which
    is used exactly for the creation and editing of partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Linux FS objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we already mentioned in the previous section, the FS is realized through
    objects, and there are four main types we care about:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Superblock**: This represents the mounted FS metadata – the respective device,
    the modification flags, the corresponding FS type, the FS access permissions,
    the modified files, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open()`, `create()`, `lookup()`, `mkdir()`. Regular files, special files,
    directories, and `stat` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, look at the permission bits – `0775/-rwxrwxr-x`. Both the numbers and the
    symbol flags have the same meaning but are different representations. `-` means
    the flag is not set. `r` means the file is readable by the current user, group,
    or everyone (reading left to right). `w` means `x` stands for `p` in front, it
    marks this file as a `1`. Other symbols you might see during your operations are
    `d` for `b` for `c` for `s` for **sockets**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Directory entry (dentry)**: For usability, we will not refer to physical
    files using numbers as the inode does but, instead, using names and locations.
    So, we need a translation table, mapping symbolic names (for users) to inode numbers
    (for the kernel). The easiest way to represent this is through the pathname, such
    as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the inode is the same as the previous example – `696116`, and
    the symbolic name is `test`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`open()` and destroyed at `close()`. Some of the members this object contains
    are the `open()` method is called for the specific FS realization, and the file
    is placed into the file descriptor table of the calling process. In user-space,
    the file descriptor is used for the application’s file operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram provides an overview of single-file access through multiple
    processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – File access organization](img/Figure_3.2_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – File access organization
  prefs: []
  type: TYPE_NORMAL
- en: We can see a few interesting things here. Although the processes open the same
    file, they go through different execution paths before reaching the real data.
    First of all, the processes have their own `fork()`, the child gets the same **open
    file table**. The independent process points to a separate one. Then, let’s say
    we have two **dentries** for the same file and our file objects point to it. Such
    a situation occurs when we reach the same physical file through different pathnames.
    As we work with the same file, the entries will point to a single inode and **superblock**
    instances. From then on, the exact FS, where the file resides, will take over
    with its specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One disclaimer, though – the OS is not an arbiter of simultaneous file updates
    by multiple processes. It will schedule those operations by the rules we discussed
    in the previous chapter. If you want to make a specific policy for such actions,
    then this must be designed and applied explicitly. Although the FS provides file
    locking as a `sudo rm -rf`, you might delete ones that are currently in use. This
    can lead to irreversible system issues. We use file locking to ensure safe, concurrent
    access to the file’s contents. It allows only one process to access the file at
    a given time, thus avoiding possible race conditions, which you will learn about
    in [*Chapter 6*](B20833_06.xhtml#_idTextAnchor086). Linux supports two kinds of
    file locks – advisory locks and mandatory locks, which you can read more about
    here: [https://www.kernel.org/doc/html/next/filesystems/locking.xhtml](https://www.kernel.org/doc/html/next/filesystems/locking.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The unique numbers for physical file identification through the respective inodes
    are not endless. The VFS might contain so many tiny files that it exhausts its
    abilities to create new files, while there’s still free space on the NVM. This
    error is observed on high-scale systems more often than you may think.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve probably also wondered about the ways to reach the same file through
    different pathnames. Well, do you recall our discussion on link files in [*Chapter
    1*](B20833_01.xhtml#_idTextAnchor014)? We talked about **hard links** and **symbolic
    links**. The first ones are always available for a given file – for example, when
    there’s at least one hard link, related to a piece of data, then the corresponding
    file is considered to exist in the FS. Through it, a pathname is directly associated
    with the point on the NVM where the file resides and can be opened from. Multiple
    pathnames to the same point on the device lead to multiple hard link constructions.
    Let’s check it out. First, we will list the data for some of our files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create a hard link for the same file through the `ln` command,
    and list both files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, they both have the same inode because they have different character
    names, but they are the same file. The only true representation of the file is
    the `695571`. This means they truly point to the same block of the hard drive.
    Then, we see that the hard link counter has increased from `1` to `2` (between
    the access permissions and the `uid` columns).
  prefs: []
  type: TYPE_NORMAL
- en: '`ln` command again, but this time we will add the `-s` option. We will list
    all of the files so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily see that the new file – `some_data_sl` – has a different inode
    from the original file and its hard link. It points to a new location in the NVM
    and has its own access permissions. In addition, it shows visually which pathname
    it truly points to. Even if there’s a symbolic link to a symbolic link, `ls -li`
    will still present the file a symbolic link is set to point to, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And check out the sizes in bytes – the original file is only `4247` bytes in
    size, while the symbolic link is `8` bytes, and the next is `10`. Actually, the
    original file size doesn’t matter for the symbolic link’s size, but something
    else does – you could figure it out by counting the number of characters in the
    referred file’s **pathname**.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the preceding filenames will provide you with the ability to access
    and modify the file. They also provide you with the flexibility to get data from
    multiple access points without duplication and meaningless usage of extra storage
    space. Many system programmers use symbolic links to reorder the FS, just for
    the purposes of easier data management for some specialized user processes. The
    Linux system itself does that, just to reorder the FS hierarchy for the same reasons.
    Let’s create an overview of this example through the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – A hard link and symbolic link overview](img/Figure_3.3_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – A hard link and symbolic link overview
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Even if the original file is moved or deleted, the symbolic link will continue
    to point to its pathname as a target, while the hard link must point to an existing
    file. The symbolic link will work across partitions, but the hard link doesn’t
    link paths on different volumes or FSes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will continue to manipulate files, but this time through
    C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Executing FS operations with C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With C++17 FS operations that are closer to the system programming are facilitated.
    The FS library allows the C++ developer to distinguish between the Linux fs types
    and perform certain operations with them. Let’s take a look at an exemplary interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method checks whether a given pathname is a `is_fifo()`, `is_regular_file()`,
    `is_socket()`, and `is_symlink()`. Can you tell why we don’t have the `is_hardlink()`
    method? That’s right – if two files with different character names point to a
    single inode, then both of them provide access to the same content. It doesn’t
    matter whether the inode’s hard link counter is higher than one, although we could
    get it through the `hard_link_count()` method.
  prefs: []
  type: TYPE_NORMAL
- en: As the C++ language is compilable on multiple OSes, the FS functions are also
    dependent on the respective FSes for those exact systems. For example, FAT does
    not support symbolic links; therefore, the methods related to them will fail,
    and the error handling is left to the system programmer. You can use the `std::filesystem::filesystem_error`
    exception object to get details about the current error’s FS error state. Such
    discussions are available in [*Chapter 5*](B20833_05.xhtml#_idTextAnchor075).
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier that the concurrent file access has to be managed by the
    software engineer, or the OS will schedule the operations as it sees fit. The
    same goes for this library, too. Don’t expect it to handle race conditions or
    modification conflicts itself. Now, let’s see how some of the operations can be
    used. One disclaimer though – as mentioned, error conditions will be discussed
    later, so we will not focus on them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new directory (marker `{1}` in the following code segment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see what happened on the FS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call the program again, it will fail, as the directory already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We populate the new directory, as described in the example earlier (*see* *Figure
    3**.3*), but this time with C++ code (markers `{1}` and `{2}` in the following
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, it is important to call the program from the directory, where `some_data`
    is, or provide its pathname accordingly – through the `some_data`, so it’s `9`
    bytes in size. Still, the picture is almost the same – of course, the inodes are
    different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We also create by hand a new inner directory, called `inner_test_dir`, with
    a new file, called `inner_some_data`. Let’s iterate through the directory, both
    non-recursively (marker `{1}` in the following code) and recursively, and print
    out the directory contents (marker `{2}` in the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is not surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to check whether some of the files are symbolic links (marker
    `{1}` in the following code), and if so, let’s print out their targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the output is as expected – the target is the initial source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try to rename the symbolic link file (marker `{1}` in the following code
    segment), before we continue with some other modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the renaming is successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s remove the initial file – `some_data` (marker `{2}` in the following
    code), and observe the free space on the system changing (markers `{1}` and `{3}`
    in the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see `4096` bytes have been freed, although the file was only `9`
    bytes in size. This is because the minimum value we actually use is the size of
    one NVM block – the smallest unit of data the OS can write in or read from a file.
    In this case, it is 4 KB. If the details are not interesting to you, but you only
    want to check whether the space values have been updated, then with C++ 20, you
    also have the `==` operator overload; thus you can directly compare the two `space_info`
    objects, which are actually behind the returned values of `space()` (markers `{1}`
    and `{3}`).
  prefs: []
  type: TYPE_NORMAL
- en: We used these code examples to go quickly through the C++ filesystem library.
    We hope it is a good overview for you, although we have jumped a bit from function
    to function. It should be useful in your work. The next section deals with something
    very important – the fundamentals of multi-process communication. As you already
    know from the beginning of this chapter, Linux treats everything that’s not a
    process as a file. The same goes for communication resources, and we will delve
    into them armed with our C++ knowledge. There will be a bit more theory, so stay
    with us!
  prefs: []
  type: TYPE_NORMAL
- en: IPC through anonymous pipes and named pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we even start working on this topic, let us ask you this. Have you ever
    done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If yes, then you probably call `|` a `|`-symbolled pipe the same as them? No!
    That’s an anonymous pipe. System programmers differentiate between the so-called
    `pipefs`, while the user executes the standard VFS system calls. We are going
    to use pipes as examples to visualize some observations for the FS as well. Let’s
    get into it then!
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous or unnamed pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`|` symbol, you can easily conclude that such implementation is related more
    to short-term communication, and it is not persistent in time. Anonymous pipes
    have two endpoints – a read one and a write one. Both of these are represented
    by a file descriptor. As soon as both endpoints are closed, the pipe will be destroyed,
    as there are no more ways to reference it through an open file descriptor. In
    addition, this type of communication is known as a simplex FIFO communication
    – for example, it creates a one-way-only data transfer – most often from a parent
    process to a child. Let’s see one example, which uses the system calls to create
    an anonymous pipe and a simple data transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We require an integer array to hold the file descriptors, representing the
    pipe’s *in* and *out* endpoints – `a_pipe`. Then, this array is passed to the
    `pipe()` system call, which will return `-1` if there is an error, or `0` on success
    (see marker `{1}`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We create a new process through `fork()`, as we did in [*Chapter 2*](B20833_02.xhtml#_idTextAnchor029).
    Knowing this, can you tell how many pipes are created at the end? That’s right
    – one pipe is created, and the file descriptors are shared between the processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the data transfer is one-way, we need to close the unused endpoint for each
    process – markers `{2}` and `{4}`. If the process writes and reads its own **pipe**
    in and out file descriptors, it will only get the information that it has written
    there beforehand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, we forbid the child from *talking* *back* to the parent, and
    the parent can only send data to the child. The data is sent simply by writing
    it into a file and reading from it (see markers `{3}` and `{5}`). This is a very
    simple piece of code, and usually, the communication through anonymous pipes is
    that simple. However, be careful – `write()` and `read()` are blocking calls;
    if there’s nothing to be read from the pipe (the pipe buffer is empty), the respective
    process-reader will be blocked. If the pipe capacity is exhausted (the pipe buffer
    is full), the process-writer will be blocked. If there’s no reader to consume
    the data, `SIGPIPE` will be triggered. We will provide such an example in the
    last section of this chapter. There’s no risk of race conditions in the way we
    will present them in [*Chapter 6*](B20833_06.xhtml#_idTextAnchor086), but synchronization
    of data creation and consumption is still in the programmer’s hands. The next
    diagram provides you with some additional information on what happens when we
    use the anonymous pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – An anonymous pipe communication mechanism](img/Figure_3.4_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – An anonymous pipe communication mechanism
  prefs: []
  type: TYPE_NORMAL
- en: 'In the background, at the kernel level, there are a few more operations going
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Anonymous pipe creation](img/Figure_3.5_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Anonymous pipe creation
  prefs: []
  type: TYPE_NORMAL
- en: The pipe’s capacity can be checked and set using the `fcntl(fd, F_GETPIPE_SZ)`
    and `F_SETPIPE_SZ` operations, respectively. You can see that the pipe has 16
    *pages* by default. The *page* is the smallest unit of data the *virtual memory*
    can manage. If a single page is 4,096 KB, then it could transfer 65,536 bytes
    of data before it overflows. We will discuss this later in the chapter. However,
    keep in mind that some systems may vary, and the info from *Figure 3**.5* might
    be wrong for you. In a similar fashion, we can represent what happens at a lower
    level during `read()` and `write()` operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the following diagram, the question of using an FS as a shared (global) memory
    arises. Note that although the FS has its own protection mechanisms through mutexes,
    this will not help us at a user level to synchronize the data correctly. Simply
    modifying a regular file through multiple processes will cause trouble, as mentioned
    earlier. Doing so with a pipe will cause less trouble, but we are still not on
    the safe side. As you can see, the **scheduler** is involved, and we might end
    up in a **deadlock** of constantly waiting processes. This is easier to avoid
    with anonymous pipes than with named pipes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Pipe read and write operations](img/Figure_3.6_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Pipe read and write operations
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our communication established, why do we need an additional
    file type such as the named pipe? We will discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Named pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Named pipes are *a bit more complex* than anonymous pipes, as there’s more
    programable context to them. For example, they have character names and are observable
    by a user in an FS. They are not destroyed after a process finishes working with
    them but, instead, when a specific system call for the file removal is executed
    – `unlink()`. Therefore, we can say that they provide *persistency*. In a similar
    fashion to anonymous pipes, we can demonstrate named pipes in the following CLI
    command, creating `fifo_example` as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the communication is duplexed – for example, the data transfer could
    work both ways. Still, your work might push you in the direction of wrapping system
    calls with C++ code. The next example provides a sample overview, with the disclaimer
    that it is exemplary, and as C++ context is added to the code, the program becomes
    larger in size. Let’s get an example from the **pipe** from earlier, which we
    can modify with C++ code, but the behavior remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'At marker `{1}`, we introduce the `string_view` object. It represents a pair
    of pointers to a string or an array, and its respective size. As it is a `view-handle`
    class type, we preferably and cheaply pass it by value (see marker `{2}`), together
    with the expected substring operation interface. It is always `const`, so you
    don’t need to declare it as such. So, it’s an object and it’s bigger in size,
    but it has the benefit of being unconditionally safe – taking care of typical
    C string error cases, such as `NULL-termination`. Any issue will be handled at
    compile time. In our case, we can simply use it as a `const char*` or `const string`
    alternative. Let’s proceed with the reader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Markers `{2}` and `{3}` show the C++ wrappers of `write()` and `read()` respectively.
    You can see that instead of doing `strlen()` or `sizeof()` acrobatics, we use
    the `string_view`’s and the `array`’s `data()` and `size()`, respectively, because
    they are packed together through the respective object. One important point is
    that we use `array<char, buf_size>` to be specific about the buffer size and type.
    Similarly, we can use `string` instead of `array`, as it is defined as `basic_string<char>`,
    and we can limit its size with `reserve(buf_size)`. The choice really depends
    on your needs later in the function. In our case, we will use `array` as a direct
    representation of reading a fixed-sized `char` buffer from the pipe. We construct
    the resultant `string` afterward or leave it empty (see marker `{4}`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will use the already known `exists()` function to discard a second
    `mkfifo()` call by the process that arrives second. Then, we check whether the
    file is truly a FIFO (see marker `{6}`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, look at markers `{7}` and `{10}`. Do you see where we open the pipe, where
    we keep this result, and where we check its value? Correct – we keep these operations
    packed together in the `if` statement, thus focusing our scope on the same logical
    place. Then, we read from the pipe through the newly added function wrapper (markers
    `{8}` and `{12}`). And then we write to the pipe through the `write()` wrapper
    (markers `{9}` and `{11}`). Note that at marker `{9}`, we pass `string_view` to
    the function, while at marker `{11}`, we pass a `string`. It works for both cases,
    thus additionally proving our point of using `string_views` for such interfaces,
    instead of `const string`, `const char *`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The pipe is removed at marker `{13}`, but we will keep it for experiments.
    For example, we can list the named pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Please observe that its size is `0`. This means that everything written in was
    consumed. On `close()`, the kernel will flush the file descriptors and will destroy
    the FIFO object in the main memory, as it did for the anonymous pipe. It is possible
    sometimes that the *reader* doesn’t consume the data fully. As you may remember,
    it can store data for 16 pages. That’s why we encourage you to use the number
    of bytes, returned by the `read()` and `write()` functions, to decide whether
    the processes have to be terminated or not. Now, look at the permission bits –
    do you see something interesting there? Yes – there is an extra `p` in front of
    them, which marks this file as a pipe. Did you observe this somewhere earlier
    in the chapter? If not, you can go back and check the permissions bits of the
    inode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue with the last code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple one-time ping-pong application with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can still use an IO operation to send the message, but then `string_view`
    wouldn’t do. In the next section, we will provide a brief overview of what happens
    when communication through a pipe is disturbed. To keep the focus on system calls,
    we will put aside C++ for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now return to the C++ filesystem library. We can check whether the current
    file is truly a FIFO file through the library operations. If so, let’s delete
    it with the `remove()` function. It will be the same as `unlink()`, although one
    level of abstraction over the system call itself. Again, this will give us some
    platform independency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, we use the already known methods, which were explained earlier
    in the chapter. Let’s see what happens at the VFS and kernel levels now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Named pipe creation system operations](img/Figure_3.7_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Named pipe creation system operations
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram, as well as the next one, gives you an example of why the anonymous
    pipe is considered a bit more lightweight. See how many functions calls there
    are between the initial system call from the process caller until the actual FS
    inode operation is executed. That said, together with the additional effort to
    close and delete files, it is easy to conclude that even the related code is larger.
    Still, the named pipe is used for persistency and communication between different
    processes, including ones that don’t have a parent-child relationship. Just think
    about it – you have the communication resource endpoint in the FS, you know its
    character name, and then you only have to open it from two independent processes,
    and start the data transfer. A similar approach is used by other IPC mechanisms,
    as we will discuss later in [*Chapter 7*](B20833_07.xhtml#_idTextAnchor101). Until
    then, check out the following diagram to see how many operations there are between
    the simple `open()` function and the creation of the FIFO buffer in the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Named pipe opening and transformation to pipe](img/Figure_3.8_B20833.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Named pipe opening and transformation to pipe
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem library doesn’t allow you to directly work with the file descriptors.
    At the same time, the system calls expect them. Someday, it might be different
    in the C++ Standard.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s an already known non-standard approach to associating a file descriptor
    with `iostream`. You can refer to it here: [http://www.josuttis.com/cppcode/fdstream.xhtml](http://www.josuttis.com/cppcode/fdstream.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the next section to provide a brief overview of what happens when
    communication through a pipe is disturbed.
  prefs: []
  type: TYPE_NORMAL
- en: Briefly observing signal handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals in Linux are a powerful and simple way to synchronize processes through
    software interrupts sent to them, indicating that an important event has occurred.
    They have a different nature, depending on their roles. Some of them are ignorable,
    while others are not and cause a process to be blocked, unblocked, or terminated.
    We discussed those behaviors in the previous chapter, but is there something we
    could do to gracefully handle them? We will use the anonymous pipe example to
    trigger a `SIGPIPE` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a `SIGPIPE` handler (marker `{1}`), where we could provide additional
    functionality if this signal is triggered. We intentionally close both the pipe
    endpoints of the child, so there’s no process that would read from it. Then, we
    declare a signal action, which maps the signal handler to the action itself (markers
    `{3}` and `{4}`). We provide some time for the child to close the file descriptors,
    and then we try to write in the **pipe**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel will trigger `SIGPIPE`, which intends to block the parent until
    there’s someone to read from it. In this case, we print out a message, telling
    the user that the signal is received and the parent process will be terminated.
    Actually, this is the default behavior to handle such a signal. We use the handle
    to inform the user accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can also ignore the signal through the following simple change
    on marker `{3}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Calling the program once again will not trigger the handler, which means that
    the signal is ignored and the process will continue as per its workflow. You can
    use both approaches in your code, but be careful – some signals cannot be ignored.
    We will use this knowledge later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we didn’t show any examples of file data modifications through
    C++. Our goals were mostly related to explaining the different Linux FS entities.
    We use the C++ filesystem library to enrich the knowledge in this direction –
    for example, improving system programming awareness. You learned about the roles
    of the different FS objects and their specifics. You also have the C++ instruments
    to manage file resources and level up your abstraction. There were also some hands-on
    examples of how to communicate between processes through anonymous and named pipes.
    Their implementation at the OS level was discussed as well, and we briefly explored
    signal handling in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finally dive deeper into the C++ language, laying
    the foundations for its safe and secure usage, according to the latest standard.
    Later in the book, we will revisit some code segments shown in this chapter. We
    will continuously improve them through the usage of new C++ features.
  prefs: []
  type: TYPE_NORMAL
