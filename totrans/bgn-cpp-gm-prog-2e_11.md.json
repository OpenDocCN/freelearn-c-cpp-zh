["```cpp\n&\n```", "```cpp\n*\n```", "```cpp\n// Declare a pointer to hold \n// the address of a variable of type int\nint* pHealth;\n```", "```cpp\nint* pHealth;\n```", "```cpp\nint * pHealth;\n```", "```cpp\nint *pHealth;\n```", "```cpp\n// A regular int variable called health\nint health = 5;\n// Declare a pointer to hold the address of a variable of type int\nint* pHealth;\n// Initialize pHealth to hold the address of health,\n// using the \"address of\" operator\npHealth = &health;\n```", "```cpp\n  pHealth = &health;\n```", "```cpp\n// A regular int variable called health\nint health = 5;\nint score = 0;\n// Declare a pointer to hold the address of a variable of type int\nint* pHealth;\n// Initialize pHealth to hold the address of health\npHealth = &health;\n// Re-initialize pHealth to hold the address of score\npHealth = &score;\n```", "```cpp\n*\n```", "```cpp\n// Some regular int variables\nint score = 0;\nint hiScore = 10;\n// Declare 2 pointers to hold the addresses of int\nint* pIntPointer1;\nint* pIntPointer2;\n// Initialize pIntPointer1 to hold the address of score\npIntPointer1 = &score;\n// Initialize pIntPointer2 to hold the address of hiScore\npIntPointer2 = &hiScore;\n// Add 10 to score directly\nscore += 10;\n// Score now equals 10\n// Add 10 to score using pIntPointer1\n*pIntPointer1 += 10;\n// score now equals 20\\. A new high score\n// Assign the new hi score to hiScore using only pointers\n*pIntPointer2 = *pIntPointer1;\n// hiScore and score both equal 20\n```", "```cpp\n// Add 10 to score using pIntPointer1\n*pIntPointer1 += 10;\n// score now equals 20, A new high score\n```", "```cpp\n// Assign the new hi-score to hiScore with only pointers\n*pIntPointer2 = *pIntPointer1;\n// hiScore and score both equal 20\n```", "```cpp\nint* pToInt = nullptr;\n```", "```cpp\npToInt = new int;\n```", "```cpp\ndelete pToInt;\n```", "```cpp\npToInt = nullptr;\n```", "```cpp\nvoid myFunction(int *pInt)\n{\n   // Dereference and increment the value stored \n   // at the address pointed to by the pointer\n   *pInt ++\n   return;\n}\n```", "```cpp\nint someInt = 10;\nint* pToInt = &someInt;\nmyFunction(&someInt);\n// someInt now equals 11\nmyFunction(pToInt);\n// someInt now equals 12\n```", "```cpp\nPlayer player;\nPlayer* pPlayer = &Player;\n```", "```cpp\n// Call a member function of the player class\npPlayer->moveLeft()\n```", "```cpp\n// Declare an array of ints\nint arrayOfInts[100];\n// Declare a pointer to int and initialize it \n// with the address of the first\n// element of the array, arrayOfInts\nint* pToIntArray = arrayOfInts;\n// Use pToIntArray just as you would arrayOfInts\narrayOfInts[0] = 999;\n// First element of arrayOfInts now equals 999\npToIntArray[0] = 0;\n// First element of arrayOfInts now equals 0\n```", "```cpp\nmap<string, int> accounts;\n```", "```cpp\naccounts[\"John\"] = 1234567;\n```", "```cpp\naccounts[\"Smit\"] = 7654321;\naccounts[\"Larissa\"] = 8866772;\n```", "```cpp\nint accountNumber = accounts[\"Smit\"];\n```", "```cpp\naccounts.erase(\"John\");\n```", "```cpp\nint size = accounts.size();\n```", "```cpp\nif(accounts.find(\"John\") != accounts.end())\n{\n    // This code won't run because John was erased\n}\nif(accounts.find(\"Smit\") != accounts.end())\n{\n    // This code will run because Smit is in the map\n}\n```", "```cpp\nfor (map<string,int>::iterator it = accounts.begin(); \n    it != accounts.end();  \n    ++ it)\n{\n    it->second += 1;\n}\n```", "```cpp\nfor (auto it = accounts.begin(); it != accounts.end(); ++ it)\n{\n    it->second += 1;\n}\n```", "```cpp\n#pragma once\n#ifndef TEXTURE_HOLDER_H\n#define TEXTURE_HOLDER_H\n#include <SFML/Graphics.hpp>\n#include <map>\nusing namespace sf;\nusing namespace std;\nclass TextureHolder\n{\nprivate:\n    // A map container from the STL,\n    // that holds related pairs of String and Texture\n    map<    string, Texture> m_Textures;\n    // A pointer of the same type as the class itself\n    // the one and only instance\n    static TextureHolder* m_s_Instance;\npublic:\n    TextureHolder();\n    static Texture& GetTexture(string const& filename);\n};\n#endif\n```", "```cpp\nstatic TextureHolder* m_s_Instance;\n```", "```cpp\nstatic Texture& GetTexture(string const& filename);\n```", "```cpp\n#include \"TextureHolder.h\"\n// Include the \"assert feature\"\n#include <assert.h>\nTextureHolder* TextureHolder::m_s_Instance = nullptr;\nTextureHolder::TextureHolder()\n{\n    assert(m_s_Instance == nullptr);\n    m_s_Instance = this;\n}\n```", "```cpp\nTexture& TextureHolder::GetTexture(string const& filename)\n{\n    // Get a reference to m_Textures using m_s_Instance\n    auto& m = m_s_Instance->m_Textures;\n    // auto is the equivalent of map<string, Texture>\n    // Create an iterator to hold a key-value-pair (kvp)\n    // and search for the required kvp\n    // using the passed in file name\n    auto keyValuePair = m.find(filename);\n    // auto is equivalent of map<string, Texture>::iterator\n\n    // Did we find a match?\n    if (keyValuePair != m.end())\n    {\n        // Yes\n        // Return the texture,\n        // the second part of the kvp, the texture\n        return keyValuePair->second;\n    }\n    else\n    {\n        // File name not found\n        // Create a new key value pair using the filename\n        auto& texture = m[filename];\n        // Load the texture from file in the usual way\n        texture.loadFromFile(filename);\n        // Return the texture to the calling code\n        return texture;\n    }\n}\n```", "```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\nusing namespace sf;\nclass Zombie\n{\nprivate:\n    // How fast is each zombie type?\n    const float BLOATER_SPEED = 40;\n    const float CHASER_SPEED = 80;\n    const float CRAWLER_SPEED = 20;\n    // How tough is each zombie type\n    const float BLOATER_HEALTH = 5;\n    const float CHASER_HEALTH = 1;\n    const float CRAWLER_HEALTH = 3;\n    // Make each zombie vary its speed slightly\n    const int MAX_VARRIANCE = 30;\n    const int OFFSET = 101 - MAX_VARRIANCE;\n    // Where is this zombie?\n    Vector2f m_Position;\n    // A sprite for the zombie\n    Sprite m_Sprite;\n    // How fast can this one run/crawl?\n    float m_Speed;\n    // How much health has it got?\n    float m_Health;\n    // Is it still alive?\n    bool m_Alive;\n\n    // Public prototypes go here\n};\n```", "```cpp\n    // Is it still alive?\n    bool m_Alive;\n\n    // Public prototypes go here    \npublic:\n\n    // Handle when a bullet hits a zombie\n    bool hit();\n    // Find out if the zombie is alive\n    bool isAlive();\n    // Spawn a new zombie\n    void spawn(float startX, float startY, int type, int seed);\n    // Return a rectangle that is the position in the world\n    FloatRect getPosition();\n    // Get a copy of the sprite to draw\n    Sprite getSprite();\n    // Update the zombie each frame\n    void update(float elapsedTime, Vector2f playerLocation);\n};\n```", "```cpp\n#include \"zombie.h\"\n#include \"TextureHolder.h\"\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n```", "```cpp\nvoid Zombie::spawn(float startX, float startY, int type, int seed)\n{\n\n    switch (type)\n    {\n    case 0:\n        // Bloater\n        m_Sprite = Sprite(TextureHolder::GetTexture(\n            \"graphics/bloater.png\"));\n        m_Speed = BLOATER_SPEED;\n        m_Health = BLOATER_HEALTH;\n        break;\n    case 1:\n        // Chaser\n        m_Sprite = Sprite(TextureHolder::GetTexture(\n            \"graphics/chaser.png\"));\n        m_Speed = CHASER_SPEED;\n        m_Health = CHASER_HEALTH;\n        break;\n    case 2:\n        // Crawler\n        m_Sprite = Sprite(TextureHolder::GetTexture(\n            \"graphics/crawler.png\"));\n        m_Speed = CRAWLER_SPEED;\n        m_Health = CRAWLER_HEALTH;\n        break;\n    }\n    // Modify the speed to make the zombie unique\n    // Every zombie is unique. Create a speed modifier\n    srand((int)time(0) * seed);\n    // Somewhere between 80 and 100\n    float modifier = (rand() % MAX_VARRIANCE) + OFFSET;\n    // Express this as a fraction of 1\n    modifier /= 100; // Now equals between .7 and 1\n    m_Speed *= modifier;\n\n    // Initialize its location\n    m_Position.x = startX;\n    m_Position.y = startY;\n    // Set its origin to its center\n    m_Sprite.setOrigin(25, 25);\n    // Set its position\n    m_Sprite.setPosition(m_Position);\n}\n```", "```cpp\nbool Zombie::hit()\n{\n    m_Health--;\n    if (m_Health < 0)\n    {\n        // dead\n        m_Alive = false;\n        m_Sprite.setTexture(TextureHolder::GetTexture(\n            \"graphics/blood.png\"));\n        return true; \n    }\n    // injured but not dead yet\n    return false;\n}\n```", "```cpp\nbool Zombie::isAlive()\n{\n    return m_Alive;\n}\nFloatRect Zombie::getPosition()\n{\n    return m_Sprite.getGlobalBounds();\n}\nSprite Zombie::getSprite()\n{\n    return m_Sprite;\n}\n```", "```cpp\nvoid Zombie::update(float elapsedTime, \n    Vector2f playerLocation)\n{\n    float playerX = playerLocation.x;\n    float playerY = playerLocation.y;\n    // Update the zombie position variables\n    if (playerX > m_Position.x)\n    {\n        m_Position.x = m_Position.x + \n            m_Speed * elapsedTime;\n    }\n    if (playerY > m_Position.y)\n    {\n        m_Position.y = m_Position.y + \n            m_Speed * elapsedTime;\n    }\n\n    if (playerX < m_Position.x)\n    {\n        m_Position.x = m_Position.x - \n            m_Speed * elapsedTime;\n    }\n    if (playerY < m_Position.y)\n    {\n        m_Position.y = m_Position.y - \n            m_Speed * elapsedTime;\n    }\n    // Move the sprite\n    m_Sprite.setPosition(m_Position);\n    // Face the sprite in the correct direction\n    float angle = (atan2(playerY - m_Position.y,\n        playerX - m_Position.x)\n        * 180) / 3.141;\n    m_Sprite.setRotation(angle);\n}\n```", "```cpp\n#pragma once\n#include \"Zombie.h\"\nusing namespace sf;\nint createBackground(VertexArray& rVA, IntRect arena);\nZombie* createHorde(int numZombies, IntRect arena);\n```", "```cpp\n#include \"ZombieArena.h\"\n#include \"Zombie.h\"\nZombie* createHorde(int numZombies, IntRect arena) \n{\n    Zombie* zombies = new Zombie[numZombies];\n    int maxY = arena.height - 20;\n    int minY = arena.top + 20;\n    int maxX = arena.width - 20;\n    int minX = arena.left + 20;\n    for (int i = 0; i < numZombies; i++)\n    {\n\n        // Which side should the zombie spawn\n        srand((int)time(0) * i);\n        int side = (rand() % 4);\n        float x, y;\n        switch (side)\n        {\n        case 0:\n            // left\n            x = minX;\n            y = (rand() % maxY) + minY;\n            break;\n        case 1:\n            // right\n            x = maxX;\n            y = (rand() % maxY) + minY;\n            break;\n        case 2:\n            // top\n            x = (rand() % maxX) + minX;\n            y = minY;\n            break;\n        case 3:\n            // bottom\n            x = (rand() % maxX) + minX;\n            y = maxY;\n            break;\n        }\n        // Bloater, crawler or runner\n        srand((int)time(0) * i * 2);\n        int type = (rand() % 3);\n        // Spawn the new zombie into the array\n        zombies[i].spawn(x, y, type, i);\n\n    }\n    return zombies;\n}\n```", "```cpp\n#include \"ZombieArena.h\"\n#include \"Zombie.h\"\n```", "```cpp\nZombie* createHorde(int numZombies, IntRect arena) \n{\n    Zombie* zombies = new Zombie[numZombies];\n```", "```cpp\nint maxY = arena.height - 20;\nint minY = arena.top + 20;\nint maxX = arena.width - 20;\nint minX = arena.left + 20;\n```", "```cpp\nfor (int i = 0; i < numZombies; i++)\n```", "```cpp\n// Which side should the zombie spawn\nsrand((int)time(0) * i);\nint side = (rand() % 4);\nfloat x, y;\n```", "```cpp\nswitch (side)\n{\n    case 0:\n        // left\n        x = minX;\n        y = (rand() % maxY) + minY;\n        break;\n    case 1:\n        // right\n        x = maxX;\n        y = (rand() % maxY) + minY;\n        break;\n    case 2:\n        // top\n        x = (rand() % maxX) + minX;\n        y = minY;\n        break;\n    case 3:\n        // bottom\n        x = (rand() % maxX) + minX;\n        y = maxY;\n        break;        \n}\n```", "```cpp\n// Bloater, crawler or runner\nsrand((int)time(0) * i * 2);\nint type = (rand() % 3);\n// Spawn the new zombie into the array\nzombies[i].spawn(x, y, type, i);\n```", "```cpp\nreturn zombies;\n```", "```cpp\n#include <SFML/Graphics.hpp>\n#include \"ZombieArena.h\"\n#include \"Player.h\"\n#include \"TextureHolder.h\"\nusing namespace sf;\nint main()\n{\n    // Here is the instance of TextureHolder\n    TextureHolder holder;\n    // The game will always be in one of four states\n    enum class State { PAUSED, LEVELING_UP, GAME_OVER, PLAYING };\n    // Start with the GAME_OVER state\n    State state = State::GAME_OVER;\n```", "```cpp\n// Create the background\nVertexArray background;\n// Load the texture for our background vertex array\nTexture textureBackground;\ntextureBackground.loadFromFile(\"graphics/background_sheet.png\");\n// Prepare for a horde of zombies\nint numZombies;\nint numZombiesAlive;\nZombie* zombies = nullptr;\n// The main game loop\nwhile (window.isOpen())\n```", "```cpp\nif (state == State::PLAYING)\n{\n    // Prepare the level\n    // We will modify the next two lines later\n    arena.width = 500;\n    arena.height = 500;\n    arena.left = 0;\n    arena.top = 0;\n    // Pass the vertex array by reference \n    // to the createBackground function\n    int tileSize = createBackground(background, arena);\n    // Spawn the player in the middle of the arena\n    player.spawn(arena, resolution, tileSize);\n    // Create a horde of zombies\n    numZombies = 10;\n    // Delete the previously allocated memory (if it exists)\n    delete[] zombies;\n    zombies = createHorde(numZombies, arena);\n    numZombiesAlive = numZombies;\n    // Reset the clock so there isn't a frame jump\n    clock.restart();\n}\n```", "```cpp\n/*\n ****************\n UPDATE THE FRAME\n ****************\n */\nif (state == State::PLAYING)\n{\n    // Update the delta time\n    Time dt = clock.restart();\n    // Update the total game time\n    gameTimeTotal += dt;\n    // Make a decimal fraction of 1 from the delta time\n    float dtAsSeconds = dt.asSeconds();\n    // Where is the mouse pointer\n    mouseScreenPosition = Mouse::getPosition();\n    // Convert mouse position to world coordinates of mainView\n    mouseWorldPosition = window.mapPixelToCoords(\n        Mouse::getPosition(), mainView);\n    // Update the player\n    player.update(dtAsSeconds, Mouse::getPosition());\n    // Make a note of the players new position\n    Vector2f playerPosition(player.getCenter());\n    // Make the view centre around the player                \n    mainView.setCenter(player.getCenter());\n    // Loop through each Zombie and update them\n    for (int i = 0; i < numZombies; i++)\n    {\n        if (zombies[i].isAlive())\n        {\n            zombies[i].update(dt.asSeconds(), playerPosition);\n        }\n    }\n}// End updating the scene\n```", "```cpp\n/*\n **************\n Draw the scene\n **************\n */\nif (state == State::PLAYING)\n{\n    window.clear();\n    // set the mainView to be displayed in the window\n    // And draw everything related to it\n    window.setView(mainView);\n    // Draw the background\n    window.draw(background, &textureBackground);\n    // Draw the zombies\n    for (int i = 0; i < numZombies; i++)\n    {\n        window.draw(zombies[i].getSprite());\n    }\n    // Draw the player\n    window.draw(player.getSprite());\n}\n```", "```cpp\n    }// End of main game loop\n     // Delete the previously allocated memory (if it exists)\n    delete[] zombies;\n    return 0;\n}\n```", "```cpp\n// Load the texture for our background vertex array\nTexture textureBackground;\ntextureBackground.loadFromFile(\"graphics/background_sheet.png\");\n```", "```cpp\n// Load the texture for our background vertex array\nTexture textureBackground = TextureHolder::GetTexture(\n    \"graphics/background_sheet.png\");\n```", "```cpp\n#include \"player.h\"\nPlayer::Player()\n{\n    m_Speed = START_SPEED;\n    m_Health = START_HEALTH;\n    m_MaxHealth = START_HEALTH;\n    // Associate a texture with the sprite\n    // !!Watch this space!!\n    m_Texture.loadFromFile(\"graphics/player.png\");\n    m_Sprite.setTexture(m_Texture);\n    // Set the origin of the sprite to the centre, \n    // for smooth rotation\n    m_Sprite.setOrigin(25, 25);\n}\n```", "```cpp\n#include \"player.h\"\n#include \"TextureHolder.h\"\nPlayer::Player()\n{\n    m_Speed = START_SPEED;\n    m_Health = START_HEALTH;\n    m_MaxHealth = START_HEALTH;\n    // Associate a texture with the sprite\n    // !!Watch this space!!\n    m_Sprite = Sprite(TextureHolder::GetTexture(\n            \"graphics/player.png\"));\n    // Set the origin of the sprite to the centre, \n    // for smooth rotation\n    m_Sprite.setOrigin(25, 25);\n}\n```"]