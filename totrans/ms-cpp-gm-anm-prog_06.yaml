- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Application Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Chapter 4*! In the previous chapter, we added capabilities for a
    better selection of a single instance among a possibly large number of models
    and instances. We started with a simple “move to” function and added a highlight
    to the current instance as the next step. Then, we implemented a visual selection
    by using the mouse. Finally, we created a null object to allow selecting no instance
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the edit mode. First, we will add the capability
    to switch off all controls and menus by creating a separate view mode. The split
    between edit and view modes will help us in later chapters to stop all automatic
    actions when we configure instance settings. Next, we will implement a simplified
    version of the undo functionality, allowing us to reset the settings of a model
    instance after applying changes. As the last step, we will implement undo and
    redo of setting changes on the instance level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Switching between edit and view modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverting changes before applying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing undo and redo functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example source code for this chapter is in the `chapter04` folder, in the
    `01_opengl_edit_view_mode` subfolder for OpenGL and `02_vulkan_edit_view_mode`
    for Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: After making instance selection easy in [*Chapter 3*](Chapter_3.xhtml), changing
    the settings of an instance will be the next topic to tackle. Right now, we have
    a Control menu on the screen, capturing the mouse input if the pointer is placed
    over the ImGui window. Any change we make will remain permanent in the current
    application session. Reverting any accidental rotation or scaling to the exact
    same value as before could be very difficult since we would have to memorize the
    previous values to undo the change.
  prefs: []
  type: TYPE_NORMAL
- en: We will now change the application to toggle to a mode without any controls
    or selection and add a rather simple but useful undo and redo functionality to
    roll changes to instances back or forward.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between edit and view modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we start the current version of the application, we will see that a large
    part of the screen is blocked by the user interface whenever we want to make changes
    to instances.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.1* shows what the user interface window looks like when all headers
    are expanded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.1_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: User interface blocking parts of the screen'
  prefs: []
  type: TYPE_NORMAL
- en: As more and more options will be added later in the book, the user interface
    may fill up even more of the available window space. In addition, a selected instance
    will blink if the highlight is active and the coordinate arrows are placed below
    it.
  prefs: []
  type: TYPE_NORMAL
- en: To change the overall appearance, we must check which features should be disabled
    in a separate view mode.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding what should be switched in view mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our main goal for this section is to remove the ImGui **Control** window to
    have the full application available for interacting with the model instances.
    We could just switch off the rendering of the user interface, but if we do not
    show the user interface window, there is no need to do any calculations like the
    timer and FPS updates. So, for the first decision, we will skip the user interface
    in the **View mode**.
  prefs: []
  type: TYPE_NORMAL
- en: We must also add a shortcut to avoid forwarding mouse button events to ImGui
    when the user interface is not active. ImGui saves the positions of all control
    elements, and we would still get unwanted side effects, like being unable to move
    the camera if we switch the user interface while the mouse pointer is above the
    ImGui window.
  prefs: []
  type: TYPE_NORMAL
- en: Even without a user interface, all parts related to the instance selection are
    still active. This means we do not need the instance selection in view mode, since
    there is no way to adjust instance parameters without a user interface. Our second
    decision here is to switch off everything connected to the instance selection.
    We will disable mouse picking, including the selection shaders, the coordinate
    arrows, and the highlight calculation.
  prefs: []
  type: TYPE_NORMAL
- en: We will also adjust the window title, reflecting the current view/edit state
    of the application. Changing the window properties from the renderer requires
    a bit of callback “magic” but helps to immediately see what mode the application
    is in.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of most of the switch of view and edit mode is simple. We
    just need a variable to save the current state, and some of the branches to enable
    or disable above specified operations for the two modes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the state variable plus code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the first implementation step, we create a new `enum` class named `appMode`
    in the `OGLRenderData.h` file in the `opengl` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For the Vulkan renderer, the `appMode` `enum` class will reside in the `VkRenderData.h`
    file in the `vulkan` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, a variable named `rdApplicationMode` must be added to the `OGLRenderData`
    struct for the OpenGL renderer, and the respective `VkRenderData` struct for the
    Vulkan renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We initialize `rdApplicationMode` with the value for the edit mode, avoiding
    visible changes to the application functionality at startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable or disable a feature in the renderer, depending on the mode, we can
    simply check the value of the `rdApplicationMode` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to switch between the animated shader with and without selection
    support, the following lines are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable rendering of the user interface in view mode, we surround the `render()`
    call to the user interface in the renderer with a check for the application mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We disable the timer calls in view mode too – without a user interface on screen,
    filling the timer values would be a waste of computing power.
  prefs: []
  type: TYPE_NORMAL
- en: Switching from edit to view mode and back will be done by pressing a hotkey.
    We cannot use an ImGui button here if we disable the user interface completely
    since we would need the button to toggle back to edit mode.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling between the two modes and changing the title
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the mode switch, a simple check for the `F10` key is done in the `handleKeyEvents()`
    method of the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Any other unused key can be achieved by placing the respective GLFW key name
    as the second parameter into the `glfwGetKey()` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `setModeInWindowTitle()` needs further explanation, as we are using
    callback functions to change the title string of our application window. The function
    call itself is short and simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We save the original window title in the `init()` method of the renderer, and
    append the default mode (**Edit mode**) to the window title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since the Window class initializes the renderer class, we have to move the window
    title change request backward, from the renderer to the application window.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, two `std::function` aliases are created in the renderer header file,
    `OGLRenderer.h` for OpenGL and `VkRenderer.h` for Vulkan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add two `public` methods to the declaration of our renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the aliases makes it easier to handle the calls to `std::function`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create two methods matching the callback signatures in the `Window`
    class header file, `window.h`, in the `window` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, a `private` member variable named `mWindowTitle` is added, storing
    the current title of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Storing the window title in a variable may be handy for debugging log prints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, right after initializing the renderer in the `init()` method of the `Window`
    class, two lambda functions are used to forward the `Window` class function calls
    to the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When we press `F10` now, the renderer appends a mode string to the original
    window title and forwards the created string via callback to the Window class.
    This way, the current application mode is presented in the title text of the application
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4.2*, the user interface and the selection have been disabled. Check
    the window title to see the current mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.2_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: No user interface in view mode'
  prefs: []
  type: TYPE_NORMAL
- en: Without the user interface window in view mode, the entire application window
    can be used to fly around in the virtual world. By pressing *F10*, we can go back
    to the edit mode to adjust the parameters of the model instances.
  prefs: []
  type: TYPE_NORMAL
- en: An outlook for future changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For every new feature we add later in the book, we must decide how to handle
    the feature in edit and view mode. Some of the new features are only feasible
    in edit mode, like adding and configuring different cameras in [*Chapter 6*](Chapter_6.xhtml).
    Using the cameras, on the other hand, is best done in view mode since we only
    need to switch between different cameras when roaming through the virtual world
    we created. We will have to think about the usage of a new feature every time.
  prefs: []
  type: TYPE_NORMAL
- en: After adding a separate view mode, let’s go back to the basic application handling.
    Whenever we select an instance and change one of the settings, we are stuck with
    the new value, without a proper way to reset the instance state to a “last known
    good” setting. In the next section, we will add a basic mechanism to revert at
    least the last change to a model instance.
  prefs: []
  type: TYPE_NORMAL
- en: Reverting changes before applying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main purpose of the current model viewer application is to view model instances.
    But, next to pure model viewing, adjusting instance properties and settings will
    become a larger part of the application throughout the book. And changing settings
    can go wrong in many ways. A solution to preview a change sounds like a good feature
    to add.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple rollback method would allow us to accept a change to the instance setting,
    or to revert the same settings to the previous values. We could experiment with
    the values, try to move the instance to the correct destination, or adjust other
    parameters to fit our needs. When we are happy with the result, we push the **Apply**
    button, and the instance settings are made permanent. The same workflow can be
    used for the next instance, and so on, until we have placed all instances in the
    way we imagined.
  prefs: []
  type: TYPE_NORMAL
- en: Adding code and User Interface elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we add two new `private` members to the `UserInterface.h` header file
    of the `UserInterface` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the `mCurrentInstance` smart pointer, we store the currently selected instance,
    and in the `mSavedInstanceSettings` variable, we will save the original settings
    of the currently selected instance.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are retrieving the current instance several times in the user interface,
    we can simply remove the `currentInstance` declaration in all other places within
    the `CollapsingHeader` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading the settings of the currently selected instance stays the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But, in addition, we also check if the currently selected instance is different
    compared to the new `mCurrentInstance` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the current instance changes, we store the new selected instance in
    the `mCurrentInstance` pointer, and we also save the instance settings we just
    retrieved in the `mSavedInstanceSettings` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mSavedInstanceSetting` variable enables us now to revert the settings
    of the instance, undoing any changes. To toggle the setting revert, we add a new
    button named `Reset Values to Previous` below the existing `Reset Values to Zero`
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To undo any changes, we copy the saved instance settings back to the current
    settings variable. At the end of the `CollapsingHeader` **Instances**, the values
    in settings are saved to the currently selected instance. Et voilà, we have reverted
    the settings to the state when we selected the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the changes just does the copy operation the other way around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the saved settings are overwritten by the current settings of the instance,
    making the current settings the new default for an undo operation.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.3* shows the location of the two new buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4.3_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Button to revert instance settings, respectively doing a permanent
    apply'
  prefs: []
  type: TYPE_NORMAL
- en: By using the **Apply Changes** button, the current changes to the model instance
    are made permanent. And with the **Reset Values to Previous** button, we can revert
    any changes to the instance to the state when we pressed **Apply Changes** before.
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks of the current solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using two buttons to apply or revert every instance setting change is time-consuming
    and cumbersome. A version that applies the changes automatically and more often
    would generate a much better workflow while editing instance properties. The general
    idea from this section will be kept; we just add some more automatic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a real-world undo and redo solution.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing undo and redo functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly every application has some way to undo one operation or more, and many
    applications also allow a redo of reverted steps. Accidents can happen in both
    ways; undoing an unwanted undo can save a lot of time and stress for the user.
  prefs: []
  type: TYPE_NORMAL
- en: What do we need to create undo and redo?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to undo a simple operation that changes object properties, we need
    to save the previous values. Undoing that change could then be done by applying
    the “old” values to the same object, and restoring the state of that object before
    the change.
  prefs: []
  type: TYPE_NORMAL
- en: For more complex undo operations, storing the operation type is also required.
    If we delete something, the undo step must recreate the object with the same properties,
    and vice versa – undoing the creation of a new object will delete that object.
  prefs: []
  type: TYPE_NORMAL
- en: Other options could be also taken into account. Do we want to store the absolute
    previous values or just the difference to the new values? By storing relative
    values, redoing the changes that followed the reverted operation could use the
    adjusted values as a basis, while absolute values would overwrite intermitted
    adjustments. And do we store the complete settings for that object, or only the
    changed parameter(s)? The implication is similar to the absolute and relative
    values before.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a technical side, our implementation will use two stacks: one for the
    possible undo operations and another for the possible redo operations. Every configuration
    change will push the new and the old settings to the undo stack, allowing the
    reversal of the changes by applying the old settings.'
  prefs: []
  type: TYPE_NORMAL
- en: After the undo operation has been done, the very same setting combination will
    be taken from the undo stack and pushed to the redo stack. If we now do a redo
    of the same operation, the new settings will be applied, and the settings will
    be moved back to the undo stack.
  prefs: []
  type: TYPE_NORMAL
- en: This simple workflow will allow us a virtually endless undo and redo size, limited
    mostly by the amount of memory in the computer. And, since the settings are small,
    it would take a very long time to fill up the computer memory with the two stacks.
  prefs: []
  type: TYPE_NORMAL
- en: As the first step on the road to undo and redo, we will create a storage container
    class that encapsulates all the information we need to revert the settings in
    one or the other direction.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a setting storage class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new class is called `AssimpSettingsContainer`, and the header and implementation
    file are in the model folder. In the header file, a struct is declared to store
    all the settings we need for both undo and redo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AssimpInstanceSettings` struct saves the previous and current settings
    of an instance, along with a weak pointer to the instance. Using `std::weak_ptr`
    instead of `std::shared_ptr` here has two important reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: A weak pointer breaks the dependency between the `miAssimpInstances` vector
    containing the instance `std::shared_ptr` and the settings stored for undo/redo
    because a weak pointer is not added to the reference counter of the smart pointer
    for the instance. If we use another shared pointer when storing the undo/redo
    information instead, the memory for a deleted instance may not be freed, since
    there could be another active reference to the instance stored somewhere in the
    undo or redo stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When requesting the weak pointer to return the shared pointer by using the `lock()`
    call, we can easily find deleted instances and remove the saved settings. The
    `lock()` call returns a `nullptr` if the shared pointer is no longer available,
    and we simply use a `pop()` call on the respective stack to remove the dead settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to save the settings instances of an instance, we call the `apply()`
    method of the `AssimpSettingsContainer` class. The `apply()` method creates a
    new `AssimpInstanceSettings` object and pushes the settings to the undo stack.
  prefs: []
  type: TYPE_NORMAL
- en: We also clear the redo stack while saving a new setting via `apply()`. It may
    be useless to use the redo operation after we reverted a couple of changes and
    applied recent changes since the redo operations could create conflicts with the
    latest changes, or even overwrite the latest change. Removing all settings from
    the redo stack is a quick and safe way to avoid side effects after the latest
    changes are applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `undo()` and `redo()` methods is short and simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Check for any deleted instances by requesting the shared pointer from the weak
    pointer, and remove the settings struct if the instance pointer is invalid. The
    check will be done in a `while()` loop to find all deleted instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the stack is empty (i.e., because all instances that had settings saved for
    undo or redo are gone), we return from the operation immediately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the top entry from the stack and apply the saved settings to the instance
    in case of an undo operation, or the new settings for a redo operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the top entry of a stack to the opposite stack and remove the top entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, all relevant instance changes can be saved to the undo stack. If we choose
    to undo a change to an instance, we can also immediately redo the very same change.
    In the background, the structs containing old and new settings and the instance
    pointer are just moved between the two stacks on undo and redo operations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the new operations to the renderer requires a bit of extra work.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking up the storage class to the renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The renderer will be extended by two new methods for the undo/redo related code,
    called `undoLastOperation()` and `redoLastOperation()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the start of each of the methods, we call the respective operation on the
    settings container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In addition, a call to `assignInstanceIndices()` will be issued. Enumerating
    all instances after undo and redo operations is crucial. The settings taken from
    the stack could contain an invalid instance index in the `isInstanceIndexPosition`
    variable after other instances have been deleted, resulting in access outside
    the `miAssimpInstance` vector.
  prefs: []
  type: TYPE_NORMAL
- en: A side effect of the enumeration is a position change in the `miAssimpInstances`
    vector. So, we cannot just take the new `isInstanceIndexPosition` to select the
    instance that was changed by the undo or redo operation. Instead, we retrieve
    the instance pointer of the changed instance from `AssimpInstanceSettings` and
    use `std::find_if` to search the `miAssimpInstance` vector for a matching pointer.
    If we don’t find the correct instance, the null instance will be selected, resulting
    in no instance to be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Defining hotkeys for undo and redo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use undo and redo functions by using known key combinations on the keyboard,
    we add the new keys to the `handleKeyEvents()` method in the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, only the undo part is shown, utilizing the key combination `CTRL + Z`,
    like many other applications. The redo function is called when `CTRL + Y` is pressed,
    which is also a well-known key combination to redo changes.
  prefs: []
  type: TYPE_NORMAL
- en: Undo and redo functionality will only be activated in edit mode. We cannot adjust
    instance settings in view mode, so we also do not need to revert or redo changes.
  prefs: []
  type: TYPE_NORMAL
- en: We are now able to call the undo and redo functions by key combinations. However,
    for easier access, reaching both operations via a menu bar would be great.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an ImGui menu to allow direct access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Luckily, a menu bar can be added with a few ImGui calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Like other ImGui widgets, the main menu bar itself, and all menus in the menu
    bar, start with an `ImGui::Begin*()` line and end with an `ImGui::End*()` line.
    As with other ImGui widgets, the ImGui menu commands return a Boolean value of
    `true` if they are activated (i.e., by clicking the left mouse button on the menu
    item).
  prefs: []
  type: TYPE_NORMAL
- en: Also, we are using – once again – callback functions in the `ModelAndInstanceData`
    struct to move the workload to do the undo and redo operations from the user interface
    to the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4.4*, the new ImGui menu bar of the application is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  AI-generated content may be incorrect.](img/Figure_4.4_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Main menu bar, containing the edit menu with undo and redo entries'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Limits and enhancements of our undo/redo implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the biggest shortcomings of the current undo/redo implementation is the
    limitation to react to configuration changes of single instances. We do not capture
    other features, like loading or deleting models, or the creation of multiple instances
    of a model at once.
  prefs: []
  type: TYPE_NORMAL
- en: Adding undo/redo support for multiple instances would need an extension of the
    `AssimpSettingsContainer` class to store all affected instances in a single group.
    In case of an undo or redo operation, we don’t want to step through every single
    instance, but all instances should reappear or disappear at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Including model changes to the undo/redo stacks requires another rework of the
    settings container class. Now, we would have to check what kind of object we are
    working on and add the model change plus the affected instance changes. Deleting
    a model also removes all instances of that model; an undo operation would need
    to restore the model and all instances with their respective settings.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the currently implemented undo/redo functionality to support multiple
    instances and model changes can be found as a task in the *Practical sessions*
    section at the end of this chapter. But be warned, building a mature undo/redo
    system is not trivial and will require a significant amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, keeping up a consistently working undo/redo feature adds a lot
    of overhead to an application, but the time spent on good undo and redo handling
    is well-invested. The future user of any application will thank the programmers
    for being able to recover from unwanted changes, like an accidental change, or
    even the deletion of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added a second application mode to disable all features
    that are not needed for a visit to the virtual world. The user interface, selection,
    and all parts belonging to such topics can be disabled by a hotkey now. Next,
    we tested a basic rollback operation for instance setting changes and enabling
    a simple undo. Finally, we enhanced the rollback to an undo/redo functionality
    for any setting changes on the instance level.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will implement the ability to save the current configuration
    of all models and instances to a file, plus restore all models and instances from
    a saved file. With a working save and load functionality, we can stop changing
    the virtual world at any time and continue in the exact same state at a later
    point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Practical sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some additions you could make to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the **Import Model** button to the menu bar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Import Model** button may feel a bit misplaced since the start, but now
    we have the chance to change the functionality. Move the functionality of the
    button to a submenu of the menu bar, making it easier to understand how to import
    a model to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Add a confirmation dialog when the application is closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use key combinations like `ALT + F4` now or press the icon to close the
    window, the application ends immediately. Add a simple popup dialog with a yes/no
    question, allowing the user to stop another possibly accidental operation. Since
    we have a menu bar now, you can also create a File->Exit entry, calling the same
    logic to request confirmation before closing the application. Oh, and don’t forget
    to switch back to edit mode when the application exit is requested. A hidden exit
    dialog is hardly usable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enhanced difficulty: Add a full-featured undo/redo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now, we only store simple setting changes. Extend the `AssimpSettingContainer`
    class to also store the addition and deletion events of instances. You may need
    an `enum` to store the action because, during the undo and redo operations, you
    need to execute the opposite action. You may have to adjust the two stacks to
    also store vectors of instance settings. Doing a mass-adding of instances should
    be reverted in both directions by a single undo or redo call, not by acting on
    every single instance of the group.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Command pattern, used for undo/redo operations: [https://gameprogrammingpatterns.com/command.html](https://gameprogrammingpatterns.com/command.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Game Programming in C++* by *Sanjay Madhav*, published by *Pearson Addison-Wesley*,
    ISBN 978-0134597201'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
