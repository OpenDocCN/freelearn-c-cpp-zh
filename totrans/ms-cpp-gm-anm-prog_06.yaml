- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Enhancing Application Handling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高应用程序处理能力
- en: Welcome to *Chapter 4*! In the previous chapter, we added capabilities for a
    better selection of a single instance among a possibly large number of models
    and instances. We started with a simple “move to” function and added a highlight
    to the current instance as the next step. Then, we implemented a visual selection
    by using the mouse. Finally, we created a null object to allow selecting no instance
    at all.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**第4章**！在前一章中，我们添加了在可能的大量模型和实例中选择单个实例的能力。我们从简单的“移动到”功能开始，并在下一步添加了对当前实例的高亮显示。然后，我们通过使用鼠标实现了视觉选择。最后，我们创建了一个空对象，以允许选择没有任何实例。
- en: In this chapter, we will focus on the edit mode. First, we will add the capability
    to switch off all controls and menus by creating a separate view mode. The split
    between edit and view modes will help us in later chapters to stop all automatic
    actions when we configure instance settings. Next, we will implement a simplified
    version of the undo functionality, allowing us to reset the settings of a model
    instance after applying changes. As the last step, we will implement undo and
    redo of setting changes on the instance level.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注编辑模式。首先，我们将通过创建一个单独的视图模式来添加关闭所有控制和菜单的能力。编辑和视图模式之间的分离将帮助我们后续章节在配置实例设置时停止所有自动操作。接下来，我们将实现撤销功能的简化版本，允许我们在应用更改后重置模型实例的设置。最后一步，我们将实现实例级别的设置撤销和重做。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Switching between edit and view modes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编辑和视图模式之间切换
- en: Reverting changes before applying
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用更改之前撤销更改
- en: Implementing undo and redo functionality
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现撤销和重做功能
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example source code for this chapter is in the `chapter04` folder, in the
    `01_opengl_edit_view_mode` subfolder for OpenGL and `02_vulkan_edit_view_mode`
    for Vulkan.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码位于`chapter04`文件夹中，对于OpenGL位于`01_opengl_edit_view_mode`子文件夹，对于Vulkan位于`02_vulkan_edit_view_mode`。
- en: After making instance selection easy in [*Chapter 3*](Chapter_3.xhtml), changing
    the settings of an instance will be the next topic to tackle. Right now, we have
    a Control menu on the screen, capturing the mouse input if the pointer is placed
    over the ImGui window. Any change we make will remain permanent in the current
    application session. Reverting any accidental rotation or scaling to the exact
    same value as before could be very difficult since we would have to memorize the
    previous values to undo the change.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](Chapter_3.xhtml)中使实例选择变得容易之后，接下来要解决的问题是更改实例的设置。目前，屏幕上有一个控制菜单，如果指针放在ImGui窗口上，则会捕获鼠标输入。我们做出的任何更改都将保留在当前应用程序会话中。将任何意外的旋转或缩放撤销到与之前完全相同的确切值可能非常困难，因为我们必须记住之前的值来撤销更改。
- en: We will now change the application to toggle to a mode without any controls
    or selection and add a rather simple but useful undo and redo functionality to
    roll changes to instances back or forward.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将应用程序更改为切换到一个没有任何控制或选择模式的模式，并添加一个相当简单但实用的撤销和重做功能，以便将更改回滚到实例或向前推进。
- en: Switching between edit and view modes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编辑和视图模式之间切换
- en: If we start the current version of the application, we will see that a large
    part of the screen is blocked by the user interface whenever we want to make changes
    to instances.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动当前版本的应用程序，我们会看到，每当我们要更改实例时，用户界面都会阻塞屏幕的大部分区域。
- en: '*Figure 4.1* shows what the user interface window looks like when all headers
    are expanded:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.1**显示了当所有标题都展开时用户界面窗口的外观：'
- en: '![](img/Figure_4.1_B22428.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1](img/Figure_4.1_B22428.png)'
- en: 'Figure 4.1: User interface blocking parts of the screen'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：用户界面遮挡屏幕部分
- en: As more and more options will be added later in the book, the user interface
    may fill up even more of the available window space. In addition, a selected instance
    will blink if the highlight is active and the coordinate arrows are placed below
    it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书后面将添加越来越多的选项，用户界面可能会占用更多的可用窗口空间。此外，如果高亮显示处于活动状态，并且坐标箭头位于所选实例下方，则所选实例会闪烁。
- en: To change the overall appearance, we must check which features should be disabled
    in a separate view mode.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变整体外观，我们必须检查在单独的视图模式中应该禁用哪些功能。
- en: Deciding what should be switched in view mode
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定在视图模式下应该切换什么
- en: Our main goal for this section is to remove the ImGui **Control** window to
    have the full application available for interacting with the model instances.
    We could just switch off the rendering of the user interface, but if we do not
    show the user interface window, there is no need to do any calculations like the
    timer and FPS updates. So, for the first decision, we will skip the user interface
    in the **View mode**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本节的主要目标是移除ImGui **控制**窗口，以便整个应用程序可以用于与模型实例交互。我们本可以简单地关闭用户界面的渲染，但如果我们不显示用户界面窗口，就没有必要进行任何计算，如计时器和FPS更新。因此，对于第一个决定，我们将跳过**查看模式**中的用户界面。
- en: We must also add a shortcut to avoid forwarding mouse button events to ImGui
    when the user interface is not active. ImGui saves the positions of all control
    elements, and we would still get unwanted side effects, like being unable to move
    the camera if we switch the user interface while the mouse pointer is above the
    ImGui window.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须添加一个快捷方式，以避免在用户界面不活跃时将鼠标按钮事件转发到ImGui。ImGui保存所有控制元素的位置，如果我们切换用户界面而鼠标指针位于ImGui窗口上方，我们仍然会得到不希望出现的副作用，例如无法移动相机。
- en: Even without a user interface, all parts related to the instance selection are
    still active. This means we do not need the instance selection in view mode, since
    there is no way to adjust instance parameters without a user interface. Our second
    decision here is to switch off everything connected to the instance selection.
    We will disable mouse picking, including the selection shaders, the coordinate
    arrows, and the highlight calculation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有用户界面，所有与实例选择相关的部分仍然处于活动状态。这意味着在查看模式下我们不需要实例选择，因为没有用户界面就无法调整实例参数。我们在这里的第二个决定是关闭与实例选择相关的一切。我们将禁用鼠标拾取，包括选择着色器、坐标箭头和高亮计算。
- en: We will also adjust the window title, reflecting the current view/edit state
    of the application. Changing the window properties from the renderer requires
    a bit of callback “magic” but helps to immediately see what mode the application
    is in.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将调整窗口标题，以反映应用程序当前的查看/编辑状态。从渲染器更改窗口属性需要一点回调“魔法”，但这有助于立即看到应用程序处于何种模式。
- en: The implementation of most of the switch of view and edit mode is simple. We
    just need a variable to save the current state, and some of the branches to enable
    or disable above specified operations for the two modes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数查看和编辑模式的切换实现都很简单。我们只需要一个变量来保存当前状态，以及一些分支来为两种模式启用或禁用上述指定的操作。
- en: Adding the state variable plus code
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加状态变量及代码
- en: 'As the first implementation step, we create a new `enum` class named `appMode`
    in the `OGLRenderData.h` file in the `opengl` folder:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步实现，我们在`opengl`文件夹中的`OGLRenderData.h`文件中创建一个新的`enum`类，命名为`appMode`：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For the Vulkan renderer, the `appMode` `enum` class will reside in the `VkRenderData.h`
    file in the `vulkan` folder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan渲染器，`appMode` `enum`类将位于`vulkan`文件夹中的`VkRenderData.h`文件中。
- en: 'In addition, a variable named `rdApplicationMode` must be added to the `OGLRenderData`
    struct for the OpenGL renderer, and the respective `VkRenderData` struct for the
    Vulkan renderer:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，必须为OpenGL渲染器添加一个名为`rdApplicationMode`的变量到`OGLRenderData`结构体中，以及为Vulkan渲染器相应的`VkRenderData`结构体：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We initialize `rdApplicationMode` with the value for the edit mode, avoiding
    visible changes to the application functionality at startup.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`rdApplicationMode`初始化为编辑模式的值，以避免在启动时对应用程序功能产生可见的变化。
- en: 'To enable or disable a feature in the renderer, depending on the mode, we can
    simply check the value of the `rdApplicationMode` variable:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据模式，要启用或禁用渲染器中的功能，我们可以简单地检查`rdApplicationMode`变量的值：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For example, to switch between the animated shader with and without selection
    support, the following lines are used:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在具有和没有选择支持的动画着色器之间切换，使用以下行：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To disable rendering of the user interface in view mode, we surround the `render()`
    call to the user interface in the renderer with a check for the application mode:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要在查看模式下禁用用户界面的渲染，我们在渲染器中对用户界面的`render()`调用周围添加一个检查应用程序模式：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We disable the timer calls in view mode too – without a user interface on screen,
    filling the timer values would be a waste of computing power.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在查看模式下禁用了计时器调用——没有屏幕上的用户界面，填充计时器值将是计算资源的浪费。
- en: Switching from edit to view mode and back will be done by pressing a hotkey.
    We cannot use an ImGui button here if we disable the user interface completely
    since we would need the button to toggle back to edit mode.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按热键从编辑模式切换到查看模式并返回。如果我们完全禁用用户界面，我们无法在这里使用ImGui按钮，因为我们需要按钮来切换回编辑模式。
- en: Toggling between the two modes and changing the title
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在两种模式之间切换并更改标题
- en: 'For the mode switch, a simple check for the `F10` key is done in the `handleKeyEvents()`
    method of the renderer:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模式切换，在渲染器的`handleKeyEvents()`方法中执行了对`F10`键的简单检查：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Any other unused key can be achieved by placing the respective GLFW key name
    as the second parameter into the `glfwGetKey()` call.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他未使用的键可以通过将相应的GLFW键名作为`glfwGetKey()`调用的第二个参数放置来实现。
- en: 'The call to `setModeInWindowTitle()` needs further explanation, as we are using
    callback functions to change the title string of our application window. The function
    call itself is short and simple:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对`setModeInWindowTitle()`的调用需要进一步解释，因为我们正在使用回调函数来更改应用程序窗口的标题字符串。函数调用本身简短且简单：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We save the original window title in the `init()` method of the renderer, and
    append the default mode (**Edit mode**) to the window title:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在渲染器的`init()`方法中保存原始窗口标题，并将默认模式（**编辑模式**）追加到窗口标题中：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since the Window class initializes the renderer class, we have to move the window
    title change request backward, from the renderer to the application window.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于窗口类初始化渲染器类，我们必须将窗口标题更改请求向后移动，从渲染器到应用程序窗口。
- en: 'First, two `std::function` aliases are created in the renderer header file,
    `OGLRenderer.h` for OpenGL and `VkRenderer.h` for Vulkan:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在渲染器头文件`OGLRenderer.h`（用于OpenGL）和`VkRenderer.h`（用于Vulkan）中创建了两个`std::function`别名：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also add two `public` methods to the declaration of our renderer:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在渲染器的声明中添加了两个`public`方法：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using the aliases makes it easier to handle the calls to `std::function`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用别名使得处理对`std::function`的调用更加容易。
- en: 'Next, we create two methods matching the callback signatures in the `Window`
    class header file, `window.h`, in the `window` folder:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`window`文件夹中的`Window`类头文件`window.h`中创建了两个与回调签名匹配的方法：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In addition, a `private` member variable named `mWindowTitle` is added, storing
    the current title of the window:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还添加了一个名为`mWindowTitle`的`private`成员变量，用于存储窗口的当前标题：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Storing the window title in a variable may be handy for debugging log prints.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将窗口标题存储在变量中可能对调试日志打印很有用。
- en: 'Then, right after initializing the renderer in the `init()` method of the `Window`
    class, two lambda functions are used to forward the `Window` class function calls
    to the renderer:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Window`类的`init()`方法中初始化渲染器之后，使用了两个lambda函数将`Window`类函数调用转发给渲染器：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we press `F10` now, the renderer appends a mode string to the original
    window title and forwards the created string via callback to the Window class.
    This way, the current application mode is presented in the title text of the application
    window.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们按`F10`时，渲染器将模式字符串追加到原始窗口标题中，并通过回调将创建的字符串转发给窗口类。这样，当前应用程序模式就显示在应用程序窗口的标题文本中。
- en: 'In *Figure 4.2*, the user interface and the selection have been disabled. Check
    the window title to see the current mode:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.2*中，用户界面和选择已被禁用。检查窗口标题以查看当前模式：
- en: '![](img/Figure_4.2_B22428.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.2_B22428.png)'
- en: 'Figure 4.2: No user interface in view mode'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：查看模式中没有用户界面
- en: Without the user interface window in view mode, the entire application window
    can be used to fly around in the virtual world. By pressing *F10*, we can go back
    to the edit mode to adjust the parameters of the model instances.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看模式下没有用户界面窗口时，整个应用程序窗口都可以用来在虚拟世界中飞行。通过按*F10*，我们可以回到编辑模式以调整模型实例的参数。
- en: An outlook for future changes
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对未来变化的展望
- en: For every new feature we add later in the book, we must decide how to handle
    the feature in edit and view mode. Some of the new features are only feasible
    in edit mode, like adding and configuring different cameras in [*Chapter 6*](Chapter_6.xhtml).
    Using the cameras, on the other hand, is best done in view mode since we only
    need to switch between different cameras when roaming through the virtual world
    we created. We will have to think about the usage of a new feature every time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书后面添加的每个新功能，我们必须决定如何在编辑和查看模式下处理该功能。其中一些新功能仅在编辑模式下可行，例如在[*第6章*](Chapter_6.xhtml)中添加和配置不同的摄像机。另一方面，使用摄像机最好在查看模式下进行，因为我们只需要在我们创建的虚拟世界中漫游时在不同的摄像机之间切换。每次我们都要考虑新功能的用法。
- en: After adding a separate view mode, let’s go back to the basic application handling.
    Whenever we select an instance and change one of the settings, we are stuck with
    the new value, without a proper way to reset the instance state to a “last known
    good” setting. In the next section, we will add a basic mechanism to revert at
    least the last change to a model instance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了单独的视图模式后，让我们回到基本的应用处理。每次我们选择一个实例并更改其中一个设置时，我们都会被新的值所困扰，没有适当的方法来将实例状态重置为“最后已知良好”的设置。在下一节中，我们将添加一个基本机制，至少将模型实例的最后更改撤销。
- en: Reverting changes before applying
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用更改之前撤销更改
- en: The main purpose of the current model viewer application is to view model instances.
    But, next to pure model viewing, adjusting instance properties and settings will
    become a larger part of the application throughout the book. And changing settings
    can go wrong in many ways. A solution to preview a change sounds like a good feature
    to add.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当前模型查看器应用的主要目的是查看模型实例。但是，在纯模型查看旁边，调整实例属性和设置将在整本书中成为应用的一个更大部分。而更改设置可能会出错。一个预览更改的解决方案听起来像是一个很好的功能来添加。
- en: The basic idea
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本思想
- en: A simple rollback method would allow us to accept a change to the instance setting,
    or to revert the same settings to the previous values. We could experiment with
    the values, try to move the instance to the correct destination, or adjust other
    parameters to fit our needs. When we are happy with the result, we push the **Apply**
    button, and the instance settings are made permanent. The same workflow can be
    used for the next instance, and so on, until we have placed all instances in the
    way we imagined.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的回滚方法将允许我们接受实例设置的更改，或者将相同的设置撤销到之前的值。我们可以尝试实验值，尝试将实例移动到正确的目的地，或者调整其他参数以满足我们的需求。当我们对结果满意时，我们按下**应用**按钮，实例设置就被永久化了。相同的流程可以用于下一个实例，依此类推，直到我们将所有实例放置到我们想象中的位置。
- en: Adding code and User Interface elements
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加代码和用户界面元素
- en: 'First, we add two new `private` members to the `UserInterface.h` header file
    of the `UserInterface` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`UserInterface`类的`UserInterface.h`头文件中添加了两个新的`private`成员：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `mCurrentInstance` smart pointer, we store the currently selected instance,
    and in the `mSavedInstanceSettings` variable, we will save the original settings
    of the currently selected instance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mCurrentInstance`智能指针中，我们存储当前选定的实例，而在`mSavedInstanceSettings`变量中，我们将保存当前选定实例的原始设置。
- en: Since we are retrieving the current instance several times in the user interface,
    we can simply remove the `currentInstance` declaration in all other places within
    the `CollapsingHeader` block.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在用户界面中多次检索当前实例，我们可以在`CollapsingHeader`块内的所有其他地方简单地删除`currentInstance`声明。
- en: 'Reading the settings of the currently selected instance stays the same:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 读取当前选定实例的设置保持不变：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But, in addition, we also check if the currently selected instance is different
    compared to the new `mCurrentInstance` pointer:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还要检查当前选定的实例是否与新的`mCurrentInstance`指针不同：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Whenever the current instance changes, we store the new selected instance in
    the `mCurrentInstance` pointer, and we also save the instance settings we just
    retrieved in the `mSavedInstanceSettings` variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每当当前实例更改时，我们将新的选定实例存储在`mCurrentInstance`指针中，同时我们也将刚刚检索到的实例设置保存到`mSavedInstanceSettings`变量中。
- en: 'The `mSavedInstanceSetting` variable enables us now to revert the settings
    of the instance, undoing any changes. To toggle the setting revert, we add a new
    button named `Reset Values to Previous` below the existing `Reset Values to Zero`
    button:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`mSavedInstanceSetting`变量现在使我们能够撤销实例的设置，撤销任何更改。为了切换设置撤销，我们在现有的`Reset Values
    to Zero`按钮下方添加了一个名为`Reset Values to Previous`的新按钮：'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To undo any changes, we copy the saved instance settings back to the current
    settings variable. At the end of the `CollapsingHeader` **Instances**, the values
    in settings are saved to the currently selected instance. Et voilà, we have reverted
    the settings to the state when we selected the instance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要撤销任何更改，我们将保存的实例设置复制回当前设置变量。在`CollapsingHeader` **实例**的末尾，设置中的值被保存到当前选定的实例中。Et
    voilà，我们已经将设置撤销到了选择实例时的状态。
- en: 'Applying the changes just does the copy operation the other way around:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 应用更改只是执行相反的复制操作：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the saved settings are overwritten by the current settings of the instance,
    making the current settings the new default for an undo operation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，保存的设置被实例的当前设置覆盖，使得当前设置成为撤销操作的新默认值。
- en: '*Figure 4.3* shows the location of the two new buttons:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.3* 展示了两个新按钮的位置：'
- en: '![](img/Figure_4.3_B22428.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3](img/Figure_4.3_B22428.png)'
- en: 'Figure 4.3: Button to revert instance settings, respectively doing a permanent
    apply'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：撤销实例设置或永久应用的按钮
- en: By using the **Apply Changes** button, the current changes to the model instance
    are made permanent. And with the **Reset Values to Previous** button, we can revert
    any changes to the instance to the state when we pressed **Apply Changes** before.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**应用更改**按钮，将当前对模型实例的更改永久化。而使用**重置值到之前**按钮，我们可以将实例的任何更改撤销到我们按下**应用更改**之前的那个状态。
- en: Drawbacks of the current solution
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前解决方案的缺点
- en: Using two buttons to apply or revert every instance setting change is time-consuming
    and cumbersome. A version that applies the changes automatically and more often
    would generate a much better workflow while editing instance properties. The general
    idea from this section will be kept; we just add some more automatic behavior.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个按钮来应用或撤销每个实例设置更改既耗时又繁琐。一个自动应用更改且更频繁的版本将生成在编辑实例属性时的更好工作流程。本节的一般思想将保持不变；我们只是添加了一些更多的自动行为。
- en: Let’s create a real-world undo and redo solution.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个真实的撤销和重做解决方案。
- en: Implementing undo and redo functionality
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现撤销和重做功能
- en: Nearly every application has some way to undo one operation or more, and many
    applications also allow a redo of reverted steps. Accidents can happen in both
    ways; undoing an unwanted undo can save a lot of time and stress for the user.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序都有一种方法可以撤销一个或多个操作，许多应用程序还允许撤销已撤销的步骤。两种方式都可能发生意外；撤销不想要的撤销可以节省用户大量时间和压力。
- en: What do we need to create undo and redo?
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们需要什么来创建撤销和重做？
- en: To be able to undo a simple operation that changes object properties, we need
    to save the previous values. Undoing that change could then be done by applying
    the “old” values to the same object, and restoring the state of that object before
    the change.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够撤销一个改变对象属性的简单操作，我们需要保存前一个值。然后可以通过将“旧”值应用到相同的对象上来撤销该更改，并恢复该对象在更改之前的状态。
- en: For more complex undo operations, storing the operation type is also required.
    If we delete something, the undo step must recreate the object with the same properties,
    and vice versa – undoing the creation of a new object will delete that object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的撤销操作，存储操作类型也是必需的。如果我们删除了某些内容，撤销步骤必须重新创建具有相同属性的对象，反之亦然——撤销创建新对象的操作将删除该对象。
- en: Other options could be also taken into account. Do we want to store the absolute
    previous values or just the difference to the new values? By storing relative
    values, redoing the changes that followed the reverted operation could use the
    adjusted values as a basis, while absolute values would overwrite intermitted
    adjustments. And do we store the complete settings for that object, or only the
    changed parameter(s)? The implication is similar to the absolute and relative
    values before.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以考虑其他选项。我们是否想要存储绝对的前一个值，还是只存储与新值之间的差异？通过存储相对值，在撤销操作之后重做更改可以使用调整后的值作为基础，而绝对值将覆盖中间的调整。并且我们是否存储该对象的完整设置，还是只存储更改的参数？其含义与之前的绝对值和相对值类似。
- en: 'From a technical side, our implementation will use two stacks: one for the
    possible undo operations and another for the possible redo operations. Every configuration
    change will push the new and the old settings to the undo stack, allowing the
    reversal of the changes by applying the old settings.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，我们的实现将使用两个堆栈：一个用于可能的撤销操作，另一个用于可能的重做操作。每次配置更改都会将新的和旧的设置推送到撤销堆栈，通过应用旧的设置来允许撤销更改。
- en: After the undo operation has been done, the very same setting combination will
    be taken from the undo stack and pushed to the redo stack. If we now do a redo
    of the same operation, the new settings will be applied, and the settings will
    be moved back to the undo stack.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行撤销操作之后，将直接从撤销堆栈中取出完全相同的设置组合并将其推送到重做堆栈。如果我们现在对相同的操作进行重做，新设置将被应用，并且设置将移回撤销堆栈。
- en: This simple workflow will allow us a virtually endless undo and redo size, limited
    mostly by the amount of memory in the computer. And, since the settings are small,
    it would take a very long time to fill up the computer memory with the two stacks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的流程将使我们几乎可以无限地撤销和重做，主要受限于计算机内存的容量。而且，由于设置很小，用这两个堆栈填满计算机内存将需要很长时间。
- en: As the first step on the road to undo and redo, we will create a storage container
    class that encapsulates all the information we need to revert the settings in
    one or the other direction.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在撤销和重做的道路上迈出的第一步是创建一个存储容器类，该类封装了我们需要的所有信息，以便在任一方向上撤销设置。
- en: Creating a setting storage class
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建设置存储类
- en: 'The new class is called `AssimpSettingsContainer`, and the header and implementation
    file are in the model folder. In the header file, a struct is declared to store
    all the settings we need for both undo and redo:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类称为 `AssimpSettingsContainer`，其头文件和实现文件位于模型文件夹中。在头文件中，声明了一个结构体来存储我们为撤销和重做所需的所有设置：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `AssimpInstanceSettings` struct saves the previous and current settings
    of an instance, along with a weak pointer to the instance. Using `std::weak_ptr`
    instead of `std::shared_ptr` here has two important reasons:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssimpInstanceSettings` 结构体保存了实例的先前和当前设置，以及指向实例的弱指针。在这里使用 `std::weak_ptr`
    而不是 `std::shared_ptr` 有两个重要原因：'
- en: A weak pointer breaks the dependency between the `miAssimpInstances` vector
    containing the instance `std::shared_ptr` and the settings stored for undo/redo
    because a weak pointer is not added to the reference counter of the smart pointer
    for the instance. If we use another shared pointer when storing the undo/redo
    information instead, the memory for a deleted instance may not be freed, since
    there could be another active reference to the instance stored somewhere in the
    undo or redo stack.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱指针打破了包含实例 `std::shared_ptr` 的 `miAssimpInstances` 向量与存储撤销/重做的设置之间的依赖关系，因为弱指针不会被添加到实例智能指针的引用计数器中。如果我们使用另一个共享指针来存储撤销/重做信息，那么删除实例的内存可能不会被释放，因为可能存在另一个活动引用存储在撤销或重做栈中的某个地方。
- en: When requesting the weak pointer to return the shared pointer by using the `lock()`
    call, we can easily find deleted instances and remove the saved settings. The
    `lock()` call returns a `nullptr` if the shared pointer is no longer available,
    and we simply use a `pop()` call on the respective stack to remove the dead settings.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `lock()` 调用请求通过弱指针返回共享指针时，我们可以轻松地找到已删除的实例并移除保存的设置。如果共享指针不再可用，`lock()` 调用将返回
    `nullptr`，我们只需在相应的栈上使用 `pop()` 调用来移除无效的设置。
- en: If we want to save the settings instances of an instance, we call the `apply()`
    method of the `AssimpSettingsContainer` class. The `apply()` method creates a
    new `AssimpInstanceSettings` object and pushes the settings to the undo stack.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要保存实例的设置实例，我们调用 `AssimpSettingsContainer` 类的 `apply()` 方法。`apply()` 方法创建一个新的
    `AssimpInstanceSettings` 对象，并将设置推送到撤销栈。
- en: We also clear the redo stack while saving a new setting via `apply()`. It may
    be useless to use the redo operation after we reverted a couple of changes and
    applied recent changes since the redo operations could create conflicts with the
    latest changes, or even overwrite the latest change. Removing all settings from
    the redo stack is a quick and safe way to avoid side effects after the latest
    changes are applied.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在通过 `apply()` 保存新设置的同时也清空重做栈。在我们撤销了几次更改并应用了最近更改之后，使用重做操作可能毫无意义，因为重做操作可能会与最新更改产生冲突，甚至覆盖最新更改。从重做栈中移除所有设置是避免最新更改应用后副作用的一种快速且安全的方法。
- en: 'The implementation of the `undo()` and `redo()` methods is short and simple:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`undo()` 和 `redo()` 方法的实现简短且简单：'
- en: Check for any deleted instances by requesting the shared pointer from the weak
    pointer, and remove the settings struct if the instance pointer is invalid. The
    check will be done in a `while()` loop to find all deleted instances.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从弱指针请求共享指针来检查任何已删除的实例，如果实例指针无效，则移除设置结构体。检查将在 `while()` 循环中完成，以找到所有已删除的实例。
- en: If the stack is empty (i.e., because all instances that had settings saved for
    undo or redo are gone), we return from the operation immediately.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果栈为空（即，因为所有为撤销或重做保存了设置的实例都已消失），我们立即从操作中返回。
- en: Get the top entry from the stack and apply the saved settings to the instance
    in case of an undo operation, or the new settings for a redo operation.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从栈中获取顶部条目，并在撤销操作的情况下应用保存的设置到实例，或者在重做操作的情况下应用新设置。
- en: Push the top entry of a stack to the opposite stack and remove the top entry.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将栈顶条目推送到相反的栈中，并移除栈顶条目。
- en: Now, all relevant instance changes can be saved to the undo stack. If we choose
    to undo a change to an instance, we can also immediately redo the very same change.
    In the background, the structs containing old and new settings and the instance
    pointer are just moved between the two stacks on undo and redo operations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有相关的实例更改都可以保存到撤销堆栈中。如果我们选择撤销对实例的更改，我们也可以立即重做完全相同的更改。在后台，包含旧的和新的设置以及实例指针的结构体只是在撤销和重做操作的两个堆栈之间移动。
- en: Adding the new operations to the renderer requires a bit of extra work.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将新操作添加到渲染器需要一些额外的工作。
- en: Hooking up the storage class to the renderer
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将存储类连接到渲染器
- en: The renderer will be extended by two new methods for the undo/redo related code,
    called `undoLastOperation()` and `redoLastOperation()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器将通过两个新方法扩展与撤销/重做相关代码，分别称为`undoLastOperation()`和`redoLastOperation()`。
- en: 'At the start of each of the methods, we call the respective operation on the
    settings container:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种方法的开始，我们都在设置容器上调用相应的操作：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In addition, a call to `assignInstanceIndices()` will be issued. Enumerating
    all instances after undo and redo operations is crucial. The settings taken from
    the stack could contain an invalid instance index in the `isInstanceIndexPosition`
    variable after other instances have been deleted, resulting in access outside
    the `miAssimpInstance` vector.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还将发出对`assignInstanceIndices()`的调用。在撤销和重做操作之后枚举所有实例至关重要。从堆栈中取出的设置在删除其他实例后，`isInstanceIndexPosition`变量中的实例索引可能无效，导致访问`miAssimpInstance`向量之外的内容。
- en: A side effect of the enumeration is a position change in the `miAssimpInstances`
    vector. So, we cannot just take the new `isInstanceIndexPosition` to select the
    instance that was changed by the undo or redo operation. Instead, we retrieve
    the instance pointer of the changed instance from `AssimpInstanceSettings` and
    use `std::find_if` to search the `miAssimpInstance` vector for a matching pointer.
    If we don’t find the correct instance, the null instance will be selected, resulting
    in no instance to be selected.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的一个副作用是在`miAssimpInstances`向量中的位置变化。因此，我们不能仅仅使用新的`isInstanceIndexPosition`来选择被撤销或重做操作更改的实例。相反，我们从`AssimpInstanceSettings`中检索更改实例的实例指针，并使用`std::find_if`在`miAssimpInstance`向量中搜索匹配的指针。如果我们找不到正确的实例，将选择空实例，导致没有实例被选中。
- en: Defining hotkeys for undo and redo
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义撤销和重做的快捷键
- en: 'To use undo and redo functions by using known key combinations on the keyboard,
    we add the new keys to the `handleKeyEvents()` method in the renderer:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过在键盘上使用已知的关键组合来使用撤销和重做功能，我们在渲染器中的`handleKeyEvents()`方法中添加了新键：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, only the undo part is shown, utilizing the key combination `CTRL + Z`,
    like many other applications. The redo function is called when `CTRL + Y` is pressed,
    which is also a well-known key combination to redo changes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只展示了撤销部分，使用键盘组合`CTRL + Z`，就像许多其他应用程序一样。当按下`CTRL + Y`时，会调用重做功能，这也是一个众所周知的关键组合，用于重做更改。
- en: Undo and redo functionality will only be activated in edit mode. We cannot adjust
    instance settings in view mode, so we also do not need to revert or redo changes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 撤销和重做功能仅在编辑模式下激活。我们无法在查看模式下调整实例设置，因此我们也不需要撤销或重做更改。
- en: We are now able to call the undo and redo functions by key combinations. However,
    for easier access, reaching both operations via a menu bar would be great.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过键盘组合调用撤销和重做功能。然而，为了更方便地访问，通过菜单栏访问这两个操作会更好。
- en: Adding an ImGui menu to allow direct access
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加ImGui菜单以允许直接访问
- en: 'Luckily, a menu bar can be added with a few ImGui calls:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以通过几个ImGui调用来添加菜单栏：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Like other ImGui widgets, the main menu bar itself, and all menus in the menu
    bar, start with an `ImGui::Begin*()` line and end with an `ImGui::End*()` line.
    As with other ImGui widgets, the ImGui menu commands return a Boolean value of
    `true` if they are activated (i.e., by clicking the left mouse button on the menu
    item).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他ImGui小部件一样，主菜单栏本身以及菜单栏中的所有菜单都从`ImGui::Begin*()`行开始，并以`ImGui::End*()`行结束。与其他ImGui小部件一样，ImGui菜单命令在激活时（即通过在菜单项上单击左鼠标按钮）返回一个布尔值`true`。
- en: Also, we are using – once again – callback functions in the `ModelAndInstanceData`
    struct to move the workload to do the undo and redo operations from the user interface
    to the renderer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们再次在`ModelAndInstanceData`结构体中使用回调函数，将撤销和重做操作的工作负载从用户界面移动到渲染器。
- en: 'In *Figure 4.4*, the new ImGui menu bar of the application is shown:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.4*中，显示了应用程序的新ImGui菜单栏：
- en: '![A screenshot of a computer  AI-generated content may be incorrect.](img/Figure_4.4_B22428.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 AI生成的内容可能不正确。](img/Figure_4.4_B22428.png)'
- en: 'Figure 4.4: Main menu bar, containing the edit menu with undo and redo entries'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：主菜单栏，包含带有撤销和重做条目的编辑菜单
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Limits and enhancements of our undo/redo implementation
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们撤销/重做实现的限制和增强
- en: One of the biggest shortcomings of the current undo/redo implementation is the
    limitation to react to configuration changes of single instances. We do not capture
    other features, like loading or deleting models, or the creation of multiple instances
    of a model at once.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当前撤销/重做实现的最大缺点是限制了对单个实例配置更改的反应。我们没有捕获其他功能，如加载或删除模型，或一次创建多个模型实例。
- en: Adding undo/redo support for multiple instances would need an extension of the
    `AssimpSettingsContainer` class to store all affected instances in a single group.
    In case of an undo or redo operation, we don’t want to step through every single
    instance, but all instances should reappear or disappear at the same time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为多个实例添加撤销/重做支持需要对`AssimpSettingsContainer`类进行扩展，以在单个组中存储所有受影响的实例。在撤销或重做操作中，我们不想逐个实例进行操作，但所有实例应同时出现或消失。
- en: Including model changes to the undo/redo stacks requires another rework of the
    settings container class. Now, we would have to check what kind of object we are
    working on and add the model change plus the affected instance changes. Deleting
    a model also removes all instances of that model; an undo operation would need
    to restore the model and all instances with their respective settings.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 包括对撤销/重做堆栈的模型更改需要重新设计设置容器类。现在，我们必须检查我们正在处理哪种类型的对象，并添加模型更改以及受影响的实例更改。删除一个模型也会删除该模型的所有实例；撤销操作需要恢复模型及其所有实例及其相应的设置。
- en: Extending the currently implemented undo/redo functionality to support multiple
    instances and model changes can be found as a task in the *Practical sessions*
    section at the end of this chapter. But be warned, building a mature undo/redo
    system is not trivial and will require a significant amount of time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前实现的撤销/重做功能扩展到支持多个实例和模型更改，可以在本章末尾的*实践课程*部分找到一个任务。但请注意，构建一个成熟的撤销/重做系统并非易事，并且需要大量的时间。
- en: As you can see, keeping up a consistently working undo/redo feature adds a lot
    of overhead to an application, but the time spent on good undo and redo handling
    is well-invested. The future user of any application will thank the programmers
    for being able to recover from unwanted changes, like an accidental change, or
    even the deletion of elements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，保持一致的撤销/重做功能会增加应用程序的很多开销，但投入在良好的撤销和重做处理上的时间是值得的。任何应用程序的未来用户都会感谢程序员能够从不受欢迎的更改中恢复，比如意外的更改，甚至元素的删除。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we added a second application mode to disable all features
    that are not needed for a visit to the virtual world. The user interface, selection,
    and all parts belonging to such topics can be disabled by a hotkey now. Next,
    we tested a basic rollback operation for instance setting changes and enabling
    a simple undo. Finally, we enhanced the rollback to an undo/redo functionality
    for any setting changes on the instance level.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们添加了第二种应用程序模式，以禁用所有不适用于虚拟世界访问的功能。用户界面、选择以及属于这些主题的所有部分现在可以通过热键禁用。接下来，我们测试了实例设置更改的基本回滚操作和启用简单的撤销。最后，我们将回滚增强为实例级别任何设置更改的撤销/重做功能。
- en: In the next chapter, we will implement the ability to save the current configuration
    of all models and instances to a file, plus restore all models and instances from
    a saved file. With a working save and load functionality, we can stop changing
    the virtual world at any time and continue in the exact same state at a later
    point in time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现将所有模型和实例的当前配置保存到文件中的功能，以及从保存的文件中恢复所有模型和实例。有了工作的保存和加载功能，我们可以在任何时候停止更改虚拟世界，并在稍后的时间点以完全相同的状态继续。
- en: Practical sessions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: 'There are some additions you could make to the code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在代码中添加一些内容：
- en: Move the **Import Model** button to the menu bar.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**导入模型**按钮移动到菜单栏。
- en: The **Import Model** button may feel a bit misplaced since the start, but now
    we have the chance to change the functionality. Move the functionality of the
    button to a submenu of the menu bar, making it easier to understand how to import
    a model to the application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入模型**按钮可能从一开始就感觉有点放错位置，但现在我们有机会改变其功能。将按钮的功能移动到菜单栏的子菜单中，使其更容易理解如何将模型导入到应用程序中。'
- en: Add a confirmation dialog when the application is closed.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序关闭时添加一个确认对话框。
- en: If we use key combinations like `ALT + F4` now or press the icon to close the
    window, the application ends immediately. Add a simple popup dialog with a yes/no
    question, allowing the user to stop another possibly accidental operation. Since
    we have a menu bar now, you can also create a File->Exit entry, calling the same
    logic to request confirmation before closing the application. Oh, and don’t forget
    to switch back to edit mode when the application exit is requested. A hidden exit
    dialog is hardly usable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在使用像 `ALT + F4` 这样的快捷键组合或点击图标来关闭窗口，应用程序会立即结束。添加一个简单的弹出对话框，包含是/否问题，允许用户停止另一个可能的事故性操作。由于我们现在有了菜单栏，你也可以创建一个
    File->Exit（文件->退出）的条目，调用相同的逻辑在关闭应用程序前请求确认。哦，别忘了当请求应用程序退出时切换回编辑模式。一个隐藏的退出对话框几乎不可用。
- en: 'Enhanced difficulty: Add a full-featured undo/redo.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强难度：添加一个功能齐全的撤销/重做。
- en: Right now, we only store simple setting changes. Extend the `AssimpSettingContainer`
    class to also store the addition and deletion events of instances. You may need
    an `enum` to store the action because, during the undo and redo operations, you
    need to execute the opposite action. You may have to adjust the two stacks to
    also store vectors of instance settings. Doing a mass-adding of instances should
    be reverted in both directions by a single undo or redo call, not by acting on
    every single instance of the group.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只存储简单的设置更改。扩展`AssimpSettingContainer`类以存储实例的添加和删除事件。你可能需要一个`enum`来存储操作，因为在撤销和重做操作期间，你需要执行相反的操作。你可能需要调整两个栈以存储实例设置的向量。对实例进行大量添加应该可以通过单个撤销或重做调用在两个方向上回滚，而不是对每个组中的单个实例进行操作。
- en: Additional resources
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The Command pattern, used for undo/redo operations: [https://gameprogrammingpatterns.com/command.html](https://gameprogrammingpatterns.com/command.html)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于撤销/重做操作的命令模式：[https://gameprogrammingpatterns.com/command.html](https://gameprogrammingpatterns.com/command.html)
- en: '*Game Programming in C++* by *Sanjay Madhav*, published by *Pearson Addison-Wesley*,
    ISBN 978-0134597201'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*C++游戏编程*》由*Sanjay Madhav*著，由*Pearson Addison-Wesley*出版，ISBN 978-0134597201
