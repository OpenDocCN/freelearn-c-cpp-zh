<html><head></head><body>
<div><h1 class="chapterNumber">3</h1>
<h1 class="chapterTitle" id="_idParaDest-47">Embedded C++ Ecosystem</h1>
<p class="normal">At the heart of every embedded system sits a microcontroller. The transition from basic cores to more modern ones mirrors the evolution of technology. The microcontroller landscape is vast, ranging from cost-effective 8-bit cores and 16-bit cores to modern 32-bit Arm and RISC-V® based microcontrollers. This variety of architecture has impacted the development of tools and compilers. While some manufacturers have opted to focus on C support, many have recognized the importance of C++ and provided good support for C++ development within their toolchains.</p>
<p class="normal">As the embedded system is vast and it is impossible to cover all of the available architectures and vendors, we will focus on Arm® Cortex®-M as one of the dominant architectures for modern microcontrollers <a id="_idIndexMarker123"/>and <strong class="keyWord">Systems on a Chip</strong> (<strong class="keyWord">SoCs</strong>). We will go through the available development environments and toolchains that provide support for development in C++ for the Arm Cortex-M. We will also go through tools such as static analyzers, learn how to profile an embedded target, and cover methodologies such as unit testing.</p>
<p class="normal">In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li class="bulletList">Compilers and development environments</li>
<li class="bulletList">Static analyzers</li>
<li class="bulletList">Unit testing</li>
<li class="bulletList">Profiling</li>
</ul>
<h1 class="heading-1" id="_idParaDest-48">Technical requirements</h1>
<p class="normal">To get the most out of this chapter, I strongly recommend using Compiler Explorer (<a href="https://godbolt.org/">https://godbolt.org/</a>) as you read through the examples. Select GCC as your compiler and target x86 architecture. This will allow you to see standard output (stdio) results and better observe the code’s behavior. As we are using a lot of modern C++ features, make sure to select C++23 standard, by adding <code class="inlineCode">-std=c++23</code> in compiler options box.</p>
<p class="normal">The examples from this chapter are available on GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter03">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter03</a>).</p>
<h1 class="heading-1" id="_idParaDest-49">Compilers and development environments</h1>
<p class="normal">The adoption of C++ in embedded<a id="_idIndexMarker124"/> systems was influenced by compiler support. While most compilers supported C, the support for C++ was slower. Nowadays, there is a variety of compilers and toolchains available for C++ depending on the target architecture and functional <a id="_idIndexMarker125"/>safety requirements. Support for 32-bit architecture such as Arm Cortex-M is generally good, but the level of support depends on the toolchain vendor and functional safety requirements.</p>
<p class="normal">Many vendors offer functional safety versions of their tools that include certified compilers according to the safety standards for different industries. Functional safety standards are designed to ensure that software operates correctly and safely, even in the event of hardware failures or operational errors. IEC 61508 is the international umbrella safety standard for functional safety, and the following are safety standards for some industries:</p>
<ul>
<li class="bulletList"><strong class="keyWord">ISO 26262</strong>: Automotive safety standard</li>
<li class="bulletList"><strong class="keyWord">EN 50128</strong>: European railways safety standard</li>
<li class="bulletList"><strong class="keyWord">IEC 62304</strong>: International standard for medical software</li>
<li class="bulletList"><strong class="keyWord">IEC 60730-1</strong>: Automatic electrical control for household appliances</li>
</ul>
<p class="normal">Functional safety<a id="_idIndexMarker126"/> requirements <a id="_idIndexMarker127"/>are one of the first items on our checklist when selecting a compiler for a new project. If they call for qualified compilers, then we are limited to commercial versions of compilers that provide qualified compilers according to the exact standard in question.</p>
<p class="normal">While many vendors providing tools for embedded development provide functional safety versions of their tools and compilers, there are also free development environments and open source compilers for embedded system development that can be used in non-critical applications.</p>
<p class="normal">Development environments pack different tools to make the development process seamless and allow you to focus on the development. These tools can also be used individually and tailored according to individual or organizational preferences. Tools used for embedded development, either individually or integrated into a development environment, are listed as follows:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Code editor</strong>: This <a id="_idIndexMarker128"/>can be as basic as a text editor or a more advanced tool such as Vim or Visual Studio Code supporting plugins for features such as syntax highlighting, autocompletion, code navigation across different source files, and refactoring.</li>
<li class="bulletList"><strong class="keyWord">Compiler and linker</strong>: These <a id="_idIndexMarker129"/>are used to transform code into object files and link them to executable and binary files that can be flashed to a target. Some of the most popular C++ compilers are GCC, Clang, Arm Compiler for Embedded, and IAR C/C++ Compiler.</li>
<li class="bulletList"><strong class="keyWord">Debugger</strong>: It is <a id="_idIndexMarker130"/>used to flash and debug a target. Parts of the debugging system are a debugger probe and software that communicates with a probe to debug the connected target.</li>
<li class="bulletList"><strong class="keyWord">Build system</strong>: Tools such as <a id="_idIndexMarker131"/>GNU Make and Ninja are used to control the process of compiling and linking. CMake and Bazel are used for build automation and dependency management.</li>
<li class="bulletList"><strong class="keyWord">Static analysis tools</strong>: These<a id="_idIndexMarker132"/> are used to analyze source code. Depending on capability, they can detect some forms of undefined behavior such as out-of-bound access, uninitialized variables, null pointer dereferences, and so on. Dedicated static analysis tools can check whether the code is MISRA or AUTOSAR-compliant.</li>
<li class="bulletList"><strong class="keyWord">Runtime profilers</strong>: These <a id="_idIndexMarker133"/>are a combination of target capabilities, software instrumentation, and debugger probes used to measure function execution time and analyze the performance of your software.</li>
</ul>
<p class="normal">Most <a id="_idIndexMarker134"/>embedded <strong class="keyWord">integrated development environments</strong> (<strong class="keyWord">IDEs</strong>) provide the following capabilities:</p>
<ul>
<li class="bulletList">Project creation and organization</li>
<li class="bulletList">Build automation</li>
<li class="bulletList">Debugging</li>
</ul>
<p class="normal">Some development environments integrate more advanced features for code analysis, such as the following:</p>
<ul>
<li class="bulletList">Static analysis</li>
<li class="bulletList">Profiling and performance analysis</li>
</ul>
<p class="normal">We will cover some of the most used development environments and compilers in the industry on the next pages.</p>
<h2 class="heading-2" id="_idParaDest-50">Arm Keil MDK and Arm Compiler for Embedded</h2>
<p class="normal"><strong class="keyWord">Arm® Keil® MDK</strong> is a set of tools for embedded development on (mostly) Arm Cortex-M microcontrollers and it includes the following:</p>
<ul>
<li class="bulletList">Keil Studio, a set of extensions for VS Code</li>
<li class="bulletList">Keil μVision, a legacy Windows®-based IDE</li>
<li class="bulletList">Arm Compiler for Embedded, a C and C++ compiler</li>
<li class="bulletList">Arm Virtual Hardware</li>
</ul>
<p class="normal">Both <strong class="keyWord">Keil Studio</strong> and <strong class="keyWord">Keil μVision</strong> provide <a id="_idIndexMarker135"/>all the IDE features needed for embedded development, including project configuration for different targets, build, and debugging on target.</p>
<p class="normal">Keil μVision provides <a id="_idIndexMarker136"/>support for the integration of PC-Lint, a static C and C++ analyzer, while VS Code (Keil Studio) can be configured to use <code class="inlineCode">clang-tidy</code> or <code class="inlineCode">cppcheck</code>.</p>
<p class="normal">Keil μVision is packed with Keil Simulator, allowing running firmware on simulated targets on your PC, and it also has an integrated profiler as a part of the μVision debugger.</p>
<p class="normal">Arm Keil MDK comes with Arm Virtual Hardware Fixed Virtual Platforms, which is Arm’s cloud platform that allows you to run binaries on simulated targets providing infrastructure for CI/CD in a simulated environment.</p>
<p class="normal">There is a basic version of Keil MDK available for non-commercial use (Community), and two commercial versions (Essential and Professional), depending on the features available. Only the Professional commercial version comes with functional safety support and extended maintenance. Next, we will cover Arm Compiler for Embedded, a C and C++ compiler that comes with MDK. It also includes linker and standard libraries.</p>
<p class="normal"><strong class="keyWord">Arm Compiler for Embedded</strong> is a<a id="_idIndexMarker137"/> C and C++ compiler provided by Arm. Arm also <a id="_idIndexMarker138"/>provides a <strong class="keyWord">functional safety</strong> (<strong class="keyWord">FuSa</strong>) version of the compiler that is certified according to IEC 61508, ISO 26262, EN 50128, and IEC 62304 safety standards.</p>
<p class="normal">The FuSa version is available only in the highest edition of MDK – Professional.</p>
<p class="normal">Arm Compiler for <a id="_idIndexMarker139"/>Embedded consists of the following toolchain components:</p>
<ul>
<li class="bulletList"><code class="inlineCode">armclang</code>, a <strong class="keyWord">low-level virtual machine</strong> (<strong class="keyWord">LLVM</strong>)-based compiler</li>
<li class="bulletList"><code class="inlineCode">armlink</code>, a linker that combines objects and libraries to produce an executable</li>
<li class="bulletList">Arm C libraries</li>
<li class="bulletList">Arm C++ libraries based on the LLVM <code class="inlineCode">libc++</code> project</li>
</ul>
<p class="normal">Arm Compiler supports C++17 standard, while the latest version of Arm Compiler for Embedded FuSa 6.16 supports C++ 14. Even though we are in 2024 at the time of writing this book, the support for the latest version of the C++ standard is slow. After C++17, C++20 and C++23 were released.</p>
<p class="normal">Support of the latest C++ standard in commercial compilers is still rather slow, which makes the latest language features in these environments unavailable.</p>
<h2 class="heading-2" id="_idParaDest-51">IAR C/C++ Compiler and IAR Embedded Workbench for Arm</h2>
<p class="normal"><strong class="keyWord">IAR Embedded Workbench®</strong> is a <a id="_idIndexMarker140"/>development environment for Arm Cortex-M, Cortex-R, and <a id="_idIndexMarker141"/>Cortex-A cores (IAR stands for Ingenjörsfirma Anders Rundgren). It integrates the following tools:</p>
<ul>
<li class="bulletList">IDE, including a debugger and profiler</li>
<li class="bulletList">IAR C/C++ Compiler</li>
<li class="bulletList">IAR C-STAT®, a static analyzer</li>
<li class="bulletList">IAR C-RUN®, a tool for runtime analysis</li>
</ul>
<p class="normal">IAR Embedded Workbench is a well-rounded solution for the development of Arm Cortex-M cores. The IDE is packed with standard tools, such as a debugger, but also provides more advanced embedded tools, such as a profiler and running firmware in the simulator.</p>
<p class="normal">IAR offers C-STAT, a tool for static analysis that can run static analysis against safety coding standards such as MISRAC++2008.</p>
<p class="normal">IAR also provides C-RUN, a tool for runtime analysis that covers heap checks, bounds checking, buffer overrun, integer overflow, and other runtime checks by instrumenting your code.</p>
<p class="normal">IAR C/C++ Compiler <a id="_idIndexMarker142"/>supports C++17 from 9.30.1. The FuSa version of IAR Embedded Workbench for Arm, version 9.50.3 (February 2024), also provides C++17 support.</p>
<p class="normal">IAR C/C++ Compiler and Arm Compiler for Embedded are commercial options for embedded development. Besides the support you can expect from a commercial project, the strength of these tools is that they provide safety-qualified versions for safety-critical projects.</p>
<p class="normal">Some microcontroller vendors provide their own versions of development environments, usually based on Eclipse®, providing additional support for their own products.</p>
<h2 class="heading-2" id="_idParaDest-52">Vendor-supported IDEs and GCC</h2>
<p class="normal">Alternatives to <a id="_idIndexMarker143"/>commercial development environments are vendor-supported environments, which are based mostly on Eclipse and <strong class="keyWord">GNU Compiler Collection</strong> (<strong class="keyWord">GCC</strong>) tools and <strong class="keyWord">GNU Project Debugger (GDB</strong>) for debugging. Examples are STM32CubeIDE by ST® and MCUXpresso by NXP®.</p>
<p class="normal">These tools <a id="_idIndexMarker144"/>are packed with code configurator UIs that can generate C code used for GPIO configuration, clock setup, and peripheral drivers’ initialization.</p>
<p class="normal">Some vendors, such as <a id="_idIndexMarker145"/>Nordic Semiconductor®, opted for VS Code as the basis of their IDE solution. They provide plugins for GPIO configuration and debugging. VS Code is a modern code editor that allows developers to use plugins such as IntelliSense for code completion, parameter information, syntax highlighting, and many others to enhance the development experience.</p>
<h3 class="heading-3" id="_idParaDest-53">GCC</h3>
<p class="normal">GCC is one of the<a id="_idIndexMarker146"/> most used C and C++ compilers in general. It is free software, and it is also the most popular compiler for non-critical applications that do not require a qualified compiler. However, even GCC can be qualified. The process of <a id="_idIndexMarker147"/>qualification includes compiling and running test programs and comparing outputs against expected results. All the issues that are found must be documented and a process must be put in place to mitigate them.</p>
<p class="normal">Besides the compiler, GCC also includes an assembler and linker, providing users with a so-called driver program (<code class="inlineCode">gcc</code> for C and <code class="inlineCode">g++</code> for C++). When invoked, the driver program runs preprocessing, compilation, assembly, and linking. The following figure visualizes the GCC compilation process:</p>
<figure class="mediaobject"><img alt="Figure 3.1 – GCC compilation process" src="img/B22402_3_01.png"/></figure>
<p class="packt_figref">Figure 3.1 – GCC compilation process</p>
<p class="normal">In <em class="italic">Figure 3</em><em class="italic">.1</em>, we see what<a id="_idIndexMarker148"/> happens when GCC is used to compile a single file, <code class="inlineCode">main.cpp</code>:</p>
<ol>
<li class="numberedList" value="1">GCC first runs the preprocessor, adding all header files specified with the <code class="inlineCode">#include</code> directive and expanding macros in the translation unit.</li>
<li class="numberedList">The result from the preprocessor stage is run through the compiler, generating assembly.</li>
<li class="numberedList">The output of the assembly stage is an object file.</li>
<li class="numberedList">Finally, the linker links the object file with C and C++ standard libraries and generates an ELF file.</li>
</ol>
<p class="normal">The GCC driver program can be supplied with additional arguments to provide outputs from intermediate phases. To redirect preprocessor output to standard output, one can use the <code class="inlineCode">-E</code> flag:</p>
<pre class="programlisting con"><code class="hljs-con">arm-none-eabi-g++ -E main.cpp
</code></pre>
<p class="normal">The preceding command will result in a lengthy output if <code class="inlineCode">main.cpp</code> includes the <strong class="keyWord">C Standard Input and Output</strong> (<strong class="keyWord">cstdio</strong>) library. You <a id="_idIndexMarker149"/>can write a simple <code class="inlineCode">hello world</code> program and see it for yourself by running the preceding command, or you can use Compiler Explorer.</p>
<h3 class="heading-3" id="_idParaDest-54">Compiler Explorer</h3>
<p class="normal"><strong class="keyWord">Compiler Explorer</strong> (<a href="https://github.com/compiler-explorer/compiler-explorer">https://github.com/compiler-explorer/compiler-explorer</a>) is an interactive<a id="_idIndexMarker150"/> online compiler that shows the assembly output of compiled C++, Rust, Go, and other code. You can try it online (<a href="https://godbolt.org/">https://godbolt.org/</a>). It is a great tool that, by default, shows the assembly output and can be used to explore different language features with different compilers and compiler flags.</p>
<p class="normal">Let’s use Compiler Explorer<a id="_idIndexMarker151"/> to explore the GCC compilation process. We will select <strong class="screenText">ARM GCC 11.2.1 (none)</strong> as our compiler and provide it with an <code class="inlineCode">-E</code> flag. <strong class="screenText">ARM GCC 11.2.1 (none)</strong>, or <strong class="screenText">arm-none-eabi-gcc</strong>, is the GCC used for Cortex-M architecture. In the following figure, we can see the preprocessor output in Compiler Explorer:</p>
<figure class="mediaobject"><img alt="Figure 3.2 – Compiler Explorer: preprocessor output" src="img/B22402_3_02.png"/></figure>
<p class="packt_figref">Figure 3.2 – Compiler Explorer: preprocessor output</p>
<p class="normal">In <em class="italic">Figure 3</em><em class="italic">.2</em>, we can see that the preprocessor adds exactly 800 lines to our simple <code class="inlineCode">hello world</code> example. The preprocessor goes through the <code class="inlineCode">cstdio</code> file, resolves all preprocessor directives, and pastes the result in the translation unit, resulting in 808 lines of code.</p>
<p class="normal">The default view of<a id="_idIndexMarker152"/> Compiler Explorer is the assembly output, which we can get by simply removing the <code class="inlineCode">–E</code> flag from the previous example, as shown in the following figure:</p>
<figure class="mediaobject"><img alt="Figure 3.3 – Compiler Explorer: assembly output" src="img/B22402_3_03.png"/></figure>
<p class="packt_figref">Figure 3.3 – Compiler Explorer: assembly output</p>
<p class="normal">In <em class="italic">Figure 3</em><em class="italic">.3</em>, we can see the generated assembly output of GCC’s compilation process. We can see that the optimization process replaced the <code class="inlineCode">printf</code> function with <code class="inlineCode">puts</code>. Also, we don’t see the body of the <code class="inlineCode">puts</code> function because this function is part of the C standard library that we link against. The next steps of the process are as follows:</p>
<ol>
<li class="numberedList" value="1">The assembler will generate object code from the assembly code.</li>
<li class="numberedList">The linker will link the generated object code with the C standard library that contains the <code class="inlineCode">puts</code> implementation (among other functions).</li>
</ol>
<p class="normal">In this simple example, we<a id="_idIndexMarker153"/> went through GCC’s compilation process, which will not result in the code that we can run on a microcontroller, as we also need to do the following steps:</p>
<ol>
<li class="numberedList" value="1">Add clock and hardware peripheral initialization code.</li>
<li class="numberedList">Set compiler flags for the architecture and instruction set for our target.</li>
<li class="numberedList">Add a startup assembly script containing a reset handler and C and C++ runtime initialization.</li>
<li class="numberedList">Add a linker script defining different memory regions for a target, including RAM and Flash regions.</li>
<li class="numberedList">Add instructions for the linker to link against specific C and C++ standard libraries.</li>
</ol>
<p class="normal">The output from the last stage of the GCC compilation process, the linking stage, is an <strong class="keyWord">Executable and Linkable Format</strong> (<strong class="keyWord">ELF</strong>) file. The<a id="_idIndexMarker154"/> ELF file is converted into binary or hex format using the <code class="inlineCode">objdump</code> tool, as binary and hex formats are usually used by the flashing process to be loaded on the target.</p>
<p class="normal">From version 10, GCC has an integrated static analyzer, which can be enabled with the <code class="inlineCode">–fanalyzer</code> compiler flag.</p>
<h1 class="heading-1" id="_idParaDest-55">Static analyzers</h1>
<p class="normal"><strong class="keyWord">Static analyzers</strong> are tools<a id="_idIndexMarker155"/> that go through source code and detect potential issues with the code such as undefined behavior, or they check whether the code is compliant with a safety standard such as MISRA® or AUTOSAR®. Not all static analyzers have the same capabilities, and only commercial versions support safety standards checks. Some of the issues that can be detected with static analyzers are as follows:</p>
<ul>
<li class="bulletList">Use of uninitialized data</li>
<li class="bulletList">Out-of-bounds array access</li>
<li class="bulletList">Null pointers dereference</li>
<li class="bulletList">Division by zero</li>
<li class="bulletList">Use after delete, double delete, and other memory management issues</li>
</ul>
<p class="normal">We <a id="_idIndexMarker156"/>can enable GCC’s static analyzer by providing the GCC driver program with the <code class="inlineCode">–fanalyzer</code> flag. Let us take an example of a simple sum function that takes a <code class="inlineCode">std::array&lt;int, 4&gt;</code> constant reference and returns the sum shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;array&gt;
int sum(const std::array&lt;int, 4&gt; &amp;arr) {
    int ret;
    for(int elem: arr) {
        ret += elem;
    }
    return ret;
}
</code></pre>
<p class="normal">The issue with the preceding example is that we are not initializing the <code class="inlineCode">ret</code> variable to zero. During the stack allocation of variables in the <code class="inlineCode">sum</code> function, the value of the <code class="inlineCode">ret</code> variable will be populated with anything on the allocated location, leading to undefined behavior. We can add the <code class="inlineCode">-fanalyzer</code> flag in Compiler Explorer and open the compiler output, as shown in the following screenshot:</p>
<figure class="mediaobject"><img alt="Figure 3.4 – Compiler Explorer: static analyzer, use of uninitialized value" src="img/B22402_3_04.png"/></figure>
<p class="packt_figref">Figure 3.4 – Compiler Explorer: static analyzer, use of uninitialized value</p>
<p class="normal">In <em class="italic">Figure 3</em><em class="italic">.4</em>, we <a id="_idIndexMarker157"/>can see compiler output in a new plane, which we enabled by clicking on <strong class="screenText">Output (0/42)</strong>. We can see that the static analyzer recognized that we were using an uninitialized variable and issued the warning. GCC, like many other compilers, can issue compiler warnings, and can also detect different issues with code, including uninitialized variables. We can enable regular compiler warnings using flags such as <code class="inlineCode">-Wall</code>, <code class="inlineCode">-Wextra,</code> <code class="inlineCode">-Wpedantic</code>, but in this case, they wouldn’t catch uninitialized variables. </p>
<p class="normal">We can see this in the following screenshot:</p>
<figure class="mediaobject"><img alt="Figure 3.5 – Compiler Explorer: GCC warnings, uninitialized value" src="img/B22402_3_05.png"/></figure>
<p class="packt_figref">Figure 3.5 – Compiler Explorer: GCC warnings, uninitialized value</p>
<p class="normal">In <em class="italic">Figure 3</em><em class="italic">.5</em>, we <a id="_idIndexMarker158"/>can see that GCC didn’t issue a warning for uninitialized data using regular compiler warnings. Enabling a static analyzer using the <code class="inlineCode">–fanalyzer</code> flag will help detect the issue, but also keep in mind that static analysis takes more time, which might be an issue with larger code bases. There is also a GCC flag, <code class="inlineCode">–Wuninitialized</code>, which should generate a warning for uninitialized variables. In this particular example, it will generate a warning only if a program is compiled with an optimization flag different from 0 (e.g., <code class="inlineCode">-O2</code>).</p>
<p class="normal">Different compilers have different capabilities, including detecting issues with code. If we were to compile this example using the <code class="inlineCode">clang</code> compiler (switch the compiler to <strong class="screenText">armv7-a clang 11.0.1</strong> in Compiler Explorer), we would see that the <code class="inlineCode">clang</code> compiler would detect this uninitialized variable issue <a id="_idIndexMarker159"/>and emit a warning. Also, static analyzers have different capabilities, so it is a good practice to run your code through several static analyzers, as one may detect issues that the others can’t, and vice versa.</p>
<p class="normal">Here is another example of a static analyzer in action, detecting out-of-bounds access:</p>
<figure class="mediaobject"><img alt="Figure 3.6 – Compiler Explorer: static analyzer, out-of-bounds access" src="img/B22402_3_06.png"/></figure>
<p class="packt_figref">Figure 3.6 – Compiler Explorer: static analyzer, out-of-bounds access</p>
<p class="normal">In <em class="italic">Figure 3</em><em class="italic">.6</em>, we are trying to access the fifth element of an array that has four elements, which will result in undefined behavior. This was caught by the GCC’s static analyzer, which issued a descriptive warning. In GCC, warnings can be treated as errors that will result in failed compilation <a id="_idIndexMarker160"/>and no ELF file generated. To treat warnings as errors, just add the <code class="inlineCode">-Werror</code> compiler flag to the GCC driver program invocation.</p>
<p class="normal">There are other commonly used static analyzers, most notably <code class="inlineCode">clang-tidy</code> and <code class="inlineCode">cppcheck</code>. <code class="inlineCode">clang-tidy</code> can <a id="_idIndexMarker161"/>be enabled in Compiler Explorer using the <strong class="screenText">Add tool</strong> option. Both <code class="inlineCode">clang-tidy</code> (<a href="https://clang.llvm.org/extra/clang-tidy/">https://clang.llvm.org/extra/clang-tidy/</a>) and <code class="inlineCode">cppcheck</code> (<a href="https://cppcheck.sourceforge.io/">https://cppcheck.sourceforge.io/</a>) are easy to install and use, and as previously <a id="_idIndexMarker162"/>stated, it is usually a good idea to use several static analyzers to catch different issues with the code.</p>
<p class="normal">Static analyzers are great for catching common programming errors and potential issues with your code or making sure that code is compliant according to a safety standard, but they don’t guarantee that the code does what it is supposed to do. To validate the actual functionality of our firmware, we can run manual tests on a target or we can use unit testing to write test cases for individual pieces of our code.</p>
<h1 class="heading-1" id="_idParaDest-56">Unit testing</h1>
<p class="normal"><strong class="keyWord">Unit testing</strong> is the<a id="_idIndexMarker163"/> process of testing units of code by using a test framework that provides infrastructure for setting up tests, running them, and reporting them. So, what is a unit of code? It depends on what we want to test; it can be a function or a software module, or we can reason about unit testing as testing a unit of work. What does the firmware need to do if a user presses a button, or what does it need to do if we receive a specific packet <a id="_idIndexMarker164"/>over a <strong class="keyWord">Bluetooth® Low Energy</strong> (<strong class="keyWord">BLE</strong>) connection?</p>
<p class="normal">Depending on the granularity of unit testing, we can test different components of firmware on the individual level and their interaction to ensure proper functionality. Unit tests test the units of code or units of work in isolation from other software components. This forces us to focus on the functionality of said units during the development and split the responsibilities between components more easily, leading to more robust software.</p>
<p class="normal">Most of the C++ testing frameworks are not well suited for running on small, embedded targets due to the resulting binary size, most notably, due to the usage of <code class="inlineCode">ostream</code> from the standard library. This leaves us with the option to run our unit tests on the host machine instead of the embedded target. This is not to say that unit tests can’t be run on embedded targets. Running <a id="_idIndexMarker165"/>tests on a target takes more time, as all tests would need to be compiled for the target and flashed to it, and we’d need a report-catching mechanism on the host machine to read test results.</p>
<p class="normal">Running tests off the target on a host machine is a common practice. However, there are concerns about this approach, as tests are run on a different architecture where even data types can have different sizes. To address this, one can enforce the use of fixed-width data types (e.g., <code class="inlineCode">uint8_t</code> or <code class="inlineCode">int32_t</code>). Additionally, there may be differences between the compilers used for the host and target machines, so it is advisable to use the same versions of compilers. Running tests on a host machine is faster and easier, but the differences between architectures and setups can potentially have an impact on test results. There are manual target tests and system and integration tests that can discover potential issues with code functionality and serve as an additional layer of functionality validation.</p>
<p class="normal">There are different testing frameworks for C++, and some of the most used are as follows:</p>
<ul>
<li class="bulletList">Google Test</li>
<li class="bulletList">Catch2</li>
<li class="bulletList">Boost.Test</li>
<li class="bulletList">CppUTest</li>
</ul>
<p class="normal">We can easily try them in Compiler Explorer by adding the relevant libraries. The first thing to do is to add an <strong class="screenText">Execution Only</strong> pane, as shown in the following figure:</p>
<figure class="mediaobject"><img alt="Figure 3.7 – Compiler Explorer: execution pane" src="img/B22402_3_07.png"/></figure>
<p class="packt_figref">Figure 3.7 – Compiler Explorer: execution pane</p>
<p class="normal">In <em class="italic">Figure 3</em><em class="italic">.7</em>, we added an execution pane and selected <strong class="screenText">x86-64 gcc 13.2</strong> as the compiler. Now, we need to <a id="_idIndexMarker166"/>add the Google Test library by clicking on the <strong class="screenText">Libraries</strong> button in the execution pane. It will open a new window in which we can search for a library and include it, as shown in the following figure:</p>
<figure class="mediaobject"><img alt="Figure 3.8 – Compiler Explorer: including a library" src="img/B22402_3_08.png"/></figure>
<p class="packt_figref">Figure 3.8 – Compiler Explorer: including a library</p>
<p class="normal">In <em class="italic">Figure 3</em><em class="italic">.8</em>, we search for the Google Test library and we add it to the project by selecting the version in the drop-down menu. Let’s see how we can test our generic ring buffer implementation <a id="_idIndexMarker167"/>from the first chapter using Google Test. The following is the code with ring buffer implementation and a couple of simple tests:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;array&gt;
#include &lt;cstdio&gt;
#include "gtest/gtest.h"
template &lt;class T, std::size_t N&gt; struct ring_buffer {
  std::array&lt;T, N&gt; arr;
  std::size_t write_idx = 0;
  std::size_t read_idx = 0;
  std::size_t count = 0;
  void push(T t) {
    arr.at(write_idx) = t;
    write_idx = (write_idx + 1) % N;
    if (count &lt; N) {
      count++;
    } else {
      read_idx = (read_idx + 1) % N;
    }
  }
  T pop() {
    if (count == 0) {
      return T{};
    }
    T value = arr.at(read_idx);
    read_idx = (read_idx + 1) % N;
    --count;
    return value;
  }
  bool is_empty() const {
      return count == 0;
  }
  std::size_t get_count() const {
      return count;
  }
};
TEST(RingBufferInt, PushPop) {
    ring_buffer&lt;int, 2&gt; rb;
    rb.push(1);
    rb.push(2);
    EXPECT_EQ(rb.pop(), 1);
    EXPECT_EQ(rb.pop(), 2);
}
TEST(RingBufferInt, GetCount) {
    ring_buffer&lt;int, 20&gt; rb;
    for(int i = 0; i &lt; 50; i++) {
        rb.push(i);
    }
    EXPECT_EQ(rb.get_count(), 20);
    for(int i = 0; i &lt; 10; i++) {
        rb.pop();
    }
    EXPECT_EQ(rb.get_count(), 10);
}
int main() {
  testing::InitGoogleTest();
  return RUN_ALL_TESTS();
}
</code></pre>
<p class="normal">In the preceding example, the ring buffer implementation is the same as in the first chapter with the <a id="_idIndexMarker168"/>addition of the <code class="inlineCode">get_count</code> method, which returns the number of elements currently held by the buffer. We defined a test suite, <code class="inlineCode">RingBufferInt</code>, using the <code class="inlineCode">TEST</code> macro. We specified two tests named <code class="inlineCode">PushPop</code> and <code class="inlineCode">GetCount</code>.</p>
<p class="normal">In the <code class="inlineCode">PushPop</code> test, we are testing the <code class="inlineCode">push</code> and <code class="inlineCode">pop</code> functionality of the ring buffer, making sure that <code class="inlineCode">pop</code> will return pushed values in the correct order using the <code class="inlineCode">EXPECT_EQ</code> macro.</p>
<p class="normal">In the <code class="inlineCode">GetCount</code> test, we are checking whether the number of elements held by the buffer matches the intended functionality using the following scenario:</p>
<ol>
<li class="numberedList" value="1">We first push 50 values to the buffer, which can hold a maximum of 20 values, making sure that <code class="inlineCode">get_count</code> will return <code class="inlineCode">20</code>.</li>
<li class="numberedList">We then pop 10 values from the buffer and check whether the count will be equal to <code class="inlineCode">10</code>.</li>
</ol>
<p class="normal">Running the preceding program will result in Google Test generating a report on standard output, as in the following figure:</p>
<figure class="mediaobject"><img alt="Figure 3.9 – Compiler Explorer: Google Test execution" src="img/B22402_3_09.png"/></figure>
<p class="packt_figref">Figure 3.9 – Compiler Explorer: Google Test execution</p>
<p class="normal">In <em class="italic">Figure 3</em><em class="italic">.9</em>, we see<a id="_idIndexMarker169"/> the results of our tests in the execution pane. The <code class="inlineCode">TEST</code> macro will ensure that tests are automatically registered in the framework so we don’t need to add them manually. This allows us to focus on writing tests utilizing the infrastructure provided by the framework. Google Test offers a lot more, and this example is just a glimpse into its capabilities.</p>
<p class="normal">Writing unit tests makes us think about how our code interacts with other software modules in the system. By focusing on units of code, we can write code that is loosely coupled, making our software more flexible and robust. Unit tests are crucial for development techniques such as <strong class="keyWord">Test-Driven Development</strong> (<strong class="keyWord">TDD</strong>), which<a id="_idIndexMarker170"/> requires us to write tests before we write the code. After we write a unit test, we write the actual code just to pass the test, and then we add<a id="_idIndexMarker171"/> more tests, refactor the implementation, and iterate on the process.</p>
<p class="normal">Unit tests are a powerful tool for validating the functionality of our code, whether we run them on the target or the host platform. Still, they don’t tell us a lot about the performance of our firmware. For that, we need to run the production firmware on the target and measure the performance using profiler tools.</p>
<h1 class="heading-1" id="_idParaDest-57">Profiling</h1>
<p class="normal">Running <a id="_idIndexMarker172"/>code on the target and profiling is the best way to ensure the <strong class="keyWord">Worst-Case Execution Time</strong> (<strong class="keyWord">WCET</strong>) for<a id="_idIndexMarker173"/> critical functionality and make necessary optimizations if needed.</p>
<p class="normal">The challenge with profiling is that it is an intrusive operation, as the code source needs to be modified or instrumented to enable traces that can tell us more about what is happening internally on the target.</p>
<p class="normal">Profiling depends on target capabilities. Some cores have integrated units for tracing, as we saw in the previous chapter, providing profiling that is minimally invasive. Also, some targets have special interfaces that allow high-speed trace data transfer using advanced debugging and tracing probes connected to the host machine. We can see an example of profiling infrastructure used for some Cortex-M targets in the following figure:</p>
<figure class="mediaobject"><img alt="Figure 3.10 – ﻿Arm target connected to host machine over a debug probe" src="img/B22402_3_10.png"/></figure>
<p class="packt_figref">Figure 3.10 – Arm target connected to host machine over a debug probe</p>
<p class="normal">In <em class="italic">Figure 3</em><em class="italic">.10</em>, we <a id="_idIndexMarker174"/>can see an Arm target connected over a debugging probe to a host machine. Profiling, or trace data flow, can be described through the next steps:</p>
<ol>
<li class="numberedList" value="1">A <strong class="keyWord">Program Counter</strong> (<strong class="keyWord">PC</strong>) is<a id="_idIndexMarker175"/> sampled using DWT and generates an event.</li>
<li class="numberedList">ITM sends events generated by DWT and instrumented code over <strong class="keyWord">Single Wire Output SWO</strong> to a<a id="_idIndexMarker176"/> debugging probe.</li>
<li class="numberedList">The debugging probe transfers trace data to capturing software on the host machine over USB.</li>
<li class="numberedList">Capturing software is usually a part of a larger software package that can analyze and visualize captured received data.</li>
</ol>
<p class="normal">In order to have precise information about function execution times, the source code needs to be instrumented by adding instructions that will generate trace data. We saw how this can be achieved in the previous chapter using GCC’s compiler features for adding instructions to the entry and exit of every function. This data can be sent using ITM to profiler software running on the host machine. This approach has good accuracy, but by adding instructions to code, we are degrading performances for the sake of measurement.</p>
<p class="normal">PC sampling can be less intrusive than code instrumentation, but it is less accurate and can serve only to detect bottlenecks in the firmware without precise timing information.</p>
<p class="normal">Some Arm cores have an<a id="_idIndexMarker177"/> integrated <strong class="keyWord">Embedded Trace Macrocell</strong> (<strong class="keyWord">ETM</strong>). ETM records instruction execution, generates trace data, and sends it to the connected probe. With the instruction trace data, a profiler can measure the execution time of functions accurately and create a call graph of each function call, the same as code instrumentation. ETM enables code profiling without the instrumentation cost.</p>
<p class="normal"><strong class="keyWord">Code instrumentation</strong> is still <a id="_idIndexMarker178"/>a very common approach as it depends less on the target’s integrated tracing capabilities. SEGGER’s SystemView is an example of a profiler for embedded targets. As we briefly discussed in the previous chapter, we need to use SEGGER’s SystemView and RTT libraries on the target to enable trace generation. In the<a id="_idIndexMarker179"/> following, you can see data generated by SystemView:</p>
<figure class="mediaobject"><img alt="Figure 3.11 – SystemView" src="img/B22402_3_11.png"/></figure>
<p class="packt_figref">Figure 3.11 – SystemView</p>
<p class="normal">In <em class="italic">Figure 3</em><em class="italic">.11</em>, we see <a id="_idIndexMarker180"/>the names of functions from instrumented firmware, including minimum and maximum running time. Profiling code can help with the optimization of time-critical sections of firmware, enabling us to ensure the system’s timing requirements.</p>
<h1 class="heading-1" id="_idParaDest-58">Summary</h1>
<p class="normal">In this chapter, we discovered the available tools for C++ development in the <em class="italic">Embedded</em> domain. There is a variety of available development environments and compilers. While commercial solutions come with guaranteed support and have functional safety editions of their tools, free tools are also common and can even be qualified if needed.</p>
<p class="normal">Static analyzers can help in avoiding common programming issues and ensure safety guidelines compliances. By using unit tests, we can validate the functionality of our firmware, and profilers can help with detecting bottlenecks, measuring WCET, and ensuring timing requirements.</p>
<p class="normal">In the next chapter, we will create a development environment for C++ for embedded applications using selected free tools.</p>
<h1 class="heading-1" id="_idParaDest-59">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/embeddedsystems">https://packt.link/embeddedsystems</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_code_Discord.png"/></p>
</div>
</body></html>