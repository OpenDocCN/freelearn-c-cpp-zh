<html><head></head><body>
<div id="_idContainer033">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 class="chapterTitle" id="_idParaDest-47"><span class="koboSpan" id="kobo.2.1">Embedded C++ Ecosystem</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">At the heart of every embedded system sits a microcontroller. </span><span class="koboSpan" id="kobo.3.2">The transition from basic cores to more modern ones mirrors the evolution of technology. </span><span class="koboSpan" id="kobo.3.3">The microcontroller landscape is vast, ranging from cost-effective 8-bit cores and 16-bit cores to modern 32-bit Arm and RISC-V® based microcontrollers. </span><span class="koboSpan" id="kobo.3.4">This variety of architecture has impacted the development of tools and compilers. </span><span class="koboSpan" id="kobo.3.5">While some manufacturers have opted to focus on C support, many have recognized the importance of C++ and provided good support for C++ development within their toolchains.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">As the embedded system is vast and it is impossible to cover all of the available architectures and vendors, we will focus on Arm® Cortex®-M as one of the dominant architectures for modern microcontrollers </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.5.1">and </span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">Systems on a Chip</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.8.1">SoCs</span></strong><span class="koboSpan" id="kobo.9.1">). </span><span class="koboSpan" id="kobo.9.2">We will go through the available development environments and toolchains that provide support for development in C++ for the Arm Cortex-M. </span><span class="koboSpan" id="kobo.9.3">We will also go through tools such as static analyzers, learn how to profile an embedded target, and cover methodologies such as unit testing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.10.1">In this chapter, we’re going to cover the following main topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Compilers and development environments</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Static analyzers</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Unit testing</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Profiling</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-48"><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.16.1">To get the most out of this chapter, I strongly recommend using Compiler Explorer (</span><a href="https://godbolt.org/"><span class="url"><span class="koboSpan" id="kobo.17.1">https://godbolt.org/</span></span></a><span class="koboSpan" id="kobo.18.1">) as you read through the examples. </span><span class="koboSpan" id="kobo.18.2">Select GCC as your compiler and target x86 architecture. </span><span class="koboSpan" id="kobo.18.3">This will allow you to see standard output (stdio) results and better observe the code’s behavior. </span><span class="koboSpan" id="kobo.18.4">As we are using a lot of modern C++ features, make sure to select C++23 standard, by adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.19.1">-std=c++23</span></code><span class="koboSpan" id="kobo.20.1"> in compiler options box.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.21.1">The examples from this chapter are available on GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter03"><span class="url"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter03</span></span></a><span class="koboSpan" id="kobo.23.1">).</span></p>
<h1 class="heading-1" id="_idParaDest-49"><span class="koboSpan" id="kobo.24.1">Compilers and development environments</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.25.1">The adoption of C++ in embedded</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.26.1"> systems was influenced by compiler support. </span><span class="koboSpan" id="kobo.26.2">While most compilers supported C, the support for C++ was slower. </span><span class="koboSpan" id="kobo.26.3">Nowadays, there is a variety of compilers and toolchains available for C++ depending on the target architecture and functional </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.27.1">safety requirements. </span><span class="koboSpan" id="kobo.27.2">Support for 32-bit architecture such as Arm Cortex-M is generally good, but the level of support depends on the toolchain vendor and functional safety requirements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.28.1">Many vendors offer functional safety versions of their tools that include certified compilers according to the safety standards for different industries. </span><span class="koboSpan" id="kobo.28.2">Functional safety standards are designed to ensure that software operates correctly and safely, even in the event of hardware failures or operational errors. </span><span class="koboSpan" id="kobo.28.3">IEC 61508 is the international umbrella safety standard for functional safety, and the following are safety standards for some industries:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.29.1">ISO 26262</span></strong><span class="koboSpan" id="kobo.30.1">: Automotive safety standard</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.31.1">EN 50128</span></strong><span class="koboSpan" id="kobo.32.1">: European railways safety standard</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.33.1">IEC 62304</span></strong><span class="koboSpan" id="kobo.34.1">: International standard for medical software</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.35.1">IEC 60730-1</span></strong><span class="koboSpan" id="kobo.36.1">: Automatic electrical control for household appliances</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.37.1">Functional safety</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.38.1"> requirements </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.39.1">are one of the first items on our checklist when selecting a compiler for a new project. </span><span class="koboSpan" id="kobo.39.2">If they call for qualified compilers, then we are limited to commercial versions of compilers that provide qualified compilers according to the exact standard in question.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.40.1">While many vendors providing tools for embedded development provide functional safety versions of their tools and compilers, there are also free development environments and open source compilers for embedded system development that can be used in non-critical applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.41.1">Development environments pack different tools to make the development process seamless and allow you to focus on the development. </span><span class="koboSpan" id="kobo.41.2">These tools can also be used individually and tailored according to individual or organizational preferences. </span><span class="koboSpan" id="kobo.41.3">Tools used for embedded development, either individually or integrated into a development environment, are listed as follows:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.42.1">Code editor</span></strong><span class="koboSpan" id="kobo.43.1">: This </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.44.1">can be as basic as a text editor or a more advanced tool such as Vim or Visual Studio Code supporting plugins for features such as syntax highlighting, autocompletion, code navigation across different source files, and refactoring.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.45.1">Compiler and linker</span></strong><span class="koboSpan" id="kobo.46.1">: These </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.47.1">are used to transform code into object files and link them to executable and binary files that can be flashed to a target. </span><span class="koboSpan" id="kobo.47.2">Some of the most popular C++ compilers are GCC, Clang, Arm Compiler for Embedded, and IAR C/C++ Compiler.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.48.1">Debugger</span></strong><span class="koboSpan" id="kobo.49.1">: It is </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.50.1">used to flash and debug a target. </span><span class="koboSpan" id="kobo.50.2">Parts of the debugging system are a debugger probe and software that communicates with a probe to debug the connected target.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.51.1">Build system</span></strong><span class="koboSpan" id="kobo.52.1">: Tools such as </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.53.1">GNU Make and Ninja are used to control the process of compiling and linking. </span><span class="koboSpan" id="kobo.53.2">CMake and Bazel are used for build automation and dependency management.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.54.1">Static analysis tools</span></strong><span class="koboSpan" id="kobo.55.1">: These</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.56.1"> are used to analyze source code. </span><span class="koboSpan" id="kobo.56.2">Depending on capability, they can detect some forms of undefined behavior such as out-of-bound access, uninitialized variables, null pointer dereferences, and so on. </span><span class="koboSpan" id="kobo.56.3">Dedicated static analysis tools can check whether the code is MISRA or AUTOSAR-compliant.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.57.1">Runtime profilers</span></strong><span class="koboSpan" id="kobo.58.1">: These </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.59.1">are a combination of target capabilities, software instrumentation, and debugger probes used to measure function execution time and analyze the performance of your software.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.60.1">Most </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.61.1">embedded </span><strong class="keyWord"><span class="koboSpan" id="kobo.62.1">integrated development environments</span></strong><span class="koboSpan" id="kobo.63.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.64.1">IDEs</span></strong><span class="koboSpan" id="kobo.65.1">) provide the following capabilities:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.66.1">Project creation and organization</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.67.1">Build automation</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.68.1">Debugging</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.69.1">Some development environments integrate more advanced features for code analysis, such as the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.70.1">Static analysis</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.71.1">Profiling and performance analysis</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.72.1">We will cover some of the most used development environments and compilers in the industry on the next pages.</span></p>
<h2 class="heading-2" id="_idParaDest-50"><span class="koboSpan" id="kobo.73.1">Arm Keil MDK and Arm Compiler for Embedded</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.74.1">Arm® Keil® MDK</span></strong><span class="koboSpan" id="kobo.75.1"> is a set of tools for embedded development on (mostly) Arm Cortex-M microcontrollers and it includes the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.76.1">Keil Studio, a set of extensions for VS Code</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.77.1">Keil μVision, a legacy Windows®-based IDE</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.78.1">Arm Compiler for Embedded, a C and C++ compiler</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.79.1">Arm Virtual Hardware</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.80.1">Both </span><strong class="keyWord"><span class="koboSpan" id="kobo.81.1">Keil Studio</span></strong><span class="koboSpan" id="kobo.82.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.83.1">Keil μVision</span></strong><span class="koboSpan" id="kobo.84.1"> provide </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.85.1">all the IDE features needed for embedded development, including project configuration for different targets, build, and debugging on target.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.86.1">Keil μVision provides </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.87.1">support for the integration of PC-Lint, a static C and C++ analyzer, while VS Code (Keil Studio) can be configured to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">clang-tidy</span></code><span class="koboSpan" id="kobo.89.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.90.1">cppcheck</span></code><span class="koboSpan" id="kobo.91.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.92.1">Keil μVision is packed with Keil Simulator, allowing running firmware on simulated targets on your PC, and it also has an integrated profiler as a part of the μVision debugger.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.93.1">Arm Keil MDK comes with Arm Virtual Hardware Fixed Virtual Platforms, which is Arm’s cloud platform that allows you to run binaries on simulated targets providing infrastructure for CI/CD in a simulated environment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.94.1">There is a basic version of Keil MDK available for non-commercial use (Community), and two commercial versions (Essential and Professional), depending on the features available. </span><span class="koboSpan" id="kobo.94.2">Only the Professional commercial version comes with functional safety support and extended maintenance. </span><span class="koboSpan" id="kobo.94.3">Next, we will cover Arm Compiler for Embedded, a C and C++ compiler that comes with MDK. </span><span class="koboSpan" id="kobo.94.4">It also includes linker and standard libraries.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.95.1">Arm Compiler for Embedded</span></strong><span class="koboSpan" id="kobo.96.1"> is a</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.97.1"> C and C++ compiler provided by Arm. </span><span class="koboSpan" id="kobo.97.2">Arm also </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.98.1">provides a </span><strong class="keyWord"><span class="koboSpan" id="kobo.99.1">functional safety</span></strong><span class="koboSpan" id="kobo.100.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.101.1">FuSa</span></strong><span class="koboSpan" id="kobo.102.1">) version of the compiler that is certified according to IEC 61508, ISO 26262, EN 50128, and IEC 62304 safety standards.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.103.1">The FuSa version is available only in the highest edition of MDK – Professional.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.104.1">Arm Compiler for </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.105.1">Embedded consists of the following toolchain components:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.106.1">armclang</span></code><span class="koboSpan" id="kobo.107.1">, a </span><strong class="keyWord"><span class="koboSpan" id="kobo.108.1">low-level virtual machine</span></strong><span class="koboSpan" id="kobo.109.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.110.1">LLVM</span></strong><span class="koboSpan" id="kobo.111.1">)-based compiler</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.112.1">armlink</span></code><span class="koboSpan" id="kobo.113.1">, a linker that combines objects and libraries to produce an executable</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.114.1">Arm C libraries</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.115.1">Arm C++ libraries based on the LLVM </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">libc++</span></code><span class="koboSpan" id="kobo.117.1"> project</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.118.1">Arm Compiler supports C++17 standard, while the latest version of Arm Compiler for Embedded FuSa 6.16 supports C++ 14. </span><span class="koboSpan" id="kobo.118.2">Even though we are in 2024 at the time of writing this book, the support for the latest version of the C++ standard is slow. </span><span class="koboSpan" id="kobo.118.3">After C++17, C++20 and C++23 were released.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.119.1">Support of the latest C++ standard in commercial compilers is still rather slow, which makes the latest language features in these environments unavailable.</span></p>
<h2 class="heading-2" id="_idParaDest-51"><span class="koboSpan" id="kobo.120.1">IAR C/C++ Compiler and IAR Embedded Workbench for Arm</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.121.1">IAR Embedded Workbench®</span></strong><span class="koboSpan" id="kobo.122.1"> is a </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.123.1">development environment for Arm Cortex-M, Cortex-R, and </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.124.1">Cortex-A cores (IAR stands for Ingenjörsfirma Anders Rundgren). </span><span class="koboSpan" id="kobo.124.2">It integrates the following tools:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.125.1">IDE, including a debugger and profiler</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.126.1">IAR C/C++ Compiler</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.127.1">IAR C-STAT®, a static analyzer</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.128.1">IAR C-RUN®, a tool for runtime analysis</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.129.1">IAR Embedded Workbench is a well-rounded solution for the development of Arm Cortex-M cores. </span><span class="koboSpan" id="kobo.129.2">The IDE is packed with standard tools, such as a debugger, but also provides more advanced embedded tools, such as a profiler and running firmware in the simulator.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.130.1">IAR offers C-STAT, a tool for static analysis that can run static analysis against safety coding standards such as MISRAC++2008.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.131.1">IAR also provides C-RUN, a tool for runtime analysis that covers heap checks, bounds checking, buffer overrun, integer overflow, and other runtime checks by instrumenting your code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.132.1">IAR C/C++ Compiler </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.133.1">supports C++17 from 9.30.1. </span><span class="koboSpan" id="kobo.133.2">The FuSa version of IAR Embedded Workbench for Arm, version 9.50.3 (February 2024), also provides C++17 support.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.134.1">IAR C/C++ Compiler and Arm Compiler for Embedded are commercial options for embedded development. </span><span class="koboSpan" id="kobo.134.2">Besides the support you can expect from a commercial project, the strength of these tools is that they provide safety-qualified versions for safety-critical projects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.135.1">Some microcontroller vendors provide their own versions of development environments, usually based on Eclipse®, providing additional support for their own products.</span></p>
<h2 class="heading-2" id="_idParaDest-52"><span class="koboSpan" id="kobo.136.1">Vendor-supported IDEs and GCC</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.137.1">Alternatives to </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.138.1">commercial development environments are vendor-supported environments, which are based mostly on Eclipse and </span><strong class="keyWord"><span class="koboSpan" id="kobo.139.1">GNU Compiler Collection</span></strong><span class="koboSpan" id="kobo.140.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.141.1">GCC</span></strong><span class="koboSpan" id="kobo.142.1">) tools and </span><strong class="keyWord"><span class="koboSpan" id="kobo.143.1">GNU Project Debugger (GDB</span></strong><span class="koboSpan" id="kobo.144.1">) for debugging. </span><span class="koboSpan" id="kobo.144.2">Examples are STM32CubeIDE by ST® and MCUXpresso by NXP®.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.145.1">These tools </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.146.1">are packed with code configurator UIs that can generate C code used for GPIO configuration, clock setup, and peripheral drivers’ initialization.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.147.1">Some vendors, such as </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.148.1">Nordic Semiconductor®, opted for VS Code as the basis of their IDE solution. </span><span class="koboSpan" id="kobo.148.2">They provide plugins for GPIO configuration and debugging. </span><span class="koboSpan" id="kobo.148.3">VS Code is a modern code editor that allows developers to use plugins such as IntelliSense for code completion, parameter information, syntax highlighting, and many others to enhance the development experience.</span></p>
<h3 class="heading-3" id="_idParaDest-53"><span class="koboSpan" id="kobo.149.1">GCC</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.150.1">GCC is one of the</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.151.1"> most used C and C++ compilers in general. </span><span class="koboSpan" id="kobo.151.2">It is free software, and it is also the most popular compiler for non-critical applications that do not require a qualified compiler. </span><span class="koboSpan" id="kobo.151.3">However, even GCC can be qualified. </span><span class="koboSpan" id="kobo.151.4">The process of </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.152.1">qualification includes compiling and running test programs and comparing outputs against expected results. </span><span class="koboSpan" id="kobo.152.2">All the issues that are found must be documented and a process must be put in place to mitigate them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.153.1">Besides the compiler, GCC also includes an assembler and linker, providing users with a so-called driver program (</span><code class="inlineCode"><span class="koboSpan" id="kobo.154.1">gcc</span></code><span class="koboSpan" id="kobo.155.1"> for C and </span><code class="inlineCode"><span class="koboSpan" id="kobo.156.1">g++</span></code><span class="koboSpan" id="kobo.157.1"> for C++). </span><span class="koboSpan" id="kobo.157.2">When invoked, the driver program runs preprocessing, compilation, assembly, and linking. </span><span class="koboSpan" id="kobo.157.3">The following figure visualizes the GCC compilation process:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.158.1"><img alt="Figure 3.1 – GCC compilation process" src="../Images/B22402_3_01.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.159.1">Figure 3</span></span><span class="koboSpan" id="kobo.160.1">.1 – GCC compilation process</span></p>
<p class="normal"><span class="koboSpan" id="kobo.161.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.162.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.163.1">.1</span></em><span class="koboSpan" id="kobo.164.1">, we see what</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.165.1"> happens when GCC is used to compile a single file, </span><code class="inlineCode"><span class="koboSpan" id="kobo.166.1">main.cpp</span></code><span class="koboSpan" id="kobo.167.1">:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.168.1">GCC first runs the preprocessor, adding all header files specified with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">#include</span></code><span class="koboSpan" id="kobo.170.1"> directive and expanding macros in the translation unit.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.171.1">The result from the preprocessor stage is run through the compiler, generating assembly.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.172.1">The output of the assembly stage is an object file.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.173.1">Finally, the linker links the object file with C and C++ standard libraries and generates an ELF file.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.174.1">The GCC driver program can be supplied with additional arguments to provide outputs from intermediate phases. </span><span class="koboSpan" id="kobo.174.2">To redirect preprocessor output to standard output, one can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.175.1">-E</span></code><span class="koboSpan" id="kobo.176.1"> flag:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.177.1">arm-none-eabi-g++ -E main.cpp
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.178.1">The preceding command will result in a lengthy output if </span><code class="inlineCode"><span class="koboSpan" id="kobo.179.1">main.cpp</span></code><span class="koboSpan" id="kobo.180.1"> includes the </span><strong class="keyWord"><span class="koboSpan" id="kobo.181.1">C Standard Input and Output</span></strong><span class="koboSpan" id="kobo.182.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.183.1">cstdio</span></strong><span class="koboSpan" id="kobo.184.1">) library. </span><span class="koboSpan" id="kobo.184.2">You </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.185.1">can write a simple </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">hello world</span></code><span class="koboSpan" id="kobo.187.1"> program and see it for yourself by running the preceding command, or you can use Compiler Explorer.</span></p>
<h3 class="heading-3" id="_idParaDest-54"><span class="koboSpan" id="kobo.188.1">Compiler Explorer</span></h3>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.189.1">Compiler Explorer</span></strong><span class="koboSpan" id="kobo.190.1"> (</span><a href="https://github.com/compiler-explorer/compiler-explorer"><span class="url"><span class="koboSpan" id="kobo.191.1">https://github.com/compiler-explorer/compiler-explorer</span></span></a><span class="koboSpan" id="kobo.192.1">) is an interactive</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.193.1"> online compiler that shows the assembly output of compiled C++, Rust, Go, and other code. </span><span class="koboSpan" id="kobo.193.2">You can try it online (</span><a href="https://godbolt.org/"><span class="url"><span class="koboSpan" id="kobo.194.1">https://godbolt.org/</span></span></a><span class="koboSpan" id="kobo.195.1">). </span><span class="koboSpan" id="kobo.195.2">It is a great tool that, by default, shows the assembly output and can be used to explore different language features with different compilers and compiler flags.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.196.1">Let’s use Compiler Explorer</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.197.1"> to explore the GCC compilation process. </span><span class="koboSpan" id="kobo.197.2">We will select </span><strong class="screenText"><span class="koboSpan" id="kobo.198.1">ARM GCC 11.2.1 (none)</span></strong><span class="koboSpan" id="kobo.199.1"> as our compiler and provide it with an </span><code class="inlineCode"><span class="koboSpan" id="kobo.200.1">-E</span></code><span class="koboSpan" id="kobo.201.1"> flag. </span><strong class="screenText"><span class="koboSpan" id="kobo.202.1">ARM GCC 11.2.1 (none)</span></strong><span class="koboSpan" id="kobo.203.1">, or </span><strong class="screenText"><span class="koboSpan" id="kobo.204.1">arm-none-eabi-gcc</span></strong><span class="koboSpan" id="kobo.205.1">, is the GCC used for Cortex-M architecture. </span><span class="koboSpan" id="kobo.205.2">In the following figure, we can see the preprocessor output in Compiler Explorer:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.206.1"><img alt="Figure 3.2 – Compiler Explorer: preprocessor output" src="../Images/B22402_3_02.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.207.1">Figure 3</span></span><span class="koboSpan" id="kobo.208.1">.2 – Compiler Explorer: preprocessor output</span></p>
<p class="normal"><span class="koboSpan" id="kobo.209.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.210.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.211.1">.2</span></em><span class="koboSpan" id="kobo.212.1">, we can see that the preprocessor adds exactly 800 lines to our simple </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">hello world</span></code><span class="koboSpan" id="kobo.214.1"> example. </span><span class="koboSpan" id="kobo.214.2">The preprocessor goes through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">cstdio</span></code><span class="koboSpan" id="kobo.216.1"> file, resolves all preprocessor directives, and pastes the result in the translation unit, resulting in 808 lines of code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.217.1">The default view of</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.218.1"> Compiler Explorer is the assembly output, which we can get by simply removing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.219.1">–E</span></code><span class="koboSpan" id="kobo.220.1"> flag from the previous example, as shown in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.221.1"><img alt="Figure 3.3 – Compiler Explorer: assembly output" src="../Images/B22402_3_03.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.222.1">Figure 3</span></span><span class="koboSpan" id="kobo.223.1">.3 – Compiler Explorer: assembly output</span></p>
<p class="normal"><span class="koboSpan" id="kobo.224.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.225.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.226.1">.3</span></em><span class="koboSpan" id="kobo.227.1">, we can see the generated assembly output of GCC’s compilation process. </span><span class="koboSpan" id="kobo.227.2">We can see that the optimization process replaced the </span><code class="inlineCode"><span class="koboSpan" id="kobo.228.1">printf</span></code><span class="koboSpan" id="kobo.229.1"> function with </span><code class="inlineCode"><span class="koboSpan" id="kobo.230.1">puts</span></code><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">Also, we don’t see the body of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.232.1">puts</span></code><span class="koboSpan" id="kobo.233.1"> function because this function is part of the C standard library that we link against. </span><span class="koboSpan" id="kobo.233.2">The next steps of the process are as follows:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.234.1">The assembler will generate object code from the assembly code.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.235.1">The linker will link the generated object code with the C standard library that contains the </span><code class="inlineCode"><span class="koboSpan" id="kobo.236.1">puts</span></code><span class="koboSpan" id="kobo.237.1"> implementation (among other functions).</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.238.1">In this simple example, we</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.239.1"> went through GCC’s compilation process, which will not result in the code that we can run on a microcontroller, as we also need to do the following steps:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.240.1">Add clock and hardware peripheral initialization code.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.241.1">Set compiler flags for the architecture and instruction set for our target.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.242.1">Add a startup assembly script containing a reset handler and C and C++ runtime initialization.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.243.1">Add a linker script defining different memory regions for a target, including RAM and Flash regions.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.244.1">Add instructions for the linker to link against specific C and C++ standard libraries.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.245.1">The output from the last stage of the GCC compilation process, the linking stage, is an </span><strong class="keyWord"><span class="koboSpan" id="kobo.246.1">Executable and Linkable Format</span></strong><span class="koboSpan" id="kobo.247.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.248.1">ELF</span></strong><span class="koboSpan" id="kobo.249.1">) file. </span><span class="koboSpan" id="kobo.249.2">The</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.250.1"> ELF file is converted into binary or hex format using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">objdump</span></code><span class="koboSpan" id="kobo.252.1"> tool, as binary and hex formats are usually used by the flashing process to be loaded on the target.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.253.1">From version 10, GCC has an integrated static analyzer, which can be enabled with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.254.1">–fanalyzer</span></code><span class="koboSpan" id="kobo.255.1"> compiler flag.</span></p>
<h1 class="heading-1" id="_idParaDest-55"><span class="koboSpan" id="kobo.256.1">Static analyzers</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.257.1">Static analyzers</span></strong><span class="koboSpan" id="kobo.258.1"> are tools</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.259.1"> that go through source code and detect potential issues with the code such as undefined behavior, or they check whether the code is compliant with a safety standard such as MISRA® or AUTOSAR®. </span><span class="koboSpan" id="kobo.259.2">Not all static analyzers have the same capabilities, and only commercial versions support safety standards checks. </span><span class="koboSpan" id="kobo.259.3">Some of the issues that can be detected with static analyzers are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.260.1">Use of uninitialized data</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.261.1">Out-of-bounds array access</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.262.1">Null pointers dereference</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.263.1">Division by zero</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.264.1">Use after delete, double delete, and other memory management issues</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.265.1">We </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.266.1">can enable GCC’s static analyzer by providing the GCC driver program with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">–fanalyzer</span></code><span class="koboSpan" id="kobo.268.1"> flag. </span><span class="koboSpan" id="kobo.268.2">Let us take an example of a simple sum function that takes a </span><code class="inlineCode"><span class="koboSpan" id="kobo.269.1">std::array&lt;int, 4&gt;</span></code><span class="koboSpan" id="kobo.270.1"> constant reference and returns the sum shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.271.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.272.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.273.1">&lt;array&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.274.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.275.1">sum</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.276.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.277.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.278.1"> std::array&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.279.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.280.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.281.1">4</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.282.1">&gt; &amp;arr)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.283.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.284.1">int</span></span><span class="koboSpan" id="kobo.285.1"> ret;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.286.1">for</span></span><span class="koboSpan" id="kobo.287.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.288.1">int</span></span><span class="koboSpan" id="kobo.289.1"> elem: arr) {
        ret += elem;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.290.1">return</span></span><span class="koboSpan" id="kobo.291.1"> ret;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.292.1">The issue with the preceding example is that we are not initializing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">ret</span></code><span class="koboSpan" id="kobo.294.1"> variable to zero. </span><span class="koboSpan" id="kobo.294.2">During the stack allocation of variables in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">sum</span></code><span class="koboSpan" id="kobo.296.1"> function, the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">ret</span></code><span class="koboSpan" id="kobo.298.1"> variable will be populated with anything on the allocated location, leading to undefined behavior. </span><span class="koboSpan" id="kobo.298.2">We can add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">-fanalyzer</span></code><span class="koboSpan" id="kobo.300.1"> flag in Compiler Explorer and open the compiler output, as shown in the following screenshot:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.301.1"><img alt="Figure 3.4 – Compiler Explorer: static analyzer, use of uninitialized value" src="../Images/B22402_3_04.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.302.1">Figure 3</span></span><span class="koboSpan" id="kobo.303.1">.4 – Compiler Explorer: static analyzer, use of uninitialized value</span></p>
<p class="normal"><span class="koboSpan" id="kobo.304.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.305.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.306.1">.4</span></em><span class="koboSpan" id="kobo.307.1">, we </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.308.1">can see compiler output in a new plane, which we enabled by clicking on </span><strong class="screenText"><span class="koboSpan" id="kobo.309.1">Output (0/42)</span></strong><span class="koboSpan" id="kobo.310.1">. </span><span class="koboSpan" id="kobo.310.2">We can see that the static analyzer recognized that we were using an uninitialized variable and issued the warning. </span><span class="koboSpan" id="kobo.310.3">GCC, like many other compilers, can issue compiler warnings, and can also detect different issues with code, including uninitialized variables. </span><span class="koboSpan" id="kobo.310.4">We can enable regular compiler warnings using flags such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.311.1">-Wall</span></code><span class="koboSpan" id="kobo.312.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.313.1">-Wextra,</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.314.1">-Wpedantic</span></code><span class="koboSpan" id="kobo.315.1">, but in this case, they wouldn’t catch uninitialized variables. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.316.1">We can see this in the following screenshot:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.317.1"><img alt="Figure 3.5 – Compiler Explorer: GCC warnings, uninitialized value" src="../Images/B22402_3_05.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.318.1">Figure 3</span></span><span class="koboSpan" id="kobo.319.1">.5 – Compiler Explorer: GCC warnings, uninitialized value</span></p>
<p class="normal"><span class="koboSpan" id="kobo.320.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.321.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.322.1">.5</span></em><span class="koboSpan" id="kobo.323.1">, we </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.324.1">can see that GCC didn’t issue a warning for uninitialized data using regular compiler warnings. </span><span class="koboSpan" id="kobo.324.2">Enabling a static analyzer using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">–fanalyzer</span></code><span class="koboSpan" id="kobo.326.1"> flag will help detect the issue, but also keep in mind that static analysis takes more time, which might be an issue with larger code bases. </span><span class="koboSpan" id="kobo.326.2">There is also a GCC flag, </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">–Wuninitialized</span></code><span class="koboSpan" id="kobo.328.1">, which should generate a warning for uninitialized variables. </span><span class="koboSpan" id="kobo.328.2">In this particular example, it will generate a warning only if a program is compiled with an optimization flag different from 0 (e.g., </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">-O2</span></code><span class="koboSpan" id="kobo.330.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.331.1">Different compilers have different capabilities, including detecting issues with code. </span><span class="koboSpan" id="kobo.331.2">If we were to compile this example using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">clang</span></code><span class="koboSpan" id="kobo.333.1"> compiler (switch the compiler to </span><strong class="screenText"><span class="koboSpan" id="kobo.334.1">armv7-a clang 11.0.1</span></strong><span class="koboSpan" id="kobo.335.1"> in Compiler Explorer), we would see that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.336.1">clang</span></code><span class="koboSpan" id="kobo.337.1"> compiler would detect this uninitialized variable issue </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.338.1">and emit a warning. </span><span class="koboSpan" id="kobo.338.2">Also, static analyzers have different capabilities, so it is a good practice to run your code through several static analyzers, as one may detect issues that the others can’t, and vice versa.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.339.1">Here is another example of a static analyzer in action, detecting out-of-bounds access:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.340.1"><img alt="Figure 3.6 – Compiler Explorer: static analyzer, out-of-bounds access" src="../Images/B22402_3_06.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.341.1">Figure 3</span></span><span class="koboSpan" id="kobo.342.1">.6 – Compiler Explorer: static analyzer, out-of-bounds access</span></p>
<p class="normal"><span class="koboSpan" id="kobo.343.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.344.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.345.1">.6</span></em><span class="koboSpan" id="kobo.346.1">, we are trying to access the fifth element of an array that has four elements, which will result in undefined behavior. </span><span class="koboSpan" id="kobo.346.2">This was caught by the GCC’s static analyzer, which issued a descriptive warning. </span><span class="koboSpan" id="kobo.346.3">In GCC, warnings can be treated as errors that will result in failed compilation </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.347.1">and no ELF file generated. </span><span class="koboSpan" id="kobo.347.2">To treat warnings as errors, just add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.348.1">-Werror</span></code><span class="koboSpan" id="kobo.349.1"> compiler flag to the GCC driver program invocation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.350.1">There are other commonly used static analyzers, most notably </span><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">clang-tidy</span></code><span class="koboSpan" id="kobo.352.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.353.1">cppcheck</span></code><span class="koboSpan" id="kobo.354.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.355.1">clang-tidy</span></code><span class="koboSpan" id="kobo.356.1"> can </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.357.1">be enabled in Compiler Explorer using the </span><strong class="screenText"><span class="koboSpan" id="kobo.358.1">Add tool</span></strong><span class="koboSpan" id="kobo.359.1"> option. </span><span class="koboSpan" id="kobo.359.2">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">clang-tidy</span></code><span class="koboSpan" id="kobo.361.1"> (</span><a href="https://clang.llvm.org/extra/clang-tidy/"><span class="url"><span class="koboSpan" id="kobo.362.1">https://clang.llvm.org/extra/clang-tidy/</span></span></a><span class="koboSpan" id="kobo.363.1">) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">cppcheck</span></code><span class="koboSpan" id="kobo.365.1"> (</span><a href="https://cppcheck.sourceforge.io/"><span class="url"><span class="koboSpan" id="kobo.366.1">https://cppcheck.sourceforge.io/</span></span></a><span class="koboSpan" id="kobo.367.1">) are easy to install and use, and as previously </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.368.1">stated, it is usually a good idea to use several static analyzers to catch different issues with the code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.369.1">Static analyzers are great for catching common programming errors and potential issues with your code or making sure that code is compliant according to a safety standard, but they don’t guarantee that the code does what it is supposed to do. </span><span class="koboSpan" id="kobo.369.2">To validate the actual functionality of our firmware, we can run manual tests on a target or we can use unit testing to write test cases for individual pieces of our code.</span></p>
<h1 class="heading-1" id="_idParaDest-56"><span class="koboSpan" id="kobo.370.1">Unit testing</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.371.1">Unit testing</span></strong><span class="koboSpan" id="kobo.372.1"> is the</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.373.1"> process of testing units of code by using a test framework that provides infrastructure for setting up tests, running them, and reporting them. </span><span class="koboSpan" id="kobo.373.2">So, what is a unit of code? </span><span class="koboSpan" id="kobo.373.3">It depends on what we want to test; it can be a function or a software module, or we can reason about unit testing as testing a unit of work. </span><span class="koboSpan" id="kobo.373.4">What does the firmware need to do if a user presses a button, or what does it need to do if we receive a specific packet </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.374.1">over a </span><strong class="keyWord"><span class="koboSpan" id="kobo.375.1">Bluetooth® Low Energy</span></strong><span class="koboSpan" id="kobo.376.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.377.1">BLE</span></strong><span class="koboSpan" id="kobo.378.1">) connection?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.379.1">Depending on the granularity of unit testing, we can test different components of firmware on the individual level and their interaction to ensure proper functionality. </span><span class="koboSpan" id="kobo.379.2">Unit tests test the units of code or units of work in isolation from other software components. </span><span class="koboSpan" id="kobo.379.3">This forces us to focus on the functionality of said units during the development and split the responsibilities between components more easily, leading to more robust software.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.380.1">Most of the C++ testing frameworks are not well suited for running on small, embedded targets due to the resulting binary size, most notably, due to the usage of </span><code class="inlineCode"><span class="koboSpan" id="kobo.381.1">ostream</span></code><span class="koboSpan" id="kobo.382.1"> from the standard library. </span><span class="koboSpan" id="kobo.382.2">This leaves us with the option to run our unit tests on the host machine instead of the embedded target. </span><span class="koboSpan" id="kobo.382.3">This is not to say that unit tests can’t be run on embedded targets. </span><span class="koboSpan" id="kobo.382.4">Running </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.383.1">tests on a target takes more time, as all tests would need to be compiled for the target and flashed to it, and we’d need a report-catching mechanism on the host machine to read test results.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.384.1">Running tests off the target on a host machine is a common practice. </span><span class="koboSpan" id="kobo.384.2">However, there are concerns about this approach, as tests are run on a different architecture where even data types can have different sizes. </span><span class="koboSpan" id="kobo.384.3">To address this, one can enforce the use of fixed-width data types (e.g., </span><code class="inlineCode"><span class="koboSpan" id="kobo.385.1">uint8_t</span></code><span class="koboSpan" id="kobo.386.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">int32_t</span></code><span class="koboSpan" id="kobo.388.1">). </span><span class="koboSpan" id="kobo.388.2">Additionally, there may be differences between the compilers used for the host and target machines, so it is advisable to use the same versions of compilers. </span><span class="koboSpan" id="kobo.388.3">Running tests on a host machine is faster and easier, but the differences between architectures and setups can potentially have an impact on test results. </span><span class="koboSpan" id="kobo.388.4">There are manual target tests and system and integration tests that can discover potential issues with code functionality and serve as an additional layer of functionality validation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.389.1">There are different testing frameworks for C++, and some of the most used are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.390.1">Google Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.391.1">Catch2</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.392.1">Boost.Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.393.1">CppUTest</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.394.1">We can easily try them in Compiler Explorer by adding the relevant libraries. </span><span class="koboSpan" id="kobo.394.2">The first thing to do is to add an </span><strong class="screenText"><span class="koboSpan" id="kobo.395.1">Execution Only</span></strong><span class="koboSpan" id="kobo.396.1"> pane, as shown in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.397.1"><img alt="Figure 3.7 – Compiler Explorer: execution pane" src="../Images/B22402_3_07.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.398.1">Figure 3</span></span><span class="koboSpan" id="kobo.399.1">.7 – Compiler Explorer: execution pane</span></p>
<p class="normal"><span class="koboSpan" id="kobo.400.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.401.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.402.1">.7</span></em><span class="koboSpan" id="kobo.403.1">, we added an execution pane and selected </span><strong class="screenText"><span class="koboSpan" id="kobo.404.1">x86-64 gcc 13.2</span></strong><span class="koboSpan" id="kobo.405.1"> as the compiler. </span><span class="koboSpan" id="kobo.405.2">Now, we need to </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.406.1">add the Google Test library by clicking on the </span><strong class="screenText"><span class="koboSpan" id="kobo.407.1">Libraries</span></strong><span class="koboSpan" id="kobo.408.1"> button in the execution pane. </span><span class="koboSpan" id="kobo.408.2">It will open a new window in which we can search for a library and include it, as shown in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.409.1"><img alt="Figure 3.8 – Compiler Explorer: including a library" src="../Images/B22402_3_08.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.410.1">Figure 3</span></span><span class="koboSpan" id="kobo.411.1">.8 – Compiler Explorer: including a library</span></p>
<p class="normal"><span class="koboSpan" id="kobo.412.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.413.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.414.1">.8</span></em><span class="koboSpan" id="kobo.415.1">, we search for the Google Test library and we add it to the project by selecting the version in the drop-down menu. </span><span class="koboSpan" id="kobo.415.2">Let’s see how we can test our generic ring buffer implementation </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.416.1">from the first chapter using Google Test. </span><span class="koboSpan" id="kobo.416.2">The following is the code with ring buffer implementation and a couple of simple tests:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.417.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.418.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.419.1">&lt;array&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.420.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.421.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.422.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.423.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.424.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.425.1">"gtest/gtest.h"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.426.1">template</span></span><span class="koboSpan" id="kobo.427.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.428.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.429.1">T</span></span><span class="koboSpan" id="kobo.430.1">, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.431.1">size_t</span></span><span class="koboSpan" id="kobo.432.1"> N&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.433.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.434.1">ring_buffer</span></span><span class="koboSpan" id="kobo.435.1"> {
  std::array&lt;T, N&gt; arr;
  std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.436.1">size_t</span></span><span class="koboSpan" id="kobo.437.1"> write_idx = </span><span class="hljs-number"><span class="koboSpan" id="kobo.438.1">0</span></span><span class="koboSpan" id="kobo.439.1">;
  std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.440.1">size_t</span></span><span class="koboSpan" id="kobo.441.1"> read_idx = </span><span class="hljs-number"><span class="koboSpan" id="kobo.442.1">0</span></span><span class="koboSpan" id="kobo.443.1">;
  std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.444.1">size_t</span></span><span class="koboSpan" id="kobo.445.1"> count = </span><span class="hljs-number"><span class="koboSpan" id="kobo.446.1">0</span></span><span class="koboSpan" id="kobo.447.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.448.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.449.1">push</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.450.1">(T t)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.451.1">{
    arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.452.1">at</span></span><span class="koboSpan" id="kobo.453.1">(write_idx) = t;
    write_idx = (write_idx + </span><span class="hljs-number"><span class="koboSpan" id="kobo.454.1">1</span></span><span class="koboSpan" id="kobo.455.1">) % N;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.456.1">if</span></span><span class="koboSpan" id="kobo.457.1"> (count &lt; N) {
      count++;
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.458.1">else</span></span><span class="koboSpan" id="kobo.459.1"> {
      read_idx = (read_idx + </span><span class="hljs-number"><span class="koboSpan" id="kobo.460.1">1</span></span><span class="koboSpan" id="kobo.461.1">) % N;
    }
  }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.462.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.463.1">pop</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.464.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.465.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.466.1">if</span></span><span class="koboSpan" id="kobo.467.1"> (count == </span><span class="hljs-number"><span class="koboSpan" id="kobo.468.1">0</span></span><span class="koboSpan" id="kobo.469.1">) {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.470.1">return</span></span><span class="koboSpan" id="kobo.471.1"> T{};
    }
    T value = arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.472.1">at</span></span><span class="koboSpan" id="kobo.473.1">(read_idx);
    read_idx = (read_idx + </span><span class="hljs-number"><span class="koboSpan" id="kobo.474.1">1</span></span><span class="koboSpan" id="kobo.475.1">) % N;
    --count;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.476.1">return</span></span><span class="koboSpan" id="kobo.477.1"> value;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.478.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.479.1">is_empty</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.480.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.481.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.482.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.483.1">return</span></span><span class="koboSpan" id="kobo.484.1"> count == </span><span class="hljs-number"><span class="koboSpan" id="kobo.485.1">0</span></span><span class="koboSpan" id="kobo.486.1">;
  }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.487.1">std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.488.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.489.1">get_count</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.490.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.491.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.492.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.493.1">return</span></span><span class="koboSpan" id="kobo.494.1"> count;
  }
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.495.1">TEST</span></span><span class="koboSpan" id="kobo.496.1">(RingBufferInt, PushPop) {
    ring_buffer&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.497.1">int</span></span><span class="koboSpan" id="kobo.498.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.499.1">2</span></span><span class="koboSpan" id="kobo.500.1">&gt; rb;
    rb.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.501.1">push</span></span><span class="koboSpan" id="kobo.502.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.503.1">1</span></span><span class="koboSpan" id="kobo.504.1">);
    rb.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.505.1">push</span></span><span class="koboSpan" id="kobo.506.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.507.1">2</span></span><span class="koboSpan" id="kobo.508.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.509.1">EXPECT_EQ</span></span><span class="koboSpan" id="kobo.510.1">(rb.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.511.1">pop</span></span><span class="koboSpan" id="kobo.512.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.513.1">1</span></span><span class="koboSpan" id="kobo.514.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.515.1">EXPECT_EQ</span></span><span class="koboSpan" id="kobo.516.1">(rb.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.517.1">pop</span></span><span class="koboSpan" id="kobo.518.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.519.1">2</span></span><span class="koboSpan" id="kobo.520.1">);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.521.1">TEST</span></span><span class="koboSpan" id="kobo.522.1">(RingBufferInt, GetCount) {
    ring_buffer&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.523.1">int</span></span><span class="koboSpan" id="kobo.524.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.525.1">20</span></span><span class="koboSpan" id="kobo.526.1">&gt; rb;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.527.1">for</span></span><span class="koboSpan" id="kobo.528.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.529.1">int</span></span><span class="koboSpan" id="kobo.530.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.531.1">0</span></span><span class="koboSpan" id="kobo.532.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.533.1">50</span></span><span class="koboSpan" id="kobo.534.1">; i++) {
        rb.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.535.1">push</span></span><span class="koboSpan" id="kobo.536.1">(i);
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.537.1">EXPECT_EQ</span></span><span class="koboSpan" id="kobo.538.1">(rb.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.539.1">get_count</span></span><span class="koboSpan" id="kobo.540.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.541.1">20</span></span><span class="koboSpan" id="kobo.542.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.543.1">for</span></span><span class="koboSpan" id="kobo.544.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.545.1">int</span></span><span class="koboSpan" id="kobo.546.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.547.1">0</span></span><span class="koboSpan" id="kobo.548.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.549.1">10</span></span><span class="koboSpan" id="kobo.550.1">; i++) {
        rb.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.551.1">pop</span></span><span class="koboSpan" id="kobo.552.1">();
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.553.1">EXPECT_EQ</span></span><span class="koboSpan" id="kobo.554.1">(rb.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.555.1">get_count</span></span><span class="koboSpan" id="kobo.556.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.557.1">10</span></span><span class="koboSpan" id="kobo.558.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.559.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.560.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.561.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.562.1">{
  testing::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.563.1">InitGoogleTest</span></span><span class="koboSpan" id="kobo.564.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.565.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.566.1">RUN_ALL_TESTS</span></span><span class="koboSpan" id="kobo.567.1">();
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.568.1">In the preceding example, the ring buffer implementation is the same as in the first chapter with the </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.569.1">addition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.570.1">get_count</span></code><span class="koboSpan" id="kobo.571.1"> method, which returns the number of elements currently held by the buffer. </span><span class="koboSpan" id="kobo.571.2">We defined a test suite, </span><code class="inlineCode"><span class="koboSpan" id="kobo.572.1">RingBufferInt</span></code><span class="koboSpan" id="kobo.573.1">, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.574.1">TEST</span></code><span class="koboSpan" id="kobo.575.1"> macro. </span><span class="koboSpan" id="kobo.575.2">We specified two tests named </span><code class="inlineCode"><span class="koboSpan" id="kobo.576.1">PushPop</span></code><span class="koboSpan" id="kobo.577.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.578.1">GetCount</span></code><span class="koboSpan" id="kobo.579.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.580.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.581.1">PushPop</span></code><span class="koboSpan" id="kobo.582.1"> test, we are testing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.583.1">push</span></code><span class="koboSpan" id="kobo.584.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.585.1">pop</span></code><span class="koboSpan" id="kobo.586.1"> functionality of the ring buffer, making sure that </span><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">pop</span></code><span class="koboSpan" id="kobo.588.1"> will return pushed values in the correct order using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.589.1">EXPECT_EQ</span></code><span class="koboSpan" id="kobo.590.1"> macro.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.591.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.592.1">GetCount</span></code><span class="koboSpan" id="kobo.593.1"> test, we are checking whether the number of elements held by the buffer matches the intended functionality using the following scenario:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.594.1">We first push 50 values to the buffer, which can hold a maximum of 20 values, making sure that </span><code class="inlineCode"><span class="koboSpan" id="kobo.595.1">get_count</span></code><span class="koboSpan" id="kobo.596.1"> will return </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">20</span></code><span class="koboSpan" id="kobo.598.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.599.1">We then pop 10 values from the buffer and check whether the count will be equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.600.1">10</span></code><span class="koboSpan" id="kobo.601.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.602.1">Running the preceding program will result in Google Test generating a report on standard output, as in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.603.1"><img alt="Figure 3.9 – Compiler Explorer: Google Test execution" src="../Images/B22402_3_09.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.604.1">Figure 3</span></span><span class="koboSpan" id="kobo.605.1">.9 – Compiler Explorer: Google Test execution</span></p>
<p class="normal"><span class="koboSpan" id="kobo.606.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.607.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.608.1">.9</span></em><span class="koboSpan" id="kobo.609.1">, we see</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.610.1"> the results of our tests in the execution pane. </span><span class="koboSpan" id="kobo.610.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.611.1">TEST</span></code><span class="koboSpan" id="kobo.612.1"> macro will ensure that tests are automatically registered in the framework so we don’t need to add them manually. </span><span class="koboSpan" id="kobo.612.2">This allows us to focus on writing tests utilizing the infrastructure provided by the framework. </span><span class="koboSpan" id="kobo.612.3">Google Test offers a lot more, and this example is just a glimpse into its capabilities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.613.1">Writing unit tests makes us think about how our code interacts with other software modules in the system. </span><span class="koboSpan" id="kobo.613.2">By focusing on units of code, we can write code that is loosely coupled, making our software more flexible and robust. </span><span class="koboSpan" id="kobo.613.3">Unit tests are crucial for development techniques such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.614.1">Test-Driven Development</span></strong><span class="koboSpan" id="kobo.615.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.616.1">TDD</span></strong><span class="koboSpan" id="kobo.617.1">), which</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.618.1"> requires us to write tests before we write the code. </span><span class="koboSpan" id="kobo.618.2">After we write a unit test, we write the actual code just to pass the test, and then we add</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.619.1"> more tests, refactor the implementation, and iterate on the process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.620.1">Unit tests are a powerful tool for validating the functionality of our code, whether we run them on the target or the host platform. </span><span class="koboSpan" id="kobo.620.2">Still, they don’t tell us a lot about the performance of our firmware. </span><span class="koboSpan" id="kobo.620.3">For that, we need to run the production firmware on the target and measure the performance using profiler tools.</span></p>
<h1 class="heading-1" id="_idParaDest-57"><span class="koboSpan" id="kobo.621.1">Profiling</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.622.1">Running </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.623.1">code on the target and profiling is the best way to ensure the </span><strong class="keyWord"><span class="koboSpan" id="kobo.624.1">Worst-Case Execution Time</span></strong><span class="koboSpan" id="kobo.625.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.626.1">WCET</span></strong><span class="koboSpan" id="kobo.627.1">) for</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.628.1"> critical functionality and make necessary optimizations if needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.629.1">The challenge with profiling is that it is an intrusive operation, as the code source needs to be modified or instrumented to enable traces that can tell us more about what is happening internally on the target.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.630.1">Profiling depends on target capabilities. </span><span class="koboSpan" id="kobo.630.2">Some cores have integrated units for tracing, as we saw in the previous chapter, providing profiling that is minimally invasive. </span><span class="koboSpan" id="kobo.630.3">Also, some targets have special interfaces that allow high-speed trace data transfer using advanced debugging and tracing probes connected to the host machine. </span><span class="koboSpan" id="kobo.630.4">We can see an example of profiling infrastructure used for some Cortex-M targets in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.631.1"><img alt="Figure 3.10 – ﻿Arm target connected to host machine over a debug probe" src="../Images/B22402_3_10.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.632.1">Figure 3</span></span><span class="koboSpan" id="kobo.633.1">.10 – Arm target connected to host machine over a debug probe</span></p>
<p class="normal"><span class="koboSpan" id="kobo.634.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.635.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.636.1">.10</span></em><span class="koboSpan" id="kobo.637.1">, we </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.638.1">can see an Arm target connected over a debugging probe to a host machine. </span><span class="koboSpan" id="kobo.638.2">Profiling, or trace data flow, can be described through the next steps:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.639.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.640.1">Program Counter</span></strong><span class="koboSpan" id="kobo.641.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.642.1">PC</span></strong><span class="koboSpan" id="kobo.643.1">) is</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.644.1"> sampled using DWT and generates an event.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.645.1">ITM sends events generated by DWT and instrumented code over </span><strong class="keyWord"><span class="koboSpan" id="kobo.646.1">Single Wire Output SWO</span></strong><span class="koboSpan" id="kobo.647.1"> to a</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.648.1"> debugging probe.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.649.1">The debugging probe transfers trace data to capturing software on the host machine over USB.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.650.1">Capturing software is usually a part of a larger software package that can analyze and visualize captured received data.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.651.1">In order to have precise information about function execution times, the source code needs to be instrumented by adding instructions that will generate trace data. </span><span class="koboSpan" id="kobo.651.2">We saw how this can be achieved in the previous chapter using GCC’s compiler features for adding instructions to the entry and exit of every function. </span><span class="koboSpan" id="kobo.651.3">This data can be sent using ITM to profiler software running on the host machine. </span><span class="koboSpan" id="kobo.651.4">This approach has good accuracy, but by adding instructions to code, we are degrading performances for the sake of measurement.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.652.1">PC sampling can be less intrusive than code instrumentation, but it is less accurate and can serve only to detect bottlenecks in the firmware without precise timing information.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.653.1">Some Arm cores have an</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.654.1"> integrated </span><strong class="keyWord"><span class="koboSpan" id="kobo.655.1">Embedded Trace Macrocell</span></strong><span class="koboSpan" id="kobo.656.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.657.1">ETM</span></strong><span class="koboSpan" id="kobo.658.1">). </span><span class="koboSpan" id="kobo.658.2">ETM records instruction execution, generates trace data, and sends it to the connected probe. </span><span class="koboSpan" id="kobo.658.3">With the instruction trace data, a profiler can measure the execution time of functions accurately and create a call graph of each function call, the same as code instrumentation. </span><span class="koboSpan" id="kobo.658.4">ETM enables code profiling without the instrumentation cost.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.659.1">Code instrumentation</span></strong><span class="koboSpan" id="kobo.660.1"> is still </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.661.1">a very common approach as it depends less on the target’s integrated tracing capabilities. </span><span class="koboSpan" id="kobo.661.2">SEGGER’s SystemView is an example of a profiler for embedded targets. </span><span class="koboSpan" id="kobo.661.3">As we briefly discussed in the previous chapter, we need to use SEGGER’s SystemView and RTT libraries on the target to enable trace generation. </span><span class="koboSpan" id="kobo.661.4">In the</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.662.1"> following, you can see data generated by SystemView:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.663.1"><img alt="Figure 3.11 – SystemView" src="../Images/B22402_3_11.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.664.1">Figure 3</span></span><span class="koboSpan" id="kobo.665.1">.11 – SystemView</span></p>
<p class="normal"><span class="koboSpan" id="kobo.666.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.667.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.668.1">.11</span></em><span class="koboSpan" id="kobo.669.1">, we see </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.670.1">the names of functions from instrumented firmware, including minimum and maximum running time. </span><span class="koboSpan" id="kobo.670.2">Profiling code can help with the optimization of time-critical sections of firmware, enabling us to ensure the system’s timing requirements.</span></p>
<h1 class="heading-1" id="_idParaDest-58"><span class="koboSpan" id="kobo.671.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.672.1">In this chapter, we discovered the available tools for C++ development in the </span><em class="italic"><span class="koboSpan" id="kobo.673.1">Embedded</span></em><span class="koboSpan" id="kobo.674.1"> domain. </span><span class="koboSpan" id="kobo.674.2">There is a variety of available development environments and compilers. </span><span class="koboSpan" id="kobo.674.3">While commercial solutions come with guaranteed support and have functional safety editions of their tools, free tools are also common and can even be qualified if needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.675.1">Static analyzers can help in avoiding common programming issues and ensure safety guidelines compliances. </span><span class="koboSpan" id="kobo.675.2">By using unit tests, we can validate the functionality of our firmware, and profilers can help with detecting bottlenecks, measuring WCET, and ensuring timing requirements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.676.1">In the next chapter, we will create a development environment for C++ for embedded applications using selected free tools.</span></p>
<h1 class="heading-1" id="_idParaDest-59"><span class="koboSpan" id="kobo.677.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.678.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="https://packt.link/embeddedsystems"><span class="url"><span class="koboSpan" id="kobo.679.1">https://packt.link/embeddedsystems</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.680.1"><img alt="" role="presentation" src="../Images/QR_code_Discord.png"/></span></p>
</div>
</body></html>