["```cpp\ngit clone https://github.com/codeplea/Hands-On-Network-Programming-with-C\ncd Hands-On-Network-Programming-with-C/chap09\n```", "```cpp\n#if defined(_WIN32)\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x0600\n#endif\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#pragma comment(lib, \"ws2_32.lib\")\n\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <errno.h>\n\n#endif\n```", "```cpp\n/*chap09.h continued*/\n\n#if defined(_WIN32)\n#define ISVALIDSOCKET(s) ((s) != INVALID_SOCKET)\n#define CLOSESOCKET(s) closesocket(s)\n#define GETSOCKETERRNO() (WSAGetLastError())\n\n#else\n#define ISVALIDSOCKET(s) ((s) >= 0)\n#define CLOSESOCKET(s) close(s)\n#define SOCKET int\n#define GETSOCKETERRNO() (errno)\n#endif\n```", "```cpp\n/*chap09.h continued*/\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n\n#include <openssl/crypto.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n```", "```cpp\nopenssl version\n```", "```cpp\n/*openssl_version.c*/\n\n#include <openssl/ssl.h>\n\nint main(int argc, char *argv[]) {\n    printf(\"OpenSSL version: %s\\n\", OpenSSL_version(SSLEAY_VERSION));\n    return 0;\n}\n```", "```cpp\ngcc openssl_version.c -o openssl_version -lcrypto\n./openssl_version\n```", "```cpp\ngcc openssl_version.c -o openssl_version.exe -lcrypto\nopenssl_version.exe\n```", "```cpp\nSSL_library_init();\nOpenSSL_add_all_algorithms();\nSSL_load_error_strings();\n```", "```cpp\nSSL_CTX *ctx = SSL_CTX_new(TLS_client_method());\nif (!ctx) {\n    fprintf(stderr, \"SSL_CTX_new() failed.\\n\");\n    return 1;\n}\n```", "```cpp\ngetaddrinfo(hostname, port, hints, address);\nsocket = socket(address, type, protocol);\nconnect(socket, address, type);\n```", "```cpp\nSSL *ssl = SSL_new(ctx);\nif (!ctx) {\n    fprintf(stderr, \"SSL_new() failed.\\n\");\n    return 1;\n}\n\nif (!SSL_set_tlsext_host_name(ssl, hostname)) {\n    fprintf(stderr, \"SSL_set_tlsext_host_name() failed.\\n\");\n    ERR_print_errors_fp(stderr);\n    return 1;\n}\n\nSSL_set_fd(ssl, socket);\nif (SSL_connect(ssl) == -1) {\n    fprintf(stderr, \"SSL_connect() failed.\\n\");\n    ERR_print_errors_fp(stderr);\n    return 1;\n}\n```", "```cpp\nprintf (\"SSL/TLS using %s\\n\", SSL_get_cipher(ssl));\n```", "```cpp\nchar *data = \"Hello World!\";\nint bytes_sent = SSL_write(ssl, data, strlen(data));\n```", "```cpp\nchar read[4096];\nint bytes_received = SSL_read(ssl, read, 4096);\nprintf(\"Received: %.*s\\n\", bytes_received, read);\n```", "```cpp\nSSL_shutdown(ssl);\nCLOSESOCKET(socket);\nSSL_free(ssl);\n```", "```cpp\nSSL_CTX_free(ctx);\n```", "```cpp\n    X509 *cert = SSL_get_peer_certificate(ssl);\n    if (!cert) {\n        fprintf(stderr, \"SSL_get_peer_certificate() failed.\\n\");\n        return 1;\n    }\n\n    char *tmp;\n    if (tmp = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) {\n        printf(\"subject: %s\\n\", tmp);\n        OPENSSL_free(tmp);\n    }\n\n    if (tmp = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) {\n        printf(\"issuer: %s\\n\", tmp);\n        OPENSSL_free(tmp);\n    }\n\n    X509_free(cert);\n```", "```cpp\nlong vp = SSL_get_verify_result(ssl);\nif (vp == X509_V_OK) {\n    printf(\"Certificates verified successfully.\\n\");\n} else {\n    printf(\"Could not verify certificates: %ld\\n\", vp);\n}\n```", "```cpp\nif (!SSL_CTX_load_verify_locations(ctx, \"trusted.pem\", 0)) {\n    fprintf(stderr, \"SSL_CTX_load_verify_locations() failed.\\n\");\n    ERR_print_errors_fp(stderr);\n    return 1;\n}\n```", "```cpp\n/*https_simple.c*/\n\n#include \"chap09.h\"\n\nint main(int argc, char *argv[]) {\n\n#if defined(_WIN32)\n    WSADATA d;\n    if (WSAStartup(MAKEWORD(2, 2), &d)) {\n        fprintf(stderr, \"Failed to initialize.\\n\");\n        return 1;\n    }\n#endif\n```", "```cpp\n   /*https_simple.c continued*/\n\n    SSL_library_init();\n    OpenSSL_add_all_algorithms();\n    SSL_load_error_strings();\n```", "```cpp\n   /*https_simple.c continued*/ \n\n    SSL_CTX *ctx = SSL_CTX_new(TLS_client_method());\n    if (!ctx) {\n        fprintf(stderr, \"SSL_CTX_new() failed.\\n\");\n        return 1;\n    }\n```", "```cpp\n/*https_simple.c continued*/\n\n    if (argc < 3) {\n        fprintf(stderr, \"usage: https_simple hostname port\\n\");\n        return 1;\n    }\n\n    char *hostname = argv[1];\n    char *port = argv[2];\n```", "```cpp\n/*https_simple.c continued*/\n\n    printf(\"Configuring remote address...\\n\");\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_socktype = SOCK_STREAM;\n    struct addrinfo *peer_address;\n    if (getaddrinfo(hostname, port, &hints, &peer_address)) {\n        fprintf(stderr, \"getaddrinfo() failed. (%d)\\n\", GETSOCKETERRNO());\n        exit(1);\n    }\n\n    printf(\"Remote address is: \");\n    char address_buffer[100];\n    char service_buffer[100];\n    getnameinfo(peer_address->ai_addr, peer_address->ai_addrlen,\n            address_buffer, sizeof(address_buffer),\n            service_buffer, sizeof(service_buffer),\n            NI_NUMERICHOST);\n    printf(\"%s %s\\n\", address_buffer, service_buffer);\n```", "```cpp\n/*https_simple.c continued*/\n\n    printf(\"Creating socket...\\n\");\n    SOCKET server;\n    server = socket(peer_address->ai_family,\n            peer_address->ai_socktype, peer_address->ai_protocol);\n    if (!ISVALIDSOCKET(server)) {\n        fprintf(stderr, \"socket() failed. (%d)\\n\", GETSOCKETERRNO());\n        exit(1);\n    }\n\n    printf(\"Connecting...\\n\");\n    if (connect(server,\n                peer_address->ai_addr, peer_address->ai_addrlen)) {\n        fprintf(stderr, \"connect() failed. (%d)\\n\", GETSOCKETERRNO());\n        exit(1);\n    }\n    freeaddrinfo(peer_address);\n\n    printf(\"Connected.\\n\\n\");\n```", "```cpp\n/*https_simple.c continued*/\n\n    SSL *ssl = SSL_new(ctx);\n    if (!ctx) {\n        fprintf(stderr, \"SSL_new() failed.\\n\");\n        return 1;\n    }\n\n    if (!SSL_set_tlsext_host_name(ssl, hostname)) {\n        fprintf(stderr, \"SSL_set_tlsext_host_name() failed.\\n\");\n        ERR_print_errors_fp(stderr);\n        return 1;\n    }\n\n    SSL_set_fd(ssl, server);\n    if (SSL_connect(ssl) == -1) {\n        fprintf(stderr, \"SSL_connect() failed.\\n\");\n        ERR_print_errors_fp(stderr);\n        return 1;\n    }\n```", "```cpp\n/*https_simple.c continued*/\n\n    printf(\"SSL/TLS using %s\\n\", SSL_get_cipher(ssl));\n```", "```cpp\n/*https_simple.c continued*/\n\n    X509 *cert = SSL_get_peer_certificate(ssl);\n    if (!cert) {\n        fprintf(stderr, \"SSL_get_peer_certificate() failed.\\n\");\n        return 1;\n    }\n\n    char *tmp;\n    if ((tmp = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0))) {\n        printf(\"subject: %s\\n\", tmp);\n        OPENSSL_free(tmp);\n    }\n\n    if ((tmp = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0))) {\n        printf(\"issuer: %s\\n\", tmp);\n        OPENSSL_free(tmp);\n    }\n\n    X509_free(cert);\n```", "```cpp\n/*https_simple.c continued*/\n\n    char buffer[2048];\n\n    sprintf(buffer, \"GET / HTTP/1.1\\r\\n\");\n    sprintf(buffer + strlen(buffer), \"Host: %s:%s\\r\\n\", hostname, port);\n    sprintf(buffer + strlen(buffer), \"Connection: close\\r\\n\");\n    sprintf(buffer + strlen(buffer), \"User-Agent: https_simple\\r\\n\");\n    sprintf(buffer + strlen(buffer), \"\\r\\n\");\n\n    SSL_write(ssl, buffer, strlen(buffer));\n    printf(\"Sent Headers:\\n%s\", buffer);\n```", "```cpp\n/*https_simple.c continued*/\n\n    while(1) {\n        int bytes_received = SSL_read(ssl, buffer, sizeof(buffer));\n            if (bytes_received < 1) {\n                printf(\"\\nConnection closed by peer.\\n\");\n                break;\n            }\n\n            printf(\"Received (%d bytes): '%.*s'\\n\",\n                    bytes_received, bytes_received, buffer);\n    }\n```", "```cpp\n/*https_simple.c continued*/\n\n    printf(\"\\nClosing socket...\\n\");\n    SSL_shutdown(ssl);\n    CLOSESOCKET(server);\n    SSL_free(ssl);\n    SSL_CTX_free(ctx);\n\n#if defined(_WIN32)\n    WSACleanup();\n#endif\n\n    printf(\"Finished.\\n\");\n    return 0;\n}\n```", "```cpp\ngcc https_simple.c -o https_simple.exe -lssl -lcrypto -lws2_32\nhttps_simple example.org 443\n```", "```cpp\ngcc https_simple.c -o https_simple -lssl -lcrypto\n./https_simple example.org 443\n```"]