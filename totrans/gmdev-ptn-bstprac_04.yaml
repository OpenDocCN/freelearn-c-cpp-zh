- en: Artificial Intelligence Using the State Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态模式的人工智能
- en: In the last chapter, we discussed the Component Object Model. Giving an entity
    a behavior is now as simple as just creating a new component and having that control
    the game object.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了组件对象模型。现在给实体赋予行为就像创建一个新的组件并让该组件控制游戏对象一样简单。
- en: Whenever someone starts to make a game, they begin by writing gameplay code.
    That is the fun stuff. Everyone wants to see graphics and physics take effect
    on screen. Things such as a pause screen, options menu, or even a second level
    are an afterthought. The same happens for organizing the behaviors of a player.
    Programmers are excited to make a player jump and make a player dash, but with
    each new ability a player has, there are combinations that you may want to disallow.
    For example, the player might not be allowed to dash while jumping, or may only
    be able to dash every 3 seconds. The State pattern solves these problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有人开始制作游戏时，他们首先编写游戏玩法代码。这是有趣的部分。每个人都想看到图形和物理效果在屏幕上显示。例如，暂停屏幕、选项菜单或甚至第二个关卡都是次要的。为玩家组织行为也是如此。程序员们热衷于让玩家跳跃和冲刺，但随着玩家新能力的增加，可能会有一些组合是你不希望允许的。例如，玩家可能不允许在跳跃时冲刺，或者可能每3秒才能冲刺一次。状态模式解决了这些问题。
- en: By coding the Game State Manager first, the problem of switching to a menu or
    pausing is solved. By coding finite State Machines as a component for the game object,
    the problem of complex behavior or a player or enemy is solved. By adding multiple
    State Machines to the same game object, complex behavior can be created with very
    simple code, as is seen in many games, and is a widely used feature built into
    the Unreal Engine and given visual editors in Unity using Hutong Games LLC's popular
    Playmaker extension.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先编写游戏状态管理器，解决了切换到菜单或暂停的问题。通过将有限状态机作为游戏对象的组件进行编码，解决了复杂行为或玩家或敌人的问题。通过将多个状态机添加到同一个游戏对象中，可以非常简单地创建复杂的行为，正如许多游戏中所见，这是
    Unreal 引擎中广泛使用的内置功能，Unity 使用 Hutong Games LLC 流行的 Playmaker 扩展提供了视觉编辑器。
- en: Chapter overview
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: In this chapter, we will create a simple State Machine to control the player
    via input, as well as create an enemy State Machine which will detect when the
    player gets close to it and will follow them when in range. We will also look
    at the base `StateMachineComponent` class in the Mach5 Engine and show that, by
    writing code for a few states, we can create a more complex behavior quite easily.
    We will also show that adding more than one State Machine to an object can create
    multiple behaviors to run at the same time, avoiding duplicated state code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个简单的状态机来通过输入控制玩家，同时创建一个敌人状态机，当玩家靠近时会检测到并跟随。我们还将查看 Mach5 引擎中的基础 `StateMachineComponent`
    类，并展示通过编写几个状态代码，我们可以轻松地创建更复杂的行为。我们还将展示将多个状态机添加到对象中可以创建多个同时运行的行为，从而避免重复的状态代码。
- en: Your objectives
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的目标
- en: 'This chapter will be split into a number of topics. It will contain a simple
    step-by-step process from beginning to end. Here is the outline of our tasks:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为几个主题。它将包含一个从开始到结束的简单步骤过程。以下是我们的任务大纲：
- en: The State pattern explained
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式解释
- en: Introduction to State Machines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态机简介
- en: An overview of enumerations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举概述
- en: Doing things based on our states
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据我们的状态做事
- en: Why if statements could get you fired
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 if 语句可能会让你失业
- en: Expanding on the State Machine
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展状态机
- en: The State pattern in action--M5StateMachine
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式在实际应用中的体现--M5StateMachine
- en: The State pattern in action--StageManager
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式在实际应用中的体现--StageManager
- en: Issues with FSMs
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态机的问题
- en: The State pattern explained
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式解释
- en: 'The State pattern is a way to allow a game object to change its behavior and
    functionality in response to different stimuli within the game, especially when
    a variable or a condition within that object changes, as those changes may trigger
    a change in state. The state of an object is managed by some context (commonly
    referred to in the game industry as a machine), but the states tell the machine
    when to change states and thereby functionality. The State pattern contains two
    parts: the state and the context. The context object holds the current state and
    can be used by the state class to change what state should be run, whereas the
    state object holds the actual functionality:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式是一种允许游戏对象根据游戏中的不同刺激改变其行为和功能的方法，尤其是在对象内部的变量或条件发生变化时，因为这些变化可能会触发状态的变化。对象的状态由某些上下文（在游戏行业中通常被称为机器）管理，但状态告诉机器何时改变状态以及相应的功能。状态模式包含两个部分：状态和上下文。上下文对象持有当前状态，并且可以被状态类用来改变应该运行哪个状态，而状态对象则持有实际的功能：
- en: '![](img/00033.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00033.jpeg)'
- en: In the Mach5 Engine, there is a class that already uses the State pattern (`M5StateMachine`)
    but, before we dive into a completed version, let's actually build one from scratch.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mach5引擎中，有一个类已经使用了状态模式（`M5StateMachine`），但在我们深入研究一个完整的版本之前，让我们真正从头开始构建一个。
- en: There are multiple ways to implement the State pattern or to get a State-like
    behavior. We'll go over some of the commonly seen versions and the pros and cons
    of using them before moving to our final version.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实现状态模式或获得类似状态行为的方法有很多。在我们转向最终版本之前，我们将讨论一些常见的版本以及使用它们的优缺点。
- en: Introduction to State Machines
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态机简介
- en: We often write code to react to things happening within the game environment
    based on the expectations of us, as well as our players. For instance, if we are
    creating a 2D side-scrolling platformer game, when the player presses one of the
    arrow keys, we're expecting the player's character to move and, whenever we press
    the spacebar, we expect the sprite to jump into the air. Or perhaps in a 3D game,
    when our player sees a panel with a large button, they expect to be able to press
    it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常编写代码来根据我们的期望以及玩家的期望来对游戏环境中的事件做出反应。例如，如果我们正在创建一个2D横版滚动平台游戏，当玩家按下箭头键时，我们期望玩家的角色移动，每次我们按下空格键时，我们期望精灵跳入空中。或者在一个3D游戏中，当我们的玩家看到带有大按钮的面板时，他们期望能够按下它。
- en: Tons of things in our ordinary lives act this way as well, reactive to certain
    stimuli. For instance, when you use your television remote, you expect certain
    things to happen, or even when swiping or tapping on your mobile phone. Based
    on the stimuli provided, the *state* of our object may change. We call something
    that can be in one of multiple states at a time a State Machine.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们日常生活中有很多事情也是这样，对某些刺激做出反应。例如，当你使用电视遥控器时，你期望某些事情发生，或者甚至在你滑动或轻触手机时。根据提供的刺激，我们的对象的状态可能会改变。我们称那些可以在同一时间处于多个状态之一的对象为状态机。
- en: Almost every program you write can be considered a State Machine of some sort.
    The second that you add in an `if` statement to your project, you have developed
    code that can be in at least one of those states. That being said, you don't want
    to have a bunch of `switch` and/or `if` statements inside of your code as it can
    quickly get out of hand and make it difficult to understand exactly what it is
    that your code is doing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你写的几乎每一个程序都可以被视为某种状态机。当你向项目中添加一个`if`语句时，你就已经开发出了可以处于至少一个那些状态中的代码。也就是说，你不想在代码中有一大堆`switch`和/或`if`语句，因为这会使代码很快失控，并使理解代码的确切功能变得困难。
- en: As programmers, we often want to take our problems and break them down over
    and over again until they're in their simplest form, so let's see a possible way
    to do that. In game development, you'll hear references to an **FSM** which stands
    for **Finite State Machine**. Finite means that there are only a certain number
    of states and that they are all clearly defined for what they can do and how they
    will change between states.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们经常希望将问题分解成最简单的形式，让我们看看一种可能的方法。在游戏开发中，你会听到关于**FSM**的提及，它代表**有限状态机**。有限意味着只有一定数量的状态，并且它们都明确定义了它们可以做什么以及它们如何在状态之间变化。
- en: An overview of enumerations
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举概述
- en: 'Let''s say we''re going to create a simple enemy. This enemy will not do anything
    by default, but if the player is nearby, it will move toward them. However, if
    the player gets too far away from them, then they will stop their pursuit. Finally,
    if the player shoots the enemy, it will die. So, keeping that in mind, we can
    extract the states that we''ll need. They are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要创建一个简单的敌人。这个敌人默认不会做任何事情，但如果玩家靠近，它会向玩家移动。然而，如果玩家离得太远，它们将停止追击。最后，如果玩家射击敌人，敌人会死亡。所以，考虑到这一点，我们可以提取所需的各个状态。它们如下所示：
- en: Idle
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空闲
- en: Follow
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟随
- en: Death
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死亡
- en: While we are creating our State Machine, we need some way to keep track of what
    state our objects are going to be in. One may think a way to do this would be
    to have a `bool` (Boolean value of true or false) for each possible state there
    is and then set them all to `false`, except for the state that we're in. This
    is a very bad idea.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建我们的状态机时，我们需要一种方法来跟踪我们的对象将处于哪种状态。有人可能会认为一种方法是为每个可能的状态设置一个`bool`（布尔值，真或假），并将它们都设置为`false`，除了我们当前所在的状态。这是一个非常糟糕的想法。
- en: Another thought could be to just have an integer and then set a value for each
    one that there is. This is also a bad idea, as using numbers in this way is basically
    the same thing as using magic numbers in our code, since the numbers have no logic
    to them for people to read. Alternatively, you could have `#defines` for each
    possible value, but that will allow people to put in whatever number they want
    without any protections at all. Instead, whenever we see a series of things where
    only one of them is true at a time, we can make use of the programming feature
    of enumerations, called enums for short.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个想法可能是只使用一个整数，并为每个可能的值设置一个值。这同样是一个糟糕的想法，因为以这种方式使用数字基本上和我们在代码中使用魔法数字是一样的，因为这些数字对人们来说没有逻辑性。作为替代方案，你可以为每个可能的值设置`#defines`，但这样将允许人们随意输入任何数字，没有任何保护措施。相反，每当我们看到一系列只有其中一个为真时，我们可以利用枚举的编程特性，简称枚举。
- en: 'The basic concept of using enumerations is that you get to create your own
    custom data types which are restricted to only have a certain list of values.
    Unlike integers or `#defines`, these numbers are expressed using constants and
    allow us to have all of the advantages of having a value, such as being able to
    compare values. In our case, an `enum` for our states would look something like
    the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用枚举的基本概念是，你可以创建自己的自定义数据类型，这些数据类型仅限于具有某些值的列表。与整数或`#defines`不同，这些数字使用常量表示，使我们能够拥有具有值的全部优势，例如能够比较值。在我们的情况下，我们的状态枚举可能看起来如下所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Acting on states
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对状态进行操作
- en: Now that we have our states defined, let's now make it so that we can actually
    do something in our code based on what state our object is in. For this first
    example, I'm going to update the `ChasePlayerComponent` class that already exists
    in the `EngineTest` project.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了状态，让我们现在使我们的代码能够根据对象所处的状态实际执行一些操作。在这个第一个例子中，我将更新`EngineTest`项目中已经存在的`ChasePlayerComponent`类。
- en: 'From the Solution Explorer tab on the right-hand side, open up the `SpaceShooter/Components/ChasePlayerComp`
    folder and access the `ChasePlayerComponent.h` file. From there, replace the class
    with the following changes in bold:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从右侧的解决方案资源管理器选项卡中，打开`SpaceShooter/Components/ChasePlayerComp`文件夹，访问`ChasePlayerComponent.h`文件。从那里，用以下加粗的更改替换类：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `FollowPlayer` and `GetDistanceFromPlayer` functions are going to be helper
    functions for our functionality. We've added our state `enum` to store each of
    the possible states we can be in, and we added the `m_currentState` variable to
    hold the current state we are in. To determine when we should switch states, we
    have two other values, `m_followDistance` and `m_loseDistance`, which are the
    distance in pixels that our player needs to be from the enemy to follow them,
    and then how far the player needs to get away to escape, respectively.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`FollowPlayer`和`GetDistanceFromPlayer`函数将是我们功能中的辅助函数。我们已经添加了我们的状态`enum`来存储我们可以处于的每个可能状态，并添加了`m_currentState`变量来保存我们当前所在的状态。为了确定何时切换状态，我们还有两个其他值，`m_followDistance`和`m_loseDistance`，它们分别表示玩家需要与敌人保持多少像素的距离才能跟随，以及玩家需要逃多远才能逃脱。'
- en: 'Now that we have that finished, let''s first go ahead and add in the helper
    functions at the bottom of the `ChasePlayerComponent.cpp` file so that we can
    have the proper functionality, once we update our other functions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个，让我们首先在`ChasePlayerComponent.cpp`文件的底部添加一些辅助函数，这样我们就可以在更新其他函数后拥有适当的功能：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These functions use some basic linear algebra in order to move our object toward
    the player and to get the distance between two positions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数使用一些基本的线性代数来移动我们的对象朝向玩家，并获取两个位置之间的距离。
- en: 'Diving into the mathematics behind it is out of the scope of this book, but
    if you''re interested in learning more, I highly suggest you check out the following
    link. The code is written for Cocos2D so it will not be exactly the same as what
    Mach5 would use, but the concepts are explained very well: [https://www.raywenderlich.com/35866/trigonometry-for-game-programming-part-1](https://www.raywenderlich.com/35866/trigonometry-for-game-programming-part-1).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨其背后的数学超出了本书的范围，但如果您想了解更多，我强烈建议您查看以下链接。代码是为Cocos2D编写的，所以它不会与Mach5使用的完全相同，但概念解释得很好：[https://www.raywenderlich.com/35866/trigonometry-for-game-programming-part-1](https://www.raywenderlich.com/35866/trigonometry-for-game-programming-part-1)。
- en: 'Now that we have that functionality in, we need to update a couple of things.
    First of all, we will use the constructor to set the initial value of our `currentState`
    variable:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了这个功能，我们需要更新一些内容。首先，我们将使用构造函数来设置`currentState`变量的初始值：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we need to tell our object to read in the values of our object through
    its INI file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉我们的对象通过其INI文件读取对象的值：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`FromFile` is only called once on the first object that gets created in initialization.
    In order to make it easy to tweak values without having to recompile the project,
    Mach 5 reads in information from a file to set variables. We haven''t modified
    the `.ini` file yet, but we will once we finish all of these modifications:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromFile`只在初始化时创建的第一个对象上调用一次。为了在不重新编译项目的情况下轻松调整值，Mach 5从文件中读取信息来设置变量。我们还没有修改`.ini`文件，但一旦完成所有这些修改，我们将会：'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We then need to go to Windows Explorer and move to the project''s `EngineTest/EngineTest/ArcheTypes`
    folder, and then access the `Raider.ini` file and add the new properties to the
    object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要转到Windows资源管理器，移动到项目的`EngineTest/EngineTest/ArcheTypes`文件夹，然后访问`Raider.ini`文件，并将新属性添加到对象中：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If a text editor doesn't open for you, feel free to use Notepad. In this case,
    we are adding in two new properties which represent the values we created earlier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本编辑器没有为您打开，请随意使用记事本。在这种情况下，我们正在添加两个新的属性，它们代表我们之前创建的值。
- en: 'Then, we need to update our stage so it''s a little easier for us to do some
    testing. Back in Windows Explorer, open up the `EngineTest/EngineTest/Stages`
    folder and then open up the `Level01.ini` file and set it to the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新我们的阶段，使其更容易进行测试。回到Windows资源管理器，打开`EngineTest/EngineTest/Stages`文件夹，然后打开`Level01.ini`文件，将其设置为以下内容：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this, our level will just have our player in the center of the world and
    an enemy Raider positioned at (`100`, `10`). With all of that accomplished, save
    the files and dive back into our `ChasePlayerComponent.cpp` file and replace the
    `Update` function with the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们的级别将只包含位于世界中心的玩家和一个位于(`100`, `10`)的敌人掠夺者。完成所有这些后，保存文件，然后回到我们的`ChasePlayerComponent.cpp`文件，将`Update`函数替换为以下内容：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save everything and go ahead and run the project. If all goes well, you should
    see a scene like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有内容，然后运行项目。如果一切顺利，你应该会看到一个像这样的场景：
- en: '![](img/00034.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: 'Notice that our enemy is not moving at the beginning due to it being in the
    Idle state. However, if we move closer to it, it would look something like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们的敌人最初处于空闲状态，它不会移动。然而，如果我们靠近它，它看起来会像这样：
- en: '![](img/00035.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: 'You''ll see that it now follows us without stopping. If we manage to move far
    enough away from the enemy though, they''ll stop:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到它现在会跟随我们而不会停止。如果我们设法远离敌人，它们会停止：
- en: '![](img/00036.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: This clearly shows the basic principles of the State pattern in use, though
    there are a number of things we can do to improve this, which we will talk about
    soon.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地展示了使用状态模式的基本原理，尽管我们可以做很多事情来改进它，我们很快就会讨论。
- en: Issues with conditionals
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句的问题
- en: 'The next thing we need to consider is how we should do something based on what
    state we are in. When writing programs, conditional clauses such as the `if` and
    `switch` statements that we learned about earlier may make your code more difficult
    to manage. Sometimes, when writing code for specific functionality, writing if
    statements is completely understandable, especially if it makes sense when you
    are writing it. For example, the following code makes perfect sense:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要考虑的是，我们应该根据当前的状态来做些什么。在编写程序时，我们之前学到的 `if` 和 `switch` 等条件语句可能会使代码更难以管理。有时，当你编写特定功能的代码时，编写
    `if` 语句是完全可以理解的，特别是如果你在编写时它是有意义的。例如，以下代码完全合理：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, if you are writing something where you are checking what the type
    of an object is, or whether a variable is of a certain type, that is a bit of
    an issue. For instance, look at the following function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你正在编写检查对象类型或变量是否为特定类型的代码，那可能是个问题。例如，看看以下函数：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, if we start going down this path, we will need to add many
    different checks throughout our project, which will make our code hard to change
    if we ever decide to add more things to support here. First of all, instead of
    a bunch of `if`/`else` statements, when we see something that''s comparing the
    same value and doing something based off of that value, we should be using a `switch`
    statement, like we did earlier, with a few modifications:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，如果我们开始走这条路，我们将在整个项目中添加许多不同的检查，这将使得如果我们决定添加更多支持的内容，我们的代码将难以更改。首先，当我们看到一些比较相同值并根据该值执行某些操作时，我们应该使用
    `switch` 语句，就像我们之前做的那样，但进行一些修改：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But in this particular case, we are just calling a different function based
    on the value, with each of the functions being some kind of attack. Instead, we
    should make use of polymorphism and have the code automatically do the correct
    thing:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个特定的情况下，我们只是根据值调用不同的函数，每个函数都是某种攻击方式。相反，我们应该利用多态性，让代码自动完成正确的事情：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now whenever we call `AttackPlayer`, it will do the correct thing automatically.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每当调用 `AttackPlayer` 时，它将自动完成正确的事情。
- en: Just remember that creating complex behavior leads to ugly code being written
    and increases the likelihood of bugs. If you forget about a condition that needs
    to be there, your game hopefully would break, letting you know there is a problem,
    but it could not do anything. Then, when you find your game crashes down the road,
    your life becomes a lot more complex and your game could become unplayable or
    just plainly not fun.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，创建复杂的行为会导致编写丑陋的代码，并增加出现错误的可能性。如果你忘记了一个需要存在的条件，你的游戏可能就会崩溃，让你知道有问题，但它无法做任何事情。然后，当你发现你的游戏最终崩溃时，你的生活就会变得复杂得多，你的游戏可能变得无法玩或根本不好玩。
- en: 'Robert Elder has a link of the subject which I think explains the kind of crazy
    things that you can do with conditional statements, which would almost certainly
    get you fired: [http://blog.robertelder.org/switch-statements-statement-expressions/](http://blog.robertelder.org/switch-statements-statement-expressions/).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特·埃尔德有一个关于这个主题的链接，我认为它解释了你可以用条件语句做的一些疯狂的事情，这几乎肯定会让你失业：[http://blog.robertelder.org/switch-statements-statement-expressions/](http://blog.robertelder.org/switch-statements-statement-expressions/)。
- en: Don't lose sleep over having conditionals in your code, but make sure that you
    only include them when you actually need them there. As you continue coding, you'll
    have a better idea as to when it's a good idea or not, but it is something to
    keep in mind.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为代码中有条件语句而烦恼，但确保你只在你真正需要它们的时候包含它们。随着你继续编码，你会更好地了解何时是合适的，但这是你需要记住的事情。
- en: Expanding on the State Machine
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展状态机
- en: So currently, you'll notice that in the Idle state we are setting our velocity
    to `0,0` every single frame. In this simple example, it's not a terribly big deal,
    but this overdoing of calculations is something that we'd like to avoid in the
    future. We only really need to do it once, right when we enter the state. We may
    also want to do certain actions when we leave the state, but we won't be able
    to do that in the current form of our State Machine, so we are going to need to
    redo some stuff.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所以目前，你会注意到在空闲状态下，我们每帧都将速度设置为 `0,0`。在这个简单的例子中，这并不是什么大问题，但这种过度计算是我们未来想要避免的。我们实际上只需要在进入状态时做一次，我们可能还希望在离开状态时执行某些操作，但在当前的状态机形式中，我们无法做到这一点，所以我们需要重做一些事情。
- en: 'First, let''s go back to the `ChasePlayerComponent.h` file and add the following
    bold function definitions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回到`ChasePlayerComponent.h`文件，并添加以下粗体函数定义：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So instead of having our `Update` function handle everything, we''ve now created
    three functions for each of the different times that our state can be in: entering
    a new state, updating based on that state, and then what to do when we leave the
    state. Aside from that, we also have a `SetNewState` function which will take
    care of changing the state to something else. All of the functions take in a `State`
    enum to choose how to execute, with the `Update` state also having the time that
    passed this frame, and the `SetNewState` having an option for saying it''s the
    first time you''ve set a state so you don''t need to leave the previous one. After
    that, we need to actually add in the functionality for these new functions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不是让`Update`函数处理所有事情，而是现在为我们的状态可能处于的不同时间创建了三个函数：进入新状态、根据该状态更新，以及离开状态时应该做什么。除此之外，我们还有一个`SetNewState`函数，它将负责将状态更改为其他状态。所有这些函数都接受一个`State`枚举来选择如何执行，其中`Update`状态还有通过这一帧过去的时间，而`SetNewState`有一个选项表示这是你第一次设置状态，因此你不需要离开上一个状态。之后，我们需要实际添加这些新函数的功能：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then, we need to update our `Update` function to just call our correct
    function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新我们的`Update`函数，使其仅调用我们的正确函数：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We also need to change our constructor so that instead of setting the current
    state, we set it ourselves:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改我们的构造函数，使其不再设置当前状态，而是由我们自己设置：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First of all, note that I am calling the `M5DEBUG_PRINT` function. This is to
    make it easy to tell that we are changing between different states. For the purposes
    of this demonstration, I commented out the `Update` function's version, but it
    could be useful for you to check it out. Note in this version, we have a `switch`
    statement for each of the functions and do something differently based on the
    state that is set in there.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意我正在调用`M5DEBUG_PRINT`函数。这样做是为了让我们更容易地知道我们正在在不同状态之间切换。为了演示的目的，我注释掉了`Update`函数的版本，但也许你可以查看一下。注意在这个版本中，我们为每个函数都有一个`switch`语句，并根据在那里设置的状态执行不同的操作。
- en: 'In my version of the editor, by default the text will not be displayed on the
    screen. To fix this issue, go to the `SplashStage.cpp` file and comment out the
    following bold code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的编辑器版本中，默认情况下文本不会显示在屏幕上。为了解决这个问题，请转到`SplashStage.cpp`文件并注释掉以下粗体代码：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now let's run our project!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行我们的项目！
- en: '![](img/00037.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00037.jpeg)'
- en: You can tell from the editor when we are switching our states and that the code
    is being called correctly!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从编辑器中看出我们何时切换状态，以及代码是否被正确调用！
- en: This version works pretty well, but there are some issues with it; namely that
    it involves a lot of rewriting, and we will need to copy/paste this functionality
    and make changes anytime we want to make a new version. Next, we will take a look
    at the State Machine included in the Mach5 Engine and the advantages that it has
    over what we've been talking about so far.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本工作得相当不错，但也有一些问题；主要是它涉及到大量的重写，并且每次我们想要创建一个新版本时，都需要复制/粘贴这个功能并做出相应的更改。接下来，我们将看看Mach5引擎中包含的状态机以及它相对于我们之前讨论的内容所具有的优势。
- en: The State pattern in action - the M5StateMachine class
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式在实际应用中的体现 - M5StateMachine类
- en: The Mach5 Engine itself also has its own implementation of a State Machine,
    using inheritance to allow users to not have to rewrite the base functionality
    over and over again and using function pointers instead of having one function
    for each state. A function pointer is what it sounds like--a pointer to the address
    in memory where the function is--and we can call it from that information.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Mach5引擎本身也有它自己的状态机实现，使用继承来允许用户不必反复重写基本功能，并使用函数指针而不是为每个状态有一个函数。函数指针就像它的名字一样——指向函数在内存中的地址的指针——我们可以从这个信息中调用它。
- en: To learn more about function pointers and how they are used, check out [http://www.cprogramming.com/tutorial/function-pointers.html](http://www.cprogramming.com/tutorial/function-pointers.html).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于函数指针及其使用方法的信息，请查看[http://www.cprogramming.com/tutorial/function-pointers.html](http://www.cprogramming.com/tutorial/function-pointers.html)。
- en: 'You can take a look at the base version of one here, starting with the `Header`
    file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看其基础版本，从`Header`文件开始：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, note that we finally broke apart the `StateMachine`
    and the `State` object into their own classes, with the state function having
    its own `Enter`, `Update`, and `Exit` functions. The State Machine keeps track
    of the current state that we are in and updates appropriately using the `Update`
    and `SetNextState` functions, and a `SetStateState` function is used to dictate
    what state we should start from. The implementation for the class looks a little
    something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意我们最终将`StateMachine`和`State`对象分解成它们自己的类，状态函数有自己的`Enter`、`Update`和`Exit`函数。状态机跟踪我们当前所处的状态，并使用`Update`和`SetNextState`函数适当地更新，`SetStateState`函数用于指定我们应该从哪个状态开始。类的实现看起来有点像这样：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This system provides a template that we can expand upon, in order to create
    more interesting behavior that does something a bit more complex. Take, for example,
    the `RandomGoComponent` class, whose header looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统提供了一个模板，我们可以在此基础上扩展，以创建更复杂、更有趣的行为。以`RandomGoComponent`类为例，其头文件看起来如下：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This class contains three states, `Find`, `Rotate`, and `Go`, which have been
    added as objects in the `RandomGoComponent`. Each of the states has their own
    `Enter`, `Update`, and `Exit` functionality, in addition to the constructor and
    a reference to their parent. The implementation for the classes looks something
    like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含三个状态，`Find`、`Rotate`和`Go`，这些状态已经被添加为`RandomGoComponent`中的对象。每个状态都有它们自己的`Enter`、`Update`和`Exit`功能，除了构造函数和对其父对象的引用。类的实现看起来大致如下：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This class will just tell our main State Machine where its intended location
    is. This only needs to be done once, so it is done in the `Enter` state. The `Update`
    state just states that after this is done, we want to move to the `Rotate` state,
    and `Exit` does nothing. Technically, we could not create it, and that would be
    fine as well since the base class doesn''t do anything as well, but it is here
    if you wish to expand upon it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只是告诉我们的主状态机其预期的位置。这只需要做一次，所以它在`Enter`状态下完成。`Update`状态只是声明完成之后，我们希望移动到`Rotate`状态，而`Exit`什么也不做。技术上，我们可能无法创建它，但这也可以，因为基类也没有做任何事情，但如果你愿意扩展它，它就在这里：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Rotate` state will just rotate the character till it is facing the location
    that it wants to go to. If it is within the range of the rotation, it will then
    switch to the `Go` state. Before leaving though, it will set the velocity of our
    parent to the appropriate direction in the `Exit` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rotate`状态将只是旋转角色，直到它面对它想要去的位置。如果它在旋转范围内，它将切换到`Go`状态。但在离开之前，它将在`Exit`函数中将父对象的速率设置为适当的方向：'
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Go` state merely checks whether the enemy intersects with the target that
    we are set to go to. If it does, we then set our state to move back to the `Find`
    state and start everything over again, and also stop the player from moving in
    the `Exit` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Go`状态只是检查敌人是否与我们要去的目标相交。如果是，我们就会将我们的状态设置为移动回`Find`状态并重新开始一切，并在`Exit`函数中停止玩家移动：'
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, this works in a very similar way to what we have done before--setting
    our first state, getting the initial values from the INI file, and then setting
    things properly when cloned. Finally, we also have a `GetState` function which
    will return the current state that the player has using a switch like we talked
    about previously.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这与我们之前所做的工作非常相似--设置我们的第一个状态，从INI文件中获取初始值，然后在克隆时设置正确的事情。最后，我们还有一个`GetState`函数，它将返回玩家当前的状态，就像我们之前讨论的那样使用switch语句。
- en: 'To see this in action, go ahead and go to the `Raider.ini` file and modify
    the code to fit the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个效果，请前往`Raider.ini`文件并修改代码以适应以下内容：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If all went well, save the file and then run the project!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，保存文件然后运行项目！
- en: '![](img/00038.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: Now we will see the enemy continually move into new areas, rotating before going
    there!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到敌人不断地移动到新的区域，在到达之前旋转！
- en: The State pattern in action - StageManager
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式的应用 - StageManager
- en: 'Another aspect of the Mach5 Engine that uses the State pattern is the `M5StageManager`
    class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Mach5 引擎使用状态模式的另一个方面是`M5StageManager`类：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since there will only be one of these in the game, all of the functionality
    has been made static similarly to a Singleton but, depending on the state that
    the project is in, it will do different things. Take, for example, changing what
    stage we are in. I''m sure you''ll find that it looks very similar to how we changed
    states earlier:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏中只会存在一个这样的实例，因此所有功能都已被设置为静态，类似于单例模式，但根据项目所处的状态，它将执行不同的操作。以改变我们处于的阶段为例。我相信你会发现这和之前我们改变状态的方式非常相似：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I highly advise taking a closer look at the file and going through each function
    to see how they interact with each other.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你仔细查看文件，并逐个函数地了解它们是如何相互作用的。
- en: Issues with FSMs
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于有限状态机（FSM）的问题
- en: We've seen some of the ways in which FSMs can be valuable things to add to your
    projects and how they can make simple AI behaviors much easier, but there are
    some issues with them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了有限状态机（FSM）可以作为有价值的东西添加到项目中，以及它们如何使简单的AI行为变得更容易，但它们也存在一些问题。
- en: Traditional FSMs such as the ones we've displayed here can, over time, become
    unmanageable as you continue to add many different states to them. The difficult
    part is keeping the number of states to a minimum while also adding complexity
    by adding new contexts in which your characters can respond.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的有限状态机，如我们在此处展示的，随着时间的推移，可能会变得难以管理，因为你继续向其中添加许多不同的状态。困难的部分是在添加新上下文的同时，将状态的数量保持在最低，以便你的角色可以响应。
- en: You'll also have a lot of similar code being written as you'll be rebuilding
    different behaviors that have pieces of others, which can also be time-consuming.
    Another thing that's been going on recently in the game industry is AI programmers
    moving on to more complex ways of handing AI, such as behavior trees.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重建具有其他部分的行为时，你将编写大量类似的代码，这可能会消耗时间。最近在游戏行业中发生的一件事是，AI程序员正在转向更复杂的方式来处理AI，例如行为树。
- en: 'If you''re interested in why some people believe that the age of Finite State
    Machines is over, check out [http://aigamedev.com/open/article/fsm-age-is-over/](http://aigamedev.com/open/article/fsm-age-is-over/).
    A look at the issues with FSMs, as well as some potential solutions to fix those
    issues, can be found here: [http://aigamedev.com/open/article/hfsm-gist/](http://aigamedev.com/open/article/fsm-age-is-over/).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，想知道为什么有些人认为有限状态机的时代已经结束，请查看[http://aigamedev.com/open/article/fsm-age-is-over/](http://aigamedev.com/open/article/fsm-age-is-over/)。在这里可以找到关于有限状态机的问题以及一些潜在的解决方案来修复这些问题：[http://aigamedev.com/open/article/hfsm-gist/](http://aigamedev.com/open/article/hfsm-gist/)。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the State pattern, which is a way to allow
    a game object to change its behavior and functionality in response to different
    stimuli within the game. We learned about the State and the Context (Machine)
    and how they are used together. We then learned how we can use the State pattern
    to gain some exposure toward AI programming, as well as how our project's Game
    State Manager works and why it's important. Of course, FSMs are most popular in
    being used for AI, but can also be used in UI as well as dealing with user input,
    making them another useful tool to have in your arsenal.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了状态模式，这是一种允许游戏对象根据游戏中的不同刺激改变其行为和功能的方法。我们学习了状态和上下文（机器）以及它们是如何一起使用的。然后我们学习了如何使用状态模式来获得一些关于AI编程的曝光，以及我们项目的游戏状态管理器是如何工作的以及为什么它很重要。当然，有限状态机在用于AI方面最为流行，但也可以用于UI以及处理用户输入，使它们成为你武器库中的另一个有用工具。
