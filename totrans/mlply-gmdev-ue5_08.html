<html><head></head><body>
<div id="_idContainer127">
<h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-162"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.2.1">Introducing AI into a Multiplayer Environment</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Artificial Intelligence</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.5.1">AI</span></strong><span class="koboSpan" id="kobo.6.1">) systems</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.7.1"> offer an exciting and unique gaming experience for players by providing dynamic challenges that are unpredictable and engaging. </span><span class="koboSpan" id="kobo.7.2">This allows developers to create immersive worlds with realistic behavior </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.8.1">from </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">non-player </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.10.1">characters</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.11.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.12.1">NPCs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">In this chapter, I will introduce you to the basics of AI in Unreal Engine but, as this is a book about multiplayer games, I will not go deep into the details of the system – instead, you will take the first steps in the creation of opponents, which will make your game fully playable from a networked point </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">of view.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">By the end of the chapter, you will have created an enemy Actor that wanders around the level and actively pursues the player’s character once it is detected. </span><span class="koboSpan" id="kobo.16.2">This will serve as a starting point for creating more diverse and compelling enemies in </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">your game.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">So, in this chapter, I will present you with the </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">Setting up the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">AI system</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Creating an </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">AI opponent</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Adding opponents to </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">the level</span></span></li>
</ul>
<h1 id="_idParaDest-163"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.26.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.27.1">To follow the topics presented in this chapter, you should have completed the previous ones and understood </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">their content.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">.zip</span></strong><span class="koboSpan" id="kobo.31.1"> project files provided in this book’s accompanying </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">project repository:</span></span></p>
<p><a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5"><span class="No-Break"><span class="koboSpan" id="kobo.33.1">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</span></span></a></p>
<p><span class="koboSpan" id="kobo.34.1">You can download the files that are up to date with the end of the last chapter by clicking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">Unreal Shadows – </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">Chapter 07</span></strong></span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">End</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.38.1"> link.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.39.1">Setting up the AI system</span></h1>
<p><span class="koboSpan" id="kobo.40.1">Crafting an </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.41.1">AI opponent in Unreal Engine can be quite a hard task. </span><span class="koboSpan" id="kobo.41.2">Luckily, this book is focused on boosting your multiplayer prowess, rather than getting bogged down in all the details of AI, so I will not go deep into the Unreal Engine AI system. </span><span class="koboSpan" id="kobo.41.3">However, if you want to make your game enjoyable, it definitely helps to have some know-how on creating a worthy </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">AI opponent.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">In order to make the AI character move around the level, you will need to define which areas are allowed and which are not (as an example, you will most definitely need to give the character a safe place that the opponents won’t dare to step into). </span><span class="koboSpan" id="kobo.43.2">Once we’ve done that, in the next steps, we will create these areas so that the AI system can manage the minions’ walking paths. </span><span class="koboSpan" id="kobo.43.3">Once we’ve done that, we’ll be well on our way to creating awesome, mindless, </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">walking undead.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">To make everything work properly, first of all, we need to give our minion opponents something to walk on. </span><span class="koboSpan" id="kobo.45.2">As you may already know, Unreal Engine uses a </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">Navigation System</span></strong><span class="koboSpan" id="kobo.47.1"> to let </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.48.1">AI Actors navigate a level using </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">pathfinding algorithms.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">The Navigation System takes the collision geometry in your level and generates a </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Navigation Mesh</span></strong><span class="koboSpan" id="kobo.52.1">, which </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.53.1">is then split into portions (i.e., polygon geometries) that are used to create a graph. </span><span class="koboSpan" id="kobo.53.2">This graph is </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.54.1">what </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">agents</span></strong><span class="koboSpan" id="kobo.56.1"> (such as AI characters) use to navigate to their destination. </span><span class="koboSpan" id="kobo.56.2">Each portion is given a cost, which agents then use to calculate the most efficient path (the one with the lowest overall cost). </span><span class="koboSpan" id="kobo.56.3">It’s like a smart GPS for your </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">game characters!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.58.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.59.1">If you want more information about the Unreal Engine Navigation System and its inner workings, you can visit the official Epic Games documentation at this </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">link: </span></span><a href="https://docs.unrealengine.com/5.1/en-US/navigation-system-in-unreal-engine/"><span class="No-Break"><span class="koboSpan" id="kobo.61.1">https://docs.unrealengine.com/5.1/en-US/navigation-system-in-unreal-engine/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.62.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">To add a</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.64.1"> Navigation Mesh to the level, you will need to take the </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.66.1">Open the game level you’ve been working on so far and, from the </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">Quickly add to the project</span></strong><span class="koboSpan" id="kobo.68.1"> button, select </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">NavMeshBoundsVolume</span></strong><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">This will add the </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">NavMeshBoundsVolume</span></strong><span class="koboSpan" id="kobo.72.1"> component to the level and a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.73.1">RecastNavMesh</span></strong></span><span class="No-Break"> </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">Actor</span></span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.76.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">Outliner</span></strong><span class="koboSpan" id="kobo.78.1">, select </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">NavMeshBoundsVolume</span></strong><span class="koboSpan" id="kobo.80.1"> and, with the </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">Scale</span></strong><span class="koboSpan" id="kobo.82.1"> tool enabled, resize it so that it covers your desired portion of the level – avoid the spawn region for your player characters, as you want to give them a safe place to rest or escape to </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">if needed.</span></span></li>
<li><span class="koboSpan" id="kobo.84.1">Hit the </span><em class="italic"><span class="koboSpan" id="kobo.85.1">P</span></em><span class="koboSpan" id="kobo.86.1"> key on your keyboard to show the newly created Navigation Mesh, which should look </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.87.1">similar to the one depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.88.1">Figure 8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.89.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer122">
<span class="koboSpan" id="kobo.91.1"><img alt="Figure 8.1 – The Navigation Mesh area" src="image/Figure_08_01_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.92.1">Figure 8.1 – The Navigation Mesh area</span></p>
<p><span class="koboSpan" id="kobo.93.1">The green-colored area (i.e., the Navigation Mesh) represents the places where the AI character can walk. </span><span class="koboSpan" id="kobo.93.2">You will </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.94.1">notice that walls and doors will create “holes” in this mesh, so the AI will be forbidden to step into it. </span><span class="koboSpan" id="kobo.94.2">Don’t worry about the portions outside of your dungeon – there are no open doors to connect them, so the minions won’t be able to </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">reach them.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">In this section, you were briefly introduced to the Unreal Engine Navigation System and you have set up a navigable area for the soon-to-be-created AI opponents. </span><span class="koboSpan" id="kobo.96.2">As I see you’re eager to start coding, let’s fire up your programming IDE and start writing some code together! </span><span class="koboSpan" id="kobo.96.3">It’s time to summon some undead minions and let them walk around </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">the dungeon.</span></span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.98.1">Creating an AI opponent</span></h1>
<p><span class="koboSpan" id="kobo.99.1">In this </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.100.1">section, you’ll start by creating a class for your hero’s foes, complete with the basic ability to patrol and attack. </span><span class="koboSpan" id="kobo.100.2">Sure, they might not be the sharpest guys around, but hey, they’re the Lichlord’s undead minions – not exactly known for their intelligence, </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">are they?</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">We’ll be starting by extending the Character class, which, as you may already know, can be controlled by an </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">AIController</span></strong><span class="koboSpan" id="kobo.104.1">, allowing independent actions </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">during gameplay.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">At this point, we want the minion to have the </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">following features:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.108.1">A random patrolling movement around </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">the level</span></span></li>
<li><span class="koboSpan" id="kobo.110.1">A perception system that will allow it to see and hear the </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">player’s character</span></span></li>
<li><span class="koboSpan" id="kobo.112.1">The ability to seek out the player once it has </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">been detected</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.114.1">In the next chapters, we’ll extend the Character class further by adding some more features such as health and spawnable goodies (when the AI has been defeated) but for now, we’ll just focus on the movement and </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">perception system.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.116.1">Adding the navigation module</span></h2>
<p><span class="koboSpan" id="kobo.117.1">The first thing to do </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.118.1">in order to have an agent that can navigate through a Navigation Mesh is to add the corresponding module to </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">your project.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">To do this, get back to your programming IDE and open your project build file – the one named </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">UnrealShadows_LOTL.Build.cs</span></strong><span class="koboSpan" id="kobo.122.1"> (or similar, if you opted for a different project name). </span><span class="koboSpan" id="kobo.122.2">Locate the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.124.1">
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput" });</span></pre>
<p><span class="koboSpan" id="kobo.125.1">Change it by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">NavigationSystem</span></strong><span class="koboSpan" id="kobo.127.1"> declaration, </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.129.1">
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "NavigationSystem" });</span></pre>
<p><span class="koboSpan" id="kobo.130.1">With the project settings updated, we can start working on the minion AI, by creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">dedicated class.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.132.1">Creating the minion class</span></h2>
<p><span class="koboSpan" id="kobo.133.1">It’s time to create the </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.134.1">AI minion class, so create a new class derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">Character</span></strong><span class="koboSpan" id="kobo.136.1"> and name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">US_Minion</span></strong><span class="koboSpan" id="kobo.138.1">. </span><span class="koboSpan" id="kobo.138.2">Once the class has been created, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">US_Minion.h</span></strong><span class="koboSpan" id="kobo.140.1"> header file and, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">private</span></strong><span class="koboSpan" id="kobo.142.1"> section, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Minion Perception", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UPawnSensingComponent&gt; PawnSense;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Minion Perception", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class USphereComponent&gt; Collision;
UPROPERTY()
FVector PatrolLocation;</span></pre>
<p><span class="koboSpan" id="kobo.145.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">Collision</span></strong><span class="koboSpan" id="kobo.147.1"> property will be used as a trigger for the AI to grab the character, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">PatrolLocation</span></strong><span class="koboSpan" id="kobo.149.1"> will be used to tell the AI where to go if not chasing </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">the character.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">PawnSense</span></strong><span class="koboSpan" id="kobo.153.1"> property is the declaration for </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">PawnSensingComponent</span></strong><span class="koboSpan" id="kobo.155.1">, a component that can be used by the AI character to see and hear pawns around the level (i.e., the player characters). </span><span class="koboSpan" id="kobo.155.2">This component is quite straightforward to use and is easily configurable, letting you make the opponent more or less “dumb” during gameplay. </span><span class="koboSpan" id="kobo.155.3">You’ll get mere info on this in a minute or two when you’ll be </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">initializing it.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Now it’s time to add some properties to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">public</span></strong><span class="koboSpan" id="kobo.159.1"> section. </span><span class="koboSpan" id="kobo.159.2">Just add the </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Minion AI")
float PatrolSpeed = 150.0f;
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Minion AI")
float ChaseSpeed = 350.0f;
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Minion AI")
float PatrolRadius = 50000.0f;</span></pre>
<p><span class="koboSpan" id="kobo.162.1">We have defined </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.163.1">two movement speed properties: </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">PatrolSpeed</span></strong><span class="koboSpan" id="kobo.165.1"> will be used when the minion is walking around aimlessly, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">ChaseSpeed</span></strong><span class="koboSpan" id="kobo.167.1"> will be used whenever the minion is seeking the character, in order to make it a new pawn for the Lichlord’s army! </span><span class="koboSpan" id="kobo.167.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">PatrolRadius</span></strong><span class="koboSpan" id="kobo.169.1"> property will be used to find a new location in the level for the minion </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">to inspect.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">After the properties, you will be declaring the public methods needed for the correct behavior of the AI opponent. </span><span class="koboSpan" id="kobo.171.2">Still in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">public</span></strong><span class="koboSpan" id="kobo.173.1"> section, add this block of code to </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">declare them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
UFUNCTION(BlueprintCallable, Category="Minion AI")
void SetNextPatrolLocation();
UFUNCTION(BlueprintCallable, Category="Minion AI")
void Chase(APawn* Pawn);
virtual void PostInitializeComponents() override;
FORCEINLINE UPawnSensingComponent* GetPawnSense() const { return PawnSense; }
FORCEINLINE USphereComponent* GetCollision() const { return Collision; }</span></pre>
<p><span class="koboSpan" id="kobo.176.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">SetNextPatrolLocation()</span></strong><span class="koboSpan" id="kobo.178.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Chase()</span></strong><span class="koboSpan" id="kobo.180.1"> methods will be used to let the AI character move around the scene, looking for a new spot or seeking the player character. </span><span class="koboSpan" id="kobo.180.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">PostInitializeComponent()</span></strong><span class="koboSpan" id="kobo.182.1"> override will be used to register the character events. </span><span class="koboSpan" id="kobo.182.2">Lastly, we are declaring the usual getters for the character components that have </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">been added.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">The last step in the</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.185.1"> header declaration is to add the event handlers for </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">this character:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
UFUNCTION()
void OnPawnDetected(APawn* Pawn);
UFUNCTION()
void OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor);</span></pre>
<p><span class="koboSpan" id="kobo.188.1">The first one will manage the minion logic once it has detected a pawn with its senses, while the second one will be used to check whether a player character has </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">been captured.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">The header has</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.191.1"> finally been declared – please note that, at the moment, we are not taking into consideration the hearing capabilities of the minion; this is something we are going to implement in the next chapter when our thief hero starts to make </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">some noise!</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.193.1">Implementing the minions’ behaviors</span></h2>
<p><span class="koboSpan" id="kobo.194.1">You’ve</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.195.1"> declared all your functions and properties, so now it’s time to put them to good use by implementing some behaviors for your AI minions. </span><span class="koboSpan" id="kobo.195.2">Let’s make sure everything is running smoothly and get this </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">project rolling!</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">US_Minion.cpp</span></strong><span class="koboSpan" id="kobo.199.1"> file and add the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">include</span></strong><span class="koboSpan" id="kobo.201.1"> statements at </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">the top:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.203.1">
#include "AIController.h"
#include "NavigationSystem.h"
#include "US_Character.h"
#include "Components/CapsuleComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Perception/PawnSensingComponent.h"
#include "Blueprint/AIBlueprintHelperLibrary.h"
#include "Components/SphereComponent.h"</span></pre>
<p><span class="koboSpan" id="kobo.204.1">As usual, these lines of code will declare the classes we will use from now on. </span><span class="koboSpan" id="kobo.204.2">After you have done that, it’s time to implement the constructor by adding the needed components and initializing all </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">the properties.</span></span></p>
<h3><span class="koboSpan" id="kobo.206.1">Declaring the constructor</span></h3>
<p><span class="koboSpan" id="kobo.207.1">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">include</span></strong><span class="koboSpan" id="kobo.209.1"> statements have been</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.210.1"> properly declared, you can start by locating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">AUS_Minion()</span></strong><span class="koboSpan" id="kobo.212.1"> constructor and inserting the character initialization. </span><span class="koboSpan" id="kobo.212.2">Inside the brackets, just after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">PrimaryActorTick.bCanEverTick</span></strong><span class="koboSpan" id="kobo.214.1"> declaration, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">following </span></span><span class="No-Break"><a id="_idIndexMarker455"/></span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
bUseControllerRotationPitch = false;
bUseControllerRotationYaw = false;
bUseControllerRotationRoll = false;
AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned;
AIControllerClass = AAIController::StaticClass();
PawnSense = CreateDefaultSubobject&lt;UPawnSensingComponent&gt;(TEXT("PawnSense"));
PawnSense-&gt;SensingInterval = .8f;
PawnSense-&gt;SetPeripheralVisionAngle(45.f);
PawnSense-&gt;SightRadius = 1500.f;
PawnSense-&gt;HearingThreshold = 400.f;
PawnSense-&gt;LOSHearingThreshold = 800.f;
Collision = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT("Collision"));
Collision-&gt;SetSphereRadius(100);
Collision-&gt;SetupAttachment(RootComponent);
GetCapsuleComponent()-&gt;InitCapsuleSize(60.f, 96.0f);
GetCapsuleComponent()-&gt;SetGenerateOverlapEvents(true);
GetMesh()-&gt;SetRelativeLocation(FVector(0.f, 0.f, -91.f));
static ConstructorHelpers::FObjectFinder&lt;USkeletalMesh&gt; SkeletalMeshAsset(TEXT("/Game/KayKit/Skeletons/skeleton_minion"));
if (SkeletalMeshAsset.Succeeded())
{
 GetMesh()-&gt;SetSkeletalMesh(SkeletalMeshAsset.Object);
}
GetCharacterMovement()-&gt;bOrientRotationToMovement = true;
GetCharacterMovement()-&gt;RotationRate = FRotator(0.0f, 500.0f, 0.0f);
GetCharacterMovement()-&gt;MaxWalkSpeed = 200.f;
GetCharacterMovement()-&gt;MinAnalogWalkSpeed = 20.f;
GetCharacterMovement()-&gt;BrakingDecelerationWalking = 2000.f;</span></pre>
<p><span class="koboSpan" id="kobo.218.1">You’ll already be familiar with most of the code from the thief character creation, but you will see some noticeable additions. </span><span class="koboSpan" id="kobo.218.2">First of all, we are setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">AutoPossessAI</span></strong><span class="koboSpan" id="kobo.220.1"> property, which lets us define whether the game system will possess the AI character once in the level – we want it to be both in full control when it is spawned at runtime and when it is already in the level when the game starts, so we have opted for a value </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">PlacedInWorldOrSpawned</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">Then, we </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.225.1">define which controller will be used for the AI system by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">AIControllerClass</span></strong><span class="koboSpan" id="kobo.227.1"> property; in this case, we are just using the base </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">AAIController</span></strong><span class="koboSpan" id="kobo.229.1"> class, but you can obviously implement your own with </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">additional features.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">The last notable thing is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">PawnSense</span></strong><span class="koboSpan" id="kobo.233.1"> component creation – as you can see, we are initializing the properties that will make the minion see and hear at a certain distance. </span><span class="koboSpan" id="kobo.233.2">You should take note of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">SensingInterval</span></strong><span class="koboSpan" id="kobo.235.1"> initialization, which will let us tweak how much </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.236.1">time will pass between two sense perceptions. </span><span class="koboSpan" id="kobo.236.2">This will make the difference between a very reactive character (i.e., a lower value) or a really dumb one (i.e., a </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">higher one).</span></span></p>
<h3><span class="koboSpan" id="kobo.238.1">Initializing the minion</span></h3>
<p><span class="koboSpan" id="kobo.239.1">It’s now time to </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.240.1">initialize the character when it is added to the game. </span><span class="koboSpan" id="kobo.240.2">As you already know, this is usually done from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">BeginPlay()</span></strong><span class="koboSpan" id="kobo.242.1"> method. </span><span class="koboSpan" id="kobo.242.2">So, just after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">Super::BeginPlay()</span></strong><span class="koboSpan" id="kobo.244.1"> declaration, add </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
SetNextPatrolLocation();</span></pre>
<p><span class="koboSpan" id="kobo.247.1">This call will simply start the patrolling behavior. </span><span class="koboSpan" id="kobo.247.2">Then, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">PostInitializeComponents()</span></strong><span class="koboSpan" id="kobo.249.1"> implementation by adding this code to </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.251.1">
void AUS_Minion::PostInitializeComponents()
{
 Super::PostInitializeComponents();
if(GetLocalRole() != ROLE_Authority) return;
 OnActorBeginOverlap.AddDynamic(this, &amp;AUS_Minion::OnBeginOverlap);
 GetPawnSense()-&gt;OnSeePawn.AddDynamic(this, &amp;AUS_Minion::OnPawnDetected);
}</span></pre>
<p><span class="koboSpan" id="kobo.252.1">As you can see, we are using two delegates to react to an Actor overlap, for checking whether we have reached the player character, and to handle the pawn perception to check whether we can see the player character. </span><span class="koboSpan" id="kobo.252.2">Also, notice that they are initialized only if the role of this object is authoritative (i.e., the method is being executed on </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">the server).</span></span></p>
<p><span class="koboSpan" id="kobo.254.1">The next step is to </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.255.1">implement these two delegate functions in order to manage the </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">aforementioned events.</span></span></p>
<h3><span class="koboSpan" id="kobo.257.1">Handling the delegate functions</span></h3>
<p><span class="koboSpan" id="kobo.258.1">Whenever the </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.259.1">minion detects a pawn, it will immediately check whether it is a character and, if the result is successful, it will start chasing it. </span><span class="koboSpan" id="kobo.259.2">Let’s add the method to handle the delegate in the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">source file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
void AUS_Minion::OnPawnDetected(APawn* Pawn)
{
 if (!Pawn-&gt;IsA&lt;AUS_Character&gt;()) return;
 GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT("Character detected!"));
 if (GetCharacterMovement()-&gt;MaxWalkSpeed != ChaseSpeed)
 {
  Chase(Pawn);
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.262.1">The code here is quite straightforward – we just have added a debug message stating that a character has </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">been detected.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">The second delegate we need to handle is the overlap, so add the following </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">method implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
void AUS_Minion::OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor)
{
 if (!OtherActor-&gt;IsA&lt;AUS_Character&gt;()) return;
 GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Yellow, TEXT("Character captured!"));
}</span></pre>
<p><span class="koboSpan" id="kobo.267.1">As you can see, we check again whether we have found a character, and after that, we simply display a debug message – it looks like our hero got a little too close to the minions and now they’ve roped them into joining the Lichlord’s undead army! </span><span class="koboSpan" id="kobo.267.2">Later on, you’ll implement a </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.268.1">respawn system to let the player restart the game with a </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">brand-new character.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">The next step will be the actual AI’s movement through the Navigation Mesh, both for the patrol and </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">chase behaviors.</span></span></p>
<h3><span class="koboSpan" id="kobo.272.1">Implementing the chase and patrol behaviors</span></h3>
<p><span class="koboSpan" id="kobo.273.1">It’s now time to </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.274.1">start implementing the movement control for your AI character – specifically, you’ll be implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">SetNextPatrolLocation()</span></strong><span class="koboSpan" id="kobo.276.1"> function, which will find a new reachable point for the minion, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">Chase()</span></strong><span class="koboSpan" id="kobo.278.1"> function, which will send the minion on a “seek and destroy” mission toward the character. </span><span class="koboSpan" id="kobo.278.2">To do so, add the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.280.1">
void AUS_Minion::SetNextPatrolLocation()
{
 if(GetLocalRole() != ROLE_Authority) return;
 GetCharacterMovement()-&gt;MaxWalkSpeed = PatrolSpeed;
 const auto LocationFound = UNavigationSystemV1::K2_GetRandomReachablePointInRadius(
     this, GetActorLocation(), PatrolLocation, PatrolRadius);
 if(LocationFound)
 {
  UAIBlueprintHelperLibrary::SimpleMoveToLocation(GetController(), PatrolLocation);
 }
}
void AUS_Minion::Chase(APawn* Pawn)
{
 if(GetLocalRole() != ROLE_Authority) return;
 GetCharacterMovement()-&gt;MaxWalkSpeed = ChaseSpeed;
 UAIBlueprintHelperLibrary::SimpleMoveToActor(GetController(), Pawn);
 DrawDebugSphere(GetWorld(), Pawn-&gt;GetActorLocation(), 25.f, 12, FColor::Red, true, 10.f, 0, 2.f);
}</span></pre>
<p><span class="koboSpan" id="kobo.281.1">The first function sets the character speed to the patrolling value and uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">UNavigationSystemV1::K2_GetRandomReachablePointInRadius()</span></strong><span class="koboSpan" id="kobo.283.1"> method to find a reachable point in the Navigation Mesh. </span><span class="koboSpan" id="kobo.283.2">Then, the AI is simply commanded to reach </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">that location.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">The second </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.286.1">function does something similar, but the target point will be the character – after all, it is on a mission from the Lichlord to get as many soon-to-be undead heroes </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">as possible!</span></span></p>
<h3><span class="koboSpan" id="kobo.288.1">Implementing the Tick() event</span></h3>
<p><span class="koboSpan" id="kobo.289.1">The last </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.290.1">thing you need to implement in order to make the patrolling system fully operational is to check whether the AI character has reached its destination; in this case, it will just have to find another point in the Navigation Mesh. </span><span class="koboSpan" id="kobo.290.2">As we need to continuously check the distance between the AI and the target point, the best place to write the code is within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">Tick()</span></strong><span class="koboSpan" id="kobo.292.1"> event. </span><span class="koboSpan" id="kobo.292.2">Let’s find the method and, just after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Super::Tick(DeltaTime)</span></strong><span class="koboSpan" id="kobo.294.1"> call, add this piece </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.296.1">
if(GetLocalRole() != ROLE_Authority) return;
if(GetMovementComponent()-&gt;GetMaxSpeed() == ChaseSpeed) return;
if((GetActorLocation() - PatrolLocation).Size() &lt; 500.f)
{
 SetNextPatrolLocation();
}</span></pre>
<p><span class="koboSpan" id="kobo.297.1">As you can see, the first line checks whether the character is patrolling (i.e., the maximum speed should not equal the chase speed). </span><span class="koboSpan" id="kobo.297.2">Then, we are checking that we are near enough (about half a meter) to the patrol location in order to look for another </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">reachable point.</span></span></p>
<h3><span class="koboSpan" id="kobo.299.1">Testing the AI opponent</span></h3>
<p><span class="koboSpan" id="kobo.300.1">Now</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.301.1"> that the enemy AI has been created, you can test it out in the game level. </span><span class="koboSpan" id="kobo.301.2">To do this, open the Unreal Engine Editor and, from the Content Browser, drag an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">US_Minion</span></strong><span class="koboSpan" id="kobo.303.1"> class (located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">C++ Classes</span></strong><span class="koboSpan" id="kobo.305.1"> | </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">UnrealShadows_LOTL</span></strong><span class="koboSpan" id="kobo.307.1"> folder) into the level. </span><span class="koboSpan" id="kobo.307.2">You should see something similar to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.308.1">Figure 8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.309.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer123">
<span class="koboSpan" id="kobo.311.1"><img alt="Figure 8.2 – The AI opponent in the level" src="image/Figure_08_02_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.312.1">Figure 8.2 – The AI opponent in the level</span></p>
<p><span class="koboSpan" id="kobo.313.1">The gizmos around the character represent the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">PawnSense</span></strong><span class="koboSpan" id="kobo.315.1"> component – its sight and hearing capabilities. </span><span class="koboSpan" id="kobo.315.2">The sight area is represented by a green cone that shows how wide and far the AI can see. </span><span class="koboSpan" id="kobo.315.3">The hearing sense is represented by two spheres – a yellow one that shows how far the AI will hear a noise if it is not obstructed by any obstacle, and a cyan one that shows how far the AI will sense noise, even if generated behind an obstacle, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">a wall.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Go into play mode and the opponent should start wandering around the level and over the Navigation Mesh. </span><span class="koboSpan" id="kobo.317.2">Whenever a player character enters the minion’s line of sight (i.e., the green cone), the enemy will react and start chasing the player at a </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">higher speed.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">Once the character has been reached, you will notice that the minion will stop moving – its mission has been completed and it </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">can rest!</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">As an extra exercise, you may want to add a timer that will check whether the AI is staying still for too long; in that case, it will restart its patrolling system by looking for a new </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">reachable</span></span><span class="No-Break"><a id="_idIndexMarker466"/></span><span class="No-Break"><span class="koboSpan" id="kobo.323.1"> location.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">So, in this section, you have created your AI opponent, ready to roam around the dungeon, seeking its next victim. </span><span class="koboSpan" id="kobo.324.2">You have created a simple but effective patrolling system and added a perception sense to the AI so that it can intercept the player when they are not </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">stealthy enough.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">In the next section, you’ll create a spawning system in order to add minions as the game progresses and make things more challenging for </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">the players.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.328.1">Adding opponents to the level</span></h1>
<p><span class="koboSpan" id="kobo.329.1">Now that you </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.330.1">have an opponent for your thief hero, it is time to let the system spawn a bunch of them at runtime. </span><span class="koboSpan" id="kobo.330.2">You’ll be doing this by implementing a spawn system similar to the one used in </span><a href="B18203_03.xhtml#_idTextAnchor065"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.331.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.332.1">, </span><em class="italic"><span class="koboSpan" id="kobo.333.1">Testing the Multiplayer System with a Project Prototype</span></em><span class="koboSpan" id="kobo.334.1"> – this time, you’ll create the spawner in </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">C++ instead.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">What we want to implement here is an Actor that will have the </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">following features:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.338.1">Spawns a few minions at the start of </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">the game.</span></span></li>
<li><span class="koboSpan" id="kobo.340.1">Spawns new minions at </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">predefined intervals.</span></span></li>
<li><span class="koboSpan" id="kobo.342.1">Spawns the minions in a </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">selected area.</span></span></li>
<li><span class="koboSpan" id="kobo.344.1">Randomly selects a minion type every time it spawns. </span><span class="koboSpan" id="kobo.344.2">At the moment, we have just one minion type, but in the following chapters, we will add </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">more variations.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.346.1">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">get started.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.348.1">Creating a spawner class</span></h2>
<p><span class="koboSpan" id="kobo.349.1">Start by creating a C++ class that </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.350.1">extends from Actor and </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.351.1">name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">US_MinionSpawner</span></strong><span class="koboSpan" id="kobo.353.1">. </span><span class="koboSpan" id="kobo.353.2">Once created, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">.h</span></strong><span class="koboSpan" id="kobo.355.1"> file and, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">private</span></strong><span class="koboSpan" id="kobo.357.1"> section, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">following declarations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.359.1">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Spawn System", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UBoxComponent&gt; SpawnArea;
UPROPERTY()
FTimerHandle SpawnTimerHandle;</span></pre>
<p><span class="koboSpan" id="kobo.360.1">You should be already familiar with the first declaration from </span><a href="B18203_03.xhtml#_idTextAnchor065"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.361.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.362.1">, </span><em class="italic"><span class="koboSpan" id="kobo.363.1">Testing the Multiplayer System with a Project Prototype</span></em><span class="koboSpan" id="kobo.364.1"> – we are declaring an area that will be used to randomize the spawned minion location. </span><span class="koboSpan" id="kobo.364.2">The second declaration will be used to store a reference of the timer handler used by the spawner to generate new minions at </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">predefined intervals.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">Now we are going to declare some properties that will make this class customizable in the level. </span><span class="koboSpan" id="kobo.366.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">public</span></strong><span class="koboSpan" id="kobo.368.1"> section, add the following </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">property declarations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Spawn System")
TArray&lt;TSubclassOf&lt;class AUS_Minion&gt;&gt; SpawnableMinions;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Spawn System")
float SpawnDelay = 10.0f;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Spawn System")
int32 NumMinionsAtStart = 5;</span></pre>
<p><span class="koboSpan" id="kobo.371.1">The first property </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.372.1">will expose an array that will contain all the spawnable minion types. </span><span class="koboSpan" id="kobo.372.2">As stated before, at the moment, we have just one type, but we will add some more later on. </span><span class="koboSpan" id="kobo.372.3">The other two properties are self-explanatory, letting </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.373.1">us define the spawn timing and how many minions should already be in the level when the </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">game starts.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">The last step is to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">Spawn()</span></strong><span class="koboSpan" id="kobo.377.1"> method in the protected section of </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">the header:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.379.1">
UFUNCTION()
void Spawn();</span></pre>
<p><span class="koboSpan" id="kobo.380.1">The header is now finished. </span><span class="koboSpan" id="kobo.380.2">Now, let’s switch to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">.cpp</span></strong><span class="koboSpan" id="kobo.382.1"> and implement some </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">code logic.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">Implementing the </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">spawner logic</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">It’s time to implement the spawner </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.387.1">features. </span><span class="koboSpan" id="kobo.387.2">To do</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.388.1"> so, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">.cpp</span></strong><span class="koboSpan" id="kobo.390.1"> file, find the constructor, and add the required includes at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
#include "US_Minion.h"
#include "Components/BoxComponent.h"</span></pre>
<p><span class="koboSpan" id="kobo.393.1">Then, add the following piece </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.395.1">
SpawnArea = CreateDefaultSubobject&lt;UBoxComponent&gt;(TEXT("Spawn Area"));
SpawnArea-&gt;SetupAttachment(RootComponent);
SpawnArea-&gt;SetBoxExtent(FVector(1000.0f, 1000.0f, 100.0f));</span></pre>
<p><span class="koboSpan" id="kobo.396.1">You are already well versed in creating components, so let’s dive right into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">BeginPlay()</span></strong><span class="koboSpan" id="kobo.398.1"> method and add this code just after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">Super::BeginPlay()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.400.1"> declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.401.1">
if(SpawnableMinions.IsEmpty()) return;
if(GetLocalRole() != ROLE_Authority) return;
for (int32 i = 0; i &lt; NumMinionsAtStart; i++)
{
 Spawn();
}
GetWorldTimerManager().SetTimer(SpawnTimerHandle, this, &amp;AUS_MinionSpawner::Spawn, SpawnDelay, true, SpawnDelay);</span></pre>
<p><span class="koboSpan" id="kobo.402.1">First of all, we are checking that there is at least one spawnable minion type – if the array is empty, there is no need to go on with the code. </span><span class="koboSpan" id="kobo.402.2">Then, we check that the Actor has the authority to spawn something; as usual, we want the server to be in full control of </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">what’s happening.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">After that, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">Spawn()</span></strong><span class="koboSpan" id="kobo.406.1"> function in a loop, in order to create a starting pool of enemies. </span><span class="koboSpan" id="kobo.406.2">The last step is to create a timer, which will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">Spawn()</span></strong><span class="koboSpan" id="kobo.408.1"> function at an interval defined by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">SpawnDelay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.410.1"> value.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">The </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.412.1">last thing to do to have the spawner fully </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.413.1">functional is to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">Spawn()</span></strong><span class="koboSpan" id="kobo.415.1"> function implementation. </span><span class="koboSpan" id="kobo.415.2">Let’s add it at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
void AUS_MinionSpawner::Spawn()
{
 FActorSpawnParameters SpawnParams;
 SpawnParams.SpawnCollisionHandlingOverride =
 ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDont SpawnIfColliding;
 auto Minion =
  SpawnableMinions[FMath::RandRange(0, SpawnableMinions.Num() - 1)];
 const auto Rotation =
  FRotator(0.0f, FMath::RandRange(0.0f, 360.0f), 0.0f);
 const auto Location =
  SpawnArea-&gt;GetComponentLocation() +
   FVector(
    FMath::RandRange(-SpawnArea-&gt;GetScaledBoxExtent().X,SpawnArea-&gt;GetScaledBoxExtent().X),
    FMath::RandRange(-SpawnArea-&gt;GetScaledBoxExtent().Y, SpawnArea-&gt;GetScaledBoxExtent().Y),
    0.0f);
 GetWorld()-&gt;SpawnActor&lt;AUS_Minion&gt;(Minion, Location, Rotation, SpawnParams);
}</span></pre>
<p><span class="koboSpan" id="kobo.418.1">As</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.419.1"> long as it may seem, this code is quite straightforward, and you have already done something similar at the start of this book (do you remember the falling fruits?). </span><span class="koboSpan" id="kobo.419.2">We are just taking a random minion type from the array, retrieving a random location in the spawn area, and then we are going to spawn the minion at that location. </span><span class="koboSpan" id="kobo.419.3">The only thing worth mentioning is </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">SpawnCollisionHandlingOverride</span></strong><span class="koboSpan" id="kobo.421.1">, which is set to spawn the Actor, avoiding any collision with other </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.422.1">objects in </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">the level.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">As an extra exercise, you may add a limit to the number of minions that will be spawned from a single spawner object. </span><span class="koboSpan" id="kobo.424.2">This will avoid overcrowding your level and making the game unplayable for </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">your players!</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">The spawn Actor is ready, so it is time to compile your project and do some </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">proper testing.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.428.1">Testing the spawner</span></h2>
<p><span class="koboSpan" id="kobo.429.1">It is now time to </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.430.1">venture into </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.431.1">the glories of the Unreal Engine Editor and summon those mischievous minions to frolic throughout the level! </span><span class="koboSpan" id="kobo.431.2">Locate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">US_MinionSpawner</span></strong><span class="koboSpan" id="kobo.433.1"> class (found inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">C++ Classes</span></strong><span class="koboSpan" id="kobo.435.1"> |</span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1"> UnrealShadows_LOTL</span></strong><span class="koboSpan" id="kobo.437.1"> folder) and drag it into your level to create an instance </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Next, position the Actor in a suitable place and resize the </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">Box Extent</span></strong><span class="koboSpan" id="kobo.441.1"> parameters to set a nice size for the minions to be located within. </span><span class="koboSpan" id="kobo.441.2">In my case, I opted to place the spawner in the room labeled </span><strong class="bold"><span class="koboSpan" id="kobo.442.1">SP3</span></strong><span class="koboSpan" id="kobo.443.1"> with the </span><strong class="bold"><span class="koboSpan" id="kobo.444.1">Box Extent</span></strong><span class="koboSpan" id="kobo.445.1"> property set to </span><strong class="bold"><span class="koboSpan" id="kobo.446.1">(900, 400, 100)</span></strong><span class="koboSpan" id="kobo.447.1">, as you can see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.448.1">Figure 8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.449.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer124">
<span class="koboSpan" id="kobo.451.1"><img alt="Figure 8.3 – The spawn area" src="image/Figure_08_03_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.452.1">Figure 8.3 – The spawn area</span></p>
<p><span class="koboSpan" id="kobo.453.1">Then, with</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.454.1"> the</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.455.1"> Actor still selected, do </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.457.1">Locate the </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">Spawn System</span></strong><span class="koboSpan" id="kobo.459.1"> category in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.460.1">Details</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1"> panel.</span></span></li>
<li><span class="koboSpan" id="kobo.462.1">Add an element to the </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">Spawnable Minions</span></strong><span class="koboSpan" id="kobo.464.1"> array, which will be labeled as </span><strong class="bold"><span class="koboSpan" id="kobo.465.1">Index[0]</span></strong><span class="koboSpan" id="kobo.466.1">. </span><span class="koboSpan" id="kobo.466.2">From the corresponding drop-down menu, </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">select</span></span><span class="No-Break"> </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.468.1">US_Minion</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.470.1">Tweak </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">Spawn Delay</span></strong><span class="koboSpan" id="kobo.472.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.473.1">Num Minions at Start</span></strong><span class="koboSpan" id="kobo.474.1"> to suit your needs; in my case, I have left the default values, as you can see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.475.1">Figure 8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.476.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer125">
<span class="koboSpan" id="kobo.478.1"><img alt="Figure 8.4 – The spawn settings" src="image/Figure_08_04_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.479.1">Figure 8.4 – The spawn settings</span></p>
<p><span class="koboSpan" id="kobo.480.1">You obviously have the freedom to add as many spawner Actors as you feel necessary to balance your </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">game level.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">Once you enter the realm of play mode, lo and behold, the undead minions shall materialize before your very eyes, their replication and synchronization across all clients being a testament to the mystical powers of the Lichlord! </span><span class="koboSpan" id="kobo.482.2">Well, actually, it’s a testament to the power of the Unreal Engine replication system, but you don’t want to let your players in on the secret. </span><span class="koboSpan" id="kobo.482.3">Keep them in the dark and let them marvel at the seamless magic of your </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">game’s performance.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.484.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.485.1">.5</span></em><span class="koboSpan" id="kobo.486.1"> displays how the</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.487.1"> spawner looks in action whenever</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.488.1"> you test it, but more simply and </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">less poetically:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<span class="koboSpan" id="kobo.490.1"><img alt="Figure 8.5 – The spawner in action" src="image/Figure_08_05_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.491.1">Figure 8.5 – The spawner in action</span></p>
<p><span class="koboSpan" id="kobo.492.1">In this section, you created a fully customizable spawn system that can be used and tweaked for any level in your game. </span><span class="koboSpan" id="kobo.492.2">It’s time to wrap things up and move on to the next chapter of this adventure-packed </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">multiplayer game.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.494.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.495.1">In this chapter, you were introduced to the basics of AI in a multiplayer game. </span><span class="koboSpan" id="kobo.495.2">First of all, you were given some information on how to create a Navigation System that will let your AI move independently around the level. </span><span class="koboSpan" id="kobo.495.3">After that, you created a base minion, which will patrol around seeking the player characters, changing its behavior to a more aggressive stance once it finds them. </span><span class="koboSpan" id="kobo.495.4">As a last step, you added spawn points around the dungeon in order to populate the area with </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">worthy opponents.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">The most important thing to take away from this chapter is that, with your previously acquired knowledge, everything is correctly synchronized over the network. </span><span class="koboSpan" id="kobo.497.2">I promised you that learning things from the start would be a huge advantage in the future! </span><span class="koboSpan" id="kobo.497.3">And trust me, putting in the effort and really grasping the basics is now paying off with </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">your project!</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">In the next chapter, we’ll keep on exploring some of the possibilities of implementing worthy opponents for your hero – we will give it a sense of hearing and a health system in order to make it more engaging and, at the very </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">least, defeatable.</span></span></p>
</div>
</body></html>