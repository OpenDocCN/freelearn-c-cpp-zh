<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor162"/>8</h1>
<h1 id="_idParaDest-162"><a id="_idTextAnchor163"/>Introducing AI into a Multiplayer Environment</h1>
<p><strong class="bold">Artificial Intelligence</strong> (<strong class="bold">AI</strong>) systems<a id="_idIndexMarker438"/> offer an exciting and unique gaming experience for players by providing dynamic challenges that are unpredictable and engaging. This allows developers to create immersive worlds with realistic behavior <a id="_idIndexMarker439"/>from <strong class="bold">non-player </strong><strong class="bold">characters</strong> (<strong class="bold">NPCs</strong>).</p>
<p>In this chapter, I will introduce you to the basics of AI in Unreal Engine but, as this is a book about multiplayer games, I will not go deep into the details of the system – instead, you will take the first steps in the creation of opponents, which will make your game fully playable from a networked point of view.</p>
<p>By the end of the chapter, you will have created an enemy Actor that wanders around the level and actively pursues the player’s character once it is detected. This will serve as a starting point for creating more diverse and compelling enemies in your game.</p>
<p>So, in this chapter, I will present you with the following topics:</p>
<ul>
<li>Setting up the AI system</li>
<li>Creating an AI opponent</li>
<li>Adding opponents to the level</li>
</ul>
<h1 id="_idParaDest-163"><a id="_idTextAnchor164"/>Technical requirements</h1>
<p>To follow the topics presented in this chapter, you should have completed the previous ones and understood their content.</p>
<p>Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the <code>.zip</code> project files provided in this book’s accompanying project repository:</p>
<p><a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</a></p>
<p>You can download the files that are up to date with the end of the last chapter by clicking the <code>Unreal Shadows – </code><code>Chapter 07</code><code> </code><code>End</code> link.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Setting up the AI system</h1>
<p>Crafting an <a id="_idIndexMarker440"/>AI opponent in Unreal Engine can be quite a hard task. Luckily, this book is focused on boosting your multiplayer prowess, rather than getting bogged down in all the details of AI, so I will not go deep into the Unreal Engine AI system. However, if you want to make your game enjoyable, it definitely helps to have some know-how on creating a worthy AI opponent.</p>
<p>In order to make the AI character move around the level, you will need to define which areas are allowed and which are not (as an example, you will most definitely need to give the character a safe place that the opponents won’t dare to step into). Once we’ve done that, in the next steps, we will create these areas so that the AI system can manage the minions’ walking paths. Once we’ve done that, we’ll be well on our way to creating awesome, mindless, walking undead.</p>
<p>To make everything work properly, first of all, we need to give our minion opponents something to walk on. As you may already know, Unreal Engine uses a <strong class="bold">Navigation System</strong> to let <a id="_idIndexMarker441"/>AI Actors navigate a level using pathfinding algorithms.</p>
<p>The Navigation System takes the collision geometry in your level and generates a <strong class="bold">Navigation Mesh</strong>, which <a id="_idIndexMarker442"/>is then split into portions (i.e., polygon geometries) that are used to create a graph. This graph is <a id="_idIndexMarker443"/>what <strong class="bold">agents</strong> (such as AI characters) use to navigate to their destination. Each portion is given a cost, which agents then use to calculate the most efficient path (the one with the lowest overall cost). It’s like a smart GPS for your game characters!</p>
<p class="callout-heading">Note</p>
<p class="callout">If you want more information about the Unreal Engine Navigation System and its inner workings, you can visit the official Epic Games documentation at this link: <a href="https://docs.unrealengine.com/5.1/en-US/navigation-system-in-unreal-engine/">https://docs.unrealengine.com/5.1/en-US/navigation-system-in-unreal-engine/</a>.</p>
<p>To add a<a id="_idIndexMarker444"/> Navigation Mesh to the level, you will need to take the following steps:</p>
<ol>
<li>Open the game level you’ve been working on so far and, from the <strong class="bold">Quickly add to the project</strong> button, select <strong class="bold">NavMeshBoundsVolume</strong>. This will add the <strong class="bold">NavMeshBoundsVolume</strong> component to the level and a <strong class="bold">RecastNavMesh</strong> Actor.</li>
<li>In the <strong class="bold">Outliner</strong>, select <strong class="bold">NavMeshBoundsVolume</strong> and, with the <strong class="bold">Scale</strong> tool enabled, resize it so that it covers your desired portion of the level – avoid the spawn region for your player characters, as you want to give them a safe place to rest or escape to if needed.</li>
<li>Hit the <em class="italic">P</em> key on your keyboard to show the newly created Navigation Mesh, which should look <a id="_idIndexMarker445"/>similar to the one depicted in <em class="italic">Figure 8</em><em class="italic">.1</em>:</li>
</ol>
<div><div><img alt="Figure 8.1 – The Navigation Mesh area" src="img/Figure_08_01_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – The Navigation Mesh area</p>
<p>The green-colored area (i.e., the Navigation Mesh) represents the places where the AI character can walk. You will <a id="_idIndexMarker446"/>notice that walls and doors will create “holes” in this mesh, so the AI will be forbidden to step into it. Don’t worry about the portions outside of your dungeon – there are no open doors to connect them, so the minions won’t be able to reach them.</p>
<p>In this section, you were briefly introduced to the Unreal Engine Navigation System and you have set up a navigable area for the soon-to-be-created AI opponents. As I see you’re eager to start coding, let’s fire up your programming IDE and start writing some code together! It’s time to summon some undead minions and let them walk around the dungeon.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor166"/>Creating an AI opponent</h1>
<p>In this <a id="_idIndexMarker447"/>section, you’ll start by creating a class for your hero’s foes, complete with the basic ability to patrol and attack. Sure, they might not be the sharpest guys around, but hey, they’re the Lichlord’s undead minions – not exactly known for their intelligence, are they?</p>
<p>We’ll be starting by extending the Character class, which, as you may already know, can be controlled by an <code>AIController</code>, allowing independent actions during gameplay.</p>
<p>At this point, we want the minion to have the following features:</p>
<ul>
<li>A random patrolling movement around the level</li>
<li>A perception system that will allow it to see and hear the player’s character</li>
<li>The ability to seek out the player once it has been detected</li>
</ul>
<p>In the next chapters, we’ll extend the Character class further by adding some more features such as health and spawnable goodies (when the AI has been defeated) but for now, we’ll just focus on the movement and perception system.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor167"/>Adding the navigation module</h2>
<p>The first thing to do <a id="_idIndexMarker448"/>in order to have an agent that can navigate through a Navigation Mesh is to add the corresponding module to your project.</p>
<p>To do this, get back to your programming IDE and open your project build file – the one named <code>UnrealShadows_LOTL.Build.cs</code> (or similar, if you opted for a different project name). Locate the following line of code:</p>
<pre class="source-code">
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput" });</pre>
<p>Change it by adding the <code>NavigationSystem</code> declaration, like this:</p>
<pre class="source-code">
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "NavigationSystem" });</pre>
<p>With the project settings updated, we can start working on the minion AI, by creating a dedicated class.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor168"/>Creating the minion class</h2>
<p>It’s time to create the <a id="_idIndexMarker449"/>AI minion class, so create a new class derived from <code>Character</code> and name it <code>US_Minion</code>. Once the class has been created, open the <code>US_Minion.h</code> header file and, in the <code>private</code> section, add the following code:</p>
<pre class="source-code">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Minion Perception", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UPawnSensingComponent&gt; PawnSense;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Minion Perception", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class USphereComponent&gt; Collision;
UPROPERTY()
FVector PatrolLocation;</pre>
<p>The <code>Collision</code> property will be used as a trigger for the AI to grab the character, while <code>PatrolLocation</code> will be used to tell the AI where to go if not chasing the character.</p>
<p>The <code>PawnSense</code> property is the declaration for <code>PawnSensingComponent</code>, a component that can be used by the AI character to see and hear pawns around the level (i.e., the player characters). This component is quite straightforward to use and is easily configurable, letting you make the opponent more or less “dumb” during gameplay. You’ll get mere info on this in a minute or two when you’ll be initializing it.</p>
<p>Now it’s time to add some properties to the <code>public</code> section. Just add the following code:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Minion AI")
float PatrolSpeed = 150.0f;
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Minion AI")
float ChaseSpeed = 350.0f;
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category="Minion AI")
float PatrolRadius = 50000.0f;</pre>
<p>We have defined <a id="_idIndexMarker450"/>two movement speed properties: <code>PatrolSpeed</code> will be used when the minion is walking around aimlessly, while <code>ChaseSpeed</code> will be used whenever the minion is seeking the character, in order to make it a new pawn for the Lichlord’s army! The <code>PatrolRadius</code> property will be used to find a new location in the level for the minion to inspect.</p>
<p>After the properties, you will be declaring the public methods needed for the correct behavior of the AI opponent. Still in the <code>public</code> section, add this block of code to declare them:</p>
<pre class="source-code">
UFUNCTION(BlueprintCallable, Category="Minion AI")
void SetNextPatrolLocation();
UFUNCTION(BlueprintCallable, Category="Minion AI")
void Chase(APawn* Pawn);
virtual void PostInitializeComponents() override;
FORCEINLINE UPawnSensingComponent* GetPawnSense() const { return PawnSense; }
FORCEINLINE USphereComponent* GetCollision() const { return Collision; }</pre>
<p>The <code>SetNextPatrolLocation()</code> and <code>Chase()</code> methods will be used to let the AI character move around the scene, looking for a new spot or seeking the player character. The <code>PostInitializeComponent()</code> override will be used to register the character events. Lastly, we are declaring the usual getters for the character components that have been added.</p>
<p>The last step in the<a id="_idIndexMarker451"/> header declaration is to add the event handlers for this character:</p>
<pre class="source-code">
UFUNCTION()
void OnPawnDetected(APawn* Pawn);
UFUNCTION()
void OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor);</pre>
<p>The first one will manage the minion logic once it has detected a pawn with its senses, while the second one will be used to check whether a player character has been captured.</p>
<p>The header has<a id="_idIndexMarker452"/> finally been declared – please note that, at the moment, we are not taking into consideration the hearing capabilities of the minion; this is something we are going to implement in the next chapter when our thief hero starts to make some noise!</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor169"/>Implementing the minions’ behaviors</h2>
<p>You’ve<a id="_idIndexMarker453"/> declared all your functions and properties, so now it’s time to put them to good use by implementing some behaviors for your AI minions. Let’s make sure everything is running smoothly and get this project rolling!</p>
<p>Open the <code>US_Minion.cpp</code> file and add the following <code>include</code> statements at the top:</p>
<pre class="source-code">
#include "AIController.h"
#include "NavigationSystem.h"
#include "US_Character.h"
#include "Components/CapsuleComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Perception/PawnSensingComponent.h"
#include "Blueprint/AIBlueprintHelperLibrary.h"
#include "Components/SphereComponent.h"</pre>
<p>As usual, these lines of code will declare the classes we will use from now on. After you have done that, it’s time to implement the constructor by adding the needed components and initializing all the properties.</p>
<h3>Declaring the constructor</h3>
<p>Once the <code>include</code> statements have been<a id="_idIndexMarker454"/> properly declared, you can start by locating the <code>AUS_Minion()</code> constructor and inserting the character initialization. Inside the brackets, just after the <code>PrimaryActorTick.bCanEverTick</code> declaration, add the following <a id="_idIndexMarker455"/>code:</p>
<pre class="source-code">
bUseControllerRotationPitch = false;
bUseControllerRotationYaw = false;
bUseControllerRotationRoll = false;
AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned;
AIControllerClass = AAIController::StaticClass();
PawnSense = CreateDefaultSubobject&lt;UPawnSensingComponent&gt;(TEXT("PawnSense"));
PawnSense-&gt;SensingInterval = .8f;
PawnSense-&gt;SetPeripheralVisionAngle(45.f);
PawnSense-&gt;SightRadius = 1500.f;
PawnSense-&gt;HearingThreshold = 400.f;
PawnSense-&gt;LOSHearingThreshold = 800.f;
Collision = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT("Collision"));
Collision-&gt;SetSphereRadius(100);
Collision-&gt;SetupAttachment(RootComponent);
GetCapsuleComponent()-&gt;InitCapsuleSize(60.f, 96.0f);
GetCapsuleComponent()-&gt;SetGenerateOverlapEvents(true);
GetMesh()-&gt;SetRelativeLocation(FVector(0.f, 0.f, -91.f));
static ConstructorHelpers::FObjectFinder&lt;USkeletalMesh&gt; SkeletalMeshAsset(TEXT("/Game/KayKit/Skeletons/skeleton_minion"));
if (SkeletalMeshAsset.Succeeded())
{
 GetMesh()-&gt;SetSkeletalMesh(SkeletalMeshAsset.Object);
}
GetCharacterMovement()-&gt;bOrientRotationToMovement = true;
GetCharacterMovement()-&gt;RotationRate = FRotator(0.0f, 500.0f, 0.0f);
GetCharacterMovement()-&gt;MaxWalkSpeed = 200.f;
GetCharacterMovement()-&gt;MinAnalogWalkSpeed = 20.f;
GetCharacterMovement()-&gt;BrakingDecelerationWalking = 2000.f;</pre>
<p>You’ll already be familiar with most of the code from the thief character creation, but you will see some noticeable additions. First of all, we are setting the <code>AutoPossessAI</code> property, which lets us define whether the game system will possess the AI character once in the level – we want it to be both in full control when it is spawned at runtime and when it is already in the level when the game starts, so we have opted for a value of <code>PlacedInWorldOrSpawned</code>.</p>
<p>Then, we <a id="_idIndexMarker456"/>define which controller will be used for the AI system by setting the <code>AIControllerClass</code> property; in this case, we are just using the base <code>AAIController</code> class, but you can obviously implement your own with additional features.</p>
<p>The last notable thing is the <code>PawnSense</code> component creation – as you can see, we are initializing the properties that will make the minion see and hear at a certain distance. You should take note of the <code>SensingInterval</code> initialization, which will let us tweak how much <a id="_idIndexMarker457"/>time will pass between two sense perceptions. This will make the difference between a very reactive character (i.e., a lower value) or a really dumb one (i.e., a higher one).</p>
<h3>Initializing the minion</h3>
<p>It’s now time to <a id="_idIndexMarker458"/>initialize the character when it is added to the game. As you already know, this is usually done from the <code>BeginPlay()</code> method. So, just after the <code>Super::BeginPlay()</code> declaration, add the following:</p>
<pre class="source-code">
SetNextPatrolLocation();</pre>
<p>This call will simply start the patrolling behavior. Then, add the <code>PostInitializeComponents()</code> implementation by adding this code to the file:</p>
<pre class="source-code">
void AUS_Minion::PostInitializeComponents()
{
 Super::PostInitializeComponents();
if(GetLocalRole() != ROLE_Authority) return;
 OnActorBeginOverlap.AddDynamic(this, &amp;AUS_Minion::OnBeginOverlap);
 GetPawnSense()-&gt;OnSeePawn.AddDynamic(this, &amp;AUS_Minion::OnPawnDetected);
}</pre>
<p>As you can see, we are using two delegates to react to an Actor overlap, for checking whether we have reached the player character, and to handle the pawn perception to check whether we can see the player character. Also, notice that they are initialized only if the role of this object is authoritative (i.e., the method is being executed on the server).</p>
<p>The next step is to <a id="_idIndexMarker459"/>implement these two delegate functions in order to manage the aforementioned events.</p>
<h3>Handling the delegate functions</h3>
<p>Whenever the <a id="_idIndexMarker460"/>minion detects a pawn, it will immediately check whether it is a character and, if the result is successful, it will start chasing it. Let’s add the method to handle the delegate in the source file:</p>
<pre class="source-code">
void AUS_Minion::OnPawnDetected(APawn* Pawn)
{
 if (!Pawn-&gt;IsA&lt;AUS_Character&gt;()) return;
 GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT("Character detected!"));
 if (GetCharacterMovement()-&gt;MaxWalkSpeed != ChaseSpeed)
 {
  Chase(Pawn);
 }
}</pre>
<p>The code here is quite straightforward – we just have added a debug message stating that a character has been detected.</p>
<p>The second delegate we need to handle is the overlap, so add the following method implementation:</p>
<pre class="source-code">
void AUS_Minion::OnBeginOverlap(AActor* OverlappedActor, AActor* OtherActor)
{
 if (!OtherActor-&gt;IsA&lt;AUS_Character&gt;()) return;
 GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::Yellow, TEXT("Character captured!"));
}</pre>
<p>As you can see, we check again whether we have found a character, and after that, we simply display a debug message – it looks like our hero got a little too close to the minions and now they’ve roped them into joining the Lichlord’s undead army! Later on, you’ll implement a <a id="_idIndexMarker461"/>respawn system to let the player restart the game with a brand-new character.</p>
<p>The next step will be the actual AI’s movement through the Navigation Mesh, both for the patrol and chase behaviors.</p>
<h3>Implementing the chase and patrol behaviors</h3>
<p>It’s now time to <a id="_idIndexMarker462"/>start implementing the movement control for your AI character – specifically, you’ll be implementing the <code>SetNextPatrolLocation()</code> function, which will find a new reachable point for the minion, and the <code>Chase()</code> function, which will send the minion on a “seek and destroy” mission toward the character. To do so, add the following code to the file:</p>
<pre class="source-code">
void AUS_Minion::SetNextPatrolLocation()
{
 if(GetLocalRole() != ROLE_Authority) return;
 GetCharacterMovement()-&gt;MaxWalkSpeed = PatrolSpeed;
 const auto LocationFound = UNavigationSystemV1::K2_GetRandomReachablePointInRadius(
     this, GetActorLocation(), PatrolLocation, PatrolRadius);
 if(LocationFound)
 {
  UAIBlueprintHelperLibrary::SimpleMoveToLocation(GetController(), PatrolLocation);
 }
}
void AUS_Minion::Chase(APawn* Pawn)
{
 if(GetLocalRole() != ROLE_Authority) return;
 GetCharacterMovement()-&gt;MaxWalkSpeed = ChaseSpeed;
 UAIBlueprintHelperLibrary::SimpleMoveToActor(GetController(), Pawn);
 DrawDebugSphere(GetWorld(), Pawn-&gt;GetActorLocation(), 25.f, 12, FColor::Red, true, 10.f, 0, 2.f);
}</pre>
<p>The first function sets the character speed to the patrolling value and uses the <code>UNavigationSystemV1::K2_GetRandomReachablePointInRadius()</code> method to find a reachable point in the Navigation Mesh. Then, the AI is simply commanded to reach that location.</p>
<p>The second <a id="_idIndexMarker463"/>function does something similar, but the target point will be the character – after all, it is on a mission from the Lichlord to get as many soon-to-be undead heroes as possible!</p>
<h3>Implementing the Tick() event</h3>
<p>The last <a id="_idIndexMarker464"/>thing you need to implement in order to make the patrolling system fully operational is to check whether the AI character has reached its destination; in this case, it will just have to find another point in the Navigation Mesh. As we need to continuously check the distance between the AI and the target point, the best place to write the code is within the <code>Tick()</code> event. Let’s find the method and, just after the <code>Super::Tick(DeltaTime)</code> call, add this piece of code:</p>
<pre class="source-code">
if(GetLocalRole() != ROLE_Authority) return;
if(GetMovementComponent()-&gt;GetMaxSpeed() == ChaseSpeed) return;
if((GetActorLocation() - PatrolLocation).Size() &lt; 500.f)
{
 SetNextPatrolLocation();
}</pre>
<p>As you can see, the first line checks whether the character is patrolling (i.e., the maximum speed should not equal the chase speed). Then, we are checking that we are near enough (about half a meter) to the patrol location in order to look for another reachable point.</p>
<h3>Testing the AI opponent</h3>
<p>Now<a id="_idIndexMarker465"/> that the enemy AI has been created, you can test it out in the game level. To do this, open the Unreal Engine Editor and, from the Content Browser, drag an instance of the <code>US_Minion</code> class (located in the <code>C++ Classes</code> | <code>UnrealShadows_LOTL</code> folder) into the level. You should see something similar to <em class="italic">Figure 8</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 8.2 – The AI opponent in the level" src="img/Figure_08_02_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The AI opponent in the level</p>
<p>The gizmos around the character represent the <code>PawnSense</code> component – its sight and hearing capabilities. The sight area is represented by a green cone that shows how wide and far the AI can see. The hearing sense is represented by two spheres – a yellow one that shows how far the AI will hear a noise if it is not obstructed by any obstacle, and a cyan one that shows how far the AI will sense noise, even if generated behind an obstacle, such as a wall.</p>
<p>Go into play mode and the opponent should start wandering around the level and over the Navigation Mesh. Whenever a player character enters the minion’s line of sight (i.e., the green cone), the enemy will react and start chasing the player at a higher speed.</p>
<p>Once the character has been reached, you will notice that the minion will stop moving – its mission has been completed and it can rest!</p>
<p>As an extra exercise, you may want to add a timer that will check whether the AI is staying still for too long; in that case, it will restart its patrolling system by looking for a new reachable<a id="_idIndexMarker466"/> location.</p>
<p>So, in this section, you have created your AI opponent, ready to roam around the dungeon, seeking its next victim. You have created a simple but effective patrolling system and added a perception sense to the AI so that it can intercept the player when they are not stealthy enough.</p>
<p>In the next section, you’ll create a spawning system in order to add minions as the game progresses and make things more challenging for the players.</p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor170"/>Adding opponents to the level</h1>
<p>Now that you <a id="_idIndexMarker467"/>have an opponent for your thief hero, it is time to let the system spawn a bunch of them at runtime. You’ll be doing this by implementing a spawn system similar to the one used in <a href="B18203_03.xhtml#_idTextAnchor065"><em class="italic">Chapter 3</em></a>, <em class="italic">Testing the Multiplayer System with a Project Prototype</em> – this time, you’ll create the spawner in C++ instead.</p>
<p>What we want to implement here is an Actor that will have the following features:</p>
<ul>
<li>Spawns a few minions at the start of the game.</li>
<li>Spawns new minions at predefined intervals.</li>
<li>Spawns the minions in a selected area.</li>
<li>Randomly selects a minion type every time it spawns. At the moment, we have just one minion type, but in the following chapters, we will add more variations.</li>
</ul>
<p>Let’s get started.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor171"/>Creating a spawner class</h2>
<p>Start by creating a C++ class that <a id="_idIndexMarker468"/>extends from Actor and <a id="_idIndexMarker469"/>name it <code>US_MinionSpawner</code>. Once created, open the <code>.h</code> file and, in the <code>private</code> section, add the following declarations:</p>
<pre class="source-code">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Spawn System", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UBoxComponent&gt; SpawnArea;
UPROPERTY()
FTimerHandle SpawnTimerHandle;</pre>
<p>You should be already familiar with the first declaration from <a href="B18203_03.xhtml#_idTextAnchor065"><em class="italic">Chapter 3</em></a>, <em class="italic">Testing the Multiplayer System with a Project Prototype</em> – we are declaring an area that will be used to randomize the spawned minion location. The second declaration will be used to store a reference of the timer handler used by the spawner to generate new minions at predefined intervals.</p>
<p>Now we are going to declare some properties that will make this class customizable in the level. In the <code>public</code> section, add the following property declarations:</p>
<pre class="source-code">
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Spawn System")
TArray&lt;TSubclassOf&lt;class AUS_Minion&gt;&gt; SpawnableMinions;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Spawn System")
float SpawnDelay = 10.0f;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="Spawn System")
int32 NumMinionsAtStart = 5;</pre>
<p>The first property <a id="_idIndexMarker470"/>will expose an array that will contain all the spawnable minion types. As stated before, at the moment, we have just one type, but we will add some more later on. The other two properties are self-explanatory, letting <a id="_idIndexMarker471"/>us define the spawn timing and how many minions should already be in the level when the game starts.</p>
<p>The last step is to add a <code>Spawn()</code> method in the protected section of the header:</p>
<pre class="source-code">
UFUNCTION()
void Spawn();</pre>
<p>The header is now finished. Now, let’s switch to the <code>.cpp</code> and implement some code logic.</p>
<p>Implementing the spawner logic</p>
<p>It’s time to implement the spawner <a id="_idIndexMarker472"/>features. To do<a id="_idIndexMarker473"/> so, open the <code>.cpp</code> file, find the constructor, and add the required includes at the top of the file:</p>
<pre class="source-code">
#include "US_Minion.h"
#include "Components/BoxComponent.h"</pre>
<p>Then, add the following piece of code:</p>
<pre class="source-code">
SpawnArea = CreateDefaultSubobject&lt;UBoxComponent&gt;(TEXT("Spawn Area"));
SpawnArea-&gt;SetupAttachment(RootComponent);
SpawnArea-&gt;SetBoxExtent(FVector(1000.0f, 1000.0f, 100.0f));</pre>
<p>You are already well versed in creating components, so let’s dive right into the <code>BeginPlay()</code> method and add this code just after the <code>Super::BeginPlay()</code> declaration:</p>
<pre class="source-code">
if(SpawnableMinions.IsEmpty()) return;
if(GetLocalRole() != ROLE_Authority) return;
for (int32 i = 0; i &lt; NumMinionsAtStart; i++)
{
 Spawn();
}
GetWorldTimerManager().SetTimer(SpawnTimerHandle, this, &amp;AUS_MinionSpawner::Spawn, SpawnDelay, true, SpawnDelay);</pre>
<p>First of all, we are checking that there is at least one spawnable minion type – if the array is empty, there is no need to go on with the code. Then, we check that the Actor has the authority to spawn something; as usual, we want the server to be in full control of what’s happening.</p>
<p>After that, we call the <code>Spawn()</code> function in a loop, in order to create a starting pool of enemies. The last step is to create a timer, which will call the <code>Spawn()</code> function at an interval defined by the <code>SpawnDelay</code> value.</p>
<p>The <a id="_idIndexMarker474"/>last thing to do to have the spawner fully <a id="_idIndexMarker475"/>functional is to add the <code>Spawn()</code> function implementation. Let’s add it at the end of the file:</p>
<pre class="source-code">
void AUS_MinionSpawner::Spawn()
{
 FActorSpawnParameters SpawnParams;
 SpawnParams.SpawnCollisionHandlingOverride =
 ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDont SpawnIfColliding;
 auto Minion =
  SpawnableMinions[FMath::RandRange(0, SpawnableMinions.Num() - 1)];
 const auto Rotation =
  FRotator(0.0f, FMath::RandRange(0.0f, 360.0f), 0.0f);
 const auto Location =
  SpawnArea-&gt;GetComponentLocation() +
   FVector(
    FMath::RandRange(-SpawnArea-&gt;GetScaledBoxExtent().X,SpawnArea-&gt;GetScaledBoxExtent().X),
    FMath::RandRange(-SpawnArea-&gt;GetScaledBoxExtent().Y, SpawnArea-&gt;GetScaledBoxExtent().Y),
    0.0f);
 GetWorld()-&gt;SpawnActor&lt;AUS_Minion&gt;(Minion, Location, Rotation, SpawnParams);
}</pre>
<p>As<a id="_idIndexMarker476"/> long as it may seem, this code is quite straightforward, and you have already done something similar at the start of this book (do you remember the falling fruits?). We are just taking a random minion type from the array, retrieving a random location in the spawn area, and then we are going to spawn the minion at that location. The only thing worth mentioning is <code>SpawnCollisionHandlingOverride</code>, which is set to spawn the Actor, avoiding any collision with other <a id="_idIndexMarker477"/>objects in the level.</p>
<p>As an extra exercise, you may add a limit to the number of minions that will be spawned from a single spawner object. This will avoid overcrowding your level and making the game unplayable for your players!</p>
<p>The spawn Actor is ready, so it is time to compile your project and do some proper testing.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/>Testing the spawner</h2>
<p>It is now time to <a id="_idIndexMarker478"/>venture into <a id="_idIndexMarker479"/>the glories of the Unreal Engine Editor and summon those mischievous minions to frolic throughout the level! Locate the <code>US_MinionSpawner</code> class (found inside the <code>C++ Classes</code> |<code> UnrealShadows_LOTL</code> folder) and drag it into your level to create an instance of it.</p>
<p>Next, position the Actor in a suitable place and resize the <strong class="bold">Box Extent</strong> parameters to set a nice size for the minions to be located within. In my case, I opted to place the spawner in the room labeled <strong class="bold">SP3</strong> with the <strong class="bold">Box Extent</strong> property set to <strong class="bold">(900, 400, 100)</strong>, as you can see in <em class="italic">Figure 8</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 8.3 – The spawn area" src="img/Figure_08_03_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The spawn area</p>
<p>Then, with<a id="_idIndexMarker480"/> the<a id="_idIndexMarker481"/> Actor still selected, do the following:</p>
<ol>
<li>Locate the <strong class="bold">Spawn System</strong> category in the <strong class="bold">Details</strong> panel.</li>
<li>Add an element to the <strong class="bold">Spawnable Minions</strong> array, which will be labeled as <strong class="bold">Index[0]</strong>. From the corresponding drop-down menu, select <strong class="bold">US_Minion</strong>.</li>
<li>Tweak <strong class="bold">Spawn Delay</strong> and <strong class="bold">Num Minions at Start</strong> to suit your needs; in my case, I have left the default values, as you can see in <em class="italic">Figure 8</em><em class="italic">.4</em>:</li>
</ol>
<div><div><img alt="Figure 8.4 – The spawn settings" src="img/Figure_08_04_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The spawn settings</p>
<p>You obviously have the freedom to add as many spawner Actors as you feel necessary to balance your game level.</p>
<p>Once you enter the realm of play mode, lo and behold, the undead minions shall materialize before your very eyes, their replication and synchronization across all clients being a testament to the mystical powers of the Lichlord! Well, actually, it’s a testament to the power of the Unreal Engine replication system, but you don’t want to let your players in on the secret. Keep them in the dark and let them marvel at the seamless magic of your game’s performance.</p>
<p><em class="italic">Figure 8</em><em class="italic">.5</em> displays how the<a id="_idIndexMarker482"/> spawner looks in action whenever<a id="_idIndexMarker483"/> you test it, but more simply and less poetically:</p>
<div><div><img alt="Figure 8.5 – The spawner in action" src="img/Figure_08_05_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – The spawner in action</p>
<p>In this section, you created a fully customizable spawn system that can be used and tweaked for any level in your game. It’s time to wrap things up and move on to the next chapter of this adventure-packed multiplayer game.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor173"/>Summary</h1>
<p>In this chapter, you were introduced to the basics of AI in a multiplayer game. First of all, you were given some information on how to create a Navigation System that will let your AI move independently around the level. After that, you created a base minion, which will patrol around seeking the player characters, changing its behavior to a more aggressive stance once it finds them. As a last step, you added spawn points around the dungeon in order to populate the area with worthy opponents.</p>
<p>The most important thing to take away from this chapter is that, with your previously acquired knowledge, everything is correctly synchronized over the network. I promised you that learning things from the start would be a huge advantage in the future! And trust me, putting in the effort and really grasping the basics is now paying off with your project!</p>
<p>In the next chapter, we’ll keep on exploring some of the possibilities of implementing worthy opponents for your hero – we will give it a sense of hearing and a health system in order to make it more engaging and, at the very least, defeatable.</p>
</div>
</body></html>