- en: '*Chapter 2*: General STL Features'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a general potpourri of STL features and techniques. These are
    mostly new features introduced over the past few years, which may not yet be widely
    used. These are useful techniques that will improve the simplicity and readability
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the new `span` class to make your C-arrays safer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use structured binding to return multiple values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize variables within `if` and `switch` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use template argument deduction for simplicity and clarity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `if constexpr` to simplify compile-time decisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap02](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap02).
  prefs: []
  type: TYPE_NORMAL
- en: Use the new span class to make your C-arrays safer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: New for C++20, the `std::span` class is a simple wrapper that creates a view
    over a contiguous sequence of objects. The `span` doesn't own any of its own data,
    it refers to the data in the underlying structure. Think of it as `string_view`
    for C-arrays. The underlying structure may be a *C-array*, a `vector`, or an STL
    `array`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create a span from any compatible contiguous-storage structure. The
    most common use case will involve a C-array. For example, if you try to pass a
    C-array directly to a function, the array is demoted to a pointer and the function
    has no easy way to know the size of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you define your function with a `span` parameter, you can pass it a C-array
    and it will be promoted to `span`. Here''s a template function that takes a `span`
    and prints out the size in elements and in bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass a C-array to this function and it''s automatically promoted to
    `span`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of `span` is to encapsulate the raw data to provide a measure of
    safety and utility, with a minimum of overhead.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `span` class itself doesn't own any data. The data belongs to the underlying
    data structure. The `span` is essentially a view over the underlying data. It
    also provides some useful member functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defined in the `<span>` header, the `span` class looks something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Extent` parameter is a constant of type `constexpr size_t`, which is computed
    at compile time. It''s either the number of elements in the underlying data or
    the `std:: dynamic_extent` constant, which indicates that the size is variable.
    This allows `span` to use an underlying structure like a `vector`, which may not
    always be the same size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All member functions are `constexpr` and `const` qualified. Member functions
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18267_02_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `span` class is but a simple wrapper that performs no bounds checking. So,
    if you try to access element *n*+1 in a `span` of *n* elements, the result is
    *undefined*, which is tech for, "Bad. Don't do that."
  prefs: []
  type: TYPE_NORMAL
- en: Use structured binding to return multiple values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Structured binding* makes it easy to unpack the values of a structure into
    separate variables, improving the readability of your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With structured binding you can directly assign the member values to variables
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Structured binding* works with `pair`, `tuple`, `array`, and `struct`. Beginning
    with C++20, this includes bit-fields. This example uses a C-array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because the structured binding uses *automatic type deduction*, its type must
    be `auto`. The names of the individual variables are within the square brackets,
    `[ a, b, c, d, e ]`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example the `int` C-array `nums` holds five values. These five values
    are assigned to the variables (`a`, `b`, `c`, `d`, and `e`) using *structured
    binding*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also works with an STL `array` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use it with a `tuple`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use it with a `struct` it will take the variables in the order they''re
    defined:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a reference with a structured binding, which allows you to modify
    the values in the bound container, while avoiding duplication of the data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Because the variables are bound as a reference, you can assign a value to `c`
    and it will change the value in the array as well (`nums[2]`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare the array `const` to prevent values from being changed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or you can declare the binding `const` for the same effect, while allowing
    the array to be changed elsewhere and still avoid copying data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Structured binding uses *automatic type deduction* to unpack the structure into
    your variables. It determines the type of each value independently, and assigns
    a corresponding type to each variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because structured binding uses automatic type deduction, you cannot specify
    a type for the binding. You must use `auto`. You should get a reasonable error
    message if you try to use a type for the binding:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Above is the error from GCC when I try to use `int` with the structured binding
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s common to use structured binding for a return type from a function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `map` container classes return a pair for each element, it can
    be convenient to use structured binding to retrieve key/value pairs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using structured binding to unpack structures should make your code clearer
    and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize variables within if and switch statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beginning with C++17, `if` and `switch` now have initialization syntax, much
    like the `for` loop has had since C99\. This allows you to limit the scope of
    variables used within the condition.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may be accustomed to code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This leaves the variable `pos` exposed outside the scope of the conditional
    statement, where it needs to be managed, or it can collide with other attempts
    to use the same symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can put the initialization expression inside the `if` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now the scope of the `pos` variable is confined to the scope of the conditional.
    This keeps your namespace clean and manageable.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The initializer expression can be used in either `if` or `switch` statements.
    Here are some examples of each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use an initializer expression with an `if` statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The variable defined in the initializer expression is visible within the scope
    of the entire `if` statement, including the `else` clause. Once control flows
    out of the `if` statement scope, the variable will no longer be visible, and any
    relevant destructors will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use an initializer expression with a `switch` statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The variable defined in the initializer expression is visible within the scope
    of the entire `switch` statement, including all the `case` clauses and the `default`
    clause, if included. Once control flows out of the `switch` statement scope, the
    variable will no longer be visible, and any relevant destructors will be called.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One interesting use case is to limit the scope of a `lock_guard` that''s locking
    a mutex. This becomes simple with an initializer expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `lock_guard` locks the mutex in its constructor and unlocks it in its destructor.
    Now the `lock_guard` will be automatically destroyed when it runs out of the scope
    of the `if` statement. In the past you would have had to delete it or enclose
    the whole `if` statement in an extra block of braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use case could be using a legacy interface that uses output parameters,
    like this one from SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here I can keep the statement handle and the error code localized to the scope
    of the `if` statement. Otherwise, I would need to manage those objects globally.
  prefs: []
  type: TYPE_NORMAL
- en: Using initializer expressions will help keep your code tight and uncluttered,
    more compact, and easier to read. Refactoring and managing your code will also
    become easier.
  prefs: []
  type: TYPE_NORMAL
- en: Use template argument deduction for simplicity and clarity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template argument deduction occurs when the *types* of the arguments to a template
    function, or class template constructor (beginning with C++17), are clear enough
    to be understood by the compiler without the use of template arguments. There
    are certain rules to this feature, but it's mostly intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, template argument deduction happens automatically when you use a
    template with clearly compatible arguments. Let's consider some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a function template, argument deduction usually looks something like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Because the types are easily discernable there is no reason to specify a template
    parameter like `f<int>(47)` in the function call. The compiler can deduce the
    `<int>` type from the argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The above output shows meaningful type names where most compilers will use shorthand,
    like `i` for `int` and `PKc` for `const char *`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works just as well for multiple template parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here the compiler is deducing types for both `T1` and `T2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the types must be compatible with the template. For example, you
    cannot take a reference from a literal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Beginning with C++17 you can also use template parameter deduction with classes.
    So now this will work:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This eliminates the need for `std::make_pair()` and `std::make_tuple()` as you
    can now initialize these classes directly without the explicit template parameters.
    The `std::make_*` helper functions will remain available for backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a class so we can see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is a template class with three types and three corresponding data members.
    It has a `print()` function, which returns a formatted string with the three type
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without template parameter deduction, I would have to instantiate an object
    of this type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is both simpler and less error prone.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I call the `print()` function on the `thing1` object, I get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Of course, your compiler may report something effectively similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before C++17, template parameter deduction didn''t apply to classes, so you
    needed a helper function, which may have looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The STL includes a few of these helper functions, like `make_pair()` and `make_tuple()`,
    etc. These are now obsolescent, but will be maintained for compatibility with
    older code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the case of a constructor with a parameter pack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice the *fold expression* in the constructor `(values + ...)`. This is a
    C++17 feature that applies an operator to all the members of a parameter pack.
    In this case, it initializes `v` to the sum of the parameter pack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor for this class accepts an arbitrary number of parameters, where
    each parameter may be a different class. For example, I could call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This, of course, doesn''t compile. The template argument deduction fails to
    find a common type for all those different parameters. We get an error message
    to the effect of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix this with a *template deduction guide*. A deduction guide is a helper
    pattern to assist the compiler with a complex deduction. Here''s a guide for our
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the compiler to use the `std::common_type_t` trait, which attempts
    to find a common type for all the parameters in the pack. Now our argument deduction
    works and we can see what types it settled on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Use if constexpr to simplify compile-time decisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `if constexpr(`*condition*`)` statement is used where code needs to be executed
    based on a compile-time condition. The *condition* may be any `constexpr` expression
    of type `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the case where you have a template function that needs to operate differently
    depending upon the type of the template parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The type of the template parameter `T` is available at compile time. The `constexpr
    if` statement allows the code to easily distinguish between a pointer and a value.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `constexpr if` statement works like a normal `if` statement except it''s
    evaluated at *compile time*. The *runtime code* will not contain any branch statements
    from a `constexpr if` statement. Consider our branch statement from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The condition `is_pointer_v<T>` tests a template parameter, which is not available
    at runtime. The `constexpr` keyword tells the compiler that this `if` statement
    needs to evaluate at compile time, while the template parameter `<T>` is available.
  prefs: []
  type: TYPE_NORMAL
- en: This should make a lot of meta programming situations much easier. The `if constexpr`
    statement is available in C++17 and later.
  prefs: []
  type: TYPE_NORMAL
