["```cpp\nM5Object* pUfo = M5ObjectManager::CreateObject(AT_Ufo); \npUfo->pos.x    = M5Random::GetFloat(-100, 100); \npUfo->pos.y    = M5Random::GetFloat(-60, 60); \n\n```", "```cpp\nM5Object* pUfo = M5ObjectManager::CreateObject(AT_Ufo); \npUfo->pos.x    = M5Random::GetFloat(minWorldX, maxWorldX); \npUfo->pos.y    = M5Random::GetFloat(minWorldY, MaxWorldY); \n\n```", "```cpp\nint buffer[256]; \n\n//Some function to give start values \nInitializeBuffer(buffer, 256);  \n\nfor(int i = 0; i < 256; ++i) \nstd::cout << i \" \" << std::endl; \n\n```", "```cpp\nconst int BUFFER_SIZE = 256;  \nint buffer[BUFFER_SIZE]; \n\n//Some function to give start values \nInitializeBuffer(buffer, BUFFER_SIZE);  \n\nfor(int i = 0; i < BUFFER_SIZE; ++i) \nstd::cout << i \" \" << std::endl; \n\n```", "```cpp\nint bufferSize = GetSizeFromFile(fileName);  \n\n//we can Dynamically allocate our buffer \nint* buffer = new int[bufferSize]; \n\n//Some function to give start values \nInitializeBuffer(buffer, bufferSize);  \n\nfor(int i = 0; i < bufferSize; ++i) \nstd::cout << i \" \" << std::endl; \n\ndelete [] buffer;//We must remember to deallocate \n\n```", "```cpp\nRECT rect={0}; \nint xStart= 0,yStart = 0; \nrect.right=s_width;rect.bottom=s_height; \ns_isFullScreen = fullScreen; \nif (fullScreen) {DEVMODE settings;  \nsettings.dmSize = sizeof(settings); \nEnumDisplaySettings(0, ENUM_CURRENT_SETTINGS, &settings); \nsettings.dmPelsWidth=(DWORD)s_width;  \nsettings.dmPelsHeight = (DWORD)s_height; \nsettings.dmFields = DM_BITSPERPEL|DM_PELSWIDTH|DM_PELSHEIGHT; \ns_style = FULLSCREEN_STYLE; \nif (ChangeDisplaySettings(&settings \n,CDS_FULLSCREEN) !=DISP_CHANGE_SUCCESSFUL) { \ns_isFullScreen = false;s_style = WINDOWED_STYLE; \nChangeDisplaySettings(0, 0);M5Debug::MessagePopup( \n\"FullScreen is not supported. \" \n\"You are being switched to Windowed Mode\"); }  \n} \n else {ChangeDisplaySettings(0, 0); s_style = WINDOWED_STYLE;} \n\n```", "```cpp\n/*Set window rect size and start position*/ \nRECT rect   = { 0 }; \nrect.right  = s_width; \nrect.bottom = s_height; \nint xStart  = 0; \nint yStart  = 0; \n\n/*save input parameter to static var*/ \ns_isFullScreen = fullScreen; \n\n/*Check if we are going into full screen or not*/ \nif (fullScreen) \n{ \n  /*Get the current display settings*/ \n  DEVMODE settings; \n  settings.dmSize = sizeof(settings); \n  EnumDisplaySettings(0, ENUM_CURRENT_SETTINGS, &settings); \n\n  /*Change the resolution to the resolution of my window*/ \n  settings.dmPelsWidth  = static_cast<DWORD>(s_width); \n  settings.dmPelsHeight = static_cast<DWORD>(s_height); \n  settings.dmFields     = DM_BITSPERPEL | DM_PELSWIDTH  |  \n                          DM_PELSHEIGHT; \n\n  /*Make sure my window style is full screen*/ \n  s_style = FULLSCREEN_STYLE; \n\n  /*If we can't change, switch back to desktop mode*/ \n  if ( ChangeDisplaySettings(&settings, CDS_FULLSCREEN) !=  \n                                  DISP_CHANGE_SUCCESSFUL ) \n  { \n    s_isFullScreen = false; \n    s_style        = WINDOWED_STYLE; \n    ChangeDisplaySettings(0, 0); \n    M5Debug::MessagePopup(\"FullScreen is not supported. \" \n    \"You are being switched to Windowed Mode\"); \n  } \n} \nelse /*If we are already fullscreen, switch to desktop*/ \n{ \n  /*Make sure I am in windows style*/ \n  s_style = WINDOWED_STYLE; \n  ChangeDisplaySettings(0, 0); \n} \n\n```", "```cpp\n//This shows the purpose of the statement \nif (s_isFullScreen) \n{ \n  s_style = FULLSCREEN_STYLE; \n  SetFullScreen(true); \n} \n\n//So does this \nif (s_isFullScreen) { \n  s_style = FULLSCREEN_STYLE; \n  SetFullScreen(true); \n} \n\n//This does not shows the intent of the statement \nif (s_isFullScreen) \n{ \ns_style = FULLSCREEN_STYLE; \nSetFullScreen(true); \n} \n\n```", "```cpp\n/*Single statement in the loop*/ \nwhile (i++ < 10) \n  printf(\"The value of i is %d\\n\", i); \n\n/*After adding another statement*/ \nwhile (i++ < 10) \n  printf(\"The value of i is %d\\n\", i); \n  printf(\"i squared is %d\\n\", i*i); \n\n```", "```cpp\n//Save position and scale to variables for readability. \nconst float HALF = .5f; \nM5Vec2 halfScale = m_pObj->scale * HALF; \nM5Vec2 pos = m_pObj->pos; \n//Get world extents \nM5Vec2 botLeft; \nM5Vec2 topRight; \nM5Gfx::GetWorldBotLeft(botLeft); \nM5Gfx::GetWorldTopRight(topRight); \n//If object is outside of world, mark as dead \nif (pos.x - halfScale.x > topRight.x || pos.x + \n    halfScale.x < botLeft.x || pos.y - halfScale.y  \n    > topRight.y || pos.y + halfScale.y < botLeft.y) \n{ \n  m_pObj->isDead = true; \n} \n\n```", "```cpp\n//Save position and scale to variables for readability. \nconst float HALF = .5f; \nM5Vec2 halfScale = m_pObj->scale * HALF; \nM5Vec2 pos       = m_pObj->pos; \n\n//Get world extents \nM5Vec2 botLeft; \nM5Vec2 topRight; \nM5Gfx::GetWorldBotLeft(botLeft); \nM5Gfx::GetWorldTopRight(topRight); \n\n//If object is outside of world, mark as dead \nif ( pos.x - halfScale.x > topRight.x ||  \n     pos.x + halfScale.x < botLeft.x  || \n     pos.y - halfScale.y > topRight.y ||  \n     pos.y + halfScale.y < botLeft.y  ) \n{ \n  m_pObj->isDead = true; \n} \n\n```", "```cpp\n//If object is outside of world, mark as dead \nif (( (pos.x - halfScale.x) > topRight.x ) ||  \n    ( (pos.x + halfScale.x) < botLeft.x  ) || \n    ( (pos.y - halfScale.y) > topRight.y ) ||  \n    ( (pos.y + halfScale.y) < botLeft.y  )) \n{ \n  m_pObj->isDead = true; \n} \n\n```", "```cpp\nvoid DoStuff(bool x[], int y) \n{   \n  for(int i = 0; i < y; ++i) \n    x[i] = true; \n\n  x[0] = x[1] = false; \n\n  int b = static_cast<int>(std::sqrt(y)); \n\n  for(int a = 2; a <= b; ++a) \n  { \n    if(x[a] == false) \n      continue; \n\n    for(int c = a * 2; c < y; c += a) \n      x[c] = false; \n  } \n} \n\n```", "```cpp\nvoid CalculateSievePrimes(bool primes[], int arraySize) \n{     \n  for(int i = 0; i < arraySize; ++i) \n    primes[i] = true; \n\n  primes[0] = primes[1] = false; \n\n  int upperBound = static_cast<int>(std::sqrt(arraySize)); \n\n  for(int candidate = 2; candidate <= upperBound; ++candidate) \n  { \n    if(primes[candidate] == false) \n      continue; \n\n    int multiple = candidate * 2; \n    for(; multiple < arraySize; multiple += candidate) \n      primes[multiple] = false; \n  } \n} \n\n```", "```cpp\n//Assign START_VALUE to x \nint x = START_VALUE; \n\n```", "```cpp\n/****************************************************************/ \n/*! \nGiven an array of \"arraySize\" mark all indices that are prime as true. \n\n\\param [out] primes  \nThe array to modify and Output. \n\n\\param [in] arraySize  \n  The number of elements in the array \n\n\\return  \n  None. Indices that are prime will be marked as true \n\n*/ \n/****************************************************************/ \nvoid CalculateSievePrimes(bool primes[], int arraySize) \n{  \n  /*Ensure array is properly initialized */    \n  for(int i = 0; i <size; ++i) \n    primes[i] = true; \n\n  /*Zero and One are never prime*/  \n  primes[0] = primes[1] = false; \n\n/*Check values up to the square root of the max value*/ \n  int upperBound = static_cast<int>(std::sqrt(arraySize)); \n\n  /*Check each value, if valid, mark all multiples as false*/ \n  for(int candidate = 2; candidate <= upperBound; ++candidate) \n  { \n    if(primes[candidate] == false) \n      continue; \n\n    int multiple = candidate * 2; \n    for(; multiple < arraySize; multiple += candidate) \n      primes[multiple] = false; \n  } \n} \n\n```", "```cpp\nint i1;            //No initialization, OK \nint i2    = 0;     //Initialization, OK \n\nconst int ci1;     //ERROR: No initialization \nconst int ci2 = 0; //Initialization, OK \n\ni1 = 10;           //Assignment, OK \ni2 += 2;           //Assignment, OK \n\nci1 = 10;          //ERROR: Can't Assign \nci2 += 2;          //ERROR: Can't Assign \n\n```", "```cpp\nvoid Foo(int* a);      //Pass by pointer \nvoid Foo(int& a);      //Pass by reference \nvoid Foo(int a);       //Pass by value \nvoid Foo(const int a); //Pass by const value \nvoid Foo(const int* a);//Pass by pointer to const \nvoid Foo(const int& a);//Pass by reference to const \n\n```", "```cpp\nvoid Foo(int a);       //Pass by value \nvoid Foo(const int a); //Pass by const value \n\n```", "```cpp\n//A Poorly named function that unexpectedly modifies data \nvoid PrintArray(int buffer[], int size) \n{ \n  for(int i = 0; i < size; ++i) \n  { \n    buffer[i] = 0; //Whoops!!! \n    std::cout << buffer[i] << \" \"; \n  } \n  std::cout << std::endl; \n} \n//Example of creating an array and passing it to the function \nint main(void) \n{ \n  const int SIZE  = 5; \n  int array[SIZE] = {1, 2, 3, 4, 5}; \n\n  PrintArray(array, SIZE); \n  return 0; \n} \n\n```", "```cpp\n0 0 0 0 0  \n\n```", "```cpp\nint main(void) \n{ \n  const int SIZE  = 5; \n  const int array[SIZE] = {1, 2, 3, 4, 5};//Marked as const \n\n  array[0] = 0;//ERROR: Can't modify a const array \n\n  PrintArray(array, SIZE);//Error: Function doesn't accept const \nreturn 0; \n} \n\n```", "```cpp\n//Const prevents the function from modifying the data \nvoid PrintArray(const int buffer[], int size) \n{ \nfor(int i = 0; i < size; ++i) \n{ \n  //buffer[i] = 0; //This would be a compiler error \n  std::cout << buffer[i] << \" \"; \n  } \nstd::cout << std::endl; \n} \n\nint main(void) \n{ \n  const int SIZE  = 5; \n  int array[SIZE] = {1, 2, 3, 4, 5}; \n\n  array[0] = 0;//Modifying the array is fine \n\n  PrintArray(array, SIZE);//OK. Can accept non-const \nreturn 0; \n} \n\n```", "```cpp\n//Simplified GameObject struct \nstruct GameObject \n{ \nM5Vec2 pos; \nM5Vec2 vel; \nint    textureID; \nstd::list<M5Component*> components; \nstd::string name; \n}; \n\nvoid DebugPrintGameObject(GameObject& gameObject) \n{ \n//Do printing  \ngameObject.textureID = 0;//WHOOPS!!! \n} \n\n```", "```cpp\nvoid DebugPrintGameObject(const GameObject& gameObject) \n{ \n//Do printing  \ngameObject.textureID = 0;//ERROR: gameObject is const \n} \n\n```", "```cpp\nclass Simple \n{ \npublic: \nSimple(void) \n{ \n  m_data = 0; \n  } \nvoid SetData(int data) \n{ \n  m_data = data; \n} \nint GetData(void) \n{ \n  return m_data; \n  } \nprivate: \nint m_data; \n}; \n\nint main(void) \n{ \nSimple s; \nconst Simple cs; \n\ns.SetData(10);          //Works as Expected \nint value = s.GetData();//Works as Expected \n\ncs.SetData(10);         //Error as expected \nvalue = cs.GetData();   //Error: Not Expected \nreturn 0; \n} \n\n```", "```cpp\n//Example showing the hidden this pointer. This code won't //compile \nSimple::Simple(Simple* this) \n{ \n  this->m_data = 0; \n} \nvoid Simple::SetData(Simple* this, int data) \n{ \n  this->m_data = data; \n} \nint Simple::GetData(Simple* this) \n{ \n  return this->m_data; \n} \n\n```", "```cpp\n//Not Real Code. Will Not Compile \nSimple::Simple(Simple* const this) \n{ \n  this->m_data = 0; \n} \n\n```", "```cpp\nSimple s; \ns.SetData(10); \n\n```", "```cpp\nSimple s; \nSimple::SetData(&s, 10); \n\n```", "```cpp\n//What we would like to do but can't \nint Simple::GetData(const Simple* const this); \n\n//We must mark the function as const \n   int Simple::GetData(void) const; \n\n```", "```cpp\nclass Simple \n{ \n  public: \n  Simple(void); \n  void SetData(int data); \n  int GetData(void) const; \n  private: \n  int m_data; \n}; \n\nint main(void) \n{ \n  Simple s; \n  const Simple cs; \n\n  s.SetData(10);          //Works as Expected \n  int value = s.GetData();//Works as Expected \n\n  cs.SetData(10);         //Error as expected \n  value = cs.GetData();   //Works as Expected \n  return 0; \n} \n\n```", "```cpp\n//Const correct global function using member functions to access \n//the data \nvoid DisplaySimple(const Simple& s) \n{ \n  std::cout << s.GetData() << std::end; \n} \n\n```", "```cpp\n//Example of modifying const bits through different variables. \nint i = 0; \nconst int& ci = i; \n\nci = 10; //ERROR: can't modify the bits through const variable \ni  = 10; //OK. i is not const \n\nstd::cout << ci << std::endl;//Prints 10 \n\n```", "```cpp\nclass Simple \n{ \npublic: \n     Simple(void); \n  int GetData(void) const; \nprivate: \n  int m_data; \n  Simple* m_this; \n}; \nSimple::Simple(void):m_data(0), m_this(this) \n{ \n} \nint Simple::GetData(void) const \n{ \n  m_this->m_data = 10; \n  return m_data; \n} \n\nint main(void) \n{ \n  const Simple s; \n  std::cout << s.GetData() << std::endl; \n  return 0; \n} \n\n```", "```cpp\nint Simple::GetData(void) const \n{ \n  const_cast<Simple*>(this)->m_data = 10; \n   m_data; \n} \n\n```", "```cpp\nclass LeakyArray \n{ \npublic: \nLeakyArray(int size) \n{ \n  m_array = new int[size]; \n  } \nvoid SetValue(int index, int value) \n{ \n  m_array[index] = value; \n} \nint GetValue(int index) const \n{ \n  //function is const so we can't do this \n  //m_array = 0; \n\n  //but we can do this!!!!!!! \n  m_array[index] = 0; \n\n  return m_array[index]; \n\n  } \nprivate: \n  int* m_array; \n}; \n\n```", "```cpp\n        push    rbp \n        mov     rbp, rsp \n        mov     DWORD PTR [rbp-20], edi \n        mov     DWORD PTR [rbp-24], esi \n        mov     edx, DWORD PTR [rbp-20] \n        mov     eax, DWORD PTR [rbp-24] \n        add     eax, edx \n        mov     DWORD PTR [rbp-4], eax \n        nop \n        pop     rbp \n        ret \n\n```"]