<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer161">
<h1 class="chapter-number" id="_idParaDest-205"><a id="_idTextAnchor206"/>12</h1>
<h1 id="_idParaDest-206"><a id="_idTextAnchor207"/>Interacting with the World through Camera and Character Controllers</h1>
<p>You have been preparing little bits and pieces for the game world, especially in the last two chapters. In <a href="B17473_10.xhtml#_idTextAnchor165"><em class="italic">Chapter 10</em></a>, <em class="italic">Making Things Look Better with Lights and Shadows</em>, you added <strong class="bold">Light</strong> objects to sconces and candles. You even placed a script to adjust these objects’ lit state. Then, in <a href="B17473_11.xhtml#_idTextAnchor186"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating the User Interface</em>, you built a new scene by introducing <strong class="bold">Control</strong> nodes. This effort was for simulating a note from Clara’s uncle, Bert. </p>
<p>Although we’ve been taking steps to make things more sophisticated, pretty much everything feels static. In this chapter, we’ll show you a collection of practices that will build a connection between game objects and the player. This will make the project look live and feel more like a game. </p>
<p>The first thing we’ll look at is the <strong class="bold">Camera</strong> node and its settings. Godot’s viewport has been letting you see different scenes via a temporary construct so that you could work with the software. Such a transitory concept won’t be enough, so we’ll work with our camera system.</p>
<p>Next, we’ll focus on building a connection between some of the game objects in the world and the player. This involves detecting mouse events on a 2D surface and projecting these events into a 3D space. There might be different interactions such as hovering, clicking, pressing, and likewise, so we’ll look into ways to detect the action we want. For example, we will click a parchment left on the pier to bring up the note we worked on in the previous chapter. </p>
<p>Similarly, if the click happens to be on one of the areas where we would want to move Clara, we need a system that can do the pathfinding for us. To that end, we’ll investigate new Godot nodes, <strong class="bold">Navigation</strong> and <strong class="bold">NavigationMeshInstance</strong>.</p>
<p>Lastly, why not add a bit of animation? After we discover how to move a game object between two points in the world, we could instruct this object to trigger the appropriate animation cycle. In our case, Clara will switch between her idle state to her walking state. As a result, we’ll revisit some of the notions we got to know in the <em class="italic">Importing animations</em> section of <a href="B17473_07.xhtml#_idTextAnchor112"><em class="italic">Chapter 7</em></a>,<em class="italic"> Importing Blender Assets into Godot</em>. </p>
<p>As you can see, we are going to utilize a lot of the topics we have already visited, yet there is still a lot of new stuff to discover and learn. If we could enumerate it, it would look like this:</p>
<ul>
<li>Understanding the camera system</li>
<li>Detecting user input</li>
<li>Moving the player around</li>
<li>Triggering animations</li>
</ul>
<p>By the end of this chapter, you’ll have a much better understanding of camera settings in general, and you’ll be able to detect your player’s intentions and relate them to actions in the game. Thanks to an easy method of pathfinding, you’ll move Clara around the level to a location you want, and—finally—trigger the appropriate action to simulate her walking.</p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor208"/>Technical requirements</h1>
<p>We’ll continue where we left off in the previous chapter. This means you can keep working on your existing copy. Alternatively, you can start with the <strong class="source-inline">Finish</strong> folder of <strong class="source-inline">Chapter 12</strong> in this book’s GitHub repo: <a href="https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot">https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot</a>.</p>
<p>We have several new assets that are necessary to do the work in this chapter. These assets are in the <strong class="source-inline">Resources</strong> folder next to the <strong class="source-inline">Finish</strong> folder. As usual, merge these with your project files.</p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor209"/>Understanding the camera system</h1>
<p>In <a href="B17473_04.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Adjusting Cameras and Lights</em>, we briefly touched on the concept of a camera in Blender. We learned<a id="_idIndexMarker542"/> that we couldn’t render a scene without one. Although we took a render in the end by introducing a camera, we never talked about the different settings a camera can have. That was done intentionally because the know-how we would attain in Blender would not directly transfer to Godot. Fortunately, now is the right time to study in detail what a camera can do for enhancing the gameplay experience.</p>
<p>Not only are we going to get to know how to set up a <a id="_idIndexMarker543"/>camera that suits our game, but we are also going to discover different types of cameras Godot has in its inventory. As usual, or as it is something you might hear as a joke on internet forums and memes, there must be a node for this type of thing in Godot. </p>
<p>Yes, there is. In fact, there are four camera nodes, as outlined here:</p>
<ul>
<li><strong class="bold">Camera</strong>: This is the <a id="_idIndexMarker544"/>core class that serves as the base for all the other camera types. Even though you can have multiple <strong class="bold">Camera</strong> nodes in your scene, there can only be one active camera. And, similar to Blender, no camera means nothing to see here. </li>
<li><strong class="bold">InterpolatedCamera</strong>: This is an enhanced version of the <strong class="bold">Camera</strong> node. It comes with three extra<a id="_idIndexMarker545"/> properties that turn a regular <strong class="bold">Camera</strong> node into a mechanism that tracks and follows a target. It’s quite handy if you are developing a game with an over-the-shoulder camera look. If the game character is the target, when the target moves, the camera will catch up.</li>
</ul>
<p>Unfortunately, this node will be removed in Godot 4. Luckily, it’s not difficult to recreate its functionality by attaching a short script to a <strong class="bold">Camera</strong> node. In other words, if you remove the fancy bits of an <strong class="bold">InterpolatedCamera</strong> node, you get the <strong class="bold">Camera</strong> node, hence the decision to drop it in future versions.</p>
<ul>
<li><strong class="bold">ClippedCamera</strong>: This is <a id="_idIndexMarker546"/>another type of special <strong class="bold">Camera</strong> node, and fortunately, it will be kept in Godot 4 since it’s an advanced camera system. Our game is currently not using <strong class="bold">PhysicsBody</strong> nodes that are responsible for determining which objects can pass through each other or bump and bounce back when the bodies in motion connect with a colliding surface. For that reason, we won’t investigate this type of camera, but you might want to check this one out if you don’t want your cameras to travel through walls. It will behave like an object respecting physics rules.</li>
<li><strong class="bold">ARVRCamera</strong>: You <a id="_idIndexMarker547"/>might have guessed it: this is used for <strong class="bold">virtual reality</strong> (<strong class="bold">VR</strong>) projects. It isn’t something you’d utilize as a standalone node since it depends on a lot of other nodes that have <strong class="bold">augmented reality/virtual reality</strong> (<strong class="bold">ARVR</strong>) at the beginning of their names. Building a VR project is an advanced topic that deserves probably a whole book dedicated to the subject. For that reason, we’ll skip this node too. </li>
</ul>
<p>Besides the camera nodes for 3D workflows, there is also the <strong class="bold">Camera2D</strong> node that is used in 2D projects. Thus, there are five types of cameras in total.</p>
<p>Out of all these types we presented, the most promising candidate is the <strong class="bold">InterpolatedCamera</strong> node. Why? Because an <strong class="bold">InterpolatedCamera</strong> node is essentially a <strong class="bold">Camera</strong> node with extra pizazz such as target and track functionality. So, in your Godot 3 projects, you can start with <strong class="bold">InterpolatedCamera</strong> and treat it like a <strong class="bold">Camera</strong> node until you need that extra functionality. </p>
<p>Since we are continuing our work from the previous chapter, it makes sense to tidy up some loose ends. Let’s start with that first, then we can move on to introducing camera settings.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor210"/>Tidying things up for interactivity</h2>
<p>The last thing we did in the <strong class="source-inline">UI.tscn</strong> scene was skinning UI components. During that effort, we had already turned off the visibility of the <strong class="bold">Panel</strong> node that was responsible for displaying the note from Clara’s uncle. Then, we introduced a series of UI nodes, all grouped under an <strong class="bold">HBoxContainer</strong> node. We’ll turn that container off too, but let’s run the project first by pressing <em class="italic">F5</em>. You might see something like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<img alt="Figure 12.1 – The first run of our game " height="907" src="image/Figure_12.1_17473.jpg" width="1616"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The first run of our game</p>
<p>The UI decisions we have made are visible in the top-left corner of the game. We don’t need those for the moment. So, bring up the <strong class="source-inline">UI.tscn</strong> if you have it closed, turn off the <strong class="bold">HBoxContainer</strong> node, and run the game again. We’ll look into some UI concerns in the <em class="italic">Detecting user input</em> section soon.</p>
<p>Perhaps you’ve already noticed from the screenshots we have used in previous chapters or simply by looking at the project files that there has already been a <strong class="source-inline">Game.tscn</strong> scene configured as the main scene for the project. That’s why Godot did not ask you to pick the main scene when you pressed <em class="italic">F5</em> since we had already assigned one to the project for you. </p>
<p>Open <strong class="source-inline">Game.tscn</strong>, and let’s see how this scene is structured. Everything might look self-evident, but there is the root node labeled as <strong class="bold">Game</strong>, then two child nodes labeled as <strong class="bold">Camera</strong> and <strong class="bold">Level-01</strong>. Evidently, the level we created in <a href="B17473_09.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing the Level</em>, is a child node in <strong class="source-inline">Game.tscn</strong>. The other node, <strong class="bold">Camera</strong>, will be our main study area in this chapter. </p>
<p>We’ll split the rest of our efforts in understanding how cameras work mainly into two distinct areas. The most important topic is the projection type, which fundamentally changes the whole experience. We suggest this be something you decide early on in your own projects since any other tweaking can be done after this choice has been made. So, before we tackle individual camera settings, let’s see what kinds of projections there are.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor211"/>Deciding on a type of projection </h2>
<p>If you took an art class on learning how to draw architecture, this might be a topic you are already familiar with. The Godot version we are using comes with three types of projections. Although we will mainly focus on the first two, we’ll give a brief definition of all projection types, as follows:</p>
<ul>
<li><strong class="bold">Perspective</strong>: This is the <a id="_idIndexMarker548"/>default camera projection where the farther objects are from the camera, the smaller they will look. Hence, two objects of the exact same dimensions will look like they are differently sized when one of these objects is placed away from the camera. This is also how human beings perceive the world, so if you don’t, get a check-up.</li>
<li><strong class="bold">Orthogonal</strong>: Also known as <strong class="bold">Orthographic</strong>, this type of projection renders objects of the same <a id="_idIndexMarker549"/>dimensions without altering their size, regardless of the distance to the camera. This type could give your game the dramatic look it needs. Also, there are some types of games—roleplaying (<em class="italic">Fallout</em> series) and <strong class="bold">Explore, Expand, Exploit, Exterminate</strong> (<strong class="bold">4X</strong>) (<em class="italic">Civilization</em>)—where this kind of projection is preferred.</li>
<li><strong class="bold">Frustum</strong>: This is a<a id="_idIndexMarker550"/> relatively new type of projection that has its uses in some types of games—for example, to get that 2.5D look some old-school games used to have where the visuals looked stretched. If you want to know more, <a href="https://zdoom.org/wiki/Y-shearing">https://zdoom.org/wiki/Y-shearing</a> has some information about this topic. </li>
</ul>
<p>In most cases, the first two projections we listed here will be enough. Maybe it would be better if we investigated their differences by experimenting. Since we’ve already seen the <strong class="bold">Perspective</strong> projection type, it makes sense to try the <strong class="bold">Orthogonal</strong> projection type, so follow these next steps:</p>
<ol>
<li>Select <a id="_idIndexMarker551"/>the <strong class="bold">Camera</strong> node in the <strong class="source-inline">Game.tscn</strong> scene.</li>
<li>Change its <strong class="bold">Projection</strong> setting to <strong class="bold">Orthogonal</strong> and set its <strong class="bold">Size</strong> value to <strong class="source-inline">6</strong>. </li>
<li>Press <em class="italic">F5</em> to run the game and notice a different artistic style.</li>
</ol>
<p>After we make these changes, this is what we have:</p>
<div>
<div class="IMG---Figure" id="_idContainer148">
<img alt="Figure 12.2 – Orthographic camera view from the same location " height="767" src="image/Figure_12.2_17473.jpg" width="1368"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Orthographic camera view from the same location</p>
<p>We picked a <strong class="bold">Size</strong> value that would make the render look close enough to the example we had in <strong class="bold">Perspective</strong> projection. The <strong class="bold">Size</strong> property is an interesting one because it takes into account many factors. For example, if you change the <strong class="bold">Keep Aspect</strong> value from <strong class="bold">Keep Height</strong> to <strong class="bold">Keep Width</strong>, you will have to double the <strong class="bold">Size</strong> value to <strong class="source-inline">12</strong>. Most PC monitors, however, follow a landscape orientation. That’s why <strong class="bold">Keep Height</strong> is the default option, but if you are working on a mobile game, you might want to mix and match the correct <strong class="bold">Size</strong> value with the <strong class="bold">Keep Width</strong> option selected.</p>
<p class="callout-heading">Camera-specific environment</p>
<p class="callout">While we are looking at different properties of the <strong class="bold">Camera</strong> node in the <strong class="bold">Inspector</strong> panel, now might be a good time to get a refresher on the <strong class="bold">Environment</strong> topic. In the <em class="italic">Creating post-processing effects</em> section of <a href="B17473_10.xhtml#_idTextAnchor165"><em class="italic">Chapter 10</em></a>, <em class="italic">Making Things Look Better with Lights and Shadows</em>, we discovered how to create an environment that changed the look of the level. If you want to override some of the environment settings, you can do so by assigning a separate <strong class="bold">Environment</strong> object to the camera. The effects of both the level-wide and camera-specific environments will be combined.</p>
<p>No matter <a id="_idIndexMarker552"/>which values you pick for the right platform, one thing is obvious. Even though we didn’t move the camera’s position and rotation in the world, the effect we get is utterly different. Whereas we used to see the door in the back of the cave in the <strong class="bold">Perspective</strong> projection as depicted in <em class="italic">Figure 12.1</em>, the <strong class="bold">Orthographic</strong> view doesn’t permit us to see that far, as seen in <em class="italic">Figure 12.2</em>. When you compare both screenshots, the near elements are pretty much the same, but the <strong class="bold">Orthographic</strong> view simulates a more top-down look to the scene than looking far ahead.</p>
<p>Altering stuff in the <strong class="bold">Inspector</strong> panel and hitting <em class="italic">F5</em> to see your changes in effect might get tiring quickly. While the <strong class="bold">Camera</strong> node is still selected, if you turn on the <strong class="bold">Preview</strong> checkbox, as seen in the following screenshot, you can speed up your workflow when you are editing your camera’s attributes: </p>
<div>
<div class="IMG---Figure" id="_idContainer149">
<img alt="Figure 12.3 – Previewing what your camera sees is handy, and it’s one checkbox away " height="301" src="image/Figure_12.3_17473.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Previewing what your camera sees is handy, and it’s one checkbox away</p>
<p>This will let you preview what your camera is seeing while you are still adjusting its settings. Mind you, during preview, you cannot move around your scene freely. In fact, you can’t even select objects. So, remember to turn it off when you want to go back to editing your scene. </p>
<p>In light of what we have presented so far, what kind of projection type should we choose? We’re going to go with the <strong class="bold">Perspective</strong> mode. So, for now, revert your <strong class="bold">Camera</strong> node’s <strong class="bold">Projection</strong> setting to its default value. Since Godot decorates the <strong class="bold">Inspector</strong> panel with <a id="_idIndexMarker553"/>the relevant properties, the <strong class="bold">Size</strong> property will be replaced with the <strong class="bold">Fov</strong> property.</p>
<p>Let’s focus on this new property and some of the other changes we want to apply to the <strong class="bold">Camera</strong> node in the next section.</p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor212"/>Adjusting the camera settings for our game</h2>
<p>In this section, we are<a id="_idIndexMarker554"/> going to discuss a new term you have just been introduced to, <strong class="bold">Fov</strong>, and show which other settings we should apply to the camera. If you have been working on your own level design since the beginning, then the position and rotation of the camera we mention here will be meaningless. That’s why we’ll give you general directions to convey the spirit of the exercise. Also, hopefully, the screenshots you’ll see will help you align our level’s conditions to yours better.</p>
<p>First, a quick definition of the new term. <strong class="bold">Field of view</strong> (<strong class="bold">fov</strong>) is the <a id="_idIndexMarker555"/>angle, measured in degrees, through which a device perceives the world. Actually, if you consider your eyes as the device, your eyes also have a fov value. This is a highly technical domain, so we’ll offer you a few links in the <em class="italic">Further reading</em> section to discover it on your own.</p>
<p>For the time being, we’re much more interested in the practical applications of this subject since it’s pertinent to whether your game is running in portrait or landscape mode, or whether the game is for PC or consoles. The default value, <strong class="bold">70</strong>, that Godot uses is a decent average value that will suit most cases. However, this default value also assumes you are going to run your game in landscape mode as it’s dictated by the <strong class="bold">Keep Aspect</strong> property, which is set to <strong class="bold">Keep Height</strong>. </p>
<p>Since players might have different monitor sizes and resolutions, the application has to pick either the height or the width <a id="_idIndexMarker556"/>as the <strong class="bold">source of truth</strong> (<strong class="bold">SOT</strong>) and then apply the other necessary transformations accordingly for the sake of not distorting the visuals. Sometimes, this practice will yield a result such as having a black band above and below the visuals. This method, known<a id="_idIndexMarker557"/> as <strong class="bold">letterboxing</strong>, is also used in the cinema industry for converting movies shot with a squarer aspect ratio to modern wider (from 4:3 to 16:9 or 16:10 ratio) screens.</p>
<p>If you hover over the <strong class="bold">Fov</strong> property in the <strong class="bold">Inspector</strong> panel and read the tooltip, you’ll see that there are multiple values you can set for this property depending on the aspect ratio your game will use. Thus, we’ll let you choose the best value for your condition. Nevertheless, we’re<a id="_idIndexMarker558"/> providing the following screenshot to demonstrate the permutations of different <strong class="bold">Keep Aspect</strong> and <strong class="bold">Fov</strong> values:</p>
<div>
<div class="IMG---Figure" id="_idContainer150">
<img alt="Figure 12.4 – Same camera position with different aspect-ratio constraints and fov values " height="674" src="image/Figure_12.4_17473.jpg" width="1201"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Same camera position with different aspect-ratio constraints and fov values</p>
<p>What a big difference! Without changing a single thing for the camera, different permutations will yield lots of distinct results. Let’s wrap up the <strong class="bold">Fov</strong> topic by discussing what higher and lower values for <strong class="bold">Fov</strong> means so that you can make better decisions in your own projects.</p>
<p>At the end of the day, the <strong class="bold">Fov</strong> value you should pick will depend on the player’s viewing distance, which isn’t something you can really know ahead of time. However, there are conventions you can follow. For example, console games use a lower <strong class="bold">Fov</strong> value since it provides a zoomed-in-like view that compensates for the distance between the screen and the player. Most typically, a console game player will be sitting on a couch a few meters away from a screen that is usually large.</p>
<p>On the other hand, a PC player is usually less than one meter away from a monitor, thus it might be better to use higher <strong class="bold">Fov</strong> values. This increases immersion since players feel they get to<a id="_idIndexMarker559"/> see more of the world by virtue of having this view a bit zoomed out compared to lower <strong class="bold">Fov</strong> values. That being said, it’s known that really high <strong class="bold">Fov</strong> values also create motion sickness. When your brain is forced to process too much of the world, you get that churning stomach feeling, especially in <strong class="bold">first-person shooter</strong> (<strong class="bold">FPS</strong>) games. </p>
<p class="callout-heading">Fov calculator</p>
<p class="callout">There is a handy calculator<a id="_idIndexMarker560"/> for finding ideal <strong class="bold">Fov</strong> values: <a href="https://themetalmuncher.github.io/fov-calc/">https://themetalmuncher.github.io/fov-calc/</a>. Select the aspect ratio and orientation of your screen, and the calculator will eliminate some of the guesswork. Obviously, if you let your players change their screen resolution in the game’s settings, you’ve got to programmatically update the <strong class="bold">Fov</strong> value the game uses.</p>
<p>To finish off this section, we’ll stick with the value of <strong class="source-inline">97</strong> for <strong class="bold">Fov</strong> and choose <strong class="bold">Keep Width</strong> for the aspect ratio since it works out better artistically. Also, since this level is so small, having the camera follow the game character won’t be necessary. Still, we could try to pick the best angle and position of the <strong class="bold">Camera</strong> node to see most of the scene. As already mentioned, our values won’t mean much. However, try to change the <strong class="bold">Translation</strong> and <strong class="bold">Rotation Degrees</strong> values for the <strong class="bold">Camera</strong> node to match what you see here:</p>
<div>
<div class="IMG---Figure" id="_idContainer151">
<img alt="Figure 12.5 – The camera’s final resting position " height="751" src="image/Figure_12.5_17473.jpg" width="1430"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – The camera’s final resting position</p>
<p>What this view will <a id="_idIndexMarker561"/>give us are a few things. First, it covers the most crucial angles. Clara can only walk to certain spots on this level. Also, not every walkable location is important. Still, there doesn’t seem to be anything significant left out from this perspective.</p>
<p>Second, referring to her uncle’s note, there is a backpack behind the broken cart. It’s hard to see it from here because the sconce’s light in that corner is not enough to make the backpack all that obvious. All of this is intentional because we’ll want Clara to hold a torch in her hand, so that extra bit of light will be enough for her or the player to notice an important object.</p>
<p>Eventually, we expect the player to see and interact with the objects in the world, especially the backpack since it holds the key to the upstairs. A common instrument game designers use for player-to-world interaction is mouse events, which is what we’ll discover next.</p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor213"/>Detecting user input</h1>
<p>Mouse events are <a id="_idIndexMarker562"/>one of the many types of user input you can detect in a video game. Other most common types are keyboard or game controller events, which won’t be covered in this book. Still, the principles in detecting what the mouse is doing are similar to how you can treat other types of events. The reason why we are focusing more on mouse events is that there is an extra layer of complexity you’ve got to deal with, which is what this section will be about. Let’s dive right in.</p>
<p>In a conventional desktop application such as text- or video-editing software, the interface is usually populated with a lot of buttons, menus, and likewise. The natural behavior you’d expect from the users of such software is to click these designated spots, which is something the creators of the application anticipate and prepare for you. How would you go about this in a 3D game, though?</p>
<p>See, when you click anywhere on your screen, you are essentially clicking on a 2D surface. Thus, it originally makes sense to define the click’s coordinates based on the <em class="italic">x</em> and <em class="italic">y</em> axes. Let’s make the case even simpler. We are not clicking anything fancy but just the middle of the screen. By knowing the monitor’s resolution, we can do the calculation and come up with coordinates that are half the resolution in both axes.</p>
<p>Let’s imagine, in this special case where we keep clicking right in the middle of the screen, we have the game world we see in <em class="italic">Figure 12.5</em>. Where does that click correspond in our level? Even more interestingly, if you implemented a camera that moved elsewhere, perhaps even rotated due to gameplay reasons, how do you map the same <em class="italic">x</em> and <em class="italic">y</em> coordinates to a different position in the 3D space? </p>
<p>This is a challenging topic that is not always straightforward to resolve, but let’s see which techniques we can use to discern mouse events.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor214"/>Knowing where the player interacts</h2>
<p>There is a common <a id="_idIndexMarker563"/>technique in the industry for detecting where the player is pointing in a 3D world. It’s called <strong class="bold">raycasting</strong>, and YouTube is awash with tutorials dedicated to this particular topic, not <a id="_idIndexMarker564"/>just for Godot Engine but for other game engines as well. It assumes that you are casting a ray from where you clicked on your screen to a position in the 3D world. Since the game engine is already capable of rendering the game by considering the game objects’ positions in relation to the camera, which happens to be your screen, then the calculations are already done for you, to a certain extent. </p>
<p>Although this technique puts you in the right direction, you still have no idea which object in the path of that ray is the one you want to select. Perhaps an unfortunate analogy for a ray might be a strong enough bullet that’s traversing through all objects it connects with. So, if raycasting brings up many results, you’ve got to eliminate the ones you don’t want. Fortunately, there is a more direct way.</p>
<p>It would be convenient to only assign detection logic to the objects we want. For example, we can introduce a new model to our scene—a parchment, to be specific—right on the wooden slats of the pier. Once the player clicks this object, we’ll trigger the note currently hidden in the <strong class="source-inline">UI.tscn</strong> scene. Via this effort, you will also practice some of the methods you used in earlier chapters too. Here are the steps to take:</p>
<ol>
<li value="1">Make a <a id="_idIndexMarker565"/>new scene out of <strong class="source-inline">Parchment.glb</strong> and save it as <strong class="source-inline">Parchment.tscn</strong> in the same folder.</li>
<li>Since there is a default environment in effect, the scene will be dark, and it will be hard to follow the succeeding steps. To disable it, open <strong class="bold">Project Settings</strong> and clear the <strong class="bold">Default Environment</strong> field in the <strong class="bold">Environment</strong> section under the <strong class="bold">Rendering</strong> header. Close <strong class="bold">Project Settings</strong> to go back to <strong class="source-inline">Parchment.tscn</strong>.</li>
<li>Add a <strong class="bold">StaticBody</strong> node under the root node. </li>
<li>Add a <strong class="bold">CollisionShape</strong> node under this last node you introduced and assign a <strong class="bold">New BoxShape</strong> to its <strong class="bold">Shape</strong> field in the <strong class="bold">Inspector</strong> panel.</li>
<li>Expand this new shape by clicking it. Type <strong class="source-inline">0.15</strong>, <strong class="source-inline">0.14</strong>, and <strong class="source-inline">0.06</strong> in the <strong class="bold">Extents</strong> section’s <strong class="bold">X</strong>, <strong class="bold">Y</strong>, and <strong class="bold">Z</strong> fields respectively. This shape should encapsulate the model.</li>
<li>Still for the <strong class="bold">CollisionShape</strong> node, expand its <strong class="bold">Transform</strong> header, then type <strong class="source-inline">0.05</strong> in the <strong class="bold">Z</strong> field under its <strong class="bold">Translation</strong> section.</li>
</ol>
<p>We are not done yet with the parchment scene, but let’s take a break and explain what’s happened. </p>
<p>We have added our first <strong class="bold">PhysicsBody</strong> type of node to our workflow with a <strong class="bold">StaticBody</strong> node. There are other types too, such as <strong class="bold">KinematicBody</strong>, <strong class="bold">RigidBody</strong>, and likewise, if you would like to offer physics-based gameplay. Since the parchment object we will place in the world won’t go anywhere, we chose <strong class="bold">StaticBody</strong>. </p>
<p>Then, we assigned a collision shape to the <strong class="bold">StaticBody</strong> node. Adding collision to game objects is necessary if you want the engine to detect when your objects collide with each other. By doing so, the game engine can determine these objects’ future trajectory and speed. </p>
<p>One type of <a id="_idIndexMarker566"/>collision the game engine can detect is when players interact with objects using input devices. For instance, the player might move the mouse over an object, click this object, or even want to drag and move it somewhere else. Out of all these possibilities, we are only interested in detecting when the player clicks the parchment model. We’ll learn how to distinguish the exact event we want in the next section.</p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor215"/>Distinguishing useful mouse events</h2>
<p>We’ve constructed all the<a id="_idIndexMarker567"/> necessary mechanisms to start detecting collisions. The basic shape we wrapped the parchment model in will act like a sensor to know if collisions are occurring. Out of so many different types of collisions, we are mainly interested in listening to mouse events, and—more specifically—detecting mouse clicks.</p>
<p>We’ll treat this click on the parchment as a precursor to bringing up the currently hidden <strong class="bold">Panel</strong> node inside the <strong class="source-inline">UI.tscn</strong> scene. Ultimately, we will build a communication line between the parchment and the <strong class="source-inline">UI.tscn</strong> scene. First, let’s see how we capture a collision and filter out the right type so that we can later trigger the chain of events we want. Here’s what to do:</p>
<ol>
<li value="1">Attach a script to the root node in <strong class="source-inline">Parchment.tscn</strong> and save it as <strong class="source-inline">Parchment.gd</strong>.</li>
<li>Select the <strong class="bold">StaticBody</strong> node and turn on the <strong class="bold">Node</strong> panel.</li>
<li>Double-click the <strong class="bold">input_event</strong> entry under the <strong class="bold">CollisionObject</strong> header. </li>
<li>Press the <strong class="bold">Connect</strong> button in the pop-up menu. This will add a few lines of temporary code, so change the <strong class="source-inline">Parchment.gd</strong> script to what you see here:<p class="source-code">extends Spatial</p><p class="source-code">signal show_note</p><p class="source-code">func _on_StaticBody_input_event(camera, event, position, normal, shape_idx):</p><p class="source-code">    if event is InputEventMouseButton and </p><p class="source-code">      event.pressed:</p><p class="source-code">        emit_signal("show_note")</p></li>
</ol>
<p>We’re now, in theory, tracking the<a id="_idIndexMarker568"/> input event on the <strong class="bold">StaticBody</strong> node. However, in practice, since the collision shape for generating this event is positioned precisely over the parchment, our setup will behave as though you are detecting clicks on the parchment itself. The following screenshot shows our progress in the editor: </p>
<div>
<div class="IMG---Figure" id="_idContainer152">
<img alt="Figure 12.6 – We are attaching input events to the parchment object " height="325" src="image/Figure_12.6_17473.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – We are attaching input events to the parchment object</p>
<p>The input event we are capturing is generic enough, but we are filtering it out so that it will be valid only in mouse-click conditions. Then, we transformed the meaning of this click by emitting a <strong class="source-inline">show_note</strong> signal, but who is listening to this call? Some construct out there could make sense of this signal—more specifically, the <strong class="bold">Panel</strong> node inside the <strong class="source-inline">UI.tscn</strong> scene. Let’s connect them next, as follows:</p>
<ol>
<li value="1">Open <strong class="source-inline">UI.tscn</strong> and attach a script to the root. Save it as <strong class="source-inline">UI.gd</strong> and add the following line of code:<p class="source-code">export(NodePath) onready var note_trigger = get_node(note_trigger) as Node</p></li>
<li>Open <strong class="source-inline">Level-01.tscn</strong> and create an instance of <strong class="source-inline">Parchment.tscn</strong> in the <strong class="bold">Props</strong> group. Position this new node on the wooden slats of the pier so that it sits relatively close to the boat.</li>
<li>Select the <strong class="bold">UI</strong> node in the <strong class="bold">Scene</strong> panel. There is going to be a <strong class="bold">Note Trigger</strong> field for this node in the <strong class="bold">Inspector</strong> panel. Press <strong class="bold">Assign…</strong> and select <strong class="bold">Parchment</strong> among the options that come up in the pop-up menu.</li>
<li>Go back to the <strong class="source-inline">UI.gd</strong> script <a id="_idIndexMarker569"/>and add the following lines of code:<p class="source-code">func _ready():</p><p class="source-code">    note_trigger.connect("show_note", self, </p><p class="source-code">                         "on_show_note")</p><p class="source-code">func on_show_note():</p><p class="source-code">    $Panel.visible = true</p></li>
</ol>
<p>There is a lot going on here with a few lines of basic code. First, we prepared a field for the <strong class="bold">UI</strong> node to accept another object as a trigger so that we could assign the <strong class="bold">Parchment</strong> node using the <strong class="bold">Inspector</strong> panel. Then, we instructed the <strong class="bold">UI</strong> node to listen to a specific event—the <strong class="source-inline">show_note</strong> signal—so that it could trigger the <strong class="source-inline">on_show_note</strong> function. When this function runs as a result of the player’s click on the parchment, the <strong class="bold">Panel</strong> node, which is essentially Bert’s note, will become visible.</p>
<p>When you were building the UI in <a href="B17473_11.xhtml#_idTextAnchor186"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating the User Interface</em>, if you didn’t center the <strong class="bold">Panel</strong> perfectly, you can do so now by using the <strong class="bold">Layout</strong> button in the header of the 3D viewport. If you prefer, you can position the <strong class="bold">Panel</strong> anywhere you want. Ultimately, when you press <em class="italic">F5</em> and run the game, after you click the parchment on the pier, you will see something like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer153">
<img alt="Figure 12.7 – Bert’s note to Clara was opened when the player clicked the parchment " height="679" src="image/Figure_12.7_17473.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Bert’s note to Clara was opened when the player clicked the parchment</p>
<p>Remember that the <strong class="bold">Close</strong> button is already<a id="_idIndexMarker570"/> wired, so it’ll close the note when you press it. If you do so, you can open the note again by clicking the parchment. Who knew that a simple mouse click could mean different things? In one context, it’s pressing on a flat surface that translates to clicking a 3D object, which then triggers other game systems. In another, it’s pressing a UI element like a button.</p>
<p class="callout-heading">Sconces and candles</p>
<p class="callout">If the player is able to click the parchment, can’t they click the sconces and candles around the level? They can, but they won’t get a reaction out of it right now since you have to construct a collision structure, just as we did for the parchment. This is something you can work on as an exercise.  </p>
<p>We’re not planning to have an inventory system in our game. However, in games that employ that kind of functionality, it’s common to see that parchment disappear from the world and find a place for itself in the player’s inventory. Then, the player can later click an icon that represents the note in their inventory to bring up the note UI again. In this extra case, your UI structure would also have to listen to a <strong class="source-inline">show_note</strong> signal emitted from a different structure, but it’s a similar principle.</p>
<p>Not having an inventory system is not a real detriment to our workflow at this point since we have more pressing issues such as helping the player move around. Although we have a level where there is a solid floor, we have no game character that can stand on it. We’ll look at how to introduce one and move it in the upcoming section.</p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor216"/>Moving the player around</h1>
<p>You might have heard<a id="_idIndexMarker571"/> that context is important in real life because context can make an ordinary word or statement look especially bad or fun. This is consistently true in most technical areas—more specifically when we try to describe visual or artistic aspects. Sometimes, it’s alright to use words interchangeably, but making a distinction might be crucial—even necessary every now and then. For example, at the end of the last section, we claimed that we’d move a character. It might be an absurd attempt to do mind-reading via the pages of a book, but would we be wrong if you imagined a biped creature such as Clara walking around using her legs and swinging her arms?</p>
<p>Chances are you did think about it that way, but you’ll have to wait for that at this moment since we haven’t even moved an object between two spots on the level. Referring to the analogy of context, not every move has to involve a fully-fledged animation. Clara’s model, or an ordinary cube for that matter, could also move by following a path. Therefore, it might be more appropriate to think of movement and animation as two distinct topics. That’s why we will introduce animation into moving objects later in the <em class="italic">Triggering animations</em> section after we first tackle movement in this section.</p>
<p>Now that you know there is a difference between an object traversing a scene and doing so with an animation, the big question is: <em class="italic">How to detect where to move an object?</em> Let’s be more specific in terms of our level design. We have a pier where we have just recently placed a parchment. The basic expectation is that our player character will be standing right by this parchment. Once the player is done reading the note, we expect them to reach the backpack to acquire a key to unlock the door that leads upstairs. Therefore, we need a mechanism to do the following:</p>
<ul>
<li>Detect clicks</li>
<li>Find a possible path</li>
<li>Move the player to their desired spot</li>
</ul>
<p>Before we can start working on these items, we first need two vital ingredients: <strong class="bold">Navigation</strong> and <strong class="bold">NavigationMeshInstance</strong>. These two nodes work hand in hand to designate some areas in the level to be walkable. After all, we wouldn’t want the player to walk everywhere or through objects, hence the importance of some of the props we placed around the<a id="_idIndexMarker572"/> level. </p>
<p class="callout-heading">Interchangeability for the sake of brevity</p>
<p class="callout">Although we’ve pointed out a major difference between movement and animation and claimed that we can’t use these two concepts interchangeably, we are in luck when it comes to the two nodes we are going to peruse in this section. You’ll soon see that a <strong class="bold">Navigation</strong> node is practically incapable of doing its work without depending on <strong class="bold">NavigationMeshInstance</strong>. We’ll use <strong class="bold">Navigation</strong> as a general concept (unless otherwise specified) to talk about navigation, while technically, we might be describing the attributes of the <strong class="bold">NavigationMeshInstance</strong> node. </p>
<p>With that said, let’s create areas that are traversable by the player.</p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor217"/>Creating walkable areas with a Navigation node</h2>
<p>The level we <a id="_idIndexMarker573"/>started to design in <a href="B17473_09.xhtml#_idTextAnchor146"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing the Level</em> has some nice, but also troubling features. From a visual perspective, the <a id="_idIndexMarker574"/>props and their placement in the world look organic. Even bulkier objects such as the broken cart and the stag statue are out of the way but still in the line of sight when a person walks between the pier and the door. There is an element of usefulness mixed with clutter.</p>
<p>Speaking of clutter, when we introduce a <strong class="bold">Navigation</strong> node and ask Godot to calculate traversable areas, the location of the objects in your level may gain bigger importance. You may get a hint as to why this is after we make changes to the level, so open <strong class="source-inline">Level-01.tscn</strong> and follow along with these steps:</p>
<ol>
<li value="1">Add a <strong class="bold">Navigation</strong> node in the root node. Then, add a <strong class="bold">NavigationMeshInstance</strong> node right under this last node you’ve introduced.</li>
<li>Drag and drop the <strong class="bold">Floor</strong>, <strong class="bold">Columns</strong>, <strong class="bold">Rails</strong>, <strong class="bold">Props</strong>, and <strong class="bold">Dock</strong> groups under the <strong class="bold">NavigationMeshInstance</strong> node.</li>
<li>Select the <strong class="bold">NavigationMeshInstance</strong> node and assign a <strong class="bold">New NavigationMesh</strong> to its <strong class="bold">Navmesh</strong> field in the <strong class="bold">Inspector</strong> panel. </li>
<li>Click and expand this new property so that you can do the following:<ol><li>Type <strong class="source-inline">0.18</strong> in the <strong class="bold">Size</strong> field and <strong class="source-inline">0.1</strong> in the <strong class="bold">Height</strong> field under its <strong class="bold">Cell</strong> section.</li>
<li>Type <strong class="source-inline">0.4</strong> in the <strong class="bold">Radius</strong> field and <strong class="source-inline">0.2</strong> in the <strong class="bold">Max Climb</strong> field under its <strong class="bold">Agent</strong> section.</li>
<li>Turn on the <strong class="bold">Ledge Spans</strong> option under its <strong class="bold">Filter</strong> section.</li>
</ol></li>
<li>Press <em class="italic">7</em> on your numeric keypad to switch to the <strong class="bold">Top Orthogonal</strong> view.</li>
<li>Press the <strong class="bold">Bake NavMesh</strong> button at the top part of the 3D viewport.</li>
</ol>
<p>If your level <a id="_idIndexMarker575"/>design is different than ours, please<a id="_idIndexMarker576"/> try to follow the steps we have presented in the spirit they are given. This is especially important if you directly transfer our values to your system, which might not fit. In the end, you’ll see something similar to this: </p>
<div>
<div class="IMG---Figure" id="_idContainer154">
<img alt="Figure 12.8 – We have introduced a NavigationMeshInstance node and configured it " height="717" src="image/Figure_12.8_17473.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – We have introduced a NavigationMeshInstance node and configured it</p>
<p>Notice the light-blue overlay introduced by the <strong class="bold">Navigation</strong> node. That is all walkable as far as the engine is concerned. There is something awkward going on, though. When you dragged the <strong class="bold">Dock</strong> group into the <strong class="bold">Navigation</strong> node, the <strong class="bold">Water</strong> node came with it. So, it was also considered a candidate. </p>
<p>If this were <a id="_idIndexMarker577"/>a <em class="italic">Dungeons &amp; Dragons</em> game, your<a id="_idIndexMarker578"/> player might know the <em class="italic">Water Walk</em> spell and be able to walk on the water mesh. There is no such spell in Clara’s world, but it’s something you might want to consider if your game allows for such a mechanism and flavor. Therefore, instead of removing the water altogether, it’s best if we changed its place in the hierarchy by doing the following:</p>
<ol>
<li value="1">Move the <strong class="bold">Water</strong> node somewhere other than the <strong class="bold">NavigationMeshInstance</strong> node—for example, above the <strong class="bold">SpotLight</strong> node.</li>
<li>Similarly, drag and drop <strong class="bold">Parchment</strong> out of the <strong class="bold">Props</strong> group.</li>
<li>Select the <strong class="bold">NavigationMeshInstance</strong> node and press the <strong class="bold">Bake NavMesh</strong> button again.</li>
</ol>
<p>With a different hierarchy, the newly baked traversable area should look like this: </p>
<div>
<div class="IMG---Figure" id="_idContainer155">
<img alt="Figure 12.9 – The water is no longer walkable thanks to being in a different hierarchy " height="717" src="image/Figure_12.9_17473.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – The water is no longer walkable thanks to being in a different hierarchy</p>
<p>By determining which areas should be included in the <strong class="bold">NavigationMeshInstance</strong> node and adjusting values in the <strong class="bold">Inspector</strong> panel, you can come up with a more precise layout. Ultimately, if you can throw a few obstacles in the player’s way before they reach important places instead of following a perfectly straight line, you will create more engaging gameplay.</p>
<p>If the layout<a id="_idIndexMarker579"/> in your level doesn’t look traversable in<a id="_idIndexMarker580"/> some key areas, such as the backpack near the cart, then move some of those props around and bake a new map. This is going to be important when we introduce movement logic.</p>
<p>You might want to rotate the view to <strong class="bold">Perspective</strong> if you want to get a better feeling of which areas are reachable. Speaking of which, who is going to walk these areas? Next, we should introduce the most basic player character before we get into more advanced character models such as Clara.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor218"/>Introducing a basic player character</h2>
<p>Earlier in this chapter, in <a id="_idIndexMarker581"/>the <em class="italic">Knowing where the player interacts</em> section when we were inquiring about how the player could interact with the parchment, we introduced a <strong class="bold">StaticBody</strong> node because the object wasn’t going anywhere. We also mentioned that <strong class="bold">StaticBody</strong> was one of many <strong class="bold">PhysicsBody</strong> options available to you besides two other commonly used nodes, as described here:</p>
<ul>
<li><strong class="bold">RigidBody</strong>: Bodies that don’t have control over themselves fall under this category. The word <em class="italic">rigid</em> might be confusing at first since it conveys a feeling of how strong or flexible an object is. On the contrary, you can use a <strong class="bold">RigidBody</strong> node for simulating the motion of a soccer ball or a cannonball. You usually apply forces to objects that have this node, which will instruct how the physics engine will calculate their trajectory, collisions, and likewise.</li>
<li><strong class="bold">KinematicBody</strong>: Bodies that actually have control over how they will behave in the world fall into this category. Most typically, player characters use this node, but any system that creates its own motion—such as an actual engine or rocket—needs to use this. </li>
</ul>
<p>Consequently, the best option we have is to use a <strong class="bold">KinematicBody</strong> node to simulate a player character. We’ll now follow the next steps to create a very simple one:</p>
<ol>
<li value="1">Create a new scene and save it as <strong class="source-inline">Player.tscn</strong> under the <strong class="source-inline">Scenes</strong> folder.</li>
<li>Start with a <strong class="bold">KinematicBody</strong> node as its root. Then, add a <strong class="bold">CollisionShape</strong> node and a <strong class="bold">MeshInstance</strong> node under the root.</li>
<li>Select the <strong class="bold">MeshInstance</strong> node and do the following:<ol><li>Assign a <strong class="bold">New CapsuleMesh</strong> to its <strong class="bold">Mesh</strong> field. Expand this new field and type <strong class="source-inline">0.4</strong> for its <strong class="bold">Radius</strong> property.</li>
<li>Type <strong class="source-inline">90</strong> in the <strong class="bold">X</strong> field in <strong class="bold">Rotation Degrees</strong> under the <strong class="bold">Transform</strong> section.</li>
</ol></li>
<li>Select the <strong class="bold">CollisionShape</strong> node and do the following:<ol><li>Assign a <strong class="bold">New CapsuleShape</strong> to its <strong class="bold">Shape</strong> field. Expand this new field and type <strong class="source-inline">0.4</strong> for its <strong class="bold">Radius</strong> property.</li>
<li>Type <strong class="source-inline">90</strong> in the <strong class="bold">X</strong> field in <strong class="bold">Rotation Degrees</strong> under the <strong class="bold">Transform</strong> section.</li>
</ol></li>
<li>Select<a id="_idIndexMarker582"/> the <strong class="bold">KinematicBody</strong> node and type <strong class="source-inline">0.9</strong> in the <strong class="bold">Y</strong> field in <strong class="bold">Translation</strong> under the <strong class="bold">Transform</strong> section. Rename this <strong class="bold">KinematicBody</strong> node <strong class="source-inline">Player</strong>.</li>
</ol>
<p>This will create a capsule shape, which is a quick way to simulate player characters. Also, we picked a collision shape that would go well with the mesh we created. Since there isn’t much to look at in the <strong class="source-inline">Player.tscn</strong> scene, it may be best if we show you where to place it in the world. Create an instance of it in <strong class="source-inline">Level-01.tscn</strong>, and position it as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer156">
<img alt="Figure 12.10 – An upright pill-shaped player character " height="608" src="image/Figure_12.10_17473.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – An upright pill-shaped player character</p>
<p>The player<a id="_idIndexMarker583"/> character, although it looks like a pill standing up right now, is now part of the world and ready to move around. It just needs to be told where to go. How can we give it instructions before even we know where it’s supposed to go? To solve this mystery, we will have to prepare a structure to catch clicks. All this will eventually lead us to revisit a topic we dismissed earlier in the <em class="italic">Detecting user input</em> section: raycasting. After all, it will help us know where the player clicked in the world.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor219"/>Preparing a clickable area for raycasting</h2>
<p>When you <a id="_idIndexMarker584"/>know exactly which objects should be <a id="_idIndexMarker585"/>interactive and receive mouse events, the method we applied in the <em class="italic">Distinguishing useful mouse events</em> section is still valid. It entails anticipation on the game designer’s end, so the essential bindings could be done early on, as we saw. However, what if it wasn’t always possible to foresee this, or how viable would that method be on a larger scale?</p>
<p>For example, if we were to add a <strong class="bold">StaticBody</strong> node to each floor model we have used so far, we could certainly detect mouse clicks. That being said, sometimes, it’s a bit too late for that. Right now, our level has all the floor pieces as model instances instead of scene instances because, back then, it was convenient to drop the models and be done with the level design. We could still try to create a scene out of a floor model, but you’d still have to swap all the floor assets in the level. It’s a lot of work.</p>
<p>Since we already know that a <strong class="bold">StaticBody</strong> node is necessary to initiate an input response, we may yet use it to our advantage. Instead of attaching it to every single floor piece, we could designate an area as large as what all the floor pieces occupy, and detect the clicks on this large piece. Here’s how to do this:</p>
<ol>
<li value="1">Add a <strong class="bold">StaticBody</strong> node to the level and place a <strong class="bold">CollisionShape</strong> node inside this <strong class="bold">StaticBody</strong> node.</li>
<li>Assign a <strong class="bold">New BoxShape</strong> to the <strong class="bold">Shape</strong> field in the <strong class="bold">Inspector</strong> panel. </li>
<li>Expand this new property and adjust its <strong class="bold">Extents</strong> setting. We used values such as <strong class="source-inline">9</strong>, <strong class="source-inline">1</strong>, and <strong class="source-inline">8</strong> but you might want to adjust these values after you finish the next step.</li>
<li>Position<a id="_idIndexMarker586"/> the <strong class="bold">StaticBody</strong> node in the level so<a id="_idIndexMarker587"/> that the following applies:<ol><li>Its <strong class="bold">Y</strong> coordinate is roughly <strong class="source-inline">-1.05</strong>. Adjust it to a value so that its top almost aligns with the floor but just below the parchment. We’ll discuss this after we finish moving the player.</li>
<li>Its <strong class="bold">X</strong> and <strong class="bold">Z</strong> values are at a point where its child, <strong class="bold">CollisionShape</strong>, encompasses the floor pieces and the walkable areas on the pier.</li>
</ol></li>
</ol>
<p>It might be easier to decide on the measurements if you switch to the <strong class="bold">Top Orthographic</strong> view. The blue square in the following screenshot represents the area we want to use as a click detector:</p>
<div>
<div class="IMG---Figure" id="_idContainer157">
<img alt="Figure 12.11 – The StaticBody node covers all walkable areas " height="777" src="image/Figure_12.11_17473.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – The StaticBody node covers all walkable areas</p>
<p>You might be <a id="_idIndexMarker588"/>wondering if we overdid it with the detection<a id="_idIndexMarker589"/> area since <em class="italic">Figure 12.11 </em>clearly shows it is way larger than the walkable areas. A short explanation is that when you click on areas outside the traversable field, the pathfinding algorithm will take the player to a nearby spot but never to the exact position the player clicked. For example, if you click in the water, then the player character will move to the clicked spot as close as possible but still stay within the limits.</p>
<p>When you get to see the code, things might make more sense from a technical point of view. With that said, let’s attach some code to the player character so that it can move around, as follows:</p>
<ol>
<li value="1">Open <strong class="source-inline">Player.tscn</strong> and select the root node.</li>
<li>Attach <strong class="source-inline">Player.gd</strong> from the <strong class="source-inline">Scripts</strong> folder to the <strong class="bold">Script</strong> field in the <strong class="bold">Inspector</strong> panel.</li>
</ol>
<p>Let’s explain the most important parts of the code we have just applied. You can refer to this code block at <a href="https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot/blob/main/Chapter%2012/Resources/Scripts/Player.gd">https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot/blob/main/Chapter%2012/Resources/Scripts/Player.gd</a>. The first 10 lines are for storing some of the startup values and structures we are going to use. Three of those variables are worth a thorough explanation since the rest is self-explanatory. Let’s look at them in more detail here:</p>
<ul>
<li><strong class="source-inline">camera</strong>: The player scene has no <strong class="bold">Camera</strong> node, but it needs to access a camera to do the raycasting. So, we appropriate the currently used camera as a workaround.</li>
<li><strong class="source-inline">space_state</strong>: This is our entryway to Godot’s <strong class="bold">PhysicsServer</strong> node that monitors which objects collide or intersect with each other. We’re going to use this variable to know if a click connects with the floor.</li>
<li><strong class="source-inline">nav</strong>: Since the <strong class="bold">Player</strong> node will be part of the <strong class="source-inline">Level-01.tscn</strong> scene that also holds the <strong class="bold">Navigation</strong> node, we use a mechanism like this to inject the <strong class="bold">Navigation</strong> node into the <strong class="bold">Player</strong> node. This way, the <strong class="bold">Player</strong> node can query the <strong class="bold">Navigation</strong> node to find a possible path.</li>
</ul>
<p>The rest of the <a id="_idIndexMarker590"/>script consists of four functions. Despite <a id="_idIndexMarker591"/>that, two of those functions are doing the heavy lifting because the <strong class="source-inline">_input</strong> and <strong class="source-inline">_physics_process</strong> methods are essentially offloading their tasks to two other functions: <strong class="source-inline">find_path</strong> and <strong class="source-inline">move_along</strong> respectively. We could have ignored these latter functions, but when you are able to separate distinct functionality into their own functions, you should do this to keep your code clean.</p>
<p>All of this was done so that we could do a raycasting that is implemented in the <strong class="source-inline">find_path</strong> function, which is what we are going to study next.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor220"/>Using Navigation node for pathfinding</h2>
<p>The large <strong class="bold">StaticBody</strong> node <a id="_idIndexMarker592"/>we’ve added to the scene is still not<a id="_idIndexMarker593"/> enough to know at which point on the floor the click happened. Having just that will only let us know that the player clicked somewhere in that area. So, in the end, we are still going to use raycasting for finding the precise location so that we can begin constructing a path toward this position.</p>
<p>To that end, the <strong class="source-inline">find_path</strong> function in the <strong class="source-inline">Player.gd</strong> script is going to use the following two techniques: </p>
<ul>
<li>First is raycasting, to know exactly where the player clicked </li>
<li>Second is whether there is a possible path toward that position</li>
</ul>
<p>The first three lines of code in the <strong class="source-inline">find_path</strong> function, as shown here, are what raycasting is about:</p>
<pre class="source-code">var from = camera.project_ray_origin(event.position)
var to = from + camera.project_ray_normal(event.position) * 100
var result = space_state.intersect_ray(from, to)</pre>
<p>Firstly, we ask the camera system to tell us from where the ray is going to originate. Hence, we store it in the <strong class="source-inline">from</strong> variable. This happens to be where the mouse event happened. Keep in mind, though that this event is still on our monitor’s 2D surface. There is still no notion of where we are clicking in the 3D world.</p>
<p>Secondly, we ask the camera system to let us know where a ray would go if we projected it <strong class="source-inline">100</strong> units <strong class="source-inline">from</strong> into the world. Now, we know where <strong class="source-inline">to</strong> stretch the ray. Still, there is no guarantee that this ray will hit anything. Thus, we check if anything is intersecting the ray, and store it in the <strong class="source-inline">result</strong> variable.</p>
<p>So, in just three lines of code, we determined a line between where we clicked on our screen and a position in the world. The result of this raycasting might be empty, so it would be prudent to check if there is an object colliding with our ray. Only then can we proceed with finding a path.</p>
<p>This is where the <strong class="source-inline">nav</strong> variable<a id="_idIndexMarker594"/> comes into play. Since it’s a reference<a id="_idIndexMarker595"/> to the <strong class="bold">Navigation</strong> node in the level that knows the player’s position and where the player wants to go next, it calculates a simple path between these two spots. Ultimately, a series of 3D coordinates are stored in the <strong class="source-inline">path</strong> array.</p>
<p class="callout-heading">Separation issues</p>
<p class="callout">In a situation such as the pathfinding operation requiring a raycasting done in the <strong class="source-inline">find_path</strong> function—in other words, when two systems are closely related to each other—it might be okay not to separate the raycasting logic into its own function. We’ll revisit this concept later when we work on a more advanced game character in the <em class="italic">Triggering animations</em> section.</p>
<p>Sooner or later, you’ll have a walkable path, although this doesn’t automatically make the player character follow a path. We’ll need several more lines of code to do that. </p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor221"/>Moving the player to their desired spot</h2>
<p>We have used raycasting to <a id="_idIndexMarker596"/>detect a spot where the player wants to go and queried the <strong class="bold">Navigation</strong> node to find the closest path to this desired spot. We are now ready to instruct the <strong class="bold">Player</strong> node to move between different points along the path. </p>
<p>The <strong class="source-inline">move_along</strong> function in the <strong class="source-inline">Player.gd</strong> script receives a path and processes it one step at a time. Since it’s unlikely to have a straightforward path between the start and end points, the path will be composed of a series of midpoints before the player reaches their last stop. It’s like walking in real life where you make course corrections before you arrive at your destination. Naturally, if the path is empty or all of its steps have been processed, we terminate the function early. </p>
<p>Otherwise, we move the player between two stops by checking if the distance to the next step is within a certain threshold. Speaking of this threshold, this might be a good moment to talk about a caveat. During the writing and testing of this code, we had moments where the threshold value should have been <strong class="source-inline">3</strong>, or sometimes, <strong class="source-inline">1</strong>. You might want to experiment with a different value if you notice the player character is behaving awkwardly. This is something that will be remedied in later versions of Godot, as is noted in the official documentation:</p>
<p class="author-quote">The current navigation system has many known issues and will not always return optimal paths as expected. These issues will be fixed in Godot 4.0.</p>
<p>After all this hard work, we are now one step away from having the player character move around, so let’s carry on with this, as follows:</p>
<ol>
<li value="1">Switch to <strong class="source-inline">Level-01.tscn</strong> and select the <strong class="bold">Player</strong> node.</li>
<li>Using the <strong class="bold">Inspector</strong> panel, click the <strong class="bold">Assign…</strong> button in its <strong class="bold">Nav</strong> field to select the <strong class="bold">Navigation</strong> node in the upcoming pop-up screen.</li>
<li>Press <em class="italic">F5</em> and click on different spots in the level.</li>
</ol>
<p>When we test the scene and move the character away from the pier, this is what it looks like:</p>
<div>
<div class="IMG---Figure" id="_idContainer158">
<img alt="Figure 12.12 – The player character can now move in the world " height="600" src="image/Figure_12.12_17473.jpg" width="1526"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – The player character can now move in the world</p>
<p>You now must<a id="_idIndexMarker597"/> be able to move the player character around by pressing on the floor or even in the water. The nearest spot will be picked as a destination. Also, while you are moving around, try to click the parchment on the pier. If it is placed just so it’s below the catch-all <strong class="bold">StaticBody</strong> node, then you won’t be able to trigger the note. If that’s the case, either adjust the <strong class="bold">Y</strong> position you set in the <em class="italic">Preparing a clickable area for raycasting</em> section for the <strong class="bold">StaticBody</strong> node or move the <strong class="bold">Parchment</strong> node up in the <strong class="bold">Y</strong> direction. </p>
<p>As long as the clicks are not competing, the parchment will trigger the note. If the player character is away, it will then move near the parchment as soon as the note is open. You might notice odd behavior at this point if you click the <strong class="bold">Close</strong> button. The note will close as expected, but the player character will suddenly move just under where the <strong class="bold">Close</strong> button was. It’s as if the note UI is letting some of our clicks through and the pathfinding logic picks up <a id="_idIndexMarker598"/>that call.</p>
<p>Fortunately, there is a quick fix for this kind of behavior. If you replace the <strong class="source-inline">_input</strong> function with <strong class="source-inline">_unhandled_input</strong>, then all will be well. If these two look alike and unclear, you might want to find their nuances in the manual: <a href="https://docs.godotengine.org/en/3.4/classes/class_node.xhtml">https://docs.godotengine.org/en/3.4/classes/class_node.xhtml</a>. It might be worth remembering its use for quickly fixing a lot of UI headaches.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor222"/>Wrapping up</h2>
<p>If you have been developing video games for a while, you might already be familiar with the notion of iterative and incremental workflow. For example, it’s been okay to have indestructible crates so far. Let’s examine a scenario where you now want these crates to be destructible.</p>
<p>Not only do you have to account for certain conditions to happen, such as if the player has the right item to break the said crates, but you will also have to prepare animations to be triggered at the moment of destruction. These are both programmatical and artistic changes, and they can definitely be done with ease to a certain extent. When you <em class="italic">baked</em> the walkable areas, the <strong class="bold">Navigation</strong> node believed the crates were solid obstacles. However, in this new dynamic situation, you also have to update the <strong class="bold">NavigationMeshInstance</strong> node with the new conditions. </p>
<p>If a crate the player has just destroyed is no longer part of the world, and that particular area should indeed be walkable, you have to update the walkable areas by baking a new map. Fortunately, it’s possible to create multiple <strong class="bold">NavigationMeshInstance</strong> resources and save them on the disk so that you can swap them to accommodate dynamic cases as needed.</p>
<p>Sometimes, it makes more sense to move ahead with prototypes. For instance, it was good enough to have our player character look like a capsule to test movement logic. It would be nice to have our avatar look more like a person than a white pill. Let’s see how we can accomplish that next.</p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor223"/>Triggering animations</h1>
<p>In <a href="B17473_05.xhtml#_idTextAnchor075"><em class="italic">Chapter 5</em></a>, <em class="italic">Setting Up Animation and Rigging</em>, we tackled the creation of animations in Blender. Then, in <a href="B17473_07.xhtml#_idTextAnchor112"><em class="italic">Chapter 7</em></a>, <em class="italic">Importing Blender Assets into Godot</em>, we saw how to <a id="_idIndexMarker599"/>import a model into Godot Engine and use the <strong class="bold">AnimationPlayer</strong> node to test the model’s different actions. The steps we’ll present in this section should be enough to introduce Clara to the game, but if you need a reminder on how to create and import animations, you might want to seek out those two chapters.</p>
<p>Since we are done with the player’s movement, what is missing is to introduce Clara to our workflow and play the proper actions, such as idling while she’s standing and walking while she is moving around. </p>
<p>We’ve already created a <a id="_idIndexMarker600"/>basic player character when we constructed <strong class="source-inline">Player.tscn</strong> and attached a script to this scene. It’s primitive but the scene structure is a good starting point. Follow these steps:</p>
<ol>
<li value="1">Click <strong class="source-inline">Clara.glb</strong> in <strong class="bold">FileSystem</strong>, then bring up the <strong class="bold">Import</strong> panel. </li>
<li>Select <strong class="bold">Files (.anim)</strong> in the <strong class="bold">Storage</strong> dropdown under the <strong class="bold">Animation</strong> header. Refer to the <em class="italic">Separating actions</em> section from <a href="B17473_07.xhtml#_idTextAnchor112"><em class="italic">Chapter 7</em></a>, <em class="italic">Importing Blender Assets into Godot</em>, to remember the need for this step.</li>
<li>Press <strong class="bold">Reimport</strong> to set up Clara’s dependencies properly. Switch to the <strong class="bold">Scene</strong> panel.</li>
<li>Open <strong class="source-inline">Player.tscn</strong> and delete the <strong class="bold">MeshInstance</strong> node. </li>
<li>Drag <strong class="source-inline">Clara.glb</strong> from <strong class="bold">FileSystem</strong> onto the <strong class="bold">Player</strong> node. Thus, the old <strong class="bold">MeshInstance</strong> node will be replaced with a <strong class="bold">Clara</strong> node.</li>
<li>Click the root node and zero its <strong class="bold">Translation</strong> values since the values that applied to the basic capsule-shaped player are no longer valid.</li>
<li>Adjust the <strong class="bold">CollisionShape</strong> node’s <strong class="bold">Shape</strong> field in the <strong class="bold">Inspector</strong> panel so that it encapsulates Clara. We haven’t changed the <strong class="bold">Radius</strong> setting but set its <strong class="bold">Height</strong> value to <strong class="source-inline">1.2</strong>. </li>
</ol>
<p>The main goal here is to replace the old <strong class="bold">MeshInstance</strong> node with Clara and adjust the <strong class="bold">CollisionShape</strong> node so that collision detection is done correctly. The editor should now look like this: </p>
<div>
<div class="IMG---Figure" id="_idContainer159">
<img alt="Figure 12.13 – Clara has replaced the boring MeshInstance node " height="593" src="image/Figure_12.13_17473.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Clara has replaced the boring MeshInstance node</p>
<p>With this method, you can <a id="_idIndexMarker601"/>easily test your code for a player character, and then replace the test model with the actual model later. This might be useful if you are the main developer and you are still waiting for the artwork from your colleagues. </p>
<p>Improving the looks of the avatar was a good step forward. It’s looking much more appealing. We will do the same for its movement because you might notice odd behavior if you run the game now. Clara will be moving around like the old capsule mesh because it’s missing two major qualities, as follows:</p>
<ul>
<li>Looking in the direction it’s currently moving</li>
<li>Showing signs of walking instead of looking like a stick sliding on surfaces</li>
</ul>
<p>There is also another problem but it’s so minor you can fix it without needing much discussion and explanation. The <strong class="bold">Player</strong> node, which used to hold the simple <strong class="bold">MeshInstance</strong> node, had to be moved slightly higher in the world. You can lower this new <strong class="bold">Player</strong> node to the level of the pier so that Clara’s feet are connecting with it. If you don’t make any changes, Clara will look like she’s hovering and then moving diagonally as soon as her movement logic kicks in.</p>
<p>For the other two major concerns, we’ll have to dig deeper than just changing an object’s position. We’ve got to first update the script we are using for the <strong class="bold">Player</strong> node, though, so here’s what we need to do:</p>
<ol>
<li value="1">Select the root node in <strong class="source-inline">Player.tscn</strong>.</li>
<li>Swap its script with <strong class="source-inline">Clara.gd</strong> from the <strong class="source-inline">Scripts</strong> folder.</li>
<li>Press <em class="italic">F5</em> and enjoy seeing Clara walking around as a normal person should.</li>
</ol>
<p>Rejoice—she’s walking! </p>
<p>How did it <a id="_idIndexMarker602"/>happen so quickly? We will devote the rest of this section to discovering which changes the <strong class="source-inline">Player.gd</strong> script has received to accommodate the new behavior we are experiencing and—undoubtedly—enjoying. </p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor224"/>Understanding how Clara looks around</h2>
<p>An incremental and iterative workflow is the short and non-technical answer to understanding how Clara looks around, and it’s something we advise you to keep in mind when tasks seem monumentally big at first. For example, we were initially concerned with basic movement, which was achieved within the <strong class="source-inline">Player.gd</strong> script. At some point, when you know basic test systems are working, it’s time to take things to the next level. That’s what happened with the <strong class="source-inline">Clara.gd</strong> script.</p>
<p>We’ll now explain the steps we have taken to turn the basic sliding movement into a more elaborate walking animation. As far as having new variables is concerned, we are using a simple flag: <strong class="source-inline">is_moving</strong>. We keep track of this flag in order to understand whether Clara is moving or not. The use of this new variable will soon be discussed in the context of some other changes we have made. </p>
<p class="callout-heading">New term – flag</p>
<p class="callout">In the programming world, a flag is a variable that means a certain condition has been satisfied. It’s often used to determine a system’s behavior, like an electric switch with a false/true or off/on states, hence they are often <a id="_idIndexMarker603"/>called <strong class="bold">Boolean</strong> flags. However, it is possible for a flag to have different kinds of predetermined values.</p>
<p>A natural behavior for Clara would be to look in the direction the mouse cursor is. Let us remind you, once more, that although the cursor is moving over our monitor’s 2D surface, we need to do essential projections into the 3D space to find the proper direction. We were already doing that in the <strong class="source-inline">find_path</strong> function inside the <strong class="source-inline">Player.gd</strong> script. Since we now want a similar raycasting done for determining where Clara is supposed to look, we extracted those common lines from <strong class="source-inline">find_path</strong> to its own function, <strong class="source-inline">get_destination</strong>.</p>
<p>Hence, the more common uses and repetitions you can find in your code, the better it is to separate them into their own functions. This was something we intentionally ignored in the <strong class="source-inline">Player.gd</strong> case for simplicity’s sake. However, we now have both the <strong class="source-inline">find_path</strong> and <strong class="source-inline">turn_to</strong> functions depending on <strong class="source-inline">get_destination</strong>.</p>
<p>Just as <strong class="source-inline">find_path</strong> is piggybacking on the <strong class="source-inline">_unhandled_input</strong> function, the <strong class="source-inline">turn_to</strong> function is also using the same mouse <strong class="source-inline">event</strong>. Speaking of the <strong class="source-inline">turn_to</strong> function, let’s take a closer look at it here:</p>
<pre class="source-code">func turn_to(event):
    if is_moving:
        return
   
    var direction:Vector3 = get_destination(event) * 
    Vector3(1,0,1) + Vector3(0, global_transform.origin.y, 
    0)
    look_at(direction, Vector3.UP)</pre>
<p>First of all, although we haven’t yet seen where the <strong class="source-inline">moving</strong> flag is set, if Clara is moving, we wouldn’t want her to keep looking around. So, we have an early <strong class="source-inline">return</strong> statement to terminate the turning behavior. Then, once we determine a suitable direction via the <strong class="source-inline">get_destination</strong> function, we trigger Godot’s built-in <strong class="source-inline">look_at</strong> method.</p>
<p>The logic is simple, but the math to determine the <strong class="source-inline">direction</strong> vector in <strong class="source-inline">turn_to</strong> might need a bit more explanation. Normally, the value from <strong class="source-inline">get_destination</strong> would have been enough, but we seem to be multiplying the return value with another vector and then adding it to another vector. This is because the destination given by <strong class="source-inline">get_destination</strong> also includes the <em class="italic">y</em> axis in the 3D space. We want Clara to keep her posture the same; in other words, we don’t want her to look up or down. Those two vector operations are required so that she doesn’t rotate in an awkward way. </p>
<p>You can see the weird behavior yourself by removing the vector operations and only keeping the <strong class="source-inline">get_destination</strong> function. When you move your mouse cursor near Clara’s body, she may suddenly pivot around her feet and sometimes even flip upside down or sideways. The intricacies due to projections between 2D and 3D are something you’ll have to account for in the future, and it’s a common occurrence in controlling game characters. </p>
<p>It’s nice that Clara is facing where the mouse cursor is. It’s also a separate mechanism because she can do so without moving, as you may have already tested with the preceding code block. It would be nice if she kept looking where she was going while walking. This will be done in the enhanced version of the <strong class="source-inline">move_along</strong> function. Let’s see how we improved it in this new version. </p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor225"/>Adding a looking behavior to moving functionality</h2>
<p>It is nice to see<a id="_idIndexMarker604"/> Clara looking around while<a id="_idIndexMarker605"/> she’s standing still, but we will also want her to face the destination she’s walking to. For example, if you click near the crates by the wall (more like the right-hand side of the screen), she should walk straight until she clears the pier, then turn and look right, and then keep walking. Similarly, while she’s in this new spot, if you click somewhere far away such as near the stag statue or the pier again, she should turn around and walk back in a natural way.</p>
<p>This kind of behavior can easily be added inside the <strong class="source-inline">move_along</strong> function. The way it is, that function already determines how many steps there are left along the path Clara should take. As she’s walking toward the point on the path, she may as well look at where she is going. That’s why we have a simple <strong class="source-inline">look_at</strong> function call after <strong class="source-inline">move_and_slide</strong> in the <strong class="source-inline">move_along</strong> function.</p>
<p class="callout-heading">Other useful KinematicBody functions</p>
<p class="callout">We have been using the built-in <strong class="source-inline">move_and_slide</strong> function of the <strong class="source-inline">KinematicBody</strong> class. There is a useful function in the same class that might be helpful in levels where the player would like to reach an elevated location by following a slope: <strong class="source-inline">move_and_slide_with_snap</strong>. Similarly, you might want to check whether the player should perform the next move. If that is the case, the <strong class="source-inline">test_move</strong> method might be handy.</p>
<p>Also, the fate of <strong class="source-inline">is_moving</strong> gets decided in the following lines of code:</p>
<pre class="source-code">if !path or path_index == path.size():
    is_moving = false
    $Clara/AnimationPlayer.play("Idle")
    return
is_moving = true</pre>
<p>Notice that, similar to how we do it in <strong class="source-inline">Player.gd</strong>, the <strong class="source-inline">if</strong> block checks whether there are steps left along the path. It’s exactly at this point we can set the state of the <strong class="source-inline">is_moving</strong> flag. Consequently, unlike the original version, the new <strong class="source-inline">move_along</strong> function’s <strong class="source-inline">if</strong> block is making sure the moving logic is turned off when there is no path left for Clara to walk. </p>
<p>If the player clicks <a id="_idIndexMarker606"/>a different spot and there is a<a id="_idIndexMarker607"/> new path determined, then we turn on the moving flag. As long as there are midpoints for Clara to follow, she’ll follow the same steps we’ve described—face the right direction, walk the necessary distance, face the next direction, walk, rinse, and repeat—until she no longer has any more steps to take.</p>
<p>Besides deciding on the state of the <strong class="source-inline">is_moving</strong> flag, there is something else going on in that <strong class="source-inline">if</strong> block in regard to animations. Let’s focus on that in the next part.</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor226"/>Playing the right action for Clara</h2>
<p>We’ve<a id="_idIndexMarker608"/> already seen how actions are related to animations in the <em class="italic">Separating actions</em> section of <a href="B17473_07.xhtml#_idTextAnchor112"><em class="italic">Chapter 7</em></a>, <em class="italic">Importing Blender Assets into Godot</em>. They are like what atoms are to molecules. So, when we want to trigger an animation for a model, we actually mean to trigger a particular action. We’ll finally utilize this notion and put Clara in action.</p>
<p>We have seen how the improvements we made to the <strong class="source-inline">Player.gd</strong> script have added extra flavor to Clara’s behavior. That being said, she could also benefit from a touch-up in the animation department. That’s precisely what’s also happening inside the <strong class="source-inline">move_along</strong> function. </p>
<p>We already know how to determine whether Clara should move or not, and we are keeping track of that with the <strong class="source-inline">is_moving</strong> flag. Subsequently, that’s the right moment to trigger the required action for her. Thus, when she’s no longer supposed to move, we trigger her <strong class="bold">Idle</strong> action. Conversely, the <strong class="bold">Walk</strong> action is activated when <strong class="source-inline">is_moving</strong> is set to <strong class="source-inline">true</strong>. </p>
<p>When we made <strong class="source-inline">Clara.glb</strong> part of the <strong class="source-inline">Player.tscn</strong> scene, and it turned into a <strong class="bold">Clara</strong> node, an <strong class="bold">AnimationPlayer</strong> node already came within it with all of Clara’s actions set up. The code we have written so far is aware of exactly where this <strong class="bold">AnimationPlayer</strong> node is in the internal structure. Should you import a different model with a different <strong class="bold">Scene</strong> tree, then you might have to alter your code to find the right path to the <strong class="bold">AnimationPlayer</strong> node.</p>
<p>It’s hard to c<a id="_idIndexMarker609"/>onvey an animation via the static pages of a book, but when we move Clara near the column approaching our camera, this is what it looks like:</p>
<div>
<div class="IMG---Figure" id="_idContainer160">
<img alt="Figure 12.14 – Clara can now move around the level " height="676" src="image/Figure_12.14_17473.jpg" width="1299"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – Clara can now move around the level</p>
<p>Also, notice how the light conditions in the scene are affecting her model when she walks in darker and brighter spots. In the next chapter, we’ll turn off some of the light sources. So, as she or the player is walking around, we can use the torch she’s holding to illuminate the scene.</p>
<p>We couldn’t finish the animation topic without mentioning an advanced subject: blending animations. We will not cover it in great detail, but it is worth mentioning it for more advanced cases of animations you would like to use in your projects.</p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor227"/>Blending animations or actions</h2>
<p>After a while, the<a id="_idIndexMarker610"/> names that are used in most computer-related things may start<a id="_idIndexMarker611"/> to seem like they have something to do with each other. We used Blender in the first several chapters to build assets, textures, animations, and likewise. The blending we are now going to talk about has nothing to do with Blender itself.</p>
<p>Our point-and-click adventure game is very simple so far. Clara plays the <strong class="bold">Idle</strong> action while she’s standing still, and she uses the <strong class="bold">Walk</strong> action when she’s moving. Although her model contains other actions such as <strong class="bold">Death</strong>, <strong class="bold">Run</strong>, and likewise, we aren’t going to use those. If you want to take this project and move it further, you can accommodate different needs a player may have by improving the <strong class="source-inline">Clara.gd</strong> script and incorporate these other actions.</p>
<p>At some point, when you have a much more complex system where the actions you are triggering come to an end to give room to another action, you may notice that these actions abruptly start and end. Then, imagine how the crossfade functionality in an audio player makes the whole experience more pleasant when a song track changes to another. What if you had a way to transition the end of an action smoothly to the beginning of the next action? You can easily achieve that for animations with the <strong class="bold">AnimationTree</strong> node.</p>
<p>Unfortunately, the page count is limited for us to cover such an advanced topic. That being said, the official documentation has a nice and long tutorial page dedicated to this very subject. It also comes with plenty of animated GIFs that you can’t possibly experience on the static pages of a book. So, in the end, you might be better off exploring how to blend animations by following the instructions at <a href="https://docs.godotengine.org/en/3.4/tutorials/animation/animation_tree.xhtml">https://docs.godotengine.org/en/3.4/tutorials/animation/animation_tree.xhtml</a>.</p>
<p>Blending animations is heavily used in high-pace action games when transitioning between different attack and run states should look more seamless. In our current situation, we are not missing out much by not having this kind of functionality.</p>
<p>We have made great strides so far in our point-and-click adventure game. Let’s wrap up and count our victories.</p>
<h1 id="_idParaDest-227"><a id="_idTextAnchor228"/>Summary</h1>
<p>This chapter finally covered the long-due camera topic we’ve been waiting to tackle since <a href="B17473_04.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Adjusting Cameras and Lights</em>. You now have multiple options to choose from, from a simple <strong class="bold">Camera</strong> type to an <strong class="bold">InterpolatedCamera</strong> type that follows a target. Should you want to get fancy and dip your toes in VR, you also have <strong class="bold">ARVRCamera</strong> at your disposal.</p>
<p>As you now had a proper camera showing you the game world as opposed to seeing things within the editor, it was the right time to investigate how to interact with the world itself. To that end, we presented <strong class="bold">raycasting</strong> as a possible solution but quickly dismissed it in favor of using collision detection, which provides more flexibility and precision. We used this technique to detect a click on a specific game object: a parchment. During this effort, you used <strong class="bold">signals</strong> as a way of interpreting the player’s click as a trigger to turn on the note.</p>
<p>Next, you looked into creating a simple game character and moving it around the level. Sometimes, the game design is missing key elements, and other times, the level might need some more help. Once you, as a solo developer or as a team, are happy with the direction the game is going, then you can up the ante by introducing more complex systems.</p>
<p>That’s exactly what happened in between testing <strong class="source-inline">Player.gd</strong> and improving it with the more advanced <strong class="source-inline">Clara.gd</strong> script. In the end, you were able to find a suitable position in the world for Clara to move and do this by using the proper animation cycle. Since you’ve covered the essentials, it’s now up to you to enhance the script if you want to use more actions and special conditions for player interaction with the world. </p>
<p>In the next chapter, we’ll introduce a few more tools that will add to the interactivity we have been building, such as playing sounds, conditionally triggering certain events, and switching to another level.</p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor229"/>Further reading</h1>
<p>Although we taught you how to technically set up a camera, there is a whole other artistic side to picking the best camera settings. You might want to check out online courses and books that cover topics such as composition and storytelling. A few examples are provided here:</p>
<ul>
<li><a href="https://www.udemy.com/course/composition-and-perspective-for-stunning-visual-art/">https://www.udemy.com/course/composition-and-perspective-for-stunning-visual-art/</a></li>
<li><a href="https://www.learnsquared.com/courses/visual-storytelling">https://www.learnsquared.com/courses/visual-storytelling</a></li>
<li><a href="https://www.learnsquared.com/courses/production-concept-art">https://www.learnsquared.com/courses/production-concept-art</a></li>
<li><a href="https://www.cgmasteracademy.com/courses/93-composition-for-concept-art-and-illustration/">https://www.cgmasteracademy.com/courses/93-composition-for-concept-art-and-illustration/</a></li>
</ul>
<p>If the code in the <strong class="source-inline">Player.gd</strong> and <strong class="source-inline">Clara.gd</strong> files look very similar, and if it’s hard to compare line by line, there is an online tool you can use that can help you see and highlight the differences: http://www.tareeinternet.com/scripts/comparison-tool/.</p>
<p>Our game doesn’t involve enemy characters that follow our player, but it will follow a similar approach. For example, once the enemy detects the player, it will also have to do pathfinding for finding the player’s position and moving toward it. A lot of video-game AI books cover player detection and seeking topics such as the example we gave. So, since most AI topics are generally universal, don’t shy away from reading a wide variety of material. You can always apply the insight you gain elsewhere later in your Godot projects.</p>
</div>
</div>
</body></html>