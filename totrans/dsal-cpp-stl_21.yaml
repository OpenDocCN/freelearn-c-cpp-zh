- en: '21'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: STL Interaction with Concepts and Coroutines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will explore the interplay between the STL and two of C++’s advanced
    features: concepts and coroutines. This chapter is designed to deepen your understanding
    of how these modern C++ features enhance and interact with the STL.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We begin by learning about concepts, starting with an introduction and progressively
    exploring their role in refining STL algorithm constraints, enhancing data structures,
    and developing custom concepts. This section is crucial for grasping how explicit
    type constraints can lead to more robust and readable code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we focus on coroutines, providing a refresher before examining
    their integration with STL algorithms and data structures. This includes exploring
    potential synergies with ranges and views, culminating in discussing how coroutines
    might herald a paradigm shift in C++ programming.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will provide a comprehensive understanding and practical insights
    into using these features effectively, highlighting their importance in modern
    C++ development and their potential challenges.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Concepts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Concepts
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of concepts in C++20 marked a pivotal step towards safer and
    more expressive templated programming. With their inherent ability to specify
    constraints on template arguments, concepts promise to reshape how we interact
    with and utilize the **Standard Template Library** (**STL**). Let’s discover how
    concepts intertwine with the rich tapestry of STL algorithms and data structures
    to create a more robust and declarative C++ programming paradigm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to concepts
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Concepts** provide a mechanism to specify and check constraints on template
    arguments. Essentially, they allow developers to assert requirements about the
    types passed to a template. Concepts aim to make template errors more readable,
    help avoid common pitfalls, and promote the creation of more generic and reusable
    code.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following concept for an arithmetic type:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using this concept, one can constrain a function only to accept arithmetic
    types:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Refined constraints in STL algorithms
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STL algorithms, historically, have relied on complex, sometimes nebulous requirements
    for their template parameters. With concepts, these requirements become explicit
    and understandable. For instance, the `std::sort` algorithm requires random access
    iterators, which can now be asserted using concepts. This leads to more precise
    error messages if one mistakenly uses a list (which only provides bidirectional
    iterators).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Effectively constraining templates
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with C++ template programming, ensuring that a given type satisfies
    a specific set of requirements has historically been challenging. Before the introduction
    of concepts, developers would rely on complex techniques involving **substitution
    failure is not an error** (**SFINAE**) or specialized trait classes to impose
    type constraints. These methods were verbose and error-prone, often resulting
    in convoluted error messages that were difficult to decipher.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Concepts allow developers to define a set of predicates that a type must satisfy,
    offering a more structured and readable way to constrain templates. Using concepts,
    you can specify the requirements that template arguments must meet. When a type
    does not match the constraints defined by a concept, the compiler will reject
    the template instantiation, producing a more straightforward and more meaningful
    error message. This enhances the template code’s readability, maintainability,
    and robustness. With concepts, the compiler can quickly ascertain the suitability
    of a type for a given template, ensuring that only appropriate types are utilized,
    thereby minimizing the potential for runtime errors or undefined behavior.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a code example that demonstrates the use of concepts and how the same
    task had to be carried out before the introduction of concepts:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the example output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we define a concept called `Printable` using the required clause.
    The `Printable` concept checks if a type can be printed to `std::cout`. We then
    have two function templates, `printValue`, and `printValueSFINAE`, that print
    a value if it satisfies the concept or the SFINAE condition, respectively.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: When using the `printValue` function template with the `Printable` concept,
    the compiler will ensure that the type passed to it can be printed, and if not,
    it will produce a clear error message. This makes the code more readable and provides
    meaningful error messages.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when using the `printValueSFINAE` function template, we rely
    on SFINAE to achieve the same task. This approach is more verbose and error-prone,
    as it involves complex `std::enable_if` constructs and may lead to cryptic error
    messages when the constraints are unmet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: By comparing these two approaches, you can see how concepts improve the readability,
    maintainability, and robustness of C++ template code, making it easier to specify
    and enforce type requirements.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced data structures with explicit requirements
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STL containers, such as `std::vector` or `std::map`, often have their requirements
    for stored types, such as being copy-constructible or assignable. Concepts can
    articulate these requirements with great clarity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a custom container that necessitates its elements to be default constructible.
    This requirement can be eloquently expressed with concepts, ensuring safer and
    more predictable container behavior.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Custom concepts and STL interactions
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the strengths of concepts is that they’re not limited to the ones provided
    by the standard library. Developers can create custom concepts tailored to specific
    needs, ensuring that STL structures and algorithms can be adapted to unique and
    complex scenarios without sacrificing type safety.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if a particular algorithm demands types with a specific interface
    (such as having a `draw()` member function), one can design a concept to enforce
    this, leading to more intuitive and self-documenting code. Let''s look at a code
    example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the example output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code example, we do the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: We define a custom concept called `Drawable`, which requires a type with a `draw()`
    member function returning `void.`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We create two example classes: `Circle`, which satisfies the `Drawable` concept
    by having a `draw()` member function, and `Square`, which does not satisfy the
    concept because it lacks the `draw()` member function.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define a generic function called `drawShape`, which takes a `Drawable` type
    as a parameter and calls its `draw()` member function.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main` function, we create instances of `Circle` and `Square` and demonstrate
    that `drawShape` can be called with a `Drawable` type (e.g., `Circle`) but not
    with a type that does not satisfy the `Drawable` concept (e.g., `Square`).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example illustrates how custom concepts can enforce specific interface
    requirements, ensuring type safety and making the code more intuitive and self-documenting
    when working with complex scenarios and algorithms in C++.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Potential challenges and caveats
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While concepts are undeniably powerful, there are a few considerations to be
    made:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**: Designing intricate custom concepts can be challenging and
    may steepen the learning curve for newcomers'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compile times**: As with most template-based features, over-reliance or misuse
    can increase compilation times'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backward compatibility**: Older codebases may require refactoring to leverage
    or comply fully with new concept-driven constraints'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section provided a window into a powerful feature in C++ that allows us
    to specify constraints on template parameters. We began with a brief introduction
    to concepts, understanding their role in enhancing the expressiveness and safety
    of our code. We then explored how refined constraints can be applied in STL algorithms,
    leading to more robust and readable code. We also learned how to constrain templates
    effectively, which is crucial for preventing the misuse of our code and ensuring
    that it behaves as expected.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: However, we also acknowledged the potential challenges and caveats associated
    with concepts. While they offer many benefits, using them judiciously is important
    to avoid unnecessary complexity and potential pitfalls.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The knowledge gained from this section is invaluable as it equips us with the
    tools to write safer, more expressive, and more efficient code using the STL.
    It also prepares us for the next section, where we will explore another exciting
    feature of C++: coroutines.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The next section will refresh our understanding of coroutines and discuss their
    integration with STL algorithms and data structures. We will also explore potential
    synergies with ranges and views, which can lead to even more efficient and elegant
    code. Finally, we will look at how coroutines represent a paradigm shift in how
    we write asynchronous code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The integration of coroutines into C++20 ushers in a new paradigm for asynchronous
    programming that’s more readable and intuitive. By allowing functions to be suspended
    and resumed, coroutines offer an alternative to the callback-heavy style often
    seen in asynchronous C++ code. While transformative in its own right, this evolution
    also provides fresh, innovative ways to interact with the venerable STL. Examining
    the interaction of coroutines with STL algorithms and data structures reveals
    how they simplify asynchronous operations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Understanding coroutines – a refresher
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `co_await`, `co_return`, and `co_yield`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`co_await`: Suspends the current coroutine until the awaited expression is
    ready, at which point the coroutine resumes'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`co_return`: This is used to finish the coroutine, potentially returning a
    value'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`co_yield`: Produces a value in a generator-like fashion, allowing iteration
    over a coroutine'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STL algorithms and coroutine integration
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With coroutines, STL algorithms that previously demanded a more convoluted asynchronous
    approach can now be elegantly written with direct, linear logic. Consider algorithms
    that operate on sequences or ranges; they can be combined with coroutines to asynchronously
    generate values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a coroutine could asynchronously produce values and then process
    them using `std::transform` or `std::for_each`, weaving asynchronous code seamlessly
    with synchronous STL algorithms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines and STL data structures
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The magic of coroutines also touches the realm of STL data structures. Coroutines
    present an intriguing potential for containers such as `std::vector` or `std::list:`
    `populating` (asynchronously).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where data must be fetched from a network source and stored
    in `std::vector`. A coroutine can be used to fetch the data asynchronously, yielding
    values as they arrive, and then these values can be directly inserted into the
    vector. This blend of asynchronicity with the directness of STL data structures
    simplifies code and reduces cognitive overhead.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Potential synergies with ranges and views
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the C++ language evolves, other features, such as ranges and views, combined
    with coroutines, can offer a more expressive way to handle data manipulation and
    transformation. Coroutines can generate ranges, which can be lazily evaluated,
    filtered, and transformed using views, resulting in a robust and composable asynchronous
    programming model.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following code example that involves the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`std::vector<int>` to store a sequence of numbers.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coroutine**: A generator that asynchronously generates numbers to populate
    our vector.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::ranges::copy_if`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::views::transform`, we’ll multiply each number by two. First, we must
    create our `generator` class with a special `promise_type` structure that our
    coroutine will use. The generator class template and its nested `promise_type`
    structure in this code are key components in implementing a coroutine for generating
    a sequence of values in C++.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `T`, one at a time, upon request. It encapsulates the coroutine’s state and
    provides an interface to control its execution and access the yielded values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'The `promise_type` nested within the generator is the coroutine’s lifecycle
    and state management backbone. It holds the current value to be yielded (value)
    and defines several key functions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`get_return_object`: Returns the generator object associated with this coroutine'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initial_suspend` and `final_suspend`: Control the coroutine’s execution, suspending
    it initially and after completion'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unhandled_exception`: Defines behavior for unhandled exceptions, terminating
    the program'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return_void`: A placeholder for when the coroutine reaches its end'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yield_value`: This is called when a value is yielded (co_yield), suspending
    the coroutine and storing the yielded value'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code example below is broken into several sections (the complete example
    can be found in the book''s GitHub repository):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code defines a generic template class called `generator`. This
    class is instantiated as the return type of the `generate_numbers` function, which
    creates a sequence of integers from start to end. When called, it initiates a
    coroutine that iteratively yields integers within the specified range. Each iteration
    suspends the coroutine, making the current value available to the caller. The
    generator class provides mechanisms to resume the coroutine (`next()`) and retrieve
    the current value (`value()`). The generator’s constructor, move constructor,
    destructor, and deleted copy constructor manage the coroutine’s lifecycle and
    ensure proper resource management.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'That was the hard part. Now, we can get to work building and using our coroutine:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the example output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we did the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: We created a `generator` class to represent asynchronous generators.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the coroutine `generate_numbers` to asynchronously generate numbers
    from 1 to 10.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With ranges, we filtered only even numbers and stored them in another vector.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using views, we transformed these even numbers by multiplying them by two.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we output the transformed sequence.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking ahead – a paradigm shift
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coroutines in C++ represent a significant advancement in the domain of asynchronous
    programming. By introducing a standardized way to handle asynchronous tasks, coroutines
    facilitate writing nonblocking, efficient, and maintainable code. When used in
    conjunction with the STL, coroutines have the potential to streamline complex
    operations, transforming the landscape of C++ programming.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The STL provides a robust framework for data manipulation and algorithm implementation.
    The introduction of coroutines enhances this framework by offering a concurrency
    model that is less error-prone and more intuitive than traditional threading mechanisms.
    This synergy allows for developing sophisticated asynchronous programs to leverage
    the full power of the STL’s containers, iterators, and algorithms without compromising
    performance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: As coroutines become more integrated within the STL, we anticipate a paradigm
    shift where high-performance code will not only be characterized by its speed
    but also by its clarity and modular structure. The adoption of coroutines is poised
    to expand, driven by their ability to produce scalable and responsive software.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The future iterations of the C++ standard will likely introduce more features
    that complement the coroutine–STL interface, providing developers with a richer
    toolkit. This evolution will solidify C++’s role as a premier language for developing
    high-performance, asynchronous applications. The commitment to continual improvement
    within the C++ community maintains the language’s relevance and efficacy in solving
    modern programming challenges.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uncovered the integration of C++20’s concepts and coroutines with
    the STL. We began by exploring the role of concepts in templated programming.
    Concepts strengthen code robustness by enforcing type constraints and enhancing
    the expressivity and safety of template use. They replace error-prone SFINAE techniques
    with a more readable and declarative syntax. We saw how concepts improve the clarity
    of algorithms’ requirements, leading to more maintainable code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examined how coroutines introduce a new level of sophistication to
    asynchronous programming in C++. We discussed the mechanics of coroutines, emphasizing
    the use of `co_await`, `co_return`, and `co_yield` for creating nonblocking operations.
    We looked at how coroutines can interact with STL data structures and algorithms,
    allowing asynchronous and synchronous code to blend seamlessly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the interplay between concepts, coroutines, and the STL is crucial.
    It enables us to write code that is not just performant but also clear and reliable.
    This knowledge equips us to tackle complex programming scenarios with confidence
    and foresight.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will focus on applying execution policies that enable parallelism in
    STL algorithms. The chapter will guide us through the nuances of parallel execution
    policies, the role of `constexpr` in enhancing compile-time optimizations, and
    the best practices for achieving optimal performance in concurrent environments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于应用能够使 STL 算法实现并行的执行策略。本章将引导我们了解并行执行策略的细微差别，`constexpr` 在提升编译时优化中的作用，以及在并发环境中实现最佳性能的最佳实践。
