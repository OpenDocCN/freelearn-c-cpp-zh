- en: '21'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '21'
- en: STL Interaction with Concepts and Coroutines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL 与概念和协程的交互
- en: 'This chapter will explore the interplay between the STL and two of C++’s advanced
    features: concepts and coroutines. This chapter is designed to deepen your understanding
    of how these modern C++ features enhance and interact with the STL.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨 STL 与 C++ 的两个高级特性之间的相互作用：概念和协程。本章旨在加深你对这些现代 C++ 特性如何增强并与 STL 交互的理解。
- en: We begin by learning about concepts, starting with an introduction and progressively
    exploring their role in refining STL algorithm constraints, enhancing data structures,
    and developing custom concepts. This section is crucial for grasping how explicit
    type constraints can lead to more robust and readable code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习关于概念的知识，从介绍开始，逐步探索它们在细化 STL 算法约束、增强数据结构和开发自定义概念中的作用。这一部分对于理解显式类型约束如何导致更健壮和可读的代码至关重要。
- en: Following this, we focus on coroutines, providing a refresher before examining
    their integration with STL algorithms and data structures. This includes exploring
    potential synergies with ranges and views, culminating in discussing how coroutines
    might herald a paradigm shift in C++ programming.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重点关注协程，在检查它们与 STL 算法和数据结构的集成之前，提供一个复习。这包括探索与范围和视图的潜在协同作用，最终讨论协程可能预示着
    C++ 编程范式的转变。
- en: This chapter will provide a comprehensive understanding and practical insights
    into using these features effectively, highlighting their importance in modern
    C++ development and their potential challenges.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将全面了解并深入探讨如何有效地使用这些特性，强调它们在现代 C++ 开发中的重要性及其潜在挑战。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Concepts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念
- en: Coroutines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Concepts
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念
- en: The introduction of concepts in C++20 marked a pivotal step towards safer and
    more expressive templated programming. With their inherent ability to specify
    constraints on template arguments, concepts promise to reshape how we interact
    with and utilize the **Standard Template Library** (**STL**). Let’s discover how
    concepts intertwine with the rich tapestry of STL algorithms and data structures
    to create a more robust and declarative C++ programming paradigm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 中概念的引入标志着朝着更安全和更具表达性的模板编程迈出的关键一步。凭借其指定模板参数约束的固有能力，概念承诺将重塑我们与 **标准模板库**（**STL**）交互和利用的方式。让我们发现概念如何与
    STL 算法和数据结构的丰富织锦交织，以创建一个更健壮和声明性的 C++ 编程范式。
- en: A brief introduction to concepts
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念简介
- en: '**Concepts** provide a mechanism to specify and check constraints on template
    arguments. Essentially, they allow developers to assert requirements about the
    types passed to a template. Concepts aim to make template errors more readable,
    help avoid common pitfalls, and promote the creation of more generic and reusable
    code.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念**提供了一种指定和检查模板参数约束的机制。本质上，它们允许开发者对传递给模板的类型提出要求。概念旨在使模板错误更易于阅读，帮助避免常见陷阱，并促进更通用和可重用代码的创建。'
- en: 'Consider the following concept for an arithmetic type:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下关于算术类型的概念：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using this concept, one can constrain a function only to accept arithmetic
    types:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个概念，可以限制一个函数只接受算术类型：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Refined constraints in STL algorithms
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STL 算法中的细化约束
- en: STL algorithms, historically, have relied on complex, sometimes nebulous requirements
    for their template parameters. With concepts, these requirements become explicit
    and understandable. For instance, the `std::sort` algorithm requires random access
    iterators, which can now be asserted using concepts. This leads to more precise
    error messages if one mistakenly uses a list (which only provides bidirectional
    iterators).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，STL 算法依赖于其模板参数的复杂、有时模糊的要求。有了概念，这些要求变得明确和可理解。例如，`std::sort` 算法需要随机访问迭代器，现在可以使用概念来断言。如果错误地使用列表（仅提供双向迭代器），这将导致更精确的错误消息。
- en: Effectively constraining templates
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效地约束模板
- en: When working with C++ template programming, ensuring that a given type satisfies
    a specific set of requirements has historically been challenging. Before the introduction
    of concepts, developers would rely on complex techniques involving **substitution
    failure is not an error** (**SFINAE**) or specialized trait classes to impose
    type constraints. These methods were verbose and error-prone, often resulting
    in convoluted error messages that were difficult to decipher.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 C++ 模板编程时，确保给定的类型满足一组特定的要求在历史上一直是一个挑战。在引入概念之前，开发者会依赖于涉及**替换失败不是错误**（**SFINAE**）或专门的特质类等复杂技术的技术。这些方法冗长且容易出错，通常会导致难以理解的错误信息。
- en: Concepts allow developers to define a set of predicates that a type must satisfy,
    offering a more structured and readable way to constrain templates. Using concepts,
    you can specify the requirements that template arguments must meet. When a type
    does not match the constraints defined by a concept, the compiler will reject
    the template instantiation, producing a more straightforward and more meaningful
    error message. This enhances the template code’s readability, maintainability,
    and robustness. With concepts, the compiler can quickly ascertain the suitability
    of a type for a given template, ensuring that only appropriate types are utilized,
    thereby minimizing the potential for runtime errors or undefined behavior.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 概念允许开发者定义一组类型必须满足的谓词，提供了一种更结构化和可读性的方式来约束模板。使用概念，你可以指定模板参数必须满足的要求。当一个类型不符合概念定义的约束时，编译器将拒绝模板实例化，生成更直接、更有意义的错误信息。这增强了模板代码的可读性、可维护性和健壮性。使用概念，编译器可以快速确定类型对给定模板的适用性，确保只使用合适的类型，从而最小化运行时错误或未定义行为的风险。
- en: 'Here’s a code example that demonstrates the use of concepts and how the same
    task had to be carried out before the introduction of concepts:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，展示了概念的使用以及在没有引入概念之前如何完成相同的任务：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the example output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we define a concept called `Printable` using the required clause.
    The `Printable` concept checks if a type can be printed to `std::cout`. We then
    have two function templates, `printValue`, and `printValueSFINAE`, that print
    a value if it satisfies the concept or the SFINAE condition, respectively.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用所需子句定义了一个名为 `Printable` 的概念。`Printable` 概念检查一个类型是否可以被打印到 `std::cout`。然后我们有两个函数模板
    `printValue` 和 `printValueSFINAE`，分别用于满足概念或 SFINAE 条件时打印值。
- en: When using the `printValue` function template with the `Printable` concept,
    the compiler will ensure that the type passed to it can be printed, and if not,
    it will produce a clear error message. This makes the code more readable and provides
    meaningful error messages.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用带有 `Printable` 概念的 `printValue` 函数模板时，编译器将确保传递给它的类型可以被打印，如果不能，它将生成清晰的错误信息。这使得代码更易于阅读，并提供了有意义的错误信息。
- en: On the other hand, when using the `printValueSFINAE` function template, we rely
    on SFINAE to achieve the same task. This approach is more verbose and error-prone,
    as it involves complex `std::enable_if` constructs and may lead to cryptic error
    messages when the constraints are unmet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当使用 `printValueSFINAE` 函数模板时，我们依赖于 SFINAE 来完成相同的任务。这种方法更冗长且容易出错，因为它涉及到复杂的
    `std::enable_if` 构造，并且在约束未满足时可能导致难以理解的错误信息。
- en: By comparing these two approaches, you can see how concepts improve the readability,
    maintainability, and robustness of C++ template code, making it easier to specify
    and enforce type requirements.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较这两种方法，你可以看到概念如何提高 C++ 模板代码的可读性、可维护性和健壮性，使其更容易指定和执行类型要求。
- en: Enhanced data structures with explicit requirements
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有显式要求的增强数据结构
- en: STL containers, such as `std::vector` or `std::map`, often have their requirements
    for stored types, such as being copy-constructible or assignable. Concepts can
    articulate these requirements with great clarity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: STL 容器，如 `std::vector` 或 `std::map`，通常对存储的类型有要求，例如必须是可复制的或可赋值的。概念可以非常清晰地表达这些要求。
- en: Imagine a custom container that necessitates its elements to be default constructible.
    This requirement can be eloquently expressed with concepts, ensuring safer and
    more predictable container behavior.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个自定义容器，它要求其元素必须能够使用默认构造函数。这个要求可以用概念来优雅地表达，从而确保容器行为更安全、更可预测。
- en: Custom concepts and STL interactions
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义概念和 STL 交互
- en: One of the strengths of concepts is that they’re not limited to the ones provided
    by the standard library. Developers can create custom concepts tailored to specific
    needs, ensuring that STL structures and algorithms can be adapted to unique and
    complex scenarios without sacrificing type safety.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 概念的一个优点是它们不仅限于标准库提供的那些。开发者可以创建定制的概念，以满足特定需求，确保 STL 结构和算法可以适应独特和复杂的场景，同时不牺牲类型安全。
- en: 'For instance, if a particular algorithm demands types with a specific interface
    (such as having a `draw()` member function), one can design a concept to enforce
    this, leading to more intuitive and self-documenting code. Let''s look at a code
    example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果某个算法需要具有特定接口的类型（例如具有 `draw()` 成员函数），则可以设计一个概念来强制执行此要求，从而实现更直观和自文档化的代码。让我们看看一个代码示例：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the example output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code example, we do the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们做了以下操作：
- en: We define a custom concept called `Drawable`, which requires a type with a `draw()`
    member function returning `void.`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `Drawable` 的自定义概念，它要求类型具有返回 `void` 的 `draw()` 成员函数。
- en: 'We create two example classes: `Circle`, which satisfies the `Drawable` concept
    by having a `draw()` member function, and `Square`, which does not satisfy the
    concept because it lacks the `draw()` member function.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了两个示例类：`Circle`，它通过具有 `draw()` 成员函数满足 `Drawable` 概念，而 `Square` 则不满足该概念，因为它缺少
    `draw()` 成员函数。
- en: We define a generic function called `drawShape`, which takes a `Drawable` type
    as a parameter and calls its `draw()` member function.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `drawShape` 的泛型函数，它接受一个 `Drawable` 类型作为参数并调用其 `draw()` 成员函数。
- en: In the `main` function, we create instances of `Circle` and `Square` and demonstrate
    that `drawShape` can be called with a `Drawable` type (e.g., `Circle`) but not
    with a type that does not satisfy the `Drawable` concept (e.g., `Square`).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们创建了 `Circle` 和 `Square` 的实例，并演示了 `drawShape` 可以用 `Drawable` 类型（例如
    `Circle`）调用，但不能用不满足 `Drawable` 概念的类型（例如 `Square`）调用。
- en: This example illustrates how custom concepts can enforce specific interface
    requirements, ensuring type safety and making the code more intuitive and self-documenting
    when working with complex scenarios and algorithms in C++.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了如何使用自定义概念来强制执行特定的接口要求，确保类型安全，并在处理 C++ 中的复杂场景和算法时使代码更直观和自文档化。
- en: Potential challenges and caveats
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 潜在的挑战和注意事项
- en: 'While concepts are undeniably powerful, there are a few considerations to be
    made:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然概念无疑很强大，但有一些考虑事项需要考虑：
- en: '**Complexity**: Designing intricate custom concepts can be challenging and
    may steepen the learning curve for newcomers'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：设计复杂的自定义概念可能具有挑战性，可能会增加新手的学习曲线。'
- en: '**Compile times**: As with most template-based features, over-reliance or misuse
    can increase compilation times'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时间**：与大多数基于模板的功能一样，过度依赖或误用可能会增加编译时间。'
- en: '**Backward compatibility**: Older codebases may require refactoring to leverage
    or comply fully with new concept-driven constraints'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向后兼容性**：较老的代码库可能需要重构才能充分利用或完全符合新的概念驱动约束。'
- en: This section provided a window into a powerful feature in C++ that allows us
    to specify constraints on template parameters. We began with a brief introduction
    to concepts, understanding their role in enhancing the expressiveness and safety
    of our code. We then explored how refined constraints can be applied in STL algorithms,
    leading to more robust and readable code. We also learned how to constrain templates
    effectively, which is crucial for preventing the misuse of our code and ensuring
    that it behaves as expected.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 C++ 中一个强大的功能，允许我们指定模板参数的约束。我们首先简要介绍了概念，理解它们在增强代码可表达性和安全性方面的作用。然后，我们探讨了如何将精细的约束应用于
    STL 算法，从而实现更健壮和可读的代码。我们还学习了如何有效地约束模板，这对于防止代码误用和确保代码按预期行为至关重要。
- en: However, we also acknowledged the potential challenges and caveats associated
    with concepts. While they offer many benefits, using them judiciously is important
    to avoid unnecessary complexity and potential pitfalls.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也承认了与概念相关的潜在挑战和注意事项。虽然它们提供了许多好处，但明智地使用它们以避免不必要的复杂性和潜在陷阱是很重要的。
- en: 'The knowledge gained from this section is invaluable as it equips us with the
    tools to write safer, more expressive, and more efficient code using the STL.
    It also prepares us for the next section, where we will explore another exciting
    feature of C++: coroutines.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节中获得的知识是无价的，因为它为我们提供了使用 STL 编写更安全、更表达性和更高效代码的工具。它还为我们为下一节做准备，我们将探索 C++ 的另一个令人兴奋的特性：协程。
- en: The next section will refresh our understanding of coroutines and discuss their
    integration with STL algorithms and data structures. We will also explore potential
    synergies with ranges and views, which can lead to even more efficient and elegant
    code. Finally, we will look at how coroutines represent a paradigm shift in how
    we write asynchronous code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将刷新我们对协程的理解，并讨论它们与 STL 算法和数据结构的集成。我们还将探索与范围和视图的潜在协同作用，这可能导致更高效、更优雅的代码。最后，我们将探讨协程如何代表我们在编写异步代码时的一种范式转变。
- en: Coroutines
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: The integration of coroutines into C++20 ushers in a new paradigm for asynchronous
    programming that’s more readable and intuitive. By allowing functions to be suspended
    and resumed, coroutines offer an alternative to the callback-heavy style often
    seen in asynchronous C++ code. While transformative in its own right, this evolution
    also provides fresh, innovative ways to interact with the venerable STL. Examining
    the interaction of coroutines with STL algorithms and data structures reveals
    how they simplify asynchronous operations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 协程集成到 C++20 中引入了异步编程的新范式，这使得代码更易读、更直观。通过允许函数暂停和恢复，协程为在异步 C++ 代码中常见的回调密集型风格提供了一种替代方案。这种演变本身具有变革性，同时也提供了与尊贵的
    STL 交互的新鲜、创新方式。研究协程与 STL 算法和数据结构的交互揭示了它们如何简化异步操作。
- en: Understanding coroutines – a refresher
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解协程——复习
- en: 'A `co_await`, `co_return`, and `co_yield`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`co_await`、`co_return` 和 `co_yield`：'
- en: '`co_await`: Suspends the current coroutine until the awaited expression is
    ready, at which point the coroutine resumes'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_await`: 暂停当前协程，直到等待的表达式准备好，此时协程继续'
- en: '`co_return`: This is used to finish the coroutine, potentially returning a
    value'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_return`: 这用于结束协程，可能返回一个值'
- en: '`co_yield`: Produces a value in a generator-like fashion, allowing iteration
    over a coroutine'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_yield`: 以生成器的方式产生一个值，允许对协程进行迭代'
- en: STL algorithms and coroutine integration
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STL 算法和协程集成
- en: With coroutines, STL algorithms that previously demanded a more convoluted asynchronous
    approach can now be elegantly written with direct, linear logic. Consider algorithms
    that operate on sequences or ranges; they can be combined with coroutines to asynchronously
    generate values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协程后，之前需要更复杂异步方法的 STL 算法现在可以以直接、线性的逻辑优雅地编写。考虑在序列或范围内操作的计算算法；它们可以与协程结合，以异步方式生成值。
- en: For instance, a coroutine could asynchronously produce values and then process
    them using `std::transform` or `std::for_each`, weaving asynchronous code seamlessly
    with synchronous STL algorithms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个协程可以异步产生值，然后使用 `std::transform` 或 `std::for_each` 处理这些值，将异步代码与同步 STL 算法无缝结合。
- en: Coroutines and STL data structures
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程和 STL 数据结构
- en: The magic of coroutines also touches the realm of STL data structures. Coroutines
    present an intriguing potential for containers such as `std::vector` or `std::list:`
    `populating` (asynchronously).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的魔法也触及了 STL 数据结构的领域。协程为容器如 `std::vector` 或 `std::list` 提供了有趣的潜在用途：`填充`（异步）。
- en: Imagine a scenario where data must be fetched from a network source and stored
    in `std::vector`. A coroutine can be used to fetch the data asynchronously, yielding
    values as they arrive, and then these values can be directly inserted into the
    vector. This blend of asynchronicity with the directness of STL data structures
    simplifies code and reduces cognitive overhead.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，其中必须从网络源获取数据并将其存储在 `std::vector` 中。可以使用协程异步获取数据，在数据到达时产生值，然后直接将这些值插入到向量中。这种异步与
    STL 数据结构直接性的结合简化了代码并减少了认知开销。
- en: Potential synergies with ranges and views
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与范围和视图的潜在协同作用
- en: As the C++ language evolves, other features, such as ranges and views, combined
    with coroutines, can offer a more expressive way to handle data manipulation and
    transformation. Coroutines can generate ranges, which can be lazily evaluated,
    filtered, and transformed using views, resulting in a robust and composable asynchronous
    programming model.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 随着C++语言的演变，其他特性，如范围和视图，与协程结合，可以提供一种更表达性的方式来处理数据操作和转换。协程可以生成范围，这些范围可以延迟评估、过滤和转换，使用视图，从而实现一个强大且可组合的异步编程模型。
- en: 'Let’s look at the following code example that involves the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下涉及以下步骤的代码示例：
- en: '`std::vector<int>` to store a sequence of numbers.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector<int>` 用于存储数字序列。'
- en: '**Coroutine**: A generator that asynchronously generates numbers to populate
    our vector.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程**：一个异步生成数字以填充我们的向量的生成器。'
- en: '`std::ranges::copy_if`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::ranges::copy_if`。'
- en: '`std::views::transform`, we’ll multiply each number by two. First, we must
    create our `generator` class with a special `promise_type` structure that our
    coroutine will use. The generator class template and its nested `promise_type`
    structure in this code are key components in implementing a coroutine for generating
    a sequence of values in C++.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::views::transform`，我们将每个数字乘以二。首先，我们必须创建一个特殊的 `promise_type` 结构的 `generator`
    类，我们的协程将使用它。在这个代码中，生成器类模板及其嵌套的 `promise_type` 结构是实现C++中生成值序列协程的关键组件。'
- en: A `T`, one at a time, upon request. It encapsulates the coroutine’s state and
    provides an interface to control its execution and access the yielded values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 根据请求，一次一个 `T`。它封装了协程的状态，并提供了一个接口来控制其执行和访问产生的值。
- en: 'The `promise_type` nested within the generator is the coroutine’s lifecycle
    and state management backbone. It holds the current value to be yielded (value)
    and defines several key functions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成器内部嵌套的 `promise_type` 是协程的生命周期和状态管理核心。它保存要产生的当前值（value）并定义了几个关键函数：
- en: '`get_return_object`: Returns the generator object associated with this coroutine'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_return_object`：返回与该协程关联的生成器对象'
- en: '`initial_suspend` and `final_suspend`: Control the coroutine’s execution, suspending
    it initially and after completion'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_suspend` 和 `final_suspend`：控制协程的执行，初始暂停并在完成后暂停'
- en: '`unhandled_exception`: Defines behavior for unhandled exceptions, terminating
    the program'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unhandled_exception`：定义未处理异常的行为，终止程序'
- en: '`return_void`: A placeholder for when the coroutine reaches its end'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return_void`：当协程到达其末尾时的占位符'
- en: '`yield_value`: This is called when a value is yielded (co_yield), suspending
    the coroutine and storing the yielded value'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield_value`：当产生一个值时（co_yield），暂停协程并存储产生的值'
- en: 'The code example below is broken into several sections (the complete example
    can be found in the book''s GitHub repository):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例被分成几个部分（完整的示例可以在书籍的GitHub仓库中找到）：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code defines a generic template class called `generator`. This
    class is instantiated as the return type of the `generate_numbers` function, which
    creates a sequence of integers from start to end. When called, it initiates a
    coroutine that iteratively yields integers within the specified range. Each iteration
    suspends the coroutine, making the current value available to the caller. The
    generator class provides mechanisms to resume the coroutine (`next()`) and retrieve
    the current value (`value()`). The generator’s constructor, move constructor,
    destructor, and deleted copy constructor manage the coroutine’s lifecycle and
    ensure proper resource management.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个名为 `generator` 的泛型模板类。这个类被实例化为 `generate_numbers` 函数的返回类型，该函数创建从开始到结束的整数序列。当被调用时，它启动一个协程，迭代地产生指定范围内的整数。每次迭代都会暂停协程，使当前值对调用者可用。生成器类提供了恢复协程（`next()`）和检索当前值（`value()`）的机制。生成器的构造函数、移动构造函数、析构函数和已删除的复制构造函数管理协程的生命周期并确保适当的资源管理。
- en: 'That was the hard part. Now, we can get to work building and using our coroutine:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是难点所在。现在，我们可以开始构建和使用我们的协程：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the example output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例输出：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we did the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们做了以下几件事：
- en: We created a `generator` class to represent asynchronous generators.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `generator` 类来表示异步生成器。
- en: We used the coroutine `generate_numbers` to asynchronously generate numbers
    from 1 to 10.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `generate_numbers` 协程异步生成从 1 到 10 的数字。
- en: With ranges, we filtered only even numbers and stored them in another vector.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用范围，我们只过滤出偶数并将它们存储在另一个向量中。
- en: Using views, we transformed these even numbers by multiplying them by two.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视图，我们将这些偶数乘以二进行转换。
- en: Lastly, we output the transformed sequence.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们输出了转换后的序列。
- en: Looking ahead – a paradigm shift
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展望未来——范式转变
- en: Coroutines in C++ represent a significant advancement in the domain of asynchronous
    programming. By introducing a standardized way to handle asynchronous tasks, coroutines
    facilitate writing nonblocking, efficient, and maintainable code. When used in
    conjunction with the STL, coroutines have the potential to streamline complex
    operations, transforming the landscape of C++ programming.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的协程代表了异步编程领域的一项重大进步。通过引入处理异步任务的标准方式，协程促进了编写非阻塞、高效和可维护的代码。当与 STL 结合使用时，协程有可能简化复杂操作，改变
    C++ 编程的格局。
- en: The STL provides a robust framework for data manipulation and algorithm implementation.
    The introduction of coroutines enhances this framework by offering a concurrency
    model that is less error-prone and more intuitive than traditional threading mechanisms.
    This synergy allows for developing sophisticated asynchronous programs to leverage
    the full power of the STL’s containers, iterators, and algorithms without compromising
    performance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: STL 为数据操作和算法实现提供了一个健壮的框架。协程的引入通过提供一种比传统线程机制更不易出错、更直观的并发模型来增强这个框架。这种协同作用允许开发复杂的异步程序，利用
    STL 容器、迭代器和算法的全部力量，而不牺牲性能。
- en: As coroutines become more integrated within the STL, we anticipate a paradigm
    shift where high-performance code will not only be characterized by its speed
    but also by its clarity and modular structure. The adoption of coroutines is poised
    to expand, driven by their ability to produce scalable and responsive software.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 随着协程在 STL 中的集成越来越紧密，我们预期将出现一种范式转变，其中高性能代码不仅以其速度为特征，还将以其清晰性和模块化结构为特征。协程的采用预计将扩大，这得益于它们产生可扩展和响应性软件的能力。
- en: The future iterations of the C++ standard will likely introduce more features
    that complement the coroutine–STL interface, providing developers with a richer
    toolkit. This evolution will solidify C++’s role as a premier language for developing
    high-performance, asynchronous applications. The commitment to continual improvement
    within the C++ community maintains the language’s relevance and efficacy in solving
    modern programming challenges.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准的未来迭代可能会引入更多功能，以补充协程-STL 接口，为开发者提供更丰富的工具集。这种演变将巩固 C++ 作为开发高性能、异步应用程序的首选语言的地位。C++
    社区对持续改进的承诺保持了该语言在解决现代编程挑战中的相关性和有效性。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter uncovered the integration of C++20’s concepts and coroutines with
    the STL. We began by exploring the role of concepts in templated programming.
    Concepts strengthen code robustness by enforcing type constraints and enhancing
    the expressivity and safety of template use. They replace error-prone SFINAE techniques
    with a more readable and declarative syntax. We saw how concepts improve the clarity
    of algorithms’ requirements, leading to more maintainable code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本章揭示了 C++20 的概念和协程与 STL 的集成。我们首先探讨了概念在模板编程中的作用。概念通过强制类型约束和增强模板使用的可表达性和安全性来增强代码的健壮性。它们用更易读和声明性的语法替换了易出错的
    SFINAE 技术。我们看到概念如何提高算法要求的可清晰性，从而产生更易于维护的代码。
- en: Next, we examined how coroutines introduce a new level of sophistication to
    asynchronous programming in C++. We discussed the mechanics of coroutines, emphasizing
    the use of `co_await`, `co_return`, and `co_yield` for creating nonblocking operations.
    We looked at how coroutines can interact with STL data structures and algorithms,
    allowing asynchronous and synchronous code to blend seamlessly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了协程如何为 C++ 中的异步编程引入一个新的复杂层次。我们讨论了协程的机制，强调使用 `co_await`、`co_return` 和
    `co_yield` 来创建非阻塞操作。我们研究了协程如何与 STL 数据结构和算法交互，使异步和同步代码能够无缝融合。
- en: Understanding the interplay between concepts, coroutines, and the STL is crucial.
    It enables us to write code that is not just performant but also clear and reliable.
    This knowledge equips us to tackle complex programming scenarios with confidence
    and foresight.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 理解概念、协程和 STL 之间的相互作用至关重要。它使我们能够编写不仅性能出色，而且清晰和可靠的代码。这种知识使我们能够自信和有远见地应对复杂的编程场景。
- en: Next, we will focus on applying execution policies that enable parallelism in
    STL algorithms. The chapter will guide us through the nuances of parallel execution
    policies, the role of `constexpr` in enhancing compile-time optimizations, and
    the best practices for achieving optimal performance in concurrent environments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于应用能够使 STL 算法实现并行的执行策略。本章将引导我们了解并行执行策略的细微差别，`constexpr` 在提升编译时优化中的作用，以及在并发环境中实现最佳性能的最佳实践。
