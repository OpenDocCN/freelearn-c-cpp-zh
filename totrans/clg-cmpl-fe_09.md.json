["```cpp\n1 class TestClass { \n\n2 public: \n\n3   TestClass(){}; \n\n4   void pos(){}; \n\n5  \n\n6 private: \n\n7   void private_pos(){}; \n\n8 };\n```", "```cpp\n1 class TestClass { \n\n2 public: \n\n3   TestClass(){}; \n\n4   void test_pos(){}; \n\n5  \n\n6 private: \n\n7   void private_pos(){}; \n\n8 };\n```", "```cpp\n1      TestClass test; \n\n2       test.pos();\n```", "```cpp\n1      TestClass test; \n\n2       test.test_pos();\n```", "```cpp\n10   bool VisitCXXRecordDecl(clang::CXXRecordDecl *Class) { \n\n11     if (!Class->isClass()) \n\n12       return true; \n\n13     if (!Class->isThisDeclarationADefinition()) \n\n14       return true; \n\n15     if (!Class->getName().starts_with(\"Test\")) \n\n16       return true; \n\n17     for (const clang::CXXMethodDecl *Method : Class->methods()) { \n\n18       clang::SourceLocation StartLoc = Method->getLocation(); \n\n19       if (!processMethod(Method, StartLoc, \"Renamed method\")) \n\n20         return false; \n\n21     } \n\n22     return true; \n\n23   }\n```", "```cpp\n44   bool processMethod(const clang::CXXMethodDecl *Method, \n\n45                      clang::SourceLocation StartLoc, const char *LogMessage) { \n\n46     if (Method->getAccess() != clang::AS_public) \n\n47       return true; \n\n48     if (llvm::isa<clang::CXXConstructorDecl>(Method)) \n\n49       return true; \n\n50     if (!Method->getIdentifier() || Method->getName().starts_with(\"test_\")) \n\n51       return true; \n\n52  \n\n53     std::string OldMethodName = Method->getNameAsString(); \n\n54     std::string NewMethodName = \"test_\" + OldMethodName; \n\n55     clang::SourceManager &SM = Context.getSourceManager(); \n\n56     clang::tooling::Replacement Replace(SM, StartLoc, OldMethodName.length(), \n\n57                                         NewMethodName); \n\n58     Replaces.push_back(Replace); \n\n59     llvm::outs() << LogMessage << \": \" << OldMethodName << \" to \" \n\n60                  << NewMethodName << \"\\n\"; \n\n61     return true; \n\n62   }\n```", "```cpp\n40 private: \n\n41   clang::ASTContext &Context; \n\n42   std::vector<clang::tooling::Replacement> Replaces;\n```", "```cpp\n36   const std::vector<clang::tooling::Replacement> &getReplacements() { \n\n37     return Replaces; \n\n38   }\n```", "```cpp\n25   bool VisitCXXMemberCallExpr(clang::CXXMemberCallExpr *Call) { \n\n26     if (clang::CXXMethodDecl *Method = Call->getMethodDecl()) { \n\n27       clang::CXXRecordDecl *Class = Method->getParent(); \n\n28       if (!Class->getName().starts_with(\"Test\")) \n\n29         return true; \n\n30       clang::SourceLocation StartLoc = Call->getExprLoc(); \n\n31       return processMethod(Method, StartLoc, \"Renamed method call\"); \n\n32     } \n\n33     return true; \n\n34   }\n```", "```cpp\n6 class Consumer : public clang::ASTConsumer { \n\n7 public: \n\n8   void HandleTranslationUnit(clang::ASTContext &Context) override { \n\n9     Visitor V(Context); \n\n10     V.TraverseDecl(Context.getTranslationUnitDecl()); \n\n11  \n\n12     // Apply the replacements. \n\n13     clang::Rewriter Rewrite(Context.getSourceManager(), clang::LangOptions()); \n\n14     auto &Replaces = V.getReplacements(); \n\n15     for (const auto &Replace : Replaces) { \n\n16       if (Replace.isApplicable()) { \n\n17         Replace.apply(Rewrite); \n\n18       } \n\n19     } \n\n20  \n\n21     // Apply the Rewriter changes. \n\n22     if (Rewrite.overwriteChangedFiles()) { \n\n23       llvm::errs() << \"Error: Cannot apply changes to the file\\n\"; \n\n24     } \n\n25   } \n\n26 }; \n\n27 } // namespace methodrename\n```", "```cpp\n13 int main(int argc, const char **argv) { \n\n14   llvm::Expected<clang::tooling::CommonOptionsParser> OptionsParser = \n\n15       clang::tooling::CommonOptionsParser::create(argc, argv, TestCategory); \n\n16   if (!OptionsParser) { \n\n17     llvm::errs() << OptionsParser.takeError(); \n\n18     return 1; \n\n19   } \n\n20   clang::tooling::ClangTool Tool(OptionsParser->getCompilations(), \n\n21                                  OptionsParser->getSourcePathList()); \n\n22   return Tool.run(clang::tooling::newFrontendActionFactory< \n\n23                       clangbook::methodrename::FrontendAction>() \n\n24                       .get()); \n\n25 }\n```", "```cpp\n1 cmake_minimum_required(VERSION 3.16) \n\n2 project(\"methodrename\") \n\n3  \n\n4 if ( NOT DEFINED ENV{LLVM_HOME}) \n\n5   message(FATAL_ERROR \"$LLVM_HOME is not defined\") \n\n6 else() \n\n7   message(STATUS \"$LLVM_HOME found: $ENV{LLVM_HOME}\") \n\n8   set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH \"Root of LLVM installation\") \n\n9   set(LLVM_LIB ${LLVM_HOME}/lib) \n\n10   set(LLVM_DIR ${LLVM_LIB}/cmake/llvm) \n\n11   find_package(LLVM REQUIRED CONFIG) \n\n12   include_directories(${LLVM_INCLUDE_DIRS}) \n\n13   link_directories(${LLVM_LIBRARY_DIRS}) \n\n14   set(SOURCE_FILE MethodRename.cpp) \n\n15   add_executable(methodrename ${SOURCE_FILE}) \n\n16   set_target_properties(methodrename PROPERTIES COMPILE_FLAGS \"-fno-rtti\") \n\n17   target_link_libraries(methodrename \n\n18     LLVMSupport \n\n19     clangAST \n\n20     clangBasic \n\n21     clangFrontend \n\n22     clangSerialization \n\n23     clangToolingCore \n\n24     clangRewrite \n\n25     clangTooling \n\n26   ) \n\n27 endif()\n```", "```cpp\nexport LLVM_HOME=<...>/llvm-project/install\nmkdir build\ncd build\ncmake -G Ninja -DCMAKE_BUILD_TYPE=Debug ...\nninja\n```", "```cpp\n1 class TestClass { \n\n2 public: \n\n3   TestClass(){}; \n\n4   void pos(){}; \n\n5 }; \n\n6  \n\n7 int main() { \n\n8   TestClass test; \n\n9   test.pos(); \n\n10   return 0; \n\n11 }\n```", "```cpp\n$ ./methodrename TestClass.cpp -- -std=c++17\nRenamed method: pos to test_pos\nRenamed method call: pos to test_pos\n```", "```cpp\n1 class TestClass { \n\n2 public: \n\n3   TestClass(){}; \n\n4   void test_pos(){}; \n\n5 }; \n\n6  \n\n7 int main() { \n\n8   TestClass test; \n\n9   test.test_pos(); \n\n10   return 0; \n\n11 }\n```", "```cpp\n1 void foo() { \n\n2   constexpr int a = 0; \n\n3   constexpr const int *b = &a; \n\n4 }\n\n```", "```cpp\n$ <...>/llvm-project/install/bin/clang -cc1 -emit-obj foo.cpp -o /tmp/foo.o\nfoo.cpp:3:24: error: constexpr variable ’b’ must be initialized by a\nconstant expression\n    3 |   constexpr const int *b = &a;\n      |                        ^   ~~\nfoo.cpp:3:24: note: pointer to ’a’ is not a constant expression\nfoo.cpp:2:17: note: address of non-static constexpr variable ’a’ may differ\non each invocation of the enclosing function; add ’static’ to give it a\nconstant address\n    2 |   constexpr int a = 0;\n      |                 ^\n      |   static\n1  error generated.\n```", "```cpp\n      if (VarD && VarD->isConstexpr()) { \n\n        // Non-static local constexpr variables have unintuitive semantics: \n\n        //   constexpr int a = 1; \n\n        //   constexpr const int *p = &a; \n\n        // ... is invalid because the address of ’a’ is not constant. Suggest \n\n        // adding a ’static’ in this case. \n\n        Info.Note(VarD->getLocation(), diag::note_constexpr_not_static) \n\n            << VarD \n\n            << FixItHint::CreateInsertion(VarD->getBeginLoc(), \"static \");\n```", "```cpp\n$ ./clang-tools-extra/clang-tidy/add_new_check.py misc methodrename\n```", "```cpp\nUpdating ./clang-tools-extra/clang-tidy/misc/CMakeLists.txt...\nCreating ./clang-tools-extra/clang-tidy/misc/MethodrenameCheck.h...\nCreating ./clang-tools-extra/clang-tidy/misc/MethodrenameCheck.cpp...\nUpdating ./clang-tools-extra/clang-tidy/misc/MiscTidyModule.cpp...\nUpdating clang-tools-extra/docs/ReleaseNotes.rst...\nCreating clang-tools-extra/test/clang-tidy/checkers/misc/methodrename.cpp...\nCreating clang-tools-extra/docs/clang-tidy/checks/misc/methodrename.rst...\nUpdating clang-tools-extra/docs/clang-tidy/checks/list.rst...\nDone. Now it’s your turn!\n```", "```cpp\n27 private: \n\n28   void processMethod(const clang::CXXMethodDecl *Method, \n\n29                      clang::SourceLocation StartLoc, const char *LogMessage); \n\n30 };\n```", "```cpp\n26 void MethodrenameCheck::registerMatchers(MatchFinder *Finder) { \n\n27   auto ClassMatcher = hasAncestor(cxxRecordDecl(matchesName(\"::Test.*$\"))); \n\n28   auto MethodMatcher = cxxMethodDecl(isNotTestMethod(), ClassMatcher); \n\n29   auto CallMatcher = cxxMemberCallExpr(callee(MethodMatcher)); \n\n30   Finder->addMatcher(MethodMatcher.bind(\"method\"), this); \n\n31   Finder->addMatcher(CallMatcher.bind(\"call\"), this); \n\n32 }\n```", "```cpp\n\n18 AST_MATCHER(CXXMethodDecl, isNotTestMethod) { \n\n19   if (Node.getAccess() != clang::AS_public) return false; \n\n20   if (llvm::isa<clang::CXXConstructorDecl>(&Node)) return false; \n\n21   if (!Node.getIdentifier() || Node.getName().startswith(\"test_\")) return false; \n\n22  \n\n23   return true; \n\n24 }\n```", "```cpp\n34 void MethodrenameCheck::check(const MatchFinder::MatchResult &Result) { \n\n35   if (const auto *Method = Result.Nodes.getNodeAs<CXXMethodDecl>(\"method\")) { \n\n36     processMethod(Method, Method->getLocation(), \"Method\"); \n\n37   } \n\n38  \n\n39   if (const auto *Call = Result.Nodes.getNodeAs<CXXMemberCallExpr>(\"call\")) { \n\n40     if (CXXMethodDecl *Method = Call->getMethodDecl()) { \n\n41       processMethod(Method, Call->getExprLoc(), \"Method call\"); \n\n42     } \n\n43   } \n\n44 }\n```", "```cpp\n46 void MethodrenameCheck::processMethod(const clang::CXXMethodDecl *Method, \n\n47                                       clang::SourceLocation StartLoc, \n\n48                                       const char *LogMessage) { \n\n49   diag(StartLoc, \"%0 %1 does not have ’test_’ prefix\") << LogMessage << Method; \n\n50   diag(StartLoc, \"insert ’test_’\", DiagnosticIDs::Note) \n\n51       << FixItHint::CreateInsertion(StartLoc, \"test_\"); \n\n52 }\n```", "```cpp\n$ ninja clang-tidy\n```", "```cpp\n$ ninja install\n```", "```cpp\n$ <...>/llvm-project/install/bin/clang-tidy \\\n             -checks=’-*,misc-methodrename’ \\\n             ./TestClass.cpp              \\\n             -- -std=c++17\n```", "```cpp\nTestClass.cpp:4:8: warning: Method ’pos’ does not have ’test_’ prefix\n[misc-methodrename]\n  void pos(){};\n       ^\nTestClass.cpp:4:8: note: insert ’test_’\n  void pos(){};\n       ^\n       test_\nTestClass.cpp:9:8: warning: Method call ’pos’ does not have ’test_’ prefix\n[misc-methodrename]\n  test.pos();\n       ^\nTestClass.cpp:9:8: note: insert ’test_’\n  test.pos();\n       ^\n       test_\n```", "```cpp\n$ <...>/llvm-project/install/bin/clang-tidy \\\n             -fix-notes                   \\\n             -checks=’-*,misc-methodrename’ \\\n             ./TestClass.cpp              \\\n             -- -std=c++17\n```", "```cpp\n2 warnings generated.\nTestClass.cpp:4:8: warning: Method ’pos’ does not have ’test_’ prefix\n[misc-methodrename]\n  void pos(){};\n       ^\nTestClassSmall.cpp:4:8: note: FIX-IT applied suggested code changes\nTestClass.cpp:4:8: note: insert ’test_’\n  void pos(){};\n       ^\n       test_\nTestClass.cpp:9:8: warning: Method call ’pos’ does not have ’test_’ prefix\n[misc-methodrename]\n  test.pos();\n       ^\nTestClass.cpp:9:8: note: FIX-IT applied suggested code changes\nTestClass.cpp:9:8: note: insert ’test_’\n```", "```cpp\n  test.pos();\n       ^\n       test_\nclang-tidy applied 2 of 2 suggested fixes.\n```", "```cpp\n1 BasedOnStyle: LLVM\n```", "```cpp\n$ <...>/llvm-project/install/bin/clang-format -i main.cpp\n```", "```cpp\n1 namespace clang { \n\n2 class TestClang { \n\n3 public: \n\n4 void testClang(){}; \n\n5 }; \n\n6 }int main() { \n\n7 TestClang test; \n\n8 test.testClang(); \n\n9 return 0; \n\n10 }\n```", "```cpp\n1 namespace clang { \n\n2 class TestClang { \n\n3 public: \n\n4   void testClang(){}; \n\n5 }; \n\n6 } // namespace clang \n\n7 int main() { \n\n8   TestClang test; \n\n9   test.testClang(); \n\n10   return 0; \n\n11 }\n```", "```cpp\n1 class TestClass { \n\n2 public: \n\n3   TestClass(){}; \n\n4 void pos(){}; \n\n5 }; \n\n6  \n\n7 int main() { \n\n8   TestClass test; \n\n9 test.pos(); \n\n10   return 0; \n\n11 }\n```", "```cpp\n1 class TestClass { \n\n2 public: \n\n3   TestClass(){}; \n\n4 void test_pos(){}; \n\n5 }; \n\n6  \n\n7 int main() { \n\n8   TestClass test; \n\n9 test.test_pos(); \n\n10   return 0; \n\n11 }\n```", "```cpp\n$ <...>/llvm-project/install/bin/clang-tidy\\\n  -fix-notes                               \\\n  -checks=’-*,misc-methodrename’           \\\n  ./TestClassNotFormated.cpp               \\\n  -- -std=c++17\n```", "```cpp\n$ <...>/llvm-project/install/bin/clang-tidy\\\n  -format-style ’llvm’                     \\\n  -fix-notes                               \\\n  -checks=’-*,misc-methodrename’           \\\n  ./TestClassNotFormated.cpp               \\\n  -- -std=c++17\n```", "```cpp\n1 class TestClass { \n\n2 public: \n\n3   TestClass(){}; \n\n4 void pos(){}; \n\n5 }; \n\n6  \n\n7 int main() { \n\n8   TestClass test; \n\n9 test.pos(); \n\n10   return 0; \n\n11 }\n```", "```cpp\n1 class TestClass { \n\n2 public: \n\n3   TestClass(){}; \n\n4   void test_pos(){}; \n\n5 }; \n\n6  \n\n7 int main() { \n\n8   TestClass test; \n\n9   test.test_pos(); \n\n10   return 0; \n\n11 }\n```"]