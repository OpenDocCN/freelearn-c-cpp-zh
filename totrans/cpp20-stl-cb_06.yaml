- en: '*Chapter 6*: STL Algorithms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of the power of the STL is in the standardization of container interfaces.
    If a container has a particular capability, there's a good chance that the interface
    for that capability is standardized across container types. This standardization
    makes possible a library of *algorithms* that operate seamlessly across containers
    and sequences sharing a common interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to sum all the elements in a `vector` of `int`, we
    could use a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could use an algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This same syntax works with other containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm version is not necessarily shorter, but it is easier to read and
    easier to maintain. And an algorithm is often more efficient than the equivalent
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with C++20, the `ranges` library provides a set of alternative algorithms
    that operate with *ranges* and *views*. This book will demonstrate those alternatives
    where appropriate. For more information on ranges and views, refer to the recipe
    *Create views into containers with ranges* in [*Chaper 1*](B18267_01_ePub.xhtml#_idTextAnchor027),
    *New C++20 Features*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the algorithms are in the `algorithm` header. Some numeric algorithms,
    notably `accumulate()`, are in the `numeric` header, and some memory-related algorithms
    are in the `memory` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover STL algorithms in the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy from one iterator to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join container elements into a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort containers with `std::sort`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify containers with `std::transform`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find items in a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the values of a container to a range with `std::clamp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample data sets with `std::sample`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate permutations of data sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge sorted containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap06](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap06).
  prefs: []
  type: TYPE_NORMAL
- en: Copy from one iterator to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *copy algorithms* are generally used to copy from and to containers, but
    in fact, they work with iterators, which is far more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will experiment with `std::copy` and `std::copy_n` to get
    a good understanding of how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a function to print a container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main()`, we define a `vector` and print it with `printc()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a second `vector` with enough space to copy the first `vector`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can copy `v1` to `v2` using the `std::copy()` algorithm:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `std::copy()` algorithm takes two iterators for the range of the copy source,
    and one iterator for the destination. In this case, we give it the `begin()` and
    `end()` iterators of `v1` to copy the entire `vector`. The `begin()` iterator
    of `v2` serves as the destination for the copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our output is now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `copy()` algorithm does not allocate space for the destination. So, `v2`
    must already have the space for the copy. Alternately, you can use the `back_inserter()`
    iterator adapter to insert the elements at the back of the `vector`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also use the `ranges::copy()` algorithm to copy an entire *range*. A
    container object serves as a range so we can use `v1` as the source. We still
    use an iterator for the destination:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This also works with `back_inserter()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can copy a certain number of elements using `copy_n()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the second argument, the `copy_n()` algorithm is a *count* for the number
    of elements to copy. The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s also a `copy_if()` algorithm that uses a Boolean *predicate function*
    to determine which elements to copy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There''s also a `ranges` version of `copy_if()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output includes only strings longer than `4` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the value `beta` is excluded.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use any of these algorithms to copy to or from any sequence, including
    a stream iterator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `std::copy()` algorithm is very simple. An equivalent function would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `copy()` function uses the destination iterator's assignment operator to
    copy from the input iterator to the output iterator until it reaches the end of
    the input range.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a version of this algorithm called `std::move()`, which moves
    elements instead of copying them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This performs a move instead of copy assignment. After the move operation,
    the elements in `v1` will be empty, and the elements that were in `v1` are now
    in `v2`. The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a `ranges` version of the `move()` algorithm that performs the
    same operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The power of these algorithms lies in their simplicity. By letting the iterators
    manage the data, these simple, elegant functions allow you to seamlessly copy
    or move between any of the STL containers that support the required iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Join container elements into a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, there is no algorithm in the library to accomplish a task at hand.
    We can use iterators, with the same techniques as the `algorithms` library, to
    easily write one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we often need to join elements from a container, with separators,
    into a string. One common solution is to use a simple `for()` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this otherwise simple solution is that it leaves a trailing
    separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This may be fine in a testing environment, but in any production system, that
    trailing comma is unacceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ranges::views` library has a `join()` function, but it doesn''t provide
    a separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `views::join()` function returns a `ranges::view` object. This requires
    a separate step to display or turn into a string. We can cycle through the view
    with a `for()` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It's all there, but we need a proper separator between the elements to make
    it useful for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `algorithms` library does not have a function that suits our needs,
    we'll write one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will take the elements of a container and join them into
    a string with separators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main()` function, we declare a vector of strings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s write a simple `join()` function that uses an `ostream` object
    to join elements with a separator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I've put this in my own `bw` namespace to avoid name collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call it with `cout` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Because it returns the `ostream` object, we can follow it with `<<` to add a
    *newline* to the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll often want a `string`, instead of directly writing to `cout`. We can
    overload this function for a version that returns a `string` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This also goes in the `bw` namespace. This function creates an `ostringstream`
    object to pass to the `ostream` version of `bw::join()`. It returns a `string`
    object from the `str()` method of the `ostringstream` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add one final overload to make this easier to use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This version just takes a container and a separator, which should satisfy most
    use cases nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the work in this recipe is done by the iterators and the `ostream`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The separators go after the first element, between each of the successive elements,
    and stop before the final element. This means we can either add a separator *before*
    each element, skipping the first, or *after* each element, skipping the last.
    The logic is simpler if we test for, and skip, the first element. We do that in
    the line just before the `while()` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the first element out of the way, we can simply add a separator
    before each remaining element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We return the `ostream` object as a convenience. This allows the user to easily
    add a newline, or other objects, to the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with any of the library algorithms, the `join()` function will work with
    any container that supports *forward iterators*. For example, here''s a `list`
    of `double` constants from the `numbers` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It will even work with a `ranges::view` object, like the `greek_view` defined
    earlier in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Sort containers with std::sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem of how to efficiently sort comparable elements is essentially solved.
    For most applications, there's no reason to re-invent this wheel. The STL provides
    an excellent sorting solution via the `std::sort()` algorithm. While the standard
    does not specify a sorting algorithm, it does specify a worst-case complexity
    of *O*(*n* log *n*), when applied to a range of *n* elements.
  prefs: []
  type: TYPE_NORMAL
- en: Just a few decades ago, the *quicksort* algorithm was considered a good compromise
    for most uses and was generally faster than other comparable algorithms. Today
    we have *hybrid* algorithms that choose between different approaches according
    to the circumstances, often switching algorithms on the fly. Most current C++
    libraries use a hybrid approach with some combination of *introsort* and an *insertion
    sort*. `std::sort()` provides exceptional performance under most common circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll examine the `std::sort()` algorithm. The `sort()` algorithm
    works with any container with random-access iterators. Here, we will use a `vector`
    of `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a function to test if a container is sorted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This uses the `std::is_sorted()` algorithm and prints either `"sorted:"` or
    `"unsorted:"` according to the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need a function to print our `vector`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function calls `check_sorted()` to display the status of the container
    before the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can define and print a `vector` of `int` in the `main()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test the `std::sort()` algorithm, we need an unsorted vector. Here''s
    a simple function to randomize our container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `std::random_device` class uses your system's hardware *entropy* source.
    Most modern systems have one, otherwise the library will simulate it. The `std::default_random_engine()`
    function generates random numbers from the entropy source. This is used by `std::shuffle()`
    to randomize the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now call `randomize()` with our container and print the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, your output will be different because it''s randomized. In fact,
    I get a different result every time I run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort the vector, we simply call `std::sort()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `sort()` algorithm uses the `<` operator to sort the elements
    in the range specified by the supplied iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `partial_sort()` algorithm will sort part of the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`partial_sort()` takes three iterators: beginning, middle, and end. It sorts
    the container such that the elements before the middle are sorted. The elements
    after the middle are not guaranteed to be in the original order. Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the first five elements are sorted, and the rest are not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `partition()` algorithm *does not* sort anything. It rearranges the container
    so that certain elements appear at the front of the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The third argument is a *predicate* lambda that determines which elements will
    be moved to the front.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the values `>5` are moved to the front of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sort()` algorithms support an optional comparison function that may be
    used for non-standard comparisons. For example, given a class called `things`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can create a `vector` of `things`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need a function to print them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can sort and print the `vector` of `things`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the comparison function sorts on the `i_` member, so the result is sorted
    by `i_`. We could instead sort on the `s_` member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sort()` functions work by applying a sorting algorithm to a range of elements
    indicated by two iterators, for the beginning and end of the range.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, these algorithms use the `<` operator to compare elements. Optionally,
    they may use a *comparison function*, often provided as a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The comparison function takes two arguments and returns a `bool`. It has a
    signature equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `sort()` functions use `std::swap()` to move elements. This is efficient
    in both compute cycles and memory usage, as it relieves the need to allocate space
    for reading and writing the objects being sorted. This is also why the `partial_sort()`
    and `partition()` functions cannot guarantee the order of unsorted elements.
  prefs: []
  type: TYPE_NORMAL
- en: Modify containers with std::transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::transform()` function is remarkably powerful and flexible. One of
    the more commonly deployed algorithms in the library, it applies a *function*
    or *lambda* to each element in a container, storing the results in another container
    while leaving the original in place.
  prefs: []
  type: TYPE_NORMAL
- en: Given its power, it's deceptively simple to use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will explore a few applications for the `std::transform()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a simple function that prints the contents of a container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll use this to view the results of our transformations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, let''s declare a couple of vectors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the contents of `v1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the `transform()` function to insert the square of each value
    into `v2`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `transform()` function takes four arguments. The first two are the `begin()`
    and `end()` iterators for the source range. The third argument is the `begin()`
    iterator for the destination range. In this case, we're using the `back_inserter()`
    algorithm to insert the results in `v2`. The fourth argument is the transformation
    function. In this case, we're using a simple lambda to square the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can use `transform()` with any type. Here''s an example that
    converts a `vector` of `string` objects to lowercase. First, we need a function
    to return the lowercase value of a string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can use the `str_lower()` function with transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This calls `str_lower()` for every element in `vstr1` and inserts the results
    into `vstr2`. The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: (Yes, Pluto will always be a planet to me.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also a `ranges` version of transform:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ranges` version has a more succinct syntax and returns a `view` object,
    rather than populating another container.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::transform()` function works very much like `std::copy()`, with the
    addition of the user-provided function. Each element in the input range is passed
    to the function, and the return value from the function is copy-assigned to the
    destination iterator. This makes `transform()` a singularly useful and powerful
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that `transform()` does not guarantee the elements will
    be processed in order. If you need to ensure the order of the transformation,
    you will want to use a `for` loop instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Find items in a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `algorithm` library contains a set of functions for finding elements in
    a container. The `std::find()` function, and its derivatives, search sequentially
    through a container and return an iterator pointing to the first matching element,
    or the `end()` element if there's no match.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `find()` algorithm works with any container that satisfies the *Forward*
    or *Input* iterator qualifications. For this recipe, we''ll use `vector` containers.
    The `find()` algorithm searches sequentially for the first matching element in
    a container. In this recipe, we''ll walk through a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by declaring a `vector` of `int` in the `main()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s search for the element with the value `7`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `find()` algorithm takes three arguments: the `begin()` and `end()` iterators,
    and the value to search. It returns an iterator to the first element it finds,
    or the `end()` iterator if the search failed to find a match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also search for something more complex than a scalar. The object needs
    to support the equality comparison operator, `==`. Here''s a simple struct with
    an `operator==()` overload:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `operator=()` overload only compares the `name` members.
  prefs: []
  type: TYPE_NORMAL
- en: I've also included an `str()` function that returns a `string` representation
    of a `City` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can declare a `vector` of `City` elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can search the `vector` of `City` just as we did with the `vector` of `int`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to search on the `pop` member instead of `name`, we can use the
    `find_if()` function with a predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The predicate tests the `pop` member, so we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the result from `find_if()` returns only the first element that
    satisfies the predicate, even though there are two elements in the `vector` with
    `pop` values greater than 20,000,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `find()` and `find_if()` functions return only one iterator. The `ranges`
    library provides `ranges::views::filter()`, a *view adapter* that will give us
    all the matching iterators without disturbing our `vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us both matching elements in our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `find()` and `find_if()` functions search sequentially through a container,
    checking each element until it finds a match. If it finds a match, it returns
    an iterator pointing to that match. If it reaches the `end()` iterator without
    finding a match, it returns the `end()` iterator to indicate no match was found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find()` function takes three arguments, the `begin()` and `end()` iterators,
    and a search value. The signature looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find_if()` function uses a predicate instead of a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both `find()` functions search sequentially and return when they find the first
    match. If you want to find more matching elements, you can use the `filter()`
    function from the `ranges` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter()` function returns a *view*, a non-destructive window into the
    container with only the filtered elements. We can then use the view as we would
    any other container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Limit the values of a container to a range with std::clamp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduced with C++17, the `std::clamp()` function can be used to limit the
    range of a numeric scalar to within minimum and maximum values. The function is
    optimized to use *move semantics*, where possible, for maximum speed and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use `clamp()` to constrain the values of a container by using it in a
    loop, or with the `transform()` algorithm. Let's look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a simple function for printing out the values of a container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the *format string* `"{:>5} "`. This right-aligns each value to `5` spaces,
    for a tabular view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we''ll define an *initializer list* for use with
    our container. This allows us to use the same values more than once:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's a nice range of values to work with `clamp()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also define some constants for use as our limits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll use these values in our calls to `clamp()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can define a container in our `main()` function. We''ll use a `vector`
    of `int`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the values from our initializer list, the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use a `for` loop with `clamp()` to limit the values to between 0
    and 500:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This applies the `clamp()` function to each value in the container, using 0
    and 500 for the low and high limits, respectively. Now, the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: After the `clamp()` operation, the negative values are 0 and the values greater
    than 500 are 500.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same thing with the `transform()` algorithm, using `clamp()`
    in a lambda. This time we''ll use a `list` container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is the same as in the version with a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `clamp()` algorithm is a simple function that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: If the value of `v` is less than `lo`, it returns `lo`. If `hi` is less than
    `v`, it returns `hi`. The function is fast and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our examples, we used a `for` loop to apply `clamp()` to a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'We also used the `transform()` algorithm with `clamp()` in a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: In my experiments, both versions gave the same results, and both produced similar
    code from the GCC compiler. There was a slight difference in compiled size (the
    version with the `for` loop was smaller, as expected) and a negligible difference
    in performance.
  prefs: []
  type: TYPE_NORMAL
- en: In general, I prefer the `for` loop, but the `transform()` version may be more
    flexible in other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Sample data sets with std::sample
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::sample()` algorithm takes a random *sample* of a sequence of values
    and populates a destination container with the sample. It is useful for analyzing
    a larger set of data, where the random sample is taken to be representative of
    the whole.
  prefs: []
  type: TYPE_NORMAL
- en: A sample set allows us to approximate the characteristics of a large set of
    data, without analyzing the full set. This provides efficiency in exchange for
    accuracy, a fair trade-off in many circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll use an array of 200,000 random integers, with *standard
    normal distribution*. We'll sample a few hundred values to create a histogram
    of the frequency of each value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a simple function to return a rounded `int` from a `double`.
    The standard library lacks such a function and we''ll need it later:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The standard library provides several versions of `std::round()`, including
    one that returns a `long int`. But we need an `int`, and this is a simple solution
    that avoids compiler warnings about narrowing conversion while hiding away the
    unsightly `static_cast`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we''ll start with some useful constants:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have values for `n_data` and `n_samples`, used for the size of the data and
    sample containers, respectively. We also have values for `mean` and `dev`, the
    *mean* and *standard deviation* parameters for the *normal distribution* of random
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now set up our *random number generator* and *distribution* objects. These
    are used to initialize the source data set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `random_device` object provides access to the hardware random number generator.
    The `mt19937` class is an implementation of the *Mersenne Twister* random number
    algorithm, a high-quality algorithm that will perform well on most systems with
    a data set of the size we're using. The `normal_distribution` class provides a
    distribution of random numbers around the *mean* with the *standard deviation*
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we populate an array with an `n_data` number of random `int` values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `array` container is fixed in size, so the template parameters include a
    `size_t` value for the number of elements to allocate. We use a `for()` loop to
    populate the array.
  prefs: []
  type: TYPE_NORMAL
- en: The `rng` object is the hardware random number generator. This is passed to
    `dist()`, our `normal_distribution` object, and then to `iround()`, our integer
    rounding function.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have an array with 200,000 data points. That''s a lot to
    analyze, so we''ll use the `sample()` algorithm to take a sample of 500 values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define another `array` object to hold the samples. This one is `n_samples`
    in size. Then we use the `sample()` algorithm to populate the array with `n_samples`
    random data points.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a histogram to analyze the samples. A `map` structure is perfect
    for this as we can easily map the frequency of each value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `for()` loop takes each value from the `samples` container and uses it as
    a key in the `map`. The increment expression `++hist[i]` counts the number of
    occurrences of each value in the sample set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We print out the histogram using the C++20 `format()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `format()` specifiers that look like `{:>3}` make space for a certain number
    of characters. The angle bracket specifies alignment, right or left.
  prefs: []
  type: TYPE_NORMAL
- en: The `string(count, char)` constructor creates a `string` with a character repeated
    the number of times specified, in this case, *n* asterisk characters `*`, where
    *n* is `count/scale`, the frequency of a value in the histogram, divided by the
    `scale` constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This is a nice graphical representation of the histogram. The first number is
    the value, the second number is the frequency of the value, and the asterisks
    are a visual representation of the frequency, where each asterisk represents `scale`
    (3) occurrences in the sample set.
  prefs: []
  type: TYPE_NORMAL
- en: Your output will differ each time you run the code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::sample()` function selects a specific number of elements from random
    locations in the source container and copies them to the destination container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of `sample()` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The first two arguments are `begin()` and `end()` iterators on a container with
    the full data set. The third argument is an iterator for the destination of the
    samples. The fourth argument is the sample size, and the final argument is a random
    number generator function.
  prefs: []
  type: TYPE_NORMAL
- en: The `sample()` algorithm uses *uniform distribution*, so each data point has
    the same chance of being sampled.
  prefs: []
  type: TYPE_NORMAL
- en: Generate permutations of data sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many use cases for permutations, including testing, statistics, research,
    and more. The `next_permutation()` algorithm generates permutations by re-ordering
    a container to the next *lexicographical* permutation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will print out the permutations of a set of three strings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a short function for printing the contents of a container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll use this simple function to print our data set and permutations.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main()` function, we declare a `vector` of `string` objects and sort
    it with the `sort()` algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `next_permutation()` function requires a sorted container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can list the permutations with `next_permutation()` in a `do` loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `next_permutation()` function modifies the container and returns `true`
    if there is another permutation, or `false` if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output lists six permutations of our three pets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::next_permutation()` algorithm generates *lexicographical* permutations
    of a set of values, that is, permutations based on dictionary ordering. The input
    must be sorted because the algorithm steps through permutations in lexicographical
    order. So, if you start with a set like 3, 2, 1, it will terminate immediately
    as this is the last lexicographical order of those three elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: While the term *lexicographical* implies alphabetical ordering, the implementation
    uses standard comparison operators, so it works on any sortable values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, if values in the set repeat, they are only counted according to *lexicographical*
    order. Here we have a `vector` of `int` with two repeating sequences of five values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: There are 113,400 permutations of these values. Notice that it's not *10!* (3,628,800)
    because some values repeat. Since *3,3* and *3,3* sort the same, they are not
    different *lexicographical* permutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, if I list the permutations of this short set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'We get only three permutations, not *3!* (9), because of the repeating values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Merge sorted containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::merge()` algorithm takes two sorted sequences and creates a third
    merged and sorted sequence. This technique is often used as part of a *merge sort*,
    allowing very large amounts of data to be broken down into chunks, sorted separately,
    and merged into one sorted target.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we'll take two sorted `vector` containers and merge them into
    a third `vector` using `std::merge()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a simple function to print the contents of a container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll use this to print the source and destination sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we''ll declare our source vectors, along with the
    destination vector, and print them out:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can sort our vectors and print them again:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our source containers are sorted, we can merge them for our final
    merged result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: This output represents the merge of the two sources into one sorted vector.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `merge()` algorithm takes `begin()` and `end()` iterators from both the
    sources and an output iterator for the destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: It takes the two input ranges, performs its merge/sort operation, and sends
    the resulting sequence to the output iterator.
  prefs: []
  type: TYPE_NORMAL
