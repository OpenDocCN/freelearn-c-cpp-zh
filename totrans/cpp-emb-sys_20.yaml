- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing Scalable Finite State Machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Finite State Machine** (`FSM`) is an abstract computational module used
    to represent a system that can be in exactly one of a finite number of states
    at any given time. An `FSM` can transition from one state to another on a given
    input, and it can perform an action during the transition.
  prefs: []
  type: TYPE_NORMAL
- en: In control theory, there is a classification of Moore and Mealy machines. Moore’s
    `FSM` output depends only on a state, that is, the `FSM` uses only entry actions.
    Mealy’s `FSM` output depends on the input and current state, that is, the action
    it performs is determined by both the current state and the input.
  prefs: []
  type: TYPE_NORMAL
- en: The `FSM`s that we will cover in this chapter are a combination of both Moore
    and Mealy `FSM`s as they support both actions performed during transitions and
    entry and exit actions that depend only on a current state. `FSM`s are also called
    **Unified Modeling Language** (**UML**) state machines and are used in real-life
    applications in embedded systems to describe and control machines. For example,
    `FSM`s are commonly used to control washing machines, elevator systems, or communication
    protocols in networking devices, for managing complex sequences of operations
    based on various inputs. Understanding `FSM`s will help you design more predictable
    and maintainable embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FSM` – a simple implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FSM` – implementation using the State pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State pattern implementation using tag dispatching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost SML (State Machine Language)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (`stdio`) results and better observe the code’s behavior.
    As we are using a lot of modern C++ features, make sure to select the C++23 standard,
    by adding `-std=c++23` in the compiler options box.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly. Most of the examples can
    also be run in a Renode simulator on an ARM Cortex M0 target and are available
    on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter16](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter16)).
  prefs: []
  type: TYPE_NORMAL
- en: FSM – a simple implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will jump straight into an example of an `FSM` handling **Bluetooth Low Energy**
    (**BLE**) device connection states, analyze its shortcomings, and see how we can
    improve it using the State design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example `FSM` will be simplified for the purpose of clarity and easier
    understanding. We will have three states – `idle`, `advertising`, and `connected`.
    Here is a state diagram of the example `FSM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – BLE device connection state diagram](img/B22402_16_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – BLE device connection state diagram
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16**.1* depicts the state diagram of the BLE device connection `FSM`.
    The diagram depicts transitions between states and actions described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The default state is `idle`. It transitions to the `advertising` state on a
    `ble_button_pressed` event. During the transition, the `start_advertising` action
    is executed. In simple words, this means that if the device is in an `idle` state
    and a user presses a designated button, it will start advertising and change state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the `advertising` state, the `FSM` can transition to `connected` on a `connection_request`
    event or go back to `idle` on the `timer_expired` state while stopping the advertising
    by executing the `stop_advertising` action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in the `connected` state, the `FSM` can go only to `idle` on the `ble_button_pressed`
    event while executing the `disconnect` action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that this is an extremely simplified `FSM` we are using for the
    purpose of an example, and a real-life `FSM` would include more states and events
    to properly describe the connecting behavior of a BLE device.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `FSM` can also be described using state transition tables. This table shows
    the state to which the `FSM` moves based on the current state and input (received
    event), as well as the action it performs during the transition. Here is the transition
    table for the BLE device `FSM` we are analyzing in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Current State** | **Event** | **Next State** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **idle** | `ble_button_pressed` | advertising | `start_advertising` |'
  prefs: []
  type: TYPE_TB
- en: '| **advertising** | `timer_expired` | `idle` | `stop_advertising` |'
  prefs: []
  type: TYPE_TB
- en: '| **advertising** | `connection_request` | connected |  |'
  prefs: []
  type: TYPE_TB
- en: '| **connected** | `ble_button_pressed` | `idle` | disconnect |'
  prefs: []
  type: TYPE_TB
- en: Table 16.1 – BLE device state transition table
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 16.1* describes the BLE device `FSM` by listing transitions in rows.
    It serves as an alternative to the state diagram for describing `FSM` behavior.
    We will start with the implementation of this `FSM` first by defining states and
    events.'
  prefs: []
  type: TYPE_NORMAL
- en: Describing states and events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will model states and events as `enum`erators, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `enum`erators describe states and events for our BLE device `FSM`.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking current state and handling events – the FSM class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will define a class `ble_fsm` that will keep track of the current
    state and provide a public method, `handle_event`, which we will use to feed the
    `FSM` with events. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code above, we define the class ble_fsm with the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ble_state current_state_` – A private member with the default value `ble_state::idle`.
    We use it to track the current state, and the initial value is set to `idle`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void start_advertising()` – A private method used to implement an action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void stop_advertising()` – A private method used to implement an action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void disconnect()` – A private method used to implement an action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ble_state get_state() const` – A private method used to retrieve the current
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void handle_event(ble_event event)` – A public method used to respond to events
    by executing actions and changing the current state depending on the `current_event_`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `handle_event` method implements the actual behavior of the `FSM`, and
    the code for it is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the implementation of the `handle_event` method for
    the `ble_fsm` class. It uses a `switch` statement on `current_state_` to handle
    the event according to it and receive the event. The event is handled by calling
    an appropriate action and changing the state as described by the `FSM`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to use the `ble_fsm` class.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ble_fsm class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will first define a helper function, `state_to_string`, used to debug our
    `FSM`. The code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `state_to_string` function returns a string literal for a given state `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us see how to use the `ble_fsm` class, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code in the `main` function creates an object, `my_ble_fsm`,
    of the `ble_fsm` type, and it feeds it with events in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: It first passes `ble_event::ble_button_pressed` to the `FSM` handle_event method.
    The initial state of the `FSM` is `idle`, and after this event, it will transition
    to `advertising`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it passes the `ble_event::connection_request` event to the `FSM`, which
    will make it transition to the `connected` state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it passes the `ble_event::ble_button_pressed` event to the `FSM` for
    the second time, making it transition back to the `idle` state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code above uses the `state_to_string` function to get the string literal
    from the state `enum`, and it uses it to print the current state of the `FSM`
    after it feeds it with an event.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running the full example will provide the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows `FSM` states and the executed actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the full example in the Renode simulator from the book’s GitHub
    repo. It is placed under `Chapter16/fsm`, and you can build and run it using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The approach for implementing an `FSM` we just went through works well for simple
    `FSM`s. In real-life applications, `FSM`s are more complex – they have more states,
    actions, and events. The `handle_event` method in `ble_fsm` doesn’t scale well
    as it is implemented using `switch-case` and `if-else` logic. Adding more states,
    and handling more events and actions, makes it less readable and harder to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how we can utilize the State design pattern to mitigate these
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: FSM – implementation using the State pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on our switch-based approach, we will now refactor the BLE device connection
    `FSM` using the State design pattern. This pattern is “state-centric,” meaning
    each state is encapsulated as its own class. A common base class interface will
    allow the `FSM` to store pointers to these concrete state classes in a container.
  prefs: []
  type: TYPE_NORMAL
- en: In a typical `FSM`, states change dynamically at runtime in response to external
    interrupts and timers. In our example, we will continue using an `enum` to differentiate
    states and store the current one in a private member variable. This `enum`-based
    approach still works well with the State pattern, since it lets us quickly locate
    and switch between the concrete state objects that the `FSM` manages. We will
    start the implementation with the state class interface.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding state class interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `state` class interface is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we see that the state interface is simple and has two
    pure virtual methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`virtual ble_state handle_event(ble_event event)` – A method intended to be
    implemented by a derived class to handle an actual event. It returns a `ble_state`
    `enum` to signal a new state to an `FSM`. If handling an event doesn’t cause transition,
    it should return the `enum` that corresponds to the current state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtual ble_state get_state_enum()` – A method used to return a `ble_state`
    `enum` corresponding to an actual state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will go over the implementation of concrete state classes: `idle`,
    `advertising`, and `connected`. We will start with the `idle` class, as shown
    in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we see that the `idle` class implements pure virtual
    methods defined in the `state` interface class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ble_state handle_event(ble_event event)` – The `idle` class checks whether
    the received event is `ble_event::ble_button_pressed` and calls `start_advertising`
    if it is and returns the `ble_state::advertising` `enum`. In the case that it
    receives any other event, it returns the state provided with `get_state_enum`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ble_state get_state_enum()` – This returns the `ble_state` `enum` corresponding
    to the `idle` class, which is `ble_state::idle`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will go through the derived class `advertising`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the `advertising` class implements pure virtual methods defined
    in the `state` interface class by handling the events appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will go over the `connected` concrete class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, the `connected` class implements a state
    interface and implements the virtual methods `handle_event` and `get_state_enum`
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will refactor the `ble_fsm` class to use the state class interface
    to store pointers to concrete class objects in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the ble_fsm class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with refactoring the `ble_fsm` class, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us break down the implementation of the `ble_fsm` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ble_state current_state_` – A private member with the default value `ble_state::idle`.
    We use it to track the current state, as we did previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etl::vector<state*, 3> states_` – A container used to hold pointers to the
    state interface. If you are following this example using Compiler Explorer, you
    can replace it with `std::vector` (and include a `<vector>` header).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state* get_the_state(ble_state state_enum)` – A private method used to get
    an actual state using the `ble_state` `enum`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void handle_event(ble_event event)` – A public method used to handle events.
    It calls the `get_the_state` method provided with `current_state_` to get a pointer
    to the actual state object. If the pointer is valid, it calls `handle_event` on
    the state object and stores the return value in `current_state_`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let us go through the `get_the_state` method implementation, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the `get_the_state` method, we use the `std::find_if` function (from the
    `<algorithm>` header) to search for a pointer to a `state` object that matches
    the given `state_enum`. The search uses the `is_state_enum` lambda as a predicate,
    which compares each state’s `enum` value. If a matching state is found, the method
    returns a pointer to it; otherwise, the `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us see how to use the refactored `ble_fsm` class, the `state` interface,
    and the concrete classes `idle`, `advertising`, and `connected` to implement the
    `FSM`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the State pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will see how to use the above implementation of the State pattern
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we see that after creating an object `my_ble_fsm` of the `ble_fsm`
    type, we create instances of concrete states: `idle`, `advertising`, and `connected`.
    Then, we add pointers to the concrete states to the `my_ble_fsm` object using
    the `add_state` method. Next, we use the `FSM` as we did in the initial implementation
    and feed it with events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the full example in the Renode simulator from the book’s GitHub
    repo. It is placed under `Chapter16/fsm`, and you can build and run it using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The example we just went through is using the State design pattern. Next, we
    will go through the generic form of the State design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: State design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us go over the UML diagram of the BLE device connection `FSM`, as shown
    in *Figure 16**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – BLE device connection FSM – UML diagram](img/B22402_16_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – BLE device connection FSM – UML diagram
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16**.2* depicts a UML diagram of the BLE device connection `FSM`. We
    already went through applying the State design pattern to the `FSM` implementation.
    Let us summarize it:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FSM` class holds pointers to the state class interface in a container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FSM` keeps track of the current state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FSM` delegates `handle_event` calls to a current concrete state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete states implement the state interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete states implement actions and call them appropriately when handling
    events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete states return a new state from the `handle_event` method. This allows
    the `FSM` to update the current state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state design pattern is a simple yet effective pattern that allows us to
    break down complex switch statements into more manageable code. Still, as we were
    able to see in the previous example, concrete states handle events using `if-else`
    logic. With the increasing complexity of an `FSM`, the handle functions can also
    clutter. To mitigate this, we can apply the tag-dispatching technique.
  prefs: []
  type: TYPE_NORMAL
- en: State pattern implementation using tag dispatching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example (in the previous sections), the program flow in event
    handlers was determined at runtime using `if-else` logic. Next, we will use the
    tag-dispatching technique to decouple event handling of different events in separate
    methods. We will rely no longer on the `ble_event` `enum`, and will create empty
    types as events instead, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the class `state` will overload `handle_event` virtual methods for every
    defined event, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we see that the class `state` is no longer an interface but an
    abstract class (as not all virtual methods are pure). It overloads the `handle_event`
    function for types `ble_button_pressed`, `connection_request`, and `timer_expired`.
    It implements all overloads by returning the value generated by `get_state_enum`
    – a pure virtual method that will be implemented by derived classes, that is,
    concrete states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us see the implementation of the `advertising` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we see that the `advertising` class implements the following
    overloads of the virtual method `handle_event`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ble_state handle_event(connection_request cr)` returns `ble_state::connected`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ble_state handle_event(timer_expired te)` calls `stop_advertising` and returns
    `ble_state::idle`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By using overloaded functions, we can implement the handling of different events
    in separate methods and easily dispatch calls to them by calling `handle_event`
    with different types. To complete the implementation, we also need to overload
    the `handle_event` method in the `FSM` for all possible events. We can do this
    easily by making it a template method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the template method `handle_event` from the `ble_fsm`
    class, which makes our tag-dispatching technique application complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the full example in the Renode simulator from the book’s GitHub
    repo. It is placed under `Chapter16/fsm`, and you can build and run it using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Until this point, we saw three approaches in this chapter to implement an `FSM`
    in C++. We started with a simple switch and if-else-based approach, applied the
    State design pattern, and then utilized tag dispatching. Each step provided us
    with more flexibility in the design – making code more readable and easier to
    manage, which is important when working with complex `FSM`s.
  prefs: []
  type: TYPE_NORMAL
- en: There are other approaches to implementing an `FSM`, based on a state transition
    table, which describes transitions in a single place. Boost **State Machine Language**
    (**SML**) uses a table-based approach to describe an `FSM` using descriptive syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Boost SML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boost SML is a highly expressive C++14 single header library used to implement
    `FSM`s. We will jump straight ahead in using it by implementing the same BLE device
    connection `FSM`. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us break down this example:'
  prefs: []
  type: TYPE_NORMAL
- en: The events are modeled as structs, the same as in our tag-dispatching implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions are defined as `constexpr` lambdas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define the type `ble_fsm` as a struct with an overloaded `operator()`, which
    returns the result of a call to `make_transition_table` from the namespace `sml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code in `make_transition_table` allows SML to extract transition definitions,
    and within it, we are using the following syntax: `src_state + event [ guard ]
    / action = dst_state`. Here is a breakdown of the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src_state` – This is the state from which the transition starts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+ event` – This is the event that triggers checking for a possible transition.
    If the event arrives and the guard is satisfied, then the transition proceeds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ guard ]` – The guard is an optional bool predicate that must evaluate to
    true for the transition to occur. If omitted, the transition happens unconditionally
    at the specified event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/ action` – The action is an optional lambda to execute whenever the transition
    takes place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`= dst_state` – The destination state is where the `FSM` will go if the transition
    occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transition syntax is the essence of SML. By writing multiple lines of these
    rules inside the `operator()`, we fully describe the `FSM`'s behavior in a declarative,
    human-readable way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see how to use the `FSM` we discussed using Boost SML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we create an object `my_ble_fsm` of the type `sm<ble_fsm>`. Then,
    we use the `process_event` method to send an event to it. You can run the full
    example in the Renode simulator from the book’s GitHub repo. It is placed under
    `Chapter16/fsm`, and you can build and run it using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Boost SML is a highly expressive library that reduces boilerplate code from
    the previous implementations of an `FSM`. It also offers features such as guard
    variables and composite states. Here is a project link where you can explore more:
    [https://github.com/boost-ext/sml](https://github.com/boost-ext/sml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boost SML is not only an expressive library but also highly performant, thanks
    to its use of compile-time template metaprogramming to aggressively optimize code.
    Event dispatching relies on tag dispatching (resolved at compile time) paired
    with minimal runtime lookups, avoiding costly branching or indirection. This approach
    typically outperforms both manual switch-`enum`-based solutions and State pattern-based
    implementations (which incur virtual call overhead). For concrete performance
    comparisons, see the benchmark at the following link: [https://github.com/boost-ext/sml?tab=readme-ov-file#benchmark](https://github.com/boost-ext/sml?tab=readme-ov-file#benchmark).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we went through `FSM` implementation starting from the simple
    switch-case-based approach, to the State pattern, tag dispatching, and using the
    Boost SML library for highly expressive code.
  prefs: []
  type: TYPE_NORMAL
- en: The most basic, switch-based implementation is suitable for small `FSM`s with
    a limited number of states and transitions. When the complexity of an `FSM` increases,
    it gets hard to read and manage. Moving to a State pattern-based solution increases
    code readability and makes changes easier. Boost SML offers ultimate expressiveness,
    providing us with a human-readable syntax that allows us to write very complex
    `FSM`s in a concise manner.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through an overview of libraries and frameworks
    in C++ usable for embedded systems development.
  prefs: []
  type: TYPE_NORMAL
