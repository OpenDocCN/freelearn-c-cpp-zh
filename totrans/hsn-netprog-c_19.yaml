- en: Answers to Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1, Introducing Networks and Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are the key differences between IPv4 and IPv6?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IPv4 only supports 4 billion unique addresses, and because they were allocated
    inefficiently, we are now running out. IPv6 supports 3.4 x 10^(38) possible addresses.
    IPv6 provides many other improvements, but this is the one that affects our network
    programming directly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are the IP addresses given by the `ipconfig` and `ifconfig` commands the
    same IP addresses that a remote web server sees if you connect to it?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes, these addresses will match, but not always. If you're on a private
    IPv4 network, then your router likely performs network address translation. The
    remote web server then sees the translated address.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a publicly routable IPv4 or IPv6 address, then the address seen
    by the remote web server will match those reported by `ipconfig` and `ifconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the IPv4 loopback address?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IPv4 loopback address is `127.0.0.1`, and it allows networked programs to
    communicate with each other while executing on the same machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the IPv6 loopback address?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IPv6 loopback address is `::1`. It works in the same way as the IPv4 loopback
    address.
  prefs: []
  type: TYPE_NORMAL
- en: '**How are domain names (for example, `example.com`) resolved into IP addresses?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DNS is used to resolve domain names into IP addresses. This protocol is covered
    in detail in [Chapter 5](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml), *Hostname
    Resolution and DNS*.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you find your public IP address?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The easiest way is to visit a website that reports it for you.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does an operating system know which application is responsible for an
    incoming packet?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each IP packet has a local address, remote address, local port number, remote
    port number, and protocol type. These five attributes are memorized by the operating
    system to determine which application should handle any given incoming packet.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2, Getting to Grips with Socket APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a socket?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A socket is an abstraction that represents one endpoint of a communication link
    between systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is a connectionless protocol? What is a connection-oriented protocol?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A connection-oriented protocol sends data packets in the context of a larger
    stream of data. A connectionless protocol sends each packet of data independently
    of any before or after it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is UDP a connectionless or connection-oriented protocol?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UDP is considered a connectionless protocol. Each message is sent independently
    of any before or after it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is TCP a connectionless or connection-oriented protocol?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TCP is considered a connection-oriented protocol. Data is sent and received
    in order as a stream.
  prefs: []
  type: TYPE_NORMAL
- en: '**What types of applications generally benefit from using the UDP protocol?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UDP applications benefit from better real-time performance while sacrificing
    reliability. They are also able to take advantage of IP multicasting.
  prefs: []
  type: TYPE_NORMAL
- en: '**What types of applications generally benefit from using the TCP protocol?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applications that need a reliable stream of data transfer benefit from the TCP
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does TCP guarantee that data will be transmitted successfully?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TCP makes some guarantees about reliability, but nothing can truly guarantee
    that data is transmitted successfully. For example, if someone unplugs your modem,
    no protocol can overcome that.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are some of the main differences between Berkeley sockets and Winsock
    sockets?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The header files are different. Sockets themselves are represented as signed
    versus unsigned `ints`. When `socket()` or `accept()` calls fail, the return values
    are different. Berkeley sockets are also standard file descriptions. This isn't
    always true with Winsock. Error codes are different and retrieved in a different
    way. There are additional differences, but these are the main ones that affect
    our programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**What does the `bind()` function do? **'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `bind()` function associates a socket with a particular local network address
    and port number. Its usage is almost always required for the server, and it's
    usually not required for the client.
  prefs: []
  type: TYPE_NORMAL
- en: '**What does the `accept()` function do?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `accept()` function will block until a new TCP client has connected. It
    then returns the socket for this new connection.
  prefs: []
  type: TYPE_NORMAL
- en: '**In a TCP connection, does the client or the server send application data
    first?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either the client or the server can send data first. They can even send data
    simultaneously. In practice, many client-server protocols (such as HTTP) work
    by having the client send a request first and then having the server send a response.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3, An In-Depth Overview of TCP Connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How can we tell if the next call to `recv()` will block?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `select()` function to indicate which sockets are ready to be read
    from without blocking.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you ensure that `select()` doesn''t block for longer than a specified
    tim**e?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can pass `select()` a timeout parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '**When we used our `tcp_client` program to connect to a web server, why did
    we need to send a blank line before the web server responded?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTP, the web server's protocol, expects a blank line to indicate the end of
    the request. Without this blank line, it wouldn't know if the client was going
    to keep sending additional request headers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does `send()` ever block?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. You can use `select()` to determine when a socket is ready to be written
    to without blocking. Alternatively, sockets can be put into non-blocking mode.
    See [Chapter 13](11c5bb82-e55f-4977-bf7f-5dbe791fde92.xhtml), *Socket Programming
    Tips **and Pitfalls*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can we tell if a socket has been disconnected by our peer?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The return value of `recv()` can indicate if a socket has been disconnected.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is data received by `recv()` always the same size as data sent with `send()`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. TCP is a stream protocol. There is no way to tell if the data returned from
    one `recv()` call was sent with one or many calls to `send()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is wrong with it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Also see what is wrong with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The data returned by `recv()` is not null terminated! Both of the preceding
    code excerpts will likely cause `printf()` to read past the end of the data returned
    by `recv()`. Additionally, in the first code example the data received could contain
    format specifiers (for example `%d`), which would cause additional memory access
    violations.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4, Establishing UDP Connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How do `sendto()` and `recvfrom()` differ from `send()` and `recv()`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `send()` and `recv()` functions are useful after calling `connect()`. They
    only work with the one remote address that was passed to `connect()`. The `sendto()`
    and `recvfrom()` functions can be used with multiple remote addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can `send()` and `recv()` be used on UDP sockets?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. The `connect()` function should be called first in that case. However,
    the `sendto()` and `recvfrom()` functions are often more useful for UDP sockets.
  prefs: []
  type: TYPE_NORMAL
- en: '**What does `connect()` do in the case of a UDP socket?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `connect()` function associates the socket with a remote address.
  prefs: []
  type: TYPE_NORMAL
- en: '**What makes multiplexing with UDP easier than with TCP?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One UDP socket can talk to multiple remote peers. For TCP, one socket is needed
    for each peer.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the downsides to UDP when compared to TCP?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UDP does not attempt to fix many of the errors that TCP does. For example, TCP
    ensures that data arrives in the same order it was sent, TCP tries to avoid causing
    network congestion, and TCP attempts to resend lost packets. UDP does none of
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can the same program use UDP and TCP?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. It just needs to create sockets for both.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5, Hostname Resolution and DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Which function fills in an address needed for socket programming in a portable
    and protocol-independent way?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getaddrinfo()` is the function to use for this.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Which socket programming function can be used to convert an IP address back
    into a name?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getnameinfo()` can be used to convert addresses back to names.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A DNS query converts a name to an address, and a reverse DNS query converts
    an address back into a name. If you run a DNS query on a name, and then a reverse
    DNS query on the resulting address, do you always get back the name you started
    with?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes, you will get the same name back but not always. This is because the
    forward and reverse lookups use independent records. It's also possible to have
    many names point to one address, but that one address can only have one record
    that points back to a single name.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the DNS record types used to return IPv4 and IPv6 addresses for
    a name?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `A` record type returns an IPv4 address, and the `AAAA` record type returns
    an IPv6 address.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which DNS record type stores special information about email servers?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `MX` record type is used to return email server information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does `getaddrinfo()` always return immediately? Or can it block?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `getaddrinfo()` is doing name lookups, it will often block. In the worst-case
    scenario, many UDP messages would need to be sent to various DNS servers, so this
    can be a noticeable delay. This is one reason why DNS caching is important.
  prefs: []
  type: TYPE_NORMAL
- en: If you are simply using `getaddrinfo()` to convert from a text IP address, then
    it shouldn't block.
  prefs: []
  type: TYPE_NORMAL
- en: '**What happens when a DNS response is too large to fit into a single UDP packet?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DNS response will have the `TC` bit set in its header. This indicates that
    the message was truncated. The query should be resent using TCP.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6, Building a Simple Web Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Does HTTP use TCP or UDP?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTP runs over TCP port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What types of resources can be sent over HTTP?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTP can be used to transfer essentially any computer file. It's commonly used
    for web pages (HTML) and the associated files (such as styles, scripts, fonts,
    and images).
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the common HTTP request types?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GET`, `POST`, and `HEAD` are the most common HTTP request types.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What HTTP request type is typically used to send data from the server to
    the client?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GET` is the usual request type for a client to request a resource from the
    server.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What HTTP request type is typically used to send data from the client to
    the server?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`POST` is used when the client needs to send data to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the two common methods used to determine an HTTP response body length?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The HTTP body length is commonly determined by the `Content-Length` header
    or by using `Transfer-Encoding: chunked`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How is the HTTP request body formatted for a `POST`-type HTTP request?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is determined by the application. The client should set the `Content-Type`
    header to specify which format it is using. `application/x-www-form-urlencoded`
    and `application/json` are common values.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7, Building a Simple Web Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How does an HTTP client indicate that it has finished sending the HTTP request?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HTTP request should end with a blank line.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does an HTTP client know what type of content the HTTP server is sending?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HTTP server should identify the content with a `Content-Type` header.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can an HTTP server identify a file''s media type?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A common method of identifying a file's media type is just to look at the file
    extension. The server is free to use other methods though. When sending dynamic
    pages or data from a database, there will be no file and therefore no file extension.
    In this case, the server must know the media type from its context.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you tell whether a file exists on the filesystem and is readable
    by your program? Is `fopen(filename, "r") != 0` a good test?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is not a trivial problem. A robust program will need to consider system
    specific APIs carefully. Windows uses special filenames that will trip up a program
    that relies only on `fopen()` to check for a file's existence.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8, Making Your Program Send Email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What port does SMTP operate on?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SMTP does mail transmission over TCP port `25`. Many providers use alternative
    ports for mail submission.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you determine which SMTP server receives mail for a given domain?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mail servers responsible for receiving mail for a given domain are given
    by MX-type DNS records.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you determine which SMTP server sends mail for a given provider?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's not possible to determine that in the general case. In any case, several
    servers could be responsible. Sometimes these servers will be listed under a TXT-type
    DNS record using SPF, but that is certainly not universal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why won''t an SMTP server relay mail without authentication?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open relay SMTP servers are targeted by spammers. SMTP servers require authentication
    to prevent abuse.
  prefs: []
  type: TYPE_NORMAL
- en: '**How are binary files sent as email attachments when SMTP is a text-based
    protocol?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Binary files must be re-encoded as plain text. The most common method is with `Content-Transfer-Encoding:
    base64`.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9, Loading Secure Web Pages with HTTPS and OpenSSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What port does HTTPS typically operate on?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTPS connects over TCP port `443`.
  prefs: []
  type: TYPE_NORMAL
- en: '**How many keys does symmetric encryption use?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Symmetric encryption uses one key. Data is encrypted and decrypted with the
    same key.
  prefs: []
  type: TYPE_NORMAL
- en: '**How many keys does asymmetric encryption use?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Asymmetric encryption use two different, but mathematically related, keys. Data
    is encrypted with one and decrypted with the other.
  prefs: []
  type: TYPE_NORMAL
- en: '**Does TLS use symmetric or asymmetric encryption?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TLS use both symmetric and asymmetric encryption algorithms to function.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between SSL and TLS?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TLS is the successor to SSL. SSL is now deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: '**What purpose do certificates fulfill?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Certificates allow a server or client to verify their identity.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10, Implementing a Secure Web Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**How does a client decide whether it should trust a server''s certificate?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are various ways a client can trust a server's certificate. The chain-of-trust
    model is the most common. In this model, the client explicitly trusts an authority.
    The client then implicitly trusts any certificates it encounters that are signed
    by this trusted authority.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the main issue with self-signed certificates?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self-signed certificates aren't signed by a trusted certificate authority. Web
    browsers won't know to trust self-signed certificates unless the user adds a special
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: '**What can cause `SSL_accept()` to fail?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SSL_accept()` fails if the client doesn''t trust the server''s certificate
    or if the client and server can''t agree on a mutually supported protocol version
    and cipher suite.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Can `select()` be used to multiplex connections for HTTPS servers?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, but be aware that `select()` works on the underlying TCP connection layer,
    not on the TLS layer. Therefore, when `select()` indicates that a socket has data
    waiting, it does not necessarily mean that there is new TLS data ready.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11, Establishing SSH Connections with libssh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a significant downside of using Telnet?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Essentially, Telnet provides no security features. Passwords are sent as plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which port does SSH typically run on?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSH's official port is TCP port `22`. In practice, it is common to run SSH on
    arbitrary ports in an attempt to hide from attackers. With a properly secured
    server, these attackers are a nuisance rather than a legitimate threat.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is it essential that the client authenticates the SSH server?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the client doesn't verify the SSH server's identity, then it could be tricked
    into sending credentials to an impostor.
  prefs: []
  type: TYPE_NORMAL
- en: '**How is the server typically authenticated?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSH servers typically use certificates to identity themselves. This is similar
    to how servers are authenticated when using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: '**How is the SSH client typically authenticated?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is still common for clients to authenticate with a password. The downside
    to this method is that if a client is somehow tricked into connecting to an impostor
    server, then their password will be compromised. SSH provides alternate methods,
    including authenticating clients using certificates, that aren't susceptible to
    replay attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12, Network Monitoring and Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Which tool would you use to test the reachability of a target system?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ping` tool is useful to test reachability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which tool lists the routers to a destination system?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `traceroute` (`tracert` on Windows) tool will show the network path to a
    target system.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are raw sockets used for?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Raw sockets allow the programmer to specify directly what goes into a network
    packet. They provide lower-level access than TCP and UDP sockets, and can be used
    to implement additional protocols, such as ICMP.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which tools list the open TCP sockets on your system?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The netstat tool can be used to show open connections on your local system.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is one of the biggest concerns with security for networked C programs?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When programming networked applications in C, special care must be given to
    memory safety. Even a small mistake could allow an attacker to compromise your
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13, Socket Programming Tips and Pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Is it ever acceptable just to terminate a program if a network error is detected?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. For some applications terminating on error is the right call. For more
    substantial applications, the ability to retry and continue on may be needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which system functions are used to convert error codes into text descriptions?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use `FormatMessage()` on Windows and `strerror()` on other platforms
    to obtain error messages.
  prefs: []
  type: TYPE_NORMAL
- en: '**How long does it take for a call to `connect()` to complete on a TCP socket?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A call to `connect()` typically blocks for at least one network time round trip while
    the TCP three-way handshake is being completed.
  prefs: []
  type: TYPE_NORMAL
- en: '**What happens if you call `send()` on a disconnected TCP socket?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Unix-based systems, your program can receive a `SIGPIPE` signal. It is important
    to plan for that. Otherwise, `send()` returns `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you ensure that the next call to `send()` won''t block?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either use `select()` to make sure the socket is ready for more data or use
    non-blocking sockets.
  prefs: []
  type: TYPE_NORMAL
- en: '**What happens if both peers to a TCP connection try to send a large amount
    of data simultaneously?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If both sides to a TCP connection are calling `send()`, but not `recv()`, then
    they can be trapped in a deadlocked state. It is important to intersperse calls
    to `send()` with calls to `recv()`. The use of `select()` can help inform your
    program about what to do next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you improve application performance by disabling the Nagle algorithm?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It depends on what your application is doing. For real-time applications using
    TCP, disabling the Nagle algorithm is often a good trade-off for decreasing latency
    at the expense of bandwidth efficiency. For other applications, disabling it can
    decrease throughput, increase network congestion, and even increase latency.
  prefs: []
  type: TYPE_NORMAL
- en: '**How many connections can `select()` handle?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It depends on your platform. It is defined in the `FD_SETSIZE` macro, which
    is easily increased on Windows but not on other platforms. Typically, the upper
    limit is around 1,024 sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14, Web Programming for the Internet of Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What are the drawbacks to using Wi-Fi connectivity?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wi-Fi can be difficult for end user setup. It's also not available everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the drawbacks to using Ethernet connectivity?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Many devices aren't used in areas where wiring has been run.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the drawbacks to using cellular connectivity?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cellular connectivity is expensive. It can also have increased latency and larger
    power requirements when compared to other methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are some advantages to using a single-board computer with embedded Linux?
    What are the drawbacks?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having access to a full operating system, such as Linux, can simplify software
    development. However, **Single-Board Computers** (**SBCs**) are relatively expensive
    and offer few board-level connectivity options and peripherals when compared to
    microcontrollers. They also require lots of power, relatively speaking.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are some advantages to using a microcontroller in your IoT device?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Many IoT devices will need to use a microcontroller to provide their basic functionality
    anyway. Microcontrollers are cheap, offer a wide range of peripherals, are able
    to meet real-time performance constraints, and can run on very little power.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is the use of HTTPS always appropriate in IoT device communication?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTPS is a decent way to secure IoT communication for most applications; however,
    it has a lot of processing and bandwidth overhead. Each application is unique,
    and the security scheme used should be chosen based on your exact needs.
  prefs: []
  type: TYPE_NORMAL
