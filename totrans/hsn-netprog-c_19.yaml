- en: Answers to Questions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Chapter 1, Introducing Networks and Protocols
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章，介绍网络和协议
- en: '**What are the key differences between IPv4 and IPv6?**'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**IPv4和IPv6之间有哪些关键区别？**'
- en: IPv4 only supports 4 billion unique addresses, and because they were allocated
    inefficiently, we are now running out. IPv6 supports 3.4 x 10^(38) possible addresses.
    IPv6 provides many other improvements, but this is the one that affects our network
    programming directly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4仅支持40亿个唯一的地址，并且由于它们分配得不够高效，我们现在正在耗尽。IPv6支持3.4 x 10^(38)个可能的地址。IPv6提供了许多其他改进，但这是直接影响我们网络编程的一个。
- en: '**Are the IP addresses given by the `ipconfig` and `ifconfig` commands the
    same IP addresses that a remote web server sees if you connect to it?**'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`ipconfig`和`ifconfig`命令给出的IP地址与远程Web服务器看到的IP地址相同吗？**'
- en: Sometimes, these addresses will match, but not always. If you're on a private
    IPv4 network, then your router likely performs network address translation. The
    remote web server then sees the translated address.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这些地址会匹配，但并不总是如此。如果你在一个私有IPv4网络上，那么你的路由器很可能会执行网络地址转换。远程Web服务器然后看到转换后的地址。
- en: If you have a publicly routable IPv4 or IPv6 address, then the address seen
    by the remote web server will match those reported by `ipconfig` and `ifconfig`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个公开路由的IPv4或IPv6地址，那么远程Web服务器看到的地址将与`ipconfig`和`ifconfig`报告的地址相匹配。
- en: '**What is the IPv4 loopback address?**'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**IPv4回环地址是什么？**'
- en: The IPv4 loopback address is `127.0.0.1`, and it allows networked programs to
    communicate with each other while executing on the same machine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4回环地址是`127.0.0.1`，它允许网络程序在相同机器上执行时相互通信。
- en: '**What is the IPv6 loopback address?**'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**IPv6回环地址是什么？**'
- en: The IPv6 loopback address is `::1`. It works in the same way as the IPv4 loopback
    address.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6回环地址是`::1`。它的工作方式与IPv4回环地址相同。
- en: '**How are domain names (for example, `example.com`) resolved into IP addresses?**'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**域名（例如，`example.com`）是如何解析成IP地址的？**'
- en: DNS is used to resolve domain names into IP addresses. This protocol is covered
    in detail in [Chapter 5](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml), *Hostname
    Resolution and DNS*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DNS用于将域名解析为IP地址。该协议在第五章中详细说明，*主机名解析和DNS*。
- en: '**How can you find your public IP address?**'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何找到你的公网IP地址？**'
- en: The easiest way is to visit a website that reports it for you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是访问一个为你报告这个信息的网站。
- en: '**How does an operating system know which application is responsible for an
    incoming packet?**'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**操作系统如何知道哪个应用程序负责处理传入的数据包？**'
- en: Each IP packet has a local address, remote address, local port number, remote
    port number, and protocol type. These five attributes are memorized by the operating
    system to determine which application should handle any given incoming packet.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个IP数据包都有一个本地地址、远程地址、本地端口号、远程端口号和协议类型。这五个属性被操作系统记住，以确定哪个应用程序应该处理任何给定的传入数据包。
- en: Chapter 2, Getting to Grips with Socket APIs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章，掌握套接字API
- en: '**What is a socket?**'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是套接字？**'
- en: A socket is an abstraction that represents one endpoint of a communication link
    between systems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是一个抽象，表示系统间通信链路的一个端点。
- en: '**What is a connectionless protocol? What is a connection-oriented protocol?**'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是无连接协议？什么是面向连接的协议？**'
- en: A connection-oriented protocol sends data packets in the context of a larger
    stream of data. A connectionless protocol sends each packet of data independently
    of any before or after it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 面向连接的协议在更大的数据流上下文中发送数据包。无连接协议独立于之前或之后的数据发送每个数据包。
- en: '**Is UDP a connectionless or connection-oriented protocol?**'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**UDP是无连接的还是面向连接的协议？**'
- en: UDP is considered a connectionless protocol. Each message is sent independently
    of any before or after it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: UDP被认为是一个无连接协议。每个消息都是独立于之前或之后发送的。
- en: '**Is TCP a connectionless or connection-oriented protocol?**'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TCP是无连接的还是面向连接的协议？**'
- en: TCP is considered a connection-oriented protocol. Data is sent and received
    in order as a stream.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TCP被认为是一个面向连接的协议。数据以流的形式按顺序发送和接收。
- en: '**What types of applications generally benefit from using the UDP protocol?**'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪些类型的应用程序通常从使用UDP协议中受益？**'
- en: UDP applications benefit from better real-time performance while sacrificing
    reliability. They are also able to take advantage of IP multicasting.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: UDP应用程序在牺牲可靠性的同时，从更好的实时性能中受益。它们还能够利用IP多播。
- en: '**What types of applications generally benefit from using the TCP protocol?**'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪些类型的应用程序通常从使用TCP协议中受益？**'
- en: Applications that need a reliable stream of data transfer benefit from the TCP
    protocol.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 需要可靠数据流传输的应用程序可以从TCP协议中受益。
- en: '**Does TCP guarantee that data will be transmitted successfully?**'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TCP是否保证数据能够成功传输？**'
- en: TCP makes some guarantees about reliability, but nothing can truly guarantee
    that data is transmitted successfully. For example, if someone unplugs your modem,
    no protocol can overcome that.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TCP对可靠性做出了一些保证，但没有任何东西可以真正保证数据能够成功传输。例如，如果有人拔掉了你的调制解调器，没有任何协议可以克服这一点。
- en: '**What are some of the main differences between Berkeley sockets and Winsock
    sockets?**'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**伯克利套接字和Winsock套接字之间有哪些主要区别？**'
- en: The header files are different. Sockets themselves are represented as signed
    versus unsigned `ints`. When `socket()` or `accept()` calls fail, the return values
    are different. Berkeley sockets are also standard file descriptions. This isn't
    always true with Winsock. Error codes are different and retrieved in a different
    way. There are additional differences, but these are the main ones that affect
    our programs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件是不同的。套接字本身表示为有符号和无符号`int`。当`socket()`或`accept()`调用失败时，返回值是不同的。伯克利套接字也是标准文件描述。Winsock并不总是这样。错误代码不同，并且以不同的方式检索。还有其他差异，但这些是我们程序受影响的主要差异。
- en: '**What does the `bind()` function do? **'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`bind()`函数的作用是什么？**'
- en: The `bind()` function associates a socket with a particular local network address
    and port number. Its usage is almost always required for the server, and it's
    usually not required for the client.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()`函数将套接字与特定的本地网络地址和端口号关联。它的使用几乎总是必需的，对于服务器而言，而对于客户端通常不是必需的。'
- en: '**What does the `accept()` function do?**'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`accept()`函数的作用是什么？**'
- en: The `accept()` function will block until a new TCP client has connected. It
    then returns the socket for this new connection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept()`函数将阻塞，直到新的TCP客户端连接。然后它返回这个新连接的套接字。'
- en: '**In a TCP connection, does the client or the server send application data
    first?**'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在TCP连接中，是客户端还是服务器先发送应用程序数据？**'
- en: Either the client or the server can send data first. They can even send data
    simultaneously. In practice, many client-server protocols (such as HTTP) work
    by having the client send a request first and then having the server send a response.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端或服务器都可以先发送数据。它们甚至可以同时发送数据。在实践中，许多客户端-服务器协议（如HTTP）是通过客户端首先发送请求，然后服务器发送响应来工作的。
- en: Chapter 3, An In-Depth Overview of TCP Connections
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章，TCP连接的深入概述
- en: '**How can we tell if the next call to `recv()` will block?**'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何判断下一次调用`recv()`是否会阻塞？**'
- en: We use the `select()` function to indicate which sockets are ready to be read
    from without blocking.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`select()`函数来指示哪些套接字可以无阻塞地读取。
- en: '**How can you ensure that `select()` doesn''t block for longer than a specified
    tim**e?'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何确保`select()`不会阻塞超过指定的时间？**'
- en: You can pass `select()` a timeout parameter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向`select()`传递一个超时参数。
- en: '**When we used our `tcp_client` program to connect to a web server, why did
    we need to send a blank line before the web server responded?**'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当我们使用我们的`tcp_client`程序连接到Web服务器时，为什么需要在Web服务器响应之前发送一个空白行？**'
- en: HTTP, the web server's protocol, expects a blank line to indicate the end of
    the request. Without this blank line, it wouldn't know if the client was going
    to keep sending additional request headers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP，Web服务器的协议，期望一个空白行来表示请求的结束。没有这个空白行，它就不知道客户端是否会继续发送额外的请求头。
- en: '**Does `send()` ever block?**'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`send()`函数是否会阻塞？**'
- en: Yes. You can use `select()` to determine when a socket is ready to be written
    to without blocking. Alternatively, sockets can be put into non-blocking mode.
    See [Chapter 13](11c5bb82-e55f-4977-bf7f-5dbe791fde92.xhtml), *Socket Programming
    Tips **and Pitfalls*, for more information.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。你可以使用`select()`来确定套接字何时准备好写入而不阻塞。或者，可以将套接字置于非阻塞模式。有关更多信息，请参阅第13章，*套接字编程技巧和陷阱*。
- en: '**How can we tell if a socket has been disconnected by our peer?**'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们如何判断套接字是否被我们的对等方断开连接？**'
- en: The return value of `recv()` can indicate if a socket has been disconnected.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`recv()`的返回值可以指示套接字是否已断开连接。'
- en: '**Is data received by `recv()` always the same size as data sent with `send()`?**'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过`recv()`接收到的数据是否总是与通过`send()`发送的数据大小相同？**'
- en: No. TCP is a stream protocol. There is no way to tell if the data returned from
    one `recv()` call was sent with one or many calls to `send()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不。TCP是一种流协议。没有办法判断从一次`recv()`调用返回的数据是使用一次还是多次`send()`调用发送的。
- en: 'Consider this code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is wrong with it?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它有什么问题？
- en: 'Also see what is wrong with this code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 也看看这段代码有什么问题：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The data returned by `recv()` is not null terminated! Both of the preceding
    code excerpts will likely cause `printf()` to read past the end of the data returned
    by `recv()`. Additionally, in the first code example the data received could contain
    format specifiers (for example `%d`), which would cause additional memory access
    violations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`recv()` 返回的数据不是以空字符终止的！前述代码片段中的任何一个都可能导致 `printf()` 读取 `recv()` 返回的数据的末尾。此外，在第一个代码示例中，接收到的数据可能包含格式说明符（例如
    `%d`），这会导致额外的内存访问违规。'
- en: Chapter 4, Establishing UDP Connections
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章，建立 UDP 连接
- en: '**How do `sendto()` and `recvfrom()` differ from `send()` and `recv()`?**'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`sendto()` 和 `recvfrom()` 与 `send()` 和 `recv()` 有什么区别？**'
- en: The `send()` and `recv()` functions are useful after calling `connect()`. They
    only work with the one remote address that was passed to `connect()`. The `sendto()`
    and `recvfrom()` functions can be used with multiple remote addresses.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `connect()` 之后，`send()` 和 `recv()` 函数是有用的。它们只与传递给 `connect()` 的一个远程地址一起工作。`sendto()`
    和 `recvfrom()` 函数可以与多个远程地址一起使用。
- en: '**Can `send()` and `recv()` be used on UDP sockets?**'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`send()` 和 `recv()` 可以在 UDP 套接字上使用吗？**'
- en: Yes. The `connect()` function should be called first in that case. However,
    the `sendto()` and `recvfrom()` functions are often more useful for UDP sockets.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。在这种情况下，应该首先调用 `connect()` 函数。然而，`sendto()` 和 `recvfrom()` 函数对于 UDP 套接字通常更有用。
- en: '**What does `connect()` do in the case of a UDP socket?**'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 UDP 套接字的情况下，`connect()` 会做什么？**'
- en: The `connect()` function associates the socket with a remote address.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect()` 函数将套接字与远程地址关联。'
- en: '**What makes multiplexing with UDP easier than with TCP?**'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**与 TCP 相比，什么使得使用 UDP 的多路复用更容易？**'
- en: One UDP socket can talk to multiple remote peers. For TCP, one socket is needed
    for each peer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 UDP 套接字可以与多个远程对等方通信。对于 TCP，每个对等方需要一个套接字。
- en: '**What are the downsides to UDP when compared to TCP?**'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**与 TCP 相比，UDP 的缺点是什么？**'
- en: UDP does not attempt to fix many of the errors that TCP does. For example, TCP
    ensures that data arrives in the same order it was sent, TCP tries to avoid causing
    network congestion, and TCP attempts to resend lost packets. UDP does none of
    this.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 不尝试修复 TCP 所做的许多错误。例如，TCP 确保数据按发送的顺序到达，TCP 尝试避免造成网络拥塞，并且 TCP 尝试重新发送丢失的数据包。UDP
    什么都不做。
- en: '**Can the same program use UDP and TCP?**'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**同一个程序可以使用 UDP 和 TCP 吗？**'
- en: Yes. It just needs to create sockets for both.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。它只需要为两者创建套接字。
- en: Chapter 5, Hostname Resolution and DNS
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章，主机名解析和 DNS
- en: '**Which function fills in an address needed for socket programming in a portable
    and protocol-independent way?**'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪个函数以可移植和协议无关的方式填充套接字编程所需的地址？**'
- en: '`getaddrinfo()` is the function to use for this.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`getaddrinfo()` 是用于此目的的函数。'
- en: '**Which socket programming function can be used to convert an IP address back
    into a name?**'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪个套接字编程函数可以将 IP 地址转换回名称？**'
- en: '`getnameinfo()` can be used to convert addresses back to names.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`getnameinfo()` 可以用于将地址转换回名称。'
- en: '**A DNS query converts a name to an address, and a reverse DNS query converts
    an address back into a name. If you run a DNS query on a name, and then a reverse
    DNS query on the resulting address, do you always get back the name you started
    with?**'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DNS 查询将名称转换为地址，反向 DNS 查询将地址转换回名称。如果你对一个名称运行 DNS 查询，然后对结果地址运行反向 DNS 查询，你是否总是得到你开始的名称？**'
- en: Sometimes, you will get the same name back but not always. This is because the
    forward and reverse lookups use independent records. It's also possible to have
    many names point to one address, but that one address can only have one record
    that points back to a single name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会得到相同的名称，但并不总是这样。这是因为正向和反向查找使用独立的记录。也可能有多个名称指向一个地址，但那个地址只能有一个指向单个名称的记录。
- en: '**What are the DNS record types used to return IPv4 and IPv6 addresses for
    a name?**'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用于返回名称的 IPv4 和 IPv6 地址的 DNS 记录类型是什么？**'
- en: The `A` record type returns an IPv4 address, and the `AAAA` record type returns
    an IPv6 address.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`A` 记录类型返回一个 IPv4 地址，而 `AAAA` 记录类型返回一个 IPv6 地址。'
- en: '**Which DNS record type stores special information about email servers?**'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪种 DNS 记录类型存储有关电子邮件服务器的特殊信息？**'
- en: The `MX` record type is used to return email server information.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`MX` 记录类型用于返回电子邮件服务器信息。'
- en: '**Does `getaddrinfo()` always return immediately? Or can it block?**'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`getaddrinfo()` 是否总是立即返回？或者它可以阻塞？**'
- en: If `getaddrinfo()` is doing name lookups, it will often block. In the worst-case
    scenario, many UDP messages would need to be sent to various DNS servers, so this
    can be a noticeable delay. This is one reason why DNS caching is important.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `getaddrinfo()` 正在进行名称查找，它通常会阻塞。在最坏的情况下，需要向多个 DNS 服务器发送许多 UDP 消息，因此这可能会导致明显的延迟。这也是
    DNS 缓存重要的原因之一。
- en: If you are simply using `getaddrinfo()` to convert from a text IP address, then
    it shouldn't block.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是使用 `getaddrinfo()` 将文本 IP 地址转换为地址，那么它不应该阻塞。
- en: '**What happens when a DNS response is too large to fit into a single UDP packet?**'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当 DNS 响应太大而无法放入单个 UDP 数据包时会发生什么？**'
- en: The DNS response will have the `TC` bit set in its header. This indicates that
    the message was truncated. The query should be resent using TCP.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 响应的头部将设置 `TC` 位。这表示消息已被截断。应使用 TCP 重新发送查询。
- en: Chapter 6, Building a Simple Web Client
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章，构建简单的 Web 客户端
- en: '**Does HTTP use TCP or UDP?**'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTTP 使用 TCP 还是 UDP？**'
- en: HTTP runs over TCP port `80`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 在 TCP 端口 `80` 上运行。
- en: '**What types of resources can be sent over HTTP?**'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可以通过 HTTP 发送哪些类型的资源？**'
- en: HTTP can be used to transfer essentially any computer file. It's commonly used
    for web pages (HTML) and the associated files (such as styles, scripts, fonts,
    and images).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 可以用来传输几乎任何计算机文件。它通常用于网页（HTML）及其相关文件（例如样式、脚本、字体和图像）。
- en: '**What are the common HTTP request types?**'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**常见的 HTTP 请求类型有哪些？**'
- en: '`GET`, `POST`, and `HEAD` are the most common HTTP request types.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`、`POST` 和 `HEAD` 是最常见的 HTTP 请求类型。'
- en: '**What HTTP request type is typically used to send data from the server to
    the client?**'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通常用于从服务器向客户端发送数据的 HTTP 请求类型是什么？**'
- en: '`GET` is the usual request type for a client to request a resource from the
    server.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` 是客户端请求从服务器获取资源的常用请求类型。'
- en: '**What HTTP request type is typically used to send data from the client to
    the server?**'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通常用于从客户端向服务器发送数据的 HTTP 请求类型是什么？**'
- en: '`POST` is used when the client needs to send data to the server.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端需要向服务器发送数据时，使用 `POST`。
- en: What are the two common methods used to determine an HTTP response body length?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定 HTTP 响应体长度的两种常用方法是什么？
- en: 'The HTTP body length is commonly determined by the `Content-Length` header
    or by using `Transfer-Encoding: chunked`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP 主体长度通常由 `Content-Length` 标头或使用 `Transfer-Encoding: chunked` 确定。'
- en: '**How is the HTTP request body formatted for a `POST`-type HTTP request?**'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`POST` 类型的 HTTP 请求体是如何格式化的？**'
- en: This is determined by the application. The client should set the `Content-Type`
    header to specify which format it is using. `application/x-www-form-urlencoded`
    and `application/json` are common values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这由应用程序决定。客户端应设置 `Content-Type` 标头以指定它使用的格式。"application/x-www-form-urlencoded"
    和 "application/json" 是常见的值。
- en: Chapter 7, Building a Simple Web Server
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章，构建简单的 Web 服务器
- en: '**How does an HTTP client indicate that it has finished sending the HTTP request?**'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTTP 客户端如何指示它已发送完 HTTP 请求？**'
- en: The HTTP request should end with a blank line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求应以一个空行结束。
- en: '**How does an HTTP client know what type of content the HTTP server is sending?**'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTTP 客户端如何知道 HTTP 服务器发送的内容类型？**'
- en: The HTTP server should identify the content with a `Content-Type` header.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 服务器应使用 `Content-Type` 标头识别内容。
- en: '**How can an HTTP server identify a file''s media type?**'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTTP 服务器如何识别文件的媒体类型？**'
- en: A common method of identifying a file's media type is just to look at the file
    extension. The server is free to use other methods though. When sending dynamic
    pages or data from a database, there will be no file and therefore no file extension.
    In this case, the server must know the media type from its context.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 识别文件媒体类型的一种常见方法就是查看文件扩展名。尽管如此，服务器也可以使用其他方法。当发送动态页面或数据库中的数据时，将没有文件和文件扩展名。在这种情况下，服务器必须从其上下文中知道媒体类型。
- en: '**How can you tell whether a file exists on the filesystem and is readable
    by your program? Is `fopen(filename, "r") != 0` a good test?**'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何判断文件是否存在于文件系统中并且可以被你的程序读取？`fopen(filename, "r") != 0` 是一个好的测试吗？**'
- en: This is not a trivial problem. A robust program will need to consider system
    specific APIs carefully. Windows uses special filenames that will trip up a program
    that relies only on `fopen()` to check for a file's existence.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个简单的问题。一个健壮的程序需要仔细考虑系统特定的 API。Windows 使用特殊的文件名，这可能会使仅依赖于 `fopen()` 检查文件存在性的程序出错。
- en: Chapter 8, Making Your Program Send Email
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章，让你的程序发送电子邮件
- en: '**What port does SMTP operate on?**'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SMTP 运行在哪个端口上？**'
- en: SMTP does mail transmission over TCP port `25`. Many providers use alternative
    ports for mail submission.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP通过TCP端口`25`进行邮件传输。许多提供商使用替代端口进行邮件提交。
- en: '**How do you determine which SMTP server receives mail for a given domain?**'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何确定哪个SMTP服务器接收特定域的邮件？**'
- en: The mail servers responsible for receiving mail for a given domain are given
    by MX-type DNS records.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 负责接收特定域邮件的邮件服务器由MX类型的DNS记录给出。
- en: '**How do you determine which SMTP server sends mail for a given provider?**'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何确定哪个SMTP服务器为特定提供商发送邮件？**'
- en: It's not possible to determine that in the general case. In any case, several
    servers could be responsible. Sometimes these servers will be listed under a TXT-type
    DNS record using SPF, but that is certainly not universal.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，这是不可能确定的。在任何情况下，可能有几个服务器负责。有时这些服务器将列在TXT类型的DNS记录下使用SPF，但这绝对不是普遍的。
- en: '**Why won''t an SMTP server relay mail without authentication?**'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么SMTP服务器在没有认证的情况下不会中继邮件？**'
- en: Open relay SMTP servers are targeted by spammers. SMTP servers require authentication
    to prevent abuse.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 开放中继SMTP服务器是垃圾邮件发送者的目标。SMTP服务器需要认证以防止滥用。
- en: '**How are binary files sent as email attachments when SMTP is a text-based
    protocol?**'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当SMTP是一个基于文本的协议时，如何将二进制文件作为电子邮件附件发送？**'
- en: 'Binary files must be re-encoded as plain text. The most common method is with `Content-Transfer-Encoding:
    base64`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '二进制文件必须重新编码为纯文本。最常见的方法是使用`Content-Transfer-Encoding: base64`。'
- en: Chapter 9, Loading Secure Web Pages with HTTPS and OpenSSL
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章，使用HTTPS和OpenSSL加载安全网页
- en: '**What port does HTTPS typically operate on?**'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTTPS通常在哪个端口上运行？**'
- en: HTTPS connects over TCP port `443`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS通过TCP端口`443`连接。
- en: '**How many keys does symmetric encryption use?**'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对称加密使用多少个密钥？**'
- en: Symmetric encryption uses one key. Data is encrypted and decrypted with the
    same key.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密使用一个密钥。数据使用相同的密钥进行加密和解密。
- en: '**How many keys does asymmetric encryption use?**'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非对称加密使用多少个密钥？**'
- en: Asymmetric encryption use two different, but mathematically related, keys. Data
    is encrypted with one and decrypted with the other.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密使用两个不同但数学上相关的密钥。数据使用一个密钥加密，使用另一个密钥解密。
- en: '**Does TLS use symmetric or asymmetric encryption?**'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TLS使用对称加密还是非对称加密？**'
- en: TLS use both symmetric and asymmetric encryption algorithms to function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: TLS使用对称和非对称加密算法来工作。
- en: '**What is the difference between SSL and TLS?**'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SSL和TLS之间的区别是什么？**'
- en: TLS is the successor to SSL. SSL is now deprecated.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: TLS是SSL的后继者。SSL现在已弃用。
- en: '**What purpose do certificates fulfill?**'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**证书有什么用途？**'
- en: Certificates allow a server or client to verify their identity.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 证书允许服务器或客户端验证其身份。
- en: Chapter 10, Implementing a Secure Web Server
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章，实现安全Web服务器
- en: '**How does a client decide whether it should trust a server''s certificate?**'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端如何决定是否应该信任服务器的证书？**'
- en: There are various ways a client can trust a server's certificate. The chain-of-trust
    model is the most common. In this model, the client explicitly trusts an authority.
    The client then implicitly trusts any certificates it encounters that are signed
    by this trusted authority.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以信任服务器证书的方式有很多。信任链模型是最常见的。在这个模型中，客户端明确信任一个权威机构。然后，客户端隐式信任任何由这个受信任的权威机构签名的证书。
- en: '**What is the main issue with self-signed certificates?**'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自签名证书的主要问题是什么？**'
- en: Self-signed certificates aren't signed by a trusted certificate authority. Web
    browsers won't know to trust self-signed certificates unless the user adds a special
    exception.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名证书未由受信任的证书颁发机构签名。除非用户添加特殊例外，否则网络浏览器不会知道信任自签名证书。
- en: '**What can cause `SSL_accept()` to fail?**'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么可以导致`SSL_accept()`失败？**'
- en: '`SSL_accept()` fails if the client doesn''t trust the server''s certificate
    or if the client and server can''t agree on a mutually supported protocol version
    and cipher suite.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端不信任服务器的证书，或者客户端和服务器无法就相互支持的协议版本和加密套件达成一致，则`SSL_accept()`会失败。
- en: '**Can `select()` be used to multiplex connections for HTTPS servers?**'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`select()`能否用于HTTPS服务器的连接多路复用？**'
- en: Yes, but be aware that `select()` works on the underlying TCP connection layer,
    not on the TLS layer. Therefore, when `select()` indicates that a socket has data
    waiting, it does not necessarily mean that there is new TLS data ready.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，但请注意，`select()`在底层的TCP连接层上工作，而不是在TLS层上。因此，当`select()`指示套接字有等待的数据时，这并不一定意味着有新的TLS数据准备好。
- en: Chapter 11, Establishing SSH Connections with libssh
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章，使用libssh建立SSH连接
- en: '**What is a significant downside of using Telnet?**'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用Telnet的显著缺点是什么？**'
- en: Essentially, Telnet provides no security features. Passwords are sent as plaintext.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Telnet不提供任何安全功能。密码以明文形式发送。
- en: '**Which port does SSH typically run on?**'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SSH通常运行在哪个端口上？**'
- en: SSH's official port is TCP port `22`. In practice, it is common to run SSH on
    arbitrary ports in an attempt to hide from attackers. With a properly secured
    server, these attackers are a nuisance rather than a legitimate threat.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SSH的官方端口是TCP端口`22`。在实践中，通常会在任意端口上运行SSH以试图隐藏自己，从攻击者的角度来看，这些攻击者只是麻烦而不是真正的威胁。
- en: '**Why is it essential that the client authenticates the SSH server?**'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么客户端验证SSH服务器是至关重要的？**'
- en: If the client doesn't verify the SSH server's identity, then it could be tricked
    into sending credentials to an impostor.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端没有验证SSH服务器的身份，那么它可能会被欺骗向冒充者发送凭证。
- en: '**How is the server typically authenticated?**'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器通常是如何进行身份验证的？**'
- en: SSH servers typically use certificates to identity themselves. This is similar
    to how servers are authenticated when using HTTPS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SSH服务器通常使用证书来标识自己。这与使用HTTPS时服务器进行身份验证的方式类似。
- en: '**How is the SSH client typically authenticated?**'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SSH客户端通常是如何进行身份验证的？**'
- en: It is still common for clients to authenticate with a password. The downside
    to this method is that if a client is somehow tricked into connecting to an impostor
    server, then their password will be compromised. SSH provides alternate methods,
    including authenticating clients using certificates, that aren't susceptible to
    replay attacks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用密码进行身份验证仍然很常见。这种方法的不利之处在于，如果客户端被欺骗连接到冒充的服务器，那么他们的密码就会被泄露。SSH提供了替代方法，包括使用证书来验证客户端，这些方法不易受到重放攻击。
- en: Chapter 12, Network Monitoring and Security
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章，网络监控和安全
- en: '**Which tool would you use to test the reachability of a target system?**'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您会使用哪个工具来测试目标系统的可达性？**'
- en: The `ping` tool is useful to test reachability.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping`工具用于测试可达性。'
- en: '**Which tool lists the routers to a destination system?**'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪个工具可以列出到达目标系统的路由器？**'
- en: The `traceroute` (`tracert` on Windows) tool will show the network path to a
    target system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceroute`（在Windows上为`tracert`）工具将显示到目标系统的网络路径。'
- en: '**What are raw sockets used for?**'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**原始套接字用于什么？**'
- en: Raw sockets allow the programmer to specify directly what goes into a network
    packet. They provide lower-level access than TCP and UDP sockets, and can be used
    to implement additional protocols, such as ICMP.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 原始套接字允许程序员直接指定进入网络数据包的内容。它们比TCP和UDP套接字提供更底层的访问，可以用来实现额外的协议，如ICMP。
- en: '**Which tools list the open TCP sockets on your system?**'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪些工具可以列出您系统上的开放TCP套接字？**'
- en: The netstat tool can be used to show open connections on your local system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: netstat工具可以用来显示您本地系统上的开放连接。
- en: '**What is one of the biggest concerns with security for networked C programs?**'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**网络C程序的安全方面最大的担忧是什么？**'
- en: When programming networked applications in C, special care must be given to
    memory safety. Even a small mistake could allow an attacker to compromise your
    program.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当用C语言编写网络应用程序时，必须特别注意内存安全。即使是小小的错误也可能让攻击者破坏您的程序。
- en: Chapter 13, Socket Programming Tips and Pitfalls
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章，套接字编程技巧和陷阱
- en: '**Is it ever acceptable just to terminate a program if a network error is detected?**'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检测到网络错误时，终止程序是否总是可以接受的？**'
- en: Yes. For some applications terminating on error is the right call. For more
    substantial applications, the ability to retry and continue on may be needed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。对于一些在错误情况下终止的应用程序来说，这是正确的做法。对于更复杂的应用程序，可能需要重试并继续的能力。
- en: '**Which system functions are used to convert error codes into text descriptions?**'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用于将错误代码转换为文本描述的系统函数有哪些？**'
- en: You can use `FormatMessage()` on Windows and `strerror()` on other platforms
    to obtain error messages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Windows上使用`FormatMessage()`，在其他平台上使用`strerror()`来获取错误消息。
- en: '**How long does it take for a call to `connect()` to complete on a TCP socket?**'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在TCP套接字上调用`connect()`完成需要多长时间？**'
- en: A call to `connect()` typically blocks for at least one network time round trip while
    the TCP three-way handshake is being completed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP三次握手完成期间，对`connect()`的调用通常会阻塞至少一个网络往返时间。
- en: '**What happens if you call `send()` on a disconnected TCP socket?**'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果您在断开的TCP套接字上调用`send()`会发生什么？**'
- en: On Unix-based systems, your program can receive a `SIGPIPE` signal. It is important
    to plan for that. Otherwise, `send()` returns `-1`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Unix的系统上，您的程序可以接收一个`SIGPIPE`信号。计划这一点很重要。否则，`send()`返回`-1`。
- en: '**How can you ensure that the next call to `send()` won''t block?**'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何确保下一次调用`send()`不会阻塞？**'
- en: Either use `select()` to make sure the socket is ready for more data or use
    non-blocking sockets.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要么使用`select()`确保套接字准备好接收更多数据，要么使用非阻塞套接字。
- en: '**What happens if both peers to a TCP connection try to send a large amount
    of data simultaneously?**'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果TCP连接的两端都试图同时发送大量数据会发生什么？**'
- en: If both sides to a TCP connection are calling `send()`, but not `recv()`, then
    they can be trapped in a deadlocked state. It is important to intersperse calls
    to `send()` with calls to `recv()`. The use of `select()` can help inform your
    program about what to do next.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果TCP连接的两端都在调用`send()`，但没有调用`recv()`，那么它们可能会陷入死锁状态。在调用`send()`之间穿插调用`recv()`是很重要的。使用`select()`可以帮助你的程序了解下一步该做什么。
- en: '**Can you improve application performance by disabling the Nagle algorithm?**'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过禁用Nagle算法能否提高应用程序的性能？**'
- en: It depends on what your application is doing. For real-time applications using
    TCP, disabling the Nagle algorithm is often a good trade-off for decreasing latency
    at the expense of bandwidth efficiency. For other applications, disabling it can
    decrease throughput, increase network congestion, and even increase latency.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你的应用程序正在做什么。对于使用TCP的实时应用程序，禁用Nagle算法通常是在降低延迟的同时牺牲带宽效率的良好权衡。对于其他应用程序，禁用它可能会降低吞吐量，增加网络拥塞，甚至增加延迟。
- en: '**How many connections can `select()` handle?**'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`select()`可以处理多少个连接？**'
- en: It depends on your platform. It is defined in the `FD_SETSIZE` macro, which
    is easily increased on Windows but not on other platforms. Typically, the upper
    limit is around 1,024 sockets.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你的平台。它由`FD_SETSIZE`宏定义，在Windows上可以轻松增加，但在其他平台上则不行。通常，上限大约是1,024个套接字。
- en: Chapter 14, Web Programming for the Internet of Things
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章，物联网的Web编程
- en: '**What are the drawbacks to using Wi-Fi connectivity?**'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用Wi-Fi连接有哪些缺点？**'
- en: Wi-Fi can be difficult for end user setup. It's also not available everywhere.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Wi-Fi对于最终用户设置来说可能很困难。它也不在所有地方都可用。
- en: '**What are the drawbacks to using Ethernet connectivity?**'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用以太网连接有哪些缺点？**'
- en: Many devices aren't used in areas where wiring has been run.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 许多设备没有被用于已经布线的区域。
- en: '**What are the drawbacks to using cellular connectivity?**'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用蜂窝连接有哪些缺点？**'
- en: Cellular connectivity is expensive. It can also have increased latency and larger
    power requirements when compared to other methods.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 蜂窝连接成本高昂。与其他方法相比，它也可能具有更高的延迟和更大的电力需求。
- en: '**What are some advantages to using a single-board computer with embedded Linux?
    What are the drawbacks?**'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用带嵌入式Linux的单板计算机有哪些优点？有哪些缺点？**'
- en: Having access to a full operating system, such as Linux, can simplify software
    development. However, **Single-Board Computers** (**SBCs**) are relatively expensive
    and offer few board-level connectivity options and peripherals when compared to
    microcontrollers. They also require lots of power, relatively speaking.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 能够访问完整的操作系统，如Linux，可以简化软件开发。然而，**单板计算机**（**SBCs**）相对较贵，与微控制器相比，提供的板级连接选项和外围设备较少。它们还需要相对较多的电力。
- en: '**What are some advantages to using a microcontroller in your IoT device?**'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在物联网设备中使用微控制器有哪些优点？**'
- en: Many IoT devices will need to use a microcontroller to provide their basic functionality
    anyway. Microcontrollers are cheap, offer a wide range of peripherals, are able
    to meet real-time performance constraints, and can run on very little power.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 许多物联网设备无论如何都需要使用微控制器来提供其基本功能。微控制器价格低廉，提供广泛的外围设备，能够满足实时性能约束，并且可以在非常少的电力下运行。
- en: '**Is the use of HTTPS always appropriate in IoT device communication?**'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在物联网设备通信中，使用HTTPS是否总是合适的？**'
- en: HTTPS is a decent way to secure IoT communication for most applications; however,
    it has a lot of processing and bandwidth overhead. Each application is unique,
    and the security scheme used should be chosen based on your exact needs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS对于大多数应用来说是一种不错的物联网通信安全方式；然而，它有大量的处理和带宽开销。每个应用都是独特的，所使用的安全方案应根据你的具体需求来选择。
