<html><head></head><body>
<div id="_idContainer037">
<h1 class="chapter-number" id="_idParaDest-149"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-150"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.2.1">Arena-Based Memory Management and Other Optimizations</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Our memory-management toolbox is growing with every chapter. </span><span class="koboSpan" id="kobo.3.2">We now know how to overload memory allocation operators (</span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.5.1">) and how to put this skill to work in ways that solve a variety of concrete problems (</span><a href="B21071_08.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.7.1"> and </span><a href="B21071_09.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.9.1"> both give a few illustrative, </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">real-world examples).</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">One important reason why one would want to take control of memory allocation mechanisms is </span><em class="italic"><span class="koboSpan" id="kobo.12.1">performance</span></em><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">Now, it would be presumptuous (and plain wrong!) to state that it’s trivial to beat the implementation of these functions as provided by your library vendor, as these are good, often </span><em class="italic"><span class="koboSpan" id="kobo.14.1">very</span></em><span class="koboSpan" id="kobo.15.1"> good, for the average case. </span><span class="koboSpan" id="kobo.15.2">The key element of the previous phrase, of course, is “for the average case.” </span><span class="koboSpan" id="kobo.15.3">When one’s use case has specificities that are known of beforehand, it is sometimes possible to benefit from that information and carve an implementation that outperforms, maybe by a wide margin, anything that could have been designed for excellent </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.16.1">average</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.17.1"> performance.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">This chapter is about using knowledge of the memory management problem we want to solve and building a solution that excels for us. </span><span class="koboSpan" id="kobo.18.2">This can mean a solution that’s faster on average, that’s fast enough even in the worst case, that shows deterministic execution times, that reduces memory fragmentation, and so on. </span><span class="koboSpan" id="kobo.18.3">There are many different needs and constraints in real-world programs after all, and we often have to </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">make choices.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">Once this chapter is over, our toolbox will be expanded to let us do </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.22.1">Write arena-based allocation strategy algorithms optimized to face a priori </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">known constraints</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Write per-memory block-size </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">allocation strategies</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Understand the benefits as well as the risks associated with </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">such techniques</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.28.1">The techniques covered in this chapter will lead us to explore use cases very close to those for which memory allocation operators are overloaded in some specialized application domains. </span><span class="koboSpan" id="kobo.28.2">Thus, we will initially apply them to a “real life” problem: the fight between Orcs and Elves in a medieval </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">fantasy game.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.30.1">On the (sometimes diminishing) returns of optimization</span></p>
<p class="callout"><span class="koboSpan" id="kobo.31.1">Since we will be discussing optimization techniques (among other things) in this chapter, some words of warning are in order: </span><em class="italic"><span class="koboSpan" id="kobo.32.1">optimization is a tricky thing</span></em><span class="koboSpan" id="kobo.33.1">, a moving target, and what makes code better one day could pessimize it another day. </span><span class="koboSpan" id="kobo.33.2">Similarly, what can seem like a good idea in theory can lead to slowdowns in practice once implemented and tested, and one can sometimes spend a lot of time optimizing a piece of code that is rarely taken, effectively wasting time </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">and money.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.35.1">Before trying to optimize parts of your program, it’s generally wise to measure, ideally with a profiling tool, and identify the parts that might benefit from your efforts. </span><span class="koboSpan" id="kobo.35.2">Then, keep a simple (but correct) version of your code close by and use it as a baseline. </span><span class="koboSpan" id="kobo.35.3">Whenever you try an optimization, compare the results with the baseline code and run these tests regularly, particularly when changing hardware, library, compiler, or version thereof. </span><span class="koboSpan" id="kobo.35.4">Sometimes, something such as a compiler upgrade might induce a new optimization that “sees through” the simple baseline code and makes it faster than your finely crafted alternative. </span><span class="koboSpan" id="kobo.35.5">Be humble, be reasonable, measure early, and </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">measure often.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.37.1">Technical requirements</span></h1>
<p><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.38.1">You can find the code files for this chapter in the book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">here: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter10"><span class="No-Break"><span class="koboSpan" id="kobo.40.1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter10</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.41.1">.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.42.1">Arena-based memory management</span></h1>
<p><span class="koboSpan" id="kobo.43.1">The idea behind</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.44.1"> arena-based memory management is to allocate a chunk of memory at a known moment in the program and manage it as a “small, personalized heap” based on a strategy that benefits from knowledge of the situation or of the </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">problem domain.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">There are many variants on this general theme, including </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.48.1">In a game, allocate and manage the memory by scene or by level, deallocating it as a single chunk at the end of said scene or level. </span><span class="koboSpan" id="kobo.48.2">This can help reduce memory fragmentation in </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">the program.</span></span></li>
<li><span class="koboSpan" id="kobo.50.1">When the conditions in which allocations and deallocations are known to follow a given pattern or have bounded memory requirements, specialize allocation functions to benefit from </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">this information.</span></span></li>
<li><span class="koboSpan" id="kobo.52.1">Express a form of ownership for a group of similar objects in such as way as to destroy them all at a later point in the program instead of doing so one object at </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">a time.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.54.1">The best way to explain how arena-based allocation works is probably to write an example program that uses it and shows both what it does and what benefits this provides. </span><span class="koboSpan" id="kobo.54.2">We will write code in such a way as to use the same test code with either the standard library-provided</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.55.1"> allocation functions or our own specialized implementation, depending on the presence of a macro, and, of course, we will measure the allocation and deallocation code to see whether there is a benefit to </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">our efforts.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.57.1">Specific example – size-based implementation</span></h2>
<p><span class="koboSpan" id="kobo.58.1">Suppose we are</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.59.1"> working on a video game where the action converges toward a stupendous finale where Orcs and Elves meet in a grandiose battle. </span><span class="koboSpan" id="kobo.59.2">No one really remembers why these two groups hate each other, but there is a suspicion that one day, one of the Elves said to one of the Orcs “You know, you don’t smell all that bad today!” </span><span class="koboSpan" id="kobo.59.3">and this Orc was so insulted that it started a feud that still goes on today. </span><span class="koboSpan" id="kobo.59.4">It’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">rumor, anyway.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">It so happens that, in this game, some things are known about the behavior of Orc-using code, specifically, </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.63.1">There will never be more than a certain number of dynamically allocated </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">Orc</span></strong><span class="koboSpan" id="kobo.65.1"> objects overall, so we have an upper bound to the space required to store </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">these beasties.</span></span></li>
<li><span class="koboSpan" id="kobo.67.1">The Orcs that die will not come back to life in that game, as there are no shamans to resurrect them. </span><span class="koboSpan" id="kobo.67.2">Expressed otherwise, there is no need to implement a strategy that reuses the storage of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">Orc</span></strong><span class="koboSpan" id="kobo.69.1"> object once it has </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">been destroyed.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.71.1">These two properties open algorithmic options </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">for us:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.73.1">If we have enough memory available, we could allocate upfront a single memory block large enough to put all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">Orc</span></strong><span class="koboSpan" id="kobo.75.1"> objects in the game as we know what the worst-case </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">scenario is</span></span></li>
<li><span class="koboSpan" id="kobo.77.1">Since we know that we will not need to reuse the memory associated with individual </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">Orc</span></strong><span class="koboSpan" id="kobo.79.1"> objects, we can implement a simple (and very fast) strategy for allocation that does almost no bookkeeping and, as we will see, lets us achieve deterministic, constant-time allocation </span><em class="italic"><span class="koboSpan" id="kobo.80.1">for </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.81.1">this type</span></em></span></li>
</ul>
<p><span class="koboSpan" id="kobo.82.1">For the sake of this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">Orc</span></strong><span class="koboSpan" id="kobo.84.1"> class will be represented by three data members, </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">name</span></strong><span class="koboSpan" id="kobo.86.1"> (a </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">char[4]</span></strong><span class="koboSpan" id="kobo.88.1"> as these beasties have a limited vocabulary), </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">strength</span></strong><span class="koboSpan" id="kobo.90.1"> (of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">int</span></strong><span class="koboSpan" id="kobo.92.1">), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">smell</span></strong><span class="koboSpan" id="kobo.94.1"> (of</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.95.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">double</span></strong><span class="koboSpan" id="kobo.97.1"> type as these things have… a reputation), </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.99.1">
class Orc {
  char name[4]{ 'U', 'R', 'G' };
  int strength = 100;
  double smell = 1000.0;
public:
  static constexpr int NB_MAX = 1'000'000;
  // ...
</span><span class="koboSpan" id="kobo.99.2">};</span></pre> <p><span class="koboSpan" id="kobo.100.1">We will use arbitrary default values for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">Orc</span></strong><span class="koboSpan" id="kobo.102.1"> objects as we are only concerned about allocation and deallocation for this example. </span><span class="koboSpan" id="kobo.102.2">You can write more elaborate test code that uses non-default values if you feel like it, of course, but that would not impact our discussion so we will </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">target simplicity.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">Since we are discussing the memory allocation of a large block upfront through our size-based arena, we need to look at memory size consumption for </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">Orc</span></strong><span class="koboSpan" id="kobo.106.1"> objects. </span><span class="koboSpan" id="kobo.106.2">Supposing </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">sizeof(int)==4</span></strong><span class="koboSpan" id="kobo.108.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">sizeof(double)==8</span></strong><span class="koboSpan" id="kobo.110.1"> and supposing that, being fundamental types, their alignment requirements match their respective sizes, we can assume that </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">sizeof(Orc)==16</span></strong><span class="koboSpan" id="kobo.112.1"> in this case. </span><span class="koboSpan" id="kobo.112.2">If we aim to allocate enough space for all </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">Orc</span></strong><span class="koboSpan" id="kobo.114.1"> objects at once, ensuring </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">sizeof(Orc)</span></strong><span class="koboSpan" id="kobo.116.1"> remains reasonable for the resources at our disposal is important. </span><span class="koboSpan" id="kobo.116.2">For example, defining the maximum number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">Orc</span></strong><span class="koboSpan" id="kobo.118.1"> objects in a program as </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">Orc::NB_MAX</span></strong><span class="koboSpan" id="kobo.120.1"> and the maximal amount of memory we can allocate at once for </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">Orc</span></strong><span class="koboSpan" id="kobo.122.1"> objects as some hypothetical constant named </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">THRESHOLD</span></strong><span class="koboSpan" id="kobo.124.1">, we could leave a </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">static_assert</span></strong><span class="koboSpan" id="kobo.126.1"> such as the following in our source code as a form of </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.127.1">constraints-respected check</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.129.1">
static_assert(Orc::NB_MAX*sizeof(Orc) &lt;= THRESHOLD);</span></pre> <p><span class="koboSpan" id="kobo.130.1">This way, if we end up evolving the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">Orc</span></strong><span class="koboSpan" id="kobo.132.1"> class to the point where resources become an issue, the code will stop compiling and we will be able to reevaluate the situation. </span><span class="koboSpan" id="kobo.132.2">In our case, with a memory consumption of approximately 16 MB, we will suppose we are within budget and that we can proceed with </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">our arena.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">We will want to compare our arena-based implementation with a baseline implementation, which, in this case, will be the standard library-provided implementation </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.135.1">of the memory allocation functions. </span><span class="koboSpan" id="kobo.135.2">It’s important to note upfront that each standard library implementation provides its own version of these functions, so you might want to run the code we will be writing here on more than one implementation to get a better perspective on the impact of </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">our techniques.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">To write code that allows us to do a proper comparison, we will need two distinct executables as we will be in an either/or situation (we either get the standard version or the “homemade” one we are writing), so this is a good use case for macro-based conditional compilation. </span><span class="koboSpan" id="kobo.137.2">We will thus write a single set of source files that will conditionally replace the standard library-provided versions of the allocation operators with ours but will otherwise be </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">essentially identical.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">We will work from three files: </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">Orc.h</span></strong><span class="koboSpan" id="kobo.141.1">, which declares the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">Orc</span></strong><span class="koboSpan" id="kobo.143.1"> class and the conditionally defined allocation operator overloads; </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">Orc.cpp</span></strong><span class="koboSpan" id="kobo.145.1">, which provides the implementation for these overloads as well as the arena implementation itself; and a test program that allocates </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">Orc::NB_MAX</span></strong><span class="koboSpan" id="kobo.147.1"> objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">Orc</span></strong><span class="koboSpan" id="kobo.149.1"> then later destroys them and measures the time it takes to do these two operations. </span><span class="koboSpan" id="kobo.149.2">Of course, as with most microbenchmarks, take these measurements with a grain of salt: the numbers will not be the same in a real program where allocations are interspersed with other code, but at least we will apply the same tests to both implementations of the allocation operators so the comparison should be </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">reasonably fair.</span></span></p>
<h3><span class="koboSpan" id="kobo.151.1">Declaring the Orc class</span></h3>
<p><span class="koboSpan" id="kobo.152.1">First, let us examine </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">Orc.h</span></strong><span class="koboSpan" id="kobo.154.1">, which we have already seen in part when showing the data member</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.155.1"> layout </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.156.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">Orc</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.158.1">class earlier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.159.1">
#ifndef ORC_H
#define ORC_H
</span><strong class="bold"><span class="koboSpan" id="kobo.160.1">// #define HOMEMADE_VERSION</span></strong><span class="koboSpan" id="kobo.161.1">
#include &lt;cstddef&gt;
#include &lt;new&gt;
class Orc {
  char name[4]{ 'U', 'R', 'G' };
  int strength = 100;
  double smell = 1000.0;
public:
  static constexpr int NB_MAX = 1'000'000;
</span><strong class="bold"><span class="koboSpan" id="kobo.162.1">#ifdef HOMEMADE_VERSION</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.163.1">   void * operator new(std::size_t);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.164.1">   void * operator new[](std::size_t);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.165.1">   void operator delete(void *) noexcept;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.166.1">   void operator delete[](void *) noexcept;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.167.1">#endif</span></strong><span class="koboSpan" id="kobo.168.1">
};
#endif</span></pre> <p><span class="koboSpan" id="kobo.169.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">HOMEMADE_VERSION</span></strong><span class="koboSpan" id="kobo.171.1"> macro can be uncommented to use our version of the allocation functions. </span><span class="koboSpan" id="kobo.171.2">As can be expected, since we are applying a special strategy for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">Orc</span></strong><span class="koboSpan" id="kobo.173.1"> class and its expected usage patterns, we are using member-function overloads for the allocation operators. </span><span class="koboSpan" id="kobo.173.2">(We would not want to treat </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">int</span></strong><span class="koboSpan" id="kobo.175.1"> objects or – imagine! </span><span class="koboSpan" id="kobo.175.2">– Elves the same way we</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.176.1"> will treat Orcs, would we? </span><span class="koboSpan" id="kobo.176.2">I </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">thought not.)</span></span></p>
<h3><span class="koboSpan" id="kobo.178.1">Defining the Orc class and implementing an arena</span></h3>
<p><span class="koboSpan" id="kobo.179.1">The essence</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.180.1"> of the memory management-related code will be in </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">Orc.cpp</span></strong><span class="koboSpan" id="kobo.182.1">. </span><span class="koboSpan" id="kobo.182.2">We will go through it in two steps, the arena implementation and the allocation operator overloads, and analyze the different important parts separately. </span><span class="koboSpan" id="kobo.182.3">The whole implementation found in this file will be conditionally compiled based on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">HOMEMADE_VERSION</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.184.1"> macro.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">We will name our arena class </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Tribe</span></strong><span class="koboSpan" id="kobo.187.1">, and it will be a singleton. </span><span class="koboSpan" id="kobo.187.2">Yes, that reviled design pattern we used in </span><a href="B21071_08.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.188.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.189.1"> again, but we really do want a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">Tribe</span></strong><span class="koboSpan" id="kobo.191.1"> object in our program so that </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.192.1">conveys the intent well. </span><span class="koboSpan" id="kobo.192.2">The important parts of our implementation are </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.194.1">The default (and only) constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">Tribe</span></strong><span class="koboSpan" id="kobo.196.1"> class allocates a single block of </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">Orc::NB_MAX*sizeof(Orc)</span></strong><span class="koboSpan" id="kobo.198.1"> bytes. </span><span class="koboSpan" id="kobo.198.2">It is important to note right away that there are no </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">Orc</span></strong><span class="koboSpan" id="kobo.200.1"> objects in that chunk: this memory block is just the right size and shape to put all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">Orc</span></strong><span class="koboSpan" id="kobo.202.1"> objects we will need. </span><span class="koboSpan" id="kobo.202.2">A key idea for arena-based allocation is that, at least for this implementation, </span><em class="italic"><span class="koboSpan" id="kobo.203.1">the arena manages raw memory, not objects</span></em><span class="koboSpan" id="kobo.204.1">: object construction and destruction are the province of user code, and any object not properly destroyed at the end of the program is user code’s fault, not the fault of </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">the arena.</span></span></li>
<li><span class="koboSpan" id="kobo.206.1">We validate at once that the allocation succeeded. </span><span class="koboSpan" id="kobo.206.2">I used an </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">assert()</span></strong><span class="koboSpan" id="kobo.208.1"> in this case, as the rest of the code depends on this success, but throwing </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.210.1"> or calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">std::abort()</span></strong><span class="koboSpan" id="kobo.212.1"> would also have been reasonable options. </span><span class="koboSpan" id="kobo.212.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Tribe</span></strong><span class="koboSpan" id="kobo.214.1"> object keeps two pointers, </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">p</span></strong><span class="koboSpan" id="kobo.216.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">cur</span></strong><span class="koboSpan" id="kobo.218.1">, both initially pointing at the beginning of the block. </span><span class="koboSpan" id="kobo.218.2">We will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">p</span></strong><span class="koboSpan" id="kobo.220.1"> as the </span><em class="italic"><span class="koboSpan" id="kobo.221.1">beginning of block</span></em><span class="koboSpan" id="kobo.222.1"> marker, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">cur</span></strong><span class="koboSpan" id="kobo.224.1"> as the </span><em class="italic"><span class="koboSpan" id="kobo.225.1">pointer to the next block to return</span></em><span class="koboSpan" id="kobo.226.1">; as such, </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">p</span></strong><span class="koboSpan" id="kobo.228.1"> will remain stable throughout program execution and </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">cur</span></strong><span class="koboSpan" id="kobo.230.1"> will move forward by </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">sizeof(Orc)</span></strong><span class="koboSpan" id="kobo.232.1"> bytes with </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">each allocation.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.234.1">Using char* or Orc*</span></p>
<p class="callout"><span class="koboSpan" id="kobo.235.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">Tribe</span></strong><span class="koboSpan" id="kobo.237.1"> implementation uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">char*</span></strong><span class="koboSpan" id="kobo.239.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">p</span></strong><span class="koboSpan" id="kobo.241.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">cur</span></strong><span class="koboSpan" id="kobo.243.1"> pointers but </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">Orc*</span></strong><span class="koboSpan" id="kobo.245.1"> would have been a correct choice also. </span><span class="koboSpan" id="kobo.245.2">One simply needs to remember that, as far as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">Tribe</span></strong><span class="koboSpan" id="kobo.247.1"> object is concerned, there are no </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">Orc</span></strong><span class="koboSpan" id="kobo.249.1"> objects in the arena and the use of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Orc*</span></strong><span class="koboSpan" id="kobo.251.1"> is simply a convenient lie to simplify pointer arithmetic. </span><span class="koboSpan" id="kobo.251.2">The changes this would entail would be replacing </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">static_cast&lt;char*&gt;</span></strong><span class="koboSpan" id="kobo.253.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">static_cast&lt;Orc*&gt;</span></strong><span class="koboSpan" id="kobo.255.1"> in the constructor, and replacing </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">cur+=sizeof(Orc)</span></strong><span class="koboSpan" id="kobo.257.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">++cur</span></strong><span class="koboSpan" id="kobo.259.1"> in the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">allocate()</span></strong><span class="koboSpan" id="kobo.261.1"> member function. </span><span class="koboSpan" id="kobo.261.2">It’s mostly a matter of style and </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">personal preference.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.263.1">The destructor frees the entire block of memory managed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">Tribe</span></strong><span class="koboSpan" id="kobo.265.1"> object. </span><span class="koboSpan" id="kobo.265.2">This is a very efficient procedure: it’s quicker than separately freeing smaller blocks, and it leads to very little </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">memory fragmentation.</span></span></li>
<li><span class="koboSpan" id="kobo.267.1">This first implementation uses the Meyers singleton technique seen in </span><a href="B21071_08.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.268.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.269.1">, but we will use a different approach later in this chapter to compare the performance impacts of two implementation strategies for the same design pattern… because there are such impacts, as we </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">will see.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.271.1">The way our size-based </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.272.1">arena </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.273.1">implementation will benefit from our a priori knowledge of the expected usage pattern is </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.275.1">Each allocation will return a sequentially “allocated” </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Orc</span></strong><span class="koboSpan" id="kobo.277.1">-sized block, meaning that there is no need to search for an appropriately sized block – we always know where </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">it is.</span></span></li>
<li><span class="koboSpan" id="kobo.279.1">There is no work to do when deallocating as we are not reusing the blocks once they have been used. </span><span class="koboSpan" id="kobo.279.2">Note that, per standard rules, the allocation and deallocation functions have to be thread-safe, which explains our use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">std::mutex</span></strong><span class="koboSpan" id="kobo.281.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">this implementation.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.283.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">code follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
#include "Orc.h"
</span><strong class="bold"><span class="koboSpan" id="kobo.286.1">#ifdef HOMEMADE_VERSION</span></strong><span class="koboSpan" id="kobo.287.1">
#include &lt;cassert&gt;
#include &lt;cstdlib&gt;
#include &lt;mutex&gt;
class Tribe {
  std::mutex m;
  char *p, *cur;
  Tribe() : p{ </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">static_cast&lt;char*&gt;(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.289.1">      std::malloc(Orc::NB_MAX * sizeof(Orc))</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.290.1">  )</span></strong><span class="koboSpan" id="kobo.291.1"> } {
      assert(p);
      cur = p;
  }
  Tribe(const Tribe&amp;) = delete;
  Tribe&amp; operator=(const Tribe&amp;) = delete;
public:
  ~Tribe() {
      </span><strong class="bold"><span class="koboSpan" id="kobo.292.1">std::free(p);</span></strong><span class="koboSpan" id="kobo.293.1">
  }
  static auto &amp;get() {
</span><strong class="bold"><span class="koboSpan" id="kobo.294.1">      static Tribe singleton;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.295.1">      return singleton;</span></strong><span class="koboSpan" id="kobo.296.1">
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.297.1">  void * allocate() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.298.1">      std::lock_guard _ { m };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.299.1">      auto q = cur;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.300.1">      cur += sizeof(Orc);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.301.1">      return q;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.302.1">  }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.303.1">  void deallocate(void *) noexcept {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.304.1">  }</span></strong><span class="koboSpan" id="kobo.305.1">
};
// ...</span></pre> <p><span class="koboSpan" id="kobo.306.1">As you might have guessed already, these allocation conditions are close to optimal, but they happen more often than we would think in practice. </span><span class="koboSpan" id="kobo.306.2">A similarly efficient usage pattern would model a stack (the last block allocated is the next block freed), and we write code that uses local variables every day without necessarily realizing that we are using what is often an optimal usage pattern for the </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">underlying memory.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">We then come to the overloaded allocation operators. </span><span class="koboSpan" id="kobo.308.2">To keep this implementation simple, we will suppose there will be no array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">Orc</span></strong><span class="koboSpan" id="kobo.310.1"> objects to allocate, but you can refine the implementation to take arrays into account (it’s not a difficult task; it’s just more complicated</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.311.1"> to write</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.312.1"> relevant test code). </span><span class="koboSpan" id="kobo.312.2">The role played by these functions is to delegate the work to the underlying arena, and they will only be used for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">Orc</span></strong><span class="koboSpan" id="kobo.314.1"> class (there is a caveat to this, which will be discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.315.1">When parameters change</span></em><span class="koboSpan" id="kobo.316.1"> section later in this chapter). </span><span class="koboSpan" id="kobo.316.2">As such, they are </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">almost trivial:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.318.1">
// ...
</span><span class="koboSpan" id="kobo.318.2">void * Orc::operator new(std::size_t) {
  return Tribe::get().allocate();
}
void * Orc::operator new[](std::size_t) {
  assert(false);
}
void Orc::operator delete(void *p) noexcept {
  Tribe::get().deallocate(p);
}
void Orc::operator delete[](void *) noexcept {
  assert(false);
}
</span><strong class="bold"><span class="koboSpan" id="kobo.319.1">#endif // HOMEMADE_VERSION</span></strong></pre> <h3><span class="koboSpan" id="kobo.320.1">Testing our implementation</span></h3>
<p><span class="koboSpan" id="kobo.321.1">We then come to the test</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.322.1"> code implementation we will be using. </span><span class="koboSpan" id="kobo.322.2">This program will be made of a </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.323.1">microbenchmark function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">test()</span></strong><span class="koboSpan" id="kobo.325.1"> and of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">main()</span></strong><span class="koboSpan" id="kobo.327.1"> function. </span><span class="koboSpan" id="kobo.327.2">We will examine </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">both separately.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">test()</span></strong><span class="koboSpan" id="kobo.331.1"> function will take a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">void</span></strong><span class="koboSpan" id="kobo.333.1"> function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">f()</span></strong><span class="koboSpan" id="kobo.335.1">, a variadic pack of arguments, </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">args</span></strong><span class="koboSpan" id="kobo.337.1">, and call </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">f(args...)</span></strong><span class="koboSpan" id="kobo.339.1"> making sure to use perfect forwarding for the arguments in that call to make sure the arguments are passed with the semantic intended in the original call. </span><span class="koboSpan" id="kobo.339.2">It reads a clock before and after the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">f()</span></strong><span class="koboSpan" id="kobo.341.1"> and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">pair</span></strong><span class="koboSpan" id="kobo.343.1"> made of the result of executing </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">f(args...)</span></strong><span class="koboSpan" id="kobo.345.1"> and the time elapsed during this call. </span><span class="koboSpan" id="kobo.345.2">I used </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">high_resolution_clock</span></strong><span class="koboSpan" id="kobo.347.1"> in my code but there are valid reasons to use either </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">system_clock</span></strong><span class="koboSpan" id="kobo.349.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">steady_clock</span></strong><span class="koboSpan" id="kobo.351.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">this situation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.353.1">
#include &lt;chrono&gt;
#include &lt;utility&gt;
template &lt;class F, class ... </span><span class="koboSpan" id="kobo.353.2">Args&gt;
  auto test(F f, Args &amp;&amp;... </span><span class="koboSpan" id="kobo.353.3">args) {
      using namespace std;
      using namespace std::chrono;
</span><strong class="bold"><span class="koboSpan" id="kobo.354.1">      auto pre = high_resolution_clock::now();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.355.1">      auto res = f(std::forward&lt;Args&gt;(args)...);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.356.1">      auto post = high_resolution_clock::now();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.357.1">      return pair{ res, post - pre };</span></strong><span class="koboSpan" id="kobo.358.1">
  }
// ...</span></pre> <p><span class="koboSpan" id="kobo.359.1">You might wonder why we are requiring non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">void</span></strong><span class="koboSpan" id="kobo.361.1"> functions and returning the result of calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">f(args...)</span></strong><span class="koboSpan" id="kobo.363.1"> even if, in some cases, the return value might be a little artificial. </span><span class="koboSpan" id="kobo.363.2">The idea here is to ensure that the compiler thinks the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">f(args...)</span></strong><span class="koboSpan" id="kobo.365.1"> is useful and does not optimize it away. </span><span class="koboSpan" id="kobo.365.2">Compilers are clever beasts indeed and can remove code that seems useless under what is colloquially known as the “as-if rule” (simply put, if there is no visible effect to calling a function, just get rid </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">of it!).</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">For the test program itself, pay attention to the </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">following aspects:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.369.1">First, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">std::vector&lt;Orc*&gt;</span></strong><span class="koboSpan" id="kobo.371.1">, not </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">std::vector&lt;Orc&gt;</span></strong><span class="koboSpan" id="kobo.373.1">. </span><span class="koboSpan" id="kobo.373.2">This might seem strange at first, but since we are testing the speed of </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">Orc::operator new()</span></strong><span class="koboSpan" id="kobo.375.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">Orc::operator delete()</span></strong><span class="koboSpan" id="kobo.377.1">, we will want to actually call these operators! </span><span class="koboSpan" id="kobo.377.2">If we were using a container of </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">Orc</span></strong><span class="koboSpan" id="kobo.379.1"> objects, there would be no call to our </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">operators whatsoever.</span></span></li>
<li><span class="koboSpan" id="kobo.381.1">We call </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">reserve()</span></strong><span class="koboSpan" id="kobo.383.1"> on that </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">std::vector</span></strong><span class="koboSpan" id="kobo.385.1"> object before running our tests, to allocate the</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.386.1"> space</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.387.1"> to put the pointers to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">Orc</span></strong><span class="koboSpan" id="kobo.389.1"> objects we will be constructing. </span><span class="koboSpan" id="kobo.389.2">That is an important aspect of our measurements: calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">push_back()</span></strong><span class="koboSpan" id="kobo.391.1"> and similar insertion functions in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">std::vector</span></strong><span class="koboSpan" id="kobo.393.1"> object will need to reallocate if we try to add an element to a full container, and this reallocation will add noise to our benchmarks, so ensuring the container will not need to reallocate during the tests helps us focus on what we want </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">to measure.</span></span></li>
<li><span class="koboSpan" id="kobo.395.1">What we measure with our </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">test()</span></strong><span class="koboSpan" id="kobo.397.1"> function (used many times already in this book) is a sequence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">Orc::NB_MAX</span></strong><span class="koboSpan" id="kobo.399.1"> calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">Orc::operator new()</span></strong><span class="koboSpan" id="kobo.401.1">, eventually followed by the same number of calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">Orc::operator delete()</span></strong><span class="koboSpan" id="kobo.403.1">. </span><span class="koboSpan" id="kobo.403.2">We suppose a carnage of sorts in the time between the constructions and the destructions, but we are not showing this violence out of respect for you, </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">dear reader.</span></span></li>
<li><span class="koboSpan" id="kobo.405.1">Once we reach the end, we print out the results of our measurements, using microseconds as the measurement unit – our computers today are fast enough that milliseconds would probably not be </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">granular enough.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.407.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">code</span></span><span class="No-Break"><a id="_idIndexMarker560"/></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1"> follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
// ...
</span><span class="koboSpan" id="kobo.410.2">#include "Orc.h"
#include &lt;print&gt;
#include &lt;vector&gt;
int main() {
  using namespace std;
  using namespace std::chrono;
</span><strong class="bold"><span class="koboSpan" id="kobo.411.1">#ifdef HOMEMADE_VERSION</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.412.1">  print("HOMEMADE VERSION\n");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.413.1">#else</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.414.1">  print("STANDARD LIBRARY VERSION\n");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.415.1">#endif</span></strong><span class="koboSpan" id="kobo.416.1">
  vector&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.417.1">Orc*</span></strong><span class="koboSpan" id="kobo.418.1">&gt; orcs;
  auto [r0, dt0] = test([&amp;orcs] {
</span><strong class="bold"><span class="koboSpan" id="kobo.419.1">      for(int i = 0; i != Orc::NB_MAX; ++i)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.420.1">        orcs.push_back(new Orc);</span></strong><span class="koboSpan" id="kobo.421.1">
      return size(orcs);
  });
  // ...
</span><span class="koboSpan" id="kobo.421.2">  // CARNAGE (CENSORED)
  // ...
</span><span class="koboSpan" id="kobo.421.3">  auto [r1, dt1] = test([&amp;orcs] {
</span><strong class="bold"><span class="koboSpan" id="kobo.422.1">      for(auto p : orcs)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.423.1">        delete p;</span></strong><span class="koboSpan" id="kobo.424.1">
      return size(orcs);
  });
  print("Construction: {} orcs in {}\n",
        size(orcs), duration_cast&lt;microseconds&gt;(dt0));
  print("Destruction:  {} orcs in {}\n",
        size(orcs), duration_cast&lt;microseconds&gt;(dt1));
}</span></pre> <p><span class="koboSpan" id="kobo.425.1">At this point, you might wonder whether this is all worth the effort. </span><span class="koboSpan" id="kobo.425.2">After all, our standard libraries are probably very efficient (and indeed, they are, on average, excellent!). </span><span class="koboSpan" id="kobo.425.3">The only way to know whether the results will make us happy is to run the test code and </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.426.1">see </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">for </span></span><span class="No-Break"><a id="_idIndexMarker562"/></span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">ourselves.</span></span></p>
<h3><span class="koboSpan" id="kobo.429.1">Looking at the numbers</span></h3>
<p><span class="koboSpan" id="kobo.430.1">Using an online gcc 15 compiler with the -O2 optimization level and running this code twice (once with the standard library version and once with the homemade version using a Meyers singleton), I get the following numbers for calls to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">new</span></strong><span class="koboSpan" id="kobo.432.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">delete</span></strong><span class="koboSpan" id="kobo.434.1"> operators on </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">Orc::NB_MAX</span></strong><span class="koboSpan" id="kobo.436.1"> (here, </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">10</span></span><span class="No-Break"><span class="superscript"><span class="koboSpan" id="kobo.438.1">6</span></span></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">) objects:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style"/>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.440.1">Homemade</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.441.1">N=10</span></span><span class="No-Break"><span class="superscript"><span class="koboSpan" id="kobo.442.1">6</span></span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.443.1">Standard library</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.444.1">Meyers singleton</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">operator new()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.446.1">23433μs</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.447.1">17906μs</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">operator delete()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.449.1">7943μs</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.450.1">638μs</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.451.1">Table 10.1 – Speed comparison with Meyers singleton implementation</span></p>
<p><span class="koboSpan" id="kobo.452.1">Actual numbers will vary depending on a variety of factors, of course, but the interesting aspect of the comparison is the ratio: our homemade </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">operator new()</span></strong><span class="koboSpan" id="kobo.454.1"> only took 76.4% of the time consumed by the standard library-provided version and our homemade </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">operator delete()</span></strong><span class="koboSpan" id="kobo.456.1"> took… 8.03% of the time required by </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">our baseline.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">Those are quite pleasant results, but they should not really surprise us: we perform constant-time allocation and essentially “no time” deallocation. </span><span class="koboSpan" id="kobo.458.2">We do take the time to lock and unlock a </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">std::mutex</span></strong><span class="koboSpan" id="kobo.460.1"> object on every allocation, but most standard libraries implement mutexes that expect low contention and are very fast under those circumstances, and it so happens that our program does single-threaded allocations and deallocations that lead to code that is clearly devoid </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">of contention.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">Now, your acute reasoning skills might lead you to be surprised that deallocation is not actually faster than what we just measured. </span><span class="koboSpan" id="kobo.462.2">It’s an empty function we are calling, after all, so what’s consuming this </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">CPU time?</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">The answer is… our singleton, or more precisely, access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">static</span></strong><span class="koboSpan" id="kobo.466.1"> local variable used for the Meyers implementation. </span><span class="koboSpan" id="kobo.466.2">Remember from </span><a href="B21071_08.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.467.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.468.1"> that this technique aims to ensure that a singleton is created when needed, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">static</span></strong><span class="koboSpan" id="kobo.470.1"> local variables are constructed the first time their enclosing function </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">C++ implements “magic statics” where the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">static</span></strong><span class="koboSpan" id="kobo.474.1"> local object’s constructor is guarded by synchronization mechanisms that ensure the object is constructed only once. </span><span class="koboSpan" id="kobo.474.2">As we can see, this synchronization, efficient as it is, is not free. </span><span class="koboSpan" id="kobo.474.3">In our case, if we can guarantee that no other global object will need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">Tribe::get()</span></strong><span class="koboSpan" id="kobo.476.1"> before </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">main()</span></strong><span class="koboSpan" id="kobo.478.1"> is called, we</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.479.1"> can replace the Meyers approach with a more classical approach where the singleton is simply a </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">static</span></strong><span class="koboSpan" id="kobo.481.1"> data member of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Tribe</span></strong><span class="koboSpan" id="kobo.483.1"> class, declared within the scope of that class and defined at </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">global scope:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.485.1">
// ...
</span><strong class="bold"><span class="koboSpan" id="kobo.486.1">// "global" singleton implementation (the rest of</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.487.1">// the code remains unchanged)</span></strong><span class="koboSpan" id="kobo.488.1">
class Tribe {
  std::mutex m;
  char *p, *cur;
  Tribe() : p{ static_cast&lt;char*&gt;(
      std::malloc(Orc::NB_MAX * sizeof(Orc))
  ) } {
      assert(p);
      cur = p;
  }
  Tribe(const Tribe&amp;) = delete;
  Tribe&amp; operator=(const Tribe&amp;) = delete;
</span><strong class="bold"><span class="koboSpan" id="kobo.489.1">  static Tribe singleton;</span></strong><span class="koboSpan" id="kobo.490.1">
public:
  ~Tribe() {
      std::free(p);
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.491.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.492.1">static auto &amp;get() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.493.1">      return singleton;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.494.1">  }</span></strong><span class="koboSpan" id="kobo.495.1">
  void * allocate() {
      std::lock_guard _ { m };
      auto q = cur;
      cur += sizeof(Orc);
      return q;
  }
  void deallocate(void *) noexcept {
  }
};
</span><strong class="bold"><span class="koboSpan" id="kobo.496.1">// in a .cpp file somewhere, within a block surrounded</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.497.1">// with #ifdef HOMEMADE_VERSION and #endif</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.498.1">Tribe Tribe::singleton;</span></strong><span class="koboSpan" id="kobo.499.1">
// ...</span></pre> <p><span class="koboSpan" id="kobo.500.1">Moving the </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.501.1">definition of the singleton object away from within the function – placing it at global scope – removes the need for synchronization around the call to its constructor. </span><span class="koboSpan" id="kobo.501.2">We can now compare this implementation with our previous results to evaluate the costs involved, and the gains to be made (</span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">if any).</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">With the same test setup as used previously, adding the “global” singleton to the set of implementations under comparison, we get </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">the following:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" rowspan="2">
<p><span class="No-Break"><span class="koboSpan" id="kobo.505.1">N=10</span></span><span class="No-Break"><span class="superscript"><span class="koboSpan" id="kobo.506.1">6</span></span></span></p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style" colspan="2">
<p><span class="No-Break"><span class="koboSpan" id="kobo.507.1">Homemade</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.508.1">Standard library</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.509.1">Meyers singleton</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.510.1">Global singleton</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">Operator new()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.512.1">23433μs</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.513.1">17906μs</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.514.1">17573μs</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">Operator delete()</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.516.1">7943μs</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.517.1">638μs</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.518.1">0μs</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption"><span class="koboSpan" id="kobo.519.1">Table 10.2 – Speed comparison with Meyers and “global” singleton implementations</span></p>
<p><span class="koboSpan" id="kobo.520.1">Now, this is more like it! </span><span class="koboSpan" id="kobo.520.2">The calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">operator new()</span></strong><span class="koboSpan" id="kobo.522.1"> are slightly faster than they were 74.99% (of the time it took with the standard library version, and 98.14% of the time it took with the Meyers singleton), but the calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">operator delete()</span></strong><span class="koboSpan" id="kobo.524.1"> have become no-ops. </span><span class="koboSpan" id="kobo.524.2">It’s hard to do better </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">than this!</span></span></p>
<p><span class="koboSpan" id="kobo.526.1">So, is it worth the effort? </span><span class="koboSpan" id="kobo.526.2">It depends on your needs, of course. </span><span class="koboSpan" id="kobo.526.3">Speed is a factor; in some programs, the speed gain can be a necessity, but in others, it can be a non-factor or almost so. </span><span class="koboSpan" id="kobo.526.4">The </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.527.1">reduction in memory fragmentation can make a big difference in some programs too, and some will use arenas precisely for that reason. </span><span class="koboSpan" id="kobo.527.2">The point is this: if you need to do this, now you </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">know how.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.529.1">Generalizing to SizeBasedArena&lt;T,N&gt;</span></h2>
<p><span class="koboSpan" id="kobo.530.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">Tribe</span></strong><span class="koboSpan" id="kobo.532.1"> class as written </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.533.1">seems specific to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">Orc</span></strong><span class="koboSpan" id="kobo.535.1"> class but, in practice, it really is specific to </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">Orc</span></strong><span class="koboSpan" id="kobo.537.1">-</span><em class="italic"><span class="koboSpan" id="kobo.538.1">sized</span></em><span class="koboSpan" id="kobo.539.1"> objects as it never calls any function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">Orc</span></strong><span class="koboSpan" id="kobo.541.1"> class; it never constructs an </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">Orc</span></strong><span class="koboSpan" id="kobo.543.1"> object, nor does it ever destroy one. </span><span class="koboSpan" id="kobo.543.2">This means that we could turn that class into a generic class and reuse it for other types that are expected to be used under </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">similar constraints.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">To achieve this, we would decouple the arena code from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">Orc</span></strong><span class="koboSpan" id="kobo.547.1"> class and put it in a separate file, maybe called </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">SizeBasedArena.h</span></strong><span class="koboSpan" id="kobo.549.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.551.1">
#ifndef SIZE_BASED_ARENA_H
#define SIZE_BASED_ARENA_H
#include &lt;cassert&gt;
#include &lt;cstdlib&gt;
#include &lt;mutex&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.552.1">template &lt;class T, std::size_t N&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.553.1">class SizeBasedArena {</span></strong><span class="koboSpan" id="kobo.554.1">
  std::mutex m;
  char *p, *cur;
  SizeBasedArena() : p{ static_cast&lt;char*&gt;(
      std::malloc(N * sizeof(T))
  ) } {
      assert(p);
      cur = p;
  }
  SizeBasedArena(const SizeBasedArena&amp;) = delete;
  SizeBasedArena&amp;
      operator=(const SizeBasedArena&amp;) = delete;
public:
  ~SizeBasedArena() {
      std::free(p);
  }
  static auto &amp;get() {
      static SizeBasedArena singleton;
      return singleton;
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.555.1">  void * allocate_one() {</span></strong><span class="koboSpan" id="kobo.556.1">
      std::lock_guard _ { m };
      auto q = cur;
      </span><strong class="bold"><span class="koboSpan" id="kobo.557.1">cur += sizeof(T);</span></strong><span class="koboSpan" id="kobo.558.1">
      return q;
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.559.1">  void * allocate_n(std::size_t n) {</span></strong><span class="koboSpan" id="kobo.560.1">
      std::lock_guard _ { m };
      auto q = cur;
      </span><strong class="bold"><span class="koboSpan" id="kobo.561.1">cur += n * sizeof(T);</span></strong><span class="koboSpan" id="kobo.562.1">
      return q;
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.563.1">  void deallocate_one(void *) noexcept {</span></strong><span class="koboSpan" id="kobo.564.1">
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.565.1">  void deallocate_n(void *) noexcept {</span></strong><span class="koboSpan" id="kobo.566.1">
  }
};
#endif</span></pre> <p><span class="koboSpan" id="kobo.567.1">It might be surprising that we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">T</span></strong><span class="koboSpan" id="kobo.569.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">N</span></strong><span class="koboSpan" id="kobo.571.1"> as template parameters. </span><span class="koboSpan" id="kobo.571.2">Why type </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">T</span></strong><span class="koboSpan" id="kobo.573.1"> instead of an integer initialized with </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">sizeof(T)</span></strong><span class="koboSpan" id="kobo.575.1"> if we do not use </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">T</span></strong><span class="koboSpan" id="kobo.577.1"> in the arena? </span><span class="koboSpan" id="kobo.577.2">Well, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">Elf</span></strong><span class="koboSpan" id="kobo.579.1"> class (for example) used a size-based arena too, and if we were unlucky enough that </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">sizeof(Orc)==sizeof(Elf)</span></strong><span class="koboSpan" id="kobo.581.1">, then basing ourselves on the sizes of the types rather than on the types themselves might, if the values for their respective </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">N</span></strong><span class="koboSpan" id="kobo.583.1"> parameters are the same, lead </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">Orc</span></strong><span class="koboSpan" id="kobo.585.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">Elf</span></strong><span class="koboSpan" id="kobo.587.1"> to use the same arena… and we do not want that (nor </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">do they!).</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">To simplify the</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.590.1"> initialization </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.591.1">of the singleton in this generic example, we went back to the Meyers technique. </span><span class="koboSpan" id="kobo.591.2">It’s more difficult to guarantee the absence of interdependence at construction time for global objects when writing generic code than it was writing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">Orc</span></strong><span class="koboSpan" id="kobo.593.1">-specific equivalent, as the move to generic code just enlarged the potential user </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">base significantly.</span></span></p>
<p><span class="koboSpan" id="kobo.595.1">The implementation in </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">Orc.cpp</span></strong><span class="koboSpan" id="kobo.597.1"> would now be </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
#include "Orc.h"
#ifdef HOMEMADE_VERSION
</span><strong class="bold"><span class="koboSpan" id="kobo.600.1">#include "SizeBasedArena.h"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.601.1">using Tribe = SizeBasedArena&lt;Orc, Orc::NB_MAX&gt;;</span></strong><span class="koboSpan" id="kobo.602.1">
void * Orc::operator new(std::size_t) {
  </span><strong class="bold"><span class="koboSpan" id="kobo.603.1">return Tribe::get().allocate_one();</span></strong><span class="koboSpan" id="kobo.604.1">
}
void * Orc::operator new[](</span><strong class="bold"><span class="koboSpan" id="kobo.605.1">std::size_t n</span></strong><span class="koboSpan" id="kobo.606.1">) {
  </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">return Tribe::get().allocate_n(n / sizeof(Orc));</span></strong><span class="koboSpan" id="kobo.608.1">
}
void Orc::operator delete(void *p) noexcept {
  </span><strong class="bold"><span class="koboSpan" id="kobo.609.1">Tribe::get().deallocate_one(p);</span></strong><span class="koboSpan" id="kobo.610.1">
}
void Orc::operator delete[](void *p) noexcept {
  </span><strong class="bold"><span class="koboSpan" id="kobo.611.1">Tribe::get().deallocate_n(p);</span></strong><span class="koboSpan" id="kobo.612.1">
}
#endif</span></pre> <p><span class="koboSpan" id="kobo.613.1">You might have noted that since </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">SizeBasedArena&lt;T,N&gt;</span></strong><span class="koboSpan" id="kobo.615.1"> implements allocation functions for </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.616.1">a single</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.617.1"> object or an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">n</span></strong><span class="koboSpan" id="kobo.619.1"> objects, we have extended the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">Orc</span></strong><span class="koboSpan" id="kobo.621.1"> class’s member function allocation operator overloads to cover </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">operator new[]()</span></strong><span class="koboSpan" id="kobo.623.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">operator delete[]()</span></strong><span class="koboSpan" id="kobo.625.1">. </span><span class="koboSpan" id="kobo.625.2">There’s really no reason not to do so at </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">this point.</span></span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.627.1">When parameters change</span></h1>
<p><span class="koboSpan" id="kobo.628.1">Our size-based</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.629.1"> arena implementation is very specific: it supposes the possibility of sequential allocations and the ability to dismiss the (generally important) question of reusing memory after it has </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">been freed.</span></span></p>
<p><span class="koboSpan" id="kobo.631.1">An important caveat to any size-based implementation is, obviously, that we are counting on a specific size. </span><span class="koboSpan" id="kobo.631.2">Know, thus, that with this constraint, our current implementation is slightly dangerous. </span><span class="koboSpan" id="kobo.631.3">Indeed, consider the following evolution of our program, where we envision tougher, meaner </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">Orc</span></strong><span class="koboSpan" id="kobo.633.1"> subclasses such as </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.635.1">
class MeanOrc </span><strong class="bold"><span class="koboSpan" id="kobo.636.1">: public Orc</span></strong><span class="koboSpan" id="kobo.637.1"> {
  </span><strong class="bold"><span class="koboSpan" id="kobo.638.1">float attackBonus; // oops!</span></strong><span class="koboSpan" id="kobo.639.1">
  // ...
</span><span class="koboSpan" id="kobo.639.2">};</span></pre> <p><span class="koboSpan" id="kobo.640.1">It might not be apparent at first, but we just might have broken something important with this new class, as </span><em class="italic"><span class="koboSpan" id="kobo.641.1">the member function allocation operators are inherited by derived classes</span></em><span class="koboSpan" id="kobo.642.1">. </span><span class="koboSpan" id="kobo.642.2">This means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">Tribe</span></strong><span class="koboSpan" id="kobo.644.1"> class, also known under the somewhat noisier name of </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">SizeBasedArena&lt;Orc,Orc::NB_MAX&gt;</span></strong><span class="koboSpan" id="kobo.646.1">, would implement a strategy meant for blocks of </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">sizeof(Orc)</span></strong><span class="koboSpan" id="kobo.648.1"> bytes but be used (accidentally) also for objects of size </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">MeanOrc</span></strong><span class="koboSpan" id="kobo.650.1">. </span><span class="koboSpan" id="kobo.650.2">This can only lead </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">to pain.</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">We can protect ourselves from this disastrous situation in two ways. </span><span class="koboSpan" id="kobo.652.2">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">Orc</span></strong><span class="koboSpan" id="kobo.654.1"> class, we could disallow</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.655.1"> derived classes altogether by marking the class </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">final</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.659.1">
class Orc </span><strong class="bold"><span class="koboSpan" id="kobo.660.1">final</span></strong><span class="koboSpan" id="kobo.661.1"> {
  // ...
</span><span class="koboSpan" id="kobo.661.2">};</span></pre> <p><span class="koboSpan" id="kobo.662.1">This removes the possibility of writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">MeanOrc</span></strong><span class="koboSpan" id="kobo.664.1"> as a derived class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">Orc</span></strong><span class="koboSpan" id="kobo.666.1">; we can still write </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">MeanOrc</span></strong><span class="koboSpan" id="kobo.668.1">, but through composition or other techniques, which would sidestep the inherited </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">operators problem.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">From the perspective of </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">SizeBasedArena&lt;T,N&gt;</span></strong><span class="koboSpan" id="kobo.672.1"> itself, we can also decide to restrict our implementation to </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">final</span></strong><span class="koboSpan" id="kobo.674.1"> types, as in </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.676.1">
// ...
</span><strong class="bold"><span class="koboSpan" id="kobo.677.1">#include &lt;type_traits&gt;</span></strong><span class="koboSpan" id="kobo.678.1">
template &lt;class T, std::size_t N&gt;
class SizeBasedArena {
</span><strong class="bold"><span class="koboSpan" id="kobo.679.1">  static_assert(std::is_final_v&lt;T&gt;);</span></strong><span class="koboSpan" id="kobo.680.1">
   // ...
</span><span class="koboSpan" id="kobo.680.2">};</span></pre> <p><span class="koboSpan" id="kobo.681.1">This last part might not be for everyone, however. </span><span class="koboSpan" id="kobo.681.2">There are lots of types (fundamental types, for example) that are not </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">final</span></strong><span class="koboSpan" id="kobo.683.1"> and that could reasonably be used in a size-based arena, so it’s up to you to see whether this is a good idea or not for the kind of code you write. </span><span class="koboSpan" id="kobo.683.2">If it’s not good for you, then these constraints could be expressed as prose rather than </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">as code.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">Size-based arenas are far from the only use case for memory arenas. </span><span class="koboSpan" id="kobo.685.2">We could envision many variations on both the size-based theme and the </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">allocation strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.687.1">For example, suppose we introduce shamans in our game and the need to reuse memory becomes a reality. </span><span class="koboSpan" id="kobo.687.2">We could have a situation where there are, at most, </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">Orc::NB_MAX</span></strong><span class="koboSpan" id="kobo.689.1"> objects of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">Orc</span></strong><span class="koboSpan" id="kobo.691.1"> type in the program </span><em class="italic"><span class="koboSpan" id="kobo.692.1">at once</span></em><span class="koboSpan" id="kobo.693.1">, but there might be more than that number </span><em class="italic"><span class="koboSpan" id="kobo.694.1">overall</span></em><span class="koboSpan" id="kobo.695.1"> during the entire program’s execution. </span><span class="koboSpan" id="kobo.695.2">In such a situation, we need to consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">following things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.697.1">If we allow arrays, we will have to deal with </span><em class="italic"><span class="koboSpan" id="kobo.698.1">internal</span></em><span class="koboSpan" id="kobo.699.1"> fragmentation within the arena, so we might want to consider an implementation that allocates more than </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">N*sizeof(T)</span></strong><span class="koboSpan" id="kobo.701.1"> bytes per arena, but how </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">much more?</span></span></li>
<li><span class="koboSpan" id="kobo.703.1">We will need a strategy to reuse memory. </span><span class="koboSpan" id="kobo.703.2">There are many approaches at our disposal, including maintaining an ordered list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">begin,end</span></strong><span class="koboSpan" id="kobo.705.1"> pairs to delimit the free blocks (and fuse them more easily to reduce fragmentation) or keeping a stack (maybe a set of stacks based on block size) of recently freed blocks to make it easier to reuse freed </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">blocks quickly.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.707.1">Answers to such</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.708.1"> questions as “</span><em class="italic"><span class="koboSpan" id="kobo.709.1">What is the best approach for our code base?</span></em><span class="koboSpan" id="kobo.710.1">” are in part technical and in part political: what makes allocation fast may slow down deallocation, what makes allocation speed deterministic may cost more in memory space overhead, and so on. </span><span class="koboSpan" id="kobo.710.2">The question is to determine what trade-offs work best in our situation and measure to ensure we reap the desired benefits. </span><span class="koboSpan" id="kobo.710.3">If we cannot manage to do better than the standard library already does, then by all means, use the </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">standard library!</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.712.1">Chunked pools</span></h1>
<p><span class="koboSpan" id="kobo.713.1">Our size-based</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.714.1"> arena example was optimized for a single block size and specific usage patterns, but there are many other reasons to want to apply a specialized allocation strategy. </span><span class="koboSpan" id="kobo.714.2">In this section, we will explore the idea of a “chunked pool,” or a pool of pre-allocated raw memory of selected block sizes. </span><span class="koboSpan" id="kobo.714.3">This is meant as an academic example to build upon more than as something to use in production; the code that follows will be reasonably fast and can be made to become very fast, but in this book, we will focus on the general approach and leave you, dear reader, to enjoy optimizing it to </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">your liking.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">The idea in this example is that user code plans to allocate objects of similar (but not necessarily identical) sizes and of various types and supposes an upper bound on the maximal number of objects. </span><span class="koboSpan" id="kobo.716.2">This gives us additional knowledge; using that knowledge, we will write a </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">ChunkSizedAllocator&lt;N,Sz...&gt;</span></strong><span class="koboSpan" id="kobo.718.1"> type where </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">N</span></strong><span class="koboSpan" id="kobo.720.1"> will be the number of objects of each “size category” and each integral value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">Sz...</span></strong><span class="koboSpan" id="kobo.722.1"> will be a distinct </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">size category.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">To give a clarifying example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">ChunkSizedAllocator&lt;10,20,40,80,160&gt;</span></strong><span class="koboSpan" id="kobo.726.1"> object would pre-allocate sufficient raw memory to hold 10 objects of size 20 bytes, 40 bytes, 80 bytes, and 160 bytes each for a total of at least 3,000 bytes (the sum of the minimal size required for each size category being </span><em class="italic"><span class="koboSpan" id="kobo.727.1">200 + 400 + 800 + 1600</span></em><span class="koboSpan" id="kobo.728.1">). </span><span class="koboSpan" id="kobo.728.2">We say “at least” in this case because to be useful, our class will need to consider alignment and will generally need more than the minimal amount of memory if we are to avoid allocating </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">misaligned objects.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">To understand what we are going to do, here are some pointers (</span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">pun intended):</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.732.1">In the variadic sequence of integral values </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">Sz...</span></strong><span class="koboSpan" id="kobo.734.1"> we will require the values to be sorted in ascending order, as this will make further lookup faster (linear complexity rather than quadratic complexity). </span><span class="koboSpan" id="kobo.734.2">Since these values are known at compile time, being part of the template parameters of our type, this has no runtime costs and is more of a constraint imposed on the user. </span><span class="koboSpan" id="kobo.734.3">We will, of course, validate this at compile time to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">unpleasant mishaps.</span></span></li>
<li><span class="koboSpan" id="kobo.736.1">In C++, variadic packs can be empty, but in our case, an empty set of size categories would make no sense so we will ensure that does not happen (at compile time, of course). </span><span class="koboSpan" id="kobo.736.2">Obviously, </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">N</span></strong><span class="koboSpan" id="kobo.738.1"> has to be more than zero for this class to be useful so we will validate </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">this also.</span></span></li>
<li><span class="koboSpan" id="kobo.740.1">What might not be self-evident is that values in </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">Sz...</span></strong><span class="koboSpan" id="kobo.742.1"> have to be at least </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">sizeof(std::max_align_t)</span></strong><span class="koboSpan" id="kobo.744.1"> (we could have tested for </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">alignof</span></strong><span class="koboSpan" id="kobo.746.1"> too but, for fundamental types, this is redundant) and that, in practice, we will need to make the effective size categories powers of two to make sure arbitrary types can be allocated. </span><span class="koboSpan" id="kobo.746.2">This latter part will be handled internally, as it’s trickier to impose on </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">user code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.748.1">Looking at the code, we can see these constraints expressed explicitly. </span><span class="koboSpan" id="kobo.748.2">Note that to make the “code narrative” easier to follow, the code that follows is presented step by step, so make sure to</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.749.1"> look at the complete example if you want to experiment </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">with it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.751.1">
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;memory&gt;
#include &lt;cassert&gt;
#include &lt;concepts&gt;
#include &lt;limits&gt;
#include &lt;array&gt;
#include &lt;iterator&gt;
#include &lt;mutex&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.752.1">// ... </span><span class="koboSpan" id="kobo.752.2">helper functions (shown below)...</span></strong><span class="koboSpan" id="kobo.753.1">
template &lt;int N, auto ... </span><span class="koboSpan" id="kobo.753.2">Sz&gt;
  class ChunkSizedAllocator {
      static_assert(</span><strong class="bold"><span class="koboSpan" id="kobo.754.1">is_sorted(make_array(Sz...))</span></strong><span class="koboSpan" id="kobo.755.1">);
      static_assert(sizeof...(Sz) &gt; 0);
      static_assert(
        </span><strong class="bold"><span class="koboSpan" id="kobo.756.1">((Sz &gt;= sizeof(std::max_align_t)) &amp;&amp; ...)</span></strong><span class="koboSpan" id="kobo.757.1">
      );
      static_assert(N &gt; 0);
      static constexpr unsigned long long sizes[] {
</span><strong class="bold"><span class="koboSpan" id="kobo.758.1">        next_power_of_two(Sz)...</span></strong><span class="koboSpan" id="kobo.759.1">
      };
      using raw_ptr = void*;
</span><strong class="bold"><span class="koboSpan" id="kobo.760.1">      raw_ptr blocks[sizeof...(Sz)];</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.761.1">      int cur[sizeof...(Sz)] {}; // initialized to zero</span></strong><span class="koboSpan" id="kobo.762.1">
      // ...</span></pre> <p><span class="koboSpan" id="kobo.763.1">Note that we have two data members – namely, </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">blocks</span></strong><span class="koboSpan" id="kobo.765.1">, which will contain a pointer to a block of raw</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.766.1"> memory for each size category, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">cur</span></strong><span class="koboSpan" id="kobo.768.1">, which will contain the index of the next allocation within a block for each size category (initialized to zero by default, as we will start from the beginning in </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">each case).</span></span></p>
<p><span class="koboSpan" id="kobo.770.1">The code for this class continues shortly. </span><span class="koboSpan" id="kobo.770.2">For now, you might notice some unexplained </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">helper functions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.772.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">make_array(Sz...)</span></strong><span class="koboSpan" id="kobo.774.1">, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">constexpr</span></strong><span class="koboSpan" id="kobo.776.1"> function that constructs an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">std::array&lt;T,N&gt;</span></strong><span class="koboSpan" id="kobo.778.1"> from the values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">Sz...</span></strong><span class="koboSpan" id="kobo.780.1">, expecting all values to be of the same type (the type of the first value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">Sz...</span></strong><span class="koboSpan" id="kobo.782.1">). </span><span class="koboSpan" id="kobo.782.2">We know </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">N</span></strong><span class="koboSpan" id="kobo.784.1"> for the resulting </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">std::array&lt;T,N&gt;</span></strong><span class="koboSpan" id="kobo.786.1"> to be a compile-time constant as it is computed from the number of values </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">Sz...</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.790.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">is_sorted()</span></strong><span class="koboSpan" id="kobo.792.1"> predicate on that </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">std::array&lt;T,N&gt;</span></strong><span class="koboSpan" id="kobo.794.1"> object to ensure, at compile time, that the values are sorted in ascending order, as we expect them to be. </span><span class="koboSpan" id="kobo.794.2">Unsurprisingly, this will simply call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">std::is_sorted()</span></strong><span class="koboSpan" id="kobo.796.1"> algorithm, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">constexpr</span></strong><span class="koboSpan" id="kobo.798.1"> and thus usable in </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">this context.</span></span></li>
<li><span class="koboSpan" id="kobo.800.1">The non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">static</span></strong><span class="koboSpan" id="kobo.802.1"> member array named </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">sizes</span></strong><span class="koboSpan" id="kobo.804.1"> will contain the next power of two for each value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">Sz...</span></strong><span class="koboSpan" id="kobo.806.1">, including that value, of course: if the value is already a power of two, wonderful! </span><span class="koboSpan" id="kobo.806.2">Thus, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">Sz...</span></strong><span class="koboSpan" id="kobo.808.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">10,20,32</span></strong><span class="koboSpan" id="kobo.810.1">, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">sizes</span></strong><span class="koboSpan" id="kobo.812.1"> will </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">contain </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">16,32,32</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.816.1">Why powers of two?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.817.1">In practice, blocks that are not powers of two will lead to misaligned objects after the first allocation if we allocate them contiguously, and managing padding to avoid this is possible but would complicate our implementation significantly. </span><span class="koboSpan" id="kobo.817.2">To make allocations quicker, we compute the next power to two for each element of </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">Sz...</span></strong><span class="koboSpan" id="kobo.819.1"> at compile time and store them in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">sizes</span></strong><span class="koboSpan" id="kobo.821.1"> array. </span><span class="koboSpan" id="kobo.821.2">This means we could have two size categories that end up being of the same size (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">40</span></strong><span class="koboSpan" id="kobo.823.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">60</span></strong><span class="koboSpan" id="kobo.825.1"> would both lead to 64 bytes blocks) but that’s a minor issue (as code would still work) considering that this is a specialized facility designed for </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">knowledgeable users.</span></span></p>
<p><span class="koboSpan" id="kobo.827.1">The code for these </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.828.1">helper functions, in practice, defined before the declaration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">ChunkSizedAllocator&lt;N,Sz...&gt;</span></strong><span class="koboSpan" id="kobo.830.1"> class is </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.832.1">
// ...
</span><span class="koboSpan" id="kobo.832.2">template &lt;class T, std::same_as&lt;T&gt; ... </span><span class="koboSpan" id="kobo.832.3">Ts&gt;
  constexpr std::array&lt;T, sizeof...(Ts)+1&gt;
      make_array(T n, Ts ... </span><span class="koboSpan" id="kobo.832.4">ns) {
        return { n, ns... </span><span class="koboSpan" id="kobo.832.5">};
      }
constexpr bool is_power_of_two(std::integral auto n) {
  return n &amp;&amp; ((n &amp; (n - 1)) == 0);
}
class integral_value_too_big {};
constexpr auto next_power_of_two(std::integral auto n) {
  constexpr auto upper_limit =
      std::numeric_limits&lt;decltype(n)&gt;::max();
  for(; n != upper_limit &amp;&amp; !is_power_of_two(n); ++n)
       ;
  if(!is_power_of_two(n)) throw integral_value_too_big{};
  return n;
}
template &lt;class T&gt;
  constexpr bool is_sorted(const T &amp;c) {
      return std::is_sorted(std::begin(c), std::end(c));
  }
// ...</span></pre> <p><span class="koboSpan" id="kobo.833.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">make_array()</span></strong><span class="koboSpan" id="kobo.835.1"> uses concepts to constrain that all values are of the same type, and that </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">is_power_of_two(n)</span></strong><span class="koboSpan" id="kobo.837.1"> ensures that the proper bits of </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">n</span></strong><span class="koboSpan" id="kobo.839.1"> are tested to make this test quick (it also tests </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">n</span></strong><span class="koboSpan" id="kobo.841.1"> to ensure we do not report </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">0</span></strong><span class="koboSpan" id="kobo.843.1"> as being a power of two). </span><span class="koboSpan" id="kobo.843.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">next_power_of_two()</span></strong><span class="koboSpan" id="kobo.845.1"> function could probably be made much faster but that’s of little consequence here as it is only used at compile time (we could enforce this by making it </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">consteval</span></strong><span class="koboSpan" id="kobo.847.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">constexpr</span></strong><span class="koboSpan" id="kobo.849.1">, but there might be users that want to choose between run time and compile time usage so we’ll give them </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">that choice).</span></span></p>
<p><span class="koboSpan" id="kobo.851.1">Returning to</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.852.1"> our </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">ChunkSizedAllocator&lt;N,Sz...&gt;</span></strong><span class="koboSpan" id="kobo.854.1"> implementation after this short digression on helper functions, we have a member function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">within_block(p,i)</span></strong><span class="koboSpan" id="kobo.856.1"> that returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">true</span></strong><span class="koboSpan" id="kobo.858.1"> only if pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">p</span></strong><span class="koboSpan" id="kobo.860.1"> is within </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">blocks[i]</span></strong><span class="koboSpan" id="kobo.862.1">, which is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">i</span></strong><span class="koboSpan" id="kobo.864.1">-th pre-allocated block of memory of our object. </span><span class="koboSpan" id="kobo.864.2">The logic for that function seems deceptively simple: one might simply want to test something that looks like </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">blocks[i]&lt;=p&amp;&amp;p&lt;blocks[i]+N</span></strong><span class="koboSpan" id="kobo.866.1"> but with the proper casts applied, as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">blocks[i]</span></strong><span class="koboSpan" id="kobo.868.1"> variable is of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">void*,</span></strong><span class="koboSpan" id="kobo.870.1"> which precludes pointer arithmetic, but that happens to be incorrect in C++ (remember our discussion of the intricacies of pointer arithmetic in </span><a href="B21071_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.871.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.872.1">). </span><span class="koboSpan" id="kobo.872.2">It probably works in practice for compatibility with C code, but it’s not something you want to </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">rely on.</span></span></p>
<p><span class="koboSpan" id="kobo.874.1">As of this writing, there are ongoing discussions to add a standard library function to test whether a pointer is between two others, but until this happens, we can at least use the standard library-provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">std::less</span></strong><span class="koboSpan" id="kobo.876.1"> functor to make the comparisons somewhat legal. </span><span class="koboSpan" id="kobo.876.2">This is unsatisfactory, I know, but it will probably work on all compilers today… and by making this test local to a specialized function, we will simplify source code updates once we have a real standard solution to </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">this problem:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.878.1">
      // ...
</span><span class="koboSpan" id="kobo.878.2">      bool within_block(void *p, int i) {
        void* b = blocks[i];
        void* e = static_cast&lt;char*&gt;(b) + N * sizes[i];
        return p == b ||
                (</span><strong class="bold"><span class="koboSpan" id="kobo.879.1">std::less{}(b, p) &amp;&amp; std::less{}(p, e)</span></strong><span class="koboSpan" id="kobo.880.1">);
      }
      // ...</span></pre> <p><span class="koboSpan" id="kobo.881.1">There’s no reason to make objects of </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">ChunkSizedAllocator&lt;N,Sz...&gt;</span></strong><span class="koboSpan" id="kobo.883.1"> globally available: this is a tool that could be instantiated many times in a program and used to solve various problems. </span><span class="koboSpan" id="kobo.883.2">We do not want that type to be copyable, however (we could, but that would really complicate the design for </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">limited returns).</span></span></p>
<p><span class="koboSpan" id="kobo.885.1">Through </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.887.1">, our constructor allocates the raw memory blocks for the various sizes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">Sz...</span></strong><span class="koboSpan" id="kobo.889.1">, or at least the next power of two for each of these sizes, as explained earlier in this section, ensuring afterward that all of the allocations succeeded. </span><span class="koboSpan" id="kobo.889.2">We used </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">assert()</span></strong><span class="koboSpan" id="kobo.891.1"> for this, but one could also throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.893.1"> on failure as long as one carefully called </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">std::free()</span></strong><span class="koboSpan" id="kobo.895.1"> on the memory blocks that were successfully allocated before </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">doing so.</span></span></p>
<p><span class="koboSpan" id="kobo.897.1">Our destructor, unsurprisingly, calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">std::free()</span></strong><span class="koboSpan" id="kobo.899.1"> on each memory block: as with the arena implementation </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.900.1">earlier in this chapter, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">ChunkSizedAllocator&lt;N,Sz...&gt;</span></strong><span class="koboSpan" id="kobo.902.1"> object is responsible for memory, not the objects put there by client code, so we have to suppose that client code destroyed all objects stored within the memory blocks of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">ChunkSizedAllocator</span></strong><span class="koboSpan" id="kobo.904.1"> object before that object’s destructor </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.906.1">Note the presence of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">std::mutex</span></strong><span class="koboSpan" id="kobo.908.1"> data member, as we will need this (or some other synchronization tool) to ensure allocations and deallocations are </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">thread-safe later:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.910.1">
      // ...
</span><span class="koboSpan" id="kobo.910.2">      </span><strong class="bold"><span class="koboSpan" id="kobo.911.1">std::mutex m</span></strong><span class="koboSpan" id="kobo.912.1">;
  public:
      ChunkSizedAllocator(const ChunkSizedAllocator&amp;)
         = delete;
      ChunkSizedAllocator&amp;
        operator=(const ChunkSizedAllocator&amp;) = delete;
      ChunkSizedAllocator() {
        int i = 0;
</span><strong class="bold"><span class="koboSpan" id="kobo.913.1">        for(auto sz : sizes)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.914.1">            blocks[i++] = std::malloc(N * sz);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.915.1">        assert(std::none_of(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.916.1">            </span></strong><strong class="bold"><span class="koboSpan" id="kobo.917.1">std::begin(blocks), std::end(blocks),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.918.1">            [](auto p) { return !p; }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.919.1">        ));</span></strong><span class="koboSpan" id="kobo.920.1">
      }
      ~ChunkSizedAllocator() {
</span><strong class="bold"><span class="koboSpan" id="kobo.921.1">        for(auto p : blocks)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.922.1">            std::free(p);</span></strong><span class="koboSpan" id="kobo.923.1">
      }
      // ...</span></pre> <p><span class="koboSpan" id="kobo.924.1">Finally, we reach </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.925.1">the crux of our effort with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">allocate()</span></strong><span class="koboSpan" id="kobo.927.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">deallocate()</span></strong><span class="koboSpan" id="kobo.929.1"> member functions. </span><span class="koboSpan" id="kobo.929.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">allocate(n)</span></strong><span class="koboSpan" id="kobo.931.1">, we search for the smallest element, </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">sizes[i]</span></strong><span class="koboSpan" id="kobo.933.1">, for which the allocated block size is sufficiently big to hold </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">n</span></strong><span class="koboSpan" id="kobo.935.1"> bytes. </span><span class="koboSpan" id="kobo.935.2">Once one such block is found, we lock our </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">std::mutex</span></strong><span class="koboSpan" id="kobo.937.1"> object to avoid race conditions and then look to see whether there is still at least one available block in </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">blocks[i]</span></strong><span class="koboSpan" id="kobo.939.1">; this implementation takes them sequentially and does not reuse them, to keep the discussion simple. </span><span class="koboSpan" id="kobo.939.2">If there is one, we take it, update </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">cur[i]</span></strong><span class="koboSpan" id="kobo.941.1">, and return the appropriate address to the </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">user code.</span></span></p>
<p><span class="koboSpan" id="kobo.943.1">Note that when we do not find a free block in our pre-allocated blocks, or when </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">n</span></strong><span class="koboSpan" id="kobo.945.1"> is too large for the blocks we allocated upfront, we delegate the allocation responsibility to </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">::operator new()</span></strong><span class="koboSpan" id="kobo.947.1"> such that the allocation request might still succeed. </span><span class="koboSpan" id="kobo.947.2">We could also have thrown </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.949.1"> in this case, depending on what the intent is: if it’s important to us that the allocation is made within our blocks and nowhere else, throwing or otherwise failing is a </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">better choice.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.951.1">How could failing be a good thing?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.952.1">Some applications, particularly in embedded systems of low-latency or real-time system domains, are such that software that delivers the right answer or produces the right computation but not in due time is as bad as software that produces a wrong answer. </span><span class="koboSpan" id="kobo.952.2">Think, for example, of a system that controls the brakes of a car: a car that stops after colliding is of limited usefulness indeed. </span><span class="koboSpan" id="kobo.952.3">Such systems are rigorously tested to catch failures before being released and will count on specific runtime behavior; for that reason, when under development, they might prefer failing (in a way that will be caught during their testing phase) rather than defaulting to a strategy that might sometimes not meet their timing requirements. </span><span class="koboSpan" id="kobo.952.4">Of course, please do not ship critical systems that stop working when used in real life: test them well and make sure users are kept safe! </span><span class="koboSpan" id="kobo.952.5">But maybe you are developing a system where, if something bad happens, you will prefer to print “Sorry, we messed up” somewhere and just restart the program, and that’s perfectly fine </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">too sometimes.</span></span></p>
<p><span class="koboSpan" id="kobo.954.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">deallocate(p)</span></strong><span class="koboSpan" id="kobo.956.1"> deallocation</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.957.1"> function goes through each memory block to see whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">p</span></strong><span class="koboSpan" id="kobo.959.1"> is within that block. </span><span class="koboSpan" id="kobo.959.2">Remember that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">within_block()</span></strong><span class="koboSpan" id="kobo.961.1"> function would benefit from a pointer comparison test that the standard does not yet provide as of this writing, so if you use this code in practice, make sure you leave yourself a note to apply this new function as soon as it becomes available. </span><span class="koboSpan" id="kobo.961.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">p</span></strong><span class="koboSpan" id="kobo.963.1"> is in none of our blocks, then it was probably allocated through </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">::operator new()</span></strong><span class="koboSpan" id="kobo.965.1"> so we make sure to free it through </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">::operator delete()</span></strong><span class="koboSpan" id="kobo.967.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">we should.</span></span></p>
<p><span class="koboSpan" id="kobo.969.1">As stated previously, our implementation does not reuse memory once it has been freed, but the location where that reuse should happen has been left in comments (along with code that locks the mutex for that section) so feel free to implement memory block reuse logic there if you </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">want to:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.971.1">
      // ...
</span><span class="koboSpan" id="kobo.971.2">      auto allocate(std::size_t n) {
        using std::size;
</span><strong class="bold"><span class="koboSpan" id="kobo.972.1">        // use smallest block available</span></strong><span class="koboSpan" id="kobo.973.1">
        for(std::size_t i = 0; i != size(sizes); ++i) {
            if(n &lt; sizes[i]) {
              std::lock_guard _ { m };
              if(cur[i] &lt; N) {
                  void *p = static_cast&lt;char*&gt;(blocks[i]) +
                            cur[i] * sizes[i];
                  ++cur[i];
                  return p;
              }
            }
        }
</span><strong class="bold"><span class="koboSpan" id="kobo.974.1">        // either no block fits or no block left</span></strong><span class="koboSpan" id="kobo.975.1">
        return ::operator new(n);
      }
      void deallocate (void *p) {
        using std::size;
        for(std::size_t i = 0; i != size(sizes); ++i) {
            if(within_block(p, i)) {
</span><strong class="bold"><span class="koboSpan" id="kobo.976.1">              //std::lock_guard _ { m };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.977.1">              // if you want to reuse the memory,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.978.1">              // it's in blocks[i]</span></strong><span class="koboSpan" id="kobo.979.1">
              return;
            }
        }
</span><strong class="bold"><span class="koboSpan" id="kobo.980.1">        // p is not in our blocks</span></strong><span class="koboSpan" id="kobo.981.1">
        ::operator delete(p);
      }
  };
  // ...</span></pre> <p><span class="koboSpan" id="kobo.982.1">Since this is a specialized form of allocation to be used by client code as needed, we will use specialized overloads of the allocation operators. </span><span class="koboSpan" id="kobo.982.2">As can be expected, these overloads will be </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.983.1">templates based on the parameters of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">ChunkSizedAllocator</span></strong><span class="koboSpan" id="kobo.985.1"> object to </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">be used:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.987.1">template &lt;int N, auto ... </span><span class="koboSpan" id="kobo.987.2">Sz&gt;</span></strong><span class="koboSpan" id="kobo.988.1">
  void *operator new(std::size_t n, </span><strong class="bold"><span class="koboSpan" id="kobo.989.1">ChunkSizedAllocator&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.990.1">      N, Sz...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.991.1">  &gt; &amp;chunks</span></strong><span class="koboSpan" id="kobo.992.1">) {
      return </span><strong class="bold"><span class="koboSpan" id="kobo.993.1">chunks.allocate(n);</span></strong><span class="koboSpan" id="kobo.994.1">
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.995.1">template &lt;int N, auto ... </span><span class="koboSpan" id="kobo.995.2">Sz&gt;</span></strong><span class="koboSpan" id="kobo.996.1">
  void operator delete (void *p, </span><strong class="bold"><span class="koboSpan" id="kobo.997.1">ChunkSizedAllocator&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.998.1">      N, Sz...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.999.1">  &gt; &amp;chunks</span></strong><span class="koboSpan" id="kobo.1000.1">) {
      return </span><strong class="bold"><span class="koboSpan" id="kobo.1001.1">chunks.deallocate(p);</span></strong><span class="koboSpan" id="kobo.1002.1">
  }
// new[] and delete[] left as an exercise ;)</span></pre> <p><span class="koboSpan" id="kobo.1003.1">Now, we wrote these allocation facilities, but we need to test them, as we need to see whether there are </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.1004.1">benefits to </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">this approach.</span></span></p>
<h3><span class="koboSpan" id="kobo.1006.1">Testing ChunkSizedAllocator</span></h3>
<p><span class="koboSpan" id="kobo.1007.1">We will now write </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.1008.1">a simple test program that </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.1009.1">uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">ChunkSizedAllocator</span></strong><span class="koboSpan" id="kobo.1011.1"> object with an appropriate set of size categories, then allocate and deallocate objects with sizes that fit within these categories in ways that should benefit our class. </span><span class="koboSpan" id="kobo.1011.2">In so doing, we are supposing that users of this class do so seeking to benefit from a priori known size categories. </span><span class="koboSpan" id="kobo.1011.3">Other tests could be conducted to verify the code’s behavior with inappropriate size requests or in the presence of throwing constructors, for example, so feel free to write a more elaborate test harness than the one we will be providing for the sake of our execution </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">speed-related discussion.</span></span></p>
<p><span class="koboSpan" id="kobo.1013.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">test()</span></strong><span class="koboSpan" id="kobo.1015.1"> function used to test our size-based arena earlier in this chapter will be used here again. </span><span class="koboSpan" id="kobo.1015.2">See that section for an explanation of </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">its workings.</span></span></p>
<p><span class="koboSpan" id="kobo.1017.1">It’s not trivial to write a good test program to validate the behavior of a program that allocates and deallocates objects of various sizes. </span><span class="koboSpan" id="kobo.1017.2">What we will do is use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">dummy&lt;N&gt;</span></strong><span class="koboSpan" id="kobo.1019.1"> type whose objects will each occupy a space of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">N</span></strong><span class="koboSpan" id="kobo.1021.1"> bytes in memory (as we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">char[N]</span></strong><span class="koboSpan" id="kobo.1023.1"> data members to get this result, we know that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">alignof(dummy&lt;N&gt;)==1</span></strong><span class="koboSpan" id="kobo.1025.1"> for all valid values </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1027.1">N</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1029.1">We will also write two distinct </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">test_dummy&lt;N&gt;()</span></strong><span class="koboSpan" id="kobo.1031.1"> functions. </span><span class="koboSpan" id="kobo.1031.2">Each of these functions will allocate and then construct the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">dummy&lt;N&gt;</span></strong><span class="koboSpan" id="kobo.1033.1"> object and set up the associated destroy-then-deallocate code, but one will use the standard library implementation of the allocation operators and the other will use </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">our overloads.</span></span></p>
<p><span class="koboSpan" id="kobo.1035.1">You will note that both of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">test_dummy&lt;N&gt;()</span></strong><span class="koboSpan" id="kobo.1037.1"> functions return a pair of values: one will be a pointer to the allocated object and the other will be the code to destroy and deallocate that object. </span><span class="koboSpan" id="kobo.1037.2">Since we will store this information in client code, we need these pairs to be</span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.1038.1"> abstractions that share a common </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.1039.1">type, which explains our use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">void*</span></strong><span class="koboSpan" id="kobo.1041.1"> for the address and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">std::function&lt;void(void*)&gt;</span></strong><span class="koboSpan" id="kobo.1043.1"> for the destruction code. </span><span class="koboSpan" id="kobo.1043.2">We need </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">std::function</span></strong><span class="koboSpan" id="kobo.1045.1"> or something similar here: a function pointer would not suffice as the destruction code can be stateful (we sometimes need to remember what object was used to manage </span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1">the allocation).</span></span></p>
<p><span class="koboSpan" id="kobo.1047.1">The code for these </span><span class="No-Break"><span class="koboSpan" id="kobo.1048.1">tools follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1049.1">
#include &lt;chrono&gt;
#include &lt;utility&gt;
#include &lt;functional&gt;
template &lt;class F, class ... </span><span class="koboSpan" id="kobo.1049.2">Args&gt;
  auto test(F f, Args &amp;&amp;... </span><span class="koboSpan" id="kobo.1049.3">args) {
      using namespace std;
      using namespace std::chrono;
      auto pre = high_resolution_clock::now();
      auto res = f(std::forward&lt;Args&gt;(args)...);
      auto post = high_resolution_clock::now();
      return pair{ res, post - pre };
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.1050.1">template &lt;int N&gt; struct dummy { char _[N] {}; };</span></strong><span class="koboSpan" id="kobo.1051.1">
template &lt;int N&gt; auto </span><strong class="bold"><span class="koboSpan" id="kobo.1052.1">test_dummy()</span></strong><span class="koboSpan" id="kobo.1053.1"> {
</span><strong class="bold"><span class="koboSpan" id="kobo.1054.1">  return std::pair&lt;void *, std::function&lt;void(void*)&gt;&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1055.1">      new dummy&lt;N&gt;{},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1056.1">      [](void *p) { delete static_cast&lt;dummy&lt;N&gt;*&gt;(p); }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1057.1">  };</span></strong><span class="koboSpan" id="kobo.1058.1">
}
template &lt;int N, </span><strong class="bold"><span class="koboSpan" id="kobo.1059.1">class T</span></strong><span class="koboSpan" id="kobo.1060.1">&gt; auto test_dummy(</span><strong class="bold"><span class="koboSpan" id="kobo.1061.1">T &amp;alloc</span></strong><span class="koboSpan" id="kobo.1062.1">) {
  return </span><strong class="bold"><span class="koboSpan" id="kobo.1063.1">std::pair&lt;void *, std::function&lt;void(void*)&gt;&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1064.1">      new (alloc) dummy&lt;N&gt;{},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1065.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1066.1">[&amp;alloc](void *p) { ::operator delete(p, alloc); }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1067.1">  };</span></strong><span class="koboSpan" id="kobo.1068.1">
}
// ...</span></pre> <p><span class="koboSpan" id="kobo.1069.1">Finally, we have to </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.1070.1">write the test program. </span><span class="koboSpan" id="kobo.1070.2">We </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.1071.1">will discuss this program step by step to make sure we grasp all the subtleties involved in </span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">the process.</span></span></p>
<p><span class="koboSpan" id="kobo.1073.1">Our program first decides on a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">N</span></strong><span class="koboSpan" id="kobo.1075.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">ChunkSizedAllocator</span></strong><span class="koboSpan" id="kobo.1077.1"> object as well as on size categories </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">Sz...</span></strong><span class="koboSpan" id="kobo.1079.1"> for that memory manager to use (the value I picked for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">N</span></strong><span class="koboSpan" id="kobo.1081.1"> is arbitrary). </span><span class="koboSpan" id="kobo.1081.2">I deliberately used one </span><em class="italic"><span class="koboSpan" id="kobo.1082.1">non-power-of-two</span></em><span class="koboSpan" id="kobo.1083.1"> size category to show that the values are “rounded up” to the next power of two appropriately: the size request of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">62</span></strong><span class="koboSpan" id="kobo.1085.1"> is translated into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">64</span></strong><span class="koboSpan" id="kobo.1087.1"> when constructing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">sizes</span></strong><span class="koboSpan" id="kobo.1089.1"> data member of our type. </span><span class="koboSpan" id="kobo.1089.2">We then construct that object and name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">chunks</span></strong><span class="koboSpan" id="kobo.1091.1"> because… well, </span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">why not?</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1093.1">
// ...
</span><span class="koboSpan" id="kobo.1093.2">#include &lt;print&gt;
#include &lt;vector&gt;
int main() {
  using namespace std;
  using namespace std::chrono;
  constexpr int N = 100'000;
</span><strong class="bold"><span class="koboSpan" id="kobo.1094.1">  using Alloc = ChunkSizedAllocator&lt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1095.1">      N, 32, 62 /* 64 */, 128</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1096.1">  &gt;;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1097.1">  Alloc chunks; // construct the ChunkSizedAllocator</span></strong><span class="koboSpan" id="kobo.1098.1">
  // ...</span></pre> <p><span class="koboSpan" id="kobo.1099.1">The tests that </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.1100.1">follow take the same form for the</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.1101.1"> standard library and for our specialized facility. </span><span class="koboSpan" id="kobo.1101.2">Let’s look at them </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">in detail:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1103.1">We create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">std::vector</span></strong><span class="koboSpan" id="kobo.1105.1"> object of pairs named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">ptrs</span></strong><span class="koboSpan" id="kobo.1107.1"> filled with default values (null pointers and non-callable functions) for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">N</span></strong><span class="koboSpan" id="kobo.1109.1"> objects in three size categories (because </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">sizeof...(Sz)==3</span></strong><span class="koboSpan" id="kobo.1111.1"> in our example). </span><span class="koboSpan" id="kobo.1111.2">This ensures that the allocation for the space used by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">std::vector</span></strong><span class="koboSpan" id="kobo.1113.1"> object is performed prior to our measurements (prior to the execution of the lambda expression passed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">test()</span></strong><span class="koboSpan" id="kobo.1115.1">) and does not interfere with them later. </span><span class="koboSpan" id="kobo.1115.2">Note that each tested lambda is mutable as it needs to modify the captured </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">ptrs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1"> object.</span></span></li>
<li><span class="koboSpan" id="kobo.1118.1">For each of the three size categories, we then allocate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">N</span></strong><span class="koboSpan" id="kobo.1120.1"> objects of sizes that fit in that category and remember through the returned </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">pair</span></strong><span class="koboSpan" id="kobo.1122.1"> both that object’s address and the code that will correctly finalize </span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1">it later.</span></span></li>
<li><span class="koboSpan" id="kobo.1124.1">Then, to end each test, we use the finalization code on each object and destroy and then </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">deallocate it.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1126.1">It sounds worse than it is, happily for us. </span><span class="koboSpan" id="kobo.1126.2">Once the tests have run to completion, we print out the execution </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.1127.1">time of each test expressed </span><span class="No-Break"><span class="koboSpan" id="kobo.1128.1">as microseconds:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1129.1">
  // ...
</span><span class="koboSpan" id="kobo.1129.2">  auto [r0, dt0] = test([ptrs = std::vector&lt;
      std::pair&lt;
         void*, std::function&lt;void(void*)&gt;
      &gt;&gt;(N * 3)]() mutable {
      </span><strong class="bold"><span class="koboSpan" id="kobo.1130.1">// allocation</span></strong><span class="koboSpan" id="kobo.1131.1">
      for(int i = 0; i != N * 3; i += 3) {
        ptrs[i] = </span><strong class="bold"><span class="koboSpan" id="kobo.1132.1">test_dummy&lt;30&gt;()</span></strong><span class="koboSpan" id="kobo.1133.1">;
        ptrs[i + 1] = </span><strong class="bold"><span class="koboSpan" id="kobo.1134.1">test_dummy&lt;60&gt;()</span></strong><span class="koboSpan" id="kobo.1135.1">;
        ptrs[i + 2] = </span><strong class="bold"><span class="koboSpan" id="kobo.1136.1">test_dummy&lt;100&gt;()</span></strong><span class="koboSpan" id="kobo.1137.1">;
      }
      </span><strong class="bold"><span class="koboSpan" id="kobo.1138.1">// cleanup</span></strong><span class="koboSpan" id="kobo.1139.1">
      for(auto &amp; p : ptrs)
        </span><strong class="bold"><span class="koboSpan" id="kobo.1140.1">p.second(p.first)</span></strong><span class="koboSpan" id="kobo.1141.1">;
      return std::size(ptrs);
  });
  auto [r1, dt1] = test([</span><strong class="bold"><span class="koboSpan" id="kobo.1142.1">&amp;chunks</span></strong><span class="koboSpan" id="kobo.1143.1">, ptrs = std::vector&lt;
      std::pair&lt;
        void*, std::function&lt;void(void*)&gt;
      &gt;&gt;(N * 3)]() mutable {
      </span><strong class="bold"><span class="koboSpan" id="kobo.1144.1">// allocation</span></strong><span class="koboSpan" id="kobo.1145.1">
      for(int i = 0; i != N * 3; i += 3) {
        ptrs[i] = </span><strong class="bold"><span class="koboSpan" id="kobo.1146.1">test_dummy&lt;30&gt;(chunks)</span></strong><span class="koboSpan" id="kobo.1147.1">;
        ptrs[i + 1] = </span><strong class="bold"><span class="koboSpan" id="kobo.1148.1">test_dummy&lt;60&gt;(chunks)</span></strong><span class="koboSpan" id="kobo.1149.1">;
        ptrs[i + 2] = </span><strong class="bold"><span class="koboSpan" id="kobo.1150.1">test_dummy&lt;100&gt;(chunks)</span></strong><span class="koboSpan" id="kobo.1151.1">;
      }
      </span><strong class="bold"><span class="koboSpan" id="kobo.1152.1">// cleanup</span></strong><span class="koboSpan" id="kobo.1153.1">
      for(auto &amp; p : ptrs)
         </span><strong class="bold"><span class="koboSpan" id="kobo.1154.1">p.second(p.first)</span></strong><span class="koboSpan" id="kobo.1155.1">;
      return std::size(ptrs);
  });
   std::print("Standard version : {}\n",
              duration_cast&lt;microseconds&gt;(dt0));
  std::print("Chunked version  : {}\n",
              duration_cast&lt;microseconds&gt;(dt1));
}</span></pre> <p><span class="koboSpan" id="kobo.1156.1">Okay, so that was slightly intricate but hopefully instructive. </span><span class="koboSpan" id="kobo.1156.2">Is it worth the trouble? </span><span class="koboSpan" id="kobo.1156.3">Well, it depends on </span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">your needs.</span></span></p>
<p><span class="koboSpan" id="kobo.1158.1">When I ran this code on the same online gcc 15 compiler with the -O2 optimization level as with the size-based</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.1159.1"> arena, the standard library </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.1160.1">version reported an execution time of 13,360, whereas the time reported for the “chunked” version was 12,032, effectively 90.05% of the standard version’s execution time. </span><span class="koboSpan" id="kobo.1160.2">This kind of speedup can be lovely as long as we remember that the initial allocation done in the constructor of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">chunks</span></strong><span class="koboSpan" id="kobo.1162.1"> object was not measured: the idea here is to show we can save time when it’s important and choose to pay for it when we are not in </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">a hurry.</span></span></p>
<p><span class="koboSpan" id="kobo.1164.1">It’s important to remember that this implementation does not reuse memory, but the standard version does so, which means our speedup might be counterbalanced by a loss of functionality (if it’s a functionality you need, of course). </span><span class="koboSpan" id="kobo.1164.2">In the tests I ran, locking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">std::mutex</span></strong><span class="koboSpan" id="kobo.1166.1"> object or not doing so had a significant impact on speedup, so (a) depending on your platform, there might be a better choice of synchronization mechanism at your disposal, and (b) this implementation is probably too naïve to bring benefits as is if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">deallocate()</span></strong><span class="koboSpan" id="kobo.1168.1"> member function also needs to lock the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">std::mutex</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.1171.1">Of course, one could optimize this (quite academic) version quite a bit, and I invite you dear readers to do so (and test the results every step of the way!). </span><span class="koboSpan" id="kobo.1171.2">The point of this section was more to show (a) that chunk size-based allocation can be done, (b) how it can be done from</span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.1172.1"> an architectural standpoint, and (c) point </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.1173.1">out some risks and potential pitfalls along </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">the way.</span></span></p>
<p><span class="koboSpan" id="kobo.1175.1">That was fun, </span><span class="No-Break"><span class="koboSpan" id="kobo.1176.1">wasn’t it?</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.1177.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1178.1">As a reminder, in this chapter, we examined arena-based allocation with a concrete example (a size-based arena with a particular usage pattern) and saw we could get significant results from it, and then saw another use case with pre-allocated memory blocks from which we picked chunks where we placed objects, again seeing some benefits. </span><span class="koboSpan" id="kobo.1178.2">These techniques showed new ways to control memory management, but in no way are they meant to represent an exhaustive discussion on the subject. </span><span class="koboSpan" id="kobo.1178.3">To be honest, this entire book cannot be an exhaustive treatise on the subject, but it can hopefully give </span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">us ideas!</span></span></p>
<p><span class="koboSpan" id="kobo.1180.1">The next step in our journey will be to expand the techniques seen in this chapter and write something that is not really a garbage collector but is in some ways weaker and in some ways better: deferred reclamation memory zones. </span><span class="koboSpan" id="kobo.1180.2">This will be our last step before we start discussing memory management </span><span class="No-Break"><span class="koboSpan" id="kobo.1181.1">in containers.</span></span></p>
</div>
</body></html>