- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Common Microcontroller Software Interface Standard (CMSIS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the **Common Microcontroller Software Interface
    Standard** (**CMSIS**), a critical framework for Cortex-M and some Cortex-A processors.
    We will begin by learning how to define hardware registers using C structures.
    This foundational knowledge will enable us to read and understand CMSIS-compliant
    header files provided by microcontroller manufacturers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore CMSIS itself, discussing its components and how it facilitates
    efficient software development. Finally, we will set up the necessary header files
    from our silicon manufacturer, demonstrating how CMSIS compliance can streamline
    production and improve code portability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining peripheral registers with C structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding CMSIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the required CMSIS files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be equipped with a solid understanding
    of CMSIS and how to use it to enhance code portability in your Arm Cortex-M projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: Defining peripheral registers with C structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In embedded systems development, defining hardware registers using C structures
    is a fundamental technique that enhances code readability and maintainability.
    In this section, we will explore how to use C structures to represent peripherals
    and their registers, drawing on practical examples and analogies to simplify the
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we configured a **General Purpose Input/Output** (**GPIO**)
    pin (PA5) to turn on an LED by manually defining the address of each required
    register. We learned how to find the correct addresses from documentation, define
    registers, and define register bits. This method, while effective, can become
    cumbersome as projects grow in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: To streamline this process, we can use C structures to represent peripherals
    and their registers. This approach groups related registers into a cohesive unit
    to match the hardware architecture and memory map of our microcontroller, making
    the code more intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a structure to represent the GPIO peripherals and their associated
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we need to get the base address of each GPIO port and the offset
    of each register within these ports. Here, offset refers to the register’s address
    relative to the peripheral’s base address.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the details of creating the structure, it’s important to
    understand how to obtain the necessary base addresses and offsets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the base address and offsets of registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039), we learned how to locate
    the base addresses of peripherals in our datasheet. Specifically, we examined
    pages 54 to 56 of the STM32F411 datasheet, which lists the base addresses for
    the microcontroller’s peripherals. Here are the extracted base addresses for the
    GPIO and **Reset and Clock Control** (**RCC**) peripherals:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Peripheral** | **Base Address** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOA** | 0x4002 0000 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOB** | 0x4002 0400 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOC** | 0x4002 0800 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOD** | 0x4002 0C00 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOE** | 0x4002 1000 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOH** | 0x4002 1C00 |'
  prefs: []
  type: TYPE_TB
- en: '| **RCC** | 0x4002 3800 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: Base addresses of GPIO and RCC'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039), we covered how to
    extract the register offsets from the reference manual (**RM383**). Here are the
    extracted offsets for all the GPIO registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Register** | **Offset** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOx_MODER** | 0x00 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOx_OTYPE****R** | 0x04 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOx_OSPEED****R** | 0x08 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOx_PUPD****R** | 0x0C |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOx_IDR** | 0x10 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOx_ODR** | 0x14 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOx_BSRR** | 0x18 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOx_LCKR** | 0x1C |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOx_AFRL** | 0x20 |'
  prefs: []
  type: TYPE_TB
- en: '| **GPIOx_AFRH** | 0x24 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.2: Offsets of GPIO register'
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 6.1* shows all the GPIO registers of our STM32F411 microcontroller along
    with their offsets, arranged in the same order they appear in memory. Almost all
    registers in our microcontroller are 32 bits (4 bytes) in size. As illustrated
    in *Table 6.1*, each register is offset by 4 bytes from the previous one. For
    instance, the `GPIOx_OTYPER` register at `0x04` is 4 bytes from the `GPIOx_MODER`
    register at `0x00` (0x04 - 0x00 = 4). Similarly, the `GPIOx_PUPDR` register at
    `0x0C` is 4 bytes from the `GPIOx_OSPEEDR` register at `0x08`.'
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that the registers are contiguously arranged in that memory region,
    since we know that each register is 4 bytes in size.
  prefs: []
  type: TYPE_NORMAL
- en: However, this contiguous arrangement is not always the case. There are instances
    where gaps of a few bytes are left between registers within a peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: '*Now, what’s the relationship between the offset and the* *base address?*'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine your microcontroller as a large apartment complex. Each apartment represents
    a peripheral, such as GPIO or RCC, and the entrance to each apartment is the peripheral’s
    base address. Inside each apartment, there are several rooms, which represent
    the registers. Each room has a specific purpose and is located at a certain distance
    from the entrance, known as the **offset**.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when you enter the GPIO apartment (peripheral), the living room
    might be the `GPIOx_MODER` register located right at the entrance (offset 0x00).
    The kitchen could be the `GPIOx_OTYPER` register, located a bit further down the
    hallway (offset 0x04). The bedroom might be the `GPIOx_OSPEEDR` register, located
    even further down the hallway (offset 0x08), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This arrangement shows that each room (register) is placed at a fixed distance
    (offset) from the entrance (base address). In our case, since each room is 4 bytes
    in size, every subsequent room is 4 bytes away from the previous one. However,
    in some apartments (peripherals), there might be extra space between rooms, indicating
    non-contiguous placement of registers. This is similar to having a small hallway
    between rooms, which you’ll notice when you examine peripherals such as the RCC
    peripheral in the reference manual.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go ahead with implementing the peripheral structures using what we
    have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the peripheral structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is our `GPIO_TypeDef` structure, representing the GPIO peripherals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: The line `typedef struct` begins the definition of a new structure type. `typedef`
    is used to create an alias for the structure, allowing us to use `GPIO_TypeDef`
    as a type name later in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each member of the structure is declared as `volatile uint32_t`. Here’s the
    breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`volatile`: This keyword indicates that the value of the variable can change
    at any time, often due to hardware changes. The compiler should not optimize accesses
    to this variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint32_t`: This indicates that each member of the structure is a 32-bit (4-byte)
    unsigned integer. This is important because the registers we are working with
    are also 32 bits in size. To ensure that the structure members accurately represent
    these registers, they must match this size. This alignment guarantees that each
    member corresponds correctly to its respective register in the memory map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also note that the structure members are arranged in the same order and have
    the same size as the registers, as specified in the reference manual.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we discussed in [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039), to
    use any peripheral in the microcontroller, we first need to enable clock access
    to that peripheral. This is done through the RCC peripheral. Let’s create the
    structure for the RCC peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our RCC structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The RCC peripheral of the STM32F411 microcontroller has about 24 registers,
    which are not contiguous, leaving gaps in the memory region. The register we are
    interested in for the purposes of GPIO peripherals is the `AHB1ENR` register,
    which has an offset of 0x30.
  prefs: []
  type: TYPE_NORMAL
- en: In our `RCC_TypeDef`, we have added padding to the structure with the number
    of `uint32_t` (4 bytes) items required to reach the offset 0x30\. In this case,
    it is 12 items. This is *because 4 bytes multiplied by 12 equals 48 bytes*, which
    corresponds to *0x30 in* *hexadecimal notation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have defined two important structures (`GPIO_TypeDef` and
    `RCC_TypeDef`) required to configure and control our GPIO pins. The next step
    involves creating pointers to the base addresses of the GPIO and RCC peripherals
    using these structures. This allows us to access and manipulate the peripheral
    registers in a structured and readable manner. Here is the code snippet that accomplishes
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#define` `RCC_BASE 0x40023800`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This line defines the base address of the RCC peripheral. The address value
    is taken from *Table 6.1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`#define` `GPIOA_BASE 0x40020000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This line defines the base address of the GPIOA peripheral.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`#define RCC ((``RCC_TypeDef*) RCC_BASE)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This line defines a macro, `RCC`, that casts the `RCC_BASE` base address to
    a pointer of type `RCC_TypeDef*`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By doing this, `RCC` becomes a pointer to the RCC peripheral, allowing us to
    access its registers through the `RCC_TypeDef` structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`#define GPIOA ((``GPIO_TypeDef*) GPIOA_BASE)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, this line defines a macro, `GPIOA`, that casts the `GPIOA_BASE` base
    address to a pointer of type `GPIO_TypeDef*`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This makes `GPIOA` a pointer to the GPIOA peripheral, enabling access to its
    registers via the `GPIO_TypeDef` structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this accomplished, we are now ready to test out our implementation. Let’s
    do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the structure-based register access method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s update our previous project to use the structure-based register access
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this new implementation, we access the required registers using the C structure
    pointer operator (`->`). Here’s a breakdown of `RCC->AHB1ENR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RCC`: This is the pointer to a structure of type `RCC_TypeDef`. This pointer
    allows us to access the RCC registers using the structure’s members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`->`: This is the structure pointer operator in C. It is used to access a member
    of a structure through a pointer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AHB1ENR`: This is a member of the `RCC_TypeDef` structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, we use the same approach to access GPIOA registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of `GPIOA->MODER` and `GPIOA->ODR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOA`: This is a pointer to the structure of type `GPIO_TypeDef`, allowing
    access to GPIOA registers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODER`: A member of the `GPIO_TypeDef` structure, representing the GPIO port
    mode register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ODR`: Another member of the `GPIO_TypeDef` structure, representing the GPIO
    port output data register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the project and run it on your development board. It should work the same
    way as the previous project.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to define hardware registers using C structures.
    This technique is an important step toward understanding CMSIS-compliant code,
    which will be covered in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CMSIS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore CMSIS, an important framework designed for
    Arm Cortex-M and some Cortex-A processors. **CMSIS** is a vendor-independent hardware
    abstraction layer that standardizes software interfaces across various Arm Cortex-based
    microcontroller platforms, promoting software portability and reusability. Let’s
    start by understanding CMSIS and its key benefits.
  prefs: []
  type: TYPE_NORMAL
- en: What is CMSIS?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CMSIS, pronounced *See-M-Sys*, is a standard developed by Arm to provide a consistent
    and efficient way to interface with Cortex-based microcontrollers. It includes
    a comprehensive set of APIs, software components, tools, and workflows designed
    to simplify and streamline the development process for embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its key benefits include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standardization**: CMSIS standardizes the interface for all Cortex-based
    microcontrollers, making it easier for you to switch between different microcontrollers
    and tools without having to relearn or reconfigure your code base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: By providing a consistent API, CMSIS allows software developed
    for one microcontroller to be easily ported to another, enhancing code reuse and
    reducing development time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: CMSIS includes optimized libraries and functions, such as **Digital
    Signal Processing** (**DSP**) and neural network kernels, which improve performance
    and reduce the memory footprint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMSIS has several components. Let’s explore some of the commonly used ones.
  prefs: []
  type: TYPE_NORMAL
- en: Key components of CMSIS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CMSIS comprises several components, each serving a unique purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CMSIS-Core (M)**: This component is designed for all Cortex-M and SecurCore
    processors. It provides standardized APIs for configuring the Cortex-M processor
    core and peripherals. It also standardizes the naming of device peripheral registers,
    which helps reduce the learning curve when switching between different microcontrollers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMSIS-Driver**: This provides generic peripheral driver interfaces for middleware,
    facilitating the connection between microcontroller peripherals and middleware
    such as communication stacks, filesystems, or graphical user interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMSIS-DSP**: This component offers a library of over 60 functions for various
    data types, optimized for the **Single Instruction Multiple Data** (**SIMD**)
    instruction sets available on Cortex-M4, M7, M33, and M35P processors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMSIS-NN**: This stands for **neural network**. It includes a collection
    of efficient neural network kernels optimized to maximize the performance and
    minimize the memory footprint on Cortex-M processor cores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMSIS-RTOS**: There are two versions, RTOS v1 and RTOS v2\. RTOS v1 supports
    Cortex-M0, M0+, M3, M4, and M7 processors, providing a common API for real-time
    operating systems. RTOS v2 extends support to Cortex-A5, A7, and A9 processors,
    including features such as dynamic object creation and multi-core system support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMSIS-Pack**: Pack outlines a delivery system for software components, device
    parameters, and evaluation board support. It streamlines software reuse and facilitates
    effective product life cycle management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMSIS-SVD**: **SVD** stands for **System Viewer Description**. It defines
    device description files maintained by the silicon vendor, containing comprehensive
    descriptions of the microcontroller peripherals and registers in XML format. Development
    tools import these files to automatically construct peripheral debug windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another crucial aspect of CMSIS is its coding standard. Let’s take a closer
    look to familiarize ourselves with these guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: The CMSIS coding rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the essential coding rules and conventions used in CMSIS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compliance with ANSI C (C99) and C++ (C++03)**: This ensures compatibility
    with widely accepted programming standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<stdint.h>`, ensuring consistency in data representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complete data types**: Variables and parameters are defined with complete
    data types, avoiding ambiguity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MISRA 2012 conformance**: While CMSIS conforms to the MISRA 2012 guidelines,
    it does not claim full MISRA compliance. Any rule violations are documented for
    transparency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, CMSIS uses specific qualifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__I` for read-only variables (equivalent to **volatile const** in ANSI C)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__O` for write-only variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__IO` for read and write variables (equivalent to **volatile** in ANSI C)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These qualifiers in CMSIS provide a convenient way to specify the intended access
    mode for variables, particularly for memory-mapped peripheral registers.
  prefs: []
  type: TYPE_NORMAL
- en: With this background knowledge, let’s go ahead and learn how to use CMSIS in
    our embedded projects.
  prefs: []
  type: TYPE_NORMAL
- en: The CMSIS-Core files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CMSIS-Core files are categorized into two primary groups, each serving a
    specific purpose in the development process. These groups are the CMSIS-Core standard
    files and the CMSIS-Core device files. *Figure 6**.1* provides a comprehensive
    overview of the CMSIS-Core file structure, illustrating the different types of
    files and their roles in a project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: The CMSIS-Core files](img/B21914_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The CMSIS-Core files'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'The files are divided into three categories: **CMSIS-Core Standard Files**,
    **CMSIS-Core Device Files**, and **User** **Program Files**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **CMSIS-Core Standard Files** category of files is provided by Arm and
    typically does not require modifications. They include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`core_<cpu>.h`: This provides access to the CPU and core-specific functionalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmsis_compiler.h`: This contains core peripheral functions, CPU instruction
    access, and SIMD instruction access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<arch>_<feature>.h`: This defines architecture-specific attributes and features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmsis_<compiler>_m.h`: This is a toolchain-specific file that aids in compiler
    compatibility and optimization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next category is **CMSIS-Core Device Files**. These files are provided
    by silicon vendors (such as STMicroelectronics) and may require application-specific
    modifications. They include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system_<Device>.c`: This file handles system and clock configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`partition_<Device>.h`: This manages secure attributes and interrupt assignments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startup_<Device>.c`: This contains the device startup interrupt vectors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Device>.h`: This provides access to the CMSIS device peripheral functionalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system_<Device>.h`: This assists in system and clock configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third category is **User Program Files**. These are created by us, the developers,
    and include the main application code along with other user-defined functionalities
    essential for the project’s operation.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CMSIS is fundamental for efficient and standardized development
    across various Arm Cortex-based microcontroller platforms. In this section, we
    have explored its key components, the CMSIS coding standards, and the CMSIS-Core
    files crucial to the development of embedded projects. In the next section, we
    will learn how to include the required CMSIS files in our project, enabling us
    to leverage the full potential of this robust framework for developing embedded
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the required CMSIS files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will work through the process of integrating CMSIS files
    into our project. These files also contain the definitions of all the registers
    and their respective bits, making it easier to manage and configure peripherals
    without manually defining each register.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the right header files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by downloading the package for our microcontroller from the STMicroelectronics
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your browser and go to [https://www.st.com/content/st_com/en.html](https://www.st.com/content/st_com/en.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `STM32CubeF4` to locate the package for the STM32F4 microcontroller
    series.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, download the STM32CubeF4 package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the STM32CubeF4 package and download the latest version. Make sure not
    to download the patch version.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the download is complete, unzip the package. You will find several subfolders
    inside, including the `Drivers` folder.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our next steps involve organizing the files:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside your project workspace, create a new folder named `chip_headers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `chip_headers` folder, create another folder named `CMSIS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `Drivers/CMSIS` in the extracted package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the entire `Include` folder from `Drivers/CMSIS` into `chip_headers/CMSIS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, copy the `Device` folder from `Drivers/CMSIS` into `chip_headers/CMSIS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we clean up the `Device` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `chip_headers/CMSIS/Device/ST/STM32F4xx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete all files and folders, *except the Include folder*. This ensures you
    keep only the necessary header files for your specific microcontroller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving forward, we will consistently include the `chip_headers` folder in our
    project directories. This practice ensures that anyone running our projects on
    a different computer won’t encounter errors due to missing header files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll create a new project in STM32CubeIDE. After setting
    up the project, we’ll copy the `chip_headers` folder and paste it into the project
    directory. Subsequently, we’ll add the subfolders within `chip_headers` to our
    project’s `include` paths, ensuring seamless integration of the necessary CMSIS
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CMSIS files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will integrate the CMSIS files into our project by adding
    the relevant folders to our project’s `include` paths. We will then test our setup
    by updating our `main.c` file to use these CMSIS files instead of our manually
    defined peripheral structures.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by creating a new project following the steps outlined in [*Chapter
    1*](B21914_01.xhtml#_idTextAnchor015). I will name my project `header_files`.
    Once the project is created, I’ll copy and paste the `chip_headers` folder into
    the project folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task involves adding the paths of the subfolders within the `chip_headers`
    folder to our project’s `include` paths:'
  prefs: []
  type: TYPE_NORMAL
- en: Open STM32CubeIDE, right-click on your project, and select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the **Properties** window opens, expand the **C/C++** **General** options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Paths** **and Symbols**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Includes** tab, click **Add** to add a new directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `${ProjDirPath}\chip_headers\CMSIS\Include` to add the `Include` folder
    located in our `CMSIS` folder, and then click **OK** to save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add** again to add another directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `${ProjDirPath}\chip_headers\CMSIS\Device\ST\STM32F4xx\Include` to add
    the `Include` folder located in the `STM32F4xx` subdirectory and click **OK**
    to save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6**.2* illustrates the Project Properties window after adding these
    directories to the project’s `include` paths.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: The Includes tab in the project properties window](img/B21914_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: The Includes tab in the project properties window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the two lines we have just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${``ProjDirPath}\chip_headers\CMSIS\Include`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${ProjDirPath}`: This is a macro in STM32CubeIDE that represents the root
    directory of your current project. It’s a placeholder that dynamically points
    to the directory where your project is located.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\chip_headers\CMSIS\Include`: This specifies the path relative to the project’s
    root directory. It points to the `Include` folder within the `CMSIS` directory
    inside the `chip_headers` folder. This folder contains general CMSIS include files,
    which provide core functionalities and definitions for the Cortex-M processor.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${``ProjDirPath}\chip_headers\CMSIS\Device\ST\STM32F4xx\Include`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${ProjDirPath}`: As mentioned earlier, this macro represents the root directory
    of your current project.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\chip_headers\CMSIS\Device\ST\STM32F4xx\Include`: This specifies another path
    relative to the project’s root directory. It points to the `Include` folder within
    the `STM32F4xx` subdirectory inside the `Device` directory, which is located in
    the `CMSIS` directory in the `chip_headers` folder. This folder contains device-specific
    include files for the STM32F4xx series microcontrollers, providing definitions
    and configurations specific to this family of microcontrollers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Before closing the project properties dialog box, we need to specify the exact
    version of the STM32F4 microcontroller we are using. This ensures that the appropriate
    header file for our specific microcontroller is enabled in our project. As we
    can see, the `STM32F4xx\Include` subfolder contains header files for various microcontrollers
    within the STM32F4 family. The NUCLEO-F411 development board has the STM32F411
    microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure our project for the STM32F411 microcontroller:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **#** **Symbols** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add…** to add a new symbol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `STM32F411xE` in the **Name** field and then click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Apply and Close** to save all changes and close the Project Properties
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6**.3* illustrates the `STM32F411xE` symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: The Symbols tab in the project properties window](img/B21914_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The Symbols tab in the project properties window'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our setup, let’s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the entire content of the `main.c` file from our previous project that
    used the structure-based access approach.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `main.c` file in the current project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete all the existing content in the `main.c` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the copied content into the `main.c` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main.c` file, delete all the code related to manually defined addresses
    and structures, as we will now use the register definitions provided in our header
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the `stm32f4xx.h` header file in your project to access these definitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project in the IDE and run it on the development board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following snippet shows the updated `main.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You’ll observe that this project builds without any errors and works in the
    same way as our previous one. This implementation accesses the microcontroller
    registers defined in `chip_headers/CMSIS/Device/ST/STM32F4xx/Include/stm32f411xe.h`.
  prefs: []
  type: TYPE_NORMAL
- en: Upon inspecting this file, you will find that it contains a `typedef` structure
    for each peripheral of our microcontroller, similar to the one we manually created
    a few sections ago. This means that moving forward, we don’t need to manually
    extract the base addresses and register offsets from the documentation. Instead,
    we can simply include the `stm32f4xx.h` header file in our project. This header
    file will in turn include the `stm32f411xe.h` file because we specified in the
    **Symbols** tab of the project properties window that we are using the *STM32F411xE*
    microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the required header files significantly simplifies configuring and
    using peripherals on our STM32 microcontroller. This approach allows us to leverage
    pre-defined register addresses and bit definitions, making our code more readable
    and maintainable while also reducing development time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored CMSIS, a critical framework for Cortex-M and some
    Cortex-A processors. This chapter gave us the foundational knowledge to enhance
    code portability and efficiency in our Arm Cortex-M projects.
  prefs: []
  type: TYPE_NORMAL
- en: We began by learning how to define hardware registers using C structures, a
    fundamental technique for improving code readability and maintainability. This
    knowledge allowed us to understand how the CMSIS-compliant header files provided
    by microcontroller manufacturers give us access to the register definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored CMSIS itself, discussing its components and how it facilitates
    efficient software development. We examined the key benefits of CMSIS, such as
    standardization, portability, and efficiency, and introduced its main components,
    including CMSIS-Core, CMSIS-Driver, CMSIS-DSP, CMSIS-NN, CMSIS-RTOS, CMSIS-Pack,
    and CMSIS-SVD.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to setting up the necessary CMSIS files from our silicon manufacturer.
    This process involved downloading the relevant packages, organizing the files,
    and integrating them into our project.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we tested our setup by updating our previous project to use CMSIS files
    instead of our manually defined peripheral structures. This practical application
    showcased how CMSIS simplifies accessing microcontroller registers, making the
    code more readable, maintainable, and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the GPIO peripheral. This chapter will
    provide a comprehensive understanding of how to configure and use GPIO for input/output
    applications in embedded systems.
  prefs: []
  type: TYPE_NORMAL
