- en: Chapter 2. Drawing in SDL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 SDL中的绘图
- en: Graphics are very important to games and they can also be one of the main performance
    bottlenecks if not handled correctly. With SDL 2.0 we can really take advantage
    of the GPU when rendering, which gives us a real boost in terms of the speed of
    rendering.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图形对游戏非常重要，如果处理不当，它们也可能成为主要的性能瓶颈。使用SDL 2.0，我们可以在渲染时真正利用GPU，这为我们提供了渲染速度的实际提升。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The basics of drawing with SDL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SDL绘图的基础
- en: Source and destination rectangles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源和目标矩形
- en: Loading and displaying textures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和显示纹理
- en: Using the `SDL_image` extension
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SDL_image`扩展
- en: Basic SDL drawing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的SDL绘图
- en: In the previous chapter we created an SDL window but we have yet to render anything
    to the screen. SDL can use two structures to draw to the screen. One is the `SDL_Surface`
    structure, which contains a collection of pixels and is rendered using software
    rendering processes (not the GPU). The other is `SDL_Texture`; this can be used
    for hardware-accelerated rendering. We want our games to be as efficient as possible
    so we will focus on using `SDL_Texture`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个SDL窗口，但我们还没有将任何内容渲染到屏幕上。SDL可以使用两种结构来绘制到屏幕上。一个是`SDL_Surface`结构，它包含一组像素，并使用软件渲染过程（而不是GPU）进行渲染。另一个是`SDL_Texture`；这可以用于硬件加速渲染。我们希望我们的游戏尽可能高效，所以我们将专注于使用`SDL_Texture`。
- en: Getting some images
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取一些图像
- en: We need some images to load throughout this chapter. We do not want to spend
    any time creating art assets for our games at this point; we want to focus entirely
    on the programming side. In this book we will use assets from the `SpriteLib`
    collection available at [http://www.widgetworx.com/widgetworx/portfolio/spritelib.html](http://www.widgetworx.com/widgetworx/portfolio/spritelib.html).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们需要一些图像来加载。我们不想在这个阶段花费任何时间来为我们的游戏创建艺术资产；我们希望完全专注于编程方面。在这本书中，我们将使用来自[http://www.widgetworx.com/widgetworx/portfolio/spritelib.html](http://www.widgetworx.com/widgetworx/portfolio/spritelib.html)的`SpriteLib`集合中的资产。
- en: 'I have altered some of these files to allow us to easily use them in the upcoming
    chapters. These images are available with the source code download for this book.
    The first one we will use is the `rider.bmp` image file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经修改了一些文件，以便我们可以在接下来的章节中轻松使用它们。这些图像可以在本书的源代码下载中找到。我们将使用的第一张是`rider.bmp`图像文件：
- en: '![Getting some images](img/6821OT_02_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![获取一些图像](img/6821OT_02_01.jpg)'
- en: Creating an SDL texture
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SDL纹理
- en: First we will create a pointer to an `SDL_Texture` object as a member variable
    in our `Game.h` header file. We will also create some rectangles to be used when
    drawing the texture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在我们的`Game.h`头文件中创建一个指向`SDL_Texture`对象的指针作为成员变量。我们还将创建一些矩形，用于绘制纹理。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can load this texture in our game''s `init` function for now. Open up `Game.cpp`
    and follow the steps to load and draw an `SDL_Texture`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在游戏的`init`函数中加载这个纹理。打开`Game.cpp`，按照以下步骤加载和绘制`SDL_Texture`：
- en: First we will make an assets folder to hold our images, place this in the same
    folder as your source code (not the executable code). When you want to distribute
    the game you will copy this assets folder along with your executable. But for
    development purposes we will keep it in the same folder as the source code. Place
    the `rider.bmp` file into this assets folder.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个资产文件夹来存放我们的图像，将其放置在与您的源代码相同的文件夹中（不是可执行代码）。当您想要分发游戏时，您将复制此资产文件夹以及您的可执行文件。但为了开发目的，我们将将其保留在源代码的同一文件夹中。将`rider.bmp`文件放入此资产文件夹。
- en: In our game's `init` function we can load our image. We will use the `SDL_LoadBMP`
    function which returns an `SDL_Surface*`. From this `SDL_Surface*` we can create
    `SDL_Texture` structure using the `SDL_CreateTextureFromSurface` function. We
    then free the temporary surface, releasing any used memory.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的游戏的`init`函数中，我们可以加载我们的图像。我们将使用`SDL_LoadBMP`函数，它返回一个`SDL_Surface*`。从这个`SDL_Surface*`，我们可以使用`SDL_CreateTextureFromSurface`函数创建`SDL_Texture`结构。然后我们释放临时表面，释放任何使用的内存。
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We now have `SDL_Texture` ready to be drawn to the screen. We will first get
    the dimensions of the texture we have just loaded, and use them to set the width
    and height of `m_sourceRectangle` so that we can draw it correctly.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经有了`SDL_Texture`准备绘制到屏幕上。我们将首先获取我们刚刚加载的纹理的尺寸，并使用这些尺寸来设置`m_sourceRectangle`的宽度和高度，以便我们可以正确地绘制它。
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Querying the texture will allow us to set the width and height of our source
    rectangle to the exact dimensions needed. So now that we have the correct height
    and width of our texture stored in `m_sourceRectangle` we must also set the destination
    rectangle's height and width. This is done so that our renderer knows which part
    of the window to draw our image to, and also the width and height of the image
    we want to render. We will set both x and y coordinates to `0` (top left). Window
    coordinates can be represented with an `x` and `y` value, with `x` being the horizontal
    position and `y` the vertical. Therefore the coordinates for the top-left of a
    window in SDL would be (0,0) and the center point would be the width of the window
    divided by two for `x`, and the height of the window divided by two for `y`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询纹理将允许我们将源矩形的宽度和高度设置为所需的精确尺寸。因此，现在我们已经将纹理的正确宽度和高度存储在 `m_sourceRectangle` 中，我们还必须设置目标矩形的宽度和高度。这样做是为了让渲染器知道要将图像绘制到窗口的哪个部分，以及我们想要渲染的图像的宽度和高度。我们将
    x 和 y 坐标都设置为 `0`（左上角）。窗口坐标可以用 `x` 和 `y` 值表示，其中 `x` 是水平位置，`y` 是垂直位置。因此，SDL 中窗口左上角的坐标是
    (0,0)，中心点对于 `x` 是窗口宽度的一半，对于 `y` 是窗口高度的一半。
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have a loaded texture and its dimensions, we can move on to rendering
    it to the screen. Move to our game's `render` function and we will add the code
    to draw our texture. Put this function between the calls to `SDL_RenderClear`
    and `SDL_RenderPresent`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经加载了纹理及其尺寸，我们可以继续将其渲染到屏幕上。移动到我们的游戏的 `render` 函数，我们将添加代码来绘制我们的纹理。将此函数放置在
    `SDL_RenderClear` 和 `SDL_RenderPresent` 调用之间。
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Build the project and you will see our loaded texture.![Creating an SDL texture](img/6821OT_02_02.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目，你会看到我们加载的纹理。![创建 SDL 纹理](img/6821OT_02_02.jpg)
- en: Source and destination rectangles
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源和目标矩形
- en: Now that we have something drawn to the screen, it is a good idea to cover the
    purpose of source and destination rectangles, as they will be extremely important
    for topics such as tile map loading and drawing. They are also important for sprite
    sheet animation which we will be covering later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在屏幕上绘制了一些内容，解释源矩形和目标矩形的作用是个好主意，因为它们对于诸如瓦片地图加载和绘制等主题将极为重要。它们对于精灵表动画也很重要，我们将在本章后面讨论。
- en: 'We can think of a source rectangle as defining the area we want to copy from
    a texture onto the window:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将源矩形视为定义从纹理复制到窗口的区域的区域：
- en: In the previous example, we used the entire image so we could simply define
    the source rectangle's dimensions with the same dimensions as those of the loaded
    texture.![Source and destination rectangles](img/6821OT_02_03.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了整个图像，因此我们可以简单地使用与加载的纹理相同的尺寸来定义源矩形的尺寸。![源和目标矩形](img/6821OT_02_03.jpg)
- en: The red box in the preceding screenshot is a visual representation of the source
    rectangle we used when drawing to the screen. We want to copy pixels from inside
    the source rectangle to a specific area of the renderer, the destination rectangle
    (the red box in the following screenshot).![Source and destination rectangles](img/6821OT_02_04.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前一个屏幕截图中的红色框是我们绘制到屏幕时所使用的源矩形的视觉表示。我们希望从源矩形内部复制像素到渲染器的特定区域，即目标矩形（以下屏幕截图中的红色框）。![源和目标矩形](img/6821OT_02_04.jpg)
- en: As you would expect, these rectangles can be defined however you wish. For example,
    let's open up our `Game.cpp` file again and take a look at changing the size of
    the source rectangle. Place this code after the `SDL_QueryTexture` function.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所预期，这些矩形可以按照您的意愿定义。例如，让我们再次打开我们的 `Game.cpp` 文件，看看如何更改源矩形的尺寸。将此代码放置在 `SDL_QueryTexture`
    函数之后。
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now build again and you should see that only a 50 x 50 square of the image has
    been copied across to the renderer.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在再次构建项目，你应该会看到只有图像的 50 x 50 平方区域被复制到了渲染器中。
- en: '![Source and destination rectangles](img/6821OT_02_05.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![源和目标矩形](img/6821OT_02_05.jpg)'
- en: Now let us move the destination rectangle by changing its `x` and `y` values.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过更改其 `x` 和 `y` 值来移动目标矩形。
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Build the project again and you will see that our source rectangle location
    has remained the same but the destination rectangle has moved. All we have done
    is move the location that we want the pixels inside the source rectangle to be
    copied to.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次构建项目，你会看到我们的源矩形位置保持不变，但目标矩形已经移动。我们所做的只是移动了我们要将源矩形内的像素复制到的位置。
- en: '![Source and destination rectangles](img/6821OT_02_06.jpg)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![源和目标矩形](img/6821OT_02_06.jpg)'
- en: So far we have left the source rectangle's `x` and `y` coordinates at 0 but
    they can also be moved around to only draw the section of the image that you want.
    We can move the `x` and `y` coordinates of the source to draw the bottom-right
    section of the image rather than the top-left. Place this code just before where
    we set the destination rectangle's location.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已将源矩形的`x`和`y`坐标保持在0，但它们也可以移动，以仅绘制所需的图像部分。我们可以移动源矩形的`x`和`y`坐标，以绘制图像的右下角部分而不是左上角。将此代码放置在设置目标矩形位置的代码之前。
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that we are still drawing to the same destination location but we
    are copying a different 50 x 50 section of the image.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以看到，我们仍在绘制到相同的目标位置，但我们正在复制图像的不同50 x 50部分。
- en: '![Source and destination rectangles](img/6821OT_02_07.jpg)'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![源矩形和目标矩形](img/6821OT_02_07.jpg)'
- en: We can also pass null into the render copy for either rectangle.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以将`null`传递给任一矩形的渲染复制。
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Passing null into the source rectangle parameter will make the renderer use
    the entire texture. Likewise, passing null to the destination rectangle parameter
    will use the entire renderer for display.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`null`传递给源矩形参数将使渲染器使用整个纹理。同样，将`null`传递给目标矩形参数将使用整个渲染器进行显示。
- en: '![Source and destination rectangles](img/6821OT_02_08.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![源矩形和目标矩形](img/6821OT_02_08.jpg)'
- en: We have covered a few different ways that we can use rectangles to define areas
    of images that we would like to draw. We will now put that knowledge into practice
    by displaying an animated sprite sheet.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了几种我们可以使用矩形来定义我们想要绘制的图像区域的方法。现在，我们将通过显示动画精灵图来将这些知识付诸实践。
- en: Animating a sprite sheet
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精灵图动画
- en: 'We can apply our understanding of source and destination rectangles to the
    animation of a sprite sheet. A sprite sheet is a series of animation frames all
    put together into one image. The separate frames need to have a very specific
    width and height so that they create a seamless motion. If one part of the sprite
    sheet is not correct it will make the whole animation look out of place or completely
    wrong. Here is an example sprite sheet that we will use for this demonstration:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们对源矩形和目标矩形的理解应用到精灵图动画中。精灵图是一系列动画帧组合成的一张图片。单独的帧需要具有非常特定的宽度和高度，以便它们能够创建出无缝的运动。如果精灵图的一部分不正确，将会使整个动画看起来不协调或完全错误。以下是我们将用于此演示的示例精灵图：
- en: '![Animating a sprite sheet](img/6821OT_02_09.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![精灵图动画](img/6821OT_02_09.jpg)'
- en: This animation is six frames long and each frame is 128 x 82 pixels. We know
    from the previous section that we can use a source rectangle to grab a certain
    part of an image. Therefore we can start by defining a source rectangle that encompasses
    the first frame of the animation only.![Animating a sprite sheet](img/6821OT_02_10.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个动画由六个帧组成，每个帧的大小为128 x 82像素。根据前面的章节，我们知道我们可以使用源矩形来获取图像的某个部分。因此，我们可以首先定义一个源矩形，仅包含动画的第一帧。![精灵图动画](img/6821OT_02_10.jpg)
- en: Since we know the width, height, and location of the frame on the sprite sheet
    we can go ahead and hardcode these values into our source rectangle. First we
    must load the new `animate.bmp` file. Place it into your assets folder and alter
    the loading code.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们知道精灵图上帧的宽度、高度和位置，我们可以将这些值硬编码到我们的源矩形中。首先，我们必须加载新的`animate.bmp`文件。将其放入您的资产文件夹中，并修改加载代码。
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will now load our new sprite sheet BMP. We can remove the `SDL_QueryTexture`
    function as we are now defining our own sizes. Alter the size of the source rectangle
    to only get the first frame of the sheet.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将现在加载我们新的精灵图BMP。我们可以删除`SDL_QueryTexture`函数，因为我们现在正在定义自己的尺寸。调整源矩形的大小，以仅获取图的第一帧。
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will leave the `x` and `y` position of both rectangles at `0` so that we
    draw the image from the top-left corner and also copy it to the top-left corner
    of the renderer. We will also leave the dimensions of the destination rectangle
    as we want it to remain the same as the source rectangle. Pass both rectangles
    into the `SDL_RenderCopy` function:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保持两个矩形的`x`和`y`位置为`0`，这样我们就可以从左上角绘制图像，并将其复制到渲染器的左上角。我们还将保持目标矩形的尺寸不变，因为我们希望它保持与源矩形相同。将两个矩形传递给`SDL_RenderCopy`函数：
- en: '[PRE11]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now when we build we will have the first frame of the animation.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们构建时，将得到动画的第一帧。
- en: '![Animating a sprite sheet](img/6821OT_02_11.jpg)'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![精灵图动画](img/6821OT_02_11.jpg)'
- en: Now that we have the first frame, we can move on to animating the sprite sheet.
    Each frame has the exact same dimensions. This is extremely important for this
    sheet to animate correctly. All we want to do is move the location of the source
    rectangle, not its dimensions.![Animating a sprite sheet](img/6821OT_02_12.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了第一帧，我们可以继续动画精灵图。每一帧都有完全相同的尺寸。这对于正确动画此图非常重要。我们只想移动源矩形的定位，而不是其尺寸。![动画精灵图](img/6821OT_02_12.jpg)
- en: Every time we want to move another frame, we simply move the location of the
    source rectangle and copy it to the renderer. To do this we will use our `update`
    function.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次我们想要移动另一帧时，我们只需移动源矩形的定位并将其复制到渲染器中。为此，我们将使用我们的`update`函数。
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we have used `SDL_GetTicks()` to find out the amount of milliseconds since
    SDL was initialized. We then divide this by the amount of time (in ms) we want
    between frames and then use the modulo operator to keep it in range of the amount
    of frames we have in our animation. This code will (every 100 milliseconds) shift
    the `x` value of our source rectangle by 128 pixels (the width of a frame), multiplied
    by the current frame we want, giving us the correct position. Build the project
    and you should see the animation displayed.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`SDL_GetTicks()`来找出自SDL初始化以来经过的毫秒数。然后我们将其除以我们希望在帧之间想要的时间（以毫秒为单位），然后使用取模运算符来保持它在我们的动画中帧的数量范围内。此代码（每100毫秒）将我们的源矩形的`x`值移动128像素（帧的宽度），乘以我们想要的当前帧，从而给出正确的位置。构建项目后，你应该会看到动画正在显示。
- en: Flipping images
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻转图像
- en: In most games, players, enemies, and so on, will move in more than one direction.
    To allow the sprite to face in the direction it is moving we will have to flip
    our sprite sheet. We could of course create a new row in our sprite sheet with
    the frames flipped, but this would use more memory, which we do not want. SDL
    2.0 has another render function that allows us to pass in the way we want our
    image to be flipped or rotated. The function we will use is `SDL_RenderCopyEx`.
    This function takes the same parameters as `SDL_RenderCopy` but also takes specific
    parameters for rotation and flipping. The fourth parameter is the angle we want
    the image to be displayed with parameter five being the center point we want for
    the rotation. The final parameter is an enumerated type called `SDL_RendererFlip`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数游戏中，玩家、敌人等等都会在多个方向上移动。为了使精灵面向移动的方向，我们必须翻转我们的精灵图。当然，我们可以在精灵图中创建一个新的行来包含翻转的帧，但这会使用更多的内存，而我们不想这样做。SDL
    2.0有一个允许我们传入我们想要图像如何翻转或旋转的渲染函数。我们将使用的函数是`SDL_RenderCopyEx`。此函数与`SDL_RenderCopy`具有相同的参数，但还包含特定于旋转和翻转的参数。第四个参数是我们想要图像显示的角度，第五个参数是我们想要旋转的中心点。最后一个参数是一个名为`SDL_RendererFlip`的枚举类型。
- en: 'The following table shows the available values for the `SDL_RendererFlip` enumerated
    type:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了`SDL_RendererFlip`枚举类型可用的值：
- en: '| SDL_RendererFlip value | Purpose |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| SDL_RendererFlip值 | 目的 |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SDL_FLIP_NONE` | No flipping |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_FLIP_NONE` | 不翻转 |'
- en: '| `SDL_FLIP_HORIZONTAL` | Flip the texture horizontally |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_FLIP_HORIZONTAL` | 水平翻转纹理 |'
- en: '| `SDL_FLIP_VERTICAL` | Flip the texture vertically |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_FLIP_VERTICAL` | 垂直翻转纹理 |'
- en: 'We can use this parameter to flip our image. Here is the revised render function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此参数来翻转我们的图像。以下是修改后的渲染函数：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Build the project and you will see that the image has been flipped and is now
    facing to the left. Our characters and enemies will also have frames specifically
    for animations such as attack and jump. These can be added to different rows of
    the sprite sheet and the source rectangle's `y` value is incremented accordingly.
    (We will cover this in more detail when we create our game objects.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目后，你会看到图像已经被翻转，现在面向左侧。我们的角色和敌人也将有专门用于动画的帧，例如攻击和跳跃。这些可以添加到精灵图的不同的行中，并且源矩形的`y`值相应增加。（我们将在创建游戏对象时更详细地介绍这一点。）
- en: Installing SDL_image
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装SDL_image
- en: 'So far we have only been loading BMP image files. This is all that SDL supports
    without any extensions. We can use `SDL_image` to enable us to load many different
    image file types such as BMP, GIF, JPEG, LBM, PCX, PNG, PNM, TGA, TIFF, WEBP,
    XCF, XPM, and XV. First we will need to clone the latest build of `SDL_image`
    to ensure it will work with SDL 2.0:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只加载了BMP图像文件。这是SDL在不使用任何扩展的情况下支持的所有内容。我们可以使用`SDL_image`来使我们能够加载许多不同的图像文件类型，如BMP、GIF、JPEG、LBM、PCX、PNG、PNM、TGA、TIFF、WEBP、XCF、XPM和XV。首先，我们需要克隆`SDL_image`的最新构建版本，以确保它与SDL
    2.0兼容：
- en: Open up the `TortoiseHg` workbench and use *Ctrl* + *Shift* + *N* to clone a
    new repository.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `TortoiseHg` 工作台，使用 *Ctrl* + *Shift* + *N* 克隆一个新的仓库。
- en: The repository for SDL_image is listed on [http://www.libsdl.org/projects/SDL_image/](http://www.libsdl.org/projects/SDL_image/)
    and [http://hg.libsdl.org/SDL_image/](http://hg.libsdl.org/SDL_image/). So let's
    go ahead and type that into the **Source** box.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SDL_image 的仓库列在 [http://www.libsdl.org/projects/SDL_image/](http://www.libsdl.org/projects/SDL_image/)
    和 [http://hg.libsdl.org/SDL_image/](http://hg.libsdl.org/SDL_image/) 上。所以让我们继续在
    **源** 框中输入这些内容。
- en: Our destination will be a new directory, `C:\SDL2_image`. After typing this
    into the **Destination** box, hit **clone** and wait for it to complete.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的目标将是一个新的目录，`C:\SDL2_image`。在 **目标** 框中输入此内容后，点击 **克隆** 并等待其完成。
- en: Once you have created this folder, navigate to our `C:\SDL2_image` cloned repository.
    Open up the `VisualC` folder and then open the `SDL_image_VS2010` VC++ project
    with Visual Studio 2010 express.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了此文件夹，导航到我们的 `C:\SDL2_image` 克隆仓库。打开 `VisualC` 文件夹，然后使用 Visual Studio 2010
    express 打开 `SDL_image_VS2010` VC++ 项目。
- en: Right-click on the `SDL2_image` project and then click on **Properties**. Here
    we have to include the `SDL.h` header file. Change the configuration to **All
    Configurations**, navigate to **VC++ Directories**, click on the **Include Directories**
    drop-down, and then on **<Edit…>**. Here we can put in our `C:\SDL2\include\`
    directory.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `SDL2_image` 项目，然后点击 **属性**。在这里，我们需要包含 `SDL.h` 头文件。将配置更改为 **所有配置**，导航到
    **VC++ 目录**，点击 **包含目录** 下拉菜单，然后点击 **<编辑…**>。在这里，我们可以输入我们的 `C:\SDL2\include\` 目录。
- en: Next move to **Library Directories** and add our `C:\SDL2\lib\` folder. Now
    navigate to **Linker** | **Input** | **Additional Dependencies** and add `SDL2.lib`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到 **库目录** 并添加我们的 `C:\SDL2\lib\` 文件夹。现在导航到 **链接器** | **输入** | **附加依赖项**，并添加
    `SDL2.lib`。
- en: Click on **OK** and we are almost ready to build. We are now using `SDL2.lib`,
    so we can remove the `SDL.lib` and the `SDLmain.lib` files from the `SDL_image`
    project. Locate the files in the solution explorer, right-click and then remove
    the files. Change the build configuration to **release** and then build.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **确定**，我们几乎准备好构建了。我们现在使用 `SDL2.lib`，所以我们可以从 `SDL_image` 项目中删除 `SDL.lib` 和
    `SDLmain.lib` 文件。在解决方案资源管理器中定位文件，右键单击然后删除文件。将构建配置更改为 **发布**，然后构建。
- en: An error about being unable to start the program may appear. Just click on **OK**
    and we can close the project and continue.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能会出现一个无法启动程序的错误。只需点击 **确定**，然后我们可以关闭项目并继续。
- en: There will now be a `Release` folder inside our `C:\SDL2_image\VisualC\` folder.
    Open it and copy the `SDL_image.dll` to our game's executable folder.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `C:\SDL2_image\VisualC\` 文件夹中会有一个 `Release` 文件夹。打开它，将 `SDL_image.dll` 复制到我们的游戏可执行文件文件夹中。
- en: Next copy the `SDL2_image.lib` file into our original `C:\SDL2\lib\` directory.
    Also copy the `SDL_image` header from `C:\SDL2_image\` to the `C:\SDL2\include\`
    directory.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `SDL2_image.lib` 文件复制到我们原始的 `C:\SDL2\lib\` 目录中。也将 `SDL_image` 头文件从 `C:\SDL2_image\`
    复制到 `C:\SDL2\include\` 目录中。
- en: We just have a few more libraries to get and we are done. Download the `SDL_image-1.2.12-win32.zip`
    file (or the x64 if you are targeting a 64 bit platform) from [http://www.libsdl.org/projects/SDL_image/](http://www.libsdl.org/projects/SDL_image/).
    Extract all and then copy all of the `.dll` files apart from `SDL_image.dll` into
    our game's executable folder.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要再获取几个库，然后就可以完成了。从 [http://www.libsdl.org/projects/SDL_image/](http://www.libsdl.org/projects/SDL_image/)
    下载 `SDL_image-1.2.12-win32.zip` 文件（或者如果你是针对 64 位平台，则下载 x64）。解压所有内容，然后将所有 `.dll`
    文件（除了 `SDL_image.dll`）复制到我们的游戏可执行文件文件夹中。
- en: Open up our game project and go into its properties. Navigate to **Linker**
    | **Input** | **Additional Dependencies** and add `SDL2_image.lib`.![Installing
    SDL_image](img/6821OT_02_14.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们的游戏项目，进入其属性。导航到 **链接器** | **输入** | **附加依赖项**，并添加 `SDL2_image.lib`。[安装 SDL_image](img/6821OT_02_14.jpg)
- en: We have now installed `SDL_image` and can start to load all kinds of different
    image files. Copy the `animate.png` and `animate-alpha.png` images from the source
    downloads to our games assets folder and we can start loading PNG files.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经安装了 `SDL_image`，可以开始加载各种不同的图像文件了。将 `animate.png` 和 `animate-alpha.png`
    图像从源下载复制到我们的游戏资源文件夹中，然后我们可以开始加载 PNG 文件。
- en: Using SDL_image
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SDL_image
- en: So we have the library installed, now how do we use it? It is simple to use
    SDL_image in place of the regular SDL image loading. In our case we only need
    to replace one function and also add `#include <SDL_image.h>`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经安装了库，现在该如何使用它呢？使用 SDL_image 替代常规的 SDL 图像加载很简单。在我们的例子中，我们只需要替换一个函数，并添加
    `#include <SDL_image.h>`。
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code will be changed as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将按如下方式更改：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are now loading a `.png` image. PNG files are great to work with, they have
    a small file size and support an alpha channel. Let's perform a test. Change our
    renderer clear color to red.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在加载 `.png` 图像。PNG 文件非常适合使用，它们具有较小的文件大小并支持 alpha 通道。让我们进行一次测试。将我们的渲染器清除颜色更改为红色。
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will see that we still have our black background from the image we are using;
    this is definitely not ideal for our purposes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我们仍然在使用图像时的黑色背景；这绝对不是我们目的的理想选择。
- en: '![Using SDL_image](img/6821OT_02_15.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![使用 SDL_image](img/6821OT_02_15.jpg)'
- en: When using PNG files, we can resolve this by using an alpha channel. We remove
    the background from the image and then when we load it, SDL will not draw anything
    from the alpha channel.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 PNG 文件时，我们可以通过使用 alpha 通道来解决这个问题。我们移除图像的背景，然后在加载时，SDL 不会从 alpha 通道绘制任何内容。
- en: '![Using SDL_image](img/6821OT_02_16.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用 SDL_image](img/6821OT_02_16.jpg)'
- en: 'Let''s load this image and see how it looks:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载此图像并看看它的样子：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is exactly what we want:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的：
- en: '![Using SDL_image](img/6821OT_02_17.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![使用 SDL_image](img/6821OT_02_17.jpg)'
- en: Tying it into the framework
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将其整合到框架中
- en: We have covered a lot on the subject of drawing images with SDL but we have
    yet to tie everything together into our framework so that it becomes reusable
    throughout our game. What we will now cover is creating a texture manager class
    that will have all of the functions we need to easily load and draw textures.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对使用 SDL 绘制图像的主题进行了很多介绍，但我们还没有将所有内容整合到我们的框架中，以便在整个游戏中重用。我们现在要介绍的是创建一个纹理管理器类，它将包含我们轻松加载和绘制纹理所需的所有函数。
- en: Creating the texture manager
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建纹理管理器
- en: 'The texture manager will have functions that allow us to load and create an
    `SDL_Texture` structure from an image file, draw the texture (either static or
    animated), and also hold a list of `SDL_Texture*`, so that we can use them whenever
    we need to. Let''s go ahead and create the `TextureManager.h` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理管理器将具有允许我们从图像文件加载和创建 `SDL_Texture` 结构的函数，绘制纹理（静态或动画），并保持 `SDL_Texture*` 的列表，这样我们就可以在需要时使用它们。让我们继续创建
    `TextureManager.h` 文件：
- en: First we declare our `load` function. As parameters, the function takes the
    filename of the image we want to use, the ID we want to use to refer to the texture,
    and the renderer we want to use.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们声明我们的 `load` 函数。作为参数，该函数接受我们想要使用的图像文件名、我们想要使用的用于引用纹理的 ID，以及我们想要使用的渲染器。
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will create two draw functions, `draw` and `drawFrame`. They will both take
    the ID of the texture we want to draw, the `x` and `y` position we want to draw
    to, the height and width of the frame or the image we are using, the renderer
    we will copy to, and an `SDL_RendererFlip` value to describe how we want the image
    to be displayed (default is `SDL_FLIP_NONE`). The `drawFrame` function will take
    two additional parameters, the current frame we want to draw and which row it
    is on in the sprite sheet.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建两个绘制函数，`draw` 和 `drawFrame`。它们都将接受我们想要绘制的纹理的 ID、我们想要绘制的 `x` 和 `y` 位置、框架或我们使用的图像的高度和宽度、我们将复制的渲染器，以及一个
    `SDL_RendererFlip` 值来描述我们想要如何显示图像（默认为 `SDL_FLIP_NONE`）。`drawFrame` 函数将接受两个额外的参数，即我们想要绘制的当前帧和它在精灵图中的行。
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `TextureManager` class will also contain `std::map` of pointers to the `SDL_Texture`
    objects, keyed using `std::strings`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TextureManager` 类还将包含指向 `SDL_Texture` 对象的指针的 `std::map`，使用 `std::strings`
    作为键。'
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We now must define these functions in a `TextureManager.cpp` file. Let's start
    with the `load` function. We will take the code from our previous texture loading
    and use it within this `load` method.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在必须在 `TextureManager.cpp` 文件中定义这些函数。让我们从 `load` 函数开始。我们将从之前的纹理加载代码中提取代码，并在
    `load` 方法中使用它。
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we call this function we will then have `SDL_Texture` that can be used
    by accessing it from the map using its ID; we will use this in our `draw` functions.
    The `draw` function can be defined as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们调用此函数时，我们将拥有可以使用的 `SDL_Texture`，我们可以通过使用其 ID 从映射中访问它；我们将在我们的 `draw` 函数中使用它。`draw`
    函数可以定义如下：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We again use `SDL_RenderCopyEx` using the passed in ID variable to get the
    `SDL_Texture` object we want to draw. We also build our source and destination
    variables using the passed in `x`, `y`, `width`, and `height` values. Now we can
    move onto `drawFrame`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次使用 `SDL_RenderCopyEx`，通过传入的 ID 变量获取我们想要绘制的 `SDL_Texture` 对象。我们还使用传入的 `x`、`y`、`width`
    和 `height` 值构建我们的源和目标变量。现在我们可以继续到 `drawFrame`：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this function, we create a source rectangle to use the appropriate frame
    of the animation using the `currentFrame` and `currentRow` variables. The source
    rectangle's `x` position for the current frame is the width of the source rectangle
    multiplied by the `currentFrame` value (covered in the *Animating a sprite sheet*
    section). Its `y` value is the height of the rectangle multiplied by `currentRow
    – 1` (it sounds more natural to use the first row, rather than the zeroth row).
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个函数中，我们创建一个源矩形来使用动画的适当帧，使用 `currentFrame` 和 `currentRow` 变量。当前帧的源矩形 `x` 位置是源矩形宽度乘以
    `currentFrame` 值（在 *动画精灵表* 部分中介绍过）。它的 `y` 值是矩形高度乘以 `currentRow – 1`（使用第一行而不是零行听起来更自然）。
- en: We now have everything we need to easily load and draw textures throughout our
    game. Let's go ahead and test it out using the `animated.png` image. Open up `Game.h`.
    We will not need our texture member variables or the rectangles anymore, so delete
    any of the code dealing with them from the `Game.h` and `Game.cpp` files. We will
    however create two new member variables.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了在游戏中轻松加载和绘制纹理所需的一切。让我们继续测试它，使用 `animated.png` 图像。打开 `Game.h` 文件。我们不再需要纹理成员变量或矩形，所以请从
    `Game.h` 和 `Game.cpp` 文件中删除任何处理它们的代码。然而，我们将创建两个新的成员变量。
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will use the `m_currentFrame` variable to allow us to animate our sprite
    sheet and we also need an instance of our new `TextureManager` class (ensure you
    include `TextureManager.h`). We can now load a texture in the game's `init` function.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `m_currentFrame` 变量来允许我们动画化精灵表，并且我们还需要一个我们新的 `TextureManager` 类的实例（确保你包含了
    `TextureManager.h`）。我们可以在游戏的 `init` 函数中加载纹理。
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have given this texture an ID of `"animate"` which we can use in our `draw`
    functions. We will start by drawing a static image at 0,0 and an animated image
    at 100,100\. Here is the render function:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经给这个纹理分配了一个名为 `"animate"` 的ID，我们可以在我们的 `draw` 函数中使用它。我们将首先在 0,0 位置绘制一个静态图像，并在
    100,100 位置绘制一个动画图像。以下是渲染函数：
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The drawFrame function uses our `m_currentFrame` member variable. We can increment
    this in the `update` function like we did before, but we now do the calculation
    of the source rectangle inside the `draw` function.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`drawFrame` 函数使用我们的 `m_currentFrame` 成员变量。我们可以在 `update` 函数中增加这个值，就像我们之前做的那样，但现在我们在
    `draw` 函数内部进行源矩形的计算。'
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we can build and see our hard work in action.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们可以构建并看到我们的辛勤工作付诸实践了。
- en: '![Creating the texture manager](img/6821OT_02_18.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![创建纹理管理器](img/6821OT_02_18.jpg)'
- en: Using texture manager as a singleton
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纹理管理器作为单例
- en: Now that we have our texture manager in place we still have one problem. We
    want to reuse this `TextureManager` throughout our game so we don't want it to
    be a member of our `Game` class because then we would have to pass it into our
    draw function. A good option for us is to implement `TextureManager` as a singleton.
    A singleton is a class that can only have one instance. This works for us, as
    we want to reuse the same `TextureManager` throughout our game. We can make our
    `TextureManager` a singleton by first making its constructor private.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了纹理管理器，但我们仍然有一个问题。我们希望在整个游戏中重用这个 `TextureManager`，因此我们不希望它是 `Game` 类的成员，因为那样我们就必须将它传递给我们的绘制函数。对我们来说，将
    `TextureManager` 实现为单例是一个好选择。单例是一个只能有一个实例的类。这对我们来说很适用，因为我们希望在游戏中重用相同的 `TextureManager`。我们可以通过首先将构造函数设为私有来使我们的
    `TextureManager` 成为单例。
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is to ensure that it cannot be created like other objects. It can only
    be created and accessed using the `Instance` function, which we will declare and
    define.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了确保它不能像其他对象那样被创建。它只能通过使用 `Instance` 函数来创建和访问，我们将声明和定义它。
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function checks whether we already have an instance of our `TextureManager`.
    If not, then it constructs it, otherwise it simply returns the static instance.
    We will also `typedef` the `TextureManager`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数检查我们是否已经有了 `TextureManager` 的实例。如果没有，则构建它，否则简单地返回静态实例。我们还将 `typedef` `TextureManager`。
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We must also define the static instance in `TextureManager.cpp`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在 `TextureManager.cpp` 中定义静态实例。
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now use our `TextureManager` as a singleton. We no longer have to have
    an instance of `TextureManager` in our `Game` class, we just include the header
    and use it as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将我们的 `TextureManager` 作为单例使用。我们不再需要在 `Game` 类中有一个 `TextureManager` 的实例，我们只需包含头文件并按以下方式使用它：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When we load a texture in our `Game` (or any other) class we can then access
    it throughout our code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `Game`（或任何其他）类中加载纹理时，我们可以在整个代码中访问它。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has been all about rendering images onto the screen. We have covered
    source and destination rectangles and animating a sprite sheet. We took what we
    learned and applied it to creating a reusable texture manager class, enabling
    us to easily load and draw images throughout our game. In the next chapter, we
    will cover using inheritance and polymorphism to create a base game object class
    and use it within our game framework.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲述了将图像渲染到屏幕上的过程。我们涵盖了源矩形和目标矩形以及精灵表的动画处理。我们将所学知识应用于创建一个可重用的纹理管理器类，使我们能够轻松地在整个游戏中加载和绘制图像。在下一章中，我们将介绍如何使用继承和多态来创建一个基础游戏对象类，并在我们的游戏框架中使用它。
