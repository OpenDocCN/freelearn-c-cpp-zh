- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There Are No Libraries For Modern Programming in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Or maybe there are too many and they are not* *easily available?*'
  prefs: []
  type: TYPE_NORMAL
- en: C++ is the oldest language used in modern software development. Despite many
    attempts to replace it, it stayed up in both preference and usefulness. However,
    this legacy comes with its own challenges. The development style has evolved over
    time to include constructs that are easier to understand by developers, that solve
    problems with less code, or that sometimes just look nicer.
  prefs: []
  type: TYPE_NORMAL
- en: A big part of the ecosystem of any technology is the list of libraries available
    to it, including and complementing the standard library. Since C++ has been around
    for a long time, it has libraries. However, how do they compare with the experience
    of developers using other technologies? Do they match the needs and expectations
    of a modern developer, who is perhaps looking at the alternative solutions available
    in the marketplace of ideas?
  prefs: []
  type: TYPE_NORMAL
- en: These are a few of the questions we will examine next.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern developer experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supply chain security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we tell?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When pondering a question such as the title of this chapter, we are faced with
    the big challenge of selection. The choice of libraries for any project is completely
    contextual, and it fully depends on what the project is trying to solve. Of course,
    there are some features that are needed no matter what the project does, such
    as logging or unit testing, but what should we pick beyond these?
  prefs: []
  type: TYPE_NORMAL
- en: After all, it seems deeply unfair to compare web development in C++ with web
    development in Java, as it is to compare systems programming in C++ with systems
    programming in Java. Neither is C++ used for web development extensively, nor
    is Java for systems programming. In fact, C++ has had its own niche for a long
    time, and while it has been slowly eroded by Java, C#, Rust, and Python, it still
    holds the fort for use cases such as game development, firmware, high-frequency
    trading, engineering applications, automotive, systems programming, and probably
    others. The other languages have little traction in these domains, for very good
    reasons related to C++’s flexibility, performance, and control.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is the sheer number of libraries that exist for the aforementioned
    languages, particularly C++. An advantage of the venerable C++ is that programmers
    have had time to develop behemoth libraries such as Boost, which has no equal
    in the worlds of Java or C# (excluding the standard libraries), and absolutely
    no contender in the world of Python. We could argue that JavaScript has something
    similar to React and its surrounding ecosystem. However, in terms of the volume
    of available libraries, C++ looks dominant.
  prefs: []
  type: TYPE_NORMAL
- en: 'These observations leave us with one characteristic that we need to account
    for: how modern is the set of libraries? What would we want from a modern programming
    language and its ecosystem? Where does C++ stand from this perspective? Let’s
    examine these questions.'
  prefs: []
  type: TYPE_NORMAL
- en: A modern developer’s experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s step, for a moment, outside the C++ world and turn into a fly on the wall
    that looks at the experience of a developer using another technology. We will
    be with them as they are starting a new project, and later when they add new people
    to the team. The likely first step is that they will launch an IDE and create
    a new project or a project structure. The IDE is likely to be from Microsoft,
    such as Visual Studio .NET or Visual Studio Code, or from JetBrains, such as IntelliJ
    IDEA for Java, PyCharm for Python, or Rider for C#/.NET. A small set of strange
    programmers, such as myself, will use the command line and neovim. Even stranger
    programmers will use Emacs. I kid, of course; we all know that real programmers
    use changes in atmospheric electricity to manipulate the bits directly, as shown
    by a famous xkcd comic called *Real Programmers* ( [https://xkcd.com/378/](https://xkcd.com/378/)
    ). However, let’s go back to our story.
  prefs: []
  type: TYPE_NORMAL
- en: Upon creating a new project, the IDE will suggest a few integrations and libraries
    to install. Once created, the project is ready to run, although it won’t do a
    lot of useful things. During the creation, a source control repository will be
    selected, likely an existing one based on git. The project can then be committed
    locally and pushed to the shared repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these steps, any member of the team will have a few things to do: fire
    up the IDE, clone the repository locally, and let the IDE do its thing to get
    the necessary dependencies, as specified in the project configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s likely that, at this point, the project will already include a logging
    and unit testing library. Let’s pause for a moment to examine the libraries used.
  prefs: []
  type: TYPE_NORMAL
- en: Python has logging in its standard library, while Java has the open source Log4J
    and .NET uses either the Microsoft-built Microsoft.Extensions.Logging or the open
    source Log4Net. For unit testing, Python offers a standard implementation for
    both unit testing and mocking, but programmers tend to prefer open-source extensions
    such as pytest ( [https://docs.pytest.org/en/stable/](https://docs.pytest.org/en/stable/)
    ). Java requires a unit testing library, usually JUnit or TestNG, and a mocking
    library, usually Mockito or JMock. Finally, .NET provides a standard framework
    for testing but knowledgeable tech leads will most likely select NUnit or xUnit
    instead, along with Moq.
  prefs: []
  type: TYPE_NORMAL
- en: Where does C++ stand here? Well, there’s no shortage of logging libraries in
    C++, which shouldn’t be a surprise since logging systems have matured at the same
    time as C++. We can say that logging libraries are quasi-standardized, having
    very similar behavior and features with small variations in the API. It’s almost
    too difficult to choose a logging library for C++ unless you are using a technology
    that already comes with logging. I imagine that many projects use Boost and the
    logging that comes with it. A quick glance at GitHub shows that the **spdlog**
    library ( [https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)
    ) has 24k stars, although it only supports C++ 11.
  prefs: []
  type: TYPE_NORMAL
- en: What about unit testing? This is an interesting topic. Unit testing libraries
    exist for C++ in many forms. There’s GTest and GMock, the two libraries started
    by Google, with the usual feature set. Similarly, CppTest follows the standard
    xUnit structure for unit tests. Then there’s **doctest** ( [https://github.com/doctest/doctest](https://github.com/doctest/doctest)
    ), a single header library with no dependencies, which is why I prefer it for
    examples and the code accompanying this book. Finally, it’s worth mentioning **Cpputest**
    ( [http://cpputest.github.io](http://cpputest.github.io) ) because it allows embedded
    development, due to its small footprint and its features for identifying memory
    management problems. For mocking, **FakeIt** ( [https://github.com/eranpeer/FakeIt](https://github.com/eranpeer/FakeIt)
    ) is another single header framework that is very easy to integrate.
  prefs: []
  type: TYPE_NORMAL
- en: All these libraries would likely be set up through a package manager that stores
    the list of dependencies in a text file that’s either plain text, a markup format,
    or a script. This file gets pushed to the central repository and can be used to
    recreate the dependencies, including the dependencies required by the installed
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, during the development, the team needs an additional library, they can
    simply add it to the dependencies. This process is a bit more restricted for enterprise
    environments due to security concerns: perhaps a pre-approved list of packages
    is available and provided from an internal source, perhaps each package requires
    approval, or perhaps only specific people can add a dependency.'
  prefs: []
  type: TYPE_NORMAL
- en: Either way, when a new developer comes in, they will clone the central repository
    and run the installation commands, usually by just loading the project in the
    IDE and letting it do its thing, and everything should work fine. That’s the end
    of our fly story.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive into more details about what happens behind the scenes if you use
    a package manager. Since I often use the command line in combination with neovim
    to program in Ubuntu Linux, I know a little bit more about the process in each
    of these technologies. For Python, a virtual environment is recommended so that
    the OS is not polluted with all the libraries required. A tool called **pipenv**
    combines the **pip** package manager and the **venv** virtual environment, both
    provided by the standard library, to allow for easy setup. The command line steps
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new environment, you can simply run the following to install all the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Java and .NET have similar workflows, minus the virtual environment. They both
    use open source package managers; for Java, Maven or Gradle are used, and for
    .NET, it’s NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all these three technologies, a central place for all the libraries exists:
    Pypi ( [https://pypi.org/](https://pypi.org/) ) for Python, Maven Central ( [https://mvnrepository.com/repos/central](https://www.mvnrepository.com/repos/central)
    ) for Maven and the NuGet site ( [https://www.nuget.org/](https://www.nuget.org/)
    ) for NuGet. As mentioned earlier, it’s likely that large companies will pay more
    attention to the libraries used, and require more thorough security checks before
    using third-party code in their systems. These companies tend to provide their
    own repositories, for example, using Artifactory in Java ( [https://jfrog.com/artifactory/](https://jfrog.com/artifactory/)
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore very easy to search for libraries, update them, and install
    them in a new environment, with de facto standard tools available to any developer
    using that technology.
  prefs: []
  type: TYPE_NORMAL
- en: C++ has gone a long way since I was a junior C++ programmer in the 2000s. Back
    then, adding a new library required either downloading the binaries for the required
    targets or, more likely, compiling it yourself, which posed its own set of challenges.
    Nowadays, C++ is closing the gap through Conan and vcpkg, and it’s likely that
    many programmers have a similar experience in C++ to the one I’ve described above
    for Java, Python, and .NET. Programmers in large companies are most likely to
    recognize it, since the organization provides a Conan or vspkg repository with
    approved libraries that can be found and installed easily. Adding a new library
    to the whitelist can be a bit of a pain and can take a long time, but that’s understandable.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not as easy without that piece of infrastructure. The libraries are not
    available in a single location, and the tools don’t seem to work as well. At least
    this was my experience: Conan gave me a bunch of errors when I tried to use it
    on a simple project and I had no idea how to fix them. While I dislike Maven because
    it inexplicably downloads a lot of packages even for the simplest of setups, it
    works consistently and reliably, which is what we need from package managers.
    So, I’m afraid I will have to say this: while there are attempts to bring C++
    package management on par with other technologies, it doesn’t feel mature yet.'
  prefs: []
  type: TYPE_NORMAL
- en: With this being said, I’m sure many developers working in large companies won’t
    feel any of these issues. So, we’ll assume that the package manager works fine.
    What will we do next? Depending on the project and the technology, we will need
    more libraries to help us. Let’s look next at a few categories.
  prefs: []
  type: TYPE_NORMAL
- en: Common needs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some needs that many developers have, in no particular order:'
  prefs: []
  type: TYPE_NORMAL
- en: Database connection, reading, and writing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSV file processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression, for example, **gzip**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date/time enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Various computations, for example: matrices, imaginary numbers, math equation
    solving, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI, for desktop and mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDF processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email sending
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration file read and write: **ini** , **yaml** , and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s safe to say that there are C++ libraries for all of these. Let’s pick
    just a few random ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**zlib** for **zip** and **gzip** compression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rapidcsv ( [https://github.com/d99kris/rapidcsv](https://github.com/d99kris/rapidcsv)
    ) for CSV processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For database access, an ORM such as TinyORM ( [https://www.tinyorm.org/](https://www.tinyorm.org/)
    ) or SQLPP1 ( [https://github.com/rbock/sqlpp11](https://github.com/rbock/sqlpp11)
    ) for type-safe DSL queries and results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poco libraries ( [https://pocoproject.org/](https://pocoproject.org/) ) contain
    a lot of utilities for networking, sending emails, database access, JSON, OpenSSL,
    and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI libraries include Qt, GTK, wxWidgets, or Dear ImGui
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP clients are implemented in Boost, Curl++, or cpp-netlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement a web application, Crow ( [https://crowcpp.org/master/](https://crowcpp.org/master/)
    ) is inspired by Python’s Flask, while Oat++ ( [https://oatpp.io/](https://oatpp.io/)
    ) and Drogon ( [https://drogon.org/](https://drogon.org/) ) offer fast solutions
    for web APIs and microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could go on, but I think we’ve made our point: *C++ has libraries* . It
    has *a lot of libraries* . Some of them have inspired the implementations of other
    technologies, while others took inspiration from the best solutions used by the
    alternatives. The advantages of the C++ implementations are obvious in terms of
    speed and low memory footprint. Some of these libraries pack many features into
    a few hundred kBs. It’s also impressive how many header-only implementations exist,
    allowing for portability and simplicity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ also has frameworks. We already mentioned a few and we can add others:
    GTK, QT, Boost, POCO, WxWidgets, and Unreal Engine, for example. Lists of libraries
    and frameworks are maintained on the internet, the best one I’ve found being **awesome-cpp**
    ( [https://github.com/fffaraz/awesome-cpp](https://github.com/fffaraz/awesome-cpp)
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even niche programming styles and practices have their libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable collections? Use Immer ( [https://github.com/arximboldi/immer](https://github.com/arximboldi/immer)
    ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Programming? Use RxCpp ( [https://github.com/ReactiveX/RxCpp](https://github.com/ReactiveX/RxCpp)
    ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices? Sure, CppMicroServices ( [https://github.com/CppMicroServices/CppMicroServices](https://github.com/CppMicroServices/CppMicroServices)
    ) can help (no, microservices are not niche, but they’re rarely implemented in
    C++).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Assembly? Yes, there’s Emscripten ( [https://github.com/emscripten-core/emscripten](https://github.com/emscripten-core/emscripten)
    ) is a good choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless? There’s **aws-lambda-cpp** ( [https://github.com/awslabs/aws-lambda-cpp](https://github.com/awslabs/aws-lambda-cpp)
    ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I think it’s obvious by now that we’d be hard-pressed to find any domain in
    which C++ lacks a library or framework. However, can we use them?
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume that you find a very promising library and decide to add it to
    your project. Does it work? How *well* will it work?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s where the fragmentation of C++ shows its ugly side. The chance of any
    of the following undesirable things to happen is non-zero:'
  prefs: []
  type: TYPE_NORMAL
- en: The library uses a newer C++ version than your code and you can’t compile it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library uses an older C++ version than your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get a lot of warnings for different reasons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library compiles well with your version of C++, but its interface uses older
    constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library doesn’t work on all platforms your project targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library is incompatible with your compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library is incompatible with your compilation process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library is compatible with all platforms your project targets, but it has
    different behavior or performance issues or bugs on specific platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I hope you never encounter any of the preceding problems. Also, it’s worth
    saying that you’d be much less likely to have them in the technologies we use
    as a comparison: Python, Java, and .NET have none of these issues. Well, almost
    none; it’s possible, for example, to create Python programs that use C++ modules
    and face the same issues. Or you could create a Java program that uses OS primitives
    and has different issues on different OSs. In general, though, there’s a continuous
    effort for consistency in these worlds.'
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, mature C++ frameworks and libraries such as Boost or **zlib** made
    the same effort and provided consistent behavior. It’s just easier to create consistent
    libraries in languages that use virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that your library works fine: no warnings, no weird issues, and it
    plays well with your code and toolkit. There’s one last question: can we trust
    it?'
  prefs: []
  type: TYPE_NORMAL
- en: Supply chain security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be obvious to anyone paying attention that software has always had
    a security problem. This problem is getting worse since software usage continues
    to increase and cover more and more areas of our daily lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two parts to improving security: the cybersecurity experts, who can
    find vulnerabilities and build protection tools, and the software developers,
    who need to find security issues before release and manage the accompanying risks.
    We know there’s no perfectly secure software, but we also know that things can
    get much better.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A specific area of this increased protection is managing the potential vulnerabilities
    that come with the libraries we use. There are two situations: either vulnerabilities
    were introduced unknowingly, or they were injected on purpose by a malicious actor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In all fairness, this can happen to any technology, and many of the high-profile
    C++ libraries are reviewed for security by large companies that use them. Moreover,
    if you’re working in a large company, you have teams dealing with all these concerns.
    However, not all development is done in large companies, and not all libraries
    are treated the same, as we’ll see with the **xz backdoor case** . Let’s discuss
    the second case for a moment. A malicious actor can inject vulnerabilities in
    several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: They can do this through a contribution to the code of an open source project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can also fork an open source project and add vulnerabilities among useful
    features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can also sometimes get away with becoming the maintainer of an open source
    project and then injecting vulnerabilities among useful features. See the story
    of the xz backdoor, which I commented on at length, at [https://mozaicworks.com/blog/xz-backdoor-and-other-news](https://mozaicworks.com/blog/xz-backdoor-and-other-news)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can also replace the binary with a vulnerable version, for example, by
    offering it on another website than the original or managing to hijack the publishing
    process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may also attempt hijacking the download, for example, through a DNS attack.
    Imagine a potential attacker managing to modify your local host’s file to point
    the URL of your repository to another IP address on the internet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the items in the preceding list are serious problems. In large companies,
    the security departments and IT/Ops tend to worry about them, but in smaller companies,
    it’s likely that you’ll need to pay extra attention. The solution we know is to
    validate all binaries with their digital signature or hash. While the package
    managers for programming languages and Linux do this automatically, manually downloading
    a binary from GitHub requires manual validation of the signature, hopefully provided
    along with the library file.
  prefs: []
  type: TYPE_NORMAL
- en: The first situation is even more complicated. How do you know whether a library
    has vulnerabilities? For open source code, the general belief is that many eyes
    look at the code and find all issues. However, that’s very dependent on the number
    of contributors and their expertise.
  prefs: []
  type: TYPE_NORMAL
- en: The xz backdoor case mentioned is chilling, especially since the issue was found
    by a developer, Andres Freund, who got suspicious by the fact that **sshd** was
    using too much CPU during a micro-benchmark ( [https://mastodon.social/@AndresFreundTec/112180406142695845](https://mastodon.social/@AndresFreundTec/112180406142695845)
    ). This made the issue of overworked maintainers for open source libraries visible,
    only for it to return to obscurity soon after.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that most open source libraries are not attacked by a malicious
    actor who gains maintainer status. It’s still possible for vulnerabilities to
    escape, and more so in C++ since it has its own challenges in terms of security.
    A small team will need to stay informed of the reported vulnerabilities for the
    libraries they use, or license security tools that automatically do it for them.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that everything works fine, it’s still best to store the list of libraries
    used in an application, so that the ops people know to periodically check for
    vulnerabilities in all the libraries used. The recommended practice in this area
    is to create what’s called the **Software Bill of Materials** ( **SBOM** ) for
    your product. An SBOM contains the list of all the libraries and their dependencies.
    Specific tools are available to create the SBOM and to scan for vulnerabilities
    based on them; however, most of them work with docker containers. For example,
    consider Grype ( [https://github.com/anchore/grype](https://github.com/anchore/grype)
    and its companion tool Syft [https://github.com/anchore/syft](https://github.com/anchore/syft)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to the conclusion of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen in this chapter that C++ has a lot of libraries and frameworks
    that cover everything we might need. Compared to other technologies, the process
    of obtaining them is not as simple. They are not as easily discoverable since
    they are not in a central place, and they might bring additional issues such as
    incompatibility with the compiler or older code styles. We learned this in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, like other technologies, the C++ libraries are prone to having vulnerabilities
    and are exposed to supply chain attacks. To protect against them, teams need to
    stay up to date with the stream of vulnerabilities discovered and authenticate
    the binaries upon download. Additional audits and scans are always useful, as
    we learned in this chapter. Thus, larger organizations have a security advantage
    since they have dedicated teams looking at these issues, at the cost of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: So, are there libraries for modern programming in C++? Yes, definitely. They
    are just harder to find and less compatible than in other widely used technologies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at whether C++ is backward compatible... with
    itself and beyond.
  prefs: []
  type: TYPE_NORMAL
