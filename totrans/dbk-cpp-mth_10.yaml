- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There Are No Libraries For Modern Programming in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Or maybe there are too many and they are not* *easily available?*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: C++ is the oldest language used in modern software development. Despite many
    attempts to replace it, it stayed up in both preference and usefulness. However,
    this legacy comes with its own challenges. The development style has evolved over
    time to include constructs that are easier to understand by developers, that solve
    problems with less code, or that sometimes just look nicer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: A big part of the ecosystem of any technology is the list of libraries available
    to it, including and complementing the standard library. Since C++ has been around
    for a long time, it has libraries. However, how do they compare with the experience
    of developers using other technologies? Do they match the needs and expectations
    of a modern developer, who is perhaps looking at the alternative solutions available
    in the marketplace of ideas?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: These are a few of the questions we will examine next.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: A modern developer experience
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common needs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supply chain security
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we tell?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When pondering a question such as the title of this chapter, we are faced with
    the big challenge of selection. The choice of libraries for any project is completely
    contextual, and it fully depends on what the project is trying to solve. Of course,
    there are some features that are needed no matter what the project does, such
    as logging or unit testing, but what should we pick beyond these?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: After all, it seems deeply unfair to compare web development in C++ with web
    development in Java, as it is to compare systems programming in C++ with systems
    programming in Java. Neither is C++ used for web development extensively, nor
    is Java for systems programming. In fact, C++ has had its own niche for a long
    time, and while it has been slowly eroded by Java, C#, Rust, and Python, it still
    holds the fort for use cases such as game development, firmware, high-frequency
    trading, engineering applications, automotive, systems programming, and probably
    others. The other languages have little traction in these domains, for very good
    reasons related to C++’s flexibility, performance, and control.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is the sheer number of libraries that exist for the aforementioned
    languages, particularly C++. An advantage of the venerable C++ is that programmers
    have had time to develop behemoth libraries such as Boost, which has no equal
    in the worlds of Java or C# (excluding the standard libraries), and absolutely
    no contender in the world of Python. We could argue that JavaScript has something
    similar to React and its surrounding ecosystem. However, in terms of the volume
    of available libraries, C++ looks dominant.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'These observations leave us with one characteristic that we need to account
    for: how modern is the set of libraries? What would we want from a modern programming
    language and its ecosystem? Where does C++ stand from this perspective? Let’s
    examine these questions.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些观察让我们意识到一个需要考虑的特征：这些库集合有多现代？我们希望从一门现代编程语言及其生态系统中得到什么？从这一角度来看，C++处于什么位置？让我们来探讨这些问题。
- en: A modern developer’s experience
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代开发者的体验
- en: Let’s step, for a moment, outside the C++ world and turn into a fly on the wall
    that looks at the experience of a developer using another technology. We will
    be with them as they are starting a new project, and later when they add new people
    to the team. The likely first step is that they will launch an IDE and create
    a new project or a project structure. The IDE is likely to be from Microsoft,
    such as Visual Studio .NET or Visual Studio Code, or from JetBrains, such as IntelliJ
    IDEA for Java, PyCharm for Python, or Rider for C#/.NET. A small set of strange
    programmers, such as myself, will use the command line and neovim. Even stranger
    programmers will use Emacs. I kid, of course; we all know that real programmers
    use changes in atmospheric electricity to manipulate the bits directly, as shown
    by a famous xkcd comic called *Real Programmers* ( [https://xkcd.com/378/](https://xkcd.com/378/)
    ). However, let’s go back to our story.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时跳出C++的世界，变成一个观察其他技术使用者的“旁观者”。我们将陪伴他们从开始一个新项目，到后来向团队添加新成员。可能的第一步是他们将启动一个IDE，创建一个新项目或项目结构。IDE可能是来自微软的，如Visual
    Studio .NET或Visual Studio Code，或者是来自JetBrains的，如Java的IntelliJ IDEA，Python的PyCharm，或C#/.NET的Rider。一小部分像我这样的奇怪程序员会使用命令行和neovim。更奇怪的程序员甚至会使用Emacs。我当然是在开玩笑；我们都知道真正的程序员会利用大气电的变化来直接操纵位，正如著名的xkcd漫画《真正的程序员》（[https://xkcd.com/378/](https://xkcd.com/378/)）所展示的那样。然而，让我们回到我们的故事。
- en: Upon creating a new project, the IDE will suggest a few integrations and libraries
    to install. Once created, the project is ready to run, although it won’t do a
    lot of useful things. During the creation, a source control repository will be
    selected, likely an existing one based on git. The project can then be committed
    locally and pushed to the shared repository.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新项目时，IDE会建议安装一些集成和库。一旦创建，项目就可以运行，尽管它不会做很多有用的事情。在创建过程中，将选择一个源代码控制仓库，很可能是基于git的现有仓库。然后可以在本地提交项目并将其推送到共享仓库。
- en: 'After these steps, any member of the team will have a few things to do: fire
    up the IDE, clone the repository locally, and let the IDE do its thing to get
    the necessary dependencies, as specified in the project configuration.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些步骤之后，团队成员将有一些事情要做：启动IDE，在本地克隆仓库，并让IDE按照项目配置获取必要的依赖项。
- en: It’s likely that, at this point, the project will already include a logging
    and unit testing library. Let’s pause for a moment to examine the libraries used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，项目可能已经包含了日志记录和单元测试库。让我们暂停一下，来检查所使用的库。
- en: Python has logging in its standard library, while Java has the open source Log4J
    and .NET uses either the Microsoft-built Microsoft.Extensions.Logging or the open
    source Log4Net. For unit testing, Python offers a standard implementation for
    both unit testing and mocking, but programmers tend to prefer open-source extensions
    such as pytest ( [https://docs.pytest.org/en/stable/](https://docs.pytest.org/en/stable/)
    ). Java requires a unit testing library, usually JUnit or TestNG, and a mocking
    library, usually Mockito or JMock. Finally, .NET provides a standard framework
    for testing but knowledgeable tech leads will most likely select NUnit or xUnit
    instead, along with Moq.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python在其标准库中提供了日志记录功能，而Java有开源的Log4J，.NET则使用微软构建的Microsoft.Extensions.Logging或开源的Log4Net。对于单元测试，Python提供了单元测试和模拟的标准实现，但程序员往往更喜欢像pytest这样的开源扩展（[https://docs.pytest.org/en/stable/](https://docs.pytest.org/en/stable/)）。Java需要单元测试库，通常是JUnit或TestNG，以及模拟库，通常是Mockito或JMock。最后，.NET提供了一个标准的测试框架，但知识渊博的技术负责人更有可能选择NUnit或xUnit，以及Moq。
- en: Where does C++ stand here? Well, there’s no shortage of logging libraries in
    C++, which shouldn’t be a surprise since logging systems have matured at the same
    time as C++. We can say that logging libraries are quasi-standardized, having
    very similar behavior and features with small variations in the API. It’s almost
    too difficult to choose a logging library for C++ unless you are using a technology
    that already comes with logging. I imagine that many projects use Boost and the
    logging that comes with it. A quick glance at GitHub shows that the **spdlog**
    library ( [https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)
    ) has 24k stars, although it only supports C++ 11.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C++在这里处于什么位置呢？嗯，C++中日志库的选择并不少，这并不令人惊讶，因为日志系统与C++同时成熟。我们可以认为日志库几乎是标准化的，它们在API上有着非常相似的行为和功能，只有细微的差别。除非你正在使用自带日志功能的技术，否则选择一个C++的日志库几乎是一件非常困难的事情。我想，许多项目都使用Boost及其内置的日志功能。快速浏览GitHub可以发现，**spdlog**库（[https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)）有24k个星标，尽管它只支持C++
    11。
- en: What about unit testing? This is an interesting topic. Unit testing libraries
    exist for C++ in many forms. There’s GTest and GMock, the two libraries started
    by Google, with the usual feature set. Similarly, CppTest follows the standard
    xUnit structure for unit tests. Then there’s **doctest** ( [https://github.com/doctest/doctest](https://github.com/doctest/doctest)
    ), a single header library with no dependencies, which is why I prefer it for
    examples and the code accompanying this book. Finally, it’s worth mentioning **Cpputest**
    ( [http://cpputest.github.io](http://cpputest.github.io) ) because it allows embedded
    development, due to its small footprint and its features for identifying memory
    management problems. For mocking, **FakeIt** ( [https://github.com/eranpeer/FakeIt](https://github.com/eranpeer/FakeIt)
    ) is another single header framework that is very easy to integrate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试怎么样呢？这是一个有趣的话题。C++中存在多种形式的单元测试库。有Google启动的GTest和GMock，这两个库具有通常的功能集。同样，CppTest遵循标准的xUnit结构进行单元测试。然后是**doctest**（[https://github.com/doctest/doctest](https://github.com/doctest/doctest)），这是一个无依赖的单头库，这也是为什么我更喜欢用它来展示示例和本书伴随的代码。最后，值得一提的是**Cpputest**（[http://cpputest.github.io](http://cpputest.github.io)），因为它允许嵌入式开发，这得益于它的小型足迹和识别内存管理问题的功能。对于模拟，**FakeIt**（[https://github.com/eranpeer/FakeIt](https://github.com/eranpeer/FakeIt)）是另一个非常容易集成的单头框架。
- en: All these libraries would likely be set up through a package manager that stores
    the list of dependencies in a text file that’s either plain text, a markup format,
    or a script. This file gets pushed to the central repository and can be used to
    recreate the dependencies, including the dependencies required by the installed
    libraries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些库都可能会通过包管理器来设置，该管理器将依赖项列表存储在一个文本文件中，该文件可以是纯文本、标记格式或脚本。这个文件会被推送到中央仓库，并可用于重新创建依赖项，包括安装的库所需的依赖项。
- en: 'If, during the development, the team needs an additional library, they can
    simply add it to the dependencies. This process is a bit more restricted for enterprise
    environments due to security concerns: perhaps a pre-approved list of packages
    is available and provided from an internal source, perhaps each package requires
    approval, or perhaps only specific people can add a dependency.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，如果团队需要额外的库，他们可以简单地将其添加到依赖项中。由于安全考虑，这个过程在企业环境中可能更为受限：可能有一个预先批准的包列表，可能每个包都需要获得批准，或者可能只有特定的人可以添加依赖项。
- en: Either way, when a new developer comes in, they will clone the central repository
    and run the installation commands, usually by just loading the project in the
    IDE and letting it do its thing, and everything should work fine. That’s the end
    of our fly story.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，当新开发者加入时，他们都会克隆中央仓库并运行安装命令，通常是通过在IDE中加载项目并让它自行处理，一切应该都会顺利。这就是我们飞行的故事的结尾。
- en: 'Let’s dive into more details about what happens behind the scenes if you use
    a package manager. Since I often use the command line in combination with neovim
    to program in Ubuntu Linux, I know a little bit more about the process in each
    of these technologies. For Python, a virtual environment is recommended so that
    the OS is not polluted with all the libraries required. A tool called **pipenv**
    combines the **pip** package manager and the **venv** virtual environment, both
    provided by the standard library, to allow for easy setup. The command line steps
    would be as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In a new environment, you can simply run the following to install all the dependencies:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Java and .NET have similar workflows, minus the virtual environment. They both
    use open source package managers; for Java, Maven or Gradle are used, and for
    .NET, it’s NuGet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'For all these three technologies, a central place for all the libraries exists:
    Pypi ( [https://pypi.org/](https://pypi.org/) ) for Python, Maven Central ( [https://mvnrepository.com/repos/central](https://www.mvnrepository.com/repos/central)
    ) for Maven and the NuGet site ( [https://www.nuget.org/](https://www.nuget.org/)
    ) for NuGet. As mentioned earlier, it’s likely that large companies will pay more
    attention to the libraries used, and require more thorough security checks before
    using third-party code in their systems. These companies tend to provide their
    own repositories, for example, using Artifactory in Java ( [https://jfrog.com/artifactory/](https://jfrog.com/artifactory/)
    ).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore very easy to search for libraries, update them, and install
    them in a new environment, with de facto standard tools available to any developer
    using that technology.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: C++ has gone a long way since I was a junior C++ programmer in the 2000s. Back
    then, adding a new library required either downloading the binaries for the required
    targets or, more likely, compiling it yourself, which posed its own set of challenges.
    Nowadays, C++ is closing the gap through Conan and vcpkg, and it’s likely that
    many programmers have a similar experience in C++ to the one I’ve described above
    for Java, Python, and .NET. Programmers in large companies are most likely to
    recognize it, since the organization provides a Conan or vspkg repository with
    approved libraries that can be found and installed easily. Adding a new library
    to the whitelist can be a bit of a pain and can take a long time, but that’s understandable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not as easy without that piece of infrastructure. The libraries are not
    available in a single location, and the tools don’t seem to work as well. At least
    this was my experience: Conan gave me a bunch of errors when I tried to use it
    on a simple project and I had no idea how to fix them. While I dislike Maven because
    it inexplicably downloads a lot of packages even for the simplest of setups, it
    works consistently and reliably, which is what we need from package managers.
    So, I’m afraid I will have to say this: while there are attempts to bring C++
    package management on par with other technologies, it doesn’t feel mature yet.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: With this being said, I’m sure many developers working in large companies won’t
    feel any of these issues. So, we’ll assume that the package manager works fine.
    What will we do next? Depending on the project and the technology, we will need
    more libraries to help us. Let’s look next at a few categories.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Common needs
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some needs that many developers have, in no particular order:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Database connection, reading, and writing
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSV file processing
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression, for example, **gzip**
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date/time enhancements
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Various computations, for example: matrices, imaginary numbers, math equation
    solving, and so on'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI, for desktop and mobile applications
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP client
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP server
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous programming
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image processing
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDF processing
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background jobs
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptography
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email sending
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON processing
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration file read and write: **ini** , **yaml** , and so on'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s safe to say that there are C++ libraries for all of these. Let’s pick
    just a few random ones:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**zlib** for **zip** and **gzip** compression'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rapidcsv ( [https://github.com/d99kris/rapidcsv](https://github.com/d99kris/rapidcsv)
    ) for CSV processing
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For database access, an ORM such as TinyORM ( [https://www.tinyorm.org/](https://www.tinyorm.org/)
    ) or SQLPP1 ( [https://github.com/rbock/sqlpp11](https://github.com/rbock/sqlpp11)
    ) for type-safe DSL queries and results
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poco libraries ( [https://pocoproject.org/](https://pocoproject.org/) ) contain
    a lot of utilities for networking, sending emails, database access, JSON, OpenSSL,
    and so on
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI libraries include Qt, GTK, wxWidgets, or Dear ImGui
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP clients are implemented in Boost, Curl++, or cpp-netlib
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement a web application, Crow ( [https://crowcpp.org/master/](https://crowcpp.org/master/)
    ) is inspired by Python’s Flask, while Oat++ ( [https://oatpp.io/](https://oatpp.io/)
    ) and Drogon ( [https://drogon.org/](https://drogon.org/) ) offer fast solutions
    for web APIs and microservices
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could go on, but I think we’ve made our point: *C++ has libraries* . It
    has *a lot of libraries* . Some of them have inspired the implementations of other
    technologies, while others took inspiration from the best solutions used by the
    alternatives. The advantages of the C++ implementations are obvious in terms of
    speed and low memory footprint. Some of these libraries pack many features into
    a few hundred kBs. It’s also impressive how many header-only implementations exist,
    allowing for portability and simplicity.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ also has frameworks. We already mentioned a few and we can add others:
    GTK, QT, Boost, POCO, WxWidgets, and Unreal Engine, for example. Lists of libraries
    and frameworks are maintained on the internet, the best one I’ve found being **awesome-cpp**
    ( [https://github.com/fffaraz/awesome-cpp](https://github.com/fffaraz/awesome-cpp)
    ).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Even niche programming styles and practices have their libraries:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Immutable collections? Use Immer ( [https://github.com/arximboldi/immer](https://github.com/arximboldi/immer)
    ).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Programming? Use RxCpp ( [https://github.com/ReactiveX/RxCpp](https://github.com/ReactiveX/RxCpp)
    ).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices? Sure, CppMicroServices ( [https://github.com/CppMicroServices/CppMicroServices](https://github.com/CppMicroServices/CppMicroServices)
    ) can help (no, microservices are not niche, but they’re rarely implemented in
    C++).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Assembly? Yes, there’s Emscripten ( [https://github.com/emscripten-core/emscripten](https://github.com/emscripten-core/emscripten)
    ) is a good choice.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless? There’s **aws-lambda-cpp** ( [https://github.com/awslabs/aws-lambda-cpp](https://github.com/awslabs/aws-lambda-cpp)
    ).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I think it’s obvious by now that we’d be hard-pressed to find any domain in
    which C++ lacks a library or framework. However, can we use them?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume that you find a very promising library and decide to add it to
    your project. Does it work? How *well* will it work?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s where the fragmentation of C++ shows its ugly side. The chance of any
    of the following undesirable things to happen is non-zero:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The library uses a newer C++ version than your code and you can’t compile it
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library uses an older C++ version than your code
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get a lot of warnings for different reasons
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library compiles well with your version of C++, but its interface uses older
    constructs
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library doesn’t work on all platforms your project targets
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library is incompatible with your compiler
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library is incompatible with your compilation process
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library is compatible with all platforms your project targets, but it has
    different behavior or performance issues or bugs on specific platforms
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I hope you never encounter any of the preceding problems. Also, it’s worth
    saying that you’d be much less likely to have them in the technologies we use
    as a comparison: Python, Java, and .NET have none of these issues. Well, almost
    none; it’s possible, for example, to create Python programs that use C++ modules
    and face the same issues. Or you could create a Java program that uses OS primitives
    and has different issues on different OSs. In general, though, there’s a continuous
    effort for consistency in these worlds.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, mature C++ frameworks and libraries such as Boost or **zlib** made
    the same effort and provided consistent behavior. It’s just easier to create consistent
    libraries in languages that use virtual machines.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that your library works fine: no warnings, no weird issues, and it
    plays well with your code and toolkit. There’s one last question: can we trust
    it?'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Supply chain security
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be obvious to anyone paying attention that software has always had
    a security problem. This problem is getting worse since software usage continues
    to increase and cover more and more areas of our daily lives.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two parts to improving security: the cybersecurity experts, who can
    find vulnerabilities and build protection tools, and the software developers,
    who need to find security issues before release and manage the accompanying risks.
    We know there’s no perfectly secure software, but we also know that things can
    get much better.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'A specific area of this increased protection is managing the potential vulnerabilities
    that come with the libraries we use. There are two situations: either vulnerabilities
    were introduced unknowingly, or they were injected on purpose by a malicious actor.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'In all fairness, this can happen to any technology, and many of the high-profile
    C++ libraries are reviewed for security by large companies that use them. Moreover,
    if you’re working in a large company, you have teams dealing with all these concerns.
    However, not all development is done in large companies, and not all libraries
    are treated the same, as we’ll see with the **xz backdoor case** . Let’s discuss
    the second case for a moment. A malicious actor can inject vulnerabilities in
    several ways:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: They can do this through a contribution to the code of an open source project.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can also fork an open source project and add vulnerabilities among useful
    features.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can also sometimes get away with becoming the maintainer of an open source
    project and then injecting vulnerabilities among useful features. See the story
    of the xz backdoor, which I commented on at length, at [https://mozaicworks.com/blog/xz-backdoor-and-other-news](https://mozaicworks.com/blog/xz-backdoor-and-other-news)
    .
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can also replace the binary with a vulnerable version, for example, by
    offering it on another website than the original or managing to hijack the publishing
    process.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may also attempt hijacking the download, for example, through a DNS attack.
    Imagine a potential attacker managing to modify your local host’s file to point
    the URL of your repository to another IP address on the internet.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们也可能尝试劫持下载，例如，通过DNS攻击。想象一下一个潜在的攻击者成功修改了你的本地主机文件，将你的仓库URL指向互联网上的另一个IP地址。
- en: All of the items in the preceding list are serious problems. In large companies,
    the security departments and IT/Ops tend to worry about them, but in smaller companies,
    it’s likely that you’ll need to pay extra attention. The solution we know is to
    validate all binaries with their digital signature or hash. While the package
    managers for programming languages and Linux do this automatically, manually downloading
    a binary from GitHub requires manual validation of the signature, hopefully provided
    along with the library file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面列表中的所有项目都是严重问题。在大公司中，安全部门和IT/Ops通常会担心这些问题，但在小公司中，你可能需要额外注意。我们知道的解决方案是验证所有二进制文件与其数字签名或哈希值。虽然编程语言和Linux的包管理器会自动执行此操作，但手动从GitHub下载二进制文件需要手动验证签名，希望签名与库文件一起提供。
- en: The first situation is even more complicated. How do you know whether a library
    has vulnerabilities? For open source code, the general belief is that many eyes
    look at the code and find all issues. However, that’s very dependent on the number
    of contributors and their expertise.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况甚至更复杂。你怎么知道一个库是否有漏洞？对于开源代码，普遍的看法是，许多眼睛查看代码就能发现所有问题。然而，这非常依赖于贡献者的数量和他们的专业知识。
- en: The xz backdoor case mentioned is chilling, especially since the issue was found
    by a developer, Andres Freund, who got suspicious by the fact that **sshd** was
    using too much CPU during a micro-benchmark ( [https://mastodon.social/@AndresFreundTec/112180406142695845](https://mastodon.social/@AndresFreundTec/112180406142695845)
    ). This made the issue of overworked maintainers for open source libraries visible,
    only for it to return to obscurity soon after.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的xz后门案例令人毛骨悚然，特别是问题是由开发者Andres Freund发现的，他通过微基准测试期间**sshd**使用过多的CPU而产生了怀疑（[https://mastodon.social/@AndresFreundTec/112180406142695845](https://mastodon.social/@AndresFreundTec/112180406142695845)）。这使得开源库过度工作的维护者问题变得明显，但很快又回到了隐秘状态。
- en: Let’s assume that most open source libraries are not attacked by a malicious
    actor who gains maintainer status. It’s still possible for vulnerabilities to
    escape, and more so in C++ since it has its own challenges in terms of security.
    A small team will need to stay informed of the reported vulnerabilities for the
    libraries they use, or license security tools that automatically do it for them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设大多数开源库不会被获得维护者状态的恶意行为者攻击。漏洞仍然可能逃逸，尤其是在C++中，因为它在安全性方面有自己的挑战。一个小团队需要了解他们使用的库报告的漏洞，或者许可自动为他们执行此操作的许可证安全工具。
- en: Assuming that everything works fine, it’s still best to store the list of libraries
    used in an application, so that the ops people know to periodically check for
    vulnerabilities in all the libraries used. The recommended practice in this area
    is to create what’s called the **Software Bill of Materials** ( **SBOM** ) for
    your product. An SBOM contains the list of all the libraries and their dependencies.
    Specific tools are available to create the SBOM and to scan for vulnerabilities
    based on them; however, most of them work with docker containers. For example,
    consider Grype ( [https://github.com/anchore/grype](https://github.com/anchore/grype)
    and its companion tool Syft [https://github.com/anchore/syft](https://github.com/anchore/syft)
    ).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切正常，仍然最好将应用程序中使用的库列表存储起来，这样运维人员就知道定期检查所有库中的漏洞。在这个领域，推荐的实践是为你的产品创建所谓的**软件物料清单**（**SBOM**）。SBOM包含所有库及其依赖关系的列表。有特定的工具可以创建SBOM并基于它们扫描漏洞；然而，大多数工具都与docker容器一起工作。例如，考虑Grype（[https://github.com/anchore/grype](https://github.com/anchore/grype)）及其配套工具Syft
    [https://github.com/anchore/syft](https://github.com/anchore/syft)）。
- en: This leads us to the conclusion of this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了本章的结论。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen in this chapter that C++ has a lot of libraries and frameworks
    that cover everything we might need. Compared to other technologies, the process
    of obtaining them is not as simple. They are not as easily discoverable since
    they are not in a central place, and they might bring additional issues such as
    incompatibility with the compiler or older code styles. We learned this in this
    chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到C++拥有众多库和框架，涵盖了我们所可能需要的所有功能。与其他技术相比，获取它们的过程并不简单。由于它们不在一个中心位置，因此它们并不容易被发现，并且可能带来额外的麻烦，例如与编译器或旧代码风格的不兼容性。我们在这章中学到了这一点。
- en: Similarly, like other technologies, the C++ libraries are prone to having vulnerabilities
    and are exposed to supply chain attacks. To protect against them, teams need to
    stay up to date with the stream of vulnerabilities discovered and authenticate
    the binaries upon download. Additional audits and scans are always useful, as
    we learned in this chapter. Thus, larger organizations have a security advantage
    since they have dedicated teams looking at these issues, at the cost of flexibility.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，与其他技术一样，C++库容易存在漏洞，并可能受到供应链攻击。为了防范这些攻击，团队需要跟上发现的漏洞流，并在下载时验证二进制文件。正如我们在本章所学，额外的审计和扫描总是很有用的。因此，大型组织在安全性方面具有优势，因为它们有专门的团队来关注这些问题，但这是以灵活性为代价的。
- en: So, are there libraries for modern programming in C++? Yes, definitely. They
    are just harder to find and less compatible than in other widely used technologies.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，C++中是否有现代编程的库呢？当然有，只是它们更难找到，并且与其他广泛使用的技术相比兼容性较差。
- en: In the next chapter, we’ll look at whether C++ is backward compatible... with
    itself and beyond.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨C++是否与其自身以及更广泛的技术向后兼容。
