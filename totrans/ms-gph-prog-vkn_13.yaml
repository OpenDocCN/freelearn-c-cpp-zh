- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Revisiting Shadows with Ray Tracing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视使用光线追踪的阴影
- en: In this chapter, we are going to implement shadows using **ray tracing**. In
    [*Chapter 8*](B18395_08.xhtml#_idTextAnchor116), *Adding Shadows Using Mesh Shaders*,
    we used traditional shadow mapping techniques to get the visibility from each
    light and use that information to compute the shadow term for the final image.
    Using ray tracing for shadows allows us to get more detailed results and to have
    finer-grained control over the quality of results based on the distance and intensity
    of each light.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**光线追踪**来实现阴影效果。在[*第8章*](B18395_08.xhtml#_idTextAnchor116)中，*使用网格着色器添加阴影*，我们使用了传统的阴影映射技术来获取每个光源的可见性，并使用这些信息来计算最终图像的阴影项。使用光线追踪来实现阴影可以让我们获得更详细的结果，并且可以根据每个光源的距离和强度对结果的质量进行更精细的控制。
- en: 'We are going to implement two techniques: the first one is similar to the one
    used in offline rendering, where we shoot rays to each light to determine visibility.
    While this approach gives us the best results, it can be quite expensive depending
    on the number of lights in the scene.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现两种技术：第一种技术与离线渲染中使用的类似，即向每个光源发射光线以确定可见性。虽然这种方法可以给我们带来最佳结果，但它可能相当昂贵，这取决于场景中光源的数量。
- en: The second technique is based on a recent article from **Ray Tracing Gems**.
    We use some heuristics to determine how many rays we need to cast per light, and
    we combine the results with spatial and temporal filters to make the result stable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术基于**《光线追踪宝石》**中的一篇最新文章。我们使用一些启发式方法来确定每个光源需要发射多少条光线，并将结果与空间和时间滤波器结合，以使结果稳定。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Implementing simple ray-traced shadows
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现简单的基于光线追踪的阴影
- en: Implementing an advanced technique for ray-traced shadows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基于光线追踪的阴影的高级技术
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: By the end of this chapter you will learn how to implement basic ray-traced
    shadows. You will also become familiar with a more advanced technique that is
    capable of rendering multiple lights with soft shadows.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何实现基本的基于光线追踪的阴影效果。你还将熟悉一种更高级的技术，它能够渲染带有柔和阴影的多光源。
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter13](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter13).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下URL找到：[https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter13](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter13)。
- en: Implementing simple ray-traced shadows
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现简单的基于光线追踪的阴影
- en: As we mentioned in the introduction, shadow mapping techniques have been a staple
    of real-time rendering for many years. Before the introduction of ray tracing
    capabilities in GPUs, using other techniques was simply too expensive.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在引言中提到的，阴影映射技术多年来一直是实时渲染的基石。在GPU引入光线追踪功能之前，使用其他技术成本太高。
- en: This hasn’t prevented the graphics community from coming up with clever solutions
    to increase the quality of results while maintaining a low cost. The main issue
    with traditional techniques is that they are based on capturing depth buffers
    from the point of view of each light. This works well for objects that are near
    the light and camera, but as we move further away, depth discontinuities lead
    to artefacts in the final result.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有阻止图形社区想出聪明的解决方案来提高结果的质量，同时保持低成本。传统技术的主要问题是它们基于从每个光源的角度捕获深度缓冲区。这对于靠近光源和摄像机的物体来说效果很好，但随着我们远离，深度不连续性会导致最终结果中出现伪影。
- en: Solutions to this problem include filtering the result – for instance, using
    **Percentage Closer Filtering** (**PCF**) or **Cascade Shadow Maps** (**CSM**).
    This technique requires capturing multiple depth *slices* – the cascades to maintain
    enough resolution as we move further away from the light. This is usually employed
    only for sunlight, as it can require a lot of memory and time to re-render the
    scene multiple times. It can also be quite difficult to get good results on the
    boundaries between cascades.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法包括对结果进行滤波——例如，使用**百分比更近滤波**（**PCF**）或**级联阴影映射**（**CSM**）。这种技术需要捕获多个深度**切片**——级联以保持足够的分辨率，当我们远离光源时。这通常仅用于日光，因为它可能需要大量的内存和时间来多次重新渲染场景。它也可能很难在级联的边界处获得良好的结果。
- en: The other main issue with shadow mapping is that it can be difficult to get
    hard shadows because of the resolution of the depth buffer and the discontinuities
    it introduces. We can alleviate these issues with ray tracing. Offline rendering
    has used ray and path tracing for many years to achieve photo-realistic effects,
    including shadows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影映射的另一个主要问题是，由于深度缓冲区的分辨率和它引入的不连续性，可能难以获得硬阴影。我们可以通过光线追踪来缓解这些问题。离线渲染已经使用了多年光线和路径追踪来实现照片级效果，包括阴影。
- en: They, of course, have the luxury of being able to wait for hours or days for
    a single frame to complete, but we can get similar results in real time. In the
    previous chapter, we used the `vkCmdTraceRaysKHR` command to cast rays into a
    scene.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，他们有等待数小时或数天才能完成单个帧的奢侈，但我们可以实时获得类似的结果。在前一章中，我们使用了`vkCmdTraceRaysKHR`命令将射线投射到场景中。
- en: For this implementation, we are introducing ray queries, which allow us to traverse
    the Acceleration Structures we set up from a fragment and compute shaders.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实现，我们引入了射线查询，它允许我们从片段和计算着色器遍历我们设置的加速结构。
- en: We are going to modify the `calculate_point_light_contribution` method of our
    lighting pass to determine which lights each fragment can see and determine the
    final shadow term.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们的光照传递中的`calculate_point_light_contribution`方法，以确定每个片段可以看到哪些光源，并确定最终的阴影项。
- en: 'First, we need to enable the `VK_KHR_ray_query` device extension. We also need
    to enable the related shader extension:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要启用`VK_KHR_ray_query`设备扩展。我们还需要启用相关的着色器扩展：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, instead of computing the cube map from each light point of view, we simply
    cast a ray from the fragment world position to each light.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们不是从每个光源的视角计算立方体贴图，而是简单地从片段世界位置向每个光源发射射线。
- en: 'We start by initializing a `rayQueryEXT` object:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化一个`rayQueryEXT`对象：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice the `gl_RayFlagsTerminateOnFirstHitEXT` parameter, as we are only interested
    in the first hit for this ray. `l` is the direction from `world_position` to the
    light and we use a small offset from the ray origin to avoid self-intersection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`gl_RayFlagsTerminateOnFirstHitEXT`参数，因为我们对这个射线只对第一次命中感兴趣。"l"是从`world_position`到光源的方向，我们使用从射线原点的小偏移量来避免自相交。
- en: The last parameter, `d`, is the distance from `world_position` to the light
    position. It’s important to specify this value, as the ray query could report
    intersections past the light position otherwise, and we could incorrectly mark
    a fragment to be in shadow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数`d`是从`world_position`到灯光位置的距离。指定这个值很重要，因为否则射线查询可能会报告超过灯光位置的交点，我们可能会错误地将一个片段标记为处于阴影中。
- en: 'Now that we have initialized the ray query object, we call the following method
    to start scene traversal:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了射线查询对象，我们调用以下方法来开始场景遍历：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will return either when a hit is found or when the ray terminates. When
    using ray queries, we don’t have to specify a shader binding table. To determine
    the result of ray traversal, there are several methods we can use to query the
    outcome. In our case, we only want to know whether the ray hit any geometry:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在找到命中点或射线终止时返回。当使用射线查询时，我们不需要指定着色器绑定表。为了确定射线遍历的结果，我们可以使用几种方法来查询结果。在我们的情况下，我们只想知道射线是否击中了任何几何体：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If not, it means we can see the light we are processing from this fragment,
    and we can account for this light contribution in the final computation. We repeat
    this for each light to obtain the overall shadow term.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是，这意味着我们可以从这个片段看到我们正在处理的灯光，我们可以在最终计算中考虑这个灯光的贡献。我们对每个灯光重复此操作以获得总的阴影项。
- en: While this implementation is really simple, it mainly works for point lights.
    For other types of light – area lights, for instance – we would need to cast multiple
    rays to determine the visibility. As the number of lights increases, it can become
    too expensive to use this simple technique.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个实现非常简单，但它主要适用于点光源。对于其他类型的灯光——例如面光源——我们需要发射多根射线来确定可见性。随着光源数量的增加，使用这种简单技术可能会变得过于昂贵。
- en: In this section, we have demonstrated a simple implementation to get started
    with real-time ray-traced shadows. In the next section, we are going to introduce
    a new technique that scales better and can support multiple types of light.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们演示了一个简单的实现，以开始实时光线追踪阴影。在下一节中，我们将介绍一种新的技术，它具有更好的扩展性，可以支持多种类型的灯光。
- en: Improving ray-traced shadows
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进光线追踪阴影
- en: In the previous section, we described a simple algorithm that can be used to
    compute the visibility term in our scene. As we mentioned, this doesn’t scale
    well for a large number of lights and can require a large number of samples for
    different types of light.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们描述了一个可以用来计算场景中可见性项的简单算法。正如我们提到的，这在大规模灯光和不同类型灯光需要大量样本的情况下扩展性不好。
- en: In this section, we are going to implement a different algorithm inspired by
    the article *Ray Traced Shadows* in the *Ray Tracing Gems* book. As will be common
    in this chapter and upcoming chapters, the main idea is to spread the computation
    cost over time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个受《Ray Tracing Gems》书中“Ray Traced Shadows”文章启发的不同算法。正如在本章和即将到来的章节中常见的那样，主要思想是将计算成本分散到时间上。
- en: This can still lead to noisy results, as we are still using a low number of
    samples. To achieve the quality we are looking for, we are going to make use of
    spatial and temporal filtering, similar to what we did in [*Chapter 11*](B18395_11.xhtml#_idTextAnchor178),
    *Temporal Anti-Aliasing*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然可能导致结果噪声，因为我们仍在使用低样本数。为了达到我们想要的质量，我们将利用空间和时间滤波，类似于我们在[*第 11 章*](B18395_11.xhtml#_idTextAnchor178)中做的，*时间反走样*。
- en: The technique is implemented over three passes, and we are also going to leverage
    motion vectors. We are now going to explain each pass in detail.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术通过三个过程实现，我们还将利用运动向量。现在我们将详细解释每个过程。
- en: Motion vectors
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运动向量
- en: As we saw in [*Chapter 11*](B18395_11.xhtml#_idTextAnchor178), *Temporal Anti-Aliasing*,
    motion vectors are needed to determine how far an object at a given fragment has
    moved between frames. We need this information to determine which information
    to keep and which to discard for our computation. This helps us avoid ghosting
    artifacts in the final image.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第 11 章*](B18395_11.xhtml#_idTextAnchor178)中看到的，*时间反走样*，运动向量是确定给定片段中的物体在帧之间移动多远所必需的。我们需要这些信息来确定我们计算中要保留和丢弃哪些信息。这有助于我们避免最终图像中的鬼影伪影。
- en: 'For the technique in this chapter, we need to compute motion vectors differently
    compared to **Temporal Anti-Aliasing** (**TAA**). We first compute the proportional
    difference of depth between the two frames:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的技术，我们需要以不同于**时间反走样**（**TAA**）的方式计算运动向量。我们首先计算两帧之间深度的比例差异：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we compute an epsilon value that will be used to determine acceptable
    changes in depth:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算一个epsilon值，该值将用于确定可接受的深度变化：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we use these two values to decide whether the reprojection was successful:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用这两个值来决定重投影是否成功：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following figure shows the result of this computation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了这一计算的结果：
- en: '![Figure 13.1 – The motion vector’s texture](img/B18395_13_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 运动向量的纹理](img/B18395_13_01.jpg)'
- en: Figure 13.1 – The motion vector’s texture
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 运动向量的纹理
- en: We are going to store this value in a texture for later use. The next step is
    to compute the variation in visibility for the past four frames.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个值存储在一个纹理中，以供以后使用。下一步是计算过去四帧的可见性变化。
- en: Computing visibility variance
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算可见性方差
- en: This technique uses data from the past four frames to determine how many samples
    are needed for each light for each fragment. We store the `visibility` values
    in a 3D RGBA16 texture, where each channel is the `visibility` value of the previous
    frames. Each layer stores the visibility history for individual lights.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使用过去四帧的数据来确定每个片段每个光所需的样本数。我们将`可见性`值存储在一个 3D RGBA16 纹理中，其中每个通道是前几帧的`可见性`值。每一层存储单个光的可见性历史。
- en: 'This is one of the first compute shaders where we use a 3D dispatch size. It’s
    worth highlighting the `dispatch` call:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个使用 3D 调度大小的计算着色器之一。值得强调的是`dispatch`调用：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this pass, we simply compute the difference between the minimum and maximum
    value over the past four frames:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们只是计算过去四帧中的最小值和最大值之间的差异：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The historical values are set to `0` during the first frame. We store the delta
    in another 3D texture to be used in the next pass. The following figure shows
    the result of this pass:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一帧中，历史值被设置为`0`。我们将增量存储在另一个 3D 纹理中，以便在下一轮中使用。下图显示了这一轮的结果：
- en: '![Figure 13.2 – The visibility variation for the past four frames](img/B18395_13_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 过去四帧的可见性变化](img/B18395_13_02.jpg)'
- en: Figure 13.2 – The visibility variation for the past four frames
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 过去四帧的可见性变化
- en: Computing visibility
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算可见性
- en: This pass is responsible for computing how many rays to shoot for each light
    depending on the variance across the past four frames.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次传递负责根据过去四帧的方差计算每个光需要发射多少光线。
- en: 'This pass needs to read a lot of data from different textures. We are going
    to use **local data storage** (**LDS**) to cache the values across all threads
    within a shader invocation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次传递需要从不同的纹理中读取大量数据。我们将使用**局部数据存储（LDS**）来缓存一个着色器调用内所有线程的值：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we explained in [*Chapter 9*](B18395_09.xhtml#_idTextAnchor143), *Implementing
    Variable Rate Shading*, we need to be careful about synchronizing these writes
    by placing a `barrier()` call before accessing the data stored in `local_image_data`.
    Likewise, we need to populate values around the edges of the matrix. The code
    is the same as before and we won’t replicate it here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第9章*](B18395_09.xhtml#_idTextAnchor143)中解释的，*实现可变率着色*，我们需要小心同步这些写入，通过在访问存储在`local_image_data`中的数据之前放置一个`barrier()`调用。同样，我们还需要填充矩阵边缘的值。代码与之前相同，我们在这里不会重复它。
- en: 'Next, we are going to filter this data to make it more temporally stable. The
    first step is to compute the maximum value in a 5x5 region and store the result
    in another LDS matrix:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对这些数据进行滤波，使其更具时间稳定性。第一步是在一个5x5区域内计算最大值，并将结果存储在另一个LDS矩阵中：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`max_filter` is implemented as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_filter`的实现如下：'
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After computing the `max` values, we pass them through a 13x13 tent filter:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算了`max`值之后，我们将它们通过一个13x13的帐篷滤波器：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is done to smooth out differences between adjacent fragments while still
    giving more weight to the fragment we are processing. We then combine this value
    with temporal data:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了平滑相邻片段之间的差异，同时仍然给正在处理的片段更多的权重。然后我们将这个值与时间数据结合起来：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before moving on, we update the variation cache for the next frame:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们更新下一帧的变差缓存：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We now leverage the data we just obtained to compute the visibility term. First,
    we need to determine the sample count. If the reprojection in the previous pass
    has failed, we simply use the maximum sample count:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在利用刚刚获得的数据来计算可见性项。首先，我们需要确定样本计数。如果前一次传递中的重投影失败，我们简单地使用最大的样本计数：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the reprojection was successful, we get the sample count for the last frame
    and determine whether the sample count has been stable over the past four frames:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重投影成功，我们得到最后一帧的样本计数，并确定样本计数在过去四帧中是否稳定：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then combine this information with the filtered value we computed previously
    to determine the sample count for this frame:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些信息与我们之前计算出的滤波值结合起来，以确定这一帧的样本计数：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the filtered value surpasses a given threshold, we are going to increase
    the sample count. This means we identified a high-variance value across the past
    four frames and we’d need more samples to converge to a better result.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果滤波值超过一个给定的阈值，我们将增加样本计数。这意味着我们在过去四帧中识别出高方差值，我们需要更多的样本来收敛到一个更好的结果。
- en: If, on the other hand, the sample count has been stable across the past four
    frames, we decrease the sample count.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相反，样本计数在过去四帧中保持稳定，我们将减少样本计数。
- en: 'While this works well in practice, it could reach a sample count of `0` if
    the scene is stable – for instance, when the camera is not moving. This would
    lead to an unlit scene. For this reason, we force the sample count to `1` if the
    past four frames also had a sample count of `0`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在实践中效果很好，但如果场景稳定（例如，当相机不移动时），样本计数可能会达到`0`。这会导致一个未照亮的场景。因此，如果过去四帧的样本计数也为`0`，我们强制样本计数为`1`：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is an example of the sample count cache texture:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是样本计数缓存纹理的一个示例：
- en: '![Figure 13.3 – The sample count cache texture](img/B18395_13_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 样本计数缓存纹理](img/B18395_13_03.jpg)'
- en: Figure 13.3 – The sample count cache texture
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 样本计数缓存纹理
- en: Notice that fragments that *see* the light tend to require more samples, as
    expected.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到看到光的片段通常需要更多的样本，这是预期的。
- en: 'Now that we know how many samples we need, we can move on to computing the
    `visibility` value:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了需要多少样本，我们可以继续计算`可见性`值：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`get_light_visibility` is the method that traces rays through the scene. It’s
    implemented as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_light_visibility`是追踪场景中光线的方法。它的实现如下：'
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We first compute a few parameters as we have done before for our lighting implementation.
    In addition, we compute `d`, the distance between the world position of this fragment
    and the light we are processing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算一些参数，就像我们之前为我们的光照实现所做的那样。此外，我们计算`d`，即这个片段的世界位置与正在处理的光之间的距离。
- en: 'Next, we trace rays through the scene only if this light is close enough and
    it’s not behind geometry at this fragment. This is achieved using the following
    code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们仅在光线足够接近且不在该片段的几何体后面时，才通过场景追踪光线。这是通过以下代码实现的：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then trace one ray per sample. To make sure the results converge over time,
    we compute the ray direction by using a pre-computed Poisson disk:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为每个样本追踪一条光线。为了确保结果随时间收敛，我们通过使用预先计算的泊松盘来计算光线方向：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we have computed our ray direction, we can start ray traversal:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算了我们的光线方向，我们可以开始光线遍历：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code is very similar to the code we presented in the first section, but
    in this case, we accumulate the `visibility` value for each direction the light
    is visible from:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们第一部分中展示的代码非常相似，但在这个案例中，我们累计光线可见的每个方向上的`visibility`值：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we return the average of the computed `visibility` value:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回计算出的`visibility`值的平均值：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have the `visibility` value for this frame, we need to update our
    visibility history cache. If the reprojection was successful, we simply add the
    new value:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这一帧的`visibility`值，我们需要更新我们的可见性历史缓存。如果重投影成功，我们只需添加新值：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If, on the other hand, the reprojection failed, we overwrite all `history`
    entries with the new `visibility` value:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，另一方面，重投影失败，我们用新的`visibility`值覆盖所有`history`条目：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last step is to also update the sample count cache:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更新样本计数缓存：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we have updated the visibility term for this frame and updated all
    the caches, we can move to the last pass and compute the filtered visibility that
    will be used in our lighting computation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了这一帧的可见性项并更新了所有缓存，我们可以移动到最后一个遍历并计算用于光照计算的滤波可见性。
- en: Computing filtered visibility
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算滤波可见性
- en: If we were to use the `visibility` value as computed in the previous section,
    the output would be very noisy. For each frame, we might have a different sample
    count and sample positions, especially if the camera or objects are moving.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用上一节计算出的`visibility`值，输出将会非常嘈杂。对于每一帧，我们可能会有不同的样本数和样本位置，尤其是如果相机或物体在移动。
- en: For this reason, we need to *clean up* the result before we can use it. One
    common approach is to use a denoiser. A denoiser is usually implemented as a series
    of compute passes that, as the name implies, will reduce the noise as much as
    possible. Denoisers can take a significant amount of time, especially as the resolution
    increases.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，在我们能够使用它之前，我们需要*清理*结果。一种常见的方法是使用去噪器。去噪器通常实现为一系列计算遍历，正如其名所示，将尽可能减少噪声。去噪器可能需要相当长的时间，特别是当分辨率增加时。
- en: 'In our case, we are going to use a simple temporal and spatial filter to reduce
    the amount of time this technique takes. As with the previous pass, we need to
    read data into LDS first. This is accomplished by following two lines:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将使用一个简单的时域和空域滤波器来减少这种技术所需的时间。与之前的遍历一样，我们首先需要将数据读入LDS。这是通过以下两行代码实现的：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`visibility_temporal_filter` is implemented as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`visibility_temporal_filter`的实现如下：'
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We first read the historical visibility data at this fragment for the given
    light and simply compute the average. This is our temporal filter. Depending on
    your use case, you might use a different weighting function, giving more emphasis
    to more recent values.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先读取给定光在此片段的历史可见性数据，并简单地计算平均值。这是我们的时间滤波器。根据您的用例，您可能使用不同的加权函数，给予较近的值更多的重视。
- en: For spatial filtering, we are going to use a Gaussian kernel. The original article
    uses variable-sized kernels according to visibility variance. In our implementation,
    we decided to use a fixed 5x5 Gaussian kernel, as it provides good enough results.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于空域滤波，我们将使用高斯核。原始文章使用根据可见性方差可变大小的核。在我们的实现中，我们决定使用固定的5x5高斯核，因为它提供了足够好的结果。
- en: 'The loop to compute the filtered value is implemented as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 计算滤波值的循环实现如下：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'First, we store the normal in our fragment location. We then iterate over the
    kernel size to compute the final term:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将法线存储在我们的片段位置。然后我们遍历核大小来计算最终项：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As described in the article, if the normals of adjacent fragments diverge, we
    ignore this data point. This is done to prevent shadow leaking.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如文章所述，如果相邻片段的法线发散，我们忽略这个数据点。这样做是为了防止阴影泄露。
- en: 'Finally, we combine the value that has already gone through the temporal filter
    with the kernel value:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将已经通过时间滤波器的值与核值相结合：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following figure illustrates the content of the filtered visibility texture:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图展示了过滤后的可见性纹理的内容：
- en: '![Figure 13.4 – The filtered visibility texture](img/B18395_13_04.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 过滤后的可见性纹理](img/B18395_13_04.jpg)'
- en: Figure 13.4 – The filtered visibility texture
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 过滤后的可见性纹理
- en: This concludes the computation of the `visibility` value for each light. We
    can now use this information during our lighting pass, as described in the next
    section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了每个灯光的`可见性`值的计算。现在，我们可以使用这些信息在我们的光照过程中，如下一节所述。
- en: Using the filtered visibility
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用过滤后的可见性
- en: 'Using our `visibility` term is really simple. In the `calculate_point_light_contribution`
    method, we simply have to read the visibility we have computed in the previous
    passes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`可见性`项非常简单。在`calculate_point_light_contribution`方法中，我们只需读取在前几步中计算出的可见性：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It could be possible to combine traditional shadow maps with a ray tracing implementation
    similar to the one we described here. It all depends on the frame budget for the
    technique, the type of lights in the scene, and the desired quality.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可能可以将传统的阴影映射与类似于我们在这里描述的射线追踪实现相结合。这完全取决于该技术的帧预算、场景中的灯光类型以及期望的质量。
- en: In this section, we have presented a different implementation for ray-traced
    shadows. The first step is to compute and store the visibility variance across
    the past four frames. Next, we computed the sample count for each fragment and
    each light using a `max` filter followed by a tent filter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提出了射线追踪阴影的不同实现方法。第一步是计算并存储过去四帧的可见性方差。接下来，我们使用`max`滤波器后跟帐篷滤波器来计算每个片段和每个灯光的样本计数。
- en: We then used this sample count to trace rays into the scene to determine a raw
    `visibility` value. In the last pass, we passed this `visibility` value through
    a temporal and spatial filter to reduce noise. Finally, we used this filtered
    value in our lighting computation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用这个样本计数将射线追踪到场景中，以确定一个原始的`可见性`值。在最后一遍中，我们将这个`可见性`值通过时间和空间滤波器来减少噪声。最后，我们使用这个过滤后的值在我们的光照计算中。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have presented two implementations for ray-traced shadows.
    In the first section, we provided a simple implementation similar to what you
    might find in an offline renderer. We simply shoot one ray per fragment to each
    light to determine whether it’s visible or not from that position.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了射线追踪阴影的两个实现方法。在第一部分，我们提供了一个类似于你可能在离线渲染器中找到的简单实现。我们简单地针对每个片段向每个灯光发射一束射线，以确定从该位置是否可见。
- en: While this works well for point lights, it would require many rays to support
    other light types and render soft shadows. For this reason, we also provided an
    alternative that makes use of spatial and temporal information to determine how
    many samples to use per light.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于点光源来说效果很好，但要支持其他灯光类型并渲染软阴影，则需要许多射线。因此，我们还提供了一个替代方案，该方案利用空间和时间信息来确定每个灯光需要使用多少样本。
- en: We start by computing the visibility variance of the past four frames. We then
    filter this value to determine how many rays to shoot for each fragment for each
    light. We use this count to traverse the scene and determine the `visibility`
    value for each fragment. Finally, we filter the visibility we obtained to reduce
    the noise. The filtered visibility is then used in the lighting computation to
    determine the final shadow term.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算过去四帧的可见性方差。然后，我们过滤这个值以确定每个灯光对每个片段需要发射多少射线。我们使用这个计数来遍历场景并确定每个片段的`可见性`值。最后，我们过滤我们获得的可见性以减少噪声。过滤后的可见性随后用于光照计算以确定最终的阴影项。
- en: In the next chapter, we continue our ray tracing journey by implementing global
    illumination!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过实现全局光照来继续我们的射线追踪之旅！
- en: Further reading
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The technique we have implemented in this chapter is detailed in [*Chapter
    13*](B18395_13.xhtml#_idTextAnchor213), *Revisiting Shadows with Ray Tracing,*
    of the book *Ray Tracing Gems*. It is freely available here: [http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml](http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们实现的技术在《光线追踪宝石》一书的第13章“用光线追踪重新审视阴影”中有详细描述。该书可在以下链接免费获取：[http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml](http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml).
- en: 'We have only used a limited set of the GLSL APIs available for ray tracing.
    We recommend reading the GLSL extension specification to see all the options available:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用了可用于光线追踪的GLSL API的有限集合。我们建议阅读GLSL扩展规范以查看所有可用的选项：
- en: '[https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_tracing.txt](https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_tracing.txt)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_tracing.txt](https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_tracing.txt)'
- en: '[https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_query.txt](https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_query.txt)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_query.txt](https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_query.txt)'
- en: 'We used a few filters in this chapter. Signal processing is a vast and wonderful
    field that has more implications in graphics programming than people realize.
    To get you started, we recommend this article by Bart Wronski: [https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/](https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了几个过滤器。信号处理是一个广阔而精彩的领域，它在图形编程中的应用比人们意识到的要多。为了帮助您入门，我们推荐Bart Wronski的这篇文章：[https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/](https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/).
