<html><head></head><body>
		<div><h1 id="_idParaDest-242"><a id="_idTextAnchor249"/><em class="italic">Chapter 11</em>: Collision Detection, Pickups, and Bullets</h1>
			<p>So far, we have implemented the main visual aspects of our game. We have a controllable character running around in an arena full of zombies that chase them. The problem is that they don't interact with each other. A zombie can wander right through the player without leaving a scratch. We need to detect collisions between the zombies and the player. </p>
			<p>If the zombies are going to be able to injure and eventually kill the player, it is only fair that we give the player some bullets for their gun. We will then need to make sure that the bullets can hit and kill the zombies.</p>
			<p>At the same time, if we are writing collision detection code for bullets, zombies, and the player, it would be a good time to add a class for health and ammo pickups as well.</p>
			<p>Here is what we will do and the order in which we will cover things in this chapter:</p>
			<ul>
				<li>Shooting Bullets</li>
				<li>Adding a crosshair and hiding the mouse pointer</li>
				<li>Spawning pickups</li>
				<li>Detecting collisions</li>
			</ul>
			<p>Let's start with the <code>Bullet</code> class.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor250"/>Coding the Bullet class</h1>
			<p>We will use the SFML <code>RectangleShape</code> class to visually represent a bullet. We will code a <code>Bullet</code> class that has a <code>RectangleShape</code> member, as well as other member data and functions. Then, we will add bullets to our game in a few steps, as follows: </p>
			<ol>
				<li>First, we will code the <code>Bullet.h</code> file. This will reveal all the details of the member data and the prototypes for the functions.</li>
				<li>Next, we will code the <code>Bullet.cpp</code> file, which, of course, will contain the definitions for all the functions of the <code>Bullet</code> class. As we step through this, I will explain exactly how an object of the <code>Bullet</code> type will work and be controlled.</li>
				<li>Finally, we will declare a whole array full of bullets in the <code>main</code> function. We will also implement a control scheme for shooting, managing the player's remaining ammo, and reloading.</li>
			</ol>
			<p>Let's get started with step 1.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor251"/>Coding the Bullet header file</h2>
			<p>To make the new header file, right-click <code>Bullet.h</code>.</p>
			<p>Add the following private member variables, along with the <code>Bullet</code> class declaration, to the <code>Bullet.h</code> file. We can then run through them and explain what they are for:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
class Bullet
{
private:
    // Where is the bullet?
    Vector2f m_Position;
    // What each bullet looks like
    RectangleShape m_BulletShape;
    // Is this bullet currently whizzing through the air
    bool m_InFlight = false;
    // How fast does a bullet travel?
    float m_BulletSpeed = 1000;
    // What fraction of 1 pixel does the bullet travel, 
    // Horizontally and vertically each frame?
    // These values will be derived from m_BulletSpeed
    float m_BulletDistanceX;
    float m_BulletDistanceY;
    
    // Some boundaries so the bullet doesn't fly forever
    float m_MaxX;
    float m_MinX;
    float m_MaxY;
    float m_MinY;
// Public function prototypes go here
};</pre>
			<p>In the previous code, the first member is a <code>Vector2f</code> called <code>m_Position</code>, which will hold the bullet's location in the game world.</p>
			<p>Next, we declare a <code>RectangleShape</code> called <code>m_BulletShape</code> as we are using a simple non-texture graphic for each bullet, a bit like we did for the time-bar in Timber!!!.</p>
			<p>The code then declares a <code>Boolean</code>,<code> m_InFlight</code>, which will keep track of whether the bullet is currently whizzing through the air or not. This will allow us to decide whether we need to call its <code>update</code> function each frame and whether we need to run collision detection checks.</p>
			<p>The <code>float</code> variable, <code>m_BulletSpeed</code>, will (you can probably guess) hold the speed in pixels per second that the bullet will travel at. It is initialized to the value of <code>1000</code>, which is a little arbitrary, but it works well.</p>
			<p>Next, we have two more <code>float</code> variables, <code>m_BulletDistanceX</code> and <code>m_BulletDistanceY</code>. As the calculations to move a bullet are a little more complex than those used to move a zombie or the player, we will benefit from having these two variables, which we will perform calculations on. They will be used to decide the horizontal and vertical changes in the bullet's position in each frame.</p>
			<p>Finally, we have four more <code>float</code> variables (<code>m_MaxX</code>, <code>m_MinX</code>, <code>m_MaxY</code>, and <code>m_MinY</code>), which will later be initialized to hold the maximum and minimum and horizontal and vertical positions for the bullet.</p>
			<p>It is likely that the need for some of these variables is not immediately apparent, but it will become clearer when we see each of them in action in the <code>Bullet.cpp</code> file.</p>
			<p>Now, add all the public function prototypes to the <code>Bullet.h</code> file:</p>
			<pre>// Public function prototypes go here
<strong class="bold">public:</strong>
<strong class="bold">    // The constructor</strong>
<strong class="bold">    Bullet();</strong>
<strong class="bold">    // Stop the bullet</strong>
<strong class="bold">    void stop();</strong>
<strong class="bold">    // Returns the value of m_InFlight</strong>
<strong class="bold">    bool isInFlight();</strong>
<strong class="bold">    // Launch a new bullet</strong>
<strong class="bold">    void shoot(float startX, float startY,</strong>
<strong class="bold">        float xTarget, float yTarget);</strong>
<strong class="bold">    // Tell the calling code where the bullet is in the world</strong>
<strong class="bold">    FloatRect getPosition();</strong>
<strong class="bold">    // Return the actual shape (for drawing)</strong>
<strong class="bold">    RectangleShape getShape();</strong>
<strong class="bold">    // Update the bullet each frame</strong>
<strong class="bold">    void update(float elapsedTime);</strong>
};</pre>
			<p>Let's run through each of the functions in turn, and then we can move on to coding their definitions.</p>
			<p>First, we have the <code>Bullet</code> function, which is, of course, the constructor. In this function, we will set up each <code>Bullet</code> instance, ready for action.</p>
			<p>The <code>stop</code> function will be called when the bullet has been in action but needs to stop. </p>
			<p>The <code>isInFlight</code> function returns a Boolean and will be used to test whether a bullet is currently in flight or not.</p>
			<p>The <code>shoot</code> function's use is given away by its name, but how it will work deserves some discussion. For now, just note that it has four <code>float</code> parameters that will be passed in. The four values represent the starting (where the player is) horizontal and vertical position of the bullet, as well as the vertical and horizontal target position (where the crosshair is). </p>
			<p>The <code>getPosition</code> function returns a <code>FloatRect</code> that represents the location of the bullet. This function will be used to detect collisions with zombies. You might remember from <a href="B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 10</em></a>,<em class="italic"> Pointers, the Standard Template Library, and Texture Management</em>, that zombies also had a <code>getPosition</code> function.</p>
			<p>Following on, we have the <code>getShape</code> function, which returns an object of the <code>RectangleShape</code> type. As we have discussed, each bullet is represented visually by a <code>RectangleShape</code> object. The <code>getShape</code> function, therefore, will be used to grab a copy of the current state of <code>RectangleShape</code> in order to draw it.</p>
			<p>Finally, and hopefully as expected, there is the <code>update</code> function, which has a <code>float</code> parameter that represents the fraction of a second that has passed since the last time <code>update</code> was called. The <code>update</code> method will change the position of the bullet each frame.</p>
			<p>Let's look at and code the function definitions.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor252"/>Coding the Bullet source file</h2>
			<p>Now, we can create a new <code>.cpp</code> file that will contain the function definitions. Right-click <code>Bullet.cpp</code>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the class.</p>
			<p>Add the following code, which is for the include directives and the constructor. We know it is a constructor because the function has the same name as the class:</p>
			<pre>#include "bullet.h"
// The constructor
Bullet::Bullet()
{
    m_BulletShape.setSize(sf::Vector2f(2, 2));
}</pre>
			<p>The only thing that the <code>Bullet</code> constructor needs to do is set the size of <code>m_BulletShape</code>, which is the <code>RectangleShape</code> object. The code sets the size to two pixels by two pixels.</p>
			<p>Next, we will code the more substantial <code>shoot</code> function. Add the following code to the <code>Bullet.cpp</code> file and study it, and then we can talk about it:</p>
			<pre>void Bullet::shoot(float startX, float startY,
    float targetX, float targetY)
{
    // Keep track of the bullet
    m_InFlight = true;
    m_Position.x = startX;
    m_Position.y = startY;
    // Calculate the gradient of the flight path
    float gradient = (startX - targetX) / (startY - targetY);
    // Any gradient less than 1 needs to be negative
    if (gradient &lt; 0)
    {
        gradient *= -1;
    }
    // Calculate the ratio between x and y
    float ratioXY = m_BulletSpeed / (1 + gradient);
    // Set the "speed" horizontally and vertically
    m_BulletDistanceY = ratioXY;
    m_BulletDistanceX = ratioXY * gradient;
    
    // Point the bullet in the right direction
    if (targetX &lt; startX)
    {
        m_BulletDistanceX *= -1;
    }
    if (targetY &lt; startY)
    {
        m_BulletDistanceY *= -1;
    }
    
    // Set a max range of 1000 pixels
    float range = 1000;
    m_MinX = startX - range;
    m_MaxX = startX + range;
    m_MinY = startY - range;
    m_MaxY = startY + range;
    
    // Position the bullet ready to be drawn
    m_BulletShape.setPosition(m_Position);
}</pre>
			<p>In order to demystify the <code>shoot</code> function, we will split it up and talk about the code we have just added in chunks.</p>
			<p>First, let's remind ourselves about the signature. The <code>shoot</code> function receives the starting and target horizontal and vertical positions of a bullet. The calling code will supply these based on the position of the player sprite and the position of the crosshair. Here it is again:</p>
			<pre>void Bullet::shoot(float startX, float startY,
    float targetX, float targetY)</pre>
			<p>Inside the <code>shoot</code> function, we set <code>m_InFlight</code> to <code>true</code> and position the bullet using the <code>startX</code> and <code>startY</code> parameters. Here is that piece of code again:</p>
			<pre>// Keep track of the bullet
m_InFlight = true;
m_Position.x = startX;
m_Position.y = startY;</pre>
			<p>Now, we use a bit of trigonometry to determine the gradient of travel for a bullet. The progression of the bullet, both horizontally and vertically, must vary based on the slope of the line that's created by drawing between the start and target of a bullet. The rate of change cannot be the same or very steep shots will arrive at the horizontal location before the vertical location, and vice versa for shallow shots.</p>
			<p>The code that follows derives the gradient based on the equation of a line. Then, it checks whether the gradient is less than zero and if it is, multiplies it by -1. This is because the start and target coordinates that are passed in can be negative or positive, and we always want the amount of progression each frame to be positive. Multiplying by -1 simply makes the negative number into its positive equivalent because a minus multiplied by a minus gives a positive. The actual direction of travel will be handled in the <code>update</code> function by adding or subtracting the positive values we arrive at in this function.</p>
			<p>Next, we calculate a ratio of horizontal to vertical distance by dividing our bullet's speed (<code>m_BulletSpeed</code>) by one, plus the gradient. This will allow us to change the bullet's horizontal and vertical position by the correct amount each frame, based on the target the bullet is heading toward.</p>
			<p>Finally, in this part of the code, we assign the values to <code>m_BulletDistanceY</code> and <code>m_BulletDistanceX</code>:</p>
			<pre>// Calculate the gradient of the flight path
float gradient = (startX - targetX) / (startY - targetY);
// Any gradient less than zero needs to be negative
if (gradient &lt; 0)
{
    gradient *= -1;
}
// Calculate the ratio between x and y
float ratioXY = m_BulletSpeed / (1 + gradient);
// Set the "speed" horizontally and vertically
m_BulletDistanceY = ratioXY;
m_BulletDistanceX = ratioXY * gradient;</pre>
			<p>The following code is much more straightforward. We simply set a maximum horizontal and vertical location that the bullet can reach. We don't want a bullet carrying on forever. In the update function, we will see whether a bullet has passed its maximum or minimum locations:</p>
			<pre>// Set a max range of 1000 pixels in any direction
float range = 1000;
m_MinX = startX - range;
m_MaxX = startX + range;
m_MinY = startY - range;
m_MaxY = startY + range;</pre>
			<p>The following code moves the sprite that represents the bullet to its starting location. We use the <code>setPosition</code> function of <code>Sprite</code>, as we have often done before:</p>
			<pre>// Position the bullet ready to be drawn
m_BulletShape.setPosition(m_Position);</pre>
			<p>Next, we have four straightforward functions. Let's add the <code>stop</code>, <code>isInFlight</code>, <code>getPosition</code>, and <code>getShape</code> functions:</p>
			<pre>void Bullet::stop()
{
    m_InFlight = false;
}
bool Bullet::isInFlight()
{
    return m_InFlight;
}
FloatRect Bullet::getPosition()
{
    return m_BulletShape.getGlobalBounds();
}
RectangleShape Bullet::getShape()
{
    return m_BulletShape;
}</pre>
			<p>The <code>stop</code> function simply sets the <code>m_InFlight</code> variable to <code>false</code>. The <code>isInFlight</code> function returns whatever the value of this same variable currently is. So, we can see that <code>shoot</code> sets the bullet going, <code>stop</code> makes it stop, and <code>isInFlight</code> informs us what the current state is.</p>
			<p>The <code>getPosition</code> function returns a <code>FloatRect</code>. We will see how we can use the <code>FloatRect</code> from each game object to detect collisions soon.</p>
			<p>Finally, for the previous code, <code>getShape</code> returns a <code>RectangleShape</code> so that we can draw the bullet once each frame.</p>
			<p>The last function we need to implement before we can start using <code>Bullet</code> objects is <code>update</code>. Add the following code, study it, and then we can talk about it:</p>
			<pre>void Bullet::update(float elapsedTime)
{
    // Update the bullet position variables
    m_Position.x += m_BulletDistanceX * elapsedTime;
    m_Position.y += m_BulletDistanceY * elapsedTime;
    // Move the bullet
    m_BulletShape.setPosition(m_Position);
    // Has the bullet gone out of range?
    if (m_Position.x &lt; m_MinX || m_Position.x &gt; m_MaxX ||
        m_Position.y &lt; m_MinY || m_Position.y &gt; m_MaxY)
    {
        m_InFlight = false;
    }
}</pre>
			<p>In the <code>update</code> function, we use <code>m_BulletDistanceX</code> and <code>m_BulletDistanceY</code>, multiplied by the time since the last frame to move the bullet. Remember that the values of the two variables were calculated in the <code>shoot</code> function and represent the gradient (ratio to each other) that's required to move the bullet at just the right angle. Then, we use the <code>setPosition</code> function to actually move <code>RectangleShape</code>.</p>
			<p>The last thing we do in <code>update</code> is a test to see whether the bullet has moved beyond its maximum range. The slightly convoluted <code>if</code> statement checks <code>m_Position.x</code> and <code>m_Position.y</code> against the maximum and minimum values that were calculated in the <code>shoot</code> function. These maximum and minimum values are stored in <code>m_MinX</code>, <code>m_MaxX</code>, <code>m_MinY</code>, and <code>m_MaxY</code>. If the test is true, then <code>m_InFlight</code> is set to <code>false</code>.</p>
			<p>The <code>Bullet</code> class is done. Now, we will look at how we can shoot some in the <code>main</code> function.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor253"/>Making the bullets fly</h1>
			<p>We will make the bullets usable by following these six steps:</p>
			<ol>
				<li value="1">Add the necessary include directive for the <code>Bullet</code> class.</li>
				<li>Add some control variables and an array to hold some <code>Bullet</code> instances.</li>
				<li>Handle the player pressing <em class="italic">R</em> to reload.</li>
				<li>Handle the player pressing the left mouse button to fire a bullet.</li>
				<li>Update all bullets that are in flight in each frame.</li>
				<li>Draw the bullets that are in flight in each frame.</li>
			</ol>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor254"/>Including the Bullet class</h2>
			<p>Add the include directive to make the Bullet class available:</p>
			<pre>#include &lt;SFML/Graphics.hpp&gt;
#include "ZombieArena.h"
#include "Player.h"
#include "TextureHolder.h"
<strong class="bold">#include "Bullet.h"</strong>
using namespace sf;</pre>
			<p>Let's move on to the next step.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor255"/>Control variables and the bullet array</h2>
			<p>Here are some variables to keep track of clip sizes, spare bullets, bullets, the remaining bullets in the clip, the current rate of fire (starting at one per second), and the time when the last bullet was fired.</p>
			<p>Add the following highlighted code. Then, we can move on and see all these variables in action throughout the rest of this section:</p>
			<pre>// Prepare for a horde of zombies
int numZombies;
int numZombiesAlive;
Zombie* zombies = NULL;
<strong class="bold">// 100 bullets should do</strong>
<strong class="bold">Bullet bullets[100];</strong>
<strong class="bold">int currentBullet = 0;</strong>
<strong class="bold">int bulletsSpare = 24;</strong>
<strong class="bold">int bulletsInClip = 6;</strong>
<strong class="bold">int clipSize = 6;</strong>
<strong class="bold">float fireRate = 1;</strong>
<strong class="bold">// When was the fire button last pressed?</strong>
<strong class="bold">Time lastPressed;</strong>
// The main game loop
while (window.isOpen())</pre>
			<p>Next, let's handle what happens when the player presses the <em class="italic">R</em> keyboard key, which is used for reloading a clip.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor256"/>Reloading the gun</h2>
			<p>Now, we will handle the player input related to shooting bullets. First, we will handle pressing the <em class="italic">R</em> key to reload the gun. We will do so with an SFML event.</p>
			<p>Add the following highlighted code. It is shown with lots of context to make sure the code goes in the right place. Study the code and then we can talk about it:</p>
			<pre>// Handle events
Event event;
while (window.pollEvent(event))
{
    if (event.type == Event::KeyPressed)
    {
        // Pause a game while playing
        if (event.key.code == Keyboard::Return &amp;&amp;
            state == State::PLAYING)
        {
            state = State::PAUSED;
        }
        // Restart while paused
        else if (event.key.code == Keyboard::Return &amp;&amp;
            state == State::PAUSED)
        {
            state = State::PLAYING;
            // Reset the clock so there isn't a frame jump
            clock.restart();
        }
        // Start a new game while in GAME_OVER state
        else if (event.key.code == Keyboard::Return &amp;&amp;
            state == State::GAME_OVER)
        {
            state = State::LEVELING_UP;
        }
        if (state == State::PLAYING)
        {
<strong class="bold">            // Reloading</strong>
<strong class="bold">            if (event.key.code == Keyboard::R)</strong>
<strong class="bold">            {</strong>
<strong class="bold">                if (bulletsSpare &gt;= clipSize)</strong>
<strong class="bold">                {</strong>
<strong class="bold">                    // Plenty of bullets. Reload.</strong>
<strong class="bold">                    bulletsInClip = clipSize;</strong>
<strong class="bold">                    bulletsSpare -= clipSize;                            </strong>
<strong class="bold">                }</strong>
<strong class="bold">                else if (bulletsSpare &gt; 0)</strong>
<strong class="bold">                {</strong>
<strong class="bold">                    // Only few bullets left</strong>
<strong class="bold">                    bulletsInClip = bulletsSpare;</strong>
<strong class="bold">                    bulletsSpare = 0;                            </strong>
<strong class="bold">                }</strong>
<strong class="bold">                else</strong>
<strong class="bold">                {</strong>
<strong class="bold">                    // More here soon?!</strong>
<strong class="bold">                }</strong>
<strong class="bold">            }</strong>
        }
    }
}// End event polling</pre>
			<p>The previous code is nested within the event handling part of the game loop (<code>while(window.pollEvent)</code>), within the block that only executes when the game is actually being played (<code>if(state == State::Playing)</code>). It is obvious that we don't want the player reloading when the game has finished or is paused, and wrapping the new code as we've described achieves this.</p>
			<p>In the new code itself, the first thing we do is test for the <em class="italic">R</em> key being pressed with <code>if (event.key.code == Keyboard::R)</code>. Once we have detected that the <em class="italic">R</em> key was pressed, the remaining code is executed. Here is the structure of the <code>if</code>, <code>else if</code>, and <code>else</code> blocks:</p>
			<pre>if(bulletsSpare &gt;= clipSize)
    ...
else if(bulletsSpare &gt; 0)
    ...
else
    ...</pre>
			<p>The previous structure allows us to handle three possible scenarios, as shown here:</p>
			<ul>
				<li>The player has pressed <code>R</code> and they have more bullets spare than the clip can take. In this scenario, the clip is refilled, and the number of spare bullets is reduced.</li>
				<li>The player has some spare bullets but not enough to fill the clip completely. In this scenario, the clip is filled with as many spare bullets as the player has and the number of spare bullets is set to zero.</li>
				<li>The player has pressed <em class="italic">R</em> but they have no spare bullets at all. For this scenario, we don't actually need to alter the variables. However, we will play a sound effect here when we implement the sound in <a href="B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279"><em class="italic">Chapter 13</em></a>,<em class="italic"> Sound Effects, File I/O, and Finishing the Game</em>, so we will leave the empty <code>else</code> block ready.</li>
			</ul>
			<p>Now, let's shoot a bullet.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor257"/>Shooting a bullet</h2>
			<p>Here, we will handle the left mouse button being clicked to fire a bullet. Add the following highlighted code and study it carefully:</p>
			<pre>    if (Keyboard::isKeyPressed(Keyboard::D))
    {
        player.moveRight();
    }
    else
    {
        player.stopRight();
    }
<strong class="bold">    // Fire a bullet</strong>
<strong class="bold">    if (Mouse::isButtonPressed(sf::Mouse::Left))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        if (gameTimeTotal.asMilliseconds()</strong>
<strong class="bold">            - lastPressed.asMilliseconds()</strong>
<strong class="bold">            &gt; 1000 / fireRate &amp;&amp; bulletsInClip &gt; 0)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            // Pass the centre of the player </strong>
<strong class="bold">            // and the centre of the cross-hair</strong>
<strong class="bold">            // to the shoot function</strong>
<strong class="bold">            bullets[currentBullet].shoot(</strong>
<strong class="bold">                player.getCenter().x, player.getCenter().y,</strong>
<strong class="bold">                mouseWorldPosition.x, mouseWorldPosition.y);</strong>
<strong class="bold">            currentBullet++;</strong>
<strong class="bold">            if (currentBullet &gt; 99)</strong>
<strong class="bold">            {</strong>
<strong class="bold">                currentBullet = 0;</strong>
<strong class="bold">            }</strong>
<strong class="bold">            lastPressed = gameTimeTotal;</strong>
<strong class="bold">            bulletsInClip--;</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }// End fire a bullet</strong>
}// End WASD while playing</pre>
			<p>All the previous code is wrapped in an <code>if </code>statement that executes whenever the left mouse button is pressed, that is, <code>if (Mouse::isButtonPressed(sf::Mouse::Left))</code>. Note that the code will execute repeatedly, even if the player just holds down the button. The code we will go through now controls the rate of fire.</p>
			<p>In the preceding code, we then check whether the total time elapsed in the game (<code>gameTimeTotal</code>) minus the time the player last shot a bullet (<code>lastPressed</code>) is greater than 1,000, divided by the current rate of fire and that the player has at least one bullet in the clip. We use 1,000 because this is the number of milliseconds in a second.</p>
			<p>If this test is successful, the code that actually fires a bullet is executed. Shooting a bullet is easy because we did all the hard work in the <code>Bullet</code> class. We simply call <code>shoot </code>on the current bullet from the <code>bullets</code> array. We pass in the player's and the cross-hair's current horizontal and vertical locations. The bullet will be configured and set in flight by the code in the <code>shoot</code> function of the <code>Bullet</code> class.</p>
			<p>All we must do is keep track of the array of bullets. We incremented the <code>currentBullet</code> variable. Then, we need to check to see whether we fired the last bullet (99) with the <code>if (currentBullet &gt; 99)</code> statement. If it was the last bullet, we set <code>currentBullet</code> to zero. If it wasn't the last bullet, then the next bullet is ready to go whenever the rate of fire permits it and the player presses the left mouse button.</p>
			<p>Finally, in the preceding code, we store the time that the bullet was fired into <code>lastPressed</code> and decrement <code>bulletsInClip</code>.</p>
			<p>Now, we can update every bullet, each frame.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor258"/>Updating the bullets each frame</h2>
			<p>Add the following highlighted code to loop through the bullets array, check whether the bullet is in flight, and if it is, call its update function:</p>
			<pre>    // Loop through each Zombie and update them
    for (int i = 0; i &lt; numZombies; i++)
    {
        if (zombies[i].isAlive())
        {
            zombies[i].update(dt.asSeconds(), playerPosition);
        }
    }
<strong class="bold">    // Update any bullets that are in-flight</strong>
<strong class="bold">    for (int i = 0; i &lt; 100; i++)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        if (bullets[i].isInFlight())</strong>
<strong class="bold">        {</strong>
<strong class="bold">            bullets[i].update(dtAsSeconds);</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
}// End updating the scene</pre>
			<p>Finally, we will draw all the bullets. </p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor259"/>Drawing the bullets each frame</h2>
			<p>Add the following highlighted code to loop through the <code>bullets</code> array, check whether the bullet is in flight, and if it is, draw it:</p>
			<pre>/*
 **************
 Draw the scene
 **************
 */
if (state == State::PLAYING)
{
    window.clear();
    // set the mainView to be displayed in the window
    // And draw everything related to it
    window.setView(mainView);
    // Draw the background
    window.draw(background, &amp;textureBackground);
    // Draw the zombies
    for (int i = 0; i &lt; numZombies; i++)
    {
        window.draw(zombies[i].getSprite());
    }
<strong class="bold">    for (int i = 0; i &lt; 100; i++)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        if (bullets[i].isInFlight())</strong>
<strong class="bold">        {</strong>
<strong class="bold">            window.draw(bullets[i].getShape());</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
    // Draw the player
    window.draw(player.getSprite());
}</pre>
			<p>Run the game to try out the bullets. Notice that you can fire six shots before you need to press <em class="italic">R</em> to reload. The obvious things that are missing is some visual indicator of the number of bullets in the clip and the number of spare bullets. Another problem is that the player can very quickly run out of bullets, especially since the bullets have no stopping power whatsoever. They fly straight through the zombies. Add to this that the player is expected to aim at a mouse pointer instead of a precision crosshair and it is clear that we have work to do.</p>
			<p>In the next chapter, we will give visual feedback through a HUD. We will replace the mouse cursor with a crosshair next and then spawn some pickups to replenish bullets and health after that. Finally, in this chapter, we will handle collision detection to make the bullets and the zombies do damage and make the player able to actually get the pickups.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor260"/>Giving the player a crosshair</h1>
			<p>Adding a crosshair is easy and only requires one new concept. Add the following highlighted code, and then we can run through it:</p>
			<pre>// 100 bullets should do
Bullet bullets[100];
int currentBullet = 0;
int bulletsSpare = 24;
int bulletsInClip = 6;
int clipSize = 6;
float fireRate = 1;
// When was the fire button last pressed?
Time lastPressed;
<strong class="bold">// Hide the mouse pointer and replace it with crosshair</strong>
<strong class="bold">window.setMouseCursorVisible(true);</strong>
<strong class="bold">Sprite spriteCrosshair;</strong>
<strong class="bold">Texture textureCrosshair = TextureHolder::GetTexture("graphics/crosshair.png");</strong>
<strong class="bold">spriteCrosshair.setTexture(textureCrosshair);</strong>
<strong class="bold">spriteCrosshair.setOrigin(25, 25);</strong>
// The main game loop
while (window.isOpen())</pre>
			<p>First, we call the <code>setMouseCursorVisible</code> function on our <code>window</code> object. We then load a <code>Texture</code> and declare a <code>Sprite</code> instance and initialize it in the usual way. Furthermore, we set the sprite's origin to its center to make it convenient and simpler to make the bullets fly to the middle, as you would expect to happen.</p>
			<p>Now, we need to update the crosshair each frame with the world coordinates of the mouse. Add the following highlighted line of code, which uses the <code>mouseWorldPosition</code> vector to set the crosshair's position each frame:</p>
			<pre>/*
 ****************
 UPDATE THE FRAME
 ****************
 */
if (state == State::PLAYING)
{
    // Update the delta time
    Time dt = clock.restart();
    // Update the total game time
    gameTimeTotal += dt;
    // Make a decimal fraction of 1 from the delta time
    float dtAsSeconds = dt.asSeconds();
    // Where is the mouse pointer
    mouseScreenPosition = Mouse::getPosition();
    // Convert mouse position to world coordinates of mainView
    mouseWorldPosition = window.mapPixelToCoords(
        Mouse::getPosition(), mainView);
<strong class="bold">    // Set the crosshair to the mouse world location</strong>
<strong class="bold">    spriteCrosshair.setPosition(mouseWorldPosition);</strong>
    // Update the player
    player.update(dtAsSeconds, Mouse::getPosition());</pre>
			<p>Next, as you have probably come to expect, we can draw the crosshair each frame. Add the following highlighted line of code in the position shown. This line of code needs no explanation, but its position after all the other game objects is important, so it is drawn on top:</p>
			<pre>/*
 **************
 Draw the scene
 **************
 */
if (state == State::PLAYING)
{
    window.clear();
    // set the mainView to be displayed in the window
    // And draw everything related to it
    window.setView(mainView);
    // Draw the background
    window.draw(background, &amp;textureBackground);
    // Draw the zombies
    for (int i = 0; i &lt; numZombies; i++)
    {
        window.draw(zombies[i].getSprite());
    }
    for (int i = 0; i &lt; 100; i++)
    {
        if (bullets[i].isInFlight())
        {
            window.draw(bullets[i].getShape());
        }
    }
    // Draw the player
    window.draw(player.getSprite());
<strong class="bold">    //Draw the crosshair</strong>
<strong class="bold">    window.draw(spriteCrosshair);</strong>
}</pre>
			<p>Now, you can run the game and will see a cool crosshair instead of a mouse cursor:</p>
			<div><div><img src="img/B14278_11_01.jpg" alt=""/>
				</div>
			</div>
			<p>Notice how the bullet fires neatly through the center of the crosshair. The way the shooting mechanism works is analogous to allowing the player to choose to shoot from the hip or aim down the sights. If the player keeps the crosshair close to the center, they can fire and turn rapidly, yet must carefully judge the position of distant zombies.</p>
			<p>Alternatively, the player can hover their crosshair directly over the head of a distant zombie and score a precise hit; however, they then have much further to move the crosshair back if a zombie attacks from another direction.</p>
			<p>An interesting improvement to the game would be to add a small random amount of inaccuracy to each shot. This inaccuracy could perhaps be mitigated with an upgrade between waves.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor261"/>Coding a class for pickups</h1>
			<p>In this section, we will code a <code>Pickup</code> class that has a <code>Sprite</code> member, as well as other member data and functions. We will add pickups to our game in just a few steps:</p>
			<ol>
				<li value="1">First, we will code the <code>Pickup.h</code> file. This will reveal all the details of the member data and the prototypes for the functions.</li>
				<li>Then, we will code the <code>Pickup.cpp</code> file which, of course, will contain the definitions for all the functions of the <code>Pickup</code> class. As we step through this, I will explain exactly how an object of the <code>Pickup</code> type will work and be controlled.</li>
				<li>Finally, we will use the <code>Pickup</code> class in the <code>main</code> function to spawn them, update them, and draw them.</li>
			</ol>
			<p>Let's get started with step 1.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor262"/>Coding the Pickup header file</h2>
			<p>To make the new header file, right-click <code>Pickup.h</code>.</p>
			<p>Add and study the following code to the <code>Pickup.h</code> file and then we can go through it:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
class Pickup
{
private:
    //Start value for health pickups
    const int HEALTH_START_VALUE = 50;
    const int AMMO_START_VALUE = 12;
    const int START_WAIT_TIME = 10;
    const int START_SECONDS_TO_LIVE = 5;
    
    // The sprite that represents this pickup
    Sprite m_Sprite;
    // The arena it exists in
    IntRect m_Arena;
    // How much is this pickup worth?
    int m_Value;
    
    // What type of pickup is this? 
    // 1 = health, 2 = ammo
    int m_Type;
    // Handle spawning and disappearing
    bool m_Spawned;
    float m_SecondsSinceSpawn;
    float m_SecondsSinceDeSpawn;
    float m_SecondsToLive;
    float m_SecondsToWait;    
// Public prototypes go here
};</pre>
			<p>The previous code declares all the private variables of the <code>Pickup</code> class. Although the names should be quite intuitive, it might not be obvious why many of them are needed at all. Let's go through them, starting from the top:</p>
			<ul>
				<li><code>const int HEALTH_START_VALUE = 50</code>: This constant variable is used to set the starting value of all health pickups. The value will be used to initialize the <code>m_Value </code>variable, which will need to be manipulated throughout the course of a game.</li>
				<li><code>const int AMMO_START_VALUE = 12</code>: This constant variable is used to set the starting value of all ammo pickups. The value will be used to initialize the <code>m_Value</code> variable, which will need to be manipulated throughout the course of a game.</li>
				<li><code>const int START_WAIT_TIME = 10</code>: This variable determines how long a pickup will wait before it respawns after disappearing. It will be used to initialize the <code>m_SecondsToWait</code> variable, which can be manipulated throughout the game.</li>
				<li><code>const int START_SECONDS_TO_LIVE = 5</code>: This variable determines how long a pickup will last between spawning and being de-spawned. Like the previous three constants, it has a non-constant associated with it that can be manipulated throughout the course of the game. The non-constant it's used to initialize is <code>m_SecondsToLive</code>.</li>
				<li><code>Sprite m_Sprite</code>: This is the sprite to visually represent the object.</li>
				<li><code>IntRect m_Arena</code>: This will hold the size of the current arena to help the pickup to spawn in a sensible position.</li>
				<li><code>int m_Value</code>: How much health or ammo is this pickup worth? This value is used when the player levels up the value of the health or ammo pickup.</li>
				<li><code>int m_Type</code>: This will be either 1 or 2 for health or ammo, respectively. We could have used an enumeration class, but that seemed like overkill for just two options.</li>
				<li><code>bool m_Spawned</code>: Is the pickup currently spawned?</li>
				<li><code>float m_SecondsSinceSpawn</code>: How long is it since the pickup was spawned?</li>
				<li><code>float m_SecondsSinceDeSpawn</code>: How long is it since the pickup was de-spawned (disappeared)?</li>
				<li><code>float m_SecondsToLive</code>: How long should this pickup stay spawned before de-spawning?</li>
				<li><code>float m_SecondsToWait</code>: How long should this pickup stay de-spawned before respawning?<p class="callout-heading">Tip</p><p class="callout">Note that most of the complexity of this class is due to the variable spawn time and its upgradeable nature. If the pickups just respawned when collected and had a fixed value, this would be a very simple class. We need our pickups to be upgradeable so that the player is forced to develop a strategy to progress through the waves.</p></li>
			</ul>
			<p>Next, add the following public function prototypes to the <code>Pickup.h</code> file. Be sure to familiarize yourself with the new code so that we can go through it:</p>
			<pre>// Public prototypes go here
<strong class="bold">public:</strong>
<strong class="bold">    Pickup::Pickup(int type);</strong>
<strong class="bold">    // Prepare a new pickup</strong>
<strong class="bold">    void setArena(IntRect arena);</strong>
<strong class="bold">    void spawn();</strong>
<strong class="bold">    // Check the position of a pickup</strong>
<strong class="bold">    FloatRect getPosition();</strong>
<strong class="bold">    // Get the sprite for drawing</strong>
<strong class="bold">    Sprite getSprite();</strong>
<strong class="bold">    // Let the pickup update itself each frame</strong>
<strong class="bold">    void update(float elapsedTime);</strong>
<strong class="bold">    // Is this pickup currently spawned?</strong>
<strong class="bold">    bool isSpawned();</strong>
<strong class="bold">    // Get the goodness from the pickup</strong>
<strong class="bold">    int gotIt();</strong>
<strong class="bold">    // Upgrade the value of each pickup</strong>
<strong class="bold">    void upgrade();</strong>
};</pre>
			<p>Let's talk briefly about each of the function definitions.</p>
			<ul>
				<li>The first function is the constructor and is named after the class. Note that it takes a single <code>int</code> parameter. This will be used to initialize the type of pickup it will be (health or ammo).</li>
				<li>The <code>setArena</code> function receives an <code>IntRect</code>. This function will be called for each <code>Pickup</code> instance at the start of each wave. The <code>Pickup</code> objects will then "know" the areas into which they can spawn.</li>
				<li>The <code>spawn</code> function will, of course, handle spawning the pickup.</li>
				<li>The <code>getPosition</code> function, just like in the <code>Player</code>, <code>Zombie</code>, and <code>Bullet</code> classes, will return a <code>FloatRect</code> instance that represents the current location of the object in the game world.</li>
				<li>The <code>getSprite</code> function returns a <code>Sprite</code> object that allows the pickup to be drawn once each frame.</li>
				<li>The <code>update</code> function receives the time the previous frame took. It uses this value to update its private variables and make decisions about when to spawn and de-spawn.</li>
				<li>The <code>isSpawned</code> function returns a Boolean that will let the calling code know whether or not the pickup is currently spawned.</li>
				<li>The <code>gotIt</code> function will be called when a collision is detected with the player. The code of the <code>Pickup</code> class can then prepare itself for respawning at the appropriate time. Note that it returns an <code>int</code> value so that the calling code knows how much the pickup is "worth" in either health or ammo. </li>
				<li>The <code>upgrade</code> function will be called when the player chooses to level up the properties of a pickup during the leveling up phase of the game.</li>
			</ul>
			<p>Now that we have gone through the member variables and function prototypes, it should be quite easy to follow along as we code the function definitions. </p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor263"/>Coding the Pickup class function definitions</h2>
			<p>Now, we can create a new <code>.cpp</code> file that will contain the function definitions. Right-click <code>Pickup.cpp</code>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the class.</p>
			<p>Add the following code to the <code>Pickup.cpp</code> file. Be sure to review the code so that we can discuss it:</p>
			<pre>#include "Pickup.h"
#include "TextureHolder.h"
Pickup::Pickup(int type)
{
    // Store the type of this pickup
    m_Type = type;
    // Associate the texture with the sprite
    if (m_Type == 1)
    {
        m_Sprite = Sprite(TextureHolder::GetTexture(
            "graphics/health_pickup.png"));
        // How much is pickup worth
        m_Value = HEALTH_START_VALUE;
    }
    else
    {
        m_Sprite = Sprite(TextureHolder::GetTexture(
            "graphics/ammo_pickup.png"));
        // How much is pickup worth
        m_Value = AMMO_START_VALUE;
    }
    m_Sprite.setOrigin(25, 25);
    m_SecondsToLive = START_SECONDS_TO_LIVE;
    m_SecondsToWait = START_WAIT_TIME;
}</pre>
			<p>In the previous code, we added the familiar include directives. Then, we added the <code>Pickup</code> constructor. We know it is the constructor because it has the same name as the class.</p>
			<p>The constructor receives an <code>int</code> called <code>type</code> and the first thing the code does is assign the value that's received from <code>type</code> to <code>m_Type</code>. After this, there is an <code>if else</code> block that checks whether <code>m_Type</code> is equal to 1. If it is, <code>m_Sprite</code> is associated with the health pickup texture and <code>m_Value</code> is set to <code>HEALTH_START_VALUE</code>.</p>
			<p>If <code>m_Type</code> is not equal to 1, the <code>else</code> block associates the ammo pickup texture with <code>m_Sprite</code> and assigns the value of <code>AMMO_START_VALUE</code> to <code>m_Value</code>.</p>
			<p>After the <code>if</code> <code>else</code> block, the code sets the origin of <code>m_Sprite</code> to the center using the <code>setOrigin</code> function and assigns <code>START_SECONDS_TO_LIVE</code> and <code>START_WAIT_TIME</code> to <code>m_SecondsToLive</code> and <code>m_SecondsToWait</code>, respectively. </p>
			<p>The constructor has successfully prepared a <code>Pickup</code> object that is ready for use.</p>
			<p>Now, we will add the <code>setArena</code> function. Examine the code as you add it:</p>
			<pre>void Pickup::setArena(IntRect arena)
{
    // Copy the details of the arena to the pickup's m_Arena
    m_Arena.left = arena.left + 50;
    m_Arena.width = arena.width - 50;
    m_Arena.top = arena.top + 50;
    m_Arena.height = arena.height - 50;
    spawn();
}</pre>
			<p>The <code>setArena</code> function that we just coded simply copies the values from the passed in <code>arena</code> object but varies the values by <code>+ 50</code> on the left and top and <code>- 50</code> on the right and bottom. The <code>Pickup</code> object is now aware of the area in which it can spawn. The <code>setArena</code> function then calls its own <code>spawn</code> function to make the final preparations for being drawn and updated each frame.</p>
			<p>The <code>spawn</code> function is next. Add the following code after the <code>setArena</code> function:</p>
			<pre>void Pickup::spawn()
{
    // Spawn at a random location
    srand((int)time(0) / m_Type);
    int x = (rand() % m_Arena.width);
    srand((int)time(0) * m_Type);
    int y = (rand() % m_Arena.height);
    m_SecondsSinceSpawn = 0;
    m_Spawned = true;
    m_Sprite.setPosition(x, y);
}</pre>
			<p>The <code>spawn</code> function does everything necessary to prepare the pickup. First, it seeds the random number generator and gets a random number for both the horizontal and vertical position of the object. Notice that it uses the <code>m_Arena.width</code> and <code>m_Arena.height</code> variables as the ranges for the possible horizontal and vertical positions.</p>
			<p>The <code>m_SecondsSinceSpawn</code> variable is set to zero so that the length of time that's allowed before it is de-spawned is reset. The <code>m_Spawned</code> variable is set to <code>true</code> so that, when we call <code>isSpawned</code>, from <code>main</code>, we will get a positive response. Finally, <code>m_Sprite</code> is moved into position with <code>setPosition</code>, ready for being drawn to the screen.</p>
			<p>In the following block of code, we have three simple getter functions. The <code>getPosition</code> function returns a <code>FloatRect</code> of the current position of <code>m_Sprite</code>, <code>getSprite</code> returns a copy of <code>m_Sprite</code> itself, and <code>isSpawned</code> returns <code>true</code> or <code>false</code>, depending on whether the object is currently spawned. </p>
			<p>Add and examine the code we have just discussed:</p>
			<pre>FloatRect Pickup::getPosition()
{
    return m_Sprite.getGlobalBounds();
}
Sprite Pickup::getSprite()
{
    return m_Sprite;
}
bool Pickup::isSpawned()
{
    return m_Spawned;
}</pre>
			<p>Next, we will code the <code>gotIt</code> function. This function will be called from <code>main</code> when the player touches/collides (gets) with the pickup. Add the <code>gotIt</code> function after the <code>isSpawned</code> function:</p>
			<pre>int Pickup::gotIt()
{
    m_Spawned = false;
    m_SecondsSinceDeSpawn = 0;
    return m_Value;
}</pre>
			<p>The <code>gotIt</code> function sets <code>m_Spawned</code> to <code>false</code> so that we know not to draw and check for collisions anymore. <code>m_SecondsSinceDespawn</code> is set to zero so that the countdown to spawning begins again from the start. <code>m_Value</code> is then returned to the calling code so that the calling code can handle adding extra ammunition or health, as appropriate.</p>
			<p>Following this, we need to code the <code>update</code> function, which ties together many of the variables and functions we have seen so far. Add and familiarize yourself with the <code>update</code> function, and then we can talk about it:</p>
			<pre>void Pickup::update(float elapsedTime)
{
    if (m_Spawned)
    {
        m_SecondsSinceSpawn += elapsedTime;
    }
    else
    {
        m_SecondsSinceDeSpawn += elapsedTime;
    }
    // Do we need to hide a pickup?
    if (m_SecondsSinceSpawn &gt; m_SecondsToLive &amp;&amp; m_Spawned)
    {
        // Remove the pickup and put it somewhere else
        m_Spawned = false;
        m_SecondsSinceDeSpawn = 0;
    }
    // Do we need to spawn a pickup
    if (m_SecondsSinceDeSpawn &gt; m_SecondsToWait &amp;&amp; !m_Spawned)
    {
        // spawn the pickup and reset the timer
        spawn();
    }
}</pre>
			<p>The <code>update</code> function is divided into four blocks that are considered for execution each frame:</p>
			<ol>
				<li value="1">An <code>if</code> block that executes if <code>m_Spawned</code> is true: <code>if (m_Spawned)</code>. This block of code adds the time this frame to <code>m_SecondsSinceSpawned</code>, which keeps track of how long the pickup has been spawned.</li>
				<li>A corresponding <code>else</code> block that executes if <code>m_Spawned</code> is false. This block adds the time this frame took to <code>m_SecondsSinceDeSpawn</code>, which keeps track of how long the pickup has waited since it was last de-spawned (hidden).</li>
				<li>Another <code>if</code> block that executes when the pickup has been spawned for longer than it should have been: <code>if (m_SecondsSinceSpawn &gt; m_SecondsToLive &amp;&amp; m_Spawned)</code>. This block sets <code>m_Spawned</code> to <code>false</code> and resets <code>m_SecondsSinceDeSpawn</code> to zero. Now, block 2 will execute until it is time to spawn it again.</li>
				<li>A final <code>if</code> block that executes when the time to wait since de-spawning has exceeded the necessary wait time, and the pickup is not currently spawned: <code>if (m_SecondsSinceDeSpawn &gt; m_SecondsToWait &amp;&amp; !m_Spawned)</code>. When this block is executed, it is time to spawn the pick up again, and the <code>spawn</code> function is called.</li>
			</ol>
			<p>These four tests are what control the hiding and showing of a pickup.</p>
			<p>Finally, add the definition for the <code>upgrade</code> function:</p>
			<pre>void Pickup::upgrade()
{
    if (m_Type == 1)
    {
        m_Value += (HEALTH_START_VALUE * .5);
    }
    else
    {
        m_Value += (AMMO_START_VALUE * .5);
    }
    // Make them more frequent and last longer
    m_SecondsToLive += (START_SECONDS_TO_LIVE / 10);
    m_SecondsToWait -= (START_WAIT_TIME / 10);
}</pre>
			<p>The <code>upgrade</code> function tests for the type of pickup, either health or ammo, and then adds 50% of the (appropriate) starting value on to <code>m_Value</code>. The next two lines after the <code>if</code> <code>else</code> blocks increase the amount of time the pickup will remain spawned and decreases the amount of time the player must wait between spawns.</p>
			<p>This function is called when the player chooses to level up the pickups during the <code>LEVELING_UP</code> state. </p>
			<p>Our <code>Pickup</code> class is ready for use.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor264"/>Using the Pickup class</h1>
			<p>After all that hard work implementing the <code>Pickup</code> class, we can now go ahead and write code in the game engine to put some pickups into the game.</p>
			<p>The first thing we will do is add an include directive to the <code>ZombieArena.cpp</code> file:</p>
			<pre>#include &lt;SFML/Graphics.hpp&gt;
#include "ZombieArena.h"
#include "Player.h"
#include "TextureHolder.h"
#include "Bullet.h"
<strong class="bold">#include "Pickup.h"</strong>
using namespace sf;</pre>
			<p>In this following code, we are adding two <code>Pickup</code> instances: one called <code>healthPickup</code> and another called <code>ammoPickup</code>. We pass the values 1 and 2, respectively, into the constructor so that they are initialized to the correct type of pickup. Add the following highlighted code, which we have just discussed:</p>
			<pre>// Hide the mouse pointer and replace it with crosshair
window.setMouseCursorVisible(true);
Sprite spriteCrosshair;
Texture textureCrosshair = TextureHolder::GetTexture(
         "graphics/crosshair.png");
spriteCrosshair.setTexture(textureCrosshair);
spriteCrosshair.setOrigin(25, 25);
<strong class="bold">// Create a couple of pickups</strong>
<strong class="bold">Pickup healthPickup(1);</strong>
<strong class="bold">Pickup ammoPickup(2);</strong>
// The main game loop
while (window.isOpen())</pre>
			<p>In the <code>LEVELING_UP</code> state of the keyboard handling, add the following highlighted lines within the nested <code>PLAYING</code> code block:</p>
			<pre>if (state == State::PLAYING)
{
    // Prepare the level
    // We will modify the next two lines later
    arena.width = 500;
    arena.height = 500;
    arena.left = 0;
    arena.top = 0;
    // Pass the vertex array by reference 
    // to the createBackground function
    int tileSize = createBackground(background, arena);
    // Spawn the player in the middle of the arena
    player.spawn(arena, resolution, tileSize);
<strong class="bold">    // Configure the pick-ups</strong>
<strong class="bold">    healthPickup.setArena(arena);</strong>
<strong class="bold">    ammoPickup.setArena(arena);</strong>
    // Create a horde of zombies
    numZombies = 10;
    // Delete the previously allocated memory (if it exists)
    delete[] zombies;
    zombies = createHorde(numZombies, arena);
    numZombiesAlive = numZombies;
    // Reset the clock so there isn't a frame jump
    clock.restart();
}</pre>
			<p>The preceding code simply passes <code>arena</code> into the <code>setArena</code> function of each pickup. The pickups now know where they can spawn. This code executes for each new wave, so, as the arena's size grows, the <code>Pickup</code> objects will get updated.</p>
			<p>The following code simply calls the <code>update</code> function for each <code>Pickup</code> object on each frame:</p>
			<pre>// Loop through each Zombie and update them
    for (int i = 0; i &lt; numZombies; i++)
    {
        if (zombies[i].isAlive())
        {
            zombies[i].update(dt.asSeconds(), playerPosition);
        }
    }
    // Update any bullets that are in-flight
    for (int i = 0; i &lt; 100; i++)
    {
        if (bullets[i].isInFlight())
        {
            bullets[i].update(dtAsSeconds);
        }
    }
<strong class="bold">    // Update the pickups</strong>
<strong class="bold">    healthPickup.update(dtAsSeconds);</strong>
<strong class="bold">    ammoPickup.update(dtAsSeconds);</strong>
}// End updating the scene</pre>
			<p>The following code in the draw part of the game loop checks whether the pickup is currently spawned and if it is, draws it. Let's add it:</p>
			<pre>    // Draw the player
    window.draw(player.getSprite());
<strong class="bold">    // Draw the pick-ups, if currently spawned</strong>
<strong class="bold">    if (ammoPickup.isSpawned())</strong>
<strong class="bold">    {</strong>
<strong class="bold">        window.draw(ammoPickup.getSprite());</strong>
<strong class="bold">    }</strong>
<strong class="bold">    </strong>
<strong class="bold">    if (healthPickup.isSpawned())</strong>
<strong class="bold">    {</strong>
<strong class="bold">        window.draw(healthPickup.getSprite());</strong>
<strong class="bold">    }</strong>
    //Draw the crosshair
    window.draw(spriteCrosshair);
}</pre>
			<p>Now, you can run the game and see the pickups spawn and de-spawn. You can't, however, actually pick them up yet:</p>
			<div><div><img src="img/B14278_11_02.jpg" alt=""/>
				</div>
			</div>
			<p>Now that we have all the objects in our game, it is a good time to make them interact (collide) with each other.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor265"/>Detecting collisions</h1>
			<p>We just need to know when certain objects from our game touch certain other objects. We can then respond to that event in an appropriate manner. In our classes, we have already added functions that will be called when our objects collide. They are as follows:</p>
			<ul>
				<li>The <code>Player</code> class has a <code>hit</code> function. We will call it when a zombie collides with the player.</li>
				<li>The <code>Zombie</code> class has a <code>hit</code> function. We will call it when a bullet collides with a zombie.</li>
				<li>The <code>Pickup</code> class has a <code>gotIt</code> function. We will call it when the player collides with a pickup.</li>
			</ul>
			<p>If necessary, look back to refresh your memory regarding how each of those functions works. All we need to do now is detect the collisions and call the appropriate functions. </p>
			<p>We will use <strong class="bold">rectangle intersection</strong> to detect collisions. This type of collision detection is straightforward (especially with SFML). We will use the same technique that we used in the Pong game. The following image shows how a rectangle can reasonably accurately represent the zombies and the player:</p>
			<div><div><img src="img/B14278_11_03.jpg" alt=""/>
				</div>
			</div>
			<p>We<a id="_idTextAnchor266"/> will deal with this in three sections of code that will all follow on from one another. They will all go at the end of the update part of our game engine.</p>
			<p>We need to know the answers to the following three questions for each frame:</p>
			<ol>
				<li value="1">Has a Zombie been shot?</li>
				<li>Has the player been touched by a Zombie?</li>
				<li>Has the player touched a pickup?</li>
			</ol>
			<p>First, let's add a couple more variables for <code>score</code> and <code>hiscore</code>. We can then change them when a zombie is killed. Add the following code:</p>
			<pre>// Create a couple of pickups
Pickup healthPickup(1);
Pickup ammoPickup(2);
<strong class="bold">// About the game</strong>
<strong class="bold">int score = 0;</strong>
<strong class="bold">int hiScore = 0;</strong>
// The main game loop
while (window.isOpen())</pre>
			<p>Now, let's start by detecting whether a zombie is colliding with a bullet.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor267"/>Has a zombie been shot?</h2>
			<p>The following code might look complicated but, when we step through it, we will see it is nothing we haven't seen before. Add the following code just after the call to update the pickups each frame. Then, we can go through it:</p>
			<pre>// Update the pickups
healthPickup.update(dtAsSeconds);
ammoPickup.update(dtAsSeconds);
<strong class="bold">// Collision detection</strong>
<strong class="bold">// Have any zombies been shot?</strong>
<strong class="bold">for (int i = 0; i &lt; 100; i++)</strong>
<strong class="bold">{</strong>
<strong class="bold">    for (int j = 0; j &lt; numZombies; j++)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        if (bullets[i].isInFlight() &amp;&amp; </strong>
<strong class="bold">            zombies[j].isAlive())</strong>
<strong class="bold">        {</strong>
<strong class="bold">            if (bullets[i].getPosition().intersects</strong>
<strong class="bold">                (zombies[j].getPosition()))</strong>
<strong class="bold">            {</strong>
<strong class="bold">                // Stop the bullet</strong>
<strong class="bold">                bullets[i].stop();</strong>
<strong class="bold">                // Register the hit and see if it was a kill</strong>
<strong class="bold">                if (zombies[j].hit()) </strong>
<strong class="bold">                {</strong>
<strong class="bold">                    // Not just a hit but a kill too</strong>
<strong class="bold">                    score += 10;</strong>
<strong class="bold">                    if (score &gt;= hiScore)</strong>
<strong class="bold">                    {</strong>
<strong class="bold">                        hiScore = score;</strong>
<strong class="bold">                    }</strong>
<strong class="bold">                    numZombiesAlive--;</strong>
<strong class="bold">                    // When all the zombies are dead (again)</strong>
<strong class="bold">                    if (numZombiesAlive == 0) {</strong>
<strong class="bold">                        state = State::LEVELING_UP;</strong>
<strong class="bold">                    }</strong>
<strong class="bold">                }    </strong>
<strong class="bold">                </strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
}// End zombie being shot</pre>
			<p>In the next section, we will see all the zombie and bullet collision detection code again. We will do so a bit at a time so that we can discuss it. First of all, notice the structure of the nested <code>for</code> loops in the preceding code (with some code stripped out), as shown again here:</p>
			<pre>// Collision detection
// Have any zombies been shot?
for (int i = 0; i &lt; 100; i++)
{
    for (int j = 0; j &lt; numZombies; j++)
    {
        ...
        ...
        ...
    }
}</pre>
			<p>The code loops through every bullet (0 to 99) for each and every zombie (0 to less than <code>numZombies</code>.).</p>
			<p>Within the nested <code>for</code> loops, we do the following.</p>
			<p>We check whether the current bullet is in flight and the current zombie is still alive with the following code:</p>
			<pre>if (bullets[i].isInFlight() &amp;&amp; zombies[j].isAlive())</pre>
			<p>Provided the zombie is alive and the bullet is in flight, we test for a rectangle intersection with the following code:</p>
			<pre>if (bullets[i].getPosition().intersects(zombies[j].getPosition()))</pre>
			<p>If the current bullet and zombie have collided, then we take a number of steps, as detailed next.</p>
			<p>Stop the bullet with the following code:</p>
			<pre>// Stop the bullet
bullets[i].stop();</pre>
			<p>Register a hit with the current zombie by calling its <code>hit</code> function. Note that the <code>hit</code> function returns a Boolean that lets the calling code know whether the zombie is dead yet. This is shown in the following line of code:</p>
			<pre>// Register the hit and see if it was a kill
if (zombies[j].hit()) {</pre>
			<p>Inside this <code>if</code> block, which detects when the zombie is dead and hasn't just wounded us, do the following:</p>
			<ul>
				<li>Add ten to <code>score</code>.</li>
				<li>Change <code>hiScore</code> if the score the player has achieved has exceeded (beaten) <code>score</code>.</li>
				<li>Reduce <code>numZombiesAlive</code> by one.</li>
				<li>Check whether all the zombies are dead with <code>(numZombiesAlive == 0)</code> and if so, change <code>state</code> to <code>LEVELING_UP</code>.</li>
			</ul>
			<p>Here is the block of code inside <code>if(zombies[j].hit())</code> that we have just discussed:</p>
			<pre>// Not just a hit but a kill too
score += 10;
if (score &gt;= hiScore)
{
    hiScore = score;
}
numZombiesAlive--;
// When all the zombies are dead (again)
if (numZombiesAlive == 0) 
{
    state = State::LEVELING_UP;
}</pre>
			<p>That's the zombies and the bullets taken care of. You can now run the game and see the blood. Of course, you won't see the score until we implement the HUD in the next chapter.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor268"/>Has the player been touched by a zombie?</h2>
			<p>This code is much shorter and simpler than the zombie and bullet collision detection code. Add the following highlighted code just after the previous code we wrote:</p>
			<pre>}// End zombie being shot
<strong class="bold">// Have any zombies touched the player            </strong>
<strong class="bold">for (int i = 0; i &lt; numZombies; i++)</strong>
<strong class="bold">{</strong>
<strong class="bold">    if (player.getPosition().intersects</strong>
<strong class="bold">        (zombies[i].getPosition()) &amp;&amp; zombies[i].isAlive())</strong>
<strong class="bold">    {</strong>
<strong class="bold">        if (player.hit(gameTimeTotal))</strong>
<strong class="bold">        {</strong>
<strong class="bold">            // More here later</strong>
<strong class="bold">        }</strong>
<strong class="bold">        if (player.getHealth() &lt;= 0)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            state = State::GAME_OVER;            </strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
}// End player touched</pre>
			<p>Here, we detect whether a zombie has collided with the player by using a <code>for</code> loop to go through all the zombies. For each zombie that is alive, the code uses the <code>intersects</code> function to test for a collision with the player. When a collision has occurred, we call <code>player.hit</code>. Then, we check whether the player is dead by calling <code>player.getHealth</code>. If the player's health is equal to or less than zero, then we change <code>state</code> to <code>GAME_OVER</code>.</p>
			<p>You can run the game and collisions will be detected. However, as there is no HUD or sound effects yet, it is not clear that this is happening. In addition, we need to do some more work resetting the game when the player had died, and a new game is starting. So, although the game runs, the results are not especially satisfying right now. We will improve this over the next two chapters.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor269"/>Has the player touched a pickup?</h2>
			<p>The collision detection code between the player and each of the two pickups is shown here. Add the following highlighted code just after the previous code that we added:</p>
			<pre>    }// End player touched
<strong class="bold">    // Has the player touched health pickup</strong>
<strong class="bold">    if (player.getPosition().intersects</strong>
<strong class="bold">        (healthPickup.getPosition()) &amp;&amp; healthPickup.isSpawned())</strong>
<strong class="bold">    {</strong>
<strong class="bold">        player.increaseHealthLevel(healthPickup.gotIt());</strong>
<strong class="bold">        </strong>
<strong class="bold">    }</strong>
<strong class="bold">    // Has the player touched ammo pickup</strong>
<strong class="bold">    if (player.getPosition().intersects</strong>
<strong class="bold">        (ammoPickup.getPosition()) &amp;&amp; ammoPickup.isSpawned())</strong>
<strong class="bold">    {</strong>
<strong class="bold">        bulletsSpare += ammoPickup.gotIt();</strong>
<strong class="bold">        </strong>
<strong class="bold">    }</strong>
}// End updating the scene</pre>
			<p>The preceding code uses two simple <code>if </code>statements to see whether either <code>healthPickup</code> or <code>ammoPickup</code> have been touched by the player.</p>
			<p>If a health pickup has been collected, then the <code>player.increaseHealthLevel</code> function uses the value returned from the <code>healthPickup.gotIt</code> function to increase the player's health.</p>
			<p>If an ammo pickup has been collected, then <code>bulletsSpare</code> is increased by the value that's returned from <code>ammoPickup.gotIt</code>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can now run the game, kill zombies, and collect pickups! Note that, when your health equals zero, the game will enter the <code>GAME_OVER</code> state and pause. To restart it, you will need to press <code>Enter</code>, followed by a number between 1 and 6. When we implement the HUD, the home screen, and the leveling up screen, these steps will be intuitive and straightforward for the player. We will do so in the next chapter.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor270"/>Summary</h1>
			<p>This was a busy chapter, but we achieved a lot. Not only did we add bullets and pickups to the game through two new classes, but we also made all the objects interact as they should by detecting when they collide with each other.</p>
			<p>Despite these achievements, we need to do more work to set up each new game and to give the player feedback through a HUD. In the next chapter, we will build the HUD.</p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor271"/>FAQ</h1>
			<p>Here are some questions that might be on your mind:</p>
			<p>Q) Are there any better ways of doing collision detection?</p>
			<p>A) Yes. There are lots more ways to do collision detection, including but not limited to the following.</p>
			<ul>
				<li>You can divide objects up into multiple rectangles that fit the shape of the sprite better. It is perfectly manageable for C++ to check on thousands of rectangles each frame. This is especially the case when you use techniques such as neighbor checking to reduce the number of tests that are necessary each frame.</li>
				<li>For circular objects, you can use the radius overlap method.</li>
				<li>For irregular polygons, you can use the passing number algorithm.</li>
			</ul>
			<p>You can review all of these techniques, if you wish, by taking a look at the following links:</p>
			<ul>
				<li>Neighbor checking: <a href="http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/">http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/</a></li>
				<li>Radius overlap method: <a href="http://gamecodeschool.com/essentials/collision-detection-radius-overlap/">http://gamecodeschool.com/essentials/collision-detection-radius-overlap/</a></li>
				<li>Crossing number algorithm: <a href="http://gamecodeschool.com/essentials/collision-detection-crossing-number/">http://gamecodeschool.com/essentials/collision-detection-crossing-number/</a></li>
			</ul>
		</div>
	</body></html>