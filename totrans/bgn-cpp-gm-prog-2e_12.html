<html><head></head><body>
		<div id="_idContainer074">
			<h1 id="_idParaDest-242"><a id="_idTextAnchor249"/><em class="italic">Chapter 11</em>: Collision Detection, Pickups, and Bullets</h1>
			<p>So far, we have implemented the main visual aspects of our game. We have a controllable character running around in an arena full of zombies that chase them. The problem is that they don't interact with each other. A zombie can wander right through the player without leaving a scratch. We need to detect collisions between the zombies and the player. </p>
			<p>If the zombies are going to be able to injure and eventually kill the player, it is only fair that we give the player some bullets for their gun. We will then need to make sure that the bullets can hit and kill the zombies.</p>
			<p>At the same time, if we are writing collision detection code for bullets, zombies, and the player, it would be a good time to add a class for health and ammo pickups as well.</p>
			<p>Here is what we will do and the order in which we will cover things in this chapter:</p>
			<ul>
				<li>Shooting Bullets</li>
				<li>Adding a crosshair and hiding the mouse pointer</li>
				<li>Spawning pickups</li>
				<li>Detecting collisions</li>
			</ul>
			<p>Let's start with the <strong class="source-inline">Bullet</strong> class.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor250"/>Coding the Bullet class</h1>
			<p>We will use the SFML <strong class="source-inline">RectangleShape</strong> class to visually represent a bullet. We will code a <strong class="source-inline">Bullet</strong> class that has a <strong class="source-inline">RectangleShape</strong> member, as well as other member data and functions. Then, we will add bullets to our game in a few steps, as follows: </p>
			<ol>
				<li>First, we will code the <strong class="source-inline">Bullet.h</strong> file. This will reveal all the details of the member data and the prototypes for the functions.</li>
				<li>Next, we will code the <strong class="source-inline">Bullet.cpp</strong> file, which, of course, will contain the definitions for all the functions of the <strong class="source-inline">Bullet</strong> class. As we step through this, I will explain exactly how an object of the <strong class="source-inline">Bullet</strong> type will work and be controlled.</li>
				<li>Finally, we will declare a whole array full of bullets in the <strong class="source-inline">main</strong> function. We will also implement a control scheme for shooting, managing the player's remaining ammo, and reloading.</li>
			</ol>
			<p>Let's get started with step 1.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor251"/>Coding the Bullet header file</h2>
			<p>To make the new header file, right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong>, and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Bullet.h</strong>.</p>
			<p>Add the following private member variables, along with the <strong class="source-inline">Bullet</strong> class declaration, to the <strong class="source-inline">Bullet.h</strong> file. We can then run through them and explain what they are for:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Bullet</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // Where is the bullet?</p>
			<p class="source-code">    Vector2f m_Position;</p>
			<p class="source-code">    // What each bullet looks like</p>
			<p class="source-code">    RectangleShape m_BulletShape;</p>
			<p class="source-code">    // Is this bullet currently whizzing through the air</p>
			<p class="source-code">    bool m_InFlight = false;</p>
			<p class="source-code">    // How fast does a bullet travel?</p>
			<p class="source-code">    float m_BulletSpeed = 1000;</p>
			<p class="source-code">    // What fraction of 1 pixel does the bullet travel, </p>
			<p class="source-code">    // Horizontally and vertically each frame?</p>
			<p class="source-code">    // These values will be derived from m_BulletSpeed</p>
			<p class="source-code">    float m_BulletDistanceX;</p>
			<p class="source-code">    float m_BulletDistanceY;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Some boundaries so the bullet doesn't fly forever</p>
			<p class="source-code">    float m_MaxX;</p>
			<p class="source-code">    float m_MinX;</p>
			<p class="source-code">    float m_MaxY;</p>
			<p class="source-code">    float m_MinY;</p>
			<p class="source-code">// Public function prototypes go here</p>
			<p class="source-code">};</p>
			<p>In the previous code, the first member is a <strong class="source-inline">Vector2f</strong> called <strong class="source-inline">m_Position</strong>, which will hold the bullet's location in the game world.</p>
			<p>Next, we declare a <strong class="source-inline">RectangleShape</strong> called <strong class="source-inline">m_BulletShape</strong> as we are using a simple non-texture graphic for each bullet, a bit like we did for the time-bar in Timber!!!.</p>
			<p>The code then declares a <strong class="source-inline">Boolean</strong>,<strong class="source-inline"> m_InFlight</strong>, which will keep track of whether the bullet is currently whizzing through the air or not. This will allow us to decide whether we need to call its <strong class="source-inline">update</strong> function each frame and whether we need to run collision detection checks.</p>
			<p>The <strong class="source-inline">float</strong> variable, <strong class="source-inline">m_BulletSpeed</strong>, will (you can probably guess) hold the speed in pixels per second that the bullet will travel at. It is initialized to the value of <strong class="source-inline">1000</strong>, which is a little arbitrary, but it works well.</p>
			<p>Next, we have two more <strong class="source-inline">float</strong> variables, <strong class="source-inline">m_BulletDistanceX</strong> and <strong class="source-inline">m_BulletDistanceY</strong>. As the calculations to move a bullet are a little more complex than those used to move a zombie or the player, we will benefit from having these two variables, which we will perform calculations on. They will be used to decide the horizontal and vertical changes in the bullet's position in each frame.</p>
			<p>Finally, we have four more <strong class="source-inline">float</strong> variables (<strong class="source-inline">m_MaxX</strong>, <strong class="source-inline">m_MinX</strong>, <strong class="source-inline">m_MaxY</strong>, and <strong class="source-inline">m_MinY</strong>), which will later be initialized to hold the maximum and minimum and horizontal and vertical positions for the bullet.</p>
			<p>It is likely that the need for some of these variables is not immediately apparent, but it will become clearer when we see each of them in action in the <strong class="source-inline">Bullet.cpp</strong> file.</p>
			<p>Now, add all the public function prototypes to the <strong class="source-inline">Bullet.h</strong> file:</p>
			<p class="source-code">// Public function prototypes go here</p>
			<p class="source-code"><strong class="bold">public:</strong></p>
			<p class="source-code"><strong class="bold">    // The constructor</strong></p>
			<p class="source-code"><strong class="bold">    Bullet();</strong></p>
			<p class="source-code"><strong class="bold">    // Stop the bullet</strong></p>
			<p class="source-code"><strong class="bold">    void stop();</strong></p>
			<p class="source-code"><strong class="bold">    // Returns the value of m_InFlight</strong></p>
			<p class="source-code"><strong class="bold">    bool isInFlight();</strong></p>
			<p class="source-code"><strong class="bold">    // Launch a new bullet</strong></p>
			<p class="source-code"><strong class="bold">    void shoot(float startX, float startY,</strong></p>
			<p class="source-code"><strong class="bold">        float xTarget, float yTarget);</strong></p>
			<p class="source-code"><strong class="bold">    // Tell the calling code where the bullet is in the world</strong></p>
			<p class="source-code"><strong class="bold">    FloatRect getPosition();</strong></p>
			<p class="source-code"><strong class="bold">    // Return the actual shape (for drawing)</strong></p>
			<p class="source-code"><strong class="bold">    RectangleShape getShape();</strong></p>
			<p class="source-code"><strong class="bold">    // Update the bullet each frame</strong></p>
			<p class="source-code"><strong class="bold">    void update(float elapsedTime);</strong></p>
			<p class="source-code">};</p>
			<p>Let's run through each of the functions in turn, and then we can move on to coding their definitions.</p>
			<p>First, we have the <strong class="source-inline">Bullet</strong> function, which is, of course, the constructor. In this function, we will set up each <strong class="source-inline">Bullet</strong> instance, ready for action.</p>
			<p>The <strong class="source-inline">stop</strong> function will be called when the bullet has been in action but needs to stop. </p>
			<p>The <strong class="source-inline">isInFlight</strong> function returns a Boolean and will be used to test whether a bullet is currently in flight or not.</p>
			<p>The <strong class="source-inline">shoot</strong> function's use is given away by its name, but how it will work deserves some discussion. For now, just note that it has four <strong class="source-inline">float</strong> parameters that will be passed in. The four values represent the starting (where the player is) horizontal and vertical position of the bullet, as well as the vertical and horizontal target position (where the crosshair is). </p>
			<p>The <strong class="source-inline">getPosition</strong> function returns a <strong class="source-inline">FloatRect</strong> that represents the location of the bullet. This function will be used to detect collisions with zombies. You might remember from <a href="B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 10</em></a>,<em class="italic"> Pointers, the Standard Template Library, and Texture Management</em>, that zombies also had a <strong class="source-inline">getPosition</strong> function.</p>
			<p>Following on, we have the <strong class="source-inline">getShape</strong> function, which returns an object of the <strong class="source-inline">RectangleShape</strong> type. As we have discussed, each bullet is represented visually by a <strong class="source-inline">RectangleShape</strong> object. The <strong class="source-inline">getShape</strong> function, therefore, will be used to grab a copy of the current state of <strong class="source-inline">RectangleShape</strong> in order to draw it.</p>
			<p>Finally, and hopefully as expected, there is the <strong class="source-inline">update</strong> function, which has a <strong class="source-inline">float</strong> parameter that represents the fraction of a second that has passed since the last time <strong class="source-inline">update</strong> was called. The <strong class="source-inline">update</strong> method will change the position of the bullet each frame.</p>
			<p>Let's look at and code the function definitions.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor252"/>Coding the Bullet source file</h2>
			<p>Now, we can create a new <strong class="source-inline">.cpp</strong> file that will contain the function definitions. Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong>, and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Bullet.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the class.</p>
			<p>Add the following code, which is for the include directives and the constructor. We know it is a constructor because the function has the same name as the class:</p>
			<p class="source-code">#include "bullet.h"</p>
			<p class="source-code">// The constructor</p>
			<p class="source-code">Bullet::Bullet()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_BulletShape.setSize(sf::Vector2f(2, 2));</p>
			<p class="source-code">}</p>
			<p>The only thing that the <strong class="source-inline">Bullet</strong> constructor needs to do is set the size of <strong class="source-inline">m_BulletShape</strong>, which is the <strong class="source-inline">RectangleShape</strong> object. The code sets the size to two pixels by two pixels.</p>
			<p>Next, we will code the more substantial <strong class="source-inline">shoot</strong> function. Add the following code to the <strong class="source-inline">Bullet.cpp</strong> file and study it, and then we can talk about it:</p>
			<p class="source-code">void Bullet::shoot(float startX, float startY,</p>
			<p class="source-code">    float targetX, float targetY)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Keep track of the bullet</p>
			<p class="source-code">    m_InFlight = true;</p>
			<p class="source-code">    m_Position.x = startX;</p>
			<p class="source-code">    m_Position.y = startY;</p>
			<p class="source-code">    // Calculate the gradient of the flight path</p>
			<p class="source-code">    float gradient = (startX - targetX) / (startY - targetY);</p>
			<p class="source-code">    // Any gradient less than 1 needs to be negative</p>
			<p class="source-code">    if (gradient &lt; 0)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        gradient *= -1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Calculate the ratio between x and y</p>
			<p class="source-code">    float ratioXY = m_BulletSpeed / (1 + gradient);</p>
			<p class="source-code">    // Set the "speed" horizontally and vertically</p>
			<p class="source-code">    m_BulletDistanceY = ratioXY;</p>
			<p class="source-code">    m_BulletDistanceX = ratioXY * gradient;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Point the bullet in the right direction</p>
			<p class="source-code">    if (targetX &lt; startX)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_BulletDistanceX *= -1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (targetY &lt; startY)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_BulletDistanceY *= -1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Set a max range of 1000 pixels</p>
			<p class="source-code">    float range = 1000;</p>
			<p class="source-code">    m_MinX = startX - range;</p>
			<p class="source-code">    m_MaxX = startX + range;</p>
			<p class="source-code">    m_MinY = startY - range;</p>
			<p class="source-code">    m_MaxY = startY + range;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Position the bullet ready to be drawn</p>
			<p class="source-code">    m_BulletShape.setPosition(m_Position);</p>
			<p class="source-code">}</p>
			<p>In order to demystify the <strong class="source-inline">shoot</strong> function, we will split it up and talk about the code we have just added in chunks.</p>
			<p>First, let's remind ourselves about the signature. The <strong class="source-inline">shoot</strong> function receives the starting and target horizontal and vertical positions of a bullet. The calling code will supply these based on the position of the player sprite and the position of the crosshair. Here it is again:</p>
			<p class="source-code">void Bullet::shoot(float startX, float startY,</p>
			<p class="source-code">    float targetX, float targetY)</p>
			<p>Inside the <strong class="source-inline">shoot</strong> function, we set <strong class="source-inline">m_InFlight</strong> to <strong class="source-inline">true</strong> and position the bullet using the <strong class="source-inline">startX</strong> and <strong class="source-inline">startY</strong> parameters. Here is that piece of code again:</p>
			<p class="source-code">// Keep track of the bullet</p>
			<p class="source-code">m_InFlight = true;</p>
			<p class="source-code">m_Position.x = startX;</p>
			<p class="source-code">m_Position.y = startY;</p>
			<p>Now, we use a bit of trigonometry to determine the gradient of travel for a bullet. The progression of the bullet, both horizontally and vertically, must vary based on the slope of the line that's created by drawing between the start and target of a bullet. The rate of change cannot be the same or very steep shots will arrive at the horizontal location before the vertical location, and vice versa for shallow shots.</p>
			<p>The code that follows derives the gradient based on the equation of a line. Then, it checks whether the gradient is less than zero and if it is, multiplies it by -1. This is because the start and target coordinates that are passed in can be negative or positive, and we always want the amount of progression each frame to be positive. Multiplying by -1 simply makes the negative number into its positive equivalent because a minus multiplied by a minus gives a positive. The actual direction of travel will be handled in the <strong class="source-inline">update</strong> function by adding or subtracting the positive values we arrive at in this function.</p>
			<p>Next, we calculate a ratio of horizontal to vertical distance by dividing our bullet's speed (<strong class="source-inline">m_BulletSpeed</strong>) by one, plus the gradient. This will allow us to change the bullet's horizontal and vertical position by the correct amount each frame, based on the target the bullet is heading toward.</p>
			<p>Finally, in this part of the code, we assign the values to <strong class="source-inline">m_BulletDistanceY</strong> and <strong class="source-inline">m_BulletDistanceX</strong>:</p>
			<p class="source-code">// Calculate the gradient of the flight path</p>
			<p class="source-code">float gradient = (startX - targetX) / (startY - targetY);</p>
			<p class="source-code">// Any gradient less than zero needs to be negative</p>
			<p class="source-code">if (gradient &lt; 0)</p>
			<p class="source-code">{</p>
			<p class="source-code">    gradient *= -1;</p>
			<p class="source-code">}</p>
			<p class="source-code">// Calculate the ratio between x and y</p>
			<p class="source-code">float ratioXY = m_BulletSpeed / (1 + gradient);</p>
			<p class="source-code">// Set the "speed" horizontally and vertically</p>
			<p class="source-code">m_BulletDistanceY = ratioXY;</p>
			<p class="source-code">m_BulletDistanceX = ratioXY * gradient;</p>
			<p>The following code is much more straightforward. We simply set a maximum horizontal and vertical location that the bullet can reach. We don't want a bullet carrying on forever. In the update function, we will see whether a bullet has passed its maximum or minimum locations:</p>
			<p class="source-code">// Set a max range of 1000 pixels in any direction</p>
			<p class="source-code">float range = 1000;</p>
			<p class="source-code">m_MinX = startX - range;</p>
			<p class="source-code">m_MaxX = startX + range;</p>
			<p class="source-code">m_MinY = startY - range;</p>
			<p class="source-code">m_MaxY = startY + range;</p>
			<p>The following code moves the sprite that represents the bullet to its starting location. We use the <strong class="source-inline">setPosition</strong> function of <strong class="source-inline">Sprite</strong>, as we have often done before:</p>
			<p class="source-code">// Position the bullet ready to be drawn</p>
			<p class="source-code">m_BulletShape.setPosition(m_Position);</p>
			<p>Next, we have four straightforward functions. Let's add the <strong class="source-inline">stop</strong>, <strong class="source-inline">isInFlight</strong>, <strong class="source-inline">getPosition</strong>, and <strong class="source-inline">getShape</strong> functions:</p>
			<p class="source-code">void Bullet::stop()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_InFlight = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool Bullet::isInFlight()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_InFlight;</p>
			<p class="source-code">}</p>
			<p class="source-code">FloatRect Bullet::getPosition()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_BulletShape.getGlobalBounds();</p>
			<p class="source-code">}</p>
			<p class="source-code">RectangleShape Bullet::getShape()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_BulletShape;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">stop</strong> function simply sets the <strong class="source-inline">m_InFlight</strong> variable to <strong class="source-inline">false</strong>. The <strong class="source-inline">isInFlight</strong> function returns whatever the value of this same variable currently is. So, we can see that <strong class="source-inline">shoot</strong> sets the bullet going, <strong class="source-inline">stop</strong> makes it stop, and <strong class="source-inline">isInFlight</strong> informs us what the current state is.</p>
			<p>The <strong class="source-inline">getPosition</strong> function returns a <strong class="source-inline">FloatRect</strong>. We will see how we can use the <strong class="source-inline">FloatRect</strong> from each game object to detect collisions soon.</p>
			<p>Finally, for the previous code, <strong class="source-inline">getShape</strong> returns a <strong class="source-inline">RectangleShape</strong> so that we can draw the bullet once each frame.</p>
			<p>The last function we need to implement before we can start using <strong class="source-inline">Bullet</strong> objects is <strong class="source-inline">update</strong>. Add the following code, study it, and then we can talk about it:</p>
			<p class="source-code">void Bullet::update(float elapsedTime)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Update the bullet position variables</p>
			<p class="source-code">    m_Position.x += m_BulletDistanceX * elapsedTime;</p>
			<p class="source-code">    m_Position.y += m_BulletDistanceY * elapsedTime;</p>
			<p class="source-code">    // Move the bullet</p>
			<p class="source-code">    m_BulletShape.setPosition(m_Position);</p>
			<p class="source-code">    // Has the bullet gone out of range?</p>
			<p class="source-code">    if (m_Position.x &lt; m_MinX || m_Position.x &gt; m_MaxX ||</p>
			<p class="source-code">        m_Position.y &lt; m_MinY || m_Position.y &gt; m_MaxY)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_InFlight = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the <strong class="source-inline">update</strong> function, we use <strong class="source-inline">m_BulletDistanceX</strong> and <strong class="source-inline">m_BulletDistanceY</strong>, multiplied by the time since the last frame to move the bullet. Remember that the values of the two variables were calculated in the <strong class="source-inline">shoot</strong> function and represent the gradient (ratio to each other) that's required to move the bullet at just the right angle. Then, we use the <strong class="source-inline">setPosition</strong> function to actually move <strong class="source-inline">RectangleShape</strong>.</p>
			<p>The last thing we do in <strong class="source-inline">update</strong> is a test to see whether the bullet has moved beyond its maximum range. The slightly convoluted <strong class="source-inline">if</strong> statement checks <strong class="source-inline">m_Position.x</strong> and <strong class="source-inline">m_Position.y</strong> against the maximum and minimum values that were calculated in the <strong class="source-inline">shoot</strong> function. These maximum and minimum values are stored in <strong class="source-inline">m_MinX</strong>, <strong class="source-inline">m_MaxX</strong>, <strong class="source-inline">m_MinY</strong>, and <strong class="source-inline">m_MaxY</strong>. If the test is true, then <strong class="source-inline">m_InFlight</strong> is set to <strong class="source-inline">false</strong>.</p>
			<p>The <strong class="source-inline">Bullet</strong> class is done. Now, we will look at how we can shoot some in the <strong class="source-inline">main</strong> function.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor253"/>Making the bullets fly</h1>
			<p>We will make the bullets usable by following these six steps:</p>
			<ol>
				<li value="1">Add the necessary include directive for the <strong class="source-inline">Bullet</strong> class.</li>
				<li>Add some control variables and an array to hold some <strong class="source-inline">Bullet</strong> instances.</li>
				<li>Handle the player pressing <em class="italic">R</em> to reload.</li>
				<li>Handle the player pressing the left mouse button to fire a bullet.</li>
				<li>Update all bullets that are in flight in each frame.</li>
				<li>Draw the bullets that are in flight in each frame.</li>
			</ol>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor254"/>Including the Bullet class</h2>
			<p>Add the include directive to make the Bullet class available:</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "ZombieArena.h"</p>
			<p class="source-code">#include "Player.h"</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code"><strong class="bold">#include "Bullet.h"</strong></p>
			<p class="source-code">using namespace sf;</p>
			<p>Let's move on to the next step.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor255"/>Control variables and the bullet array</h2>
			<p>Here are some variables to keep track of clip sizes, spare bullets, bullets, the remaining bullets in the clip, the current rate of fire (starting at one per second), and the time when the last bullet was fired.</p>
			<p>Add the following highlighted code. Then, we can move on and see all these variables in action throughout the rest of this section:</p>
			<p class="source-code">// Prepare for a horde of zombies</p>
			<p class="source-code">int numZombies;</p>
			<p class="source-code">int numZombiesAlive;</p>
			<p class="source-code">Zombie* zombies = NULL;</p>
			<p class="source-code"><strong class="bold">// 100 bullets should do</strong></p>
			<p class="source-code"><strong class="bold">Bullet bullets[100];</strong></p>
			<p class="source-code"><strong class="bold">int currentBullet = 0;</strong></p>
			<p class="source-code"><strong class="bold">int bulletsSpare = 24;</strong></p>
			<p class="source-code"><strong class="bold">int bulletsInClip = 6;</strong></p>
			<p class="source-code"><strong class="bold">int clipSize = 6;</strong></p>
			<p class="source-code"><strong class="bold">float fireRate = 1;</strong></p>
			<p class="source-code"><strong class="bold">// When was the fire button last pressed?</strong></p>
			<p class="source-code"><strong class="bold">Time lastPressed;</strong></p>
			<p class="source-code">// The main game loop</p>
			<p class="source-code">while (window.isOpen())</p>
			<p>Next, let's handle what happens when the player presses the <em class="italic">R</em> keyboard key, which is used for reloading a clip.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor256"/>Reloading the gun</h2>
			<p>Now, we will handle the player input related to shooting bullets. First, we will handle pressing the <em class="italic">R</em> key to reload the gun. We will do so with an SFML event.</p>
			<p>Add the following highlighted code. It is shown with lots of context to make sure the code goes in the right place. Study the code and then we can talk about it:</p>
			<p class="source-code">// Handle events</p>
			<p class="source-code">Event event;</p>
			<p class="source-code">while (window.pollEvent(event))</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (event.type == Event::KeyPressed)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Pause a game while playing</p>
			<p class="source-code">        if (event.key.code == Keyboard::Return &amp;&amp;</p>
			<p class="source-code">            state == State::PLAYING)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            state = State::PAUSED;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        // Restart while paused</p>
			<p class="source-code">        else if (event.key.code == Keyboard::Return &amp;&amp;</p>
			<p class="source-code">            state == State::PAUSED)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            state = State::PLAYING;</p>
			<p class="source-code">            // Reset the clock so there isn't a frame jump</p>
			<p class="source-code">            clock.restart();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        // Start a new game while in GAME_OVER state</p>
			<p class="source-code">        else if (event.key.code == Keyboard::Return &amp;&amp;</p>
			<p class="source-code">            state == State::GAME_OVER)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            state = State::LEVELING_UP;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        if (state == State::PLAYING)</p>
			<p class="source-code">        {</p>
			<p class="source-code"><strong class="bold">            // Reloading</strong></p>
			<p class="source-code"><strong class="bold">            if (event.key.code == Keyboard::R)</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                if (bulletsSpare &gt;= clipSize)</strong></p>
			<p class="source-code"><strong class="bold">                {</strong></p>
			<p class="source-code"><strong class="bold">                    // Plenty of bullets. Reload.</strong></p>
			<p class="source-code"><strong class="bold">                    bulletsInClip = clipSize;</strong></p>
			<p class="source-code"><strong class="bold">                    bulletsSpare -= clipSize;                            </strong></p>
			<p class="source-code"><strong class="bold">                }</strong></p>
			<p class="source-code"><strong class="bold">                else if (bulletsSpare &gt; 0)</strong></p>
			<p class="source-code"><strong class="bold">                {</strong></p>
			<p class="source-code"><strong class="bold">                    // Only few bullets left</strong></p>
			<p class="source-code"><strong class="bold">                    bulletsInClip = bulletsSpare;</strong></p>
			<p class="source-code"><strong class="bold">                    bulletsSpare = 0;                            </strong></p>
			<p class="source-code"><strong class="bold">                }</strong></p>
			<p class="source-code"><strong class="bold">                else</strong></p>
			<p class="source-code"><strong class="bold">                {</strong></p>
			<p class="source-code"><strong class="bold">                    // More here soon?!</strong></p>
			<p class="source-code"><strong class="bold">                }</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}// End event polling</p>
			<p>The previous code is nested within the event handling part of the game loop (<strong class="source-inline">while(window.pollEvent)</strong>), within the block that only executes when the game is actually being played (<strong class="source-inline">if(state == State::Playing)</strong>). It is obvious that we don't want the player reloading when the game has finished or is paused, and wrapping the new code as we've described achieves this.</p>
			<p>In the new code itself, the first thing we do is test for the <em class="italic">R</em> key being pressed with <strong class="source-inline">if (event.key.code == Keyboard::R)</strong>. Once we have detected that the <em class="italic">R</em> key was pressed, the remaining code is executed. Here is the structure of the <strong class="source-inline">if</strong>, <strong class="source-inline">else if</strong>, and <strong class="source-inline">else</strong> blocks:</p>
			<p class="source-code">if(bulletsSpare &gt;= clipSize)</p>
			<p class="source-code">    ...</p>
			<p class="source-code">else if(bulletsSpare &gt; 0)</p>
			<p class="source-code">    ...</p>
			<p class="source-code">else</p>
			<p class="source-code">    ...</p>
			<p>The previous structure allows us to handle three possible scenarios, as shown here:</p>
			<ul>
				<li>The player has pressed <strong class="source-inline">R</strong> and they have more bullets spare than the clip can take. In this scenario, the clip is refilled, and the number of spare bullets is reduced.</li>
				<li>The player has some spare bullets but not enough to fill the clip completely. In this scenario, the clip is filled with as many spare bullets as the player has and the number of spare bullets is set to zero.</li>
				<li>The player has pressed <em class="italic">R</em> but they have no spare bullets at all. For this scenario, we don't actually need to alter the variables. However, we will play a sound effect here when we implement the sound in <a href="B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279"><em class="italic">Chapter 13</em></a>,<em class="italic"> Sound Effects, File I/O, and Finishing the Game</em>, so we will leave the empty <strong class="source-inline">else</strong> block ready.</li>
			</ul>
			<p>Now, let's shoot a bullet.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor257"/>Shooting a bullet</h2>
			<p>Here, we will handle the left mouse button being clicked to fire a bullet. Add the following highlighted code and study it carefully:</p>
			<p class="source-code">    if (Keyboard::isKeyPressed(Keyboard::D))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        player.moveRight();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        player.stopRight();</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // Fire a bullet</strong></p>
			<p class="source-code"><strong class="bold">    if (Mouse::isButtonPressed(sf::Mouse::Left))</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        if (gameTimeTotal.asMilliseconds()</strong></p>
			<p class="source-code"><strong class="bold">            - lastPressed.asMilliseconds()</strong></p>
			<p class="source-code"><strong class="bold">            &gt; 1000 / fireRate &amp;&amp; bulletsInClip &gt; 0)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            // Pass the centre of the player </strong></p>
			<p class="source-code"><strong class="bold">            // and the centre of the cross-hair</strong></p>
			<p class="source-code"><strong class="bold">            // to the shoot function</strong></p>
			<p class="source-code"><strong class="bold">            bullets[currentBullet].shoot(</strong></p>
			<p class="source-code"><strong class="bold">                player.getCenter().x, player.getCenter().y,</strong></p>
			<p class="source-code"><strong class="bold">                mouseWorldPosition.x, mouseWorldPosition.y);</strong></p>
			<p class="source-code"><strong class="bold">            currentBullet++;</strong></p>
			<p class="source-code"><strong class="bold">            if (currentBullet &gt; 99)</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                currentBullet = 0;</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code"><strong class="bold">            lastPressed = gameTimeTotal;</strong></p>
			<p class="source-code"><strong class="bold">            bulletsInClip--;</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }// End fire a bullet</strong></p>
			<p class="source-code">}// End WASD while playing</p>
			<p>All the previous code is wrapped in an <strong class="source-inline">if </strong>statement that executes whenever the left mouse button is pressed, that is, <strong class="source-inline">if (Mouse::isButtonPressed(sf::Mouse::Left))</strong>. Note that the code will execute repeatedly, even if the player just holds down the button. The code we will go through now controls the rate of fire.</p>
			<p>In the preceding code, we then check whether the total time elapsed in the game (<strong class="source-inline">gameTimeTotal</strong>) minus the time the player last shot a bullet (<strong class="source-inline">lastPressed</strong>) is greater than 1,000, divided by the current rate of fire and that the player has at least one bullet in the clip. We use 1,000 because this is the number of milliseconds in a second.</p>
			<p>If this test is successful, the code that actually fires a bullet is executed. Shooting a bullet is easy because we did all the hard work in the <strong class="source-inline">Bullet</strong> class. We simply call <strong class="source-inline">shoot </strong>on the current bullet from the <strong class="source-inline">bullets</strong> array. We pass in the player's and the cross-hair's current horizontal and vertical locations. The bullet will be configured and set in flight by the code in the <strong class="source-inline">shoot</strong> function of the <strong class="source-inline">Bullet</strong> class.</p>
			<p>All we must do is keep track of the array of bullets. We incremented the <strong class="source-inline">currentBullet</strong> variable. Then, we need to check to see whether we fired the last bullet (99) with the <strong class="source-inline">if (currentBullet &gt; 99)</strong> statement. If it was the last bullet, we set <strong class="source-inline">currentBullet</strong> to zero. If it wasn't the last bullet, then the next bullet is ready to go whenever the rate of fire permits it and the player presses the left mouse button.</p>
			<p>Finally, in the preceding code, we store the time that the bullet was fired into <strong class="source-inline">lastPressed</strong> and decrement <strong class="source-inline">bulletsInClip</strong>.</p>
			<p>Now, we can update every bullet, each frame.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor258"/>Updating the bullets each frame</h2>
			<p>Add the following highlighted code to loop through the bullets array, check whether the bullet is in flight, and if it is, call its update function:</p>
			<p class="source-code">    // Loop through each Zombie and update them</p>
			<p class="source-code">    for (int i = 0; i &lt; numZombies; i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (zombies[i].isAlive())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            zombies[i].update(dt.asSeconds(), playerPosition);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // Update any bullets that are in-flight</strong></p>
			<p class="source-code"><strong class="bold">    for (int i = 0; i &lt; 100; i++)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        if (bullets[i].isInFlight())</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            bullets[i].update(dtAsSeconds);</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}// End updating the scene</p>
			<p>Finally, we will draw all the bullets. </p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor259"/>Drawing the bullets each frame</h2>
			<p>Add the following highlighted code to loop through the <strong class="source-inline">bullets</strong> array, check whether the bullet is in flight, and if it is, draw it:</p>
			<p class="source-code">/*</p>
			<p class="source-code"> **************</p>
			<p class="source-code"> Draw the scene</p>
			<p class="source-code"> **************</p>
			<p class="source-code"> */</p>
			<p class="source-code">if (state == State::PLAYING)</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.clear();</p>
			<p class="source-code">    // set the mainView to be displayed in the window</p>
			<p class="source-code">    // And draw everything related to it</p>
			<p class="source-code">    window.setView(mainView);</p>
			<p class="source-code">    // Draw the background</p>
			<p class="source-code">    window.draw(background, &amp;textureBackground);</p>
			<p class="source-code">    // Draw the zombies</p>
			<p class="source-code">    for (int i = 0; i &lt; numZombies; i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        window.draw(zombies[i].getSprite());</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    for (int i = 0; i &lt; 100; i++)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        if (bullets[i].isInFlight())</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            window.draw(bullets[i].getShape());</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    // Draw the player</p>
			<p class="source-code">    window.draw(player.getSprite());</p>
			<p class="source-code">}</p>
			<p>Run the game to try out the bullets. Notice that you can fire six shots before you need to press <em class="italic">R</em> to reload. The obvious things that are missing is some visual indicator of the number of bullets in the clip and the number of spare bullets. Another problem is that the player can very quickly run out of bullets, especially since the bullets have no stopping power whatsoever. They fly straight through the zombies. Add to this that the player is expected to aim at a mouse pointer instead of a precision crosshair and it is clear that we have work to do.</p>
			<p>In the next chapter, we will give visual feedback through a HUD. We will replace the mouse cursor with a crosshair next and then spawn some pickups to replenish bullets and health after that. Finally, in this chapter, we will handle collision detection to make the bullets and the zombies do damage and make the player able to actually get the pickups.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor260"/>Giving the player a crosshair</h1>
			<p>Adding a crosshair is easy and only requires one new concept. Add the following highlighted code, and then we can run through it:</p>
			<p class="source-code">// 100 bullets should do</p>
			<p class="source-code">Bullet bullets[100];</p>
			<p class="source-code">int currentBullet = 0;</p>
			<p class="source-code">int bulletsSpare = 24;</p>
			<p class="source-code">int bulletsInClip = 6;</p>
			<p class="source-code">int clipSize = 6;</p>
			<p class="source-code">float fireRate = 1;</p>
			<p class="source-code">// When was the fire button last pressed?</p>
			<p class="source-code">Time lastPressed;</p>
			<p class="source-code"><strong class="bold">// Hide the mouse pointer and replace it with crosshair</strong></p>
			<p class="source-code"><strong class="bold">window.setMouseCursorVisible(true);</strong></p>
			<p class="source-code"><strong class="bold">Sprite spriteCrosshair;</strong></p>
			<p class="source-code"><strong class="bold">Texture textureCrosshair = TextureHolder::GetTexture("graphics/crosshair.png");</strong></p>
			<p class="source-code"><strong class="bold">spriteCrosshair.setTexture(textureCrosshair);</strong></p>
			<p class="source-code"><strong class="bold">spriteCrosshair.setOrigin(25, 25);</strong></p>
			<p class="source-code">// The main game loop</p>
			<p class="source-code">while (window.isOpen())</p>
			<p>First, we call the <strong class="source-inline">setMouseCursorVisible</strong> function on our <strong class="source-inline">window</strong> object. We then load a <strong class="source-inline">Texture</strong> and declare a <strong class="source-inline">Sprite</strong> instance and initialize it in the usual way. Furthermore, we set the sprite's origin to its center to make it convenient and simpler to make the bullets fly to the middle, as you would expect to happen.</p>
			<p>Now, we need to update the crosshair each frame with the world coordinates of the mouse. Add the following highlighted line of code, which uses the <strong class="source-inline">mouseWorldPosition</strong> vector to set the crosshair's position each frame:</p>
			<p class="source-code">/*</p>
			<p class="source-code"> ****************</p>
			<p class="source-code"> UPDATE THE FRAME</p>
			<p class="source-code"> ****************</p>
			<p class="source-code"> */</p>
			<p class="source-code">if (state == State::PLAYING)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Update the delta time</p>
			<p class="source-code">    Time dt = clock.restart();</p>
			<p class="source-code">    // Update the total game time</p>
			<p class="source-code">    gameTimeTotal += dt;</p>
			<p class="source-code">    // Make a decimal fraction of 1 from the delta time</p>
			<p class="source-code">    float dtAsSeconds = dt.asSeconds();</p>
			<p class="source-code">    // Where is the mouse pointer</p>
			<p class="source-code">    mouseScreenPosition = Mouse::getPosition();</p>
			<p class="source-code">    // Convert mouse position to world coordinates of mainView</p>
			<p class="source-code">    mouseWorldPosition = window.mapPixelToCoords(</p>
			<p class="source-code">        Mouse::getPosition(), mainView);</p>
			<p class="source-code"><strong class="bold">    // Set the crosshair to the mouse world location</strong></p>
			<p class="source-code"><strong class="bold">    spriteCrosshair.setPosition(mouseWorldPosition);</strong></p>
			<p class="source-code">    // Update the player</p>
			<p class="source-code">    player.update(dtAsSeconds, Mouse::getPosition());</p>
			<p>Next, as you have probably come to expect, we can draw the crosshair each frame. Add the following highlighted line of code in the position shown. This line of code needs no explanation, but its position after all the other game objects is important, so it is drawn on top:</p>
			<p class="source-code">/*</p>
			<p class="source-code"> **************</p>
			<p class="source-code"> Draw the scene</p>
			<p class="source-code"> **************</p>
			<p class="source-code"> */</p>
			<p class="source-code">if (state == State::PLAYING)</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.clear();</p>
			<p class="source-code">    // set the mainView to be displayed in the window</p>
			<p class="source-code">    // And draw everything related to it</p>
			<p class="source-code">    window.setView(mainView);</p>
			<p class="source-code">    // Draw the background</p>
			<p class="source-code">    window.draw(background, &amp;textureBackground);</p>
			<p class="source-code">    // Draw the zombies</p>
			<p class="source-code">    for (int i = 0; i &lt; numZombies; i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        window.draw(zombies[i].getSprite());</p>
			<p class="source-code">    }</p>
			<p class="source-code">    for (int i = 0; i &lt; 100; i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (bullets[i].isInFlight())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            window.draw(bullets[i].getShape());</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Draw the player</p>
			<p class="source-code">    window.draw(player.getSprite());</p>
			<p class="source-code"><strong class="bold">    //Draw the crosshair</strong></p>
			<p class="source-code"><strong class="bold">    window.draw(spriteCrosshair);</strong></p>
			<p class="source-code">}</p>
			<p>Now, you can run the game and will see a cool crosshair instead of a mouse cursor:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B14278_11_01.jpg" alt=""/>
				</div>
			</div>
			<p>Notice how the bullet fires neatly through the center of the crosshair. The way the shooting mechanism works is analogous to allowing the player to choose to shoot from the hip or aim down the sights. If the player keeps the crosshair close to the center, they can fire and turn rapidly, yet must carefully judge the position of distant zombies.</p>
			<p>Alternatively, the player can hover their crosshair directly over the head of a distant zombie and score a precise hit; however, they then have much further to move the crosshair back if a zombie attacks from another direction.</p>
			<p>An interesting improvement to the game would be to add a small random amount of inaccuracy to each shot. This inaccuracy could perhaps be mitigated with an upgrade between waves.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor261"/>Coding a class for pickups</h1>
			<p>In this section, we will code a <strong class="source-inline">Pickup</strong> class that has a <strong class="source-inline">Sprite</strong> member, as well as other member data and functions. We will add pickups to our game in just a few steps:</p>
			<ol>
				<li value="1">First, we will code the <strong class="source-inline">Pickup.h</strong> file. This will reveal all the details of the member data and the prototypes for the functions.</li>
				<li>Then, we will code the <strong class="source-inline">Pickup.cpp</strong> file which, of course, will contain the definitions for all the functions of the <strong class="source-inline">Pickup</strong> class. As we step through this, I will explain exactly how an object of the <strong class="source-inline">Pickup</strong> type will work and be controlled.</li>
				<li>Finally, we will use the <strong class="source-inline">Pickup</strong> class in the <strong class="source-inline">main</strong> function to spawn them, update them, and draw them.</li>
			</ol>
			<p>Let's get started with step 1.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor262"/>Coding the Pickup header file</h2>
			<p>To make the new header file, right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong>, and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Pickup.h</strong>.</p>
			<p>Add and study the following code to the <strong class="source-inline">Pickup.h</strong> file and then we can go through it:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Pickup</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    //Start value for health pickups</p>
			<p class="source-code">    const int HEALTH_START_VALUE = 50;</p>
			<p class="source-code">    const int AMMO_START_VALUE = 12;</p>
			<p class="source-code">    const int START_WAIT_TIME = 10;</p>
			<p class="source-code">    const int START_SECONDS_TO_LIVE = 5;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // The sprite that represents this pickup</p>
			<p class="source-code">    Sprite m_Sprite;</p>
			<p class="source-code">    // The arena it exists in</p>
			<p class="source-code">    IntRect m_Arena;</p>
			<p class="source-code">    // How much is this pickup worth?</p>
			<p class="source-code">    int m_Value;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // What type of pickup is this? </p>
			<p class="source-code">    // 1 = health, 2 = ammo</p>
			<p class="source-code">    int m_Type;</p>
			<p class="source-code">    // Handle spawning and disappearing</p>
			<p class="source-code">    bool m_Spawned;</p>
			<p class="source-code">    float m_SecondsSinceSpawn;</p>
			<p class="source-code">    float m_SecondsSinceDeSpawn;</p>
			<p class="source-code">    float m_SecondsToLive;</p>
			<p class="source-code">    float m_SecondsToWait;    </p>
			<p class="source-code">// Public prototypes go here</p>
			<p class="source-code">};</p>
			<p>The previous code declares all the private variables of the <strong class="source-inline">Pickup</strong> class. Although the names should be quite intuitive, it might not be obvious why many of them are needed at all. Let's go through them, starting from the top:</p>
			<ul>
				<li><strong class="source-inline">const int HEALTH_START_VALUE = 50</strong>: This constant variable is used to set the starting value of all health pickups. The value will be used to initialize the <strong class="source-inline">m_Value </strong>variable, which will need to be manipulated throughout the course of a game.</li>
				<li><strong class="source-inline">const int AMMO_START_VALUE = 12</strong>: This constant variable is used to set the starting value of all ammo pickups. The value will be used to initialize the <strong class="source-inline">m_Value</strong> variable, which will need to be manipulated throughout the course of a game.</li>
				<li><strong class="source-inline">const int START_WAIT_TIME = 10</strong>: This variable determines how long a pickup will wait before it respawns after disappearing. It will be used to initialize the <strong class="source-inline">m_SecondsToWait</strong> variable, which can be manipulated throughout the game.</li>
				<li><strong class="source-inline">const int START_SECONDS_TO_LIVE = 5</strong>: This variable determines how long a pickup will last between spawning and being de-spawned. Like the previous three constants, it has a non-constant associated with it that can be manipulated throughout the course of the game. The non-constant it's used to initialize is <strong class="source-inline">m_SecondsToLive</strong>.</li>
				<li><strong class="source-inline">Sprite m_Sprite</strong>: This is the sprite to visually represent the object.</li>
				<li><strong class="source-inline">IntRect m_Arena</strong>: This will hold the size of the current arena to help the pickup to spawn in a sensible position.</li>
				<li><strong class="source-inline">int m_Value</strong>: How much health or ammo is this pickup worth? This value is used when the player levels up the value of the health or ammo pickup.</li>
				<li><strong class="source-inline">int m_Type</strong>: This will be either 1 or 2 for health or ammo, respectively. We could have used an enumeration class, but that seemed like overkill for just two options.</li>
				<li><strong class="source-inline">bool m_Spawned</strong>: Is the pickup currently spawned?</li>
				<li><strong class="source-inline">float m_SecondsSinceSpawn</strong>: How long is it since the pickup was spawned?</li>
				<li><strong class="source-inline">float m_SecondsSinceDeSpawn</strong>: How long is it since the pickup was de-spawned (disappeared)?</li>
				<li><strong class="source-inline">float m_SecondsToLive</strong>: How long should this pickup stay spawned before de-spawning?</li>
				<li><strong class="source-inline">float m_SecondsToWait</strong>: How long should this pickup stay de-spawned before respawning?<p class="callout-heading">Tip</p><p class="callout">Note that most of the complexity of this class is due to the variable spawn time and its upgradeable nature. If the pickups just respawned when collected and had a fixed value, this would be a very simple class. We need our pickups to be upgradeable so that the player is forced to develop a strategy to progress through the waves.</p></li>
			</ul>
			<p>Next, add the following public function prototypes to the <strong class="source-inline">Pickup.h</strong> file. Be sure to familiarize yourself with the new code so that we can go through it:</p>
			<p class="source-code">// Public prototypes go here</p>
			<p class="source-code"><strong class="bold">public:</strong></p>
			<p class="source-code"><strong class="bold">    Pickup::Pickup(int type);</strong></p>
			<p class="source-code"><strong class="bold">    // Prepare a new pickup</strong></p>
			<p class="source-code"><strong class="bold">    void setArena(IntRect arena);</strong></p>
			<p class="source-code"><strong class="bold">    void spawn();</strong></p>
			<p class="source-code"><strong class="bold">    // Check the position of a pickup</strong></p>
			<p class="source-code"><strong class="bold">    FloatRect getPosition();</strong></p>
			<p class="source-code"><strong class="bold">    // Get the sprite for drawing</strong></p>
			<p class="source-code"><strong class="bold">    Sprite getSprite();</strong></p>
			<p class="source-code"><strong class="bold">    // Let the pickup update itself each frame</strong></p>
			<p class="source-code"><strong class="bold">    void update(float elapsedTime);</strong></p>
			<p class="source-code"><strong class="bold">    // Is this pickup currently spawned?</strong></p>
			<p class="source-code"><strong class="bold">    bool isSpawned();</strong></p>
			<p class="source-code"><strong class="bold">    // Get the goodness from the pickup</strong></p>
			<p class="source-code"><strong class="bold">    int gotIt();</strong></p>
			<p class="source-code"><strong class="bold">    // Upgrade the value of each pickup</strong></p>
			<p class="source-code"><strong class="bold">    void upgrade();</strong></p>
			<p class="source-code">};</p>
			<p>Let's talk briefly about each of the function definitions.</p>
			<ul>
				<li>The first function is the constructor and is named after the class. Note that it takes a single <strong class="source-inline">int</strong> parameter. This will be used to initialize the type of pickup it will be (health or ammo).</li>
				<li>The <strong class="source-inline">setArena</strong> function receives an <strong class="source-inline">IntRect</strong>. This function will be called for each <strong class="source-inline">Pickup</strong> instance at the start of each wave. The <strong class="source-inline">Pickup</strong> objects will then "know" the areas into which they can spawn.</li>
				<li>The <strong class="source-inline">spawn</strong> function will, of course, handle spawning the pickup.</li>
				<li>The <strong class="source-inline">getPosition</strong> function, just like in the <strong class="source-inline">Player</strong>, <strong class="source-inline">Zombie</strong>, and <strong class="source-inline">Bullet</strong> classes, will return a <strong class="source-inline">FloatRect</strong> instance that represents the current location of the object in the game world.</li>
				<li>The <strong class="source-inline">getSprite</strong> function returns a <strong class="source-inline">Sprite</strong> object that allows the pickup to be drawn once each frame.</li>
				<li>The <strong class="source-inline">update</strong> function receives the time the previous frame took. It uses this value to update its private variables and make decisions about when to spawn and de-spawn.</li>
				<li>The <strong class="source-inline">isSpawned</strong> function returns a Boolean that will let the calling code know whether or not the pickup is currently spawned.</li>
				<li>The <strong class="source-inline">gotIt</strong> function will be called when a collision is detected with the player. The code of the <strong class="source-inline">Pickup</strong> class can then prepare itself for respawning at the appropriate time. Note that it returns an <strong class="source-inline">int</strong> value so that the calling code knows how much the pickup is "worth" in either health or ammo. </li>
				<li>The <strong class="source-inline">upgrade</strong> function will be called when the player chooses to level up the properties of a pickup during the leveling up phase of the game.</li>
			</ul>
			<p>Now that we have gone through the member variables and function prototypes, it should be quite easy to follow along as we code the function definitions. </p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor263"/>Coding the Pickup class function definitions</h2>
			<p>Now, we can create a new <strong class="source-inline">.cpp</strong> file that will contain the function definitions. Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong>, and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Pickup.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the class.</p>
			<p>Add the following code to the <strong class="source-inline">Pickup.cpp</strong> file. Be sure to review the code so that we can discuss it:</p>
			<p class="source-code">#include "Pickup.h"</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">Pickup::Pickup(int type)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Store the type of this pickup</p>
			<p class="source-code">    m_Type = type;</p>
			<p class="source-code">    // Associate the texture with the sprite</p>
			<p class="source-code">    if (m_Type == 1)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Sprite = Sprite(TextureHolder::GetTexture(</p>
			<p class="source-code">            "graphics/health_pickup.png"));</p>
			<p class="source-code">        // How much is pickup worth</p>
			<p class="source-code">        m_Value = HEALTH_START_VALUE;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Sprite = Sprite(TextureHolder::GetTexture(</p>
			<p class="source-code">            "graphics/ammo_pickup.png"));</p>
			<p class="source-code">        // How much is pickup worth</p>
			<p class="source-code">        m_Value = AMMO_START_VALUE;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    m_Sprite.setOrigin(25, 25);</p>
			<p class="source-code">    m_SecondsToLive = START_SECONDS_TO_LIVE;</p>
			<p class="source-code">    m_SecondsToWait = START_WAIT_TIME;</p>
			<p class="source-code">}</p>
			<p>In the previous code, we added the familiar include directives. Then, we added the <strong class="source-inline">Pickup</strong> constructor. We know it is the constructor because it has the same name as the class.</p>
			<p>The constructor receives an <strong class="source-inline">int</strong> called <strong class="source-inline">type</strong> and the first thing the code does is assign the value that's received from <strong class="source-inline">type</strong> to <strong class="source-inline">m_Type</strong>. After this, there is an <strong class="source-inline">if else</strong> block that checks whether <strong class="source-inline">m_Type</strong> is equal to 1. If it is, <strong class="source-inline">m_Sprite</strong> is associated with the health pickup texture and <strong class="source-inline">m_Value</strong> is set to <strong class="source-inline">HEALTH_START_VALUE</strong>.</p>
			<p>If <strong class="source-inline">m_Type</strong> is not equal to 1, the <strong class="source-inline">else</strong> block associates the ammo pickup texture with <strong class="source-inline">m_Sprite</strong> and assigns the value of <strong class="source-inline">AMMO_START_VALUE</strong> to <strong class="source-inline">m_Value</strong>.</p>
			<p>After the <strong class="source-inline">if</strong> <strong class="source-inline">else</strong> block, the code sets the origin of <strong class="source-inline">m_Sprite</strong> to the center using the <strong class="source-inline">setOrigin</strong> function and assigns <strong class="source-inline">START_SECONDS_TO_LIVE</strong> and <strong class="source-inline">START_WAIT_TIME</strong> to <strong class="source-inline">m_SecondsToLive</strong> and <strong class="source-inline">m_SecondsToWait</strong>, respectively. </p>
			<p>The constructor has successfully prepared a <strong class="source-inline">Pickup</strong> object that is ready for use.</p>
			<p>Now, we will add the <strong class="source-inline">setArena</strong> function. Examine the code as you add it:</p>
			<p class="source-code">void Pickup::setArena(IntRect arena)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Copy the details of the arena to the pickup's m_Arena</p>
			<p class="source-code">    m_Arena.left = arena.left + 50;</p>
			<p class="source-code">    m_Arena.width = arena.width - 50;</p>
			<p class="source-code">    m_Arena.top = arena.top + 50;</p>
			<p class="source-code">    m_Arena.height = arena.height - 50;</p>
			<p class="source-code">    spawn();</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">setArena</strong> function that we just coded simply copies the values from the passed in <strong class="source-inline">arena</strong> object but varies the values by <strong class="source-inline">+ 50</strong> on the left and top and <strong class="source-inline">- 50</strong> on the right and bottom. The <strong class="source-inline">Pickup</strong> object is now aware of the area in which it can spawn. The <strong class="source-inline">setArena</strong> function then calls its own <strong class="source-inline">spawn</strong> function to make the final preparations for being drawn and updated each frame.</p>
			<p>The <strong class="source-inline">spawn</strong> function is next. Add the following code after the <strong class="source-inline">setArena</strong> function:</p>
			<p class="source-code">void Pickup::spawn()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Spawn at a random location</p>
			<p class="source-code">    srand((int)time(0) / m_Type);</p>
			<p class="source-code">    int x = (rand() % m_Arena.width);</p>
			<p class="source-code">    srand((int)time(0) * m_Type);</p>
			<p class="source-code">    int y = (rand() % m_Arena.height);</p>
			<p class="source-code">    m_SecondsSinceSpawn = 0;</p>
			<p class="source-code">    m_Spawned = true;</p>
			<p class="source-code">    m_Sprite.setPosition(x, y);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">spawn</strong> function does everything necessary to prepare the pickup. First, it seeds the random number generator and gets a random number for both the horizontal and vertical position of the object. Notice that it uses the <strong class="source-inline">m_Arena.width</strong> and <strong class="source-inline">m_Arena.height</strong> variables as the ranges for the possible horizontal and vertical positions.</p>
			<p>The <strong class="source-inline">m_SecondsSinceSpawn</strong> variable is set to zero so that the length of time that's allowed before it is de-spawned is reset. The <strong class="source-inline">m_Spawned</strong> variable is set to <strong class="source-inline">true</strong> so that, when we call <strong class="source-inline">isSpawned</strong>, from <strong class="source-inline">main</strong>, we will get a positive response. Finally, <strong class="source-inline">m_Sprite</strong> is moved into position with <strong class="source-inline">setPosition</strong>, ready for being drawn to the screen.</p>
			<p>In the following block of code, we have three simple getter functions. The <strong class="source-inline">getPosition</strong> function returns a <strong class="source-inline">FloatRect</strong> of the current position of <strong class="source-inline">m_Sprite</strong>, <strong class="source-inline">getSprite</strong> returns a copy of <strong class="source-inline">m_Sprite</strong> itself, and <strong class="source-inline">isSpawned</strong> returns <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>, depending on whether the object is currently spawned. </p>
			<p>Add and examine the code we have just discussed:</p>
			<p class="source-code">FloatRect Pickup::getPosition()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Sprite.getGlobalBounds();</p>
			<p class="source-code">}</p>
			<p class="source-code">Sprite Pickup::getSprite()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Sprite;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool Pickup::isSpawned()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Spawned;</p>
			<p class="source-code">}</p>
			<p>Next, we will code the <strong class="source-inline">gotIt</strong> function. This function will be called from <strong class="source-inline">main</strong> when the player touches/collides (gets) with the pickup. Add the <strong class="source-inline">gotIt</strong> function after the <strong class="source-inline">isSpawned</strong> function:</p>
			<p class="source-code">int Pickup::gotIt()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Spawned = false;</p>
			<p class="source-code">    m_SecondsSinceDeSpawn = 0;</p>
			<p class="source-code">    return m_Value;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">gotIt</strong> function sets <strong class="source-inline">m_Spawned</strong> to <strong class="source-inline">false</strong> so that we know not to draw and check for collisions anymore. <strong class="source-inline">m_SecondsSinceDespawn</strong> is set to zero so that the countdown to spawning begins again from the start. <strong class="source-inline">m_Value</strong> is then returned to the calling code so that the calling code can handle adding extra ammunition or health, as appropriate.</p>
			<p>Following this, we need to code the <strong class="source-inline">update</strong> function, which ties together many of the variables and functions we have seen so far. Add and familiarize yourself with the <strong class="source-inline">update</strong> function, and then we can talk about it:</p>
			<p class="source-code">void Pickup::update(float elapsedTime)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_Spawned)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_SecondsSinceSpawn += elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_SecondsSinceDeSpawn += elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Do we need to hide a pickup?</p>
			<p class="source-code">    if (m_SecondsSinceSpawn &gt; m_SecondsToLive &amp;&amp; m_Spawned)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Remove the pickup and put it somewhere else</p>
			<p class="source-code">        m_Spawned = false;</p>
			<p class="source-code">        m_SecondsSinceDeSpawn = 0;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Do we need to spawn a pickup</p>
			<p class="source-code">    if (m_SecondsSinceDeSpawn &gt; m_SecondsToWait &amp;&amp; !m_Spawned)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // spawn the pickup and reset the timer</p>
			<p class="source-code">        spawn();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">update</strong> function is divided into four blocks that are considered for execution each frame:</p>
			<ol>
				<li value="1">An <strong class="source-inline">if</strong> block that executes if <strong class="source-inline">m_Spawned</strong> is true: <strong class="source-inline">if (m_Spawned)</strong>. This block of code adds the time this frame to <strong class="source-inline">m_SecondsSinceSpawned</strong>, which keeps track of how long the pickup has been spawned.</li>
				<li>A corresponding <strong class="source-inline">else</strong> block that executes if <strong class="source-inline">m_Spawned</strong> is false. This block adds the time this frame took to <strong class="source-inline">m_SecondsSinceDeSpawn</strong>, which keeps track of how long the pickup has waited since it was last de-spawned (hidden).</li>
				<li>Another <strong class="source-inline">if</strong> block that executes when the pickup has been spawned for longer than it should have been: <strong class="source-inline">if (m_SecondsSinceSpawn &gt; m_SecondsToLive &amp;&amp; m_Spawned)</strong>. This block sets <strong class="source-inline">m_Spawned</strong> to <strong class="source-inline">false</strong> and resets <strong class="source-inline">m_SecondsSinceDeSpawn</strong> to zero. Now, block 2 will execute until it is time to spawn it again.</li>
				<li>A final <strong class="source-inline">if</strong> block that executes when the time to wait since de-spawning has exceeded the necessary wait time, and the pickup is not currently spawned: <strong class="source-inline">if (m_SecondsSinceDeSpawn &gt; m_SecondsToWait &amp;&amp; !m_Spawned)</strong>. When this block is executed, it is time to spawn the pick up again, and the <strong class="source-inline">spawn</strong> function is called.</li>
			</ol>
			<p>These four tests are what control the hiding and showing of a pickup.</p>
			<p>Finally, add the definition for the <strong class="source-inline">upgrade</strong> function:</p>
			<p class="source-code">void Pickup::upgrade()</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_Type == 1)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Value += (HEALTH_START_VALUE * .5);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Value += (AMMO_START_VALUE * .5);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Make them more frequent and last longer</p>
			<p class="source-code">    m_SecondsToLive += (START_SECONDS_TO_LIVE / 10);</p>
			<p class="source-code">    m_SecondsToWait -= (START_WAIT_TIME / 10);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">upgrade</strong> function tests for the type of pickup, either health or ammo, and then adds 50% of the (appropriate) starting value on to <strong class="source-inline">m_Value</strong>. The next two lines after the <strong class="source-inline">if</strong> <strong class="source-inline">else</strong> blocks increase the amount of time the pickup will remain spawned and decreases the amount of time the player must wait between spawns.</p>
			<p>This function is called when the player chooses to level up the pickups during the <strong class="source-inline">LEVELING_UP</strong> state. </p>
			<p>Our <strong class="source-inline">Pickup</strong> class is ready for use.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor264"/>Using the Pickup class</h1>
			<p>After all that hard work implementing the <strong class="source-inline">Pickup</strong> class, we can now go ahead and write code in the game engine to put some pickups into the game.</p>
			<p>The first thing we will do is add an include directive to the <strong class="source-inline">ZombieArena.cpp</strong> file:</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "ZombieArena.h"</p>
			<p class="source-code">#include "Player.h"</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">#include "Bullet.h"</p>
			<p class="source-code"><strong class="bold">#include "Pickup.h"</strong></p>
			<p class="source-code">using namespace sf;</p>
			<p>In this following code, we are adding two <strong class="source-inline">Pickup</strong> instances: one called <strong class="source-inline">healthPickup</strong> and another called <strong class="source-inline">ammoPickup</strong>. We pass the values 1 and 2, respectively, into the constructor so that they are initialized to the correct type of pickup. Add the following highlighted code, which we have just discussed:</p>
			<p class="source-code">// Hide the mouse pointer and replace it with crosshair</p>
			<p class="source-code">window.setMouseCursorVisible(true);</p>
			<p class="source-code">Sprite spriteCrosshair;</p>
			<p class="source-code">Texture textureCrosshair = TextureHolder::GetTexture(</p>
			<p class="source-code">         "graphics/crosshair.png");</p>
			<p class="source-code">spriteCrosshair.setTexture(textureCrosshair);</p>
			<p class="source-code">spriteCrosshair.setOrigin(25, 25);</p>
			<p class="source-code"><strong class="bold">// Create a couple of pickups</strong></p>
			<p class="source-code"><strong class="bold">Pickup healthPickup(1);</strong></p>
			<p class="source-code"><strong class="bold">Pickup ammoPickup(2);</strong></p>
			<p class="source-code">// The main game loop</p>
			<p class="source-code">while (window.isOpen())</p>
			<p>In the <strong class="source-inline">LEVELING_UP</strong> state of the keyboard handling, add the following highlighted lines within the nested <strong class="source-inline">PLAYING</strong> code block:</p>
			<p class="source-code">if (state == State::PLAYING)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Prepare the level</p>
			<p class="source-code">    // We will modify the next two lines later</p>
			<p class="source-code">    arena.width = 500;</p>
			<p class="source-code">    arena.height = 500;</p>
			<p class="source-code">    arena.left = 0;</p>
			<p class="source-code">    arena.top = 0;</p>
			<p class="source-code">    // Pass the vertex array by reference </p>
			<p class="source-code">    // to the createBackground function</p>
			<p class="source-code">    int tileSize = createBackground(background, arena);</p>
			<p class="source-code">    // Spawn the player in the middle of the arena</p>
			<p class="source-code">    player.spawn(arena, resolution, tileSize);</p>
			<p class="source-code"><strong class="bold">    // Configure the pick-ups</strong></p>
			<p class="source-code"><strong class="bold">    healthPickup.setArena(arena);</strong></p>
			<p class="source-code"><strong class="bold">    ammoPickup.setArena(arena);</strong></p>
			<p class="source-code">    // Create a horde of zombies</p>
			<p class="source-code">    numZombies = 10;</p>
			<p class="source-code">    // Delete the previously allocated memory (if it exists)</p>
			<p class="source-code">    delete[] zombies;</p>
			<p class="source-code">    zombies = createHorde(numZombies, arena);</p>
			<p class="source-code">    numZombiesAlive = numZombies;</p>
			<p class="source-code">    // Reset the clock so there isn't a frame jump</p>
			<p class="source-code">    clock.restart();</p>
			<p class="source-code">}</p>
			<p>The preceding code simply passes <strong class="source-inline">arena</strong> into the <strong class="source-inline">setArena</strong> function of each pickup. The pickups now know where they can spawn. This code executes for each new wave, so, as the arena's size grows, the <strong class="source-inline">Pickup</strong> objects will get updated.</p>
			<p>The following code simply calls the <strong class="source-inline">update</strong> function for each <strong class="source-inline">Pickup</strong> object on each frame:</p>
			<p class="source-code">// Loop through each Zombie and update them</p>
			<p class="source-code">    for (int i = 0; i &lt; numZombies; i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (zombies[i].isAlive())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            zombies[i].update(dt.asSeconds(), playerPosition);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Update any bullets that are in-flight</p>
			<p class="source-code">    for (int i = 0; i &lt; 100; i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (bullets[i].isInFlight())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            bullets[i].update(dtAsSeconds);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // Update the pickups</strong></p>
			<p class="source-code"><strong class="bold">    healthPickup.update(dtAsSeconds);</strong></p>
			<p class="source-code"><strong class="bold">    ammoPickup.update(dtAsSeconds);</strong></p>
			<p class="source-code">}// End updating the scene</p>
			<p>The following code in the draw part of the game loop checks whether the pickup is currently spawned and if it is, draws it. Let's add it:</p>
			<p class="source-code">    // Draw the player</p>
			<p class="source-code">    window.draw(player.getSprite());</p>
			<p class="source-code"><strong class="bold">    // Draw the pick-ups, if currently spawned</strong></p>
			<p class="source-code"><strong class="bold">    if (ammoPickup.isSpawned())</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        window.draw(ammoPickup.getSprite());</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    </strong></p>
			<p class="source-code"><strong class="bold">    if (healthPickup.isSpawned())</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        window.draw(healthPickup.getSprite());</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    //Draw the crosshair</p>
			<p class="source-code">    window.draw(spriteCrosshair);</p>
			<p class="source-code">}</p>
			<p>Now, you can run the game and see the pickups spawn and de-spawn. You can't, however, actually pick them up yet:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B14278_11_02.jpg" alt=""/>
				</div>
			</div>
			<p>Now that we have all the objects in our game, it is a good time to make them interact (collide) with each other.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor265"/>Detecting collisions</h1>
			<p>We just need to know when certain objects from our game touch certain other objects. We can then respond to that event in an appropriate manner. In our classes, we have already added functions that will be called when our objects collide. They are as follows:</p>
			<ul>
				<li>The <strong class="source-inline">Player</strong> class has a <strong class="source-inline">hit</strong> function. We will call it when a zombie collides with the player.</li>
				<li>The <strong class="source-inline">Zombie</strong> class has a <strong class="source-inline">hit</strong> function. We will call it when a bullet collides with a zombie.</li>
				<li>The <strong class="source-inline">Pickup</strong> class has a <strong class="source-inline">gotIt</strong> function. We will call it when the player collides with a pickup.</li>
			</ul>
			<p>If necessary, look back to refresh your memory regarding how each of those functions works. All we need to do now is detect the collisions and call the appropriate functions. </p>
			<p>We will use <strong class="bold">rectangle intersection</strong> to detect collisions. This type of collision detection is straightforward (especially with SFML). We will use the same technique that we used in the Pong game. The following image shows how a rectangle can reasonably accurately represent the zombies and the player:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B14278_11_03.jpg" alt=""/>
				</div>
			</div>
			<p>We<a id="_idTextAnchor266"/> will deal with this in three sections of code that will all follow on from one another. They will all go at the end of the update part of our game engine.</p>
			<p>We need to know the answers to the following three questions for each frame:</p>
			<ol>
				<li value="1">Has a Zombie been shot?</li>
				<li>Has the player been touched by a Zombie?</li>
				<li>Has the player touched a pickup?</li>
			</ol>
			<p>First, let's add a couple more variables for <strong class="source-inline">score</strong> and <strong class="source-inline">hiscore</strong>. We can then change them when a zombie is killed. Add the following code:</p>
			<p class="source-code">// Create a couple of pickups</p>
			<p class="source-code">Pickup healthPickup(1);</p>
			<p class="source-code">Pickup ammoPickup(2);</p>
			<p class="source-code"><strong class="bold">// About the game</strong></p>
			<p class="source-code"><strong class="bold">int score = 0;</strong></p>
			<p class="source-code"><strong class="bold">int hiScore = 0;</strong></p>
			<p class="source-code">// The main game loop</p>
			<p class="source-code">while (window.isOpen())</p>
			<p>Now, let's start by detecting whether a zombie is colliding with a bullet.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor267"/>Has a zombie been shot?</h2>
			<p>The following code might look complicated but, when we step through it, we will see it is nothing we haven't seen before. Add the following code just after the call to update the pickups each frame. Then, we can go through it:</p>
			<p class="source-code">// Update the pickups</p>
			<p class="source-code">healthPickup.update(dtAsSeconds);</p>
			<p class="source-code">ammoPickup.update(dtAsSeconds);</p>
			<p class="source-code"><strong class="bold">// Collision detection</strong></p>
			<p class="source-code"><strong class="bold">// Have any zombies been shot?</strong></p>
			<p class="source-code"><strong class="bold">for (int i = 0; i &lt; 100; i++)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    for (int j = 0; j &lt; numZombies; j++)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        if (bullets[i].isInFlight() &amp;&amp; </strong></p>
			<p class="source-code"><strong class="bold">            zombies[j].isAlive())</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            if (bullets[i].getPosition().intersects</strong></p>
			<p class="source-code"><strong class="bold">                (zombies[j].getPosition()))</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                // Stop the bullet</strong></p>
			<p class="source-code"><strong class="bold">                bullets[i].stop();</strong></p>
			<p class="source-code"><strong class="bold">                // Register the hit and see if it was a kill</strong></p>
			<p class="source-code"><strong class="bold">                if (zombies[j].hit()) </strong></p>
			<p class="source-code"><strong class="bold">                {</strong></p>
			<p class="source-code"><strong class="bold">                    // Not just a hit but a kill too</strong></p>
			<p class="source-code"><strong class="bold">                    score += 10;</strong></p>
			<p class="source-code"><strong class="bold">                    if (score &gt;= hiScore)</strong></p>
			<p class="source-code"><strong class="bold">                    {</strong></p>
			<p class="source-code"><strong class="bold">                        hiScore = score;</strong></p>
			<p class="source-code"><strong class="bold">                    }</strong></p>
			<p class="source-code"><strong class="bold">                    numZombiesAlive--;</strong></p>
			<p class="source-code"><strong class="bold">                    // When all the zombies are dead (again)</strong></p>
			<p class="source-code"><strong class="bold">                    if (numZombiesAlive == 0) {</strong></p>
			<p class="source-code"><strong class="bold">                        state = State::LEVELING_UP;</strong></p>
			<p class="source-code"><strong class="bold">                    }</strong></p>
			<p class="source-code"><strong class="bold">                }    </strong></p>
			<p class="source-code"><strong class="bold">                </strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}// End zombie being shot</p>
			<p>In the next section, we will see all the zombie and bullet collision detection code again. We will do so a bit at a time so that we can discuss it. First of all, notice the structure of the nested <strong class="source-inline">for</strong> loops in the preceding code (with some code stripped out), as shown again here:</p>
			<p class="source-code">// Collision detection</p>
			<p class="source-code">// Have any zombies been shot?</p>
			<p class="source-code">for (int i = 0; i &lt; 100; i++)</p>
			<p class="source-code">{</p>
			<p class="source-code">    for (int j = 0; j &lt; numZombies; j++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        ...</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The code loops through every bullet (0 to 99) for each and every zombie (0 to less than <strong class="source-inline">numZombies</strong>.).</p>
			<p>Within the nested <strong class="source-inline">for</strong> loops, we do the following.</p>
			<p>We check whether the current bullet is in flight and the current zombie is still alive with the following code:</p>
			<p class="source-code">if (bullets[i].isInFlight() &amp;&amp; zombies[j].isAlive())</p>
			<p>Provided the zombie is alive and the bullet is in flight, we test for a rectangle intersection with the following code:</p>
			<p class="source-code">if (bullets[i].getPosition().intersects(zombies[j].getPosition()))</p>
			<p>If the current bullet and zombie have collided, then we take a number of steps, as detailed next.</p>
			<p>Stop the bullet with the following code:</p>
			<p class="source-code">// Stop the bullet</p>
			<p class="source-code">bullets[i].stop();</p>
			<p>Register a hit with the current zombie by calling its <strong class="source-inline">hit</strong> function. Note that the <strong class="source-inline">hit</strong> function returns a Boolean that lets the calling code know whether the zombie is dead yet. This is shown in the following line of code:</p>
			<p class="source-code">// Register the hit and see if it was a kill</p>
			<p class="source-code">if (zombies[j].hit()) {</p>
			<p>Inside this <strong class="source-inline">if</strong> block, which detects when the zombie is dead and hasn't just wounded us, do the following:</p>
			<ul>
				<li>Add ten to <strong class="source-inline">score</strong>.</li>
				<li>Change <strong class="source-inline">hiScore</strong> if the score the player has achieved has exceeded (beaten) <strong class="source-inline">score</strong>.</li>
				<li>Reduce <strong class="source-inline">numZombiesAlive</strong> by one.</li>
				<li>Check whether all the zombies are dead with <strong class="source-inline">(numZombiesAlive == 0)</strong> and if so, change <strong class="source-inline">state</strong> to <strong class="source-inline">LEVELING_UP</strong>.</li>
			</ul>
			<p>Here is the block of code inside <strong class="source-inline">if(zombies[j].hit())</strong> that we have just discussed:</p>
			<p class="source-code">// Not just a hit but a kill too</p>
			<p class="source-code">score += 10;</p>
			<p class="source-code">if (score &gt;= hiScore)</p>
			<p class="source-code">{</p>
			<p class="source-code">    hiScore = score;</p>
			<p class="source-code">}</p>
			<p class="source-code">numZombiesAlive--;</p>
			<p class="source-code">// When all the zombies are dead (again)</p>
			<p class="source-code">if (numZombiesAlive == 0) </p>
			<p class="source-code">{</p>
			<p class="source-code">    state = State::LEVELING_UP;</p>
			<p class="source-code">}</p>
			<p>That's the zombies and the bullets taken care of. You can now run the game and see the blood. Of course, you won't see the score until we implement the HUD in the next chapter.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor268"/>Has the player been touched by a zombie?</h2>
			<p>This code is much shorter and simpler than the zombie and bullet collision detection code. Add the following highlighted code just after the previous code we wrote:</p>
			<p class="source-code">}// End zombie being shot</p>
			<p class="source-code"><strong class="bold">// Have any zombies touched the player            </strong></p>
			<p class="source-code"><strong class="bold">for (int i = 0; i &lt; numZombies; i++)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    if (player.getPosition().intersects</strong></p>
			<p class="source-code"><strong class="bold">        (zombies[i].getPosition()) &amp;&amp; zombies[i].isAlive())</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        if (player.hit(gameTimeTotal))</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            // More here later</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        if (player.getHealth() &lt;= 0)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            state = State::GAME_OVER;            </strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}// End player touched</p>
			<p>Here, we detect whether a zombie has collided with the player by using a <strong class="source-inline">for</strong> loop to go through all the zombies. For each zombie that is alive, the code uses the <strong class="source-inline">intersects</strong> function to test for a collision with the player. When a collision has occurred, we call <strong class="source-inline">player.hit</strong>. Then, we check whether the player is dead by calling <strong class="source-inline">player.getHealth</strong>. If the player's health is equal to or less than zero, then we change <strong class="source-inline">state</strong> to <strong class="source-inline">GAME_OVER</strong>.</p>
			<p>You can run the game and collisions will be detected. However, as there is no HUD or sound effects yet, it is not clear that this is happening. In addition, we need to do some more work resetting the game when the player had died, and a new game is starting. So, although the game runs, the results are not especially satisfying right now. We will improve this over the next two chapters.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor269"/>Has the player touched a pickup?</h2>
			<p>The collision detection code between the player and each of the two pickups is shown here. Add the following highlighted code just after the previous code that we added:</p>
			<p class="source-code">    }// End player touched</p>
			<p class="source-code"><strong class="bold">    // Has the player touched health pickup</strong></p>
			<p class="source-code"><strong class="bold">    if (player.getPosition().intersects</strong></p>
			<p class="source-code"><strong class="bold">        (healthPickup.getPosition()) &amp;&amp; healthPickup.isSpawned())</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        player.increaseHealthLevel(healthPickup.gotIt());</strong></p>
			<p class="source-code"><strong class="bold">        </strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    // Has the player touched ammo pickup</strong></p>
			<p class="source-code"><strong class="bold">    if (player.getPosition().intersects</strong></p>
			<p class="source-code"><strong class="bold">        (ammoPickup.getPosition()) &amp;&amp; ammoPickup.isSpawned())</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        bulletsSpare += ammoPickup.gotIt();</strong></p>
			<p class="source-code"><strong class="bold">        </strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}// End updating the scene</p>
			<p>The preceding code uses two simple <strong class="source-inline">if </strong>statements to see whether either <strong class="source-inline">healthPickup</strong> or <strong class="source-inline">ammoPickup</strong> have been touched by the player.</p>
			<p>If a health pickup has been collected, then the <strong class="source-inline">player.increaseHealthLevel</strong> function uses the value returned from the <strong class="source-inline">healthPickup.gotIt</strong> function to increase the player's health.</p>
			<p>If an ammo pickup has been collected, then <strong class="source-inline">bulletsSpare</strong> is increased by the value that's returned from <strong class="source-inline">ammoPickup.gotIt</strong>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can now run the game, kill zombies, and collect pickups! Note that, when your health equals zero, the game will enter the <strong class="source-inline">GAME_OVER</strong> state and pause. To restart it, you will need to press <strong class="source-inline">Enter</strong>, followed by a number between 1 and 6. When we implement the HUD, the home screen, and the leveling up screen, these steps will be intuitive and straightforward for the player. We will do so in the next chapter.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor270"/>Summary</h1>
			<p>This was a busy chapter, but we achieved a lot. Not only did we add bullets and pickups to the game through two new classes, but we also made all the objects interact as they should by detecting when they collide with each other.</p>
			<p>Despite these achievements, we need to do more work to set up each new game and to give the player feedback through a HUD. In the next chapter, we will build the HUD.</p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor271"/>FAQ</h1>
			<p>Here are some questions that might be on your mind:</p>
			<p>Q) Are there any better ways of doing collision detection?</p>
			<p>A) Yes. There are lots more ways to do collision detection, including but not limited to the following.</p>
			<ul>
				<li>You can divide objects up into multiple rectangles that fit the shape of the sprite better. It is perfectly manageable for C++ to check on thousands of rectangles each frame. This is especially the case when you use techniques such as neighbor checking to reduce the number of tests that are necessary each frame.</li>
				<li>For circular objects, you can use the radius overlap method.</li>
				<li>For irregular polygons, you can use the passing number algorithm.</li>
			</ul>
			<p>You can review all of these techniques, if you wish, by taking a look at the following links:</p>
			<ul>
				<li>Neighbor checking: <a href="http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/">http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/</a></li>
				<li>Radius overlap method: <a href="http://gamecodeschool.com/essentials/collision-detection-radius-overlap/">http://gamecodeschool.com/essentials/collision-detection-radius-overlap/</a></li>
				<li>Crossing number algorithm: <a href="http://gamecodeschool.com/essentials/collision-detection-crossing-number/">http://gamecodeschool.com/essentials/collision-detection-crossing-number/</a></li>
			</ul>
		</div>
	</body></html>