- en: Chapter 8. The More You Know – Common Game Programming Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 知识越多越好 – 常见游戏编程模式
- en: As we move past the halfway point of this book, the bells and whistles in our
    games are going to get more and more advanced. To showcase them properly, the
    genre of our final project will be a classical 2D **Role Playing Game** with orthographic
    projection. With our code-base growing at a rapid rate, poor design quickly becomes
    tedious to maintain, or even unmanageable. As new features get added, we want
    expansion of code to be easy and not slow down the overall process. This is the
    area where game programming patterns shine the brightest.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们这本书过半，我们游戏中的功能和装饰将越来越复杂。为了正确展示它们，我们最终项目的类型将是一个经典的二维 **角色扮演游戏**，采用正交投影。随着我们的代码库以快速的速度增长，糟糕的设计很快就会变得难以维护，甚至难以管理。随着新功能的添加，我们希望代码的扩展变得容易，而不是减慢整体过程。这正是游戏编程模式最闪耀的地方。
- en: 'In this chapter, we will be covering:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The design and implementation of the entity component system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体组件系统的设计和实现
- en: Inter-system communication using the observer pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用观察者模式进行跨系统通信
- en: Render ordering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染顺序
- en: Implementation of map layers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图层的实现
- en: Let's not waste any time and jump right into making our code base more robust!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要浪费时间，直接进入使我们的代码库更健壮的步骤！
- en: Use of copyrighted resources
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版权资源的利用
- en: 'Once again, before beginning this chapter, we''d like to give credit where
    credit''s due. The graphics used for the third project of this book consist of
    but are not limited to:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，在开始本章之前，我们希望对应该给予的赞誉给予应有的认可。本书第三个项目的图形资源包括但不限于：
- en: '*[LPC] Medieval fantasy character sprites* by *wulax* under CC-BY-SA 3.0 and
    GPL 3.0 licenses:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由 *wulax* 根据 CC-BY-SA 3.0 和 GPL 3.0 许可证提供的 *[LPC] 中世纪幻想角色精灵*：
- en: '[http://opengameart.org/content/lpc-medieval-fantasy-character-sprites](http://opengameart.org/content/lpc-medieval-fantasy-character-sprites)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://opengameart.org/content/lpc-medieval-fantasy-character-sprites](http://opengameart.org/content/lpc-medieval-fantasy-character-sprites)'
- en: '*Lots of free 2D tiles and sprites* by *Hyptosis* under the CC-BY 3.0 license:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由 *Hyptosis* 提供 *大量免费的2D瓦片和精灵*，根据 CC-BY 3.0 许可证：
- en: '[http://opengameart.org/content/lots-of-free-2d-tiles-and-sprites-by-hyptosis](http://opengameart.org/content/lots-of-free-2d-tiles-and-sprites-by-hyptosis)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://opengameart.org/content/lots-of-free-2d-tiles-and-sprites-by-hyptosis](http://opengameart.org/content/lots-of-free-2d-tiles-and-sprites-by-hyptosis)'
- en: 'All of the licenses that apply to the use of these resources can be found here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于这些资源使用的所有许可证都可以在这里找到：
- en: '[http://creativecommons.org/licenses/by/3.0/](http://creativecommons.org/licenses/by/3.0/)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://creativecommons.org/licenses/by/3.0/](http://creativecommons.org/licenses/by/3.0/)'
- en: '[http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/)'
- en: '[http://www.gnu.org/licenses/gpl-3.0.html](http://www.gnu.org/licenses/gpl-3.0.html)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.gnu.org/licenses/gpl-3.0.html](http://www.gnu.org/licenses/gpl-3.0.html)'
- en: What is a programming pattern?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是编程模式？
- en: Programming patterns, or design patterns, at they're more commonly referred
    to, are reusable and widely-implemented solutions to a given problem. That is
    not to say that these patterns exist as some sort of libraries out there, although
    there are libraries based on them. Instead, a programming pattern is more of an
    idea or a strategy. It is a well laid out plan on tackling a certain problem,
    the best possible answer to a given problematic situation, proven by time and
    experience, which is one of the the best reasons they should be used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编程模式，或称为设计模式，是针对特定问题的可重用和广泛实施的解决方案。这并不是说这些模式作为某种库存在，尽管基于它们的库是存在的。相反，编程模式更多的是一种想法或策略。它是对解决某个问题的精心设计的计划，是对给定问题情境的最佳可能答案，这是经过时间和经验证明的，这也是它们应该被使用的一个最好的理由。
- en: 'There are quite a few design patterns out there, as well as books, tutorials
    and even classes dedicated solely to understanding and implementing them. For
    our purposes, we''re going to be covering four: the entity component system, event
    queue, observer and factory patterns. We''ll be talking about each one separately,
    as they''re non overlapping in function, even though they can be working together.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多设计模式，以及书籍、教程甚至专门用于理解和实现它们的课程。为了我们的目的，我们将介绍四种：实体组件系统、事件队列、观察者和工厂模式。我们将分别讨论每一个，尽管它们在功能上不重叠，但它们可以一起工作。
- en: The entity component system
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体组件系统
- en: The **entity component system** is a programming pattern, which allows entities
    to possess properties and functionality through the means of composition, as opposed
    to inheritance. The biggest benefits of using this pattern include stronger decoupling
    of logic, easier serialization and de-serialization of entities, better reusability
    of code and ease of creating new entities. It does, however, add a fair bit of
    complexity to your code base.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体组件系统**是一种编程模式，它允许实体通过组合的方式拥有属性和功能，而不是通过继承。使用这种模式的最大好处包括逻辑更强的解耦、更容易的实体序列化和反序列化、更好的代码重用性以及创建新实体的简便性。然而，它确实会给你的代码库增加相当多的复杂性。'
- en: 'The typical implementation of this pattern consists of three parts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的典型实现包括三个部分：
- en: '**Entities**: In most cases, entities are barely anything more than identifiers,
    slapped on a collection of components'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：在大多数情况下，实体几乎只是标识符，被贴在一系列组件上'
- en: '**Components**: These are the building blocks of entities, that are nothing
    more than collections of data'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**是实体的构建块，它们不过是数据的集合'
- en: '**Systems**: These are specialized classes that deal with a very specific task
    and are responsible for holding all of the logic in this paradigm'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统**：这些是专门处理非常特定任务的类，并负责持有这个范式中的所有逻辑'
- en: In addition to working with these three distinct types of elements, our entity
    component system is also going to need an entity manager to keep and manage all
    of the entity and component data, as well as the system manager, which will be
    responsible for updating each system, in addition to some other functionality
    we'll be covering soon.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理这三种不同的元素类型外，我们的实体组件系统还需要一个实体管理器来保存和管理所有实体和组件数据，以及系统管理器，它将负责更新每个系统，此外还有一些我们很快会介绍的功能。
- en: 'In order to differentiate between different types of components and systems,
    we''re going to create a new header file, `ECS_Types.h`, which will be used to
    store this information:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分不同类型的组件和系统，我们将创建一个新的头文件，`ECS_Types.h`，该文件将用于存储这些信息：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In addition to component and system enumerations, we're also aliasing an unsigned
    integer to act as the component type and defining a macro `N_COMPONENT_TYPES`,
    which represents the maximum number of component types we can have.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了组件和系统枚举之外，我们还别名一个无符号整数作为组件类型，并定义了一个宏`N_COMPONENT_TYPES`，它代表我们可以拥有的最大组件类型数。
- en: What is a component?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是组件？
- en: 'Within the entity component system paradigm, a **component** is the smallest,
    non-overlapping aspect of an entity, such as its position, velocity or a sprite.
    From the programming point of view, however, it is nothing more than a simple
    data structure, which has no real logic in it. Its only job is storing information
    about the feature of an entity it represents, as illustrated below:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体组件系统范式内，**组件**是实体的最小、非重叠的部分，例如其位置、速度或精灵。然而，从编程的角度来看，它不过是一个简单的数据结构，其中没有任何真正的逻辑。它的唯一任务是存储它所代表的实体特征信息，如下所示：
- en: '![What is a component?](img/B04284_08_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![什么是组件？](img/B04284_08_01.jpg)'
- en: 'In order to store components easily, they have to rely on principles of inheritance.
    Let''s take a look at a base component class definition:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松存储组件，它们必须依赖于继承原则。让我们看看一个基组件类的定义：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The constructor of our component base class will take in the type of the component
    it represents. One thing to note is the overloaded `>>` operator, which calls
    a purely virtual function `ReadIn`. This serves as a quick way to read component
    data in from a file. Because each component is unique, it defines its own version
    of the `ReadIn` method in order to load its data correctly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件基类的构造函数将接受它所代表的组件类型。需要注意的是重载的`>>`运算符，它调用一个纯虚函数`ReadIn`。这提供了一种快速从文件中读取组件数据的方法。因为每个组件都是唯一的，它定义了自己的`ReadIn`方法版本，以便正确地加载数据。
- en: The position component
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置组件
- en: 'A good example of putting the base component class to work is actually implementing
    the first and arguably most common type of component: **position**.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将基组件类投入实际应用的一个好例子是实现第一种也是最具普遍性的组件类型：**位置**。
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The constructor of our component base class is invoked in the initializer list,
    with the component type being passed in as the only argument. Although there are
    better ways of assigning individual component types their own unique identifiers,
    it's better to start simple for clarity's sake.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件基类的构造函数在初始化列表中被调用，组件类型作为唯一参数传递。虽然还有更好的方法为单个组件类型分配它们自己的唯一标识符，但为了清晰起见，最好从简单开始。
- en: 'This component keeps track of three pieces of data: its current position, the
    position it was at during the previous cycle, and the current elevation of an
    entity, which is simply a value that represents how high the entity is in relation
    to the map.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件跟踪三份数据：其实际位置、前一个周期时的位置以及实体的当前高度，这是一个表示实体相对于地图高度的值。
- en: Much like any other component we will be covering later in the chapter, it offers
    a number of methods for modifying and obtaining its data members. While making
    its data members publically available is perfectly valid, offering helper methods
    reduces code redundancy and offers a familiar interface.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章后面将要介绍的其他任何组件一样，它提供了一系列修改和获取其数据成员的方法。虽然公开其数据成员是完全可以接受的，但提供辅助方法可以减少代码冗余并提供一个熟悉的接口。
- en: Lastly, note the implementation of the `ReadIn` method. It uses a `stringstream`
    object as an argument and loads the relevant pieces of data from it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意`ReadIn`方法的实现。它使用一个`stringstream`对象作为参数，并从中加载相关的数据。
- en: The bitmask
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位掩码
- en: Having a lightweight, easy-to-use as well as easy-to-expend data structure,
    representing the makeup of any given entity, as well as a set of requirements
    imposed by a system saves a lot of headaches. For us, that data structure is a
    **bitmask**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个轻量级、易于使用且易于扩展的数据结构，它可以表示任何给定实体的组成，以及系统强加的一组要求，这可以节省很多麻烦。对我们来说，这个数据结构是一个**位掩码**。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The standard template library provides its own version of a bitmask: the `std::bitset`.
    For educational purposes, we''re going to be implementing our own version of this
    class.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 标准模板库提供了一个自己的位掩码版本：`std::bitset`。出于教育目的，我们将实现这个类的自己的版本。
- en: As you probably know already, in binary, any and all numbers can be represented
    as a combination of zeroes and ones. However, who's to say that those two values
    have to be used only to represent a number? With some quick bitwise operator magic,
    any simple integer can be turned into a string of continuous flags that represent
    different aspects of an entity, such as which components it has, or types of components
    it needs to have in order to belong to a system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经知道，在二进制中，任何和所有数字都可以表示为零和一的组合。然而，谁又能说这两个值只能用来表示一个数字呢？通过一些快速的位运算符魔法，任何简单的整数都可以转换成一系列连续的标志，这些标志代表实体的不同方面，例如它具有哪些组件，或者它需要具有哪些类型的组件才能属于一个系统。
- en: 'Consider the following illustration:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下插图：
- en: '![The bitmask](img/B04284_08_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![位掩码](img/B04284_08_02.jpg)'
- en: 'The only real difference in practice would be a lot more than eight flags available.
    Let''s get coding:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上的唯一真正区别是可用的标志比八个多得多。让我们开始编码：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We begin by defining the data type for our bitset, kindly provided by the `stdint.h`
    header. As the name implies, the `uint32_t` type is exactly 32 bits wide. Using
    this type, and not, let's say, a typical integer, eliminates the possibility of
    cross-platform differences. A regular integer could take up less or more memory,
    depending on the platform our code is executed on. Using specialized types from
    the `stdint.h` header ensures the exact same results, regardless of platform differences.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了bitset的数据类型，这个数据类型由`stdint.h`头文件友好地提供。正如其名所示，`uint32_t`类型正好是32位宽。使用这种类型，而不是，比如说，一个典型的整数，消除了跨平台差异的可能性。一个常规整数可能根据我们的代码在哪个平台上执行而占用更少或更多的内存。使用`stdint.h`头文件中的专用类型确保无论平台差异如何，都能得到相同的结果。
- en: The majority of the `Bitmask` class consists of nothing but bitwise operations,
    which are an essential part of the C/C++ background. If you are not yet familiar
    with them, it's not the end of the world, however, it would be more beneficial
    to at least understand how they work before moving forward.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bitmask`类的大部分内容都是位运算，这是C/C++背景的一个基本组成部分。如果您还不熟悉它们，那也不是世界末日，然而，在继续前进之前至少了解它们是如何工作的会更有益。'
- en: Managing entities
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理实体
- en: 'Now that we have the building blocks of entities defined, it''s time to talk
    about storing and managing them. As mentioned previously, all an entity is at
    this point is a single identifier. Knowing that, we can begin shaping the way
    this data is going to be stored, beginning, as always, with the definition of
    data types to be used:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了实体的构建块，是时候讨论存储和管理它们了。如前所述，目前实体只是一个单一的标识符。了解这一点后，我们可以开始塑造这种数据存储的方式，一如既往地，从定义要使用的数据类型开始：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first data type we'll be working with is the entity identifier, once again
    represented by an unsigned integer. Next, a container is needed to hold all of
    the components for an entity. A vector works just fine for this purpose. Following
    that, we define a pair, a bitmask and the component container, which will hold
    all of the information about the entity. The bitmask is used here in order to
    alleviate the need to iterate over containers searching for components, when it
    can be quickly queried for the same purpose. The last piece of the entity puzzle
    is mapping an entity identifier to all of its data, for which we'll be using the
    `unordered_map`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的第一种数据类型是实体标识符，它再次由一个无符号整数表示。接下来，需要一个容器来存储实体的所有组件。向量非常适合这个目的。随后，我们定义了一对，一个位掩码和组件容器，它们将存储有关实体的所有信息。位掩码在这里被用来减轻在容器中迭代以查找组件的需求，当可以快速查询以实现相同目的时。实体拼图的最后一部分是将实体标识符映射到所有其数据上，我们将使用`unordered_map`来完成这项工作。
- en: In order to generate different component types with as little code as possible,
    we'll be using our trusty lambda-expression factory method here as well. The last
    four lines of type definitions here make that possible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能少地编写代码来生成不同的组件类型，我们在这里也将使用我们信任的lambda表达式工厂方法。这里类型定义的最后四行使得这一点成为可能。
- en: 'Having all of the data types defined allows us to finally take a look at the
    entity manager class declaration:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了所有数据类型后，我们终于可以查看实体管理器类的声明了：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In a fairly predictable fashion, we have all of the methods that would exist
    in any other class that serves as a container. Two different versions of adding
    entities are provided, one based on a bitmask passed in as an argument, and the
    other for loading an entity configuration from a file. The method for obtaining
    a component from a specific entity is templated, reducing the amount of code that
    has to be written outside of this class in order to obtain the type of component
    that is desired. Let''s take a look at how it''s implemented:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以相当可预测的方式，我们拥有任何其他作为容器存在的类中可能存在的所有方法。提供了两种不同的添加实体版本，一种基于作为参数传递的位掩码，另一种是从文件中加载实体配置。从特定实体获取组件的方法是模板化的，这减少了在类外编写以获取所需组件类型代码的数量。让我们看看它是如何实现的：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The entity argument passed into the method is evaluated first, in order to determine
    if one with the provided identifier exists. If it does, the bitmask of that entity
    is checked to verify that a component with the requested type is part of it. The
    component is then located in the vector and returned as the dynamically-cast type
    of the template.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先评估传递给方法中的实体参数，以确定是否存在具有提供标识符的实体。如果存在，则检查该实体的位掩码以验证请求类型的组件是否是其一部分。然后在该向量中定位组件，并以模板的动态类型返回。
- en: Implementing the entity manager
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现实体管理器
- en: 'With the class definition out of the way, we can start implementing its methods.
    As per usual, let''s address the constructor and destructor of the entity manager
    class first:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完类定义后，我们可以开始实现其方法。按照惯例，让我们首先处理实体管理器类的构造函数和析构函数：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The constructor takes in a pointer to the `SystemManager` class, which we will
    be implementing shortly, as well as a pointer the `TextureManager`. In its initializer
    list, the `idCounter` data member is set to zero. This is simply a variable that
    will be used to keep track of the last identifier that was given to an entity.
    Additionally, both the system manager and the texture manager pointers are stored
    for later reference. The last purpose of the constructor is adding all of the
    different types of components to the component factory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接收一个指向`SystemManager`类的指针，我们将在不久后实现它，以及一个指向`TextureManager`的指针。在其初始化列表中，`idCounter`数据成员被设置为零。这是一个变量，将用于跟踪分配给实体的最后一个标识符。此外，系统管理器和纹理管理器指针被存储以供以后参考。构造函数的最后一个目的是将所有不同类型的组件添加到组件工厂中。
- en: The destructor simply invokes a `Purge` method, which will be used to clean
    up all of the dynamically allocated memory and clear all possible containers in
    this class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数简单地调用一个`Purge`方法，该方法将用于清理所有动态分配的内存并清除此类中所有可能的容器。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the case of adding an entity based on the provided bitmask, a new entity
    pair is inserted into the entity container first. If the insertion was successful,
    a `for` loop iterates over all possible types of components and checks the mask
    for that type. The `AddComponent` method is then invoked, if the bitmask has the
    said type enabled.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在根据提供的位掩码添加实体的情况下，首先将新的实体对插入到实体容器中。如果插入成功，则`for`循环遍历所有可能的组件类型，并检查该类型的掩码。如果位掩码启用了该类型，则调用`AddComponent`方法。
- en: After the component insertion, the system manager is notified of an entity being
    modified, or, in this case, inserted. The entity identifier, along with the bitmask
    of the said entity is passed into the `EntityModified` method of the system manager.
    An event is also created to alert the systems that this entity just spawned.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件插入后，系统管理员被通知实体已被修改，或者在这种情况下，被插入。实体标识符以及该实体的位掩码被传递到系统管理员的`EntityModified`方法中。同时创建一个事件来提醒系统这个实体刚刚生成。
- en: The identifier of the newly created entity is then returned. If the method failed
    to add an entity, -1 is returned instead, to signify an error.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后返回新创建的实体的标识符。如果方法未能添加实体，则返回-1，以表示错误。
- en: 'Removing an entity is every bit as easy, if not more so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 删除实体同样简单，甚至可能更简单：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the entity is successfully located in the entity container, the dynamically
    allocated memory of every single component it has is first freed, and the component
    is then removed from the vector. The entity itself is then erased from the entity
    container and the system manager is notified of its removal.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体容器中成功定位实体后，首先释放它所拥有的每个组件的动态分配的内存，然后从向量中删除组件。然后实体本身从实体容器中被删除，并且系统管理员被通知其删除。
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding a component to an entity begins by verifying an entity with the provided
    identifier exists. If it does, and if there isn't already a component of that
    type added to the entity, the lambda-function container is queried for the desired
    type. Once the memory for the component is allocated, it's pushed into the component
    vector. The bitmask is then modified to reflect the changes made to the entity.
    The system manager is notified of those changes as well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 向实体添加组件的过程首先是通过提供的标识符验证实体是否存在。如果存在，并且该实体尚未添加该类型的组件，则查询lambda函数容器以获取所需类型的组件。一旦为组件分配了内存，它就被推入组件向量中。然后修改位掩码以反映对实体的更改。系统管理员也会被通知这些更改。
- en: 'Predictably, a very similar process takes place when removing the component
    from an entity:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 预计在从实体中删除组件时，发生的过程非常相似：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After confirming that both the entity and component exist, the memory allocated
    for the component is freed and the component itself is erased. The bitmask also
    gets modified to reflect these changes. Much like before, the system manager needs
    to know if an entity was altered, so the `EntityModified` method is invoked.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 确认实体和组件都存在后，为组件分配的内存被释放，组件本身也被删除。位掩码也相应地修改以反映这些变化。就像之前一样，系统管理员需要知道实体是否被修改，因此调用`EntityModified`方法。
- en: 'A fairly useful method to have for outside classes is one that checks if an
    entity has a certain type of component:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于课外活动来说，有一个非常有用的方法是检查一个实体是否具有某种类型的组件：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This follows the same pattern as before by checking if an entity exists first,
    then checking its bitmask for a certain component type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它遵循之前的模式，首先检查实体是否存在，然后检查其位掩码以确定是否存在特定类型的组件。
- en: 'It''s cleanup time. Correctly disposing of all allocated resources is left
    up to the `Purge` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 清理时间到了。正确处理所有分配的资源留给`Purge`方法：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The system manager is notified to remove all of its entities first. While iterating
    over all of the entities in storage, it frees up the memory of every single component.
    The component container is then cleared. Lastly, the entity container itself is
    cleared and the identification counter is set back to 0.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员首先被通知删除所有实体。在遍历存储中的所有实体时，它会释放每个组件的内存。然后清除组件容器。最后，清除实体容器本身，并将标识符计数器重置为0。
- en: The factory pattern
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂模式
- en: With complex data structures such as entities, chances are the programmer will
    not be setting up and initializing every single component by hand. Setting up
    entities with any arrangement of components quickly and with as little repeated
    code as possible is very much the goal here. Luckily, a programming pattern exists
    to solve this particular problem. It is simply referred to as the **factory**
    pattern.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像实体这样的复杂数据结构，程序员可能不会手动设置和初始化每个组件。快速设置具有任何组件排列的实体，并尽可能减少重复代码，这是这里的主要目标。幸运的是，存在一种编程模式可以解决这个特定问题。它简单地被称为**工厂**模式。
- en: 'The philosophy of use for this neat pattern is quite simple. There exists a
    class with some abstract method that takes in one or two arguments, pertaining
    to some vague identifying qualities. This class then generates, based on the information
    it was given, a class or a number of classes and returns a handle to them, effectively
    cutting out the part where data allocation or member initialization is done by
    hand. In other words, it is given a blueprint and produces a product based on
    it, hence the name "factory". This functionality was already achieved in a way
    by creating entities based on a bitmask, however, no actual data was initialized,
    only the defaults. Having a more pristine way of actually setting up these entities
    requires a more elaborate blueprint, so why not use text files? For example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种整洁模式的用法哲学相当简单。存在一个类，它包含一些抽象方法，这些方法接受一个或两个参数，这些参数与一些模糊的识别特性相关。然后，根据它所提供的信息，这个类生成一个或多个类，并返回它们的句柄，实际上消除了手动进行数据分配或成员初始化的部分。换句话说，它提供了一个蓝图，并根据它生成产品，因此得名“工厂”。这种功能已经通过基于位掩码创建实体来实现，然而，实际上并没有初始化任何数据，只是设置了默认值。要更纯净地设置这些实体，需要一个更详细的蓝图，所以为什么不使用文本文件呢？例如：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This format would allow everything there is to an entity to be stored in plain
    text as a blueprint and loaded at any time to produce any number of entities with
    exactly the same qualities. Let''s take a look at how processing entity files
    could be achieved:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式允许将实体的所有内容以纯文本形式存储为蓝图，并在任何时间加载以生成具有完全相同特性的任意数量的实体。让我们看看如何实现处理实体文件：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Loading entity files isn't much different from any other files we've processed
    in the past. For now, reading entity names hasn't yet been implemented. The attributes
    line is simply the numeric value that the bitmask has with the desired components
    enabled. Once that value is read in, we pass it in to the other version of `AddEntity`,
    in order to create it and have all of the components properly allocated.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 加载实体文件与我们过去处理的其他文件没有太大区别。目前，读取实体名称尚未实现。属性行只是位掩码与已启用的所需组件的数值。一旦读取了这个值，我们就将其传递给`AddEntity`的其他版本，以创建它并确保所有组件都正确分配。
- en: Reading in the actual components is slightly more complicated. First, we must
    make sure that the entity has been created. This means that the "Attributes" line
    has to come before the individual component data in the entity file. If the entity
    ID is greater than -1, we proceed with reading in the component ID and obtaining
    the actual object based on it. The overloaded `>>` operator comes in handy here,
    since it greatly simplifies actually streaming in the component data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 读取实际组件稍微复杂一些。首先，我们必须确保实体已经被创建。这意味着“属性”行必须在实体文件中各个组件数据之前。如果实体ID大于-1，我们继续读取组件ID并根据它获取实际对象。重载的`>>`运算符在这里很有用，因为它极大地简化了实际流式传输组件数据。
- en: Lastly, due to the nature of resource handling, the component type has to be
    checked in order to provide its instance with a pointer to the texture manager
    class, if it needs it. We haven't yet created such components, however one of
    them will be the sprite sheet component that will represent some entities.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于资源管理的性质，必须检查组件类型，以便为其实例提供一个指向纹理管理器类的指针，如果需要的话。我们还没有创建这样的组件，然而其中之一将是代表某些实体的精灵图组件。
- en: Designing the systems
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计系统
- en: With the data side of this paradigm being accounted for, the last remaining
    component remains to be the **system**. As the name loosely implies, systems are
    responsible for handling all of the logic that takes place inside and between
    components. Things ranging from sprites being rendered to collision checks are
    all handled by their own, respective systems to ensure complete separation between
    non-overlapping parts of the game. At least, that's how it should play out in
    an ideal world. In reality, as hard as one tries to decouple and categorize logic
    or data, some things still remain loosely connected, which is just the nature
    of the beast. Information still has to be traded between systems, however. Certain
    functionality also needs to be invoked as a consequence of a totally unrelated
    system's actions. To put it simply, there needs to be a way for systems to talk
    to each other without them knowing anything about how the other one works.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了这一范式的数据方面之后，最后一个剩余的组件就是**系统**。正如其名称所暗示的，系统负责处理组件内部和之间的所有逻辑。从精灵渲染到碰撞检测等所有事情都是由各自的系统处理的，以确保游戏非重叠部分之间的完全分离。至少，在理想世界中应该是这样。然而，在现实中，尽管人们尽力解耦和分类逻辑或数据，但某些事物仍然保持松散的联系，这正是事物的本质。信息仍然需要在系统之间进行交换。某些功能也需要作为完全无关的系统动作的结果而被调用。简单来说，系统之间需要有一种方式来进行交流，而无需了解彼此的工作方式。
- en: Entity events
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体事件
- en: 'A fairly simplistic, and as it happens, necessary approach to handling inter-system
    relations is dispatching events. Every other system could be listening for those
    events and performing their own logic, completely separate from everything else,
    in response to a certain event taking place. Let''s take a look at a possible
    list of entity events:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 处理系统间关系的一种相当简单且必要的做法是派发事件。每个其他系统都可以监听这些事件，并在发生特定事件时执行自己的逻辑，完全独立于其他一切。让我们看看可能的实体事件列表：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This should give you a pretty good idea of how system communication will take
    place. Let's say that an entity is moving in the left direction. The "movement
    system" starts dispatching events, saying that it's in motion. The "animation
    system" listens for those events, and when they're received, it proceeds to increase
    frames in the entity's sprite sheet. Keep in mind that all of these chunks of
    logic are still completely separate from one another. The "movement system" is
    not increasing the frames of the entity's sprite sheet. It's simply saying to
    all of the other systems "Hello, I am moving entity x to the left," while they
    listen and react. It sounds like we can benefit from the "event queue."
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能给你一个很好的概念，了解系统通信将如何进行。假设有一个实体正在向左移动。"移动系统"开始派发事件，表示它在运动。"动画系统"监听这些事件，并在接收到事件后，继续增加实体精灵表中的帧数。记住，所有这些逻辑块之间仍然是完全独立的。"移动系统"并没有增加实体精灵表中的帧数。它只是对所有其他系统说：“嗨，我正在将实体x向左移动”，而它们在监听并做出反应。听起来我们可以从"事件队列"中受益。
- en: Entity event queue
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体事件队列
- en: 'The **event queue** is a programming pattern, which is used to decouple when
    an event is fired from when it''s actually processed. This illustration should
    capture the essence of it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件队列**是一种编程模式，用于解耦事件触发和实际处理的时间。下面的插图应该能够捕捉到它的本质：'
- en: '![Entity event queue](img/B04284_08_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![实体事件队列](img/B04284_08_03.jpg)'
- en: 'A queue is what''s referred to as a First-In-First-Out data container. The
    data that is pushed onto it earliest is removed first. This serves our needs nicely.
    As the definition of the event queue states, its events are processed at a completely
    different time in relation to them being added. With that in mind, let''s start
    designing the `EventQueue` class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 队列被称为先进先出（First-In-First-Out）的数据容器。最早推入的数据最先被移除。这很好地满足了我们的需求。正如事件队列的定义所述，其事件是在与它们添加时完全不同的时间被处理的。考虑到这一点，让我们开始设计`EventQueue`类：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The event identifier is represented with an unsigned integer. In order to store
    the actual events, we'll be using, appropriately enough, a `queue` container.
    Adding an event to it is as simple as any other STL container. This class offers
    a method that can be used with while loops in order to simplify event processing.
    It returns a Boolean value in order to break the loop when the event queue is
    empty and its sole argument is taken by reference, in order to modify it each
    time the method is called. This is similar to the way SFML handles events.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 事件标识符用一个无符号整数表示。为了存储实际的事件，我们将使用一个合适的`队列`容器。向其中添加一个事件就像向任何其他STL容器添加一样简单。这个类提供了一个方法，可以在while循环中使用，以简化事件处理。它返回一个布尔值，以便在事件队列空时退出循环，并且它的唯一参数是通过引用传递的，以便每次调用该方法时都可以修改它。这与SFML处理事件的方式类似。
- en: The base system
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基类
- en: 'In order to begin implementing our systems, they must first have a common base
    class, which not only provides a common interface that must be implemented, but
    also eliminates code redundancy. Much like most other classes we build, it will
    have its own data types defined:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始实现我们的系统，它们必须首先有一个共同的基类，这个基类不仅提供了一个必须实现的共同接口，还消除了代码冗余。就像我们构建的大多数其他类一样，它将有自己的数据类型定义：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The system identifier, just like the component identifier, is represented by
    an unsigned integer. All of the entity identifiers will be stored in a vector
    container, much like the requirement bitmasks. The reason we would ever want to
    have more than one requirement bitmask is to have the ability to define combinations
    of different types of components that could still belong to the same system. A
    good example of that would be different drawable types belonging to the same rendering
    system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 系统标识符，就像组件标识符一样，由一个无符号整数表示。所有实体标识符都将存储在一个向量容器中，就像要求位掩码一样。我们之所以想要超过一个要求位掩码，是为了能够定义属于同一系统的不同类型组件的组合。一个很好的例子是不同可绘制类型属于同一渲染系统。
- en: 'Let''s take a look at the header of our system base class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的系统基类的头文件：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We want every single system to have its own update method, as well as its own
    version of event handling. Additionally, systems having access to their own manager
    is also desired. Everything else that is not system-specific, like checking requirement
    bitmasks, is handled by the base class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个系统都有自己的更新方法，以及自己的事件处理版本。此外，希望系统可以访问它们自己的管理器。所有其他非系统特定的东西，比如检查要求位掩码，都由基类处理。
- en: Implementing the base system
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现基类
- en: 'Because all systems require a pointer to the system manager, there''s an issue
    of cross-inclusion. A forward declaration of it right before the class header
    and the inclusion of the system manager header in the implementation file takes
    care of the issue:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有系统都需要指向系统管理器的指针，所以存在交叉包含的问题。在类头文件之前进行前向声明，并在实现文件中包含系统管理器头文件，可以解决这个问题：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Time to go down the list of methods to implement, starting with the constructor
    and destructor:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始实现方法的列表了，从构造函数和析构函数开始：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each system has to have its own identifier, much like all of the components.
    That gets passed in the argument list to the constructor, along with a pointer
    to the system manager. Aside from setting the appropriate data members to these
    values in an initializer list, the constructor of a base system does nothing else.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都必须有自己的标识符，就像所有组件一样。这个标识符通过构造函数的参数列表传递，同时传递一个指向系统管理器的指针。除了在初始化列表中将适当的数据成员设置为这些值之外，基类构造函数不做其他任何事情。
- en: The destructor, following the typical fashion, invokes the `Purge` method to
    do the cleanup.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数，遵循典型模式，调用`Purge`方法来进行清理。
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Adding an entity to a system is fairly easy. If the identifier that was provided
    as an argument doesn''t already exist within the said system, it simply gets pushed
    into the vector. How does a system determine if it has an entity with such an
    identifier? Let''s find out:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统中添加实体相当简单。如果提供的标识符在该系统中不存在，它就直接被推入向量中。系统是如何确定它是否有具有该标识符的实体呢？让我们来看看：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Utilizing the `std::find` function allows us to sum up this method in a single
    line. Removing an entity also takes advantage of a similar function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 利用`std::find`函数，我们可以将此方法总结为单行。移除实体也利用了类似的功能：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, we're using the `std::find_if` function, which takes a predicate
    as the third argument. A predicate is just another function that compares two
    elements together in order to find a match. In this case, we simply construct
    a lambda function that takes in an `EntityId` and returns a Boolean value, which
    will tell the find function whether a match was found. If it was, the entity is
    then removed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`std::find_if`函数，它将谓词作为第三个参数。谓词只是另一个函数，它比较两个元素以找到匹配项。在这种情况下，我们简单地构造一个lambda函数，它接受一个`EntityId`并返回一个布尔值，这将告诉查找函数是否找到了匹配项。如果是，则移除该实体。
- en: 'Each system has to make sure that an entity has all the required components
    in order to be added to it. That''s where this method comes in:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都必须确保一个实体拥有所有必需的组件才能将其添加进去。这正是这个方法发挥作用的地方：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It takes in a bitmask as an argument and utilizes the same `std::find_if` function
    in conjunction with a lambda to locate a match. Very few systems will even need
    to define more than one bitmask for its required components, however it's nice
    to have this functionality when the need for it arises.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个位掩码作为参数，并利用相同的`std::find_if`函数与lambda一起定位匹配项。虽然很少的系统需要为其实际组件定义超过一个位掩码，但是当需要时，拥有这种功能总是很好的。
- en: 'Lastly, here''s the method for cleaning up:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是清理的方法：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because there's no actual dynamic memory being allocated here, it's safe to
    just empty the container of all the entity identifiers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里没有实际分配动态内存，所以可以安全地清空容器中的所有实体标识符。
- en: Handling messages
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理消息
- en: Entity events, while useful for a lot of situations, aren't perfect for everything.
    For instance, carrying data between systems is impossible using the event queue.
    The events are also being delivered to every single system, which can be wasteful.
    Instead, why not have an additional method of communication that not only carries
    data around, but also allows systems to pick and choose what they want to receive?
    Entity component system messaging serves exactly that purpose, and there just
    so happens to be yet another programming pattern, which allows easy implementation
    of the message-subscription approach.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实体事件，虽然对许多情况很有用，但并不是所有情况都适用。例如，使用事件队列在系统之间传递数据是不可能的。事件还被发送到每个系统，这可能是浪费的。为什么不有一个额外的通信方法，不仅能够携带数据，还允许系统选择他们想要接收的内容？实体组件系统消息正好满足这个目的，而且恰好还有一个编程模式，它允许轻松实现消息订阅方法。
- en: The observer pattern
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'As the name entails, the **observer** pattern allows its users to pick and
    choose what they will be notified of. In other words, the observer will lay dormant
    after subscribing to information types it wishes to receive, and will only be
    notified if those types are encountered. Let''s take a look at a very basic implementation
    of the `Observer` base class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，**观察者**模式允许用户选择他们希望被通知的内容。换句话说，观察者在订阅希望接收的信息类型后会处于休眠状态，并且只有在遇到这些类型时才会被通知。让我们看看`Observer`基类的非常基本的实现：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Observer` class is simply an interface, the inheritors of which must define
    a single method in order to use it. Although it looks simple, many features we
    desire in our game wouldn''t be possible without it. Let''s take a look at what
    these observers will be notified with:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observer`类只是一个接口，其继承者必须定义一个方法才能使用它。尽管看起来很简单，但如果没有它，我们游戏中许多期望的功能将无法实现。让我们看看这些观察者将收到什么通知：'
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Aside from holding the information about the sender and receiver entities, as
    well as the message type, it employs a `union` in order to avoid inheritance.
    That essentially means that all of the data members within this union will be
    sharing the same space in memory, and only one of them can be valid at a time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包含发送者和接收者实体以及消息类型的信息外，它还使用了一个`union`来避免继承。这本质上意味着这个`union`中的所有数据成员将在内存中共享相同的空间，并且一次只能有一个有效。
- en: 'The last piece of the puzzle is containing all possible observers in a `Communicator`
    class. For this, we''ll be using a vector:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图的最后一块是将所有可能的观察者包含在一个`Communicator`类中。为此，我们将使用一个向量：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Because this class has relatively simple methods that simply deal with managing
    a vector container, let''s take a look at the full class definition head to toe:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类具有相对简单的仅处理管理向量容器的函数，让我们从头到尾查看完整的类定义：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The basic methods for adding, removing and looking for an observer are all typical.
    One thing to note, however, is the `Broadcast` method, which simply invokes the
    `Notify` method of an observer and passes in a message to send.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 添加、删除和查找观察者的基本方法都是典型的。然而，有一点需要注意，那就是`Broadcast`方法，它只是调用了观察者的`Notify`方法，并传递了一个要发送的消息。
- en: 'Last, and definitely the least amount of code is responsible for actually putting
    the observer approach to use:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，真正使用观察者方法的代码量最少：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Because the base system class has virtual methods, it doesn't need to implement
    its own version of `Notify`. That will be the job for all the systems that inherit
    from this class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基本系统类有虚方法，它不需要实现自己的`Notify`版本。这将是所有从该类继承的系统的工作。
- en: The message handler class
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息处理器类
- en: 'We have all of the pieces to build a cohesive messaging system. Let''s take
    a look at some data types that will be used to store message subscription information:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了构建统一消息系统的所有组件。让我们看看将用于存储消息订阅信息的数据类型：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Each possible message type will have its own communicator that will broadcast
    the message to all of its observers. Using an `unordered_map` is perfect for expressing
    such a relationship.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每种可能的消息类型都将有自己的通信者，用于将消息广播给所有观察者。使用`unordered_map`是表达这种关系的完美选择。
- en: 'The message handler is a very simple class, so let''s take a look at its entire
    implementation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 消息处理器是一个非常简单的类，让我们看看它的完整实现：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Subscribing and unsubscribing to message types is simply done by manipulating
    the unordered map data container. When a message is dispatched, the message type
    in the subscription container is queried. If it is found, the communicator's `Broadcast`
    method is invoked with the message passed in as the argument.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅和取消订阅消息类型只需通过操作无序映射数据容器即可完成。当消息被分发时，会在订阅容器中查询消息类型。如果找到，则使用传递的消息作为参数调用通信者的`Broadcast`方法。
- en: 'At this point you might be wondering what kind of messages we''ll be handling.
    Let''s take a gander at the `EntityMessages.h` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道我们将处理哪种类型的消息。让我们看看`EntityMessages.h`文件：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The purpose of a messaging system quickly becomes clear, even by simply reading
    the names of message types. Every one of them lends itself to either needing to
    contain extra data or only ever applying to a single system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地阅读消息类型的名称，消息系统的目的很快就会变得清晰。每一个都适合需要包含额外数据或仅适用于单个系统。
- en: Managing systems
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理系统
- en: 'Finally, we''ve arrived at the last stop on the entity component system route:
    handling systems themselves. Let''s quickly review our custom data types for this
    class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经到达了实体组件系统路线的最后一站：处理系统本身。让我们快速回顾一下这个类的自定义数据类型：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first data type, `SystemContainer`, is really hard to misinterpret. An unordered
    map is used to link system identifiers to actual systems. The second type definition
    here is responsible for storage of entity events. It also uses an unordered map
    and links entity identifiers to `EventQueue` instances, that all hold events for
    a specific entity until they're processed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据类型`SystemContainer`非常难以误解。使用无序映射将系统标识符链接到实际系统。这里第二个类型定义负责存储实体事件。它也使用无序映射并将实体标识符链接到`EventQueue`实例，这些实例都持有特定实体的所有事件，直到它们被处理。
- en: 'It''s time to design the system manager class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候设计系统管理器类了：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As expected, it needs to have methods for adding and handling events, updating
    and drawing the systems, notifying them of entity changes and removal requests,
    and obtaining them as well. The template method for getting a particular system
    is implemented this way:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，它需要添加和处理事件、更新和绘制系统、通知实体更改和删除请求的方法，以及获取它们的方法。获取特定系统的方式如下实现模板方法：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Just like the entity manager's method of obtaining components, this method relies
    on the use of templates and dynamic casting in order to obtain a system in the
    correct form.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就像实体管理器获取组件的方法一样，这个方法依赖于模板和动态类型转换的使用，以获取正确形式的系统。
- en: Implementing the system manager
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现系统管理器
- en: 'Cross-inclusion peaks its ugly head once more, so we must combat it with forward
    declarations and inclusions of headers in the implementation files:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉包含问题再次浮现，因此我们必须通过在实现文件中使用前向声明和头文件包含来对抗它：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With that out of the way, we can now start implementing the constructor and
    destructor:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，我们现在可以开始实现构造函数和析构函数：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The constructor sets up a pointer to an entity manager class before initializing
    all of the systems it holds. The destructor performs its usual job of cleaning
    up the mess, which is entrusted to the `PurgeSystems` method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数在初始化它所持有的所有系统之前，设置了一个指向实体管理器类的指针。析构函数执行其通常的清理工作，这被委托给`PurgeSystems`方法。
- en: 'Because the system manager needs to have a pointer to the entity manager and
    vice versa, the one that''s instantiated first will not simply be able to take
    a pointer to the other class in its constructor, hence the need for the `SetEntityManager`
    method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因为系统管理器需要指向实体管理器的指针，反之亦然，所以首先实例化的那个不能简单地在其构造函数中获取其他类的指针，因此需要`SetEntityManager`方法：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With a class so broadly applied, it needs to provide getter methods for its
    data members:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个应用广泛的类，它需要为其数据成员提供getter方法：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This ensures that all systems have access to the message handler, as well as
    the entity handler.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了所有系统都可以访问消息处理器以及实体处理器。
- en: 'Speaking of system access, they also must be able to add events to any entity:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 说到系统访问，它们还必须能够向任何实体添加事件：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using an `unordered_map` structure here really makes this method simple and
    neat. The entity identifier being the key, it's easy to access its individual
    event queue and add to it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用`unordered_map`结构真的让这个方法变得简单而整洁。实体标识符作为键，可以轻松访问其单独的事件队列并向其中添加内容。
- en: 'Providing we want those systems to tick, an update loop is in order:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让那些系统运行，就需要一个更新循环：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, every single system''s update method is invoked and the elapsed time
    is passed in. The event handling takes place after all of the systems have been
    updated. Time to dissect that method:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，调用每个系统的更新方法，并传入经过的时间。在所有系统更新完毕后进行事件处理。现在是时候剖析那个方法了：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We begin by iterating over the event queues of different entities. An event
    identifier variable is set up and used in a `while` loop by reference, in order
    to obtain information from the queue. Every system in the manager is iterated
    over and checked for having the entity of interest. If it does, the system's `HandleEvent`
    method is invoked and the relevant information is passed in. That, in a nutshell,
    concludes event management on a larger scale. Now every individual system only
    has to worry about which events it wants to handle and how it wants to respond
    to them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先遍历不同实体的事件队列。设置了一个事件标识符变量，并在`while`循环中通过引用使用它，以从队列中获取信息。遍历管理器中的每个系统，并检查是否有感兴趣的实体。如果有，就调用系统的`HandleEvent`方法，并传入相关信息。总结来说，这就是在更大规模上完成事件管理。现在每个系统只需要担心它想要处理哪些事件以及如何响应它们。
- en: 'In order to populate the dark void of the screen with entities, we''re going
    to need a `Draw` method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕的黑暗空间中填充实体，我们需要一个`Draw`方法：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For most needs, having a single system devoted to rendering entities more than
    suffices. Ergo, the renderer system is located in the system container and type-cast
    up from the base class. Its `Render` method is then invoked with relevant arguments,
    one of which is the current elevation that's being rendered. Drawing it this way
    allows the feel of "depth" to be achieved within our game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数需求，有一个专门用于渲染实体的系统就足够了。因此，渲染系统位于系统容器中，并从基类向上进行类型转换。然后使用相关参数调用其`Render`方法，其中一个参数是当前正在渲染的高度。以这种方式绘制可以让我们在游戏中实现“深度”感。
- en: 'As entities are not static in their composure, systems must be aware of these
    changes and properly take in or dispose of them, given the circumstances. This
    specific method has already been brought up multiple times during the implementation
    of the entity manager class, so let''s take a look at how it works:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实体的组成不是静态的，系统必须意识到这些变化，并根据情况适当接收或处理它们。这个特定方法已经在实体管理器类的实现过程中多次被提及，所以让我们看看它是如何工作的：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Upon any changes regarding entities taking place, the `EntityModified` method
    must be invoked with the identifier of the entity and its new bitmask passed in
    as arguments. Every system is then iterated over. Their respective `FitsRequirements`
    methods are invoked with the new bitmask as the argument. If the entity fits the
    requirements of a system and it doesn't belong to it, it is added. If, however,
    the entity does not fit these requirements but a system still has this entity,
    it's removed. The use of this simple concept allows entities to be dynamic in
    structure. Any given entity can lose or gain a component and immediately "transform"
    into something else.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当有关实体的任何变化发生时，必须使用实体的标识符及其新的位掩码作为参数调用`EntityModified`方法。然后遍历每个系统。它们的相应`FitsRequirements`方法使用新的位掩码作为参数被调用。如果一个实体符合系统的要求，但它不属于该系统，它将被添加。然而，如果一个实体不符合这些要求，但系统仍然有这个实体，它将被移除。这个简单概念的使用使得实体在结构上具有动态性。任何给定的实体都可以失去或获得一个组件，并立即“转变”成其他东西。
- en: 'Removal of entities is quite simple:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的移除相当简单：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'All that needs to happen here is the `RemoveEntity` method of every system
    being invoked, which is quite similar to purging all entities:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要发生的事情只是调用每个系统的`RemoveEntity`方法，这与清除所有实体非常相似：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Getting rid of all systems in the system manager is also a cake walk:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从系统管理器中移除所有系统也是轻而易举的事情：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because systems are dynamically allocated, the memory has to be freed for each
    of them. The system container is then simply cleared.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统是动态分配的，因此必须为每个系统释放内存。然后系统容器被简单地清空。
- en: 'This last method marks the completion of our system manager, as well as the
    core structure of the entity component system paradigm. All of the basic tools
    for shaping our game are now present, so let''s implement the first and most important
    system in the game: the renderer.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法标志着我们的系统管理器的完成，以及实体组件系统范例的核心结构。现在，我们塑造游戏的基本工具都已经准备好了，所以让我们实现游戏中的第一个也是最重要的系统：渲染器。
- en: Implementing the rendering system
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现渲染系统
- en: 'In order for entities to be drawn on screen, they must have a component that
    represents them visually. After some careful planning, one can deduce that an
    entity will probably not have just one possible choice for a graphical representation.
    For example, instead of a sprite sheet, an entity can be a simple shape with a
    single color fill. In order to make that happen, we need a common interface for
    drawable components. Let''s see what we can come up with:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让实体能够在屏幕上绘制，它们必须有一个代表其视觉外观的组件。经过一些仔细的计划，可以推断出实体可能不会只有一个可能的图形表示选择。例如，一个实体可以是一个简单的形状，具有单色填充，而不是精灵表。为了实现这一点，我们需要一个可绘制组件的通用接口。让我们看看我们能想出什么：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first thing to note here is that the constructor of this class also takes
    in a component type, and simply passes it to the base class. Since `C_Drawable`
    only has purely virtual methods, it can never be instantiated and will only be
    used as a mold to shape other drawable components. It requires all derived classes
    to implement a method for updating the drawable's position, obtaining its size
    and drawing it on screen.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里首先要注意的是，这个类的构造函数也接受一个组件类型，并将其简单地传递给基类。由于`C_Drawable`只有纯虚方法，它永远不能被实例化，而只能用作塑造其他可绘制组件的模板。它要求所有派生类实现一个用于更新可绘制位置、获取其大小并在屏幕上绘制的方法。
- en: The sprite sheet component
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精灵表组件
- en: 'With the base class set up, it''s time to take a look at creating the sprite
    sheet component:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 基类设置好后，是时候看看如何创建精灵表组件了：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This component will, of course, be utilizing the `SpriteSheet` class we built
    in the past as one of its data members. We also want to hold on to the sprite
    sheet name in order to properly allocate resources after the time of de-serialization.
    Let''s begin implementing the sprite sheet component:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个组件将利用我们之前构建的`SpriteSheet`类作为其数据成员之一。我们还想保留精灵表名称，以便在反序列化之后正确分配资源。让我们开始实现精灵表组件：
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So far, nothing is out of the ordinary. The constructor uses the initializer
    list to set up the component type and set the sprite sheet pointer to `NULL`,
    while the destructor takes care of de-allocating the memory that's taken up by
    said sprite sheet.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很正常。构造函数使用初始化列表来设置组件类型并将精灵表指针设置为`NULL`，而析构函数则负责释放由该精灵表占用的内存。
- en: 'Next, let''s handle reading in the component data, which only consists of the
    sprite sheet name:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理读取组件数据，这仅包括精灵表名称：
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Due to the nature of this particular drawable component, it needs access to
    the texture manager. In order to set up the sprite sheet properly, the `Create`
    method is introduced:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特定的可绘制组件的性质，它需要访问纹理管理器。为了正确设置精灵表，引入了`Create`方法：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As seen previously, this particular method is used to set up the sprite sheet
    component during entity loading. It first checks if the memory for the `m_spriteSheet`
    data member hasn't already been allocated. If it hasn't, a new `SpriteSheet` object
    is created with the texture manager pointer passed in as its sole argument. The
    rest of the code deals with the second, optional argument. The name of the texture
    can be passed to the `Create` method itself, or it can use the `m_sheetName` data
    member that has been read in from the entity file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个特定方法用于在实体加载期间设置精灵表组件。它首先检查`m_spriteSheet`数据成员的内存是否已经被分配。如果没有，就使用传入的纹理管理器指针作为唯一参数创建一个新的`SpriteSheet`对象。其余的代码处理第二个可选参数。纹理的名称可以直接传递给`Create`方法，或者可以使用从实体文件中读取的`m_sheetName`数据成员。
- en: 'Lastly, all of the virtual methods of the `C_Drawable` class must be implemented
    here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有`C_Drawable`类的虚拟方法都必须在这里实现：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: All of the work done on the `SpriteSheet` class in the past makes this pretty
    easy. One thing to note is that due to the nature of loading sprite sheet components,
    it may be wise to check if it has actually been allocated, before attempting to
    draw it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 过去在`SpriteSheet`类上所做的所有工作使得这变得相当简单。需要注意的是，由于加载精灵表组件的性质，在尝试绘制之前检查它是否实际上已经被分配可能是个明智的选择。
- en: The renderer
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染器
- en: 'With the simple part out of the way, let''s focus on creating our first system
    ever built, the renderer:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的部分已经处理完毕，让我们专注于创建我们构建的第一个系统，即渲染器：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The header for all of the other systems will look very much like this one,
    with the exception of private methods, specific to the function that each individual
    system performs. Each system must implement its own `Update` and `HandleEvent`
    methods. Additionally, being an observer requires a unique implementation of the
    `Notify` method as well. Time to take a stab at implementing the renderer system:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他系统的头文件看起来将非常类似于这个，除了私有方法，这些方法针对每个系统执行的功能是特定的。每个系统都必须实现自己的`Update`和`HandleEvent`方法。此外，作为一个观察者，还需要实现一个独特的`Notify`方法。现在是时候尝试实现渲染器系统了：
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: After invoking the base system's constructor and passing in the appropriate
    type, along with a pointer to the system manager, the renderer sets up a bitmask
    of requirements an entity has to meet in order to belong to this system. As you
    can see, it only needs to have the position and sprite sheet components. Once
    the requirement bitmask is added to the system, it also subscribes to the `Direction_Changed`
    message type. This utilizes the observer pattern discussed previously.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用基类构造函数并传入适当的类型以及指向系统管理器的指针后，渲染器设置了一个位掩码，表示实体必须满足的要求才能属于这个系统。正如你所见，它只需要具有位置和精灵表组件。一旦将要求位掩码添加到系统中，它还会订阅`Direction_Changed`消息类型。这利用了之前讨论过的观察者模式。
- en: 'Let''s take a look at the update method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更新方法：
- en: '[PRE58]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: During iteration over all of the entities that belong to this system, the position
    and drawable components are obtained through the entity manager. The drawable's
    position is then updated through the use of its `UpdatePosition` method. This
    method can obviously be expanded if additional drawable types are added in the
    future.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代属于这个系统的所有实体时，通过实体管理器获取位置和可绘制组件。然后，通过使用其`UpdatePosition`方法更新可绘制组件的位置。显然，如果将来添加了额外的可绘制类型，这个方法可以扩展。
- en: 'Next, let''s handle the appropriate events:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理适当的事件：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If the system encounters any events of entities spawning, changing their position
    or elevation, their drawable representations have to be re-sorted in order to
    assure the correct layering. The result of this is quite worth the trouble:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统遇到实体生成、改变位置或海拔高度的事件，它们的可绘制表示必须重新排序，以确保正确的分层。这个结果相当值得麻烦：
- en: '![The renderer](img/B04284_08_04.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![渲染器](img/B04284_08_04.jpg)'
- en: 'The code for message handling here is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 消息处理的相关代码如下：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Since messages are globally broadcasted to every system regardless of what entities
    they have, and the renderer only deals with a single message type that pertains
    to specific entities only, a check takes place in order to make sure the entity
    exists within the renderer system. The sole message type we care about so far
    is the direction being altered, in which case a private method is invoked to adjust
    it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消息是全球广播到每个系统，无论它们包含哪些实体，并且渲染器只处理与特定实体相关的单一消息类型，因此会进行一次检查，以确保实体存在于渲染器系统中。到目前为止，我们关注的唯一消息类型是方向被改变，在这种情况下，将调用一个私有方法来调整它。
- en: 'Now, let''s address the main purpose the renderer system exists:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈渲染器系统存在的主要目的：
- en: '[PRE61]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Each entity is iterated over, much like any other system. The main difference
    here is the layer argument the method takes in. Because we want to have a map
    that has many different layers entities can be, for the lack of better term, "sandwiched"
    in, rendering elevation by elevation is necessary in order to maintain the correct
    draw order and offer the feeling of depth, as illustrated here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体都会被迭代，就像任何其他系统一样。这里的主要区别是方法接受的层参数。因为我们想要有一个地图，许多不同的层实体可以“夹”在其中，按高度渲染是必要的，以保持正确的绘制顺序并提供深度感，如图所示：
- en: '![The renderer](img/B04284_08_05.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![渲染器](img/B04284_08_05.jpg)'
- en: The second half of the `Render` method is devoted to entity culling. First,
    a rectangle structure is created in order to represent the boundaries of a drawable.
    In the case of a sprite sheet, we know that its origin is set at the point of
    half its width and its full height. Using this information, the rectangle structure
    is properly set up and inspected for intersections with the view space, which
    essentially means the sprite is on screen and should be drawn.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`Render`方法的第二部分致力于实体剔除。首先，创建一个矩形结构来表示可渲染对象的边界。在精灵图的情况下，我们知道其原点设置在其宽度的一半和其完整高度的位置。使用这些信息，矩形结构被正确设置并检查与视图空间的交集，这本质上意味着精灵在屏幕上，应该被绘制。'
- en: 'Re-using code as much as possible makes life easier in the long run, hence
    the existence of many private methods amongst multiple systems, regarding modifications
    of entity components. For example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地重用代码，从长远来看会使生活变得更轻松，这就是为什么在多个系统中存在许多私有方法，这些方法涉及实体组件的修改。例如：
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `SetSheetDirection` method simply fetches the sprite sheet component and
    changes its direction.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetSheetDirection`方法简单地获取精灵图组件并更改其方向。'
- en: 'The last feature we want to work on implementing is the render order of drawables
    in order to simulate depth. Drawing entities in a correct sequence requires them
    being sorted. This is where the `SortDrawables` method comes in:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要实现的功能的最后一项是可渲染对象的渲染顺序，以便模拟深度。正确顺序绘制实体需要它们被排序。这就是`SortDrawables`方法发挥作用的地方：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, we simply invoke the `std::sort` function, with the last argument being
    the predicate lambda that we've already seen before. Elevation is given top priority
    when entity sprites are being sorted. Anything with a higher elevation will be
    drawn on top, while sprites on the same elevation are sorted based on their *Y*
    coordinate.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是调用`std::sort`函数，最后一个参数是我们之前已经见过的谓词lambda。在实体精灵排序时，高度优先考虑。任何高度更高的对象都将绘制在顶部，而处于相同高度的精灵将根据它们的*Y*坐标进行排序。
- en: With that, the rendering system is now complete! Putting all of the pieces together
    is the final step in employing the entity component system pattern in our game.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，渲染系统现在就完成了！将所有这些部件组合在一起，是我们游戏中采用实体组件系统模式的最后一步。
- en: Putting the ECS to work
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将ECS投入工作
- en: 'Due to the part this paradigm plays in the overall structure of our application,
    we want the system manager and entity manager classes to be accessible to the
    majority of our code base. Having these objects be part of the shared context
    is the best way to do so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种范式在我们应用程序的整体结构中扮演的角色，我们希望系统管理器和实体管理类对大多数代码库都是可访问的。将这些对象作为共享上下文的一部分是做到这一点的最佳方式：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Adjusting the shared context means we have two extra classes to keep track
    of in `Game.h`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 调整共享上下文意味着我们在`Game.h`中需要跟踪两个额外的类：
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'These classes have to be properly initialized, which is done in `Game.cpp`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类必须被正确初始化，这将在`Game.cpp`中完成：
- en: '[PRE66]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice that the entity manager is initialized in the initializer list. The system
    manager is then given a pointer to the entity manager, and both of these classes
    are added to the shared context.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到实体管理器在初始化列表中被初始化。然后系统管理器被赋予实体管理器的指针，这两个类都被添加到共享上下文中。
- en: 'Next up, some changes have to be made to the game state:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要对游戏状态进行一些修改：
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The game state currently keeps track of the player''s entity identifier in
    addition to providing a new method for updating the camera, as well as moving
    the player, which will be set up as a callback like so:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当前游戏状态除了提供更新摄像头的新方法外，还跟踪玩家的实体标识符，并将这些设置为一个回调，如下所示：
- en: '[PRE68]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: After the game map is loaded, the player entity identifier is obtained through
    the `Map` class, which stores this information during map loading.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载游戏地图后，通过`Map`类获取玩家实体标识符，该类在地图加载期间存储此信息。
- en: 'The next task is getting the camera to follow our hero. This can be accomplished
    by first calling our `UpdateCamera` method in the `Update` method of our game
    state:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是让摄像头跟随我们的英雄。这可以通过首先在我们的游戏状态`Update`方法中调用我们的`UpdateCamera`方法来实现：
- en: '[PRE69]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The actual `UpdateCamera` method itself is implemented like so:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的`UpdateCamera`方法实现如下：
- en: '[PRE70]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The player identifier first is verified of being a non-negative value, which
    would signify an error. The position component of the player entity is then obtained
    and used for updating the position of the current view. The rest of the code deals
    with adjusting the view to fit within the boundaries of the map, if it wanders
    outside of it. This is also where the system manager update method must be invoked.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先验证玩家标识符是否为非负值，这会表示一个错误。然后获取玩家实体的位置组件，并用于更新当前视图的位置。其余的代码处理调整视图以适应地图边界，如果它游出边界之外。这也是必须调用系统管理器更新方法的地方。
- en: 'Drawing our game world also needs revising:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制我们的游戏世界也需要进行修订：
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'First, a `for` loop iterates over each layer that might be used in the game.
    The `Num_Layers` value is part of the `Sheet` enumeration, which is defined in
    the `Map` class header. We''ll be covering that shortly. The map `Draw` method
    now needs to know which layer to draw, as they''re not all drawn at the same time
    anymore. After the appropriate layer is rendered, all of the entities that occupy
    the same elevation are also rendered on screen, giving the impression of depth
    in the game, like so:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个`for`循环遍历可能用于游戏的每一层。`Num_Layers`值是`Sheet`枚举的一部分，该枚举在`Map`类头文件中定义。我们将在稍后介绍这一点。现在，地图`Draw`方法需要知道要绘制哪一层，因为它们不再同时绘制。在渲染适当的层之后，所有占据相同高度的实体也会在屏幕上渲染，从而产生游戏中的深度感，如下所示：
- en: '![Putting the ECS to work](img/B04284_08_06.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![将ECS投入工作](img/B04284_08_06.jpg)'
- en: 'Lastly, we need to define the callback method for moving a player:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义移动玩家的回调方法：
- en: '[PRE72]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: A message of type `Move` is created and set up in order to hold the direction
    in its `m_int` data member. The receiver of the message is also set to be the
    player, and the message is dispatched through the system manager's message handler.
    This message will be handled by one of the systems we'll be building in a later
    chapter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并设置了一个类型为`Move`的消息，以便在它的`m_int`数据成员中保存方向。消息的接收者也被设置为玩家，并且消息通过系统管理器的消息处理器分发。这个消息将由我们在后续章节中构建的系统中之一处理。
- en: 'The last change from our previous project is the number of directions an entity
    can move in. Given the format of our new entity spritesheets, let''s modify `Directions.h`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前项目中的最后一个变化是实体可以移动的方向数量。鉴于我们新的实体精灵表格式，让我们修改`Directions.h`：
- en: '[PRE73]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Since the direction is used as a way to offset numbers of rows in sprite sheets
    for obtaining correct animations, the values set here are important. This small
    change concludes building and setting up the core of our component entity system!
    All that's left now is adjusting the `Map` class to satisfy and complement the
    new, shiny features of our game.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于方向被用作偏移精灵表中的行数以获取正确动画的方式，因此这里设置的值很重要。这个小改动标志着我们组件实体系统的构建和设置完成！现在剩下的只是调整`Map`类，以满足并补充我们游戏的新特性。
- en: The new and improved map
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的改进版地图
- en: 'For as good as the second project of this book looked, a lot of things about
    it were fairly primitive. Among its other shortcomings, the map design lacked
    complexity due to its inability to support tile layers. Having a more complex
    scene requires tiles being able to layer over each other, in a manner best represented
    by this illustration:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书的第二个项目看起来很好，但它有很多方面相当原始。在其其他缺点中，由于无法支持瓦片层，地图设计缺乏复杂性。要有一个更复杂的场景，需要瓦片能够相互叠加，如图所示：
- en: '![The new and improved map](img/B04284_08_07.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![新的改进后的地图](img/B04284_08_07.jpg)'
- en: 'Adding layer support, as well as loading entity information after re-designing
    the way entities are handled requires some changes to be made to the map file
    format. Let''s take a look at an example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 添加层支持，以及重新设计处理实体方式后加载实体信息，需要对地图文件格式进行一些修改。让我们看看一个例子：
- en: '[PRE74]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: While some map properties remain in place, things like gravity or background
    images have been removed, as it no longer suits the genre of the game we're making.
    The main changes here are the entity and tile lines.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些地图属性保持不变，但像重力或背景图像这样的东西已经被移除，因为它们不再适合我们正在制作的游戏的类型。这里的主要变化是实体和瓦片行。
- en: Loading an entity is as simple as providing the name of its entity file and
    a few pieces of data, relevant to maps, such as its position and elevation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 加载实体就像提供其实体文件名称和一些与地图相关的数据一样简单，例如其位置和海拔。
- en: Tile loading is also slightly different now. In addition to its identifier and
    position, a tile now also requires having a layer, as well as a flag for solidity,
    which will be covered more in depth in the next chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦片加载现在也有所不同。除了其标识符和位置外，瓦片现在还需要有一个层，以及一个表示固实的标志，这些将在下一章中更深入地介绍。
- en: 'Amongst some of the bigger changes, a new value inside the *Sheet* enumeration
    is defined. It represents the maximum possible number of layers in any given map:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些较大的变化中，枚举`Sheet`中定义了一个新值。它代表任何给定地图中可能的最大层数：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Also, in order to allow individual solidity options, each tile now carries
    a solidity flag that can be turned on or off:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了允许单独的固实选项，每个瓦片现在都带有一个可以开启或关闭的固实标志：
- en: '[PRE76]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Working with an extra piece of information, the tile layer, requires certain
    modifications to be made to the `GetTile` and `ConvertCoords` methods:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 与额外的信息，如瓦片层一起工作，需要对`GetTile`和`ConvertCoords`方法进行某些修改：
- en: '[PRE77]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note the `m_playerId` data member. It keeps track of what entity ID the player
    has been given after loading the map file.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`m_playerId`数据成员。它在加载地图文件后跟踪玩家被分配的实体ID。
- en: Adjusting the Map class
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整地图类
- en: 'It''s time to start implementing all of these changes! First, let''s take a
    look at the method used for obtaining map tiles:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始实施所有这些更改了！首先，让我们看看用于获取地图瓦片的方法：
- en: '[PRE78]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The biggest difference here is the check for accessing tiles that are out of
    boundaries of the map. The method itself takes an additional argument that represents
    the tile layer, which it then passes into the `ConvertCoords` method. Working
    with tile layers would require having a third dimension added to a 2D array of
    tiles. Since we''re storing all of this information in a one-dimensional array,
    some additional math has to be done in order to perform the conversion:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最大的不同之处在于检查访问超出地图边界的瓦片。该方法本身接受一个额外的参数，代表瓦片层，然后将其传递到`ConvertCoords`方法。与瓦片层一起工作需要将一个三维添加到二维瓦片数组中。由于我们正在将所有这些信息存储在一个一维数组中，因此必须进行一些额外的数学运算才能执行转换：
- en: '[PRE79]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If you previously visualized the map as a 2D grid, it's now becoming a 3D cube,
    with the layer value representing its depth.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前将地图视为一个二维网格，现在它正变成一个三维立方体，层值代表其深度。
- en: 'The desired functionality of the updated `Draw` method has been outlined quite
    clearly in the game state `Draw` method. Let''s implement that:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的`Draw`方法的功能在游戏状态`Draw`方法中已经非常清晰地概述了。让我们来实现它：
- en: '[PRE80]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Before we get into any actual rendering, we must make sure that the provided
    layer argument does not exceed the defined maximum. Aside from that, the only
    real difference here is that we're passing the layer argument into the `GetTile`
    method now. That's quite a simple adjustment.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始任何实际的渲染之前，我们必须确保提供的层参数不超过定义的最大值。除此之外，唯一的真正区别现在是我们现在将层参数传递到`GetTile`方法。这是一个相当简单的调整。
- en: 'Lastly, the way tiles and entities are loaded has to be fixed. Let''s take
    a look at snippets from the `LoadMap` method:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要修复加载瓦片和实体的方式。让我们看看`LoadMap`方法的片段：
- en: '[PRE81]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The majority of this code remains unchanged. Reading in the layer and solidity
    data has been added, as well as checking if the layer value is valid, together
    with the coordinate values. The entity side of things, however, is quite different:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分保持不变。增加了读取图层和实体数据，以及检查图层值是否有效，以及坐标值。然而，实体方面的事情却相当不同：
- en: '[PRE82]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The name of an entity is read in first. If it's a player entity and it hasn't
    yet been set up based on the `m_playerId` data member, or if it's just any other
    entity, an attempt is made to add it. Upon successfully doing so, its name is
    checked once more in order to make sure the player entity identifier is caught
    and stored. The position component is then obtained and its data is read in directly
    from the map file.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先读取实体的名称。如果它是一个玩家实体，并且尚未根据`m_playerId`数据成员设置，或者它只是任何其他实体，将尝试添加它。成功添加后，会再次检查其名称，以确保捕获并存储玩家实体标识符。然后获取位置组件，并直接从地图文件中读取其数据。
- en: 'Once the `Map` class is finished, compiling and rendering our project and loading
    in a valid map should leave us with a few entities standing around peacefully:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Map`类完成，编译和渲染我们的项目以及加载一个有效的地图，我们应该会剩下一些实体安静地站立着：
- en: '![Adjusting the Map class](img/B04284_08_08.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![调整Map类](img/B04284_08_08.jpg)'
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With the invention of all the tools we need, we will next be working on adding
    the most common game elements to our final project and bringing it to life, not
    to mention actually flexing the backend functionality we built. Although this
    chapter has come to an end, this is by no means the last of us discovering and
    applying new programming patterns, should a need ever arise again to use one.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们所需的所有工具的发明，我们接下来将致力于将最常见的游戏元素添加到我们的最终项目中，并使其栩栩如生，更不用说实际上运用我们构建的后端功能了。尽管这一章节已经结束，但这绝不是我们探索和应用新编程模式的终结，如果将来再次需要使用它们的话。
- en: A good code-base is one that can handle new features and expansion of old ones
    with ease. The fruition of this chapter marks the point, at which the games we
    make are no longer bound to be simplistic due to design restrictions or inconvenient
    expansion. At this point, the question is no longer "How?", it's "Why not?" Seeing
    as you have made it this far, why not keep going? See you in the next chapter!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的代码库应该能够轻松处理新功能的添加和旧功能的扩展。这一章节的实现标志着我们制作的游戏不再受限于设计限制或不便扩展。在这个阶段，问题不再是“如何”，而是“为什么不？”既然你已经走到了这一步，为什么不继续前进呢？下一章见！
