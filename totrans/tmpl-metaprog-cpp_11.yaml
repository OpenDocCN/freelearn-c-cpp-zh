- en: '*Chapter 8*: Ranges and Algorithms'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*: 范围和算法'
- en: By reaching this point of the book, you have learned everything about the syntax
    and the mechanism of templates in C++, up to the latest version of the standard,
    C++20\. This has equipped you with the necessary knowledge to write templates
    from simple forms to complex ones. Templates are the key to writing generic libraries.
    Even though you might not write such a library yourself, you’d still be using
    one or more. In fact, the everyday code that you’re writing in C++ uses templates.
    And the main reason for that is that as a modern C++ developer, you’re using the
    standard library, which is a library based on templates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到达本书的这一部分，你已经学习了有关C++模板的语法和机制的所有内容，直到最新的标准版本C++20。这为你编写从简单到复杂的模板提供了必要的知识。模板是编写泛型库的关键。即使你可能不会自己编写这样的库，你也会使用一个或多个。事实上，你用C++编写的日常代码就使用了模板。主要原因在于，作为一个现代C++开发者，你正在使用基于模板的标准库。
- en: However, the standard library is a collection of many libraries, such as the
    containers library, iterators library, algorithms library, numeric library, input/output
    library, filesystem library, regular expressions library, thread support library,
    utility libraries, and others. Overall, it’s a large library that could make the
    topic of at least an entire book. However, it is worth exploring some key parts
    of the library to help you get a better understanding of some of the concepts
    and types you are or could be using regularly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，标准库是一系列许多库的集合，例如容器库、迭代器库、算法库、数值库、输入/输出库、文件系统库、正则表达式库、线程支持库、实用库等。总的来说，这是一个庞大的库，至少可以写一本书的内容。然而，探索库的一些关键部分，可以帮助你更好地理解你经常使用或可能使用的一些概念和类型。
- en: 'Because addressing this topic in a single chapter would lead to a significantly
    large chapter, we will split the discussion into two parts. In this chapter, we
    will address the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在一个章节中讨论这个主题会导致章节内容显著增加，我们将讨论分为两部分。在本章中，我们将讨论以下主题：
- en: Understanding the design of containers, iterators, and algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解容器、迭代器和算法的设计
- en: Creating a custom container and iterator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义容器和迭代器
- en: Writing a custom general-purpose algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义通用算法
- en: By the end of this chapter, you will have a good understanding of the three
    main pillars of the standard template library, which are containers, iterators,
    and algorithms.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对标准模板库的三个主要支柱有很好的理解，这些支柱是容器、迭代器和算法。
- en: We will begin this chapter with an overview of what the standard library has
    to offer in this respect.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，概述标准库在这个方面的提供内容。
- en: Understanding the design of containers, iterators, and algorithms
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器、迭代器和算法的设计
- en: '**Containers** are types that represent collections of elements. These collections
    can be implemented based on a variety of data structures, each with different
    semantics: lists, queues, trees, and so on. The standard library provides three
    categories of containers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**是表示元素集合的类型。这些集合可以根据各种数据结构实现，每个都有不同的语义：列表、队列、树等。标准库提供了三类容器：'
- en: '`vector`, `deque`, `list`, `array`, and `forward_list`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector`, `deque`, `list`, `array`, 和 `forward_list`'
- en: '`set`, `map`, `multiset`, and `multimap`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`, `map`, `multiset`, 和 `multimap`'
- en: '`unordered_set`, `unordered_map`, `unordered_multiset`, and `unordered_multimap`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unordered_set`, `unordered_map`, `unordered_multiset`, 和 `unordered_multimap`'
- en: In addition to this, there are also container adaptors that provide a different
    interface for sequence containers. This category includes the `stack`, `queue`,
    and `priority_queue` classes. Finally, there is a class called `span` that represents
    a non-owning view over a contiguous sequence of objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有提供不同接口的容器适配器，这一类别包括`stack`, `queue`, 和 `priority_queue`类。最后，还有一个名为`span`的类，它表示对连续对象序列的非拥有视图。
- en: 'The rationale for these containers to be templates was presented in [*Chapter
    1*](B18367_01_ePub.xhtml#_idTextAnchor015), *Introduction to Templates*. You don’t
    want to write the same implementation again and again for each different type
    of element that you need to store in a container. Arguably, the most used containers
    from the standard library are the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些容器为什么要使用模板的原因在第[*第1章*](B18367_01_ePub.xhtml#_idTextAnchor015)，*模板介绍*中进行了说明。你不想为需要存储在容器中的每种不同类型的元素重复编写相同的实现。可以说，标准库中最常用的容器如下：
- en: '`vector`: This is a variable-size collection of elements stored contiguously
    in memory. It’s the default container you would choose, provided no special requirements
    are defined. The internal storage expands or shrinks automatically as needed to
    accommodate the stored elements. The vector allocates more memory than needed
    so that the risk of having to expand is low. The expansion is a costly operation
    because new memory needs to be allocated, the content of the current storage needs
    to be copied to the new one, and lastly, the previous storage needs to be discarded.
    Because elements are stored contiguously in memory, they can be randomly accessed
    by an index in constant time.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector`：这是一个在内存中连续存储的变量大小元素集合。在没有特殊要求的情况下，这是你选择的默认容器。内部存储根据需要自动扩展或收缩以容纳存储的元素。向量分配比所需更多的内存，以降低扩展的风险。扩展是一个昂贵的操作，因为需要分配新内存，将当前存储的内容复制到新存储中，最后还需要丢弃之前的存储。因为元素在内存中连续存储，所以可以通过索引以常数时间随机访问。'
- en: '`array`: This is a fixed-size collection of elements stored contiguously in
    memory. The size must be a compile-time constant expression. The semantics of
    the `array` class is the same as a structure holding a C-style array (`T[n]`).
    Just like the `vector` type, the elements of the `array` class can be accessed
    randomly in constant time.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`：这是一个在内存中连续存储的固定大小元素集合。大小必须是编译时常量表达式。`array`类的语义与包含C风格数组的结构体相同（`T[n]`）。就像`vector`类型一样，`array`类的元素可以以常数时间随机访问。'
- en: '`map`: This is a collection that associates a value to a unique key. Keys are
    sorted with a comparison function and the `map` class is typically implemented
    as a red-black tree. The operations to search, insert, or remove elements have
    logarithmic complexity.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`：这是一个将值与唯一键关联的集合。键通过比较函数排序，`map`类通常实现为红黑树。搜索、插入或删除元素的操作具有对数复杂度。'
- en: '`set`: This is a collection of unique keys. The keys are the actual values
    stored in the container; there are no key-value pairs as in the case of the `map`
    class. However, just like in the case of the `map` class, `set` is typically implemented
    as a red-black tree that has logarithmic complexity for searching, inserting,
    and the removing of elements.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`：这是一个唯一键的集合。键是容器中实际存储的值；与`map`类的情况不同，没有键值对。然而，就像`map`类的情况一样，`set`通常实现为红黑树，搜索、插入和删除元素的操作具有对数复杂度。'
- en: 'Regardless of their type, the standard containers have a few things in common:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不论它们的类型如何，标准容器有一些共同点：
- en: Several common member types
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个常见的成员类型
- en: An allocator for storage management (with the exception of the `std::array`
    class)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储管理的分配器（除了`std::array`类）
- en: Several common member functions (some of them are missing from one or another
    container)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个常见的成员函数（其中一些在某些容器中可能缺失）
- en: Access to the stored data with the help of iterators
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器访问存储的数据
- en: 'The following member types are defined by all standard containers:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准容器都定义了以下成员类型：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The actual types these names are aliasing may differ from container to container.
    For instance, for `std::vector`, `value_type` is the template argument `T`, but
    for `std::map,` `value_type` is the `std::pair<const Key, T>` type. The purpose
    of these member types is to help with generic programming.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称实际所代表的数据类型可能因容器而异。例如，对于`std::vector`，`value_type`是模板参数`T`，但对于`std::map`，`value_type`是`std::pair<const
    Key, T>`类型。这些成员类型的目的在于帮助进行泛型编程。
- en: Except for the `std::array` class, which represents an array of a size known
    at compile time, all the other containers allocate memory dynamically. This is
    controlled with the help of an object called an `std::allocator` if none is specified.
    This standard allocator uses the global `new` and `delete` operators for allocating
    and releasing memory. All constructors of standard containers (including copy
    and move constructors) have overloads that allow us to specify an allocator.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表示编译时已知大小的数组的`std::array`类之外，所有其他容器都动态分配内存。如果没有指定，这通过一个称为`std::allocator`的对象来控制。这个标准分配器使用全局的`new`和`delete`运算符来分配和释放内存。所有标准容器的构造函数（包括复制和移动构造函数）都有重载，允许我们指定一个分配器。
- en: 'There are also common member functions defined in the standard containers.
    Here are some examples:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 标准容器还定义了一些常见的成员函数。以下是一些示例：
- en: '`size`, which returns the number of elements (not present in `std::forward_list`).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`，返回元素数量（在`std::forward_list`中不存在）。'
- en: '`empty`, which checks whether the container is empty.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty`，它检查容器是否为空。'
- en: '`clear`, which clears the content of the container (not present in `std::array`,
    `std::stack`, `std::queue`, and `std::priority_queue`).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear`，它清除容器的内容（`std::array`、`std::stack`、`std::queue`和`std::priority_queue`中不存在）。'
- en: '`swap`, which swaps the content of the container objects.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap`，它交换容器对象的内容。'
- en: '`begin` and `end` methods, which return iterators to the beginning and end
    of the container (not present in `std::stack`, `std::queue`, and `std::priority_queue`,
    although these are not containers but container adaptors).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin`和`end`方法，它们返回容器的开始和结束迭代器（`std::stack`、`std::queue`和`std::priority_queue`中不存在，尽管这些不是容器而是容器适配器）。'
- en: The last bullet mentions iterators. These are types that abstract the details
    of accessing elements in a container, providing a uniform way to identify and
    traverse the elements of containers. This is important because a key part of the
    standard library is represented by general-purpose algorithms. There are over
    one hundred such algorithms, ranging from sequence operations (such as `count`,
    `count_if`, `find`, and `for_each`) to modifying operations (such as `copy`, `fill`,
    `transform`, `rotate`, and `reverse`) to partitioning and sorting (`partition`,
    `sort`, `nth_element`, and more) and others. Iterators are key for ensuring they
    work generically. If each container had different ways to access its elements,
    writing generic algorithms would be virtually impossible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要点提到了迭代器。这些类型抽象了在容器中访问元素细节，提供了一种统一的方式来识别和遍历容器的元素。这很重要，因为标准库的关键部分由通用算法表示。有超过一百种这样的算法，从序列操作（如`count`、`count_if`、`find`和`for_each`）到修改操作（如`copy`、`fill`、`transform`、`rotate`和`reverse`），再到分区和排序（`partition`、`sort`、`nth_element`等）以及其他操作。迭代器对于确保它们具有通用性至关重要。如果每个容器都有不同的访问其元素的方式，编写通用算法将几乎是不可能的。
- en: 'Let’s consider the simple operation of copying elements from one container
    to another. For instance, we have a `std::vector` object and we want to copy its
    elements to a `std::list` object. This could look as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑将元素从一个容器复制到另一个容器的简单操作。例如，我们有一个`std::vector`对象，我们希望将其元素复制到`std::list`对象中。这可能看起来如下所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What if we want to copy from a `std::list` to a `std::set`, or from a `std::set`
    to a `std::array`? Each case would require different kinds of code. However, general-purpose
    algorithms enable us to do this in a uniform way. The following snippet shows
    such an example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从`std::list`复制到`std::set`，或者从`std::set`复制到`std::array`呢？每种情况都需要不同类型的代码。然而，通用算法使我们能够以统一的方式完成这些操作。以下代码片段展示了这样的一个例子：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here we have a `std::vector` object and we copy its content to another `std::vector`,
    but also to a `std::list` object. Consequently, the content of the `std::list`
    object is then copied to a `std::set` object. For all cases, the `std::copy` algorithm
    is used. This algorithm has several arguments: two iterators that define the beginning
    and end of the source, and an iterator that defines the beginning of the destination.
    The algorithm copies one element at a time from the input range to the element
    pointer by the output iterator and then increments the output iterator. Conceptually,
    it can be implemented as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`std::vector`对象，我们将它的内容复制到另一个`std::vector`中，同时也复制到一个`std::list`对象中。因此，`std::list`对象的内容随后被复制到`std::set`对象中。在所有情况下，都使用了`std::copy`算法。这个算法有几个参数：两个迭代器定义源的开始和结束，以及一个迭代器定义目标开始。算法通过输出迭代器逐个复制输入范围中的元素到输出迭代器指向的元素，然后增加输出迭代器。从概念上讲，它可以如下实现：
- en: '[PRE23]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Important Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This algorithm was discussed in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*, when we looked at how its implementation
    can be optimized with the help of type traits.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法在[*第五章*](B18367_05_ePub.xhtml#_idTextAnchor080)中进行了讨论，*类型特性和条件编译*，当时我们探讨了如何利用类型特性来优化其实现。
- en: Considering the previous example, there are cases when the destination container
    does not have its content already allocated for the copying to take place. This
    is the case with copying to the list and to the set. In this case, iterator-like
    types, `std::back_insert_iterator` and `std:insert_iterator`, are used—indirectly
    through the `std::back_inserter` and `std::inserter` helper functions, for inserting
    elements into a container. The `std::back_insert_iterator` class uses the `push_back`
    function and `std::insert_iterator` uses the `insert` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面的示例，存在目标容器尚未为其内容分配空间以进行复制的情况。这与将元素复制到列表和集合的情况相同。在这种情况下，使用类似迭代器的类型，`std::back_insert_iterator`
    和 `std::insert_iterator`，间接通过 `std::back_inserter` 和 `std::inserter` 辅助函数，将元素插入到容器中。`std::back_insert_iterator`
    类使用 `push_back` 函数，而 `std::insert_iterator` 使用 `insert` 函数。
- en: 'There are six iterator categories in C++:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C++中有六个迭代器类别：
- en: Input iterator
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入迭代器
- en: Output iterator
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出迭代器
- en: Forward iterator
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向迭代器
- en: Bidirectional iterator
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向迭代器
- en: Random access iterator
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机访问迭代器
- en: Contiguous iterator
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续迭代器
- en: 'The contiguous iterator category was added in C++17\. All operators can be
    incremented with the prefix or postfix increment operator. The following table
    shows the additional operations that each category defines:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 连续迭代器类别是在 C++17 中添加的。所有操作符都可以使用前缀或后缀增量运算符进行递增。以下表格显示了每个类别定义的附加操作：
- en: '![Table 8.1'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 8.1]'
- en: '](img/Table_8.01_B18367.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Table_8.01_B18367.jpg]'
- en: Table 8.1
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1
- en: With the exception of the output category, each category includes everything
    about it. That means a forward iterator is an input iterator, a bidirectional
    iterator is a forward iterator, a random-access iterator is a bidirectional iterator,
    and, lastly, a contiguous iterator is a random-access iterator. However, iterators
    in any of the first five categories can also be output iterators at the same time.
    Such an iterator is called a **mutable** iterator. Otherwise, they are said to
    be **constant** iterators.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了输出类别外，每个类别都包含关于它的所有内容。这意味着前向迭代器是输入迭代器，双向迭代器是前向迭代器，随机访问迭代器是双向迭代器，最后，连续迭代器是随机访问迭代器。然而，任何前五个类别中的迭代器也可以同时是输出迭代器。这样的迭代器被称为**可变**迭代器。否则，它们被称为**常量**迭代器。
- en: 'The C++20 standard has added support for concepts and a concepts library. This
    library defines standard concepts for each of these iterator categories. The following
    table shows the correlation between them:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C++20标准增加了对概念和概念库的支持。该库为这些迭代器类别中的每一个定义了标准概念。以下表格显示了它们之间的关联：
- en: '![Table 8.2'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 8.2]'
- en: '](img/Table_8.02_B18367.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 8.02_B18367.jpg]'
- en: Table 8.2
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.2
- en: Important Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Iterator concepts were briefly discussed in [*Chapter 6*](B18367_06_ePub.xhtml#_idTextAnchor099),
    *Concepts and Constraints*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器概念在[*第 6 章*](B18367_06_ePub.xhtml#_idTextAnchor099)中简要讨论了，*概念和约束*。
- en: 'All containers have the following members:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有容器都具有以下成员：
- en: '`begin`: It returns an iterator to the beginning of the container.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin`：它返回一个指向容器开头的迭代器。'
- en: '`end`: It returns an iterator to the end of the container.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`：它返回一个指向容器末尾的迭代器。'
- en: '`cbegin`: It returns a constant iterator to the beginning of the container.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cbegin`：它返回一个指向容器开头的常量迭代器。'
- en: '`cend`: It returns a constant iterator to the end of the container.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cend`：它返回一个指向容器末尾的常量迭代器。'
- en: 'Some containers also have members that return reverse iterators:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些容器还具有返回反向迭代器的成员：
- en: '`rbegin`: It returns a reverse iterator to the beginning of the reversed container.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rbegin`：它返回一个指向反转容器开头的反向迭代器。'
- en: '`rend`: It returns a reverse iterator to the end of the reversed container.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rend`：它返回一个指向反转容器末尾的反向迭代器。'
- en: '`rcbegin`: It returns a constant reverse iterator to the beginning of the reversed
    container.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rcbegin`：它返回一个指向反转容器开头的常量反向迭代器。'
- en: '`rcend`: It returns a constant reverse iterator to the end of the reversed
    container.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rcend`：它返回一个指向反转容器末尾的常量反向迭代器。'
- en: "There are two things that must be well understood to be able to work with containers\
    \ \Land iterators:"
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事必须理解得很好，才能与容器和迭代器一起工作：
- en: The end of a container is not the last element of the container but the one
    past the last.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的末尾不是容器的最后一个元素，而是最后一个元素之后的元素。
- en: Reversed iterators provide access to the elements in reverse order. A reversed
    iterator to the first element of a container is actually the last element of the
    non-reversed container.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向迭代器提供对容器中元素的逆序访问。容器第一个元素的反向迭代器实际上是未反转容器的最后一个元素。
- en: 'To better understand these two points, let’s look at the following example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这两点，让我们看看以下示例：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first call to `std::copy` prints the elements of the container in their
    given order. On the other hand, the second call to `std::copy` prints the elements
    in their reversed order.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::copy` 的第一次调用按给定顺序打印容器中的元素。另一方面，`std::copy` 的第二次调用按相反顺序打印元素。'
- en: 'The following diagram illustrates the relationship between iterators and container
    elements:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了迭代器和容器元素之间的关系：
- en: '![Figure 8.1'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.1]'
- en: '](img/Figure_8.1_B18367.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.1_B18367.jpg]'
- en: Figure 8.1
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.1]'
- en: A sequence of elements (regardless of what kind of data structure they are stored
    in memory) delimited by two iterators (a begin and an end, which is the one past
    the last element) is called a **range**. This term is used extensively in the
    C++ standard (especially with algorithms) and in literature. It is also the term
    that gave the name to the ranges library in C++20, which will be discussed in
    [*Chapter 9*](B18367_09_ePub.xhtml#_idTextAnchor188), *The Ranges Library*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由两个迭代器（一个开始和一个结束，即最后一个元素之后的那个）分隔的元素序列（无论它们存储在内存中的数据结构是什么）被称为**范围**。这个术语在C++标准（特别是与算法一起）和文献中广泛使用。它也是C++20中范围库得名的术语，将在[*第9章*](B18367_09_ePub.xhtml#_idTextAnchor188)“范围库”中讨论。
- en: 'Apart from the set of the begin/end member functions of the standard containers,
    there are also stand-alone functions with the same name. Their equivalence is
    presented in the following table:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准容器的 begin/end 成员函数集之外，还有同名的独立函数。它们之间的等价性在以下表中展示：
- en: '![Table 8.3'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 8.3]'
- en: '](img/Table_8.03_B18367.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 8.03_B18367.jpg]'
- en: Table 8.3
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.3
- en: 'Although these free functions do not bring much benefit when working with standard
    containers, they help us in writing generic code that can handle both standard
    containers and C-like arrays, since all these free functions are overloaded for
    static arrays. Here is an example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些自由函数在处理标准容器时并不带来很多好处，但它们帮助我们编写通用的代码，可以处理标准容器和C样式的数组，因为这些自由函数都为静态数组重载。以下是一个示例：
- en: '[PRE40]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Without these functions, we would have to write `std::copy(a, a + 5, …)`. Perhaps
    a big benefit of these functions is that they enable us to use arrays with range-based
    for loops, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这些函数，我们不得不编写 `std::copy(a, a + 5, …)`。也许这些函数的一个大好处是它们使我们能够使用基于范围的for循环来使用数组，如下所示：
- en: '[PRE46]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It is not the purpose of this book to teach you how to use each container or
    the many standard algorithms. However, it should be helpful for you to learn how
    to create containers, iterators, and algorithms. This is what we will do next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的不是教你如何使用每个容器或许多标准算法。然而，学习如何创建容器、迭代器和算法对你来说应该是有帮助的。这就是我们将要做的。
- en: Creating a custom container and iterator
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义容器和迭代器
- en: 'The best way to understand how containers and iterators work is to experience
    them first-hand by creating your own. To avoid implementing something that already
    exists in the standard library, we will consider something different – more precisely,
    a **circular buffer**. This is a container that, when full, overwrites existing
    elements. We can think of different ways such a container could work; therefore,
    it’s important that we first define the requirements for it. These are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 理解容器和迭代器工作原理的最好方式是亲自创建它们。为了避免实现标准库中已经存在的东西，我们将考虑一些不同的事物——更确切地说，是一个**循环缓冲区**。这是一个当满时覆盖现有元素的容器。我们可以考虑不同的方式来使这样的容器工作；因此，我们首先定义其要求是很重要的。这些要求如下：
- en: The container should have a fixed capacity that is known at compile-time. Therefore,
    there would be no runtime memory management.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器应该具有在编译时已知的固定容量。因此，将不会有运行时内存管理。
- en: The capacity is the number of elements the container can store, and the size
    is the number of elements it actually contains. When the size equals the capacity,
    we say the container is full.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容量是容器可以存储的元素数量，而大小是它实际包含的元素数量。当大小等于容量时，我们说容器已满。
- en: When the container is full, adding a new element will overwrite the oldest element
    in the container.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当容器满时，添加新元素将覆盖容器中最旧的元素。
- en: Adding new elements is always done at the end; removing existing elements is
    always done at the beginning (the oldest element in the container).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新元素始终在末尾进行；删除现有元素始终在开头进行（容器中最旧的元素）。
- en: There should be random access to the elements of the container, both with the
    subscript operator and with iterators.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该能够通过下标操作符和迭代器对容器的元素进行随机访问。
- en: 'Based on these requirements, we can think of the following implementation details:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些要求，我们可以考虑以下实现细节：
- en: The elements could be stored in an array. For convenience, this could be the
    `std::array` class.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素可以存储在数组中。为了方便，这可以是 `std::array` 类。
- en: We need two variables, which we call `head` and `tail`, to store the index of
    the first and last elements of the container. This is needed because due to the
    circular nature of the container, the beginning and the end shift over time.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要两个变量，我们称之为 `head` 和 `tail`，以存储容器中第一个和最后一个元素的下标。这是必需的，因为由于容器的循环性质，开始和结束会随着时间的推移而移动。
- en: A third variable will store the number of elements in the container. This is
    useful because otherwise, we would not be able to differentiate whether the container
    is empty or has one element only from the values of the head and tail indexes.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个变量将存储容器中的元素数量。这很有用，因为否则我们无法从 head 和 tail 指数的值中区分容器是否为空或只有一个元素。
- en: Important Note
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: The implementation shown here is provided for teaching purposes only and is
    not intended as a production-ready solution. The experienced reader will find
    different aspects of the implementation that could be optimized. However, the
    purpose here is to learn how to write a container and not how to optimize the
    implementation.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里提供的实现仅用于教学目的，并不打算作为生产就绪的解决方案。有经验的读者会发现实现的不同方面可以进行优化。然而，这里的目的是学习如何编写容器，而不是如何优化实现。
- en: 'The following diagram shows a visual representation of such a circular buffer,
    with a capacity of eight elements with different states:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了这样一个循环缓冲区的视觉表示，具有八个不同状态的元素容量：
- en: '![Figure 8.2'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2'
- en: '](img/Figure_8.2_B18367.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B18367.jpg)'
- en: Figure 8.2
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2
- en: 'What we can see in this diagram is the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这张图中看到以下内容：
- en: '**Figure A**: This is an empty buffer. The capacity is 8, the size is 0, and
    the **head** and **tail** both point to index **0**.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图 A**：这是一个空缓冲区。容量是 8，大小是 0，而 **head** 和 **tail** 都指向下标 **0**。'
- en: '**Figure B**: This buffer contains one element. The capacity is still 8, the
    size is 1, and the **head** and **tail** both still point to index **0**.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图 B**：这个缓冲区包含一个元素。容量仍然是 8，大小是 1，而 **head** 和 **tail** 都仍然指向下标 **0**。'
- en: '**Figure C**: This buffer contains two elements. The size is 2, the **head**
    contains index **0**, and the **tail** contains index **1**.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图 C**：这个缓冲区包含两个元素。大小是 2，**head** 包含下标 **0**，而 **tail** 包含下标 **1**。'
- en: '**Figure D**: This buffer is full. The size is 8, which is equal to the capacity,
    and the **head** contains index **0** and the **tail** contains index **7**.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图 D**：这个缓冲区已满。大小是 8，等于容量，**head** 包含下标 **0**，而 **tail** 包含下标 **7**。'
- en: '**Figure E**: This buffer is still full, but an additional element has been
    added, triggering the overwriting of the oldest element in the buffer. The size
    is 8, the **head** contains index **1**, and the **tail** contains index **0**.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图 E**：这个缓冲区仍然已满，但已添加了一个额外的元素，触发了缓冲区中最老元素的重写。大小是 8，**head** 包含下标 **1**，而 **tail**
    包含下标 **0**。'
- en: Now that we have looked at the semantics of the circular buffer, we can start
    writing the implementation. We will begin with the container class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了循环缓冲区的语义，我们可以开始编写实现。我们将从容器类开始。
- en: Implementing a circular buffer container
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现循环缓冲区容器
- en: 'The code for the container class would be too long to be put in a single listing,
    so we’ll break it up into multiple snippets. The first is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 容器类的代码太长，无法放在一个列表中，所以我们将将其分成多个片段。第一个如下：
- en: '[PRE52]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There are two things here: the forward declaration of a class template called
    `circular_buffer_iterator`, and a class template called `circular_buffer`. Both
    have the same template arguments, a type template parameter `T`, representing
    the type of the elements, and a non-type template parameter, representing the
    capacity of the buffer. A constraint is used to ensure that the provided value
    for capacity is always positive. If you are not using C++20, you can replace the
    constraint with a `static_assert` statement or `enable_if` to enforce the same
    restriction. The following snippets are all part of the `circular_buffer` class.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个东西：一个名为 `circular_buffer_iterator` 的类模板的前向声明，以及一个名为 `circular_buffer` 的类模板。它们具有相同的模板参数，一个类型模板参数
    `T`，表示元素的类型，以及一个非类型模板参数，表示缓冲区的容量。使用约束来确保提供的容量值始终为正。如果您不使用 C++20，可以将约束替换为 `static_assert`
    语句或 `enable_if` 来强制执行相同的限制。以下代码片段都是 `circular_buffer` 类的一部分。
- en: 'First, we have a series of member type definitions that provide aliases to
    different types that are relevant to the `circular_buffer` class template. These
    will be used in the implementation of the class. They are shown next:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一系列成员类型定义，为与 `circular_buffer` 类模板相关的不同类型提供别名。这些将在类的实现中使用。它们将在下面展示：
- en: '[PRE61]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Second, we have the data members that store the buffer state. The actual elements
    are stored in a `std::array` object. The head, tail, and size are all stored in
    a variable of the `size_type` data type. These members are all private:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们有存储缓冲区状态的成员数据。实际元素存储在一个 `std::array` 对象中。头、尾和大小都存储在 `size_type` 数据类型的变量中。这些成员都是私有的：
- en: '[PRE72]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Third, we have the member functions that implement the functionality described
    earlier. All the following members are public. The first to list here are the
    constructors:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们有实现之前描述的功能的成员函数。以下所有成员都是公开的。首先列出的是构造函数：
- en: '[PRE77]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'There are three constructors defined here (although we can think of additional
    ones). These are the default constructor (which is also defaulted) that initializes
    an empty buffer, a constructor from a C-like array of size `N`, which initializes
    a full buffer by copying the array elements, and, finally, a constructor that
    takes a single value and initializes a full buffer by copying that value into
    each element of the buffer. These constructors allow us to create circular buffers
    in any of the following ways:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里定义了三个构造函数（尽管我们可以想到更多的）。这些是默认构造函数（它也是默认的），用于初始化一个空的缓冲区，一个从类似C语言的数组中构造的构造函数，它通过复制数组元素来初始化一个满缓冲区，最后是一个接受单个值的构造函数，通过将该值复制到缓冲区的每个元素中来初始化一个满缓冲区。这些构造函数允许我们以以下任何一种方式创建循环缓冲区：
- en: '[PRE89]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, we define several member functions that describe the state of the circular
    buffer:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了几个描述循环缓冲区状态的成员函数：
- en: '[PRE92]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `size` function returns the number of elements in the buffer, the `capacity`
    function the number of elements that the buffer can hold, the `empty` function
    to check whether the buffer has no elements (the same as `size() == 0`), and the
    `full` function to check whether the buffer is full (the same as `size() == N`).
    There is also a function called `clear` that puts the circular buffer in the empty
    state. Beware that this function doesn't destroy any element (does not release
    memory or call destructors) but only resets the values defining the state of the
    buffer.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` 函数返回缓冲区中的元素数量，`capacity` 函数返回缓冲区可以容纳的元素数量，`empty` 函数用于检查缓冲区是否没有元素（等同于
    `size() == 0`），而 `full` 函数用于检查缓冲区是否已满（等同于 `size() == N`）。还有一个名为 `clear` 的函数，可以将循环缓冲区置于空状态。请注意，此函数不会销毁任何元素（不会释放内存或调用析构函数），而只是重置定义缓冲区状态的值。'
- en: 'We need to access the elements of the buffer; therefore, the following functions
    are defined for this purpose:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要访问缓冲区的元素；因此，定义了以下函数来达到这个目的：
- en: '[PRE102]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Each of these members has a `const` overload that is called for constant instances
    of the buffer. The constant member returns a constant reference; the non-const
    member returns a normal reference. These methods are as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些成员都有一个 `const` 重载，用于调用缓冲区的常量实例。常量成员返回一个常量引用；非常量成员返回一个正常引用。这些方法如下：
- en: The subscript operator that returns a reference to the element specified by
    its index, without checking the value of the index
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下标运算符返回对指定索引的元素的引用，而不检查索引的值
- en: The `at` method that works similarly to the subscript operator, except that
    it checks that the index is smaller than the size and, if not, throws an exception
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at`方法与下标操作符类似，但它会检查索引是否小于大小，如果不是，则抛出异常'
- en: The `front` method that returns a reference to the first element; if the buffer
    is empty, it throws an exception
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回第一个元素引用的`front`方法；如果缓冲区为空，则抛出异常
- en: The `back` method that returns a reference to the last element; if the buffer
    is empty, it throws an exception
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回最后一个元素引用的`back`方法；如果缓冲区为空，则抛出异常
- en: 'We have members to access the elements, but we need members for adding and
    removing elements to/from the buffer. Adding new elements always happens at the
    end, so we’ll call this `push_back`. Removing existing elements always happens
    at the beginning (the oldest element), so we’ll call this `pop_front`. Let’s look
    first at the former:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有成员函数来访问元素，但我们还需要成员函数来向/从缓冲区添加和删除元素。添加新元素总是发生在末尾，因此我们将此称为`push_back`。删除现有元素总是发生在开始位置（最老的元素），因此我们将此称为`pop_front`。让我们首先看看前者：
- en: '[PRE142]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'This works based on the defined requirements and the visual representations
    from *Figure 8.2*:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这基于定义的要求和来自*图8.2*的视觉表示：
- en: If the buffer is empty, copy the value to the element pointed by the `tail_`
    index and increment the size.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果缓冲区为空，则将值复制到`tail_`索引指向的元素，并增加大小。
- en: If the buffer is neither empty nor full, do the same but also increment the
    value of the `tail_` index.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果缓冲区既不为空也不为满，则执行相同的操作，但还要增加`tail_`索引的值。
- en: If the buffer is full, increment both the `head_` and the `tail_` and then copy
    the value to the element pointed by the `tail_` index.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果缓冲区已满，则增加`head_`和`tail_`的值，然后将值复制到`tail_`索引指向的元素。
- en: 'This function copies the `value` argument to a buffer element. However, this
    could be optimized for temporaries or objects that are no longer needed after
    pushing to the buffer. Therefore, an overload that takes an rvalue reference is
    provided. This moves the value to the buffer, avoiding an unnecessary copy. This
    overload is shown in the following snippet:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将`value`参数复制到缓冲区元素。然而，这可以针对临时对象或推送至缓冲区后不再需要的对象进行优化。因此，提供了一个接受rvalue引用的重载。这会将值移动到缓冲区，避免不必要的复制。此重载在以下代码片段中显示：
- en: '[PRE161]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'A similar approach is used for implementing the `pop_back` function to remove
    elements from the buffer. Here is the implementation:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 实现从缓冲区删除元素的`pop_back`函数采用类似的方法。以下是实现：
- en: '[PRE180]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'This function throws an exception if the buffer is empty. Otherwise, it increments
    the value of the `head_` index and returns the value of the element from the previous
    position of the `head_`. This is described visually in the following diagram:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缓冲区为空，则抛出异常。否则，增加`head_`索引的值，并返回`head_`前一个位置的元素值。这在以下图中进行了视觉描述：
- en: '![Figure 8.3'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3'
- en: '](img/Figure_8.3_B18367.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B18367.jpg)'
- en: Figure 8.3
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3
- en: 'What we can see here is the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到以下内容：
- en: '**Figure A**: The buffer has 3 elements (1, 2, and 3), **head** is at index
    **0**, and **tail** is at index **2**.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图A**：缓冲区有3个元素（1、2和3），**头**位于索引**0**，而**尾**位于索引**2**。'
- en: '**Figure B**: An element has been removed from the front, which was index **0**.
    Therefore, **head** is now index **1** and **tail** is still index **2**. The
    buffer now has two elements.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图B**：已从前面删除了一个元素，其索引为**0**。因此，**头**现在是索引**1**，而**尾**仍然位于索引**2**。缓冲区现在有两个元素。'
- en: '**Figure C**: The buffer has eight elements, which is its maximum capacity,
    and an element has been overwritten. The **head** is at index **1** and the **tail**
    is at index **0**.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图C**：缓冲区有八个元素，这是其最大容量，并且一个元素已被覆盖。**头**位于索引**1**，而**尾**位于索引**0**。'
- en: '**Figure D**: An element has been removed from the front, which was index **1**.
    The **head** is now at index **2** and the **tail** is still at index **0**. The
    buffer now has seven elements.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图D**：已从前面删除了一个元素，其索引为**1**。现在**头**位于索引**2**，而**尾**仍然位于索引**0**。缓冲区现在有七个元素。'
- en: 'An example of using both the `push_back` and the `pop_front` member functions
    is shown in the next snippet:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段展示了同时使用`push_back`和`pop_front`成员函数的示例：
- en: '[PRE188]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Finally, we have the member functions `begin` and `end` that return iterators
    to the first and one-past-the-last elements of the buffer. Here is their implementation:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有成员函数`begin`和`end`，它们返回指向缓冲区第一个和最后一个元素之后的迭代器。以下是它们的实现：
- en: '[PRE197]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: To understand these, we need to see how the iterator class is actually implemented.
    We will explore this in the next section.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些，我们需要看看迭代器类实际上是如何实现的。我们将在下一节中探讨这一点。
- en: Implementing an iterator type for the circular buffer container
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现循环缓冲区容器的迭代器类型
- en: 'We declared the iterator class template at the beginning of the previous section
    when we started with the `circular_buffer` container. However, we need to define
    its implementation too. Yet, there is one more thing we must do: in order for
    the iterator class to be able to access the private members of the container it
    needs to be declared as a friend. This is done as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始 `circular_buffer` 容器时，我们在前一节的开始处声明了迭代器类模板。然而，我们还需要定义其实现。但是，我们还有一件事必须做：为了让迭代器类能够访问容器的私有成员，它需要被声明为友元。这是如下完成的：
- en: '[PRE213]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Let’s look now at the `circular_buffer_iterator` class, which actually has
    similarities with the container class. This includes the template parameters,
    the constraints, and the set of member types (some of them being common to those
    in `circular_buffer`). Here is a snippet of the class:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `circular_buffer_iterator` 类，它实际上与容器类有相似之处。这包括模板参数、约束以及成员类型集合（其中一些与
    `circular_buffer` 中的类型相同）。以下是类的片段：
- en: '[PRE215]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'The `circular_buffer_iterator` class has a reference to a circular buffer and
    an index to the element in the buffer that it points to. The reference to `circular_buffer<T,
    N>` is wrapped inside a `std::reference_wrapper` object. The reason for this will
    be unveiled shortly. Such an iterator can be explicitly created by providing these
    two arguments. Therefore, the only constructor looks as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`circular_buffer_iterator` 类有一个指向循环缓冲区的引用和一个指向它所指向的缓冲区元素的索引。对 `circular_buffer<T,
    N>` 的引用被封装在一个 `std::reference_wrapper` 对象中。原因将在稍后揭晓。这样的迭代器可以通过提供这两个参数显式创建。因此，只有一个构造函数如下所示：'
- en: '[PRE236]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: If we now look back at the definitions of the `begin` and `end` member functions
    of `circular_buffer`, we can see that the first argument was `*this`, and the
    second was 0 for the begin iterator and `size_` for the end iterator. The second
    value is the offset from the head of the element pointed by the iterator. Therefore,
    0 is the first element, and `size_` is the one-past-the-last element in the buffer.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在回顾 `circular_buffer` 的 `begin` 和 `end` 成员函数的定义，我们可以看到第一个参数是 `*this`，第二个参数对于开始迭代器是
    0，对于结束迭代器是 `size_`。第二个值是迭代器所指向的元素从头部开始的偏移量。因此，0 是第一个元素，`size_` 是缓冲区中最后一个元素之后的一个元素。
- en: We have decided that we need random access to the elements of the buffer; therefore,
    the iterator category is random-access. The member type `iterator_category` is
    an alias for `std::random_access_iterator_tag`. This implies that we need to provide
    all the operations supported for such an iterator. In the previous section of
    this chapter, we discussed the iterator categories and the required operations
    for each category. We will implement all the required ones next.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定我们需要对缓冲区的元素进行随机访问；因此，迭代器类别是随机访问。成员类型 `iterator_category` 是 `std::random_access_iterator_tag`
    的别名。这意味着我们需要提供此类迭代器支持的所有操作。在本章的前一节中，我们讨论了迭代器类别和每个类别所需的操作。我们将在下一节中实现所有必需的操作。
- en: 'We start with the requirements for an input iterator, which are as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从输入迭代器的要求开始，如下所示：
- en: '[PRE241]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'We have implemented here incrementing (both pre- and post-fix), checking for
    equality/inequality, and dereferencing. The `*` and `->` operators throw an exception
    if the element cannot be dereferenced. The cases when this happens are when the
    buffer is empty, or the index is not within bounds (between `head_` and `tail_`).
    We used two helper functions (both private), called `compatible` and `is_bounds`.
    These are shown next:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里实现了递增（前缀和后缀），检查相等/不等，以及解引用。当元素无法解引用时，`*` 和 `->` 运算符会抛出异常。这种情况发生在缓冲区为空，或者索引不在范围内（在
    `head_` 和 `tail_` 之间）。我们使用了两个辅助函数（都是私有的），分别称为 `compatible` 和 `is_bounds`。这些将在下面展示：
- en: '[PRE281]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: A `a` and `b` are two forward iterators and they are equal, then either they
    are non-dereferenceable, otherwise, their iterator values, `*a` and `*b`, refer
    to the same object. The opposite is also true, meaning that if `*a` and `*b` are
    equal, then `a` and `b` are also equal. This is true for our implementation.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `a` 和 `b` 是两个前向迭代器并且它们相等，那么它们要么是不可解引用的，否则它们的迭代器值 `*a` 和 `*b` 指向同一个对象。反之亦然，这意味着如果
    `*a` 和 `*b` 相等，那么 `a` 和 `b` 也相等。这对于我们的实现是正确的。
- en: 'The other requirement for forward iterators is that they are swappable. That
    means if `a` and `b` are two forward iterators, then `swap(a, b)` should be a
    valid operation. This leads us back to using a `std::reference_wrapper` object
    to hold a reference to a `circular_buffer<T, N>`. References are not swappable,
    which would have made `circular_buffer_iterator` not swappable either. However,
    `std::reference_wrapper` is swappable, and that also makes our iterator type swappable.
    That can be verified with a `static_assert` statement, such as the following:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 前向迭代器的另一个要求是它们是可交换的。这意味着如果`a`和`b`是两个前向迭代器，那么`swap(a, b)`应该是一个有效的操作。这又让我们回到了使用`std::reference_wrapper`对象来持有对`circular_buffer<T,
    N>`的引用。引用是不可交换的，这将使得`circular_buffer_iterator`也不可交换。然而，`std::reference_wrapper`是可交换的，这也使得我们的迭代器类型可交换。这可以通过一个`static_assert`语句来验证，如下所示：
- en: '[PRE293]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: Important Note
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: An alternative to using `std::reference_wrapper` is to use a raw pointer to
    a `circular_buffer` class, since pointers can be assigned values and are, therefore
    swappable. It is a matter of style and personal choice which one to use. In this
    example, I preferred the solution that avoided the raw pointer.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始指针到`circular_buffer`类的替代方案是使用`std::reference_wrapper`，因为指针可以赋值，因此是可交换的。使用哪种方式是风格和个人选择的问题。在这个例子中，我更喜欢避免使用原始指针的解决方案。
- en: 'For fulfilling the requirements for the bidirectional iterator category, we
    need to support decrementing. In the next snippet, you can see the implementation
    of both pre- and post-fix decrement operators:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足双向迭代器类别的需求，我们需要支持递减操作。在下一个代码片段中，您可以看到前置和后置递减运算符的实现：
- en: '[PRE295]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'Finally, we have the requirements of the `+` and `-`) and compound (`+=` and
    `-=`) operations. These are shown next:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`+`和`-`（以及复合的`+=`和`-=`）操作的要求。这些将在下面展示：
- en: '[PRE309]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'Random-access iterators must support inequality comparison with other operations.
    That means, we need to overload the `<`, `<=`, `>`, and `>=` operators. However,
    the `<=`, `>`, and `>=` operators can be implemented based on the `<` operator.
    Therefore, their definition can be as follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 随机访问迭代器必须支持与其他操作的不等比较。这意味着我们需要重载`<`、`<=`、`>`和`>=`运算符。然而，`<=`、`>`和`>=`运算符可以基于`<`运算符来实现。因此，它们的定义可以如下所示：
- en: '[PRE337]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'Last, but not least, we need to provide access to elements with the subscript
    operator (`[]`). A possible implementation is the following:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们需要提供通过下标运算符（`[]`）访问元素的方法。一个可能的实现如下：
- en: '[PRE353]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: 'With this, we have completed the implementation of the iterator type for the
    circular buffer. If you had trouble following the multitude of code snippets for
    these two classes, you can find the complete implementation in the GitHub repository
    for the book. A simple example for using the iterator type is shown next:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经完成了环形缓冲区迭代器类型的实现。如果您在跟踪这两个类的众多代码片段时遇到困难，您可以在GitHub仓库中找到这本书的完整实现。下面展示了使用迭代器类型的一个简单示例：
- en: '[PRE361]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: 'This code can be actually simplified with range-based for loops. In this case,
    we don’t use iterators directly, but the compiler-generated code does. Therefore,
    the following snippet is equivalent to the previous one:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上可以通过基于范围的for循环来简化。在这种情况下，我们不直接使用迭代器，而是编译器生成的代码。因此，以下代码片段与上一个代码片段等价：
- en: '[PRE367]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'However, the implementation provided here for `circular_buffer_iterator` does
    not allow the following piece of code to compile:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里提供的`circular_buffer_iterator`实现不允许以下代码片段编译：
- en: '[PRE373]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: 'This requires that we are able to write elements through iterators. However,
    our implementation doesn’t meet the requirements for the output iterator category.
    This requires that expressions such as `*it = v`, or `*it++ = v` are valid. To
    do so, we need to provide non-const overloads of the `*` and `->` operators that
    return non-const reference types. This can be done as follows:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求我们能够通过迭代器写入元素。然而，我们的实现没有满足输出迭代器类别的需求。这要求表达式如`*it = v`或`*it++ = v`是有效的。为了做到这一点，我们需要提供非const重载的`*`和`->`运算符，它们返回非const引用类型。这可以通过以下方式实现：
- en: '[PRE376]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: More examples for using the `circular_buffer` class with and without iterators
    can be found in the GitHub repository. Next, we will focus our attention on implementing
    a general-purpose algorithm that works for any range, including the `circular_buffer`
    container we defined here.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub仓库中可以找到使用`circular_buffer`类带有和没有迭代器的更多示例。接下来，我们将专注于实现一个适用于任何范围的通用算法，包括我们在这里定义的`circular_buffer`容器。
- en: Writing a custom general-purpose algorithm
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义通用算法
- en: In the first section of this chapter, we saw why abstracting access to container
    elements with iterators is key for building general-purpose algorithms. However,
    it should be useful for you to practice writing such an algorithm because it can
    help you better understand the use of iterators. Therefore, in this section, we
    will write a general-purpose algorithm.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一节中，我们看到了使用迭代器抽象容器元素访问对于构建通用算法的重要性。然而，练习编写这样的算法应该对你有所帮助，因为它可以帮助你更好地理解迭代器的使用。因此，在本节中，我们将编写一个通用算法。
- en: 'The standard library features many such algorithms. One that is missing is
    a **zipping algorithm**. What zipping means is actually interpreted or understood
    differently by different people. For some, zipping means taking two or more input
    ranges and creating a new range with the elements from the input ranges intercalated.
    This is exemplified in the following diagram:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库具有许多这样的算法。其中缺失的一个是**合并算法**。合并的含义实际上被不同的人以不同的方式解释或理解。对于一些人来说，合并意味着取两个或更多输入范围并创建一个新的范围，其中输入范围的元素是交错排列的。这将在以下图中举例说明：
- en: '![Figure 8.4'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4'
- en: '](img/Figure_8.4_B18367.jpg)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B18367.jpg)'
- en: Figure 8.4
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4
- en: 'For others, zipping means taking two or more input ranges and creating a new
    range, with elements being tuples formed from the elements of the input ranges.
    This is shown in the next diagram:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他人来说，合并意味着取两个或更多输入范围并创建一个新的范围，其中元素是由输入范围的元素组成的元组。这将在下一图中展示：
- en: '![Figure 8.5'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5'
- en: '](img/Figure_8.5_B18367.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B18367.jpg)'
- en: Figure 8.5
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5
- en: 'In this section, we will implement the first algorithm. In order to avoid confusion,
    we will call this **flatzip**. Here are the requirements for it:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现第一个算法。为了避免混淆，我们将称之为**flatzip**。以下是它的要求：
- en: The algorithm takes two input ranges and writes to an output range.
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法接收两个输入范围并将结果写入输出范围。
- en: The algorithm takes iterators as arguments. A pair of first and last input iterators
    define the bounds of each input range. An output iterator defines the beginning
    of the output range where the elements will be written to.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该算法接收迭代器作为参数。一对第一个和最后一个输入迭代器定义了每个输入范围的界限。一个输出迭代器定义了输出范围的开始，元素将被写入到那里。
- en: The two input ranges should contain elements of the same type. The output range
    must have elements of the same type or a type to which the input type is implicitly
    convertible.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个输入范围应包含相同类型的元素。输出范围必须包含相同类型的元素或可以隐式转换为输入类型的类型。
- en: If the two input ranges are of different sizes, the algorithm stops when the
    smallest of the two has been processed (as shown in the previous diagrams).
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个输入范围的大小不同，算法将在处理完较小的那个范围后停止（如前图所示）。
- en: The return value is the output iterator to the one-past-the-last element that
    was copied.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值是复制到超过最后一个元素的输出迭代器。
- en: 'A possible implementation for the described algorithm is shown in the following
    listing:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的算法的一个可能实现如下所示：
- en: '[PRE394]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: 'As you can see in the snippet, the implementation is quite simple. All we do
    here is iterate through both input ranges at the same time and copy elements alternately
    from them to the destination range. The iteration on both input ranges stops when
    the end of the smallest range is reached. We can use this algorithm as follows:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码片段所示，实现相当简单。我们在这里所做的只是同时遍历两个输入范围，并交替从它们中复制元素到目标范围。当到达最小范围的末尾时，两个输入范围的迭代停止。我们可以如下使用此算法：
- en: '[PRE410]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'These examples use `std::vector` for both the input and output ranges. However,
    the `flatzip` algorithm knows nothing about containers. The elements of the container
    are accessed with the help of iterators. Therefore, as long as the iterators meet
    the specified requirements, we can use any container. This includes the `circular_buffer`
    container we previously wrote since `circular_buffer_container` meets the requirements
    for both the input and output iterator categories. This means we can also write
    the following snippet:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例使用`std::vector`作为输入和输出范围。然而，`flatzip`算法对容器一无所知。容器中的元素通过迭代器访问。因此，只要迭代器满足指定的要求，我们就可以使用任何容器。这包括我们之前编写的`circular_buffer`容器，因为`circular_buffer_container`满足输入和输出迭代器类别的需求。这意味着我们也可以编写以下代码片段：
- en: '[PRE424]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: 'We have two input circular buffers: `a`, which has four elements, and `b`,
    which has three elements. The destination circular buffer has a capacity of eight
    elements, all initialized with zero. After applying the flatzip algorithm, six
    elements of the destination circular buffer will be written with values from the
    `a` and `b` buffers. The result is that the circular buffer will contain the elements
    `1, 5, 2, 6, 3, 7, 0, 0`.'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个输入循环缓冲区：`a`，它有四个元素，和`b`，它有三个元素。目标循环缓冲区有八个元素的空间，所有元素都被初始化为零。在应用flatzip算法后，目标循环缓冲区的六个元素将被`a`和`b`缓冲区中的值写入。结果是循环缓冲区将包含元素`1,
    5, 2, 6, 3, 7, 0, 0`。
- en: Summary
  id: totrans-617
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was dedicated to seeing how templates can be used to build general-purpose
    libraries. Although we couldn’t cover these topics in great detail, we have explored
    the design of containers, iterators, and algorithms from the C++ standard library.
    These are the pillars of the standard library. We spent most of the chapter understanding
    what it takes to write a container similar to the standard ones as well as an
    iterator class to provide access to its elements. For this purpose, we implemented
    a class that represents a circular buffer, a data structure of fixed size where
    elements are overwritten once the container is full. Lastly, we implemented a
    general-purpose algorithm that zips elements from two ranges. This works for any
    container including the circular buffer container.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于探讨如何使用模板构建通用库。尽管我们无法对这些主题进行深入探讨，但我们已经探讨了C++标准库中容器、迭代器和算法的设计。这些是标准库的支柱。我们花了大部分时间来理解编写类似于标准容器的容器以及提供对其元素访问的迭代器类需要什么。为此，我们实现了一个表示循环缓冲区的类，这是一个固定大小的数据结构，当容器满时，元素将被覆盖。最后，我们实现了一个通用算法，该算法将两个范围中的元素进行合并。这对于任何容器都适用，包括循环缓冲区容器。
- en: Ranges, as discussed in this chapter, are an abstract concept. However, that
    changed with C++20, which introduced a more concrete concept of ranges with the
    new ranges library. This is what we will discuss in the final chapter of this
    book.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章所讨论的，范围是一个抽象概念。然而，随着C++20的引入，它引入了新的范围库，其中包含了一个更具体的概念。这就是本书最后一章我们将要讨论的内容。
- en: Questions
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the sequence containers from the standard library?
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准库中的序列容器有哪些？
- en: What are the common member functions defined in the standard containers?
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标准容器中定义了哪些常见的成员函数？
- en: What are iterators and how many categories exist?
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代器是什么？有多少种类别存在？
- en: What operations does a random-access iterator support?
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机访问迭代器支持哪些操作？
- en: What are range access functions?
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 范围访问函数是什么？
