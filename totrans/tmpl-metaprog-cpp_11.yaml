- en: '*Chapter 8*: Ranges and Algorithms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By reaching this point of the book, you have learned everything about the syntax
    and the mechanism of templates in C++, up to the latest version of the standard,
    C++20\. This has equipped you with the necessary knowledge to write templates
    from simple forms to complex ones. Templates are the key to writing generic libraries.
    Even though you might not write such a library yourself, you’d still be using
    one or more. In fact, the everyday code that you’re writing in C++ uses templates.
    And the main reason for that is that as a modern C++ developer, you’re using the
    standard library, which is a library based on templates.
  prefs: []
  type: TYPE_NORMAL
- en: However, the standard library is a collection of many libraries, such as the
    containers library, iterators library, algorithms library, numeric library, input/output
    library, filesystem library, regular expressions library, thread support library,
    utility libraries, and others. Overall, it’s a large library that could make the
    topic of at least an entire book. However, it is worth exploring some key parts
    of the library to help you get a better understanding of some of the concepts
    and types you are or could be using regularly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because addressing this topic in a single chapter would lead to a significantly
    large chapter, we will split the discussion into two parts. In this chapter, we
    will address the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the design of containers, iterators, and algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom container and iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a custom general-purpose algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of the three
    main pillars of the standard template library, which are containers, iterators,
    and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin this chapter with an overview of what the standard library has
    to offer in this respect.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the design of containers, iterators, and algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Containers** are types that represent collections of elements. These collections
    can be implemented based on a variety of data structures, each with different
    semantics: lists, queues, trees, and so on. The standard library provides three
    categories of containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector`, `deque`, `list`, `array`, and `forward_list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set`, `map`, `multiset`, and `multimap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unordered_set`, `unordered_map`, `unordered_multiset`, and `unordered_multimap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to this, there are also container adaptors that provide a different
    interface for sequence containers. This category includes the `stack`, `queue`,
    and `priority_queue` classes. Finally, there is a class called `span` that represents
    a non-owning view over a contiguous sequence of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rationale for these containers to be templates was presented in [*Chapter
    1*](B18367_01_ePub.xhtml#_idTextAnchor015), *Introduction to Templates*. You don’t
    want to write the same implementation again and again for each different type
    of element that you need to store in a container. Arguably, the most used containers
    from the standard library are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector`: This is a variable-size collection of elements stored contiguously
    in memory. It’s the default container you would choose, provided no special requirements
    are defined. The internal storage expands or shrinks automatically as needed to
    accommodate the stored elements. The vector allocates more memory than needed
    so that the risk of having to expand is low. The expansion is a costly operation
    because new memory needs to be allocated, the content of the current storage needs
    to be copied to the new one, and lastly, the previous storage needs to be discarded.
    Because elements are stored contiguously in memory, they can be randomly accessed
    by an index in constant time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array`: This is a fixed-size collection of elements stored contiguously in
    memory. The size must be a compile-time constant expression. The semantics of
    the `array` class is the same as a structure holding a C-style array (`T[n]`).
    Just like the `vector` type, the elements of the `array` class can be accessed
    randomly in constant time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`: This is a collection that associates a value to a unique key. Keys are
    sorted with a comparison function and the `map` class is typically implemented
    as a red-black tree. The operations to search, insert, or remove elements have
    logarithmic complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set`: This is a collection of unique keys. The keys are the actual values
    stored in the container; there are no key-value pairs as in the case of the `map`
    class. However, just like in the case of the `map` class, `set` is typically implemented
    as a red-black tree that has logarithmic complexity for searching, inserting,
    and the removing of elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regardless of their type, the standard containers have a few things in common:'
  prefs: []
  type: TYPE_NORMAL
- en: Several common member types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An allocator for storage management (with the exception of the `std::array`
    class)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several common member functions (some of them are missing from one or another
    container)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to the stored data with the help of iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following member types are defined by all standard containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The actual types these names are aliasing may differ from container to container.
    For instance, for `std::vector`, `value_type` is the template argument `T`, but
    for `std::map,` `value_type` is the `std::pair<const Key, T>` type. The purpose
    of these member types is to help with generic programming.
  prefs: []
  type: TYPE_NORMAL
- en: Except for the `std::array` class, which represents an array of a size known
    at compile time, all the other containers allocate memory dynamically. This is
    controlled with the help of an object called an `std::allocator` if none is specified.
    This standard allocator uses the global `new` and `delete` operators for allocating
    and releasing memory. All constructors of standard containers (including copy
    and move constructors) have overloads that allow us to specify an allocator.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also common member functions defined in the standard containers.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size`, which returns the number of elements (not present in `std::forward_list`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`empty`, which checks whether the container is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear`, which clears the content of the container (not present in `std::array`,
    `std::stack`, `std::queue`, and `std::priority_queue`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swap`, which swaps the content of the container objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`begin` and `end` methods, which return iterators to the beginning and end
    of the container (not present in `std::stack`, `std::queue`, and `std::priority_queue`,
    although these are not containers but container adaptors).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last bullet mentions iterators. These are types that abstract the details
    of accessing elements in a container, providing a uniform way to identify and
    traverse the elements of containers. This is important because a key part of the
    standard library is represented by general-purpose algorithms. There are over
    one hundred such algorithms, ranging from sequence operations (such as `count`,
    `count_if`, `find`, and `for_each`) to modifying operations (such as `copy`, `fill`,
    `transform`, `rotate`, and `reverse`) to partitioning and sorting (`partition`,
    `sort`, `nth_element`, and more) and others. Iterators are key for ensuring they
    work generically. If each container had different ways to access its elements,
    writing generic algorithms would be virtually impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the simple operation of copying elements from one container
    to another. For instance, we have a `std::vector` object and we want to copy its
    elements to a `std::list` object. This could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want to copy from a `std::list` to a `std::set`, or from a `std::set`
    to a `std::array`? Each case would require different kinds of code. However, general-purpose
    algorithms enable us to do this in a uniform way. The following snippet shows
    such an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have a `std::vector` object and we copy its content to another `std::vector`,
    but also to a `std::list` object. Consequently, the content of the `std::list`
    object is then copied to a `std::set` object. For all cases, the `std::copy` algorithm
    is used. This algorithm has several arguments: two iterators that define the beginning
    and end of the source, and an iterator that defines the beginning of the destination.
    The algorithm copies one element at a time from the input range to the element
    pointer by the output iterator and then increments the output iterator. Conceptually,
    it can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm was discussed in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*, when we looked at how its implementation
    can be optimized with the help of type traits.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the previous example, there are cases when the destination container
    does not have its content already allocated for the copying to take place. This
    is the case with copying to the list and to the set. In this case, iterator-like
    types, `std::back_insert_iterator` and `std:insert_iterator`, are used—indirectly
    through the `std::back_inserter` and `std::inserter` helper functions, for inserting
    elements into a container. The `std::back_insert_iterator` class uses the `push_back`
    function and `std::insert_iterator` uses the `insert` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six iterator categories in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: Input iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bidirectional iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random access iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contiguous iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The contiguous iterator category was added in C++17\. All operators can be
    incremented with the prefix or postfix increment operator. The following table
    shows the additional operations that each category defines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_8.01_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.1
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of the output category, each category includes everything
    about it. That means a forward iterator is an input iterator, a bidirectional
    iterator is a forward iterator, a random-access iterator is a bidirectional iterator,
    and, lastly, a contiguous iterator is a random-access iterator. However, iterators
    in any of the first five categories can also be output iterators at the same time.
    Such an iterator is called a **mutable** iterator. Otherwise, they are said to
    be **constant** iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++20 standard has added support for concepts and a concepts library. This
    library defines standard concepts for each of these iterator categories. The following
    table shows the correlation between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_8.02_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.2
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Iterator concepts were briefly discussed in [*Chapter 6*](B18367_06_ePub.xhtml#_idTextAnchor099),
    *Concepts and Constraints*.
  prefs: []
  type: TYPE_NORMAL
- en: 'All containers have the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`begin`: It returns an iterator to the beginning of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`: It returns an iterator to the end of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cbegin`: It returns a constant iterator to the beginning of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cend`: It returns a constant iterator to the end of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some containers also have members that return reverse iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rbegin`: It returns a reverse iterator to the beginning of the reversed container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rend`: It returns a reverse iterator to the end of the reversed container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rcbegin`: It returns a constant reverse iterator to the beginning of the reversed
    container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rcend`: It returns a constant reverse iterator to the end of the reversed
    container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "There are two things that must be well understood to be able to work with containers\
    \ \Land iterators:"
  prefs: []
  type: TYPE_NORMAL
- en: The end of a container is not the last element of the container but the one
    past the last.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversed iterators provide access to the elements in reverse order. A reversed
    iterator to the first element of a container is actually the last element of the
    non-reversed container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better understand these two points, let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first call to `std::copy` prints the elements of the container in their
    given order. On the other hand, the second call to `std::copy` prints the elements
    in their reversed order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the relationship between iterators and container
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1
  prefs: []
  type: TYPE_NORMAL
- en: A sequence of elements (regardless of what kind of data structure they are stored
    in memory) delimited by two iterators (a begin and an end, which is the one past
    the last element) is called a **range**. This term is used extensively in the
    C++ standard (especially with algorithms) and in literature. It is also the term
    that gave the name to the ranges library in C++20, which will be discussed in
    [*Chapter 9*](B18367_09_ePub.xhtml#_idTextAnchor188), *The Ranges Library*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the set of the begin/end member functions of the standard containers,
    there are also stand-alone functions with the same name. Their equivalence is
    presented in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_8.03_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.3
  prefs: []
  type: TYPE_NORMAL
- en: 'Although these free functions do not bring much benefit when working with standard
    containers, they help us in writing generic code that can handle both standard
    containers and C-like arrays, since all these free functions are overloaded for
    static arrays. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Without these functions, we would have to write `std::copy(a, a + 5, …)`. Perhaps
    a big benefit of these functions is that they enable us to use arrays with range-based
    for loops, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: It is not the purpose of this book to teach you how to use each container or
    the many standard algorithms. However, it should be helpful for you to learn how
    to create containers, iterators, and algorithms. This is what we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom container and iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to understand how containers and iterators work is to experience
    them first-hand by creating your own. To avoid implementing something that already
    exists in the standard library, we will consider something different – more precisely,
    a **circular buffer**. This is a container that, when full, overwrites existing
    elements. We can think of different ways such a container could work; therefore,
    it’s important that we first define the requirements for it. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The container should have a fixed capacity that is known at compile-time. Therefore,
    there would be no runtime memory management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The capacity is the number of elements the container can store, and the size
    is the number of elements it actually contains. When the size equals the capacity,
    we say the container is full.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the container is full, adding a new element will overwrite the oldest element
    in the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new elements is always done at the end; removing existing elements is
    always done at the beginning (the oldest element in the container).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be random access to the elements of the container, both with the
    subscript operator and with iterators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these requirements, we can think of the following implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: The elements could be stored in an array. For convenience, this could be the
    `std::array` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need two variables, which we call `head` and `tail`, to store the index of
    the first and last elements of the container. This is needed because due to the
    circular nature of the container, the beginning and the end shift over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third variable will store the number of elements in the container. This is
    useful because otherwise, we would not be able to differentiate whether the container
    is empty or has one element only from the values of the head and tail indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The implementation shown here is provided for teaching purposes only and is
    not intended as a production-ready solution. The experienced reader will find
    different aspects of the implementation that could be optimized. However, the
    purpose here is to learn how to write a container and not how to optimize the
    implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following diagram shows a visual representation of such a circular buffer,
    with a capacity of eight elements with different states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can see in this diagram is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure A**: This is an empty buffer. The capacity is 8, the size is 0, and
    the **head** and **tail** both point to index **0**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure B**: This buffer contains one element. The capacity is still 8, the
    size is 1, and the **head** and **tail** both still point to index **0**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure C**: This buffer contains two elements. The size is 2, the **head**
    contains index **0**, and the **tail** contains index **1**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure D**: This buffer is full. The size is 8, which is equal to the capacity,
    and the **head** contains index **0** and the **tail** contains index **7**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure E**: This buffer is still full, but an additional element has been
    added, triggering the overwriting of the oldest element in the buffer. The size
    is 8, the **head** contains index **1**, and the **tail** contains index **0**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have looked at the semantics of the circular buffer, we can start
    writing the implementation. We will begin with the container class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a circular buffer container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for the container class would be too long to be put in a single listing,
    so we’ll break it up into multiple snippets. The first is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things here: the forward declaration of a class template called
    `circular_buffer_iterator`, and a class template called `circular_buffer`. Both
    have the same template arguments, a type template parameter `T`, representing
    the type of the elements, and a non-type template parameter, representing the
    capacity of the buffer. A constraint is used to ensure that the provided value
    for capacity is always positive. If you are not using C++20, you can replace the
    constraint with a `static_assert` statement or `enable_if` to enforce the same
    restriction. The following snippets are all part of the `circular_buffer` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have a series of member type definitions that provide aliases to
    different types that are relevant to the `circular_buffer` class template. These
    will be used in the implementation of the class. They are shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we have the data members that store the buffer state. The actual elements
    are stored in a `std::array` object. The head, tail, and size are all stored in
    a variable of the `size_type` data type. These members are all private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, we have the member functions that implement the functionality described
    earlier. All the following members are public. The first to list here are the
    constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three constructors defined here (although we can think of additional
    ones). These are the default constructor (which is also defaulted) that initializes
    an empty buffer, a constructor from a C-like array of size `N`, which initializes
    a full buffer by copying the array elements, and, finally, a constructor that
    takes a single value and initializes a full buffer by copying that value into
    each element of the buffer. These constructors allow us to create circular buffers
    in any of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define several member functions that describe the state of the circular
    buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The `size` function returns the number of elements in the buffer, the `capacity`
    function the number of elements that the buffer can hold, the `empty` function
    to check whether the buffer has no elements (the same as `size() == 0`), and the
    `full` function to check whether the buffer is full (the same as `size() == N`).
    There is also a function called `clear` that puts the circular buffer in the empty
    state. Beware that this function doesn't destroy any element (does not release
    memory or call destructors) but only resets the values defining the state of the
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to access the elements of the buffer; therefore, the following functions
    are defined for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these members has a `const` overload that is called for constant instances
    of the buffer. The constant member returns a constant reference; the non-const
    member returns a normal reference. These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The subscript operator that returns a reference to the element specified by
    its index, without checking the value of the index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `at` method that works similarly to the subscript operator, except that
    it checks that the index is smaller than the size and, if not, throws an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `front` method that returns a reference to the first element; if the buffer
    is empty, it throws an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `back` method that returns a reference to the last element; if the buffer
    is empty, it throws an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have members to access the elements, but we need members for adding and
    removing elements to/from the buffer. Adding new elements always happens at the
    end, so we’ll call this `push_back`. Removing existing elements always happens
    at the beginning (the oldest element), so we’ll call this `pop_front`. Let’s look
    first at the former:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'This works based on the defined requirements and the visual representations
    from *Figure 8.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: If the buffer is empty, copy the value to the element pointed by the `tail_`
    index and increment the size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the buffer is neither empty nor full, do the same but also increment the
    value of the `tail_` index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the buffer is full, increment both the `head_` and the `tail_` and then copy
    the value to the element pointed by the `tail_` index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This function copies the `value` argument to a buffer element. However, this
    could be optimized for temporaries or objects that are no longer needed after
    pushing to the buffer. Therefore, an overload that takes an rvalue reference is
    provided. This moves the value to the buffer, avoiding an unnecessary copy. This
    overload is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar approach is used for implementing the `pop_back` function to remove
    elements from the buffer. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'This function throws an exception if the buffer is empty. Otherwise, it increments
    the value of the `head_` index and returns the value of the element from the previous
    position of the `head_`. This is described visually in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can see here is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure A**: The buffer has 3 elements (1, 2, and 3), **head** is at index
    **0**, and **tail** is at index **2**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure B**: An element has been removed from the front, which was index **0**.
    Therefore, **head** is now index **1** and **tail** is still index **2**. The
    buffer now has two elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure C**: The buffer has eight elements, which is its maximum capacity,
    and an element has been overwritten. The **head** is at index **1** and the **tail**
    is at index **0**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Figure D**: An element has been removed from the front, which was index **1**.
    The **head** is now at index **2** and the **tail** is still at index **0**. The
    buffer now has seven elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of using both the `push_back` and the `pop_front` member functions
    is shown in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the member functions `begin` and `end` that return iterators
    to the first and one-past-the-last elements of the buffer. Here is their implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: To understand these, we need to see how the iterator class is actually implemented.
    We will explore this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an iterator type for the circular buffer container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We declared the iterator class template at the beginning of the previous section
    when we started with the `circular_buffer` container. However, we need to define
    its implementation too. Yet, there is one more thing we must do: in order for
    the iterator class to be able to access the private members of the container it
    needs to be declared as a friend. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look now at the `circular_buffer_iterator` class, which actually has
    similarities with the container class. This includes the template parameters,
    the constraints, and the set of member types (some of them being common to those
    in `circular_buffer`). Here is a snippet of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'The `circular_buffer_iterator` class has a reference to a circular buffer and
    an index to the element in the buffer that it points to. The reference to `circular_buffer<T,
    N>` is wrapped inside a `std::reference_wrapper` object. The reason for this will
    be unveiled shortly. Such an iterator can be explicitly created by providing these
    two arguments. Therefore, the only constructor looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: If we now look back at the definitions of the `begin` and `end` member functions
    of `circular_buffer`, we can see that the first argument was `*this`, and the
    second was 0 for the begin iterator and `size_` for the end iterator. The second
    value is the offset from the head of the element pointed by the iterator. Therefore,
    0 is the first element, and `size_` is the one-past-the-last element in the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: We have decided that we need random access to the elements of the buffer; therefore,
    the iterator category is random-access. The member type `iterator_category` is
    an alias for `std::random_access_iterator_tag`. This implies that we need to provide
    all the operations supported for such an iterator. In the previous section of
    this chapter, we discussed the iterator categories and the required operations
    for each category. We will implement all the required ones next.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the requirements for an input iterator, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'We have implemented here incrementing (both pre- and post-fix), checking for
    equality/inequality, and dereferencing. The `*` and `->` operators throw an exception
    if the element cannot be dereferenced. The cases when this happens are when the
    buffer is empty, or the index is not within bounds (between `head_` and `tail_`).
    We used two helper functions (both private), called `compatible` and `is_bounds`.
    These are shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: A `a` and `b` are two forward iterators and they are equal, then either they
    are non-dereferenceable, otherwise, their iterator values, `*a` and `*b`, refer
    to the same object. The opposite is also true, meaning that if `*a` and `*b` are
    equal, then `a` and `b` are also equal. This is true for our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other requirement for forward iterators is that they are swappable. That
    means if `a` and `b` are two forward iterators, then `swap(a, b)` should be a
    valid operation. This leads us back to using a `std::reference_wrapper` object
    to hold a reference to a `circular_buffer<T, N>`. References are not swappable,
    which would have made `circular_buffer_iterator` not swappable either. However,
    `std::reference_wrapper` is swappable, and that also makes our iterator type swappable.
    That can be verified with a `static_assert` statement, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to using `std::reference_wrapper` is to use a raw pointer to
    a `circular_buffer` class, since pointers can be assigned values and are, therefore
    swappable. It is a matter of style and personal choice which one to use. In this
    example, I preferred the solution that avoided the raw pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For fulfilling the requirements for the bidirectional iterator category, we
    need to support decrementing. In the next snippet, you can see the implementation
    of both pre- and post-fix decrement operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the requirements of the `+` and `-`) and compound (`+=` and
    `-=`) operations. These are shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'Random-access iterators must support inequality comparison with other operations.
    That means, we need to overload the `<`, `<=`, `>`, and `>=` operators. However,
    the `<=`, `>`, and `>=` operators can be implemented based on the `<` operator.
    Therefore, their definition can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, but not least, we need to provide access to elements with the subscript
    operator (`[]`). A possible implementation is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have completed the implementation of the iterator type for the
    circular buffer. If you had trouble following the multitude of code snippets for
    these two classes, you can find the complete implementation in the GitHub repository
    for the book. A simple example for using the iterator type is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be actually simplified with range-based for loops. In this case,
    we don’t use iterators directly, but the compiler-generated code does. Therefore,
    the following snippet is equivalent to the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the implementation provided here for `circular_buffer_iterator` does
    not allow the following piece of code to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'This requires that we are able to write elements through iterators. However,
    our implementation doesn’t meet the requirements for the output iterator category.
    This requires that expressions such as `*it = v`, or `*it++ = v` are valid. To
    do so, we need to provide non-const overloads of the `*` and `->` operators that
    return non-const reference types. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: More examples for using the `circular_buffer` class with and without iterators
    can be found in the GitHub repository. Next, we will focus our attention on implementing
    a general-purpose algorithm that works for any range, including the `circular_buffer`
    container we defined here.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom general-purpose algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first section of this chapter, we saw why abstracting access to container
    elements with iterators is key for building general-purpose algorithms. However,
    it should be useful for you to practice writing such an algorithm because it can
    help you better understand the use of iterators. Therefore, in this section, we
    will write a general-purpose algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library features many such algorithms. One that is missing is
    a **zipping algorithm**. What zipping means is actually interpreted or understood
    differently by different people. For some, zipping means taking two or more input
    ranges and creating a new range with the elements from the input ranges intercalated.
    This is exemplified in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4
  prefs: []
  type: TYPE_NORMAL
- en: 'For others, zipping means taking two or more input ranges and creating a new
    range, with elements being tuples formed from the elements of the input ranges.
    This is shown in the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will implement the first algorithm. In order to avoid confusion,
    we will call this **flatzip**. Here are the requirements for it:'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm takes two input ranges and writes to an output range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The algorithm takes iterators as arguments. A pair of first and last input iterators
    define the bounds of each input range. An output iterator defines the beginning
    of the output range where the elements will be written to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two input ranges should contain elements of the same type. The output range
    must have elements of the same type or a type to which the input type is implicitly
    convertible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the two input ranges are of different sizes, the algorithm stops when the
    smallest of the two has been processed (as shown in the previous diagrams).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value is the output iterator to the one-past-the-last element that
    was copied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A possible implementation for the described algorithm is shown in the following
    listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the snippet, the implementation is quite simple. All we do
    here is iterate through both input ranges at the same time and copy elements alternately
    from them to the destination range. The iteration on both input ranges stops when
    the end of the smallest range is reached. We can use this algorithm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'These examples use `std::vector` for both the input and output ranges. However,
    the `flatzip` algorithm knows nothing about containers. The elements of the container
    are accessed with the help of iterators. Therefore, as long as the iterators meet
    the specified requirements, we can use any container. This includes the `circular_buffer`
    container we previously wrote since `circular_buffer_container` meets the requirements
    for both the input and output iterator categories. This means we can also write
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two input circular buffers: `a`, which has four elements, and `b`,
    which has three elements. The destination circular buffer has a capacity of eight
    elements, all initialized with zero. After applying the flatzip algorithm, six
    elements of the destination circular buffer will be written with values from the
    `a` and `b` buffers. The result is that the circular buffer will contain the elements
    `1, 5, 2, 6, 3, 7, 0, 0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was dedicated to seeing how templates can be used to build general-purpose
    libraries. Although we couldn’t cover these topics in great detail, we have explored
    the design of containers, iterators, and algorithms from the C++ standard library.
    These are the pillars of the standard library. We spent most of the chapter understanding
    what it takes to write a container similar to the standard ones as well as an
    iterator class to provide access to its elements. For this purpose, we implemented
    a class that represents a circular buffer, a data structure of fixed size where
    elements are overwritten once the container is full. Lastly, we implemented a
    general-purpose algorithm that zips elements from two ranges. This works for any
    container including the circular buffer container.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges, as discussed in this chapter, are an abstract concept. However, that
    changed with C++20, which introduced a more concrete concept of ranges with the
    new ranges library. This is what we will discuss in the final chapter of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the sequence containers from the standard library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the common member functions defined in the standard containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are iterators and how many categories exist?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What operations does a random-access iterator support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are range access functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
