<html><head></head><body>
  <div id="_idContainer051">
   <h1 class="chapter-number" id="_idParaDest-165">
    <a id="_idTextAnchor164">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     8
    </span>
   </h1>
   <h1 id="_idParaDest-166">
    <a id="_idTextAnchor165">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Asynchronous Programming Using Coroutines
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In previous chapters, we saw different methods of writing asynchronous code in C++.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     We used threads, the basic units of execution, and some higher-level asynchronous code mechanisms, such as futures and promises and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.4.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.5.1">
     .
    </span>
    <span class="koboSpan" id="kobo.5.2">
     We will look at the Boost.Asio library in the next chapter.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     All these methods often use several system threads, created and managed by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      the kernel.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     For example, the main thread of our program may need to access a database.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     This access may be slow, so we read the data in a different thread so our main thread can go on doing some other tasks.
    </span>
    <span class="koboSpan" id="kobo.7.3">
     Another example is the producer-consumer model, where one or more threads generate data items to be processed, and one or more threads process those items in a fully
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      asynchronous way.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     Both of the preceding examples use threads, also called system (kernel) threads, and require different units of execution, one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      per thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.11.1">
     In this chapter, we are going to study a different way to write asynchronous code – coroutines.
    </span>
    <span class="koboSpan" id="kobo.11.2">
     Coroutines are an old concept from the late 1950s that was added to C++ only recently, since C++20.
    </span>
    <span class="koboSpan" id="kobo.11.3">
     They don’t need a separate thread (of course, we can have different threads running coroutines).
    </span>
    <span class="koboSpan" id="kobo.11.4">
     Coroutines are a mechanism that allows us, among other things, to perform multiple tasks in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      single thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.13.1">
     In this chapter, we will cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.14.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      What are coroutines and how are they implemented and supported
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       by C++?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      Implementing basic coroutines to see what the requirements of a C++
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       coroutine are
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      Generator coroutines and the new
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       C++23
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.21.1">
        std::generator
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.22.1">
      A string parser to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       parse integers
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.24.1">
      Exceptions
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       in coroutines
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     This chapter is about C++ coroutines implemented without using any third-party libraries.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     This way of writing coroutines is quite low level and we need to write code to support
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      the compiler.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-167">
    <a id="_idTextAnchor166">
    </a>
    <span class="koboSpan" id="kobo.28.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     For this chapter, you will need a C++20 compiler.
    </span>
    <span class="koboSpan" id="kobo.29.2">
     For the generator examples, you will need a C++23 compiler.
    </span>
    <span class="koboSpan" id="kobo.29.3">
     We have tested the examples with GCC
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.30.1">
      14.1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.31.1">
     .
    </span>
    <span class="koboSpan" id="kobo.31.2">
     The code is platform-independent, so even though we have a Linux focus in this book, all the examples should work on macOS and Windows.
    </span>
    <span class="koboSpan" id="kobo.31.3">
     Please note that Visual Studio
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.32.1">
      17.11
     </span>
    </strong>
    <span class="koboSpan" id="kobo.33.1">
     doesn’t support the C++23
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.34.1">
       std::generator
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      yet.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     The code for this chapter can be found in the book’s GitHub
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      repository:
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.38.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-168">
    <a id="_idTextAnchor167">
    </a>
    <span class="koboSpan" id="kobo.40.1">
     Coroutines
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     Before we start implementing coroutines in C++, we will introduce coroutines conceptually and see how they can be useful in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      our programs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     Let’s start with a definition.
    </span>
    <span class="koboSpan" id="kobo.43.2">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.44.1">
      coroutine
     </span>
    </strong>
    <span class="koboSpan" id="kobo.45.1">
     is a function that can suspend itself.
    </span>
    <span class="koboSpan" id="kobo.45.2">
     Coroutines suspend themselves
    </span>
    <a id="_idIndexMarker552">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     while waiting for an input value (while they are suspended, they don’t execute) or after yielding a value such as the result of a computation.
    </span>
    <span class="koboSpan" id="kobo.46.2">
     Once the input value is available or the caller requests another value, the coroutine resumes execution.
    </span>
    <span class="koboSpan" id="kobo.46.3">
     We will come back to coroutines in C++ soon, but let’s see with a real-life example how a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.47.1">
      coroutine works.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     Imagine someone working as an assistant.
    </span>
    <span class="koboSpan" id="kobo.48.2">
     They start the day
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.49.1">
      reading emails.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.50.1">
     One of the emails is a request for a report.
    </span>
    <span class="koboSpan" id="kobo.50.2">
     After reading the email, they start writing the requested document.
    </span>
    <span class="koboSpan" id="kobo.50.3">
     Once they have written the introductory paragraphs, they notice that they need another report from a colleague to get some accounting results from the previous quarter.
    </span>
    <span class="koboSpan" id="kobo.50.4">
     They stop writing the report, write an email to their colleague requesting the needed information, and read the next email, which is a request to book a room for an important meeting in the afternoon.
    </span>
    <span class="koboSpan" id="kobo.50.5">
     They open a special application the company has developed for booking meeting rooms automatically to optimize their use and book
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.51.1">
      the room.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     After a while, they receive the required accounting data from their colleague and resume writing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.53.1">
      the report.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     The assistant is always busy working on their tasks.
    </span>
    <span class="koboSpan" id="kobo.54.2">
     Writing the report is a good example of a coroutine: they start writing the report, then suspend the writing while they wait for the required information, and once the information arrives, they resume their writing.
    </span>
    <span class="koboSpan" id="kobo.54.3">
     Of course, the assistant doesn’t want to waste their time, and while they wait, they go on doing other tasks.
    </span>
    <span class="koboSpan" id="kobo.54.4">
     Their colleague can be seen as another coroutine if they wait for requests and then send the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.55.1">
      appropriate response.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.56.1">
     Now let’s go back to software.
    </span>
    <span class="koboSpan" id="kobo.56.2">
     Let’s assume that we need to write a function that stores data in a database after processing some
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      input information.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     If the data comes all at once, we can implement just a function.
    </span>
    <span class="koboSpan" id="kobo.58.2">
     The function will read the input, perform the required processing on it, and finally, write the result to a database.
    </span>
    <span class="koboSpan" id="kobo.58.3">
     But what if the data to be processed arrives in blocks and processing each block requires the result from the previous block processing (we can assume for the sake of this example that the first block processing needs only some
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.59.1">
      default value)?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.60.1">
     A possible solution to our
    </span>
    <a id="_idIndexMarker553">
    </a>
    <span class="koboSpan" id="kobo.61.1">
     problem would be to make the function wait for each data block, process it, store the result in the database, and then wait for the next one, and so on.
    </span>
    <span class="koboSpan" id="kobo.61.2">
     But if we do that, we could potentially waste a lot of time while waiting for each block of data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.62.1">
      to arrive.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.63.1">
     After reading the previous chapters, you may be thinking about different potential solutions: we could create a thread to read the data, copy the blocks to a queue, and a second thread (maybe the main thread) will process the data.
    </span>
    <span class="koboSpan" id="kobo.63.2">
     This is an acceptable solution but using multiple threads may
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.64.1">
      be overkill.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     Another solution could be implementing a function to process only one block.
    </span>
    <span class="koboSpan" id="kobo.65.2">
     The caller will wait for the input to be passed to the function and will keep the result of the previous block processing required to process each data block.
    </span>
    <span class="koboSpan" id="kobo.65.3">
     In this solution, we must keep the state required by the data processing function in another function.
    </span>
    <span class="koboSpan" id="kobo.65.4">
     It may be acceptable for a simple example, but once the processing gets more complicated (for example, requiring several steps with different intermediate results to be kept), the code might be difficult to understand
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.66.1">
      and maintain.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.67.1">
     We can solve the problem with a coroutine.
    </span>
    <span class="koboSpan" id="kobo.67.2">
     Let’s see some possible pseudocode for a coroutine that processes data in blocks and keeps
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.68.1">
      intermediate results:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.69.1">
processing_result process_data(data_block data) {
    while (do_processing == true) {
        result_type result{ 0 };
        result = process_data_block(previous_result);
        update_database();
        yield result;
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.70.1">
     The preceding coroutine receives a data block from the caller, performs all the processing, updates a database, and keeps the result required to process the next block.
    </span>
    <span class="koboSpan" id="kobo.70.2">
     After yielding the result to the caller (more on yielding later), it suspends itself.
    </span>
    <span class="koboSpan" id="kobo.70.3">
     Its execution will resume when the coroutine is called again by the caller requesting the processing of a new
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.71.1">
      data block.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.72.1">
     A
    </span>
    <a id="_idIndexMarker554">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     coroutine such as this simplifies state management because it can keep the state
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.74.1">
      between calls.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.75.1">
     After this conceptual introduction to coroutines, we are going to start implementing them
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      in C++20.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-169">
    <a id="_idTextAnchor168">
    </a>
    <span class="koboSpan" id="kobo.77.1">
     C++ coroutines
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.78.1">
     As we have seen, coroutines are just functions, but they are not like the functions we are used to.
    </span>
    <span class="koboSpan" id="kobo.78.2">
     They have special properties that we will study in this chapter.
    </span>
    <span class="koboSpan" id="kobo.78.3">
     In this section, we will focus on coroutines
    </span>
    <a id="_idIndexMarker555">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.79.1">
      in C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.80.1">
     A function starts executing when it’s called and normally terminates with a return sentence or just when the function’s end
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.81.1">
      is reached.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.82.1">
     A function runs from beginning to end.
    </span>
    <span class="koboSpan" id="kobo.82.2">
     It may call another function (or even itself if it is recursive), and it may throw exceptions or have different return points.
    </span>
    <span class="koboSpan" id="kobo.82.3">
     But it always runs from beginning
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.83.1">
      to end.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.84.1">
     A coroutine is different.
    </span>
    <span class="koboSpan" id="kobo.84.2">
     A coroutine is a function that can suspend itself.
    </span>
    <span class="koboSpan" id="kobo.84.3">
     The flow for a coroutine may be like the
    </span>
    <a id="_idIndexMarker556">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.85.1">
      following pseudocode:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.86.1">
 void coroutine() {
    do_something();
    co_yield;
    do_something_else();
    co_yield;
    do_more_work();
    co_return;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.87.1">
     We will see what those terms with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.88.1">
      co_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.89.1">
     prefix
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.90.1">
      mean soon.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.91.1">
     For a coroutine, we need a mechanism to keep the execution state to be able to suspend/resume the coroutine.
    </span>
    <span class="koboSpan" id="kobo.91.2">
     This is done for us by the compiler, but we must write some
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.92.1">
      helping
     </span>
    </em>
    <span class="koboSpan" id="kobo.93.1">
     code to let the compiler help
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.94.1">
      us back.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.95.1">
     Coroutines in C++
    </span>
    <a id="_idIndexMarker557">
    </a>
    <span class="koboSpan" id="kobo.96.1">
     are stackless.
    </span>
    <span class="koboSpan" id="kobo.96.2">
     This means that the state we need to store to be able to suspend/resume the coroutine is stored in the heap calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.97.1">
      new
     </span>
    </strong>
    <span class="koboSpan" id="kobo.98.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.99.1">
      delete
     </span>
    </strong>
    <span class="koboSpan" id="kobo.100.1">
     to allocate/free dynamic memory.
    </span>
    <span class="koboSpan" id="kobo.100.2">
     These calls are created by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.101.1">
      the compiler.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-170">
    <a id="_idTextAnchor169">
    </a>
    <span class="koboSpan" id="kobo.102.1">
     New keywords
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.103.1">
     Because a coroutine is essentially
    </span>
    <a id="_idIndexMarker558">
    </a>
    <span class="koboSpan" id="kobo.104.1">
     a function (with some special properties, but a function nonetheless), the compiler needs some way to know whether a given function is a coroutine.
    </span>
    <span class="koboSpan" id="kobo.104.2">
     C++20 introduced three new keywords:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.105.1">
      co_yield
     </span>
    </strong>
    <span class="koboSpan" id="kobo.106.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.107.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.108.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.109.1">
      co_return
     </span>
    </strong>
    <span class="koboSpan" id="kobo.110.1">
     .
    </span>
    <span class="koboSpan" id="kobo.110.2">
     If a function uses at least one of those three keywords, then the compiler knows it is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.111.1">
      a coroutine.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.112.1">
     The following table summarizes the functionality of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.113.1">
      new keywords:
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-3">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.114.1">
           Keyword
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.115.1">
           Input/Output
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.116.1">
           Coroutine State
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.117.1">
           co_yield
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.118.1">
          Output
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.119.1">
          Suspended
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.120.1">
           co_await
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.121.1">
          Input
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.122.1">
          Suspended
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.123.1">
           co_return
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.124.1">
          Output
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.125.1">
          Terminated
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.126.1">
     Table 8.1: New coroutine keywords
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.127.1">
     In the preceding table, we see that after
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.128.1">
      co_yield
     </span>
    </strong>
    <span class="koboSpan" id="kobo.129.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.130.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.131.1">
     , the coroutine suspends itself, and after
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.132.1">
      co_return
     </span>
    </strong>
    <span class="koboSpan" id="kobo.133.1">
     , it is terminated (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.134.1">
      co_return
     </span>
    </strong>
    <span class="koboSpan" id="kobo.135.1">
     is the equivalent of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.136.1">
      return
     </span>
    </strong>
    <span class="koboSpan" id="kobo.137.1">
     statement in a C++ function).
    </span>
    <span class="koboSpan" id="kobo.137.2">
     A coroutine cannot have a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.138.1">
      return
     </span>
    </strong>
    <span class="koboSpan" id="kobo.139.1">
     statement; it must always use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.140.1">
      co_return
     </span>
    </strong>
    <span class="koboSpan" id="kobo.141.1">
     .
    </span>
    <span class="koboSpan" id="kobo.141.2">
     If the coroutine doesn’t return any value and any of the other two
    </span>
    <a id="_idIndexMarker559">
    </a>
    <span class="koboSpan" id="kobo.142.1">
     coroutine keywords are used, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.143.1">
      co_return
     </span>
    </strong>
    <span class="koboSpan" id="kobo.144.1">
     statement can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.145.1">
      be omitted.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-171">
    <a id="_idTextAnchor170">
    </a>
    <span class="koboSpan" id="kobo.146.1">
     Coroutines restrictions
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.147.1">
     We have said that coroutines are functions using the new coroutines keywords.
    </span>
    <span class="koboSpan" id="kobo.147.2">
     But coroutines have the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.148.1">
      following
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker560">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.149.1">
      restrictions:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.150.1">
      Functions with a variable number of arguments using
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.151.1">
       varargs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.152.1">
      can’t be coroutines (a variadic function template can be
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.153.1">
       a coroutine)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.154.1">
      A class constructor or destructor cannot be
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.155.1">
       a coroutine
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.156.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.157.1">
       constexpr
      </span>
     </strong>
     <span class="koboSpan" id="kobo.158.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.159.1">
       consteval
      </span>
     </strong>
     <span class="koboSpan" id="kobo.160.1">
      functions cannot
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.161.1">
       be coroutines
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.162.1">
      A function returning
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.163.1">
       auto
      </span>
     </strong>
     <span class="koboSpan" id="kobo.164.1">
      cannot be a coroutine but
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.165.1">
       auto
      </span>
     </strong>
     <span class="koboSpan" id="kobo.166.1">
      with a trailing return type
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.167.1">
       can be
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.168.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.169.1">
       main()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.170.1">
      function cannot be
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.171.1">
       a coroutine
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.172.1">
      Lambdas can
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.173.1">
       be coroutines
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.174.1">
     After studying the restrictions of coroutines (basically what kind of C++ functions cannot be coroutines), we are going to start implementing coroutines in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.175.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-172">
    <a id="_idTextAnchor171">
    </a>
    <span class="koboSpan" id="kobo.176.1">
     Implementing basic coroutines
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.177.1">
     In the previous section, we studied the basics of coroutines, what they are, and some
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.178.1">
      use cases.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.179.1">
     In this section, we will implement three simple
    </span>
    <a id="_idIndexMarker561">
    </a>
    <span class="koboSpan" id="kobo.180.1">
     coroutines to illustrate the basics of implementing and working
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.181.1">
      with them:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.182.1">
      The simplest coroutine that
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.183.1">
       just returns
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.184.1">
      A coroutine sending values back to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.185.1">
       the caller
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.186.1">
      A coroutine getting values from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.187.1">
       the caller
      </span>
     </span>
    </li>
   </ul>
   <h2 id="_idParaDest-173">
    <a id="_idTextAnchor172">
    </a>
    <span class="koboSpan" id="kobo.188.1">
     The simplest coroutine
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.189.1">
     We know that a
    </span>
    <a id="_idIndexMarker562">
    </a>
    <span class="koboSpan" id="kobo.190.1">
     coroutine is
    </span>
    <a id="_idIndexMarker563">
    </a>
    <span class="koboSpan" id="kobo.191.1">
     a function that can suspend itself and can be resumed by the caller.
    </span>
    <span class="koboSpan" id="kobo.191.2">
     We also know that the compiler identifies a function as a coroutine if it uses at least one
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.192.1">
      co_yield
     </span>
    </strong>
    <span class="koboSpan" id="kobo.193.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.194.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.195.1">
     , or
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.196.1">
       co_return
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.197.1">
      expression.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.198.1">
     The compiler will transform the coroutine source code and create some data structures and functions to make the coroutine functional and capable of being suspended and resumed.
    </span>
    <span class="koboSpan" id="kobo.198.2">
     This is required to keep the coroutine state and be able to communicate with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.199.1">
      the coroutine.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.200.1">
     The compiler will take care of all those details but bear in mind that C++ support for coroutines is quite low level.
    </span>
    <span class="koboSpan" id="kobo.200.2">
     There are
    </span>
    <a id="_idIndexMarker564">
    </a>
    <span class="koboSpan" id="kobo.201.1">
     some libraries to make our lives easier when working with
    </span>
    <a id="_idIndexMarker565">
    </a>
    <span class="koboSpan" id="kobo.202.1">
     coroutines in C++.
    </span>
    <span class="koboSpan" id="kobo.202.2">
     Some of them are
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.203.1">
      Lewis Baker’s cppcoro
     </span>
    </strong>
    <span class="koboSpan" id="kobo.204.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.205.1">
      Boost.Cobalt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.206.1">
     .
    </span>
    <span class="koboSpan" id="kobo.206.2">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.207.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.208.1">
     library
    </span>
    <a id="_idIndexMarker566">
    </a>
    <span class="koboSpan" id="kobo.209.1">
     has support for coroutines too.
    </span>
    <span class="koboSpan" id="kobo.209.2">
     These libraries are the subject of the next
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.210.1">
      two chapters.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.211.1">
     Let’s start from scratch.
    </span>
    <span class="koboSpan" id="kobo.211.2">
     And we mean by absolute scratch.
    </span>
    <span class="koboSpan" id="kobo.211.3">
     We will write some code and be guided by both compiler errors and the C++ reference to write a basic but fully
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      functional coroutine.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.213.1">
     The following code is the simplest implementation of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.214.1">
      a coroutine:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.215.1">
void coro_func() {
    co_return;
}
int main() {
    coro_func();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.216.1">
     Simple, isn’t it?
    </span>
    <span class="koboSpan" id="kobo.216.2">
     Our
    </span>
    <a id="_idIndexMarker567">
    </a>
    <span class="koboSpan" id="kobo.217.1">
     first coroutine will just return nothing.
    </span>
    <span class="koboSpan" id="kobo.217.2">
     It will not do anything else.
    </span>
    <span class="koboSpan" id="kobo.217.3">
     Sadly, the preceding code is too simple for a functional coroutine and will not compile.
    </span>
    <span class="koboSpan" id="kobo.217.4">
     When compiling with GCC
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.218.1">
      14.1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.219.1">
     , we get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.220.1">
      following error:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.221.1">
error: coroutines require a traits template; cannot find 'std::coroutine_traits'</span></pre>
   <p>
    <span class="koboSpan" id="kobo.222.1">
     We also get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.223.1">
      following note:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.224.1">
note: perhaps '#include &lt;coroutine&gt;' is missing</span></pre>
   <p>
    <span class="koboSpan" id="kobo.225.1">
     The compiler is giving us a hint: we
    </span>
    <a id="_idIndexMarker568">
    </a>
    <span class="koboSpan" id="kobo.226.1">
     may have missed including a required file.
    </span>
    <span class="koboSpan" id="kobo.226.2">
     Let’s include the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.227.1">
      &lt;coroutine&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.228.1">
     header file.
    </span>
    <span class="koboSpan" id="kobo.228.2">
     We’ll deal with the error about the traits template in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.229.1">
      a minute:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.230.1">
#include &lt;coroutine&gt;
void coro_func() {
    co_return;
}
int main() {
    coro_func();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.231.1">
     When compiling the preceding code, we get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.232.1">
      following error:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.233.1">
 error: unable to find the promise type for this coroutine</span></pre>
   <p>
    <span class="koboSpan" id="kobo.234.1">
     The first version of our coroutine gave us a compiler error saying that the type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.235.1">
      std::coroutine_traits
     </span>
    </strong>
    <span class="koboSpan" id="kobo.236.1">
     template couldn’t be found.
    </span>
    <span class="koboSpan" id="kobo.236.2">
     Now we get an error related to something called
    </span>
    <a id="_idIndexMarker569">
    </a>
    <span class="koboSpan" id="kobo.237.1">
     the
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.238.1">
       promise type
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.239.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.240.1">
     Looking at the C++ reference, we see that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.241.1">
      std::coroutine_traits
     </span>
    </strong>
    <span class="koboSpan" id="kobo.242.1">
     template determines the return type and parameter types of a coroutine.
    </span>
    <span class="koboSpan" id="kobo.242.2">
     The reference also states that the return type of a coroutine must define a type named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.243.1">
      promise_type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.244.1">
     .
    </span>
    <span class="koboSpan" id="kobo.244.2">
     Following the reference advice, we can write a new version of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.245.1">
      our coroutine:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.246.1">
#include &lt;coroutine&gt;
struct return_type {
    struct promise_type {
    };
};
template&lt;&gt;
struct std::coroutine_traits&lt;return_type&gt; {
    using promise_type = return_type::promise_type;
};
return_type coro_func() {
    co_return;
}
int main() {
    coro_func();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.247.1">
     Please note that the
    </span>
    <a id="_idIndexMarker570">
    </a>
    <span class="koboSpan" id="kobo.248.1">
     return type
    </span>
    <a id="_idIndexMarker571">
    </a>
    <span class="koboSpan" id="kobo.249.1">
     of a coroutine can have any name (we have called it
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.250.1">
      return_type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.251.1">
     here because is convenient for this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      simple example).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.253.1">
     Compiling the preceding code again gives us some errors (they are edited for clarity).
    </span>
    <span class="koboSpan" id="kobo.253.2">
     All the errors are about missing functions in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.254.1">
       promise_type
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.255.1">
      structure:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.256.1">
error: no member named 'return_void' in 'std::__n4861::coroutine_traits&lt;return_type&gt;::promise_type'
error: no member named 'initial_suspend' in 'std::__n4861::coroutine_traits&lt;return_type&gt;::promise_type'
error: no member named 'unhandled_exception' in 'std::__n4861::coroutine_traits&lt;return_type&gt;::promise_type'
error: no member named 'final_suspend' in 'std::__n4861::coroutine_traits&lt;return_type&gt;::promise_type'
error: no member named 'get_return_object' in 'std::__n4861::coroutine_traits&lt;return_type&gt;::promise_type'</span></pre>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     All the
    </span>
    <a id="_idIndexMarker572">
    </a>
    <span class="koboSpan" id="kobo.258.1">
     compiler errors we have seen until now are related to missing features in our code.
    </span>
    <span class="koboSpan" id="kobo.258.2">
     Writing coroutines in C++ requires following some rules and helping the compiler to make its generated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.259.1">
      code functional.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.260.1">
     The following is the final
    </span>
    <a id="_idIndexMarker573">
    </a>
    <span class="koboSpan" id="kobo.261.1">
     version of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.262.1">
      simplest coroutine:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.263.1">
#include &lt;coroutine&gt;
struct return_type {
    struct promise_type {
        return_type get_return_object() noexcept {
            return return_type{ *this };
        }
        void return_void() noexcept {}
        std::suspend_always initial_suspend() noexcept {
            return {};
        }
        std::suspend_always final_suspend() noexcept {
            return {};
        }
        void unhandled_exception() noexcept {}
    };
    explicit return_type(promise_type&amp;) {
    }
    ~return_type() noexcept {
    }
};
return_type coro_func() {
    co_return;
}
int main() {
    coro_func();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.264.1">
     You may have noticed that we have removed the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.265.1">
      std::coroutine_traits
     </span>
    </strong>
    <span class="koboSpan" id="kobo.266.1">
     template.
    </span>
    <span class="koboSpan" id="kobo.266.2">
     Implementing the return and promise types
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.267.1">
      is enough.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.268.1">
     The
    </span>
    <a id="_idIndexMarker574">
    </a>
    <span class="koboSpan" id="kobo.269.1">
     preceding
    </span>
    <a id="_idIndexMarker575">
    </a>
    <span class="koboSpan" id="kobo.270.1">
     code compiles without any errors and you can run it.
    </span>
    <span class="koboSpan" id="kobo.270.2">
     It does… nothing!
    </span>
    <span class="koboSpan" id="kobo.270.3">
     But it’s our first coroutine and we have learned that we need to supply some code required by the compiler to create
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.271.1">
      the coroutine.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.272.1">
     The promise type
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.273.1">
     The
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.274.1">
      promise type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.275.1">
     is
    </span>
    <a id="_idIndexMarker576">
    </a>
    <span class="koboSpan" id="kobo.276.1">
     required
    </span>
    <a id="_idIndexMarker577">
    </a>
    <span class="koboSpan" id="kobo.277.1">
     by the compiler.
    </span>
    <span class="koboSpan" id="kobo.277.2">
     We need to always have this type defined (it can be either a class or a struct), it must be named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.278.1">
      promise_type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.279.1">
     , and it must implement some functions specified in the C++ reference.
    </span>
    <span class="koboSpan" id="kobo.279.2">
     We have seen that if we don’t do that, the compiler will complain and give
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.280.1">
      us errors.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.281.1">
     The promise
    </span>
    <a id="_idIndexMarker578">
    </a>
    <span class="koboSpan" id="kobo.282.1">
     type must be defined inside the type returned by the
    </span>
    <a id="_idIndexMarker579">
    </a>
    <span class="koboSpan" id="kobo.283.1">
     coroutine, otherwise the code will not compile.
    </span>
    <span class="koboSpan" id="kobo.283.2">
     The
    </span>
    <a id="_idIndexMarker580">
    </a>
    <span class="koboSpan" id="kobo.284.1">
     returned type (sometimes also called the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.285.1">
      wrapper type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.286.1">
     because it wraps
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.287.1">
      promise_type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.288.1">
     ) can be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.289.1">
      named arbitrarily.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-174">
    <a id="_idTextAnchor173">
    </a>
    <span class="koboSpan" id="kobo.290.1">
     A yielding coroutine
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.291.1">
     A do-nothing coroutine is
    </span>
    <a id="_idIndexMarker581">
    </a>
    <span class="koboSpan" id="kobo.292.1">
     good for illustrating some basic concepts.
    </span>
    <span class="koboSpan" id="kobo.292.2">
     We will now
    </span>
    <a id="_idIndexMarker582">
    </a>
    <span class="koboSpan" id="kobo.293.1">
     implement another coroutine that can send data back to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.294.1">
      the caller.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.295.1">
     In this second example, we will implement a coroutine that produces a message.
    </span>
    <span class="koboSpan" id="kobo.295.2">
     It will be the “hello world” of coroutines.
    </span>
    <span class="koboSpan" id="kobo.295.3">
     The coroutine will say hello and the caller function will print the message received from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.296.1">
      the coroutine.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.297.1">
     To implement that functionality, we need to establish a communication channel from the coroutine to the caller.
    </span>
    <span class="koboSpan" id="kobo.297.2">
     This channel is the mechanism that allows the coroutine to pass values to the caller and receive information from it.
    </span>
    <span class="koboSpan" id="kobo.297.3">
     This channel is established through the coroutine’s
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.298.1">
      promise type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.299.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.300.1">
      handle
     </span>
    </strong>
    <span class="koboSpan" id="kobo.301.1">
     , which manages the state of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.302.1">
      the coroutine.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.303.1">
     The communication channel works in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.304.1">
      following way:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.305.1">
       Coroutine frame
      </span>
     </strong>
     <span class="koboSpan" id="kobo.306.1">
      : When a coroutine is called, it creates
     </span>
     <a id="_idIndexMarker583">
     </a>
     <span class="koboSpan" id="kobo.307.1">
      a
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.308.1">
       coroutine frame
      </span>
     </strong>
     <span class="koboSpan" id="kobo.309.1">
      , which contains all the state information needed to suspend and resume its execution.
     </span>
     <span class="koboSpan" id="kobo.309.2">
      This includes local variables, the promise type, and any
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.310.1">
       internal state.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.311.1">
       Promise type
      </span>
     </strong>
     <span class="koboSpan" id="kobo.312.1">
      : Each coroutine has an
     </span>
     <a id="_idIndexMarker584">
     </a>
     <span class="koboSpan" id="kobo.313.1">
      associated
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.314.1">
       promise type
      </span>
     </strong>
     <span class="koboSpan" id="kobo.315.1">
      , which is responsible for managing the coroutine’s interaction with the caller functions.
     </span>
     <span class="koboSpan" id="kobo.315.2">
      The promise is where the coroutine’s return value is stored, and it provides functions to control the coroutine’s behavior.
     </span>
     <span class="koboSpan" id="kobo.315.3">
      We are going to see these functions in this chapter’s examples.
     </span>
     <span class="koboSpan" id="kobo.315.4">
      The promise is the interface through which the caller interacts with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.316.1">
       the coroutine.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.317.1">
       Coroutine handle
      </span>
     </strong>
     <span class="koboSpan" id="kobo.318.1">
      : The
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.319.1">
       coroutine handle
      </span>
     </strong>
     <span class="koboSpan" id="kobo.320.1">
      is a type that gives access to the coroutine frame (the coroutine’s internal state) and allows the caller to resume or destroy the
     </span>
     <a id="_idIndexMarker585">
     </a>
     <span class="koboSpan" id="kobo.321.1">
      coroutine.
     </span>
     <span class="koboSpan" id="kobo.321.2">
      The handle is what the caller can use to resume the coroutine after it has been suspended (for example, after
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.322.1">
       co_await
      </span>
     </strong>
     <span class="koboSpan" id="kobo.323.1">
      or
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.324.1">
       co_yield
      </span>
     </strong>
     <span class="koboSpan" id="kobo.325.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.325.2">
      The handle can also be used to check whether the coroutine is done or to clean up
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.326.1">
       its resources.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.327.1">
       Suspend and resume mechanism
      </span>
     </strong>
     <span class="koboSpan" id="kobo.328.1">
      : When a coroutine yields a value (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.329.1">
       co_yield
      </span>
     </strong>
     <span class="koboSpan" id="kobo.330.1">
      ) or awaits an asynchronous operation (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.331.1">
       co_await
      </span>
     </strong>
     <span class="koboSpan" id="kobo.332.1">
      ), it suspends its execution, saving its state in the
     </span>
     <a id="_idIndexMarker586">
     </a>
     <span class="koboSpan" id="kobo.333.1">
      coroutine frame.
     </span>
     <span class="koboSpan" id="kobo.333.2">
      The caller can then resume the coroutine at a later point, retrieving the yielded or awaited value through the coroutine handle and continuing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.334.1">
       the execution.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.335.1">
     We are going to see, in the following examples, that this communication channel requires a considerable amount of code on our side to help the compiler generate all the code required for a coroutine to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.336.1">
      be functional.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.337.1">
     The following
    </span>
    <a id="_idIndexMarker587">
    </a>
    <span class="koboSpan" id="kobo.338.1">
     code is the new version of both the caller function and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.339.1">
      the
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker588">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.340.1">
      coroutine:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.341.1">
return_type coro_func() {
    co_yield "Hello from the coroutine\n"s;
    co_return;
}
int main() {
    auto rt = coro_func();
    std::cout &lt;&lt; rt.get() &lt;&lt; std::endl;
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.342.1">
     The
    </span>
    <a id="_idIndexMarker589">
    </a>
    <span class="koboSpan" id="kobo.343.1">
     changes are
    </span>
    <a id="_idIndexMarker590">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.344.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.345.1">
       [1]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.346.1">
      : The coroutine
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.347.1">
       yields
      </span>
     </em>
     <span class="koboSpan" id="kobo.348.1">
      and sends some data (in this case, a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.349.1">
       std::string
      </span>
     </strong>
     <span class="koboSpan" id="kobo.350.1">
      object) to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.351.1">
       the caller
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.352.1">
       [2]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.353.1">
      : The caller reads that data and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.354.1">
       prints it
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.355.1">
     The required communication mechanism is implemented in the promise type and in the return type (which is a promise
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.356.1">
      type wrapper).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.357.1">
     When the compiler reads the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.358.1">
      co_yield
     </span>
    </strong>
    <span class="koboSpan" id="kobo.359.1">
     expression, it will generate a call to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.360.1">
      yield_value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.361.1">
     function defined in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.362.1">
      promise type.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.363.1">
     The following code is the implementation for our version of that function that generates (or yields) a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.364.1">
       std::string
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.366.1">
std::suspend_always yield_value(std::string msg) noexcept {
    output_data = std::move(msg);
    return {};
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.367.1">
     The function gets a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.368.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     object and moves it to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.370.1">
      output_data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.371.1">
     member variable of the promise type.
    </span>
    <span class="koboSpan" id="kobo.371.2">
     But this just keeps the data inside the promise type.
    </span>
    <span class="koboSpan" id="kobo.371.3">
     We need a mechanism to get that string out of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.372.1">
      the coroutine.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.373.1">
     The handle type
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     Once we require a communication channel to and from a coroutine, we need a way to refer to a suspended or executing coroutine.
    </span>
    <span class="koboSpan" id="kobo.374.2">
     The C++ standard library implements such a mechanism in what is called
    </span>
    <a id="_idIndexMarker591">
    </a>
    <span class="koboSpan" id="kobo.375.1">
     a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.376.1">
      coroutine handle
     </span>
    </strong>
    <span class="koboSpan" id="kobo.377.1">
     .
    </span>
    <span class="koboSpan" id="kobo.377.2">
     Its type is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.378.1">
      std::coroutine_handle
     </span>
    </strong>
    <span class="koboSpan" id="kobo.379.1">
     and it’s a member variable of the return type.
    </span>
    <span class="koboSpan" id="kobo.379.2">
     This structure is also responsible for the full life cycle of the handle, creating and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.380.1">
      destroying it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.381.1">
     The following code snippet is the functionality we added to our return type to manage a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.382.1">
      coroutine handle:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.383.1">
std::coroutine_handle&lt;promise_type&gt; handle{};
explicit return_type(promise_type&amp; promise) : handle{ std::coroutine_handle&lt;promise_type&gt;::from_promise(promise)} {
}
~return_type() noexcept {
    if (handle) {
        handle.destroy();
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.384.1">
     The preceding code declares a coroutine handle of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.385.1">
      std::coroutine_handle&lt;promise_type&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.386.1">
     and creates the handle in the return type constructor.
    </span>
    <span class="koboSpan" id="kobo.386.2">
     The handle is destroyed in the return
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.387.1">
      type destructor.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.388.1">
     Now, back to our yielding coroutine.
    </span>
    <span class="koboSpan" id="kobo.388.2">
     The only missing bit is the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.389.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.390.1">
     function for the caller function to be able to access the string generated by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.391.1">
      the coroutine:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.392.1">
std::string get() {
    if (!handle.done()) {
        handle.resume();
    }
    return std::move(handle.promise().output_data);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.393.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.394.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.395.1">
     function
    </span>
    <a id="_idIndexMarker592">
    </a>
    <span class="koboSpan" id="kobo.396.1">
     resumes the coroutine if it is not terminated and then returns the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.397.1">
      string object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.398.1">
     The following is the full code for our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.399.1">
      second coroutine:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.400.1">
#include &lt;coroutine&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std::string_literals;
struct return_type {
    struct promise_type {
        std::string output_data { };
        return_type get_return_object() noexcept {
            std::cout &lt;&lt; "get_return_object\n";
            return return_type{ *this };
        }
        void return_void() noexcept {
            std::cout &lt;&lt; "return_void\n";
        }
        std::suspend_always yield_value(
                         std::string msg) noexcept {
            std::cout &lt;&lt; "yield_value\n";
            output_data = std::move(msg);
            return {};
        }
        std::suspend_always initial_suspend() noexcept {
            std::cout &lt;&lt; "initial_suspend\n";
            return {};
        }
        std::suspend_always final_suspend() noexcept {
            std::cout &lt;&lt; "final_suspend\n";
            return {};
        }
        void unhandled_exception() noexcept {
            std::cout &lt;&lt; "unhandled_exception\n";
        }
    };
    std::coroutine_handle&lt;promise_type&gt; handle{};
    explicit return_type(promise_type&amp; promise)
       : handle{ std::coroutine_handle&lt;
                 promise_type&gt;::from_promise(promise)}{
        std::cout &lt;&lt; "return_type()\n";
    }
    ~return_type() noexcept {
        if (handle) {
            handle.destroy();
        }
        std::cout &lt;&lt; "~return_type()\n";
    }
    std::string get() {
        std::cout &lt;&lt; "get()\n";
        if (!handle.done()) {
            handle.resume();
        }
        return std::move(handle.promise().output_data);
    }
};
return_type coro_func() {
    co_yield "Hello from the coroutine\n"s;
    co_return;
}
int main() {
    auto rt = coro_func();
    std::cout &lt;&lt; rt.get() &lt;&lt; std::endl;
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.401.1">
     Running the
    </span>
    <a id="_idIndexMarker593">
    </a>
    <span class="koboSpan" id="kobo.402.1">
     preceding code prints the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      following messages:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.404.1">
get_return_object
return_type()
initial_suspend
get()
yield_value
Hello from the coroutine
~return_type()</span></pre>
   <p>
    <span class="koboSpan" id="kobo.405.1">
     This output shows
    </span>
    <a id="_idIndexMarker594">
    </a>
    <span class="koboSpan" id="kobo.406.1">
     us what is happening during the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.407.1">
      coroutine execution:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.408.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.409.1">
       return_type
      </span>
     </strong>
     <span class="koboSpan" id="kobo.410.1">
      object is created after a call
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.411.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.412.1">
        get_return_object
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.413.1">
      The coroutine is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.414.1">
       initially suspended
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.415.1">
      The caller wants to get the message from the coroutine, so
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.416.1">
       get()
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.417.1">
       is called
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.418.1">
       yield_value
      </span>
     </strong>
     <span class="koboSpan" id="kobo.419.1">
      is called and the coroutine is resumed and the message is copied to a member variable in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.420.1">
       the promise
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.421.1">
      Finally, the message is printed by the caller function, and the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.422.1">
       coroutine returns
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.423.1">
     Note that the promise (and promise type) have nothing to do with the C++ Standard Library
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.424.1">
      std::promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.425.1">
     type explained in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.426.1">
       Chapter 6
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.427.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-175">
    <a id="_idTextAnchor174">
    </a>
    <span class="koboSpan" id="kobo.428.1">
     A waiting coroutine
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.429.1">
     In the previous example, we saw
    </span>
    <a id="_idIndexMarker595">
    </a>
    <span class="koboSpan" id="kobo.430.1">
     how to implement a coroutine that can communicate
    </span>
    <a id="_idIndexMarker596">
    </a>
    <span class="koboSpan" id="kobo.431.1">
     back to the caller by sending it a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.432.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.433.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.433.2">
     Now, we are going to implement a coroutine that can wait for input data sent by the caller.
    </span>
    <span class="koboSpan" id="kobo.433.3">
     In our example, the coroutine will wait until it gets a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.434.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.435.1">
     object and then print it.
    </span>
    <span class="koboSpan" id="kobo.435.2">
     When we say that the coroutine “waits,” we mean it is suspended (that is, not executing) until the data
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.436.1">
      is received.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.437.1">
     Let’s start with changes to both the coroutine and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.438.1">
      caller function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.439.1">
return_type coro_func() {
    std::cout &lt;&lt; co_await std::string{ };
    co_return;
}
int main() {
    auto rt = coro_func();
    rt.put("Hello from main\n"s);
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.440.1">
     In the preceding code, the caller function calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.441.1">
      put()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.442.1">
     function (a method in the return type structure) and the coroutine calls
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.443.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.444.1">
     to wait for a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.445.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.446.1">
     object from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.447.1">
      the caller.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.448.1">
     The changes to the return type are simple, that is, just adding the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.449.1">
       put()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.450.1">
      function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.451.1">
void put(std::string msg) {
    handle.promise().input_data = std::move(msg);
    if (!handle.done()) {
        handle.resume();
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.452.1">
     We need to add
    </span>
    <a id="_idIndexMarker597">
    </a>
    <span class="koboSpan" id="kobo.453.1">
     the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.454.1">
      input_data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.455.1">
     variable to the promise structure.
    </span>
    <span class="koboSpan" id="kobo.455.2">
     But just
    </span>
    <a id="_idIndexMarker598">
    </a>
    <span class="koboSpan" id="kobo.456.1">
     with those changes to our first example (we take it as the starting point for the rest of the examples in this chapter because it’s the minimum code to implement a coroutine) and the coroutine handle from the previous example, the code cannot be compiled.
    </span>
    <span class="koboSpan" id="kobo.456.2">
     The compiler gives us the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.457.1">
      following error:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.458.1">
error: no member named 'await_ready' in 'std::string' {aka 'std::__cxx11::basic_string&lt;char&gt;'}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.459.1">
     Going back to the C++ reference, we see that when the coroutine calls
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.460.1">
      co_await
     </span>
    </strong>
    <span class="koboSpan" id="kobo.461.1">
     , the compiler will generate code to call a function in the promise object called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.462.1">
      await_transform
     </span>
    </strong>
    <span class="koboSpan" id="kobo.463.1">
     , which has a parameter of the same type as the data the coroutine is waiting for.
    </span>
    <span class="koboSpan" id="kobo.463.2">
     As its name implies,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.464.1">
      await_transform
     </span>
    </strong>
    <span class="koboSpan" id="kobo.465.1">
     is a function that transforms any object (in our example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.466.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.467.1">
     ) into an awaitable object.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.468.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.469.1">
     is not awaitable, hence the previous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.470.1">
      compiler error.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.471.1">
      await_transform
     </span>
    </strong>
    <span class="koboSpan" id="kobo.472.1">
     must return
    </span>
    <a id="_idIndexMarker599">
    </a>
    <span class="koboSpan" id="kobo.473.1">
     an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.474.1">
      awaiter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.475.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.475.2">
     This is just a simple struct implementing a required interface for the awaiter to be usable by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.476.1">
      the compiler.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.477.1">
     The following
    </span>
    <a id="_idIndexMarker600">
    </a>
    <span class="koboSpan" id="kobo.478.1">
     code shows our implementation of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.479.1">
      await_transform
     </span>
    </strong>
    <span class="koboSpan" id="kobo.480.1">
     function
    </span>
    <a id="_idIndexMarker601">
    </a>
    <span class="koboSpan" id="kobo.481.1">
     and the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.482.1">
       awaiter
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.483.1">
      struct:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.484.1">
auto await_transform(std::string) noexcept {
    struct awaiter {
        promise_type&amp; promise;
        bool await_ready() const noexcept {
            return true;
        }
        std::string await_resume() const noexcept {
            return std::move(promise.input_data);
        }
        void await_suspend(std::coroutine_handle&lt;
                           promise_type&gt;) const noexcept {
        }
   };
   return awaiter(*this);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.485.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.486.1">
      promise_type
     </span>
    </strong>
    <span class="koboSpan" id="kobo.487.1">
     function
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.488.1">
      await_transform
     </span>
    </strong>
    <span class="koboSpan" id="kobo.489.1">
     is required by the compiler.
    </span>
    <span class="koboSpan" id="kobo.489.2">
     We cannot use a different identifier for this function.
    </span>
    <span class="koboSpan" id="kobo.489.3">
     The parameter type must be the same as the object the coroutine is waiting for.
    </span>
    <span class="koboSpan" id="kobo.489.4">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.490.1">
      awaiter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.491.1">
     struct can be named with any name.
    </span>
    <span class="koboSpan" id="kobo.491.2">
     We used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.492.1">
      awaiter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.493.1">
     here because is descriptive.
    </span>
    <span class="koboSpan" id="kobo.493.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.494.1">
      awaiter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.495.1">
     struct must implement
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.496.1">
      three functions:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.497.1">
       await_ready
      </span>
     </strong>
     <span class="koboSpan" id="kobo.498.1">
      : This is called to check whether the coroutine is suspended.
     </span>
     <span class="koboSpan" id="kobo.498.2">
      If that is the case, it returns
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.499.1">
       false
      </span>
     </strong>
     <span class="koboSpan" id="kobo.500.1">
      .
     </span>
     <span class="koboSpan" id="kobo.500.2">
      In our example, it always returns
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.501.1">
       true
      </span>
     </strong>
     <span class="koboSpan" id="kobo.502.1">
      to indicate the coroutine is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.503.1">
       not suspended.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.504.1">
       await_resume
      </span>
     </strong>
     <span class="koboSpan" id="kobo.505.1">
      : This resumes the coroutine and generates the result of the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.506.1">
        co_await
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.507.1">
       expression.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.508.1">
       await_suspend
      </span>
     </strong>
     <span class="koboSpan" id="kobo.509.1">
      : In our simple awaiter, this returns
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.510.1">
       void
      </span>
     </strong>
     <span class="koboSpan" id="kobo.511.1">
      , meaning the control is passed to the caller and the coroutine is suspended.
     </span>
     <span class="koboSpan" id="kobo.511.2">
      It’s also possible for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.512.1">
       await_suspend
      </span>
     </strong>
     <span class="koboSpan" id="kobo.513.1">
      to return a Boolean.
     </span>
     <span class="koboSpan" id="kobo.513.2">
      Returning
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.514.1">
       true
      </span>
     </strong>
     <span class="koboSpan" id="kobo.515.1">
      in this case is like returning
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.516.1">
       void
      </span>
     </strong>
     <span class="koboSpan" id="kobo.517.1">
      .
     </span>
     <span class="koboSpan" id="kobo.517.2">
      Returning
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.518.1">
       false
      </span>
     </strong>
     <span class="koboSpan" id="kobo.519.1">
      means the coroutine
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.520.1">
       is resumed.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.521.1">
     This is the code for
    </span>
    <a id="_idIndexMarker602">
    </a>
    <span class="koboSpan" id="kobo.522.1">
     the full
    </span>
    <a id="_idIndexMarker603">
    </a>
    <span class="koboSpan" id="kobo.523.1">
     example of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.524.1">
      waiting coroutine:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.525.1">
#include &lt;coroutine&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std::string_literals;
struct return_type {
    struct promise_type {
        std::string input_data { };
        return_type get_return_object() noexcept {
            return return_type{ *this };
        }
        void return_void() noexcept {
        }
        std::suspend_always initial_suspend() noexcept {
            return {};
        }
        std::suspend_always final_suspend() noexcept {
            return {};
        }
        void unhandled_exception() noexcept {
        }
        auto await_transform(std::string) noexcept {
            struct awaiter {
                promise_type&amp; promise;
                bool await_ready() const noexcept {
                    return true;
                }
                std::string await_resume() const noexcept {
                    return std::move(promise.input_data);
                }
                void await_suspend(std::coroutine_handle&lt;
                                  promise_type&gt;) const noexcept {
                }
            };
            return awaiter(*this);
        }
    };
    std::coroutine_handle&lt;promise_type&gt; handle{};
    explicit return_type(promise_type&amp; promise)
      : handle{ std::coroutine_handle&lt;
                         promise_type&gt;::from_promise(promise)} {
    }
    ~return_type() noexcept {
        if (handle) {
            handle.destroy();
        }
    }
    void put(std::string msg) {
        handle.promise().input_data = std::move(msg);
        if (!handle.done()) {
            handle.resume();
        }
    }
};
return_type coro_func() {
    std::cout &lt;&lt; co_await std::string{ };
    co_return;
}
int main() {
    auto rt = coro_func();
    rt.put("Hello from main\n"s);
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.526.1">
     In this section, we have seen three basic examples of coroutines.
    </span>
    <span class="koboSpan" id="kobo.526.2">
     We have implemented the simplest coroutine and then coroutines with communication channels to both generate data for the caller (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.527.1">
      co_yield
     </span>
    </strong>
    <span class="koboSpan" id="kobo.528.1">
     ) and wait for data from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.529.1">
      caller (
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.530.1">
       co_await
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.531.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.532.1">
     In the next section, we will implement a type of coroutine called a generator and generate sequences
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.533.1">
      of numbers.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-176">
    <a id="_idTextAnchor175">
    </a>
    <span class="koboSpan" id="kobo.534.1">
     Coroutine generators
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.535.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.536.1">
      generator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.537.1">
     is a
    </span>
    <a id="_idIndexMarker604">
    </a>
    <span class="koboSpan" id="kobo.538.1">
     coroutine that
    </span>
    <a id="_idIndexMarker605">
    </a>
    <span class="koboSpan" id="kobo.539.1">
     generates a sequence of elements by repeatedly resuming itself from the point that it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.540.1">
      was suspended.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.541.1">
     A generator can be seen as an
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.542.1">
      infinite
     </span>
    </em>
    <span class="koboSpan" id="kobo.543.1">
     sequence because it can generate an arbitrary number of elements.
    </span>
    <span class="koboSpan" id="kobo.543.2">
     The caller function can get as many new elements from the generator as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.544.1">
      it needs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.545.1">
     When we say infinite, we mean in theory.
    </span>
    <span class="koboSpan" id="kobo.545.2">
     A generator coroutine will yield elements without a definite last element (it is possible to implement generators with a limited range) but, in practice, we must deal with issues such as overflow in the case of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.546.1">
      numerical sequences.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.547.1">
     Let’s implement a generator from scratch, applying the knowledge we have gained in the previous sections of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.548.1">
      this chapter.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-177">
    <a id="_idTextAnchor176">
    </a>
    <span class="koboSpan" id="kobo.549.1">
     Fibonacci sequence generator
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.550.1">
     Imagine we are implementing
    </span>
    <a id="_idIndexMarker606">
    </a>
    <span class="koboSpan" id="kobo.551.1">
     an application and we need to use the Fibonacci sequence.
    </span>
    <span class="koboSpan" id="kobo.551.2">
     As you probably already know, the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.552.1">
      Fibonacci sequence
     </span>
    </strong>
    <span class="koboSpan" id="kobo.553.1">
     is a
    </span>
    <a id="_idIndexMarker607">
    </a>
    <span class="koboSpan" id="kobo.554.1">
     sequence in which each number is the sum of the two preceding ones.
    </span>
    <span class="koboSpan" id="kobo.554.2">
     The first element is 0, the second element is 1, and then we apply the definition and generate element
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.555.1">
      after element.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.556.1">
     <img alt="&lt;math  display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;;&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" src="image/12.png" style="vertical-align:-0.254em;height:0.965em;width:29.022em"/>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.557.1">
     We can always
    </span>
    <a id="_idIndexMarker608">
    </a>
    <span class="koboSpan" id="kobo.558.1">
     generate these numbers with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.559.1">
      for
     </span>
    </strong>
    <span class="koboSpan" id="kobo.560.1">
     loop.
    </span>
    <span class="koboSpan" id="kobo.560.2">
     But if we need to generate them at different points in our program, we need to implement a way to store the state of the sequence.
    </span>
    <span class="koboSpan" id="kobo.560.3">
     We need to keep somewhere in our program what the last element we generated was.
    </span>
    <span class="koboSpan" id="kobo.560.4">
     Was it the fifth or maybe the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.561.1">
      tenth element?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.562.1">
     A coroutine is a very good solution for this problem; it will keep the required state itself and it will suspend until we request the next number in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.563.1">
      the sequence.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.564.1">
     Here’s the code using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.565.1">
      generator coroutine:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.566.1">
int main() {
    sequence_generator&lt;int64_t&gt; fib = fibonacci();
    std::cout &lt;&lt; "Generate ten Fibonacci numbers\n"s;
    for (int i = 0; i &lt; 10; ++i) {
        fib.next();
        std::cout &lt;&lt; fib.value() &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; "Generate ten more\n"s;
    for (int i = 0; i &lt; 10; ++i) {
        fib.next();
        std::cout &lt;&lt; fib.value() &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; "Let's do five more\n"s;
    for (int i = 0; i &lt; 5; ++i) {
        fib.next();
        std::cout &lt;&lt; fib.value() &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.567.1">
     As you can see in the preceding code, we generate the numbers we need without worrying about what the last element was.
    </span>
    <span class="koboSpan" id="kobo.567.2">
     The sequence is generated by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.568.1">
      the coroutine.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.569.1">
     Note that even though in theory the sequence is infinite, our program must be aware of potential overflow for very big
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.570.1">
      Fibonacci numbers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.571.1">
     To implement the
    </span>
    <a id="_idIndexMarker609">
    </a>
    <span class="koboSpan" id="kobo.572.1">
     generator coroutine, we follow the
    </span>
    <a id="_idIndexMarker610">
    </a>
    <span class="koboSpan" id="kobo.573.1">
     principles explained previously in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.574.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.575.1">
     First, we implement the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.576.1">
      coroutine function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.577.1">
sequence_generator&lt;int64_t&gt; fibonacci() {
    int64_t a{ 0 };
    int64_t b{ 1 };
    int64_t c{ 0 };
    while (true) {
        co_yield a;
        c = a + b;
        a = b;
        b = c;
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.578.1">
     The coroutine just generates the next element in the Fibonacci sequence by applying the formula.
    </span>
    <span class="koboSpan" id="kobo.578.2">
     The elements are generated in an infinite loop, but the coroutine suspends itself
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.579.1">
      after
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.580.1">
       co_yield
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.581.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.582.1">
     The return type is the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.583.1">
      sequence_generator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.584.1">
     struct (we use a template to be able to use either 32- or 64-bit integers).
    </span>
    <span class="koboSpan" id="kobo.584.2">
     It contains a promise type, pretty much like the one in the yielding coroutine we saw in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.585.1">
      previous section.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.586.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.587.1">
      sequence_generator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.588.1">
     struct, we added two functions that are useful when implementing a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.589.1">
      sequence generator.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.590.1">
void next() {
    if (!handle.done()) {
        handle.resume();
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.591.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.592.1">
      next()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.593.1">
     function resumes the coroutine for a new Fibonacci number in the sequence to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.594.1">
      be generated.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.595.1">
int64_t value() {
    return handle.promise().output_data;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.596.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.597.1">
      value()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.598.1">
     function returns the last generated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.599.1">
      Fibonacci number.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.600.1">
     This way, we
    </span>
    <a id="_idIndexMarker611">
    </a>
    <span class="koboSpan" id="kobo.601.1">
     decouple element generation and its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.602.1">
      retrieval Qvalue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.603.1">
     Please find the full code for this example in the book’s accompanying
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.604.1">
      GitHub repository.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.605.1">
     C++23 std::generator
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.606.1">
     We have seen that implementing even the most basic coroutine in C++ requires a certain amount of code.
    </span>
    <span class="koboSpan" id="kobo.606.2">
     This may change in C++26 with more support for coroutines in the C++ Standard Library, which will allow us to write coroutines much
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.607.1">
      more easily.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.608.1">
     C++23 introduced
    </span>
    <a id="_idIndexMarker612">
    </a>
    <span class="koboSpan" id="kobo.609.1">
     the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.610.1">
      std::generator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.611.1">
     template class.
    </span>
    <span class="koboSpan" id="kobo.611.2">
     By using it, we can write coroutine-based generators without writing any of the required code, such as the promise type, the return type, and all their functions.
    </span>
    <span class="koboSpan" id="kobo.611.3">
     To run this example, you will need a C++23 compiler.
    </span>
    <span class="koboSpan" id="kobo.611.4">
     We have used GCC 14.1.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.612.1">
      std::generator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.613.1">
     is not available
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.614.1">
      in Clang.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.615.1">
     Let’s see the
    </span>
    <a id="_idIndexMarker613">
    </a>
    <span class="koboSpan" id="kobo.616.1">
     Fibonacci sequence generator using the new C++23 Standard
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.617.1">
      Library features:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.618.1">
#include &lt;generator&gt;
#include &lt;iostream&gt;
std::generator&lt;int&gt; fibonacci_generator() {
    int a{ };
    int b{ 1 };
    while (true) {
        co_yield a;
        int c = a + b;
        a = b;
        b = c;
    }
}
auto fib = fibonacci_generator();
int main() {
    int i = 0;
    for (auto f = fib.begin(); f != fib.end(); ++f) {
        if (i == 10) {
            break;
        }
        std::cout &lt;&lt; *f &lt;&lt; " ";
        ++i;
    }
    std::cout &lt;&lt; std::endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.619.1">
     The first step is to include the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.620.1">
      &lt;generator&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.621.1">
     header file.
    </span>
    <span class="koboSpan" id="kobo.621.2">
     Then, we just write the coroutine because all the rest of the required code has been written for us.
    </span>
    <span class="koboSpan" id="kobo.621.3">
     In the preceding code, we access the generated elements with an iterator (which is provided by the C++ Standard Library).
    </span>
    <span class="koboSpan" id="kobo.621.4">
     This allows us to use a range-for loop, algorithms,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.622.1">
      and ranges.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.623.1">
     It is also possible to
    </span>
    <a id="_idIndexMarker614">
    </a>
    <span class="koboSpan" id="kobo.624.1">
     write a version of the Fibonacci generator to generate a certain number of elements instead of an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.625.1">
      infinite series:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.626.1">
std::generator&lt;int&gt; fibonacci_generator(int limit) {
    int a{ };
    int b{ 1 };
    while (limit--) {
        co_yield a;
        int c = a + b;
        a = b;
        b = c;
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.627.1">
     The code changes are very simple: just pass the number of elements we want the generator to generate and use it as the termination condition in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.628.1">
       while
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.629.1">
      loop.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.630.1">
     In this section, we have implemented one of the most common coroutine types – a generator.
    </span>
    <span class="koboSpan" id="kobo.630.2">
     We have implemented generators both from scratch and using the C++23
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.631.1">
      std::generator
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.632.1">
      class template.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.633.1">
     We will implement a simple string parser coroutine in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.634.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-178">
    <a id="_idTextAnchor177">
    </a>
    <span class="koboSpan" id="kobo.635.1">
     Simple coroutine string parser
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.636.1">
     In this section, we will
    </span>
    <a id="_idIndexMarker615">
    </a>
    <span class="koboSpan" id="kobo.637.1">
     implement our last example: a simple string parser.
    </span>
    <span class="koboSpan" id="kobo.637.2">
     The coroutine will wait for the input, a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.638.1">
      std::string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.639.1">
     object, and will yield the output, a number, after parsing the input string.
    </span>
    <span class="koboSpan" id="kobo.639.2">
     To simplify the example, we will assume that the string representation of the number doesn’t have any errors and that the end of a number is represented by the hash character,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.640.1">
      #
     </span>
    </strong>
    <span class="koboSpan" id="kobo.641.1">
     .
    </span>
    <span class="koboSpan" id="kobo.641.2">
     We will also assume that the number type is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.642.1">
      int64_t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.643.1">
     and that the string won’t contain any values out of that integer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.644.1">
      type range.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-179">
    <a id="_idTextAnchor178">
    </a>
    <span class="koboSpan" id="kobo.645.1">
     The parsing algorithm
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.646.1">
     Let’s see how to convert a
    </span>
    <a id="_idIndexMarker616">
    </a>
    <span class="koboSpan" id="kobo.647.1">
     string representing an integer into a number.
    </span>
    <span class="koboSpan" id="kobo.647.2">
     For example, the string
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.648.1">
      "-12321#"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.649.1">
     represents the number -12321.
    </span>
    <span class="koboSpan" id="kobo.649.2">
     To convert the string into a number, we can write a function
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.650.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.651.1">
int64_t parse_string(const std::string&amp; str) {
    int64_t num{ 0 };
    int64_t sign { 1 };
    std::size_t c = 0;
    while (c &lt; str.size()) {
        if (str[c] == '-') {
            sign = -1;
        }
        else if (std::isdigit(str[c])) {
            num = num * 10 + (str[c] - '0');
        }
        else if (str[c] == '#') {
            break;
        }
        ++c;
    }
    return num * sign;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.652.1">
     The code is
    </span>
    <a id="_idIndexMarker617">
    </a>
    <span class="koboSpan" id="kobo.653.1">
     quite simple because of the assumption that the string is well formed.
    </span>
    <span class="koboSpan" id="kobo.653.2">
     If we read the minus sign,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.654.1">
      -
     </span>
    </strong>
    <span class="koboSpan" id="kobo.655.1">
     , then we change the sign to -1 (by default, we assume positive numbers, and if there is a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.656.1">
      +
     </span>
    </strong>
    <span class="koboSpan" id="kobo.657.1">
     sign, it is simply ignored).
    </span>
    <span class="koboSpan" id="kobo.657.2">
     Then, the digits are read one by one, and the number value is calculated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.658.1">
      as follows.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.659.1">
     The initial value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.660.1">
      num
     </span>
    </strong>
    <span class="koboSpan" id="kobo.661.1">
     is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.662.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.663.1">
     .
    </span>
    <span class="koboSpan" id="kobo.663.2">
     We read the first digit and add its numeric value to the current
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.664.1">
      num
     </span>
    </strong>
    <span class="koboSpan" id="kobo.665.1">
     value multiplied by 10.
    </span>
    <span class="koboSpan" id="kobo.665.2">
     This is the way we read numbers: the leftmost digit will be multiplied by 10 as many times as the number of digits to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.666.1">
      its right.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.667.1">
     When we use characters to represent digits, they have some value according to the ASCII representation (we assume no wide characters or any other character type is used).
    </span>
    <span class="koboSpan" id="kobo.667.2">
     The characters
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.668.1">
      0
     </span>
    </em>
    <span class="koboSpan" id="kobo.669.1">
     to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.670.1">
      9
     </span>
    </em>
    <span class="koboSpan" id="kobo.671.1">
     have consecutive ASCII codes, so we can easily convert them to numbers by just
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.672.1">
      subtracting
     </span>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.673.1">
       0
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.674.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.675.1">
     Even if for the preceding code the last character check is not necessary, we have included it here.
    </span>
    <span class="koboSpan" id="kobo.675.2">
     When the parser routine finds the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.676.1">
      #
     </span>
    </strong>
    <span class="koboSpan" id="kobo.677.1">
     character, it terminates the parsing loop and returns the final
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.678.1">
      number value.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.679.1">
     We can use this function to parse any string and get the number value, but we need the full string to convert it into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.680.1">
      a number.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.681.1">
     Let’s think about this scenario: the string is being received from a network connection and we need to parse it and convert it into a number.
    </span>
    <span class="koboSpan" id="kobo.681.2">
     We may save the characters to a temporary string and then call the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.682.1">
      preceding function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.683.1">
     But there is another issue: what if the characters arrive slowly, such as once every few seconds, because that’s the way they are transmitted?
    </span>
    <span class="koboSpan" id="kobo.683.2">
     We want to keep our CPU busy and, if possible, do
    </span>
    <a id="_idIndexMarker618">
    </a>
    <span class="koboSpan" id="kobo.684.1">
     some other task (or tasks) while waiting for each character
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.685.1">
      to arrive.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.686.1">
     There are different approaches to solving this problem.
    </span>
    <span class="koboSpan" id="kobo.686.2">
     We can create a thread and process the string concurrently, but this can be costly in computer time for such a simple task.
    </span>
    <span class="koboSpan" id="kobo.686.3">
     We can use
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.687.1">
       std::async
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.688.1">
      too.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-180">
    <a id="_idTextAnchor179">
    </a>
    <span class="koboSpan" id="kobo.689.1">
     The parsing coroutine
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.690.1">
     We are working with
    </span>
    <a id="_idIndexMarker619">
    </a>
    <span class="koboSpan" id="kobo.691.1">
     coroutines in this chapter, so we will implement the string parser using C++ coroutines.
    </span>
    <span class="koboSpan" id="kobo.691.2">
     We don’t need an extra thread, and because of the asynchronous nature of coroutines, it will be quite easy to perform any other processing while the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.692.1">
      characters arrive.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.693.1">
     The boilerplate code we will need for the parsing coroutine is pretty much the same as the code we have already seen in the previous examples.
    </span>
    <span class="koboSpan" id="kobo.693.2">
     The parser itself is quite different.
    </span>
    <span class="koboSpan" id="kobo.693.3">
     See the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.694.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.695.1">
async_parse&lt;int64_t, char&gt; parse_string() {
    while (true) {
        char c = co_await char{ };
        int64_t number { };
        int64_t sign { 1 };
        if (c != '-' &amp;&amp; c != '+' &amp;&amp; !std::isdigit(c)) {
            continue;
        }
        if (c == '-') {
            sign = -1;
        }
        else if (std::isdigit(c)) {
            number = number * 10 + c - '0';
        }
        while (true) {
            c = co_await char{};
            if (std::isdigit(c)) {
                number = number * 10 + c - '0';
            }
            else {
                break;
            }
        }
        co_yield number * sign;
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.696.1">
     I think that you can now easily recognize the return type (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.697.1">
      async_parse&lt;int64_t, char&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.698.1">
     ) and that the parser coroutine suspends itself waiting for an input character.
    </span>
    <span class="koboSpan" id="kobo.698.2">
     The coroutine will suspend itself after yielding the number once the parsing has
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.699.1">
      been done.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.700.1">
     But you can see too that the preceding code is not as simple as our first attempt at parsing a string into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.701.1">
      a number.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.702.1">
     First, the parser coroutine parses one character after another.
    </span>
    <span class="koboSpan" id="kobo.702.2">
     It doesn’t get the full string to parse, hence the infinite
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.703.1">
      while (true)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.704.1">
     loops.
    </span>
    <span class="koboSpan" id="kobo.704.2">
     We don’t know how many characters there are in the full string, so we need to keep on receiving and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.705.1">
      parsing them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.706.1">
     The outer loop means that
    </span>
    <a id="_idIndexMarker620">
    </a>
    <span class="koboSpan" id="kobo.707.1">
     the coroutine will parse numbers, one after another, as the characters arrive – forever.
    </span>
    <span class="koboSpan" id="kobo.707.2">
     But remember that it suspends itself to wait for the characters, so we don’t waste
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.708.1">
      CPU time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.709.1">
     Now, one character arrives.
    </span>
    <span class="koboSpan" id="kobo.709.2">
     The first check is to see whether it is a valid character for our number.
    </span>
    <span class="koboSpan" id="kobo.709.3">
     If the character is not either the minus sign,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.710.1">
      -
     </span>
    </strong>
    <span class="koboSpan" id="kobo.711.1">
     , the plus sign,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.712.1">
      +
     </span>
    </strong>
    <span class="koboSpan" id="kobo.713.1">
     , or a digit, then the parser waits for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.714.1">
      next character.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.715.1">
     If the next character is a valid one, then the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.716.1">
      following apply:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.717.1">
      If it is the minus sign, we change the sign value
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.718.1">
       to -1
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.719.1">
      If it is the plus sign, we
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.720.1">
       ignore it
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.721.1">
      If it is a digit, we parse it into the number, updating the current number value using the same method as we saw in the first version of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.722.1">
       the parser
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.723.1">
     After the first valid character, we enter a new loop to receive the rest of the characters, either digits or the separator character (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.724.1">
      #
     </span>
    </strong>
    <span class="koboSpan" id="kobo.725.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.725.2">
     Note here that when we say valid character, we mean good for numerical conversion.
    </span>
    <span class="koboSpan" id="kobo.725.3">
     We are still assuming that the input characters form a valid number that is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.726.1">
      correctly terminated.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.727.1">
     Once the number has been converted, it is yielded by the coroutine and the outer loop executes again.
    </span>
    <span class="koboSpan" id="kobo.727.2">
     The terminating character is needed here because the input character stream is, in theory, endless, and it can contain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.728.1">
      many numbers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.729.1">
     The code for the rest of the coroutine can be found in the GitHub repo.
    </span>
    <span class="koboSpan" id="kobo.729.2">
     It follows the same convention as
    </span>
    <a id="_idIndexMarker621">
    </a>
    <span class="koboSpan" id="kobo.730.1">
     any other coroutine.
    </span>
    <span class="koboSpan" id="kobo.730.2">
     First, we define the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.731.1">
      return type:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.732.1">
template &lt;typename Out, typename In&gt;
struct async_parse {
// …
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.733.1">
     We use a template for flexibility because it allows us to parameterize both the input and output data types.
    </span>
    <span class="koboSpan" id="kobo.733.2">
     In this case, these types are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.734.1">
      int64_t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.735.1">
     and
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.736.1">
       char
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.737.1">
      , respectively.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.738.1">
     The input and output data items are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.739.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.740.1">
std::optional&lt;In&gt; input_data { };
Out output_data { };</span></pre>
   <p>
    <span class="koboSpan" id="kobo.741.1">
     For input, we are using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.742.1">
      std::optional&lt;In&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.743.1">
     because we need a way to know whether we have received a character.
    </span>
    <span class="koboSpan" id="kobo.743.2">
     We use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.744.1">
      put()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.745.1">
     function to send a character to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.746.1">
      the parser:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.747.1">
 void put(char c) {
    handle.promise().input_data = c;
    if (!handle.done()) {
        handle.resume();
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.748.1">
     This function just assigns a value to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.749.1">
      std::optional
     </span>
    </strong>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.750.1">
      input_data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.751.1">
     variable.
    </span>
    <span class="koboSpan" id="kobo.751.2">
     To manage the
    </span>
    <a id="_idIndexMarker622">
    </a>
    <span class="koboSpan" id="kobo.752.1">
     waiting for the characters, we implement the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.753.1">
      awaiter type:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.754.1">
auto await_transform(char) noexcept {
    struct awaiter {
        promise_type&amp; promise;
        [[nodiscard]] bool await_ready() const noexcept {
            return promise.input_data.has_value();
        }
        [[nodiscard]] char await_resume() const noexcept {
            assert (promise.input_data.has_value());
            return *std::exchange(
                            promise.input_data,
                            std::nullopt);
        }
        void await_suspend(std::coroutine_handle&lt;
                           promise_type&gt;) const noexcept {
        }
    };
    return awaiter(*this);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.755.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.756.1">
      awaiter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.757.1">
     struct implements two functions to handle the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.758.1">
      input data:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.759.1">
       await_ready()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.760.1">
      : Returns
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.761.1">
       true
      </span>
     </strong>
     <span class="koboSpan" id="kobo.762.1">
      if the optional
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.763.1">
       input_data
      </span>
     </strong>
     <span class="koboSpan" id="kobo.764.1">
      variable contains a valid value.
     </span>
     <span class="koboSpan" id="kobo.764.2">
      It returns
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.765.1">
        false
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.766.1">
       otherwise.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.767.1">
       await_resume()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.768.1">
      : Returns the value stored in the optional
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.769.1">
       input_data
      </span>
     </strong>
     <span class="koboSpan" id="kobo.770.1">
      variable
     </span>
     <a id="_idIndexMarker623">
     </a>
     <span class="koboSpan" id="kobo.771.1">
      and
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.772.1">
       empties
      </span>
     </em>
     <span class="koboSpan" id="kobo.773.1">
      it, assigning it
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.774.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.775.1">
        std::nullopt
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.776.1">
       .
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.777.1">
     In this section, we have seen how to implement a simple parser using C++ coroutines.
    </span>
    <span class="koboSpan" id="kobo.777.2">
     This is our last example, illustrating a very basic stream processing function using coroutines.
    </span>
    <span class="koboSpan" id="kobo.777.3">
     In the next section, we will see exceptions
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.778.1">
      in coroutines.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-181">
    <a id="_idTextAnchor180">
    </a>
    <span class="koboSpan" id="kobo.779.1">
     Coroutines and exceptions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.780.1">
     In the previous
    </span>
    <a id="_idIndexMarker624">
    </a>
    <span class="koboSpan" id="kobo.781.1">
     sections, we implemented a few basic examples to learn
    </span>
    <a id="_idIndexMarker625">
    </a>
    <span class="koboSpan" id="kobo.782.1">
     the main C++ coroutines concepts.
    </span>
    <span class="koboSpan" id="kobo.782.2">
     We implemented a very basic coroutine first to understand what the compiler required from us: the return type (sometimes called the wrapper type because it wraps the promise type) and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.783.1">
      promise type.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.784.1">
     Even for such a simple coroutine, we had to implement some functions we explained while we wrote the examples.
    </span>
    <span class="koboSpan" id="kobo.784.2">
     But one function has not been
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.785.1">
      explained yet:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.786.1">
void unhandled_exception() noexcept {}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.787.1">
     We assumed then that coroutines couldn’t throw exceptions, but the truth is they can.
    </span>
    <span class="koboSpan" id="kobo.787.2">
     We can add the functionality to handle exceptions in the body of the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.788.1">
       unhandled_exception()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.789.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.790.1">
     Exceptions in coroutines can happen while the return type or the promise type object is created and while the coroutine is executed (as in a normal function, coroutines can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.791.1">
      throw exceptions).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.792.1">
     The difference is that if the exception is thrown before the coroutine is executed, the code creating the coroutine must handle the exception, while if the exception is thrown when the coroutine is executed, then
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.793.1">
      unhandled_exception()
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.794.1">
      is called.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.795.1">
     The first case is just the usual exception handling with no special functions called.
    </span>
    <span class="koboSpan" id="kobo.795.2">
     We can put the coroutine creation inside a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.796.1">
      try-catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.797.1">
     block and handle the possible exceptions as we normally do in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.798.1">
      our code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.799.1">
     If, on the other hand,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.800.1">
      unhandled_exception()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.801.1">
     is called (inside the promise type), we must implement the exception-handling functionality inside
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.802.1">
      that function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.803.1">
     There are different strategies to handle such exceptions.
    </span>
    <span class="koboSpan" id="kobo.803.2">
     Among them are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.804.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.805.1">
      Rethrow the exception so we can handle it outside the promise type (that is, in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.806.1">
       our code).
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.807.1">
      Terminate the program (for example,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.808.1">
       calling
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.809.1">
        std::terminate
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.810.1">
       ).
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.811.1">
      Leave the function empty.
     </span>
     <span class="koboSpan" id="kobo.811.2">
      In this case, the coroutine will crash and it will very likely
     </span>
     <a id="_idIndexMarker626">
     </a>
     <span class="koboSpan" id="kobo.812.1">
      crash the
     </span>
     <a id="_idIndexMarker627">
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.813.1">
       program too.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.814.1">
     Because we have implemented very simple coroutines, we have left the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.815.1">
      function empty.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.816.1">
     In this last section, we have introduced the exception-handling mechanism for coroutines.
    </span>
    <span class="koboSpan" id="kobo.816.2">
     It is very important to handle exceptions properly.
    </span>
    <span class="koboSpan" id="kobo.816.3">
     For example, if you know that after an exception occurs inside a coroutine, it won’t be able to recover; then, it may be better to let the coroutine crash and handle the exception from another part of the program (usually from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.817.1">
      caller function).
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-182">
    <a id="_idTextAnchor181">
    </a>
    <span class="koboSpan" id="kobo.818.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.819.1">
     In this chapter, we have seen coroutines, a recently introduced feature in C++ that allows us to write asynchronous code without creating new threads.
    </span>
    <span class="koboSpan" id="kobo.819.2">
     We have implemented a few simple coroutines to explain the basic requirements of a C++ coroutine.
    </span>
    <span class="koboSpan" id="kobo.819.3">
     Additionally, we have learned how to implement generators and a string parser.
    </span>
    <span class="koboSpan" id="kobo.819.4">
     Finally, we have seen exceptions
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.820.1">
      in coroutines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.821.1">
     Coroutines are important in asynchronous programming because they let the program suspend execution at specific points and resume later, allowing other tasks to run in the meantime, all running in the same thread.
    </span>
    <span class="koboSpan" id="kobo.821.2">
     They allow better resource utilization, reduce waiting time, and improve the scalability
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.822.1">
      of applications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.823.1">
     In the next chapter, we will introduce Boost.Asio – a very powerful library for writing asynchronous code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.824.1">
      in C++.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-183">
    <a id="_idTextAnchor182">
    </a>
    <span class="koboSpan" id="kobo.825.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.826.1">
       C++ Coroutines for Beginners
      </span>
     </em>
     <span class="koboSpan" id="kobo.827.1">
      , Andreas Fertig, Meeting C++
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.828.1">
       Online, 2024
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.829.1">
       Deciphering Coroutines
      </span>
     </em>
     <span class="koboSpan" id="kobo.830.1">
      , Andreas Weiss,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.831.1">
       CppCon 2022
      </span>
     </span>
    </li>
   </ul>
  </div>
 

  <div class="Content" id="_idContainer052">
   <h1 id="_idParaDest-184" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor183">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     Part 4: Advanced Asynchronous Programming with Boost Libraries
    </span>
   </h1>
  </div>
  <div id="_idContainer053">
   <p>
    <span class="koboSpan" id="kobo.2.1">
     In this part, we will learn about advanced asynchronous programming techniques using powerful Boost libraries, enabling us to efficiently manage tasks that interact with external resources and system-level services.
    </span>
    <span class="koboSpan" id="kobo.2.2">
     We will explore the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.3.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.4.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.5.1">
      Boost.Cobalt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.6.1">
     libraries, learning how they simplify the development of asynchronous applications while offering fine-grained control over complex processes such as task management and coroutine execution.
    </span>
    <span class="koboSpan" id="kobo.6.2">
     Through hands-on examples, we will see how Boost.Asio handles asynchronous I/O operations in both single-threaded and multithreaded environments, and how Boost.Cobalt abstracts away the complexities of C++20 coroutines, allowing us to focus on functionality instead of low-level
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.7.1">
      coroutine management.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.8.1">
     This part has the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.9.1">
      following chapters:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <a href="B22219_09.xhtml#_idTextAnchor184">
      <em class="italic">
       <span class="koboSpan" id="kobo.10.1">
        Chapter 9
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.11.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.12.1">
       Asynchronous Programming Using Boost.Asio
      </span>
     </em>
    </li>
    <li>
     <a href="B22219_10.xhtml#_idTextAnchor212">
      <em class="italic">
       <span class="koboSpan" id="kobo.13.1">
        Chapter 10
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.14.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.15.1">
       Coroutines with Boost.Cobalt
      </span>
     </em>
    </li>
   </ul>
  </div>
  <div>
   <div id="_idContainer054">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer055">
   </div>
  </div>
 </body></html>