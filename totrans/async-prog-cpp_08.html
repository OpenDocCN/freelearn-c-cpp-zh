<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-165">
    <a id="_idTextAnchor164">
    </a>
    
     8
    
   </h1>
   <h1 id="_idParaDest-166">
    <a id="_idTextAnchor165">
    </a>
    
     Asynchronous Programming Using Coroutines
    
   </h1>
   <p>
    
     In previous chapters, we saw different methods of writing asynchronous code in C++.
    
    
     We used threads, the basic units of execution, and some higher-level asynchronous code mechanisms, such as futures and promises and
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     .
    
    
     We will look at the Boost.Asio library in the next chapter.
    
    
     All these methods often use several system threads, created and managed by
    
    
     
      the kernel.
     
    
   </p>
   <p>
    
     For example, the main thread of our program may need to access a database.
    
    
     This access may be slow, so we read the data in a different thread so our main thread can go on doing some other tasks.
    
    
     Another example is the producer-consumer model, where one or more threads generate data items to be processed, and one or more threads process those items in a fully
    
    
     
      asynchronous way.
     
    
   </p>
   <p>
    
     Both of the preceding examples use threads, also called system (kernel) threads, and require different units of execution, one
    
    
     
      per thread.
     
    
   </p>
   <p>
    
     In this chapter, we are going to study a different way to write asynchronous code – coroutines.
    
    
     Coroutines are an old concept from the late 1950s that was added to C++ only recently, since C++20.
    
    
     They don’t need a separate thread (of course, we can have different threads running coroutines).
    
    
     Coroutines are a mechanism that allows us, among other things, to perform multiple tasks in a
    
    
     
      single thread.
     
    
   </p>
   <p>
    
     In this chapter, we will cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      What are coroutines and how are they implemented and supported
     
     
      
       by C++?
      
     
    </li>
    <li>
     
      Implementing basic coroutines to see what the requirements of a C++
     
     
      
       coroutine are
      
     
    </li>
    <li>
     
      Generator coroutines and the new
     
     
      
       C++23
      
     
     
      <strong class="source-inline">
       
        std::generator
       
      </strong>
     
    </li>
    <li>
     
      A string parser to
     
     
      
       parse integers
      
     
    </li>
    <li>
     
      Exceptions
     
     
      
       in coroutines
      
     
    </li>
   </ul>
   <p>
    
     This chapter is about C++ coroutines implemented without using any third-party libraries.
    
    
     This way of writing coroutines is quite low level and we need to write code to support
    
    
     
      the compiler.
     
    
   </p>
   <h1 id="_idParaDest-167">
    <a id="_idTextAnchor166">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     For this chapter, you will need a C++20 compiler.
    
    
     For the generator examples, you will need a C++23 compiler.
    
    
     We have tested the examples with GCC
    
    <strong class="source-inline">
     
      14.1
     
    </strong>
    
     .
    
    
     The code is platform-independent, so even though we have a Linux focus in this book, all the examples should work on macOS and Windows.
    
    
     Please note that Visual Studio
    
    <strong class="source-inline">
     
      17.11
     
    </strong>
    
     doesn’t support the C++23
    
    
     <strong class="source-inline">
      
       std::generator
      
     </strong>
    
    
     
      yet.
     
    
   </p>
   <p>
    
     The code for this chapter can be found in the book’s GitHub
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     
      
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-168">
    <a id="_idTextAnchor167">
    </a>
    
     Coroutines
    
   </h1>
   <p>
    
     Before we start implementing coroutines in C++, we will introduce coroutines conceptually and see how they can be useful in
    
    
     
      our programs.
     
    
   </p>
   <p>
    
     Let’s start with a definition.
    
    
     A
    
    <strong class="bold">
     
      coroutine
     
    </strong>
    
     is a function that can suspend itself.
    
    
     Coroutines suspend themselves
    
    <a id="_idIndexMarker552">
    </a>
    
     while waiting for an input value (while they are suspended, they don’t execute) or after yielding a value such as the result of a computation.
    
    
     Once the input value is available or the caller requests another value, the coroutine resumes execution.
    
    
     We will come back to coroutines in C++ soon, but let’s see with a real-life example how a
    
    
     
      coroutine works.
     
    
   </p>
   <p>
    
     Imagine someone working as an assistant.
    
    
     They start the day
    
    
     
      reading emails.
     
    
   </p>
   <p>
    
     One of the emails is a request for a report.
    
    
     After reading the email, they start writing the requested document.
    
    
     Once they have written the introductory paragraphs, they notice that they need another report from a colleague to get some accounting results from the previous quarter.
    
    
     They stop writing the report, write an email to their colleague requesting the needed information, and read the next email, which is a request to book a room for an important meeting in the afternoon.
    
    
     They open a special application the company has developed for booking meeting rooms automatically to optimize their use and book
    
    
     
      the room.
     
    
   </p>
   <p>
    
     After a while, they receive the required accounting data from their colleague and resume writing
    
    
     
      the report.
     
    
   </p>
   <p>
    
     The assistant is always busy working on their tasks.
    
    
     Writing the report is a good example of a coroutine: they start writing the report, then suspend the writing while they wait for the required information, and once the information arrives, they resume their writing.
    
    
     Of course, the assistant doesn’t want to waste their time, and while they wait, they go on doing other tasks.
    
    
     Their colleague can be seen as another coroutine if they wait for requests and then send the
    
    
     
      appropriate response.
     
    
   </p>
   <p>
    
     Now let’s go back to software.
    
    
     Let’s assume that we need to write a function that stores data in a database after processing some
    
    
     
      input information.
     
    
   </p>
   <p>
    
     If the data comes all at once, we can implement just a function.
    
    
     The function will read the input, perform the required processing on it, and finally, write the result to a database.
    
    
     But what if the data to be processed arrives in blocks and processing each block requires the result from the previous block processing (we can assume for the sake of this example that the first block processing needs only some
    
    
     
      default value)?
     
    
   </p>
   <p>
    
     A possible solution to our
    
    <a id="_idIndexMarker553">
    </a>
    
     problem would be to make the function wait for each data block, process it, store the result in the database, and then wait for the next one, and so on.
    
    
     But if we do that, we could potentially waste a lot of time while waiting for each block of data
    
    
     
      to arrive.
     
    
   </p>
   <p>
    
     After reading the previous chapters, you may be thinking about different potential solutions: we could create a thread to read the data, copy the blocks to a queue, and a second thread (maybe the main thread) will process the data.
    
    
     This is an acceptable solution but using multiple threads may
    
    
     
      be overkill.
     
    
   </p>
   <p>
    
     Another solution could be implementing a function to process only one block.
    
    
     The caller will wait for the input to be passed to the function and will keep the result of the previous block processing required to process each data block.
    
    
     In this solution, we must keep the state required by the data processing function in another function.
    
    
     It may be acceptable for a simple example, but once the processing gets more complicated (for example, requiring several steps with different intermediate results to be kept), the code might be difficult to understand
    
    
     
      and maintain.
     
    
   </p>
   <p>
    
     We can solve the problem with a coroutine.
    
    
     Let’s see some possible pseudocode for a coroutine that processes data in blocks and keeps
    
    
     
      intermediate results:
     
    
   </p>
   <pre class="source-code">
processing_result process_data(data_block data) {
    while (do_processing == true) {
        result_type result{ 0 };
        result = process_data_block(previous_result);
        update_database();
        yield result;
    }
}</pre>
   <p>
    
     The preceding coroutine receives a data block from the caller, performs all the processing, updates a database, and keeps the result required to process the next block.
    
    
     After yielding the result to the caller (more on yielding later), it suspends itself.
    
    
     Its execution will resume when the coroutine is called again by the caller requesting the processing of a new
    
    
     
      data block.
     
    
   </p>
   <p>
    
     A
    
    <a id="_idIndexMarker554">
    </a>
    
     coroutine such as this simplifies state management because it can keep the state
    
    
     
      between calls.
     
    
   </p>
   <p>
    
     After this conceptual introduction to coroutines, we are going to start implementing them
    
    
     
      in C++20.
     
    
   </p>
   <h1 id="_idParaDest-169">
    <a id="_idTextAnchor168">
    </a>
    
     C++ coroutines
    
   </h1>
   <p>
    
     As we have seen, coroutines are just functions, but they are not like the functions we are used to.
    
    
     They have special properties that we will study in this chapter.
    
    
     In this section, we will focus on coroutines
    
    <a id="_idIndexMarker555">
    </a>
    
     
      in C++.
     
    
   </p>
   <p>
    
     A function starts executing when it’s called and normally terminates with a return sentence or just when the function’s end
    
    
     
      is reached.
     
    
   </p>
   <p>
    
     A function runs from beginning to end.
    
    
     It may call another function (or even itself if it is recursive), and it may throw exceptions or have different return points.
    
    
     But it always runs from beginning
    
    
     
      to end.
     
    
   </p>
   <p>
    
     A coroutine is different.
    
    
     A coroutine is a function that can suspend itself.
    
    
     The flow for a coroutine may be like the
    
    <a id="_idIndexMarker556">
    </a>
    
     
      following pseudocode:
     
    
   </p>
   <pre class="source-code">
 void coroutine() {
    do_something();
    co_yield;
    do_something_else();
    co_yield;
    do_more_work();
    co_return;
}</pre>
   <p>
    
     We will see what those terms with the
    
    <strong class="source-inline">
     
      co_
     
    </strong>
    
     prefix
    
    
     
      mean soon.
     
    
   </p>
   <p>
    
     For a coroutine, we need a mechanism to keep the execution state to be able to suspend/resume the coroutine.
    
    
     This is done for us by the compiler, but we must write some
    
    <em class="italic">
     
      helping
     
    </em>
    
     code to let the compiler help
    
    
     
      us back.
     
    
   </p>
   <p>
    
     Coroutines in C++
    
    <a id="_idIndexMarker557">
    </a>
    
     are stackless.
    
    
     This means that the state we need to store to be able to suspend/resume the coroutine is stored in the heap calling
    
    <strong class="source-inline">
     
      new
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      delete
     
    </strong>
    
     to allocate/free dynamic memory.
    
    
     These calls are created by
    
    
     
      the compiler.
     
    
   </p>
   <h2 id="_idParaDest-170">
    <a id="_idTextAnchor169">
    </a>
    
     New keywords
    
   </h2>
   <p>
    
     Because a coroutine is essentially
    
    <a id="_idIndexMarker558">
    </a>
    
     a function (with some special properties, but a function nonetheless), the compiler needs some way to know whether a given function is a coroutine.
    
    
     C++20 introduced three new keywords:
    
    <strong class="source-inline">
     
      co_yield
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      co_return
     
    </strong>
    
     .
    
    
     If a function uses at least one of those three keywords, then the compiler knows it is
    
    
     
      a coroutine.
     
    
   </p>
   <p>
    
     The following table summarizes the functionality of the
    
    
     
      new keywords:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-3">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Keyword
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Input/Output
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Coroutine State
          
         </strong>
        
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           co_yield
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Output
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Suspended
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           co_await
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Input
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Suspended
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           co_return
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Output
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Terminated
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 8.1: New coroutine keywords
    
   </p>
   <p>
    
     In the preceding table, we see that after
    
    <strong class="source-inline">
     
      co_yield
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     , the coroutine suspends itself, and after
    
    <strong class="source-inline">
     
      co_return
     
    </strong>
    
     , it is terminated (
    
    <strong class="source-inline">
     
      co_return
     
    </strong>
    
     is the equivalent of the
    
    <strong class="source-inline">
     
      return
     
    </strong>
    
     statement in a C++ function).
    
    
     A coroutine cannot have a
    
    <strong class="source-inline">
     
      return
     
    </strong>
    
     statement; it must always use
    
    <strong class="source-inline">
     
      co_return
     
    </strong>
    
     .
    
    
     If the coroutine doesn’t return any value and any of the other two
    
    <a id="_idIndexMarker559">
    </a>
    
     coroutine keywords are used, the
    
    <strong class="source-inline">
     
      co_return
     
    </strong>
    
     statement can
    
    
     
      be omitted.
     
    
   </p>
   <h2 id="_idParaDest-171">
    <a id="_idTextAnchor170">
    </a>
    
     Coroutines restrictions
    
   </h2>
   <p>
    
     We have said that coroutines are functions using the new coroutines keywords.
    
    
     But coroutines have the
    
    
     
      following
     
    
    
     <a id="_idIndexMarker560">
     </a>
    
    
     
      restrictions:
     
    
   </p>
   <ul>
    <li>
     
      Functions with a variable number of arguments using
     
     <strong class="source-inline">
      
       varargs
      
     </strong>
     
      can’t be coroutines (a variadic function template can be
     
     
      
       a coroutine)
      
     
    </li>
    <li>
     
      A class constructor or destructor cannot be
     
     
      
       a coroutine
      
     
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       constexpr
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       consteval
      
     </strong>
     
      functions cannot
     
     
      
       be coroutines
      
     
    </li>
    <li>
     
      A function returning
     
     <strong class="source-inline">
      
       auto
      
     </strong>
     
      cannot be a coroutine but
     
     <strong class="source-inline">
      
       auto
      
     </strong>
     
      with a trailing return type
     
     
      
       can be
      
     
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       main()
      
     </strong>
     
      function cannot be
     
     
      
       a coroutine
      
     
    </li>
    <li>
     
      Lambdas can
     
     
      
       be coroutines
      
     
    </li>
   </ul>
   <p>
    
     After studying the restrictions of coroutines (basically what kind of C++ functions cannot be coroutines), we are going to start implementing coroutines in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-172">
    <a id="_idTextAnchor171">
    </a>
    
     Implementing basic coroutines
    
   </h1>
   <p>
    
     In the previous section, we studied the basics of coroutines, what they are, and some
    
    
     
      use cases.
     
    
   </p>
   <p>
    
     In this section, we will implement three simple
    
    <a id="_idIndexMarker561">
    </a>
    
     coroutines to illustrate the basics of implementing and working
    
    
     
      with them:
     
    
   </p>
   <ul>
    <li>
     
      The simplest coroutine that
     
     
      
       just returns
      
     
    </li>
    <li>
     
      A coroutine sending values back to
     
     
      
       the caller
      
     
    </li>
    <li>
     
      A coroutine getting values from
     
     
      
       the caller
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-173">
    <a id="_idTextAnchor172">
    </a>
    
     The simplest coroutine
    
   </h2>
   <p>
    
     We know that a
    
    <a id="_idIndexMarker562">
    </a>
    
     coroutine is
    
    <a id="_idIndexMarker563">
    </a>
    
     a function that can suspend itself and can be resumed by the caller.
    
    
     We also know that the compiler identifies a function as a coroutine if it uses at least one
    
    <strong class="source-inline">
     
      co_yield
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     , or
    
    
     <strong class="source-inline">
      
       co_return
      
     </strong>
    
    
     
      expression.
     
    
   </p>
   <p>
    
     The compiler will transform the coroutine source code and create some data structures and functions to make the coroutine functional and capable of being suspended and resumed.
    
    
     This is required to keep the coroutine state and be able to communicate with
    
    
     
      the coroutine.
     
    
   </p>
   <p>
    
     The compiler will take care of all those details but bear in mind that C++ support for coroutines is quite low level.
    
    
     There are
    
    <a id="_idIndexMarker564">
    </a>
    
     some libraries to make our lives easier when working with
    
    <a id="_idIndexMarker565">
    </a>
    
     coroutines in C++.
    
    
     Some of them are
    
    <strong class="bold">
     
      Lewis Baker’s cppcoro
     
    </strong>
    
     and
    
    <strong class="bold">
     
      Boost.Cobalt
     
    </strong>
    
     .
    
    
     The
    
    <strong class="bold">
     
      Boost.Asio
     
    </strong>
    
     library
    
    <a id="_idIndexMarker566">
    </a>
    
     has support for coroutines too.
    
    
     These libraries are the subject of the next
    
    
     
      two chapters.
     
    
   </p>
   <p>
    
     Let’s start from scratch.
    
    
     And we mean by absolute scratch.
    
    
     We will write some code and be guided by both compiler errors and the C++ reference to write a basic but fully
    
    
     
      functional coroutine.
     
    
   </p>
   <p>
    
     The following code is the simplest implementation of
    
    
     
      a coroutine:
     
    
   </p>
   <pre class="source-code">
void coro_func() {
    co_return;
}
int main() {
    coro_func();
}</pre>
   <p>
    
     Simple, isn’t it?
    
    
     Our
    
    <a id="_idIndexMarker567">
    </a>
    
     first coroutine will just return nothing.
    
    
     It will not do anything else.
    
    
     Sadly, the preceding code is too simple for a functional coroutine and will not compile.
    
    
     When compiling with GCC
    
    <strong class="source-inline">
     
      14.1
     
    </strong>
    
     , we get the
    
    
     
      following error:
     
    
   </p>
   <pre class="console">
error: coroutines require a traits template; cannot find 'std::coroutine_traits'</pre>
   <p>
    
     We also get the
    
    
     
      following note:
     
    
   </p>
   <pre class="console">
note: perhaps '#include &lt;coroutine&gt;' is missing</pre>
   <p>
    
     The compiler is giving us a hint: we
    
    <a id="_idIndexMarker568">
    </a>
    
     may have missed including a required file.
    
    
     Let’s include the
    
    <strong class="source-inline">
     
      &lt;coroutine&gt;
     
    </strong>
    
     header file.
    
    
     We’ll deal with the error about the traits template in
    
    
     
      a minute:
     
    
   </p>
   <pre class="source-code">
#include &lt;coroutine&gt;
void coro_func() {
    co_return;
}
int main() {
    coro_func();
}</pre>
   <p>
    
     When compiling the preceding code, we get the
    
    
     
      following error:
     
    
   </p>
   <pre class="console">
 error: unable to find the promise type for this coroutine</pre>
   <p>
    
     The first version of our coroutine gave us a compiler error saying that the type
    
    <strong class="source-inline">
     
      std::coroutine_traits
     
    </strong>
    
     template couldn’t be found.
    
    
     Now we get an error related to something called
    
    <a id="_idIndexMarker569">
    </a>
    
     the
    
    
     <em class="italic">
      
       promise type
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     Looking at the C++ reference, we see that the
    
    <strong class="source-inline">
     
      std::coroutine_traits
     
    </strong>
    
     template determines the return type and parameter types of a coroutine.
    
    
     The reference also states that the return type of a coroutine must define a type named
    
    <strong class="source-inline">
     
      promise_type
     
    </strong>
    
     .
    
    
     Following the reference advice, we can write a new version of
    
    
     
      our coroutine:
     
    
   </p>
   <pre class="source-code">
#include &lt;coroutine&gt;
struct return_type {
    struct promise_type {
    };
};
template&lt;&gt;
struct std::coroutine_traits&lt;return_type&gt; {
    using promise_type = return_type::promise_type;
};
return_type coro_func() {
    co_return;
}
int main() {
    coro_func();
}</pre>
   <p>
    
     Please note that the
    
    <a id="_idIndexMarker570">
    </a>
    
     return type
    
    <a id="_idIndexMarker571">
    </a>
    
     of a coroutine can have any name (we have called it
    
    <strong class="source-inline">
     
      return_type
     
    </strong>
    
     here because is convenient for this
    
    
     
      simple example).
     
    
   </p>
   <p>
    
     Compiling the preceding code again gives us some errors (they are edited for clarity).
    
    
     All the errors are about missing functions in the
    
    
     <strong class="source-inline">
      
       promise_type
      
     </strong>
    
    
     
      structure:
     
    
   </p>
   <pre class="console">
error: no member named 'return_void' in 'std::__n4861::coroutine_traits&lt;return_type&gt;::promise_type'
error: no member named 'initial_suspend' in 'std::__n4861::coroutine_traits&lt;return_type&gt;::promise_type'
error: no member named 'unhandled_exception' in 'std::__n4861::coroutine_traits&lt;return_type&gt;::promise_type'
error: no member named 'final_suspend' in 'std::__n4861::coroutine_traits&lt;return_type&gt;::promise_type'
error: no member named 'get_return_object' in 'std::__n4861::coroutine_traits&lt;return_type&gt;::promise_type'</pre>
   <p>
    
     All the
    
    <a id="_idIndexMarker572">
    </a>
    
     compiler errors we have seen until now are related to missing features in our code.
    
    
     Writing coroutines in C++ requires following some rules and helping the compiler to make its generated
    
    
     
      code functional.
     
    
   </p>
   <p>
    
     The following is the final
    
    <a id="_idIndexMarker573">
    </a>
    
     version of the
    
    
     
      simplest coroutine:
     
    
   </p>
   <pre class="source-code">
#include &lt;coroutine&gt;
struct return_type {
    struct promise_type {
        return_type get_return_object() noexcept {
            return return_type{ *this };
        }
        void return_void() noexcept {}
        std::suspend_always initial_suspend() noexcept {
            return {};
        }
        std::suspend_always final_suspend() noexcept {
            return {};
        }
        void unhandled_exception() noexcept {}
    };
    explicit return_type(promise_type&amp;) {
    }
    ~return_type() noexcept {
    }
};
return_type coro_func() {
    co_return;
}
int main() {
    coro_func();
}</pre>
   <p>
    
     You may have noticed that we have removed the
    
    <strong class="source-inline">
     
      std::coroutine_traits
     
    </strong>
    
     template.
    
    
     Implementing the return and promise types
    
    
     
      is enough.
     
    
   </p>
   <p>
    
     The
    
    <a id="_idIndexMarker574">
    </a>
    
     preceding
    
    <a id="_idIndexMarker575">
    </a>
    
     code compiles without any errors and you can run it.
    
    
     It does… nothing!
    
    
     But it’s our first coroutine and we have learned that we need to supply some code required by the compiler to create
    
    
     
      the coroutine.
     
    
   </p>
   <h3>
    
     The promise type
    
   </h3>
   <p>
    
     The
    
    <strong class="bold">
     
      promise type
     
    </strong>
    
     is
    
    <a id="_idIndexMarker576">
    </a>
    
     required
    
    <a id="_idIndexMarker577">
    </a>
    
     by the compiler.
    
    
     We need to always have this type defined (it can be either a class or a struct), it must be named
    
    <strong class="source-inline">
     
      promise_type
     
    </strong>
    
     , and it must implement some functions specified in the C++ reference.
    
    
     We have seen that if we don’t do that, the compiler will complain and give
    
    
     
      us errors.
     
    
   </p>
   <p>
    
     The promise
    
    <a id="_idIndexMarker578">
    </a>
    
     type must be defined inside the type returned by the
    
    <a id="_idIndexMarker579">
    </a>
    
     coroutine, otherwise the code will not compile.
    
    
     The
    
    <a id="_idIndexMarker580">
    </a>
    
     returned type (sometimes also called the
    
    <strong class="bold">
     
      wrapper type
     
    </strong>
    
     because it wraps
    
    <strong class="source-inline">
     
      promise_type
     
    </strong>
    
     ) can be
    
    
     
      named arbitrarily.
     
    
   </p>
   <h2 id="_idParaDest-174">
    <a id="_idTextAnchor173">
    </a>
    
     A yielding coroutine
    
   </h2>
   <p>
    
     A do-nothing coroutine is
    
    <a id="_idIndexMarker581">
    </a>
    
     good for illustrating some basic concepts.
    
    
     We will now
    
    <a id="_idIndexMarker582">
    </a>
    
     implement another coroutine that can send data back to
    
    
     
      the caller.
     
    
   </p>
   <p>
    
     In this second example, we will implement a coroutine that produces a message.
    
    
     It will be the “hello world” of coroutines.
    
    
     The coroutine will say hello and the caller function will print the message received from
    
    
     
      the coroutine.
     
    
   </p>
   <p>
    
     To implement that functionality, we need to establish a communication channel from the coroutine to the caller.
    
    
     This channel is the mechanism that allows the coroutine to pass values to the caller and receive information from it.
    
    
     This channel is established through the coroutine’s
    
    <strong class="bold">
     
      promise type
     
    </strong>
    
     and
    
    <strong class="bold">
     
      handle
     
    </strong>
    
     , which manages the state of
    
    
     
      the coroutine.
     
    
   </p>
   <p>
    
     The communication channel works in the
    
    
     
      following way:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Coroutine frame
      
     </strong>
     
      : When a coroutine is called, it creates
     
     <a id="_idIndexMarker583">
     </a>
     
      a
     
     <strong class="bold">
      
       coroutine frame
      
     </strong>
     
      , which contains all the state information needed to suspend and resume its execution.
     
     
      This includes local variables, the promise type, and any
     
     
      
       internal state.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Promise type
      
     </strong>
     
      : Each coroutine has an
     
     <a id="_idIndexMarker584">
     </a>
     
      associated
     
     <strong class="bold">
      
       promise type
      
     </strong>
     
      , which is responsible for managing the coroutine’s interaction with the caller functions.
     
     
      The promise is where the coroutine’s return value is stored, and it provides functions to control the coroutine’s behavior.
     
     
      We are going to see these functions in this chapter’s examples.
     
     
      The promise is the interface through which the caller interacts with
     
     
      
       the coroutine.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Coroutine handle
      
     </strong>
     
      : The
     
     <strong class="bold">
      
       coroutine handle
      
     </strong>
     
      is a type that gives access to the coroutine frame (the coroutine’s internal state) and allows the caller to resume or destroy the
     
     <a id="_idIndexMarker585">
     </a>
     
      coroutine.
     
     
      The handle is what the caller can use to resume the coroutine after it has been suspended (for example, after
     
     <strong class="source-inline">
      
       co_await
      
     </strong>
     
      or
     
     <strong class="source-inline">
      
       co_yield
      
     </strong>
     
      ).
     
     
      The handle can also be used to check whether the coroutine is done or to clean up
     
     
      
       its resources.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Suspend and resume mechanism
      
     </strong>
     
      : When a coroutine yields a value (
     
     <strong class="source-inline">
      
       co_yield
      
     </strong>
     
      ) or awaits an asynchronous operation (
     
     <strong class="source-inline">
      
       co_await
      
     </strong>
     
      ), it suspends its execution, saving its state in the
     
     <a id="_idIndexMarker586">
     </a>
     
      coroutine frame.
     
     
      The caller can then resume the coroutine at a later point, retrieving the yielded or awaited value through the coroutine handle and continuing
     
     
      
       the execution.
      
     
    </li>
   </ul>
   <p>
    
     We are going to see, in the following examples, that this communication channel requires a considerable amount of code on our side to help the compiler generate all the code required for a coroutine to
    
    
     
      be functional.
     
    
   </p>
   <p>
    
     The following
    
    <a id="_idIndexMarker587">
    </a>
    
     code is the new version of both the caller function and
    
    
     
      the
     
    
    
     <a id="_idIndexMarker588">
     </a>
    
    
     
      coroutine:
     
    
   </p>
   <pre class="source-code">
return_type coro_func() {
    co_yield "Hello from the coroutine\n"s;
    co_return;
}
int main() {
    auto rt = coro_func();
    std::cout &lt;&lt; rt.get() &lt;&lt; std::endl;
    return 0;
}</pre>
   <p>
    
     The
    
    <a id="_idIndexMarker589">
    </a>
    
     changes are
    
    <a id="_idIndexMarker590">
    </a>
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       [1]
      
     </strong>
     
      : The coroutine
     
     <em class="italic">
      
       yields
      
     </em>
     
      and sends some data (in this case, a
     
     <strong class="source-inline">
      
       std::string
      
     </strong>
     
      object) to
     
     
      
       the caller
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       [2]
      
     </strong>
     
      : The caller reads that data and
     
     
      
       prints it
      
     
    </li>
   </ul>
   <p>
    
     The required communication mechanism is implemented in the promise type and in the return type (which is a promise
    
    
     
      type wrapper).
     
    
   </p>
   <p>
    
     When the compiler reads the
    
    <strong class="source-inline">
     
      co_yield
     
    </strong>
    
     expression, it will generate a call to the
    
    <strong class="source-inline">
     
      yield_value
     
    </strong>
    
     function defined in the
    
    
     
      promise type.
     
    
   </p>
   <p>
    
     The following code is the implementation for our version of that function that generates (or yields) a
    
    
     <strong class="source-inline">
      
       std::string
      
     </strong>
    
    
     
      object:
     
    
   </p>
   <pre class="source-code">
std::suspend_always yield_value(std::string msg) noexcept {
    output_data = std::move(msg);
    return {};
}</pre>
   <p>
    
     The function gets a
    
    <strong class="source-inline">
     
      std::string
     
    </strong>
    
     object and moves it to the
    
    <strong class="source-inline">
     
      output_data
     
    </strong>
    
     member variable of the promise type.
    
    
     But this just keeps the data inside the promise type.
    
    
     We need a mechanism to get that string out of
    
    
     
      the coroutine.
     
    
   </p>
   <h3>
    
     The handle type
    
   </h3>
   <p>
    
     Once we require a communication channel to and from a coroutine, we need a way to refer to a suspended or executing coroutine.
    
    
     The C++ standard library implements such a mechanism in what is called
    
    <a id="_idIndexMarker591">
    </a>
    
     a
    
    <strong class="bold">
     
      coroutine handle
     
    </strong>
    
     .
    
    
     Its type is
    
    <strong class="source-inline">
     
      std::coroutine_handle
     
    </strong>
    
     and it’s a member variable of the return type.
    
    
     This structure is also responsible for the full life cycle of the handle, creating and
    
    
     
      destroying it.
     
    
   </p>
   <p>
    
     The following code snippet is the functionality we added to our return type to manage a
    
    
     
      coroutine handle:
     
    
   </p>
   <pre class="source-code">
std::coroutine_handle&lt;promise_type&gt; handle{};
explicit return_type(promise_type&amp; promise) : handle{ std::coroutine_handle&lt;promise_type&gt;::from_promise(promise)} {
}
~return_type() noexcept {
    if (handle) {
        handle.destroy();
    }
}</pre>
   <p>
    
     The preceding code declares a coroutine handle of type
    
    <strong class="source-inline">
     
      std::coroutine_handle&lt;promise_type&gt;
     
    </strong>
    
     and creates the handle in the return type constructor.
    
    
     The handle is destroyed in the return
    
    
     
      type destructor.
     
    
   </p>
   <p>
    
     Now, back to our yielding coroutine.
    
    
     The only missing bit is the
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     function for the caller function to be able to access the string generated by
    
    
     
      the coroutine:
     
    
   </p>
   <pre class="source-code">
std::string get() {
    if (!handle.done()) {
        handle.resume();
    }
    return std::move(handle.promise().output_data);
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     function
    
    <a id="_idIndexMarker592">
    </a>
    
     resumes the coroutine if it is not terminated and then returns the
    
    
     
      string object.
     
    
   </p>
   <p>
    
     The following is the full code for our
    
    
     
      second coroutine:
     
    
   </p>
   <pre class="source-code">
#include &lt;coroutine&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std::string_literals;
struct return_type {
    struct promise_type {
        std::string output_data { };
        return_type get_return_object() noexcept {
            std::cout &lt;&lt; "get_return_object\n";
            return return_type{ *this };
        }
        void return_void() noexcept {
            std::cout &lt;&lt; "return_void\n";
        }
        std::suspend_always yield_value(
                         std::string msg) noexcept {
            std::cout &lt;&lt; "yield_value\n";
            output_data = std::move(msg);
            return {};
        }
        std::suspend_always initial_suspend() noexcept {
            std::cout &lt;&lt; "initial_suspend\n";
            return {};
        }
        std::suspend_always final_suspend() noexcept {
            std::cout &lt;&lt; "final_suspend\n";
            return {};
        }
        void unhandled_exception() noexcept {
            std::cout &lt;&lt; "unhandled_exception\n";
        }
    };
    std::coroutine_handle&lt;promise_type&gt; handle{};
    explicit return_type(promise_type&amp; promise)
       : handle{ std::coroutine_handle&lt;
                 promise_type&gt;::from_promise(promise)}{
        std::cout &lt;&lt; "return_type()\n";
    }
    ~return_type() noexcept {
        if (handle) {
            handle.destroy();
        }
        std::cout &lt;&lt; "~return_type()\n";
    }
    std::string get() {
        std::cout &lt;&lt; "get()\n";
        if (!handle.done()) {
            handle.resume();
        }
        return std::move(handle.promise().output_data);
    }
};
return_type coro_func() {
    co_yield "Hello from the coroutine\n"s;
    co_return;
}
int main() {
    auto rt = coro_func();
    std::cout &lt;&lt; rt.get() &lt;&lt; std::endl;
    return 0;
}</pre>
   <p>
    
     Running the
    
    <a id="_idIndexMarker593">
    </a>
    
     preceding code prints the
    
    
     
      following messages:
     
    
   </p>
   <pre class="console">
get_return_object
return_type()
initial_suspend
get()
yield_value
Hello from the coroutine
~return_type()</pre>
   <p>
    
     This output shows
    
    <a id="_idIndexMarker594">
    </a>
    
     us what is happening during the
    
    
     
      coroutine execution:
     
    
   </p>
   <ol>
    <li>
     
      The
     
     <strong class="source-inline">
      
       return_type
      
     </strong>
     
      object is created after a call
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        get_return_object
       
      </strong>
     
    </li>
    <li>
     
      The coroutine is
     
     
      
       initially suspended
      
     
    </li>
    <li>
     
      The caller wants to get the message from the coroutine, so
     
     <strong class="source-inline">
      
       get()
      
     </strong>
     
      
       is called
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       yield_value
      
     </strong>
     
      is called and the coroutine is resumed and the message is copied to a member variable in
     
     
      
       the promise
      
     
    </li>
    <li>
     
      Finally, the message is printed by the caller function, and the
     
     
      
       coroutine returns
      
     
    </li>
   </ol>
   <p>
    
     Note that the promise (and promise type) have nothing to do with the C++ Standard Library
    
    <strong class="source-inline">
     
      std::promise
     
    </strong>
    
     type explained in
    
    
     <em class="italic">
      
       Chapter 6
      
     </em>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-175">
    <a id="_idTextAnchor174">
    </a>
    
     A waiting coroutine
    
   </h2>
   <p>
    
     In the previous example, we saw
    
    <a id="_idIndexMarker595">
    </a>
    
     how to implement a coroutine that can communicate
    
    <a id="_idIndexMarker596">
    </a>
    
     back to the caller by sending it a
    
    <strong class="source-inline">
     
      std::string
     
    </strong>
    
     object.
    
    
     Now, we are going to implement a coroutine that can wait for input data sent by the caller.
    
    
     In our example, the coroutine will wait until it gets a
    
    <strong class="source-inline">
     
      std::string
     
    </strong>
    
     object and then print it.
    
    
     When we say that the coroutine “waits,” we mean it is suspended (that is, not executing) until the data
    
    
     
      is received.
     
    
   </p>
   <p>
    
     Let’s start with changes to both the coroutine and the
    
    
     
      caller function:
     
    
   </p>
   <pre class="source-code">
return_type coro_func() {
    std::cout &lt;&lt; co_await std::string{ };
    co_return;
}
int main() {
    auto rt = coro_func();
    rt.put("Hello from main\n"s);
    return 0;
}</pre>
   <p>
    
     In the preceding code, the caller function calls the
    
    <strong class="source-inline">
     
      put()
     
    </strong>
    
     function (a method in the return type structure) and the coroutine calls
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     to wait for a
    
    <strong class="source-inline">
     
      std::string
     
    </strong>
    
     object from
    
    
     
      the caller.
     
    
   </p>
   <p>
    
     The changes to the return type are simple, that is, just adding the
    
    
     <strong class="source-inline">
      
       put()
      
     </strong>
    
    
     
      function:
     
    
   </p>
   <pre class="source-code">
void put(std::string msg) {
    handle.promise().input_data = std::move(msg);
    if (!handle.done()) {
        handle.resume();
    }
}</pre>
   <p>
    
     We need to add
    
    <a id="_idIndexMarker597">
    </a>
    
     the
    
    <strong class="source-inline">
     
      input_data
     
    </strong>
    
     variable to the promise structure.
    
    
     But just
    
    <a id="_idIndexMarker598">
    </a>
    
     with those changes to our first example (we take it as the starting point for the rest of the examples in this chapter because it’s the minimum code to implement a coroutine) and the coroutine handle from the previous example, the code cannot be compiled.
    
    
     The compiler gives us the
    
    
     
      following error:
     
    
   </p>
   <pre class="console">
error: no member named 'await_ready' in 'std::string' {aka 'std::__cxx11::basic_string&lt;char&gt;'}</pre>
   <p>
    
     Going back to the C++ reference, we see that when the coroutine calls
    
    <strong class="source-inline">
     
      co_await
     
    </strong>
    
     , the compiler will generate code to call a function in the promise object called
    
    <strong class="source-inline">
     
      await_transform
     
    </strong>
    
     , which has a parameter of the same type as the data the coroutine is waiting for.
    
    
     As its name implies,
    
    <strong class="source-inline">
     
      await_transform
     
    </strong>
    
     is a function that transforms any object (in our example,
    
    <strong class="source-inline">
     
      std::string
     
    </strong>
    
     ) into an awaitable object.
    
    <strong class="source-inline">
     
      std::string
     
    </strong>
    
     is not awaitable, hence the previous
    
    
     
      compiler error.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      await_transform
     
    </strong>
    
     must return
    
    <a id="_idIndexMarker599">
    </a>
    
     an
    
    <strong class="bold">
     
      awaiter
     
    </strong>
    
     object.
    
    
     This is just a simple struct implementing a required interface for the awaiter to be usable by
    
    
     
      the compiler.
     
    
   </p>
   <p>
    
     The following
    
    <a id="_idIndexMarker600">
    </a>
    
     code shows our implementation of the
    
    <strong class="source-inline">
     
      await_transform
     
    </strong>
    
     function
    
    <a id="_idIndexMarker601">
    </a>
    
     and the
    
    
     <strong class="source-inline">
      
       awaiter
      
     </strong>
    
    
     
      struct:
     
    
   </p>
   <pre class="source-code">
auto await_transform(std::string) noexcept {
    struct awaiter {
        promise_type&amp; promise;
        bool await_ready() const noexcept {
            return true;
        }
        std::string await_resume() const noexcept {
            return std::move(promise.input_data);
        }
        void await_suspend(std::coroutine_handle&lt;
                           promise_type&gt;) const noexcept {
        }
   };
   return awaiter(*this);
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      promise_type
     
    </strong>
    
     function
    
    <strong class="source-inline">
     
      await_transform
     
    </strong>
    
     is required by the compiler.
    
    
     We cannot use a different identifier for this function.
    
    
     The parameter type must be the same as the object the coroutine is waiting for.
    
    
     The
    
    <strong class="source-inline">
     
      awaiter
     
    </strong>
    
     struct can be named with any name.
    
    
     We used
    
    <strong class="source-inline">
     
      awaiter
     
    </strong>
    
     here because is descriptive.
    
    
     The
    
    <strong class="source-inline">
     
      awaiter
     
    </strong>
    
     struct must implement
    
    
     
      three functions:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       await_ready
      
     </strong>
     
      : This is called to check whether the coroutine is suspended.
     
     
      If that is the case, it returns
     
     <strong class="source-inline">
      
       false
      
     </strong>
     
      .
     
     
      In our example, it always returns
     
     <strong class="source-inline">
      
       true
      
     </strong>
     
      to indicate the coroutine is
     
     
      
       not suspended.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       await_resume
      
     </strong>
     
      : This resumes the coroutine and generates the result of the
     
     
      <strong class="source-inline">
       
        co_await
       
      </strong>
     
     
      
       expression.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       await_suspend
      
     </strong>
     
      : In our simple awaiter, this returns
     
     <strong class="source-inline">
      
       void
      
     </strong>
     
      , meaning the control is passed to the caller and the coroutine is suspended.
     
     
      It’s also possible for
     
     <strong class="source-inline">
      
       await_suspend
      
     </strong>
     
      to return a Boolean.
     
     
      Returning
     
     <strong class="source-inline">
      
       true
      
     </strong>
     
      in this case is like returning
     
     <strong class="source-inline">
      
       void
      
     </strong>
     
      .
     
     
      Returning
     
     <strong class="source-inline">
      
       false
      
     </strong>
     
      means the coroutine
     
     
      
       is resumed.
      
     
    </li>
   </ul>
   <p>
    
     This is the code for
    
    <a id="_idIndexMarker602">
    </a>
    
     the full
    
    <a id="_idIndexMarker603">
    </a>
    
     example of the
    
    
     
      waiting coroutine:
     
    
   </p>
   <pre class="source-code">
#include &lt;coroutine&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std::string_literals;
struct return_type {
    struct promise_type {
        std::string input_data { };
        return_type get_return_object() noexcept {
            return return_type{ *this };
        }
        void return_void() noexcept {
        }
        std::suspend_always initial_suspend() noexcept {
            return {};
        }
        std::suspend_always final_suspend() noexcept {
            return {};
        }
        void unhandled_exception() noexcept {
        }
        auto await_transform(std::string) noexcept {
            struct awaiter {
                promise_type&amp; promise;
                bool await_ready() const noexcept {
                    return true;
                }
                std::string await_resume() const noexcept {
                    return std::move(promise.input_data);
                }
                void await_suspend(std::coroutine_handle&lt;
                                  promise_type&gt;) const noexcept {
                }
            };
            return awaiter(*this);
        }
    };
    std::coroutine_handle&lt;promise_type&gt; handle{};
    explicit return_type(promise_type&amp; promise)
      : handle{ std::coroutine_handle&lt;
                         promise_type&gt;::from_promise(promise)} {
    }
    ~return_type() noexcept {
        if (handle) {
            handle.destroy();
        }
    }
    void put(std::string msg) {
        handle.promise().input_data = std::move(msg);
        if (!handle.done()) {
            handle.resume();
        }
    }
};
return_type coro_func() {
    std::cout &lt;&lt; co_await std::string{ };
    co_return;
}
int main() {
    auto rt = coro_func();
    rt.put("Hello from main\n"s);
    return 0;
}</pre>
   <p>
    
     In this section, we have seen three basic examples of coroutines.
    
    
     We have implemented the simplest coroutine and then coroutines with communication channels to both generate data for the caller (
    
    <strong class="source-inline">
     
      co_yield
     
    </strong>
    
     ) and wait for data from the
    
    
     
      caller (
     
    
    
     <strong class="source-inline">
      
       co_await
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     In the next section, we will implement a type of coroutine called a generator and generate sequences
    
    
     
      of numbers.
     
    
   </p>
   <h1 id="_idParaDest-176">
    <a id="_idTextAnchor175">
    </a>
    
     Coroutine generators
    
   </h1>
   <p>
    
     A
    
    <strong class="bold">
     
      generator
     
    </strong>
    
     is a
    
    <a id="_idIndexMarker604">
    </a>
    
     coroutine that
    
    <a id="_idIndexMarker605">
    </a>
    
     generates a sequence of elements by repeatedly resuming itself from the point that it
    
    
     
      was suspended.
     
    
   </p>
   <p>
    
     A generator can be seen as an
    
    <em class="italic">
     
      infinite
     
    </em>
    
     sequence because it can generate an arbitrary number of elements.
    
    
     The caller function can get as many new elements from the generator as
    
    
     
      it needs.
     
    
   </p>
   <p>
    
     When we say infinite, we mean in theory.
    
    
     A generator coroutine will yield elements without a definite last element (it is possible to implement generators with a limited range) but, in practice, we must deal with issues such as overflow in the case of
    
    
     
      numerical sequences.
     
    
   </p>
   <p>
    
     Let’s implement a generator from scratch, applying the knowledge we have gained in the previous sections of
    
    
     
      this chapter.
     
    
   </p>
   <h2 id="_idParaDest-177">
    <a id="_idTextAnchor176">
    </a>
    
     Fibonacci sequence generator
    
   </h2>
   <p>
    
     Imagine we are implementing
    
    <a id="_idIndexMarker606">
    </a>
    
     an application and we need to use the Fibonacci sequence.
    
    
     As you probably already know, the
    
    <strong class="bold">
     
      Fibonacci sequence
     
    </strong>
    
     is a
    
    <a id="_idIndexMarker607">
    </a>
    
     sequence in which each number is the sum of the two preceding ones.
    
    
     The first element is 0, the second element is 1, and then we apply the definition and generate element
    
    
     
      after element.
     
    
   </p>
   <p>
    
     <img alt="&lt;math  display=&quot;block&quot;&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mfenced&gt;&lt;mo&gt;;&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mfenced open=&quot;(&quot; close=&quot;)&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mfenced&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;/math&gt;" src="img/12.png" style="vertical-align:-0.254em;height:0.965em;width:29.022em"/>
    
   </p>
   <p>
    
     We can always
    
    <a id="_idIndexMarker608">
    </a>
    
     generate these numbers with a
    
    <strong class="source-inline">
     
      for
     
    </strong>
    
     loop.
    
    
     But if we need to generate them at different points in our program, we need to implement a way to store the state of the sequence.
    
    
     We need to keep somewhere in our program what the last element we generated was.
    
    
     Was it the fifth or maybe the
    
    
     
      tenth element?
     
    
   </p>
   <p>
    
     A coroutine is a very good solution for this problem; it will keep the required state itself and it will suspend until we request the next number in
    
    
     
      the sequence.
     
    
   </p>
   <p>
    
     Here’s the code using a
    
    
     
      generator coroutine:
     
    
   </p>
   <pre class="source-code">
int main() {
    sequence_generator&lt;int64_t&gt; fib = fibonacci();
    std::cout &lt;&lt; "Generate ten Fibonacci numbers\n"s;
    for (int i = 0; i &lt; 10; ++i) {
        fib.next();
        std::cout &lt;&lt; fib.value() &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; "Generate ten more\n"s;
    for (int i = 0; i &lt; 10; ++i) {
        fib.next();
        std::cout &lt;&lt; fib.value() &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; "Let's do five more\n"s;
    for (int i = 0; i &lt; 5; ++i) {
        fib.next();
        std::cout &lt;&lt; fib.value() &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</pre>
   <p>
    
     As you can see in the preceding code, we generate the numbers we need without worrying about what the last element was.
    
    
     The sequence is generated by
    
    
     
      the coroutine.
     
    
   </p>
   <p>
    
     Note that even though in theory the sequence is infinite, our program must be aware of potential overflow for very big
    
    
     
      Fibonacci numbers.
     
    
   </p>
   <p>
    
     To implement the
    
    <a id="_idIndexMarker609">
    </a>
    
     generator coroutine, we follow the
    
    <a id="_idIndexMarker610">
    </a>
    
     principles explained previously in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     First, we implement the
    
    
     
      coroutine function:
     
    
   </p>
   <pre class="source-code">
sequence_generator&lt;int64_t&gt; fibonacci() {
    int64_t a{ 0 };
    int64_t b{ 1 };
    int64_t c{ 0 };
    while (true) {
        co_yield a;
        c = a + b;
        a = b;
        b = c;
    }
}</pre>
   <p>
    
     The coroutine just generates the next element in the Fibonacci sequence by applying the formula.
    
    
     The elements are generated in an infinite loop, but the coroutine suspends itself
    
    
     
      after
     
    
    
     <strong class="source-inline">
      
       co_yield
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The return type is the
    
    <strong class="source-inline">
     
      sequence_generator
     
    </strong>
    
     struct (we use a template to be able to use either 32- or 64-bit integers).
    
    
     It contains a promise type, pretty much like the one in the yielding coroutine we saw in a
    
    
     
      previous section.
     
    
   </p>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      sequence_generator
     
    </strong>
    
     struct, we added two functions that are useful when implementing a
    
    
     
      sequence generator.
     
    
   </p>
   <pre class="source-code">
void next() {
    if (!handle.done()) {
        handle.resume();
    }
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      next()
     
    </strong>
    
     function resumes the coroutine for a new Fibonacci number in the sequence to
    
    
     
      be generated.
     
    
   </p>
   <pre class="source-code">
int64_t value() {
    return handle.promise().output_data;
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      value()
     
    </strong>
    
     function returns the last generated
    
    
     
      Fibonacci number.
     
    
   </p>
   <p>
    
     This way, we
    
    <a id="_idIndexMarker611">
    </a>
    
     decouple element generation and its
    
    
     
      retrieval Qvalue.
     
    
   </p>
   <p>
    
     Please find the full code for this example in the book’s accompanying
    
    
     
      GitHub repository.
     
    
   </p>
   <h3>
    
     C++23 std::generator
    
   </h3>
   <p>
    
     We have seen that implementing even the most basic coroutine in C++ requires a certain amount of code.
    
    
     This may change in C++26 with more support for coroutines in the C++ Standard Library, which will allow us to write coroutines much
    
    
     
      more easily.
     
    
   </p>
   <p>
    
     C++23 introduced
    
    <a id="_idIndexMarker612">
    </a>
    
     the
    
    <strong class="source-inline">
     
      std::generator
     
    </strong>
    
     template class.
    
    
     By using it, we can write coroutine-based generators without writing any of the required code, such as the promise type, the return type, and all their functions.
    
    
     To run this example, you will need a C++23 compiler.
    
    
     We have used GCC 14.1.
    
    <strong class="source-inline">
     
      std::generator
     
    </strong>
    
     is not available
    
    
     
      in Clang.
     
    
   </p>
   <p>
    
     Let’s see the
    
    <a id="_idIndexMarker613">
    </a>
    
     Fibonacci sequence generator using the new C++23 Standard
    
    
     
      Library features:
     
    
   </p>
   <pre class="source-code">
#include &lt;generator&gt;
#include &lt;iostream&gt;
std::generator&lt;int&gt; fibonacci_generator() {
    int a{ };
    int b{ 1 };
    while (true) {
        co_yield a;
        int c = a + b;
        a = b;
        b = c;
    }
}
auto fib = fibonacci_generator();
int main() {
    int i = 0;
    for (auto f = fib.begin(); f != fib.end(); ++f) {
        if (i == 10) {
            break;
        }
        std::cout &lt;&lt; *f &lt;&lt; " ";
        ++i;
    }
    std::cout &lt;&lt; std::endl;
}</pre>
   <p>
    
     The first step is to include the
    
    <strong class="source-inline">
     
      &lt;generator&gt;
     
    </strong>
    
     header file.
    
    
     Then, we just write the coroutine because all the rest of the required code has been written for us.
    
    
     In the preceding code, we access the generated elements with an iterator (which is provided by the C++ Standard Library).
    
    
     This allows us to use a range-for loop, algorithms,
    
    
     
      and ranges.
     
    
   </p>
   <p>
    
     It is also possible to
    
    <a id="_idIndexMarker614">
    </a>
    
     write a version of the Fibonacci generator to generate a certain number of elements instead of an
    
    
     
      infinite series:
     
    
   </p>
   <pre class="source-code">
std::generator&lt;int&gt; fibonacci_generator(int limit) {
    int a{ };
    int b{ 1 };
    while (limit--) {
        co_yield a;
        int c = a + b;
        a = b;
        b = c;
    }
}</pre>
   <p>
    
     The code changes are very simple: just pass the number of elements we want the generator to generate and use it as the termination condition in the
    
    
     <strong class="source-inline">
      
       while
      
     </strong>
    
    
     
      loop.
     
    
   </p>
   <p>
    
     In this section, we have implemented one of the most common coroutine types – a generator.
    
    
     We have implemented generators both from scratch and using the C++23
    
    <strong class="source-inline">
     
      std::generator
     
    </strong>
    
     
      class template.
     
    
   </p>
   <p>
    
     We will implement a simple string parser coroutine in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-178">
    <a id="_idTextAnchor177">
    </a>
    
     Simple coroutine string parser
    
   </h1>
   <p>
    
     In this section, we will
    
    <a id="_idIndexMarker615">
    </a>
    
     implement our last example: a simple string parser.
    
    
     The coroutine will wait for the input, a
    
    <strong class="source-inline">
     
      std::string
     
    </strong>
    
     object, and will yield the output, a number, after parsing the input string.
    
    
     To simplify the example, we will assume that the string representation of the number doesn’t have any errors and that the end of a number is represented by the hash character,
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     .
    
    
     We will also assume that the number type is
    
    <strong class="source-inline">
     
      int64_t
     
    </strong>
    
     and that the string won’t contain any values out of that integer
    
    
     
      type range.
     
    
   </p>
   <h2 id="_idParaDest-179">
    <a id="_idTextAnchor178">
    </a>
    
     The parsing algorithm
    
   </h2>
   <p>
    
     Let’s see how to convert a
    
    <a id="_idIndexMarker616">
    </a>
    
     string representing an integer into a number.
    
    
     For example, the string
    
    <strong class="source-inline">
     
      "-12321#"
     
    </strong>
    
     represents the number -12321.
    
    
     To convert the string into a number, we can write a function
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
int64_t parse_string(const std::string&amp; str) {
    int64_t num{ 0 };
    int64_t sign { 1 };
    std::size_t c = 0;
    while (c &lt; str.size()) {
        if (str[c] == '-') {
            sign = -1;
        }
        else if (std::isdigit(str[c])) {
            num = num * 10 + (str[c] - '0');
        }
        else if (str[c] == '#') {
            break;
        }
        ++c;
    }
    return num * sign;
}</pre>
   <p>
    
     The code is
    
    <a id="_idIndexMarker617">
    </a>
    
     quite simple because of the assumption that the string is well formed.
    
    
     If we read the minus sign,
    
    <strong class="source-inline">
     
      -
     
    </strong>
    
     , then we change the sign to -1 (by default, we assume positive numbers, and if there is a
    
    <strong class="source-inline">
     
      +
     
    </strong>
    
     sign, it is simply ignored).
    
    
     Then, the digits are read one by one, and the number value is calculated
    
    
     
      as follows.
     
    
   </p>
   <p>
    
     The initial value of
    
    <strong class="source-inline">
     
      num
     
    </strong>
    
     is
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     .
    
    
     We read the first digit and add its numeric value to the current
    
    <strong class="source-inline">
     
      num
     
    </strong>
    
     value multiplied by 10.
    
    
     This is the way we read numbers: the leftmost digit will be multiplied by 10 as many times as the number of digits to
    
    
     
      its right.
     
    
   </p>
   <p>
    
     When we use characters to represent digits, they have some value according to the ASCII representation (we assume no wide characters or any other character type is used).
    
    
     The characters
    
    <em class="italic">
     
      0
     
    </em>
    
     to
    
    <em class="italic">
     
      9
     
    </em>
    
     have consecutive ASCII codes, so we can easily convert them to numbers by just
    
    
     
      subtracting
     
    
    
     <em class="italic">
      
       0
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     Even if for the preceding code the last character check is not necessary, we have included it here.
    
    
     When the parser routine finds the
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     character, it terminates the parsing loop and returns the final
    
    
     
      number value.
     
    
   </p>
   <p>
    
     We can use this function to parse any string and get the number value, but we need the full string to convert it into
    
    
     
      a number.
     
    
   </p>
   <p>
    
     Let’s think about this scenario: the string is being received from a network connection and we need to parse it and convert it into a number.
    
    
     We may save the characters to a temporary string and then call the
    
    
     
      preceding function.
     
    
   </p>
   <p>
    
     But there is another issue: what if the characters arrive slowly, such as once every few seconds, because that’s the way they are transmitted?
    
    
     We want to keep our CPU busy and, if possible, do
    
    <a id="_idIndexMarker618">
    </a>
    
     some other task (or tasks) while waiting for each character
    
    
     
      to arrive.
     
    
   </p>
   <p>
    
     There are different approaches to solving this problem.
    
    
     We can create a thread and process the string concurrently, but this can be costly in computer time for such a simple task.
    
    
     We can use
    
    
     <strong class="source-inline">
      
       std::async
      
     </strong>
    
    
     
      too.
     
    
   </p>
   <h2 id="_idParaDest-180">
    <a id="_idTextAnchor179">
    </a>
    
     The parsing coroutine
    
   </h2>
   <p>
    
     We are working with
    
    <a id="_idIndexMarker619">
    </a>
    
     coroutines in this chapter, so we will implement the string parser using C++ coroutines.
    
    
     We don’t need an extra thread, and because of the asynchronous nature of coroutines, it will be quite easy to perform any other processing while the
    
    
     
      characters arrive.
     
    
   </p>
   <p>
    
     The boilerplate code we will need for the parsing coroutine is pretty much the same as the code we have already seen in the previous examples.
    
    
     The parser itself is quite different.
    
    
     See the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
async_parse&lt;int64_t, char&gt; parse_string() {
    while (true) {
        char c = co_await char{ };
        int64_t number { };
        int64_t sign { 1 };
        if (c != '-' &amp;&amp; c != '+' &amp;&amp; !std::isdigit(c)) {
            continue;
        }
        if (c == '-') {
            sign = -1;
        }
        else if (std::isdigit(c)) {
            number = number * 10 + c - '0';
        }
        while (true) {
            c = co_await char{};
            if (std::isdigit(c)) {
                number = number * 10 + c - '0';
            }
            else {
                break;
            }
        }
        co_yield number * sign;
    }
}</pre>
   <p>
    
     I think that you can now easily recognize the return type (
    
    <strong class="source-inline">
     
      async_parse&lt;int64_t, char&gt;
     
    </strong>
    
     ) and that the parser coroutine suspends itself waiting for an input character.
    
    
     The coroutine will suspend itself after yielding the number once the parsing has
    
    
     
      been done.
     
    
   </p>
   <p>
    
     But you can see too that the preceding code is not as simple as our first attempt at parsing a string into
    
    
     
      a number.
     
    
   </p>
   <p>
    
     First, the parser coroutine parses one character after another.
    
    
     It doesn’t get the full string to parse, hence the infinite
    
    <strong class="source-inline">
     
      while (true)
     
    </strong>
    
     loops.
    
    
     We don’t know how many characters there are in the full string, so we need to keep on receiving and
    
    
     
      parsing them.
     
    
   </p>
   <p>
    
     The outer loop means that
    
    <a id="_idIndexMarker620">
    </a>
    
     the coroutine will parse numbers, one after another, as the characters arrive – forever.
    
    
     But remember that it suspends itself to wait for the characters, so we don’t waste
    
    
     
      CPU time.
     
    
   </p>
   <p>
    
     Now, one character arrives.
    
    
     The first check is to see whether it is a valid character for our number.
    
    
     If the character is not either the minus sign,
    
    <strong class="source-inline">
     
      -
     
    </strong>
    
     , the plus sign,
    
    <strong class="source-inline">
     
      +
     
    </strong>
    
     , or a digit, then the parser waits for the
    
    
     
      next character.
     
    
   </p>
   <p>
    
     If the next character is a valid one, then the
    
    
     
      following apply:
     
    
   </p>
   <ul>
    <li>
     
      If it is the minus sign, we change the sign value
     
     
      
       to -1
      
     
    </li>
    <li>
     
      If it is the plus sign, we
     
     
      
       ignore it
      
     
    </li>
    <li>
     
      If it is a digit, we parse it into the number, updating the current number value using the same method as we saw in the first version of
     
     
      
       the parser
      
     
    </li>
   </ul>
   <p>
    
     After the first valid character, we enter a new loop to receive the rest of the characters, either digits or the separator character (
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     ).
    
    
     Note here that when we say valid character, we mean good for numerical conversion.
    
    
     We are still assuming that the input characters form a valid number that is
    
    
     
      correctly terminated.
     
    
   </p>
   <p>
    
     Once the number has been converted, it is yielded by the coroutine and the outer loop executes again.
    
    
     The terminating character is needed here because the input character stream is, in theory, endless, and it can contain
    
    
     
      many numbers.
     
    
   </p>
   <p>
    
     The code for the rest of the coroutine can be found in the GitHub repo.
    
    
     It follows the same convention as
    
    <a id="_idIndexMarker621">
    </a>
    
     any other coroutine.
    
    
     First, we define the
    
    
     
      return type:
     
    
   </p>
   <pre class="source-code">
template &lt;typename Out, typename In&gt;
struct async_parse {
// …
};</pre>
   <p>
    
     We use a template for flexibility because it allows us to parameterize both the input and output data types.
    
    
     In this case, these types are
    
    <strong class="source-inline">
     
      int64_t
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       char
      
     </strong>
    
    
     
      , respectively.
     
    
   </p>
   <p>
    
     The input and output data items are
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
std::optional&lt;In&gt; input_data { };
Out output_data { };</pre>
   <p>
    
     For input, we are using
    
    <strong class="source-inline">
     
      std::optional&lt;In&gt;
     
    </strong>
    
     because we need a way to know whether we have received a character.
    
    
     We use the
    
    <strong class="source-inline">
     
      put()
     
    </strong>
    
     function to send a character to
    
    
     
      the parser:
     
    
   </p>
   <pre class="source-code">
 void put(char c) {
    handle.promise().input_data = c;
    if (!handle.done()) {
        handle.resume();
    }
}</pre>
   <p>
    
     This function just assigns a value to the
    
    <strong class="source-inline">
     
      std::optional
     
    </strong>
    <strong class="source-inline">
     
      input_data
     
    </strong>
    
     variable.
    
    
     To manage the
    
    <a id="_idIndexMarker622">
    </a>
    
     waiting for the characters, we implement the following
    
    
     
      awaiter type:
     
    
   </p>
   <pre class="source-code">
auto await_transform(char) noexcept {
    struct awaiter {
        promise_type&amp; promise;
        [[nodiscard]] bool await_ready() const noexcept {
            return promise.input_data.has_value();
        }
        [[nodiscard]] char await_resume() const noexcept {
            assert (promise.input_data.has_value());
            return *std::exchange(
                            promise.input_data,
                            std::nullopt);
        }
        void await_suspend(std::coroutine_handle&lt;
                           promise_type&gt;) const noexcept {
        }
    };
    return awaiter(*this);
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      awaiter
     
    </strong>
    
     struct implements two functions to handle the
    
    
     
      input data:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       await_ready()
      
     </strong>
     
      : Returns
     
     <strong class="source-inline">
      
       true
      
     </strong>
     
      if the optional
     
     <strong class="source-inline">
      
       input_data
      
     </strong>
     
      variable contains a valid value.
     
     
      It returns
     
     
      <strong class="source-inline">
       
        false
       
      </strong>
     
     
      
       otherwise.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       await_resume()
      
     </strong>
     
      : Returns the value stored in the optional
     
     <strong class="source-inline">
      
       input_data
      
     </strong>
     
      variable
     
     <a id="_idIndexMarker623">
     </a>
     
      and
     
     <em class="italic">
      
       empties
      
     </em>
     
      it, assigning it
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        std::nullopt
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ul>
   <p>
    
     In this section, we have seen how to implement a simple parser using C++ coroutines.
    
    
     This is our last example, illustrating a very basic stream processing function using coroutines.
    
    
     In the next section, we will see exceptions
    
    
     
      in coroutines.
     
    
   </p>
   <h1 id="_idParaDest-181">
    <a id="_idTextAnchor180">
    </a>
    
     Coroutines and exceptions
    
   </h1>
   <p>
    
     In the previous
    
    <a id="_idIndexMarker624">
    </a>
    
     sections, we implemented a few basic examples to learn
    
    <a id="_idIndexMarker625">
    </a>
    
     the main C++ coroutines concepts.
    
    
     We implemented a very basic coroutine first to understand what the compiler required from us: the return type (sometimes called the wrapper type because it wraps the promise type) and the
    
    
     
      promise type.
     
    
   </p>
   <p>
    
     Even for such a simple coroutine, we had to implement some functions we explained while we wrote the examples.
    
    
     But one function has not been
    
    
     
      explained yet:
     
    
   </p>
   <pre class="source-code">
void unhandled_exception() noexcept {}</pre>
   <p>
    
     We assumed then that coroutines couldn’t throw exceptions, but the truth is they can.
    
    
     We can add the functionality to handle exceptions in the body of the
    
    
     <strong class="source-inline">
      
       unhandled_exception()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     Exceptions in coroutines can happen while the return type or the promise type object is created and while the coroutine is executed (as in a normal function, coroutines can
    
    
     
      throw exceptions).
     
    
   </p>
   <p>
    
     The difference is that if the exception is thrown before the coroutine is executed, the code creating the coroutine must handle the exception, while if the exception is thrown when the coroutine is executed, then
    
    <strong class="source-inline">
     
      unhandled_exception()
     
    </strong>
    
     
      is called.
     
    
   </p>
   <p>
    
     The first case is just the usual exception handling with no special functions called.
    
    
     We can put the coroutine creation inside a
    
    <strong class="source-inline">
     
      try-catch
     
    </strong>
    
     block and handle the possible exceptions as we normally do in
    
    
     
      our code.
     
    
   </p>
   <p>
    
     If, on the other hand,
    
    <strong class="source-inline">
     
      unhandled_exception()
     
    </strong>
    
     is called (inside the promise type), we must implement the exception-handling functionality inside
    
    
     
      that function.
     
    
   </p>
   <p>
    
     There are different strategies to handle such exceptions.
    
    
     Among them are
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Rethrow the exception so we can handle it outside the promise type (that is, in
     
     
      
       our code).
      
     
    </li>
    <li>
     
      Terminate the program (for example,
     
     
      
       calling
      
     
     
      <strong class="source-inline">
       
        std::terminate
       
      </strong>
     
     
      
       ).
      
     
    </li>
    <li>
     
      Leave the function empty.
     
     
      In this case, the coroutine will crash and it will very likely
     
     <a id="_idIndexMarker626">
     </a>
     
      crash the
     
     <a id="_idIndexMarker627">
     </a>
     
      
       program too.
      
     
    </li>
   </ul>
   <p>
    
     Because we have implemented very simple coroutines, we have left the
    
    
     
      function empty.
     
    
   </p>
   <p>
    
     In this last section, we have introduced the exception-handling mechanism for coroutines.
    
    
     It is very important to handle exceptions properly.
    
    
     For example, if you know that after an exception occurs inside a coroutine, it won’t be able to recover; then, it may be better to let the coroutine crash and handle the exception from another part of the program (usually from the
    
    
     
      caller function).
     
    
   </p>
   <h1 id="_idParaDest-182">
    <a id="_idTextAnchor181">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we have seen coroutines, a recently introduced feature in C++ that allows us to write asynchronous code without creating new threads.
    
    
     We have implemented a few simple coroutines to explain the basic requirements of a C++ coroutine.
    
    
     Additionally, we have learned how to implement generators and a string parser.
    
    
     Finally, we have seen exceptions
    
    
     
      in coroutines.
     
    
   </p>
   <p>
    
     Coroutines are important in asynchronous programming because they let the program suspend execution at specific points and resume later, allowing other tasks to run in the meantime, all running in the same thread.
    
    
     They allow better resource utilization, reduce waiting time, and improve the scalability
    
    
     
      of applications.
     
    
   </p>
   <p>
    
     In the next chapter, we will introduce Boost.Asio – a very powerful library for writing asynchronous code
    
    
     
      in C++.
     
    
   </p>
   <h1 id="_idParaDest-183">
    <a id="_idTextAnchor182">
    </a>
    
     Further reading
    
   </h1>
   <ul>
    <li>
     <em class="italic">
      
       C++ Coroutines for Beginners
      
     </em>
     
      , Andreas Fertig, Meeting C++
     
     
      
       Online, 2024
      
     
    </li>
    <li>
     <em class="italic">
      
       Deciphering Coroutines
      
     </em>
     
      , Andreas Weiss,
     
     
      
       CppCon 2022
      
     
    </li>
   </ul>
  </div>
 

  <div><h1 id="_idParaDest-184" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor183">
    </a>
    
     Part 4: Advanced Asynchronous Programming with Boost Libraries
    
   </h1>
  </div>
  <div><p>
    
     In this part, we will learn about advanced asynchronous programming techniques using powerful Boost libraries, enabling us to efficiently manage tasks that interact with external resources and system-level services.
    
    
     We will explore the
    
    <strong class="bold">
     
      Boost.Asio
     
    </strong>
    
     and
    
    <strong class="bold">
     
      Boost.Cobalt
     
    </strong>
    
     libraries, learning how they simplify the development of asynchronous applications while offering fine-grained control over complex processes such as task management and coroutine execution.
    
    
     Through hands-on examples, we will see how Boost.Asio handles asynchronous I/O operations in both single-threaded and multithreaded environments, and how Boost.Cobalt abstracts away the complexities of C++20 coroutines, allowing us to focus on functionality instead of low-level
    
    
     
      coroutine management.
     
    
   </p>
   <p>
    
     This part has the
    
    
     
      following chapters:
     
    
   </p>
   <ul>
    <li>
     <a href="B22219_09.xhtml#_idTextAnchor184">
      <em class="italic">
       
        Chapter 9
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Asynchronous Programming Using Boost.Asio
      
     </em>
    </li>
    <li>
     <a href="B22219_10.xhtml#_idTextAnchor212">
      <em class="italic">
       
        Chapter 10
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Coroutines with Boost.Cobalt
      
     </em>
    </li>
   </ul>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
 </body></html>