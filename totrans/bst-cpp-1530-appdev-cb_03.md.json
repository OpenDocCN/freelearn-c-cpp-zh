["```cpp\nvoid foo1() {\n    foo_class* p = new foo_class(\"Some initialization data\");\n    bool something_else_happened = some_function1(p);\n\n    if (something_else_happened) {\n        delete p;\n        return false;\n    }\n\n    some_function2(p);\n\n    delete p;\n    return true;\n}\n```", "```cpp\nvoid foo2() {\n    foo_class* p = new foo_class(\"Some initialization data\");\n    try {\n        bool something_else_happened = some_function1(p);\n        if (something_else_happened) {\n            delete p;\n            return false;\n        }\n        some_function2(p);\n    } catch (...) {\n        delete p;\n        throw;\n    }\n    delete p;\n    return true;\n}\n```", "```cpp\n#include <boost/scoped_ptr.hpp>\n\nbool foo3() {\n    boost::scoped_ptr<foo_class> p(new foo_class(\n        \"Some initialization data\"));\n    bool something_else_happened = some_function1(p.get());\n    if (something_else_happened) {\n       return false;\n    }\n    some_function2(p.get());\n    return true;\n}\n```", "```cpp\n#include <boost/thread.hpp>\n#include <boost/bind.hpp>\n\nvoid process1(const foo_class* p);\nvoid process2(const foo_class* p);\nvoid process3(const foo_class* p);\n\nvoid foo1() {\n    while (foo_class* p = get_data()) // C way\n    {\n        // There will be too many threads soon, see\n        // recipe 'Executing different tasks in parallel'\n        // for a good way to avoid uncontrolled growth of threads\n        boost::thread(boost::bind(&process1, p))\n            .detach();\n        boost::thread(boost::bind(&process2, p))\n            .detach();\n        boost::thread(boost::bind(&process3, p))\n            .detach();\n        // delete p; Oops!!!!\n    }\n}\n```", "```cpp\n#include <boost/shared_ptr.hpp>\n\nvoid process_sp1(const boost::shared_ptr<foo_class>& p);\nvoid process_sp2(const boost::shared_ptr<foo_class>& p);\nvoid process_sp3(const boost::shared_ptr<foo_class>& p);\n\nvoid foo2() {\n    typedef boost::shared_ptr<foo_class> ptr_t;\n    ptr_t p;\n    while (p = ptr_t(get_data())) // C way\n    {\n        boost::thread(boost::bind(&process_sp1, p))\n            .detach();\n        boost::thread(boost::bind(&process_sp2, p))\n            .detach();\n        boost::thread(boost::bind(&process_sp3, p))\n            .detach();\n        // no need to anything\n    }\n}\n```", "```cpp\n#include <string>\n#include <boost/smart_ptr/make_shared.hpp>\n\nvoid process_str1(boost::shared_ptr<std::string> p);\nvoid process_str2(const boost::shared_ptr<std::string>& p);\n\nvoid foo3() {\n    boost::shared_ptr<std::string> ps = boost::make_shared<std::string>(\n        \"Guess why make_shared<std::string> \"\n        \"is faster than shared_ptr<std::string> \"\n        \"ps(new std::string('this string'))\"\n    );\n    boost::thread(boost::bind(&process_str1, ps))\n            .detach();\n    boost::thread(boost::bind(&process_str2, ps))\n            .detach();\n}\n```", "```cpp\nvoid may_throw1(const char* buffer);\nvoid may_throw2(const char* buffer);\n\nvoid foo() {\n    // we cannot allocate 10MB of memory on stack,\n    // so we allocate it on heap\n    char* buffer = new char[1024 * 1024 * 10];\n    // Here comes some code, that may throw\n    may_throw1(buffer);\n    may_throw2(buffer);\n    delete[] buffer;\n}\n```", "```cpp\n#include <boost/scoped_array.hpp>\n\nvoid foo_fixed() {\n    // so we allocate it on heap\n    boost::scoped_array<char> buffer(new char[1024 * 1024 * 10]);\n\n    // Here comes some code, that may throw,\n    // but now exception won't cause a memory leak\n    may_throw1(buffer.get());\n    may_throw2(buffer.get());\n\n    // destructor of 'buffer' variable will call delete[]\n}\n```", "```cpp\n#include <cstring>\n#include <boost/thread.hpp>\n#include <boost/bind.hpp>\n\nvoid do_process(const char* data, std::size_t size);\n\nvoid do_process_in_background(const char* data, std::size_t size) {\n    // We need to copy data, because we do not know,\n    // when it will be deallocated by the caller\n    char* data_cpy = new char[size];\n    std::memcpy(data_cpy, data, size);\n\n    // Starting thread of execution to process data\n    boost::thread(boost::bind(&do_process, data_cpy, size))\n            .detach();\n\n    // We cannot delete[] data_cpy, because\n    // do_process1 or do_process2 may still work with it\n}\n```", "```cpp\n    #include <boost/shared_array.hpp>\n\n    void do_process(const boost::shared_array<char>& data, std::size_t size) {\n        do_process(data.get(), size);\n    }\n\n    void do_process_in_background_v1(const char* data, std::size_t size) {\n        // We need to copy data, because we do not know, when \n        // it will be deallocated by the caller\n        boost::shared_array<char> data_cpy(new char[size]);\n        std::memcpy(data_cpy.get(), data, size);\n\n        // Starting threads of execution to process data\n        boost::thread(boost::bind(&do_process1, data_cpy))\n            .detach();\n\n        // no need to call delete[] for data_cpy, because\n        // data_cpy destructor will deallocate data when\n        // reference count will be zero\n    }\n    ```", "```cpp\n    #include <boost/shared_ptr.hpp>\n    #include <boost/make_shared.hpp>\n\n    void do_process_shared_ptr(\n            const boost::shared_ptr<char[]>& data,\n            std::size_t size)\n    {\n        do_process(data.get(), size);\n    }\n\n    void do_process_in_background_v2(const char* data, std::size_t size) {\n        // Faster than 'First solution'\n        boost::shared_ptr<char[]> data_cpy = boost::make_shared<char[]>(size);\n        std::memcpy(data_cpy.get(), data, size);\n\n        // Starting thread of execution to process data\n        boost::thread(boost::bind(\n           &do_process_shared_ptr, data_cpy, size\n        )).detach();\n\n        // data_cpy destructor will deallocate data when\n        // reference count will be zero\n    }\n    ```", "```cpp\n    void do_process_shared_ptr2(\n            const boost::shared_ptr<char>& data,\n            std::size_t size)\n    {\n        do_process(data.get(), size);\n    }\n    void do_process_in_background_v3(const char* data, std::size_t size) {\n        // Same speed as in First solution\n        boost::shared_ptr<char> data_cpy(\n                    new char[size],\n                    boost::checked_array_deleter<char>()\n        );\n        std::memcpy(data_cpy.get(), data, size);\n\n        // Starting threads of execution to process data\n        boost::thread(boost::bind(\n           &do_process_shared_ptr2, data_cpy, size\n        )).detach();\n\n        // data_cpy destructor will deallocate data when\n        // reference count will be zero\n    }\n    ```", "```cpp\n// Required for std::unary_function<> template\n#include <functional>\n\n// making a typedef for function pointer accepting int\n// and returning nothing\ntypedef void (*func_t)(int);\n\n// Function that accepts pointer to function and\n// calls accepted function for each integer that it has\n// It cannot work with functional objects :(\nvoid process_integers(func_t f);\n\n// Functional object\nclass int_processor: public std::unary_function<int, void> {\n   const int min_;\n   const int max_;\n   bool& triggered_;\n\npublic:\n    int_processor(int min, int max, bool& triggered)\n        : min_(min)\n        , max_(max)\n        , triggered_(triggered)\n    {}\n\n    void operator()(int i) const {\n        if (i < min_ || i > max_) {\n            triggered_ = true;\n        }\n    }\n};\n```", "```cpp\n    #include <boost/function.hpp>\n\n    typedef boost::function<void(int)> fobject_t;\n\n    // Now this function may accept functional objects\n    void process_integers(const fobject_t& f);\n\n    int main() {\n        bool is_triggered = false;\n        int_processor fo(0, 200, is_triggered);\n        process_integers(fo);\n        assert(is_triggered);\n    }\n    ```", "```cpp\n    void foo(const fobject_t& f) {\n        // boost::function is convertible to bool\n        if (f) {\n            // we have value in 'f'\n            // ...\n        } else {\n            // 'f' is empty\n            // ...\n        }\n    }\n    ```", "```cpp\nbool g_is_triggered = false;\nvoid set_functional_object(fobject_t& f) {\n    int_processor fo( 100, 200, g_is_triggered);\n    f = fo;\n    // fo leavs scope and will be destroyed,\n    // but 'f' will be usable eve inouter scope\n}\n```", "```cpp\nstd::for_each(v.begin(), v.end(),\n   boost::bind(std::plus<int>(), 10, _1));\n```", "```cpp\nfobject_t f(boost::bind(std::plus<int>(), 10, _1));\nstd::for_each(v.begin(), v.end(), f);\n```", "```cpp\nauto f = boost::bind(std::plus<int>(), 10, _1);\nstd::for_each(v.begin(), v.end(), f);\n```", "```cpp\nvoid my_ints_function(int i);\n\nint main() {\n    process_integeres(&my_ints_function);\n}\n```", "```cpp\n    // lambda function with no parameters that does nothing\n    process_integeres([](int /*i*/){});\n\n    // lambda function that stores a reference\n    std::deque<int> ints;\n    process_integeres([&ints](int i){\n        ints.push_back(i);\n    });\n\n    // lambda function that modifies its content\n    std::size_t match_count = 0;\n    process_integeres([ints, &match_count](int i) mutable {\n        if (ints.front() == i) {\n           ++ match_count;\n        }\n        ints.pop_front();\n    });\n```", "```cpp\n    #include <set>\n    #include <algorithm>\n    #include <boost/bind.hpp>\n    #include <boost/type_traits/remove_pointer.hpp>\n    #include <cassert>\n\n    template <class T>\n    struct ptr_cmp: public std::binary_function<T, T, bool> {\n        template <class T1>\n        bool operator()(const T1& v1, const T1& v2) const {\n            return operator ()(*v1, *v2);\n        }\n\n        bool operator()(const T& v1, const T& v2) const {\n            return std::less<T>()(v1, v2);\n        }\n    };\n\n    void example1() {\n        std::set<int*, ptr_cmp<int> > s;\n        s.insert(new int(1));\n        s.insert(new int(0));\n        // ...\n        assert(**s.begin() == 0);\n        // ...\n        // Deallocating resources\n        // Any exception in this code will lead to\n        // memory leak\n        std::for_each(s.begin(), s.end(), boost::bind(::operator delete, _1));\n    }\n    ```", "```cpp\n        void example2_a() {\n        typedef std::auto_ptr<int> int_aptr_t;\n        std::set<int_aptr_t, ptr_cmp<int> > s;\n        s.insert(int_aptr_t(new int(1)));\n        s.insert(int_aptr_t(new int(0)));\n        // ...\n        assert(**s.begin() == 0);\n        // ...\n        // resources will be deallocated by auto_ptr<>\n    }\n    ```", "```cpp\n    void example2_b() {\n        typedef std::unique_ptr<int> int_uptr_t;\n        std::set<int_uptr_t, ptr_cmp<int> > s;\n        s.insert(int_uptr_t(new int(1)));\n        s.insert(int_uptr_t(new int(0)));\n        // ...\n        assert(**s.begin() == 0);\n        // ...\n        // resources will be deallocated by unique_ptr<>\n    }\n    ```", "```cpp\n    #include <boost/shared_ptr.hpp>\n    void example3() {\n        typedef boost::shared_ptr<int> int_sptr_t;\n        std::set<int_sptr_t, ptr_cmp<int> > s;\n        s.insert(int_sptr_t(new int(1)));\n        s.insert(int_sptr_t(new int(0)));\n        // ...\n        assert(**s.begin() == 0);\n        // ...\n        // resources will be deallocated by shared_ptr<>\n    }\n    ```", "```cpp\n#include <boost/ptr_container/ptr_set.hpp>\nvoid correct_impl() {\n    boost::ptr_set<int> s;\n    s.insert(new int(1));\n    s.insert(new int(0));\n    // ...\n    assert(*s.begin() == 0);\n    // ...\n    // resources will be deallocated by container itself\n}\n```", "```cpp\n#include <boost/ptr_container/clone_allocator.hpp>\n#include <boost/ptr_container/ptr_vector.hpp>\n\n    // Creating vector of 10 elements with values 100\n    boost::ptr_vector<int> v;\n    v.resize(10, new int(100));\n    assert(v.size() == 10);\n    assert(v.back() == 100);\n```", "```cpp\n// Some pseudo code (suspiciously similar to Java code)\ntry {\n    FileWriter f = new FileWriter(\"example_file.txt\");\n    // Some code that may trow or return\n    // …\n} finally {\n    // Whatever happened in scope, this code will be executed\n    // and file will be correctly closed\n    if (f != null) {\n        f.close()\n    }\n}\n```", "```cpp\n#include <boost/scope_exit.hpp>\n#include <cstdlib>\n#include <cstdio>\n#include <cassert>\nint main() {\n    std::FILE* f = std::fopen(\"example_file.txt\", \"w\");\n    assert(f);\n    BOOST_SCOPE_EXIT(f) {\n      // Whatever happened in scope, this code will be\n      // executed and file will be correctly closed.\n        std::fclose(f);\n    } BOOST_SCOPE_EXIT_END\n    // Some code that may throw or return.\n    // ...\n}\n```", "```cpp\nclass theres_more_example {\npublic:\n    void close(std::FILE*);\n    void theres_more_example_func() {\n        std::FILE* f = 0;\n        BOOST_SCOPE_EXIT(f, this_) { // Capture object `this_`.\n            this_->close(f);\n        } BOOST_SCOPE_EXIT_END\n    }\n};\n```", "```cpp\n#include <boost/noncopyable.hpp>\n#include <sstream>\n\nclass tasks_processor: boost::noncopyable {\n    std::ostream& log_;\n\nprotected:\n    virtual void do_process() = 0;\n\npublic:\n    explicit tasks_processor(std::ostream& log)\n        : log_(log)\n    {}\n\n    void process() {\n        log_ << \"Starting data processing\";\n        do_process();\n    }\n};\n```", "```cpp\nclass fake_tasks_processor: public tasks_processor {\n    std::ostringstream logger_;\n\n    virtual void do_process() {\n        logger_ << \"Fake processor processed!\";\n    }\n\npublic:\n    fake_tasks_processor()\n       : tasks_processor(logger_) // Oops! logger_ does \n                                  // not exist here\n       , logger_()\n   {}\n};\n```", "```cpp\n    fake_tasks_processor()\n          : logger_() // Oops! logger_ still will be constructed \n                      // AFTER tasks_processor\n          , tasks_processor(logger_)\n   {}\n```", "```cpp\n    #include <boost/utility/base_from_member.hpp>\n    ```", "```cpp\n    class fake_tasks_processor_fixed\n        : boost::base_from_member<std::ostringstream>\n        , public tasks_processor\n    ```", "```cpp\n    {\n        typedef boost::base_from_member<std::ostringstream> \n          logger_t;\n        // ...\n    public:\n        fake_tasks_processor_fixed()\n            : logger_t()\n            , tasks_processor(logger_t::member)\n        {}\n    };\n    ```", "```cpp\ntemplate < typename MemberType, int UniqueID = 0 >class base_from_member{protected:    MemberType  member;    // Constructors go there...};\n```", "```cpp\nclass fake_tasks_processor2\n    : boost::base_from_member<std::ostringstream, 0>\n    , boost::base_from_member<std::ostringstream, 1>\n    , public tasks_processor\n{\n    typedef boost::base_from_member<std::ostringstream, 0> logger0_t;\n    typedef boost::base_from_member<std::ostringstream, 1> logger1_t;\n\n    virtual void do_process() {\n        logger0_t::member << \"0: Fake processor2 processed!\";\n        logger1_t::member << \"1: Fake processor2 processed!\";\n    }\npublic:\n    fake_tasks_processor2()\n        : logger0_t()\n        , logger1_t()\n        , tasks_processor(logger0_t::member)\n    {}\n};\n```"]