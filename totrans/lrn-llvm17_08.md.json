["```cpp\n\nint bar(int x) {\n  if (x == 1) throw 1;\n  if (x == 2) throw 42.0;\n  return x;\n}\n```", "```cpp\n\nint foo(int x) {\n  int y = 0;\n  try {\n    y = bar(x);\n  }\n  catch (int e) {\n    y = e;\n  }\n  return y;\n}\n```", "```cpp\n\n%eh = call ptr @__cxa_allocate_exception(i64 4)\nstore i32 1, ptr %eh\ncall void @__cxa_throw(ptr %eh, ptr @_ZTIi, ptr null)\nunreachable\n```", "```cpp\n\n%y = invoke i32 @_Z3bari(i32 %x) to label %next\n                                 unwind label %lpad\n```", "```cpp\n\nlpad:\n%exc = landingpad { ptr, i32 }\n          cleanup\n          catch ptr @_ZTIi\n          filter [1 x ptr] [ptr @_ZTIi]\n```", "```cpp\n\n%exc.ptr = extractvalue { ptr, i32 } %exc, 0\n%exc.sel = extractvalue { ptr, i32 } %exc, 1\n```", "```cpp\n\n%tid.int = call i32 @llvm.eh.typeid.for(ptr @_ZTIi)\n%tst.int = icmp eq i32 %exc.sel, %tid.int\nbr i1 %tst.int, label %catchint, label %filterorcleanup\n```", "```cpp\n\ncatchint:\n%payload = call ptr @__cxa_begin_catch(ptr %exc.ptr)\n%retval = load i32, ptr %payload\ncall void @__cxa_end_catch()\nbr label %return\n```", "```cpp\n\nfilterorcleanup:\n%tst.blzero = icmp slt i32 %exc.sel, 0\nbr i1 %tst.blzero, label %filter, label %cleanup\n```", "```cpp\n\nfilter:\ncall void @__cxa_call_unexpected(ptr %exc.ptr) #4\nunreachable\n```", "```cpp\n\ncleanup:\nresume { ptr, i32 } %exc\n```", "```cpp\n\ndefine i32 @_Z3fooi(i32) personality ptr @__gxx_personality_v0\n```", "```cpp\n\n      GlobalVariable *TypeInfo = nullptr;\n      FunctionType *AllocEHFty = nullptr;\n      Function *AllocEHFn = nullptr;\n      FunctionType *ThrowEHFty = nullptr;\n      Function *ThrowEHFn = nullptr;\n      BasicBlock *LPadBB = nullptr;\n      BasicBlock *UnreachableBB = nullptr;\n    ```", "```cpp\n\n      void createICmpEq(Value *Left, Value *Right,\n                        BasicBlock *&TrueDest,\n                        BasicBlock *&FalseDest,\n                        const Twine &TrueLabel = \"\",\n                        const Twine &FalseLabel = \"\") {\n        Function *Fn =\n            Builder.GetInsertBlock()->getParent();\n        TrueDest = BasicBlock::Create(M->getContext(),\n                                      TrueLabel, Fn);\n        FalseDest = BasicBlock::Create(M->getContext(),\n                                       FalseLabel, Fn);\n        Value *Cmp = Builder.CreateCmp(CmpInst::ICMP_EQ,\n                                       Left, Right);\n        Builder.CreateCondBr(Cmp, TrueDest, FalseDest);\n      }\n    ```", "```cpp\n\n      void createFunc(FunctionType *&Fty, Function *&Fn,\n                      const Twine &N, Type *Result,\n                      ArrayRef<Type *> Params = None,\n                      bool IsVarArgs = false) {\n        Fty = FunctionType::get(Result, Params, IsVarArgs);\n        Fn = Function::Create(\n            Fty, GlobalValue::ExternalLinkage, N, M);\n      }\n    ```", "```cpp\n\n      void addThrow(int PayloadVal) {\n        if (!TypeInfo) {\n          TypeInfo = new GlobalVariable(\n              *M, Int8PtrTy,\n              /*isConstant=*/true,\n              GlobalValue::ExternalLinkage,\n              /*Initializer=*/nullptr, \"_ZTIi\");\n    ```", "```cpp\n\n          createFunc(AllocEHFty, AllocEHFn,\n                     \"__cxa_allocate_exception\", Int8PtrTy,\n                     {Int64Ty});\n          createFunc(ThrowEHFty, ThrowEHFn, \"__cxa_throw\",\n                     VoidTy,\n                     {Int8PtrTy, Int8PtrTy, Int8PtrTy});\n    ```", "```cpp\n\n          FunctionType *PersFty;\n          Function *PersFn;\n          createFunc(PersFty, PersFn,\n                     \"__gxx_personality_v0\", Int32Ty, std::nulopt,                  true);\n          Function *Fn =\n              Builder.GetInsertBlock()->getParent();\n          Fn->setPersonalityFn(PersFn);\n    ```", "```cpp\n\n          BasicBlock *SaveBB = Builder.GetInsertBlock();\n          LPadBB = BasicBlock::Create(M->getContext(),\n                                      \"lpad\", Fn);\n          Builder.SetInsertPoint(LPadBB);\n          addLandingPad();\n    ```", "```cpp\n\n          UnreachableBB = BasicBlock::Create(\n              M->getContext(), \"unreachable\", Fn);\n          Builder.SetInsertPoint(UnreachableBB);\n          Builder.CreateUnreachable();\n          Builder.SetInsertPoint(SaveBB);\n        }\n    ```", "```cpp\n\n        Constant *PayloadSz =\n            ConstantInt::get(Int64Ty, 4, false);\n        CallInst *EH = Builder.CreateCall(\n            AllocEHFty, AllocEHFn, {PayloadSz});\n    ```", "```cpp\n\n        Value *PayloadPtr =\n            Builder.CreateBitCast(EH, Int32PtrTy);\n        Builder.CreateStore(\n            ConstantInt::get(Int32Ty, PayloadVal, true),\n            PayloadPtr);\n    ```", "```cpp\n\n        Builder.CreateInvoke(\n            ThrowEHFty, ThrowEHFn, UnreachableBB, LPadBB,\n            {EH,\n             ConstantExpr::getBitCast(TypeInfo, Int8PtrTy),\n             ConstantPointerNull::get(Int8PtrTy)});\n      }\n    ```", "```cpp\n\n      void addLandingPad() {\n        FunctionType *TypeIdFty; Function *TypeIdFn;\n        createFunc(TypeIdFty, TypeIdFn,\n                   \"llvm.eh.typeid.for\", Int32Ty,\n                   {Int8PtrTy});\n        FunctionType *BeginCatchFty; Function *BeginCatchFn;\n        createFunc(BeginCatchFty, BeginCatchFn,\n                   \"__cxa_begin_catch\", Int8PtrTy,\n                   {Int8PtrTy});\n        FunctionType *EndCatchFty; Function *EndCatchFn;\n        createFunc(EndCatchFty, EndCatchFn,\n                   \"__cxa_end_catch\", VoidTy);\n        FunctionType *PutsFty; Function *PutsFn;\n        createFunc(PutsFty, PutsFn, \"puts\", Int32Ty,\n                   {Int8PtrTy});\n    ```", "```cpp\n\n        LandingPadInst *Exc = Builder.CreateLandingPad(\n            StructType::get(Int8PtrTy, Int32Ty), 1, \"exc\");\n        Exc->addClause(\n            ConstantExpr::getBitCast(TypeInfo, Int8PtrTy));\n    ```", "```cpp\n\n        Value *Sel =\n            Builder.CreateExtractValue(Exc, {1}, \"exc.sel\");\n        CallInst *Id =\n            Builder.CreateCall(TypeIdFty, TypeIdFn,\n                               {ConstantExpr::getBitCast(\n                                   TypeInfo, Int8PtrTy)});\n    ```", "```cpp\n\n        BasicBlock *TrueDest, *FalseDest;\n        createICmpEq(Sel, Id, TrueDest, FalseDest, \"match\",\n                     \"resume\");\n    ```", "```cpp\n\n        Builder.SetInsertPoint(FalseDest);\n        Builder.CreateResume(Exc);\n    ```", "```cpp\n\n        Builder.SetInsertPoint(TrueDest);\n        Value *Ptr =\n            Builder.CreateExtractValue(Exc, {0}, \"exc.ptr\");\n        Builder.CreateCall(BeginCatchFty, BeginCatchFn,\n                           {Ptr});\n    ```", "```cpp\n\n        Value *MsgPtr = Builder.CreateGlobalStringPtr(\n            \"Divide by zero!\", \"msg\", 0, M);\n        Builder.CreateCall(PutsFty, PutsFn, {MsgPtr});\n    ```", "```cpp\n\n        Builder.CreateCall(EndCatchFty, EndCatchFn);\n        Builder.CreateRet(Int32Zero);\n      }\n    ```", "```cpp\n\n    case BinaryOp::Div:\n      BasicBlock *TrueDest, *FalseDest;\n      createICmpEq(Right, Int32Zero, TrueDest,\n                   FalseDest, \"divbyzero\", \"notzero\");\n      Builder.SetInsertPoint(TrueDest);\n      addThrow(42); // Arbitrary payload value.\n      Builder.SetInsertPoint(FalseDest);\n      V = Builder.CreateSDiv(Left, Right);\n      break;\n```", "```cpp\n\n$ ninja\n```", "```cpp\n\n$ src/calc \"with a: 3/a\"\n```", "```cpp\n\n$ src/calc \"with a: 3/a\" | llc -filetype obj -o exp.o\n$ clang++ -o exp exp.o ../rtcalc.cpp\n```", "```cpp\n\n$ ./exp\nEnter a value for a: 1\nThe result is: 3\n$ ./exp\nEnter a value for a: 0\nDivide by zero!\n```", "```cpp\n\nvoid doSomething(int *p, float *q) {\n  *p = 42;\n  *q = 3.1425;\n}\n```", "```cpp\n\nstruct Point { float x, y; }\nvoid func(struct Point *p, float *x, int *i, char *c) {\n  p->x = 0; p->y = 0; *x = 0.0; *i = 0; *c = 0;\n}\n```", "```cpp\n\nvoid CGModule::decorateInst(llvm::Instruction *Inst,\n                            TypeDeclaration *Type) {\n  if (auto *N = TBAA.getAccessTagInfo(Type))\n    Inst->setMetadata(llvm::LLVMContext::MD_tbaa, N);\n}\n```", "```cpp\n\n#include \"tinylang/AST/AST.h\"\n#include \"llvm/IR/MDBuilder.h\"\n#include \"llvm/IR/Metadata.h\"\n```", "```cpp\n\n     class CGTBAA {\n      llvm::MDNode *Root;\n    ```", "```cpp\n\n      llvm::MDBuilder MDHelper;\n    ```", "```cpp\n\n      llvm::DenseMap<TypeDenoter *, llvm::MDNode *> MetadataCache;\n    // …\n    };\n    ```", "```cpp\n\n    CGTBAA::CGTBAA(CGModule &CGM)\n          : CGM(CGM),\n            MDHelper(llvm::MDBuilder(CGM.getLLVMCtx())),\n            Root(nullptr) {}\n    ```", "```cpp\n\n    llvm::MDNode *CGTBAA::getRoot() {\n      if (!Root)\n        Root = MDHelper.createTBAARoot(\"Simple tinylang TBAA\");\n      return Root;\n    }\n    ```", "```cpp\n\n    llvm::MDNode *\n    CGTBAA::createScalarTypeNode(TypeDeclaration *Ty,\n                                 StringRef Name,\n                                 llvm::MDNode *Parent) {\n      llvm::MDNode *N =\n          MDHelper.createTBAAScalarTypeNode(Name, Parent);\n      return MetadataCache[Ty] = N;\n    }\n    ```", "```cpp\n\n    llvm::MDNode *CGTBAA::createStructTypeNode(\n        TypeDeclaration *Ty, StringRef Name,\n        llvm::ArrayRef<std::pair<llvm::MDNode *, uint64_t>>\n            Fields) {\n      llvm::MDNode *N =\n          MDHelper.createTBAAStructTypeNode(Name, Fields);\n      return MetadataCache[Ty] = N;\n    }\n    ```", "```cpp\n\n    llvm::MDNode *CGTBAA::getTypeInfo(TypeDeclaration *Ty) {\n      if (llvm::MDNode *N = MetadataCache[Ty])\n        return N;\n      if (auto *Pervasive =\n              llvm::dyn_cast<PervasiveTypeDeclaration>(Ty)) {\n        StringRef Name = Pervasive->getName();\n        return createScalarTypeNode(Pervasive, Name, getRoot());\n      }\n      if (auto *Pointer =\n              llvm::dyn_cast<PointerTypeDeclaration>(Ty)) {\n        StringRef Name = \"any pointer\";\n        return createScalarTypeNode(Pointer, Name, getRoot());\n      }\n      if (auto *Array =\n             llvm::dyn_cast<ArrayTypeDeclaration>(Ty)) {\n        StringRef Name = Array->getType()->getName();\n        return createScalarTypeNode(Array, Name, getRoot());\n      }\n      if (auto *Record =\n              llvm::dyn_cast<RecordTypeDeclaration>(Ty)) {\n        llvm::SmallVector<std::pair<llvm::MDNode *, uint64_t>,     4> Fields;\n        auto *Rec =\n            llvm::cast<llvm::StructType>(CGM.convertType(Record));\n        const llvm::StructLayout *Layout =\n            CGM.getModule()->getDataLayout().getStructLayout(Rec);\n        unsigned Idx = 0;\n        for (const auto &F : Record->getFields()) {\n          uint64_t Offset = Layout->getElementOffset(Idx);\n          Fields.emplace_back(getTypeInfo(F.getType()), Offset);\n          ++Idx;\n        }\n        StringRef Name = CGM.mangleName(Record);\n        return createStructTypeNode(Record, Name, Fields);\n      }\n      return nullptr;\n    }\n    ```", "```cpp\n\n    llvm::MDNode *CGTBAA::getAccessTagInfo(TypeDeclaration *Ty) {\n        return getTypeInfo(Ty);\n    }\n    ```", "```cpp\n\n      Builder.CreateStore(Val, CGM.getGlobal(D));\n```", "```cpp\n\n      auto *Inst = Builder.CreateStore(Val, CGM.getGlobal(D));\n      // NOTE: V is of the VariableDeclaration class, and\n      // the getType() method in this class retrieves the\n      // TypeDeclaration that is needed for decorateInst().\n      CGM.decorateInst(Inst, V->getType());\n```", "```cpp\n\nMODULE Person;\nTYPE\n  Person = RECORD\n             Height: INTEGER;\n             Age: INTEGER\n           END;\nPROCEDURE Set(VAR p: Person);\nBEGIN\n  p.Age := 18;\nEND Set;\nEND Person.\n```", "```cpp\n\n$ tools/driver/tinylang -emit-llvm ../examples/Person.mod\n```", "```cpp\n\n; ModuleID = '../examples/Person.mod'\nsource_filename = \"../examples/Person.mod\"\ntarget datalayout = \"e-m:o-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"arm64-apple-darwin22.6.0\"\ndefine void @_t6Person3Set(ptr nocapture dereferenceable(16) %p) {\nentry:\n  %0 = getelementptr inbounds ptr, ptr %p, i32 0, i32 1\n  store i64 18, ptr %0, align 8, !tbaa !0\n  ret void\n}\n!0 = !{!\"_t6Person6Person\", !1, i64 0, !1, i64 8}\n!1 = !{!\"INTEGER\", !2, i64 0}\n!2 = !{!\"Simple tinylang TBAA\"}\n```", "```cpp\n\nllvm::DIFile *DbgFile = DBuilder.createFile(\"File.mod\",\n                                            \"/home/llvmuser\");\n```", "```cpp\n\nbool IsOptimized = false;\nllvm::StringRef CUFlags;\nunsigned ObjCRunTimeVersion = 0;\nllvm::StringRef SplitName;\nllvm::DICompileUnit::DebugEmissionKind EmissionKind =\n      llvm::DICompileUnit::DebugEmissionKind::FullDebug;\nllvm::DICompileUnit *DbgCU = DBuilder.createCompileUnit(\n      llvm::dwarf::DW_LANG_Modula2, DbgFile, „tinylang\",\n      IsOptimized, CUFlags, ObjCRunTimeVersion, SplitName,\n      EmissionKind);\n```", "```cpp\n\nllvm::DIBasicType *DbgIntTy =\n                       DBuilder.createBasicType(\"INTEGER\", 32,\n                                  llvm::dwarf::DW_ATE_signed);\n```", "```cpp\n\nllvm::Metadata *DbgSigTy = {DbgIntTy};\nllvm::DITypeRefArray DbgParamsTy =\n                      DBuilder.getOrCreateTypeArray(DbgSigTy);\nllvm::DISubroutineType *DbgFuncTy =\n                   DBuilder.createSubroutineType(DbgParamsTy);\n```", "```cpp\n\nunsigned LineNo = 5;\nunsigned ScopeLine = 5;\nllvm::DISubprogram *DbgFunc = DBuilder.createFunction(\n      DbgCU, \"Func\", \"_t4File4Func\", DbgFile, LineNo,\n      DbgFuncTy, ScopeLine, llvm::DISubprogram::FlagPrivate,\n      llvm::DISubprogram::SPFlagLocalToUnit);\n```", "```cpp\n\n@i = alloca i32\n```", "```cpp\n\ncall void @llvm.dbg.declare(metadata ptr %i,\n                        metadata !1, metadata !DIExpression())\n```", "```cpp\n\nllvm::Type *IntTy = llvm::Type::getInt32Ty(LLVMCtx);\nllvm::Value *Val = Builder.CreateAlloca(IntTy, nullptr, \"i\");\n```", "```cpp\n\nllvm::DILocalVariable *DbgLocalVar =\n Dbuilder.createAutoVariable(DbgFunc, \"i\", DbgFile,\n                             7, DbgIntTy);\n```", "```cpp\n\nllvm::DILocation *DbgLoc =\n                llvm::DILocation::get(LLVMCtx, 7, 5, DbgFunc);\nDBuilder.insertDeclare(Val, DbgLocalVar,\n                       DBuilder.createExpression(), DbgLoc,\n                       Val.getParent());\n```", "```cpp\n\nconst llvm::DataLayout &DL = Mod->getDataLayout();\nuint64_t Ofs = DL.getStructLayout(Frame)->getElementOffset(3);\n```", "```cpp\n\nllvm::SmallVector<int64_t, 2> AddrOps;\nAddrOps.push_back(llvm::dwarf::DW_OP_plus_uconst);\nAddrOps.push_back(Offset);\n```", "```cpp\n\nllvm::DIExpression *Expr = DBuilder.createExpression(AddrOps);\n```", "```cpp\n\n  CGModule &CGM;\n  llvm::DIBuilder DBuilder;\n  llvm::DICompileUnit *CU;\n llvm::DenseMap<TypeDeclaration *, llvm::DIType *>\n      TypeCache;\n  llvm::SmallVector<llvm::DIScope *, 4> ScopeStack;\n```", "```cpp\n\n    CGDebugInfo::CGDebugInfo(CGModule &CGM)\n        : CGM(CGM), DBuilder(*CGM.getModule()) {\n      llvm::SmallString<128> Path(\n          CGM.getASTCtx().getFilename());\n      llvm::sys::fs::make_absolute(Path);\n      llvm::DIFile *File = DBuilder.createFile(\n          llvm::sys::path::filename(Path),\n          llvm::sys::path::parent_path(Path));\n      bool IsOptimized = false;\n      llvm::StringRef CUFlags;\n      unsigned ObjCRunTimeVersion = 0;\n      llvm::StringRef SplitName;\n      llvm::DICompileUnit::DebugEmissionKind EmissionKind =\n          llvm::DICompileUnit::DebugEmissionKind::FullDebug;\n      CU = DBuilder.createCompileUnit(\n          llvm::dwarf::DW_LANG_Modula2, File, \"tinylang\",\n          IsOptimized, CUFlags, ObjCRunTimeVersion,\n          SplitName, EmissionKind);\n    }\n    ```", "```cpp\n\n    unsigned CGDebugInfo::getLineNumber(SMLoc Loc) {\n      return CGM.getASTCtx().getSourceMgr().FindLineNumber(\n          Loc);\n    }\n    ```", "```cpp\n\n    llvm::DIScope *CGDebugInfo::getScope() {\n      if (ScopeStack.empty())\n        openScope(CU->getFile());\n      return ScopeStack.back();\n    }\n    void CGDebugInfo::openScope(llvm::DIScope *Scope) {\n      ScopeStack.push_back(Scope);\n    }\n    void CGDebugInfo::closeScope() {\n      ScopeStack.pop_back();\n    }\n    ```", "```cpp\n\n    llvm::DIType *\n    CGDebugInfo::getPervasiveType(TypeDeclaration *Ty) {\n      if (Ty->getName() == \"INTEGER\") {\n        return DBuilder.createBasicType(\n            Ty->getName(), 64, llvm::dwarf::DW_ATE_signed);\n      }\n      if (Ty->getName() == \"BOOLEAN\") {\n        return DBuilder.createBasicType(\n            Ty->getName(), 1, llvm::dwarf::DW_ATE_boolean);\n      }\n      llvm::report_fatal_error(\n          \"Unsupported pervasive type\");\n    }\n    ```", "```cpp\n\n    llvm::DIType *\n    CGDebugInfo::getAliasType(AliasTypeDeclaration *Ty) {\n      return DBuilder.createTypedef(\n          getType(Ty->getType()), Ty->getName(),\n          CU->getFile(), getLineNumber(Ty->getLocation()),\n          getScope());\n    }\n    ```", "```cpp\n\n    llvm::DIType *\n    CGDebugInfo::getArrayType(ArrayTypeDeclaration *Ty) {\n      auto *ATy =\n          llvm::cast<llvm::ArrayType>(CGM.convertType(Ty));\n      const llvm::DataLayout &DL =\n          CGM.getModule()->getDataLayout();\n      Expr *Nums = Ty->getNums();\n      uint64_t NumElements =\n          llvm::cast<IntegerLiteral>(Nums)\n              ->getValue()\n              .getZExtValue();\n      llvm::SmallVector<llvm::Metadata *, 4> Subscripts;\n      Subscripts.push_back(\n          DBuilder.getOrCreateSubrange(0, NumElements));\n      return DBuilder.createArrayType(\n          DL.getTypeSizeInBits(ATy) * 8,\n          1 << Log2(DL.getABITypeAlign(ATy)),\n          getType(Ty->getType()),\n          DBuilder.getOrCreateArray(Subscripts));\n    }\n    ```", "```cpp\n\n    llvm::DIType *\n    CGDebugInfo::getType(TypeDeclaration *Ty) {\n      if (llvm::DIType *T = TypeCache[Ty])\n        return T;\n      if (llvm::isa<PervasiveTypeDeclaration>(Ty))\n        return TypeCache[Ty] = getPervasiveType(Ty);\n      else if (auto *AliasTy =\n                   llvm::dyn_cast<AliasTypeDeclaration>(Ty))\n        return TypeCache[Ty] = getAliasType(AliasTy);\n      else if (auto *ArrayTy =\n                   llvm::dyn_cast<ArrayTypeDeclaration>(Ty))\n        return TypeCache[Ty] = getArrayType(ArrayTy);\n      else if (auto *RecordTy =\n                   llvm ::dyn_cast<RecordTypeDeclaration>(\n                       Ty))\n        return TypeCache[Ty] = getRecordType(RecordTy);\n      llvm::report_fatal_error(\"Unsupported type\");\n      return nullptr;\n    }\n    ```", "```cpp\n\n    void CGDebugInfo::emitGlobalVariable(\n        VariableDeclaration *Decl,\n        llvm::GlobalVariable *V) {\n      llvm::DIGlobalVariableExpression *GV =\n          DBuilder.createGlobalVariableExpression(\n              getScope(), Decl->getName(), V->getName(),\n              CU->getFile(),\n              getLineNumber(Decl->getLocation()),\n              getType(Decl->getType()), false);\n      V->addDebugInfo(GV);\n    }\n    ```", "```cpp\n\n    llvm::DISubroutineType *\n    CGDebugInfo::getType(ProcedureDeclaration *P) {\n      llvm::SmallVector<llvm::Metadata *, 4> Types;\n      const llvm::DataLayout &DL =\n          CGM.getModule()->getDataLayout();\n      // Return type at index 0\n      if (P->getRetType())\n        Types.push_back(getType(P->getRetType()));\n      else\n        Types.push_back(\n            DBuilder.createUnspecifiedType(\"void\"));\n      for (const auto *FP : P->getFormalParams()) {\n        llvm::DIType *PT = getType(FP->getType());\n        if (FP->isVar()) {\n          llvm::Type *PTy = CGM.convertType(FP->getType());\n          PT = DBuilder.createReferenceType(\n              llvm::dwarf::DW_TAG_reference_type, PT,\n              DL.getTypeSizeInBits(PTy) * 8,\n              1 << Log2(DL.getABITypeAlign(PTy)));\n        }\n        Types.push_back(PT);\n      }\n      return DBuilder.createSubroutineType(\n          DBuilder.getOrCreateTypeArray(Types));\n    }\n    ```", "```cpp\n\n    void CGDebugInfo::emitProcedure(\n        ProcedureDeclaration *Decl, llvm::Function *Fn) {\n      llvm::DISubroutineType *SubT = getType(Decl);\n      llvm::DISubprogram *Sub = DBuilder.createFunction(\n          getScope(), Decl->getName(), Fn->getName(),\n          CU->getFile(), getLineNumber(Decl->getLocation()),\n          SubT, getLineNumber(Decl->getLocation()),\n          llvm::DINode::FlagPrototyped,\n          llvm::DISubprogram::SPFlagDefinition);\n      openScope(Sub);\n      Fn->setSubprogram(Sub);\n    }\n    ```", "```cpp\n\n    void CGDebugInfo::emitProcedureEnd(\n        ProcedureDeclaration *Decl, llvm::Function *Fn) {\n      if (Fn && Fn->getSubprogram())\n        DBuilder.finalizeSubprogram(Fn->getSubprogram());\n      closeScope();\n    }\n    ```", "```cpp\n\n    void CGDebugInfo::finalize() { DBuilder.finalize(); }\n    ```", "```cpp\n\nstatic llvm::cl::opt<bool>\n    Debug(\"g\", llvm::cl::desc(\"Generate debug information\"),\n          llvm::cl::init(false));\n```", "```cpp\n\n  if (Debug)\n    DebugInfo.reset(new CGDebugInfo(*this));\n```", "```cpp\n\nCGDebugInfo *getDbgInfo() {\n  return DebugInfo.get();\n}\n```", "```cpp\n\nVariableDeclaration *Var = …;\nllvm::GlobalVariable *V = …;\nif (CGDebugInfo *Dbg = getDbgInfo())\n  Dbg->emitGlobalVariable(Var, V);\n```", "```cpp\n\nllvm::DebugLoc CGDebugInfo::getDebugLoc(SMLoc Loc) {\n  std::pair<unsigned, unsigned> LineAndCol =\n      CGM.getASTCtx().getSourceMgr().getLineAndColumn(Loc);\n  llvm::DILocation *DILoc = llvm::DILocation::get(\n      CGM.getLLVMCtx(), LineAndCol.first, LineAndCol.second,\n      getScope());\n  return llvm::DebugLoc(DILoc);\n}\n```", "```cpp\n\nvoid CGModule::applyLocation(llvm::Instruction *Inst,\n                             llvm::SMLoc Loc) {\n  if (CGDebugInfo *Dbg = getDbgInfo())\n    Inst->setDebugLoc(Dbg->getDebugLoc(Loc));\n}\n```"]