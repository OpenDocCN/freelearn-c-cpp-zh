- en: Escape the Maze
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逃离迷宫
- en: In the previous chapter, you learned how Godot's node system works, allowing
    you to build a complex scene out of smaller building blocks, each providing different
    functionalities for your game's objects. This process will continue as you move
    up to larger and more complex projects. However, sometimes you'll find yourself
    duplicating the same nodes and/or code in more than one different object, and
    this project will introduce some techniques for reducing the amount of repeated
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了Godot的节点系统是如何工作的，这让你能够用更小的构建块构建复杂的场景，每个构建块都为你的游戏对象提供不同的功能。当你开始构建更大、更复杂的项目时，这个过程将继续。然而，有时你会在多个不同的对象中重复相同的节点和/或代码，这个项目将介绍一些减少重复代码数量的技术。
- en: 'In this chapter, you''ll build a game called **Escape the Maze**. In this game,
    you will be trying to navigate a maze to find the exit while avoiding the roaming
    enemies:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将构建一个名为**逃离迷宫**的游戏。在这个游戏中，你将尝试在迷宫中导航以找到出口，同时避开游荡的敌人：
- en: '![](img/f19f1bec-1b9d-4259-911a-fa948896fd3b.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f19f1bec-1b9d-4259-911a-fa948896fd3b.png)'
- en: 'You will learn about the following key topics in this project:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将学习以下关键主题：
- en: Inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Grid-based movement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于网格的移动
- en: Spritesheet animation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵动画
- en: Using TileMaps for level design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TileMaps进行关卡设计
- en: Transitioning between scenes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景之间的转换
- en: Project setup
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: Create a new project and download the project assets from [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并从[https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases)下载项目资源。
- en: As you've seen previously, Godot, by default, includes a number of input actions
    mapped to various keyboard inputs. For example, you used `ui_left` and `ui_right`
    for arrow key movement in the first project. Often, however, you need a different
    input from the defaults provided, or you'd like to customize the actions' names.
    You might also wish to add actions for mouse or gamepad inputs. You can do this
    in the Project Settings window.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所见，Godot默认包含了许多映射到各种键盘输入的输入动作。例如，在第一个项目中，你使用了`ui_left`和`ui_right`进行箭头键移动。然而，通常你需要一个不同的输入，或者你希望自定义动作的名称。你也可能希望添加鼠标或游戏手柄的输入动作。你可以在项目设置窗口中完成这些操作。
- en: 'Click on the Input Map tab and add four new input actions (left, right, up,
    and down) by typing the names into the Action: box and clicking Add. Then, for
    each new action, click the + button to add a Key action and choose the corresponding
    arrow key. You can also add WASD controls, if you wish:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“输入映射”选项卡，通过在“动作：”框中输入名称并点击“添加”来添加四个新的输入动作（左、右、上、下）。然后，对于每个新动作，点击+按钮添加一个键动作并选择相应的箭头键。你也可以添加WASD控制，如果需要的话：
- en: '![](img/964a2860-a805-4591-b4cc-dff6c68e5e4d.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/964a2860-a805-4591-b4cc-dff6c68e5e4d.png)'
- en: This game will have a variety of objects on the screen. Some of them should
    detect collisions (the player against the walls, for example), while others should
    ignore one another (like the enemies versus coins). You can solve this by setting
    the objects' physics layer and physics layer mask properties. To make these layers
    easier to work with, Godot allows you to give the game's physics layers custom
    names.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏将在屏幕上显示各种对象。其中一些应该检测碰撞（例如玩家与墙壁的碰撞），而其他一些应该相互忽略（如敌人与金币）。你可以通过设置对象的物理层和物理层掩码属性来解决此问题。为了使这些层更容易使用，Godot允许你为游戏物理层指定自定义名称。
- en: 'Click on the General tab and find the Layer Names/2D Physics section. Name
    the first four layers as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“常规”选项卡，找到“层名称/2D物理”部分。将前四个层命名为以下内容：
- en: '![](img/eac9f379-4f8b-470d-b102-b7a00d134781.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eac9f379-4f8b-470d-b102-b7a00d134781.png)'
- en: You'll see how the collision layer system works with the various objects in
    the game later in the project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在项目的后期看到碰撞层系统如何与游戏中的各种对象协同工作。
- en: 'Next, in the Display/Window section, set the Mode to viewport and the Aspect
    to keep. This will enable you to resize the game window while keeping the display''s
    proportions unchanged. Refer to the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在“显示/窗口”部分，将“模式”设置为视口，将“纵横比”设置为保持。这将使你能够在保持显示比例不变的情况下调整游戏窗口的大小。参考以下截图：
- en: '![](img/7343da03-609c-48c0-8503-74454e3b6cef.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7343da03-609c-48c0-8503-74454e3b6cef.png)'
- en: 'Finally, in the Rendering/Quality section, set Use Pixel Snap to On. This setting
    is useful, especially for pixel art-styled games, as it ensures that all objects
    are drawn at whole-number pixel values. Note that this does not affect movement,
    physics, or other properties; it only applies to the rendering of objects. Refer
    to the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 渲染/质量 部分，将 使用像素捕捉 设置为开启。这个设置很有用，特别是对于像素艺术风格的游戏，因为它确保所有对象都绘制在整数值的像素上。请注意，这 不会影响移动、物理或其他属性；它仅适用于对象的渲染。参考以下截图：
- en: '![](img/e5baf2f7-a74a-4f1e-965b-73961d090e31.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5baf2f7-a74a-4f1e-965b-73961d090e31.png)'
- en: Project organization
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目组织
- en: As your projects become larger and more involved, you'll find that saving all
    of your scenes and scripts in the same folder becomes unwieldy.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的项目变得更大、更复杂，你会发现将所有场景和脚本保存在同一个文件夹中变得难以管理。
- en: A common response to this by Godot beginners is to make a `scenes` folder and
    a `scripts` folder, and to save each type of file in the respective folder. This
    isn't very effective. Soon, you find yourself hunting through the `scripts` folder,
    looking for the script you need because it's jumbled up with all the other scripts
    of your game.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Godot初学者对此的常见反应是创建一个`scenes`文件夹和一个`scripts`文件夹，并将每种类型的文件保存在相应的文件夹中。这样做并不十分有效。很快，你就会发现自己需要在`scripts`文件夹中翻找，寻找需要的脚本，因为它与其他所有游戏脚本混在一起。
- en: 'A more logical organization is to create a folder for each type of object.
    A `player` folder, for example, will hold the player''s scene file, script(s),
    and any other resources that it needs. Organizing your project in this way is
    much more scalable and can be extended even further if you have a very large number
    of objects. For example, refer to the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更合理的组织方式是为每种类型的对象创建一个文件夹。例如，一个`player`文件夹将包含玩家的场景文件、脚本以及它需要的任何其他资源。以这种方式组织项目更具可扩展性，如果你有大量对象，还可以进一步扩展。例如，参考以下截图：
- en: '![](img/e165e4c5-5204-48bf-bc61-d13f624945c1.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e165e4c5-5204-48bf-bc61-d13f624945c1.png)'
- en: Throughout this project, the examples will assume that each new scene type is
    being saved in a folder of that type, along with its script. The `Player.tscn`
    and `Player.gd` files, for example, will be saved in a `player` folder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个项目中，示例将假设每个新的场景类型都保存在该类型的文件夹中，包括其脚本。例如，`Player.tscn`和`Player.gd`文件将被保存在`player`文件夹中。
- en: Inheritance
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: In **Object-Oriented Programming** (**OOP**), inheritance is a powerful tool.
    Put briefly, you can define a class that *inherits* from another class. An object
    created using the first class will contain all of the methods and member variables
    of the master class as well as its own.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在**面向对象编程**（**OOP**）中，继承是一个强大的工具。简要来说，你可以定义一个从另一个类继承的类。使用第一个类创建的对象将包含主类的所有方法和成员变量，以及它自己的。
- en: Godot is strongly object-oriented, and this gives you the opportunity to use
    inheritance not just with objects (scripts) but also with scenes, allowing you
    a great deal of flexibility when designing your game's architecture. It also removes
    the need to duplicate code—if two objects need to share a set of methods and variables,
    for example, you can create a common script and let both objects inherit from
    it. If you make a change to that code, it will apply to both objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Godot是强面向对象的，这让你有机会不仅可以在对象（脚本）中使用继承，还可以在场景中使用，这在你设计游戏架构时提供了很大的灵活性。它还消除了代码重复的需要——如果两个对象需要共享一组方法和变量，例如，你可以创建一个公共脚本，并让两个对象从它继承。如果你修改了这段代码，它将应用到两个对象上。
- en: 'In this project, the player''s character will be controlled by key events,
    while the mobs will wander around the maze randomly. However, both types of character
    need to have a number of properties and functions in common:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，玩家的角色将由按键事件控制，而怪物将在迷宫中随机游荡。然而，这两种类型的角色都需要一些共同的属性和函数：
- en: A spritesheet containing the four directional movement animations
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含四个方向移动动画的精灵表
- en: An `AnimationPlayer` to play the movement animations
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于播放移动动画的`AnimationPlayer`
- en: Grid-based movement (the character can only move one full *tile* at a time)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于网格的移动（角色每次只能移动一个完整的*tile*）
- en: Collision detection (the character can't move through walls)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测（角色不能穿过墙壁）
- en: By using inheritance, you can create a generic `Character` scene containing
    the nodes that all characters need. The player and mob scenes can inherit the
    shared nodes from that scene. Similarly, the actual movement code (though not
    the controls) will be identical between player and mob, so they can both inherit
    from the same script to handle movement.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用继承，你可以创建一个通用的`Character`场景，其中包含所有角色所需的节点。玩家和怪物场景可以继承该场景中的共享节点。同样，实际的运动代码（尽管不是控制代码）在玩家和怪物之间将是相同的，因此它们都可以从同一个脚本中继承以处理运动。
- en: Character scene
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色场景
- en: Start creating the `Character` scene by adding an `Area2D` and naming it `Character`.
    `Area2D` is a good choice for this type of character because its main function
    will be to detect overlaps—when it moves onto an item or enemy, for example.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 开始创建`Character`场景，添加一个`Area2D`并将其命名为`Character`。`Area2D`是这种类型角色的好选择，因为其主要功能将是检测重叠——例如，当它移动到物品或敌人上时。
- en: 'Add the following children:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下子节点：
- en: '`Sprite`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite`'
- en: '`CollisionShape2D`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollisionShape2D`'
- en: '`Tween` (named `MoveTween`)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tween`（命名为`MoveTween`)'
- en: '`AnimationPlayer`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnimationPlayer`'
- en: Leave the `Sprite` without a texture, but in the Inspector, under the Animation
    section of the `Sprite`, set its Vframes and Hframes properties to `4` and `5`,
    respectively. This tells Godot to slice the texture into a 5 x 4 grid of individual
    images.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不要给`Sprite`添加纹理，但在检查器中，在`Sprite`的动画部分下，将Vframes和Hframes属性分别设置为`4`和`5`。这告诉Godot将纹理切割成5
    x 4个单独图像的网格。
- en: 'The spritesheets you''ll use for the player and the enemy are arranged in exactly
    this pattern, with each row containing the animation frames for a single direction
    of movement:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你将用于玩家和敌人的spritesheets正好按照这种模式排列，每一行包含一个移动方向的动画帧：
- en: '![](img/c554daf6-fbfe-46b2-a55a-a5093674c110.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/c554daf6-fbfe-46b2-a55a-a5093674c110.png)'
- en: 'When a spritesheet has been sliced using the Vframes and Hframes properties,
    you can use the Frame property to set which individual frame to use. In the preceding
    player sheet, the left-facing animation would use frames 5 through 9 (counting
    from frame 0 in the upper-left corner). You''ll use an `AnimationPlayer` to change
    the Frame property below. Refer to the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Vframes和Hframes属性切割了spritesheet后，你可以使用Frame属性来设置要使用的单个帧。在先前的玩家图中，面向左边的动画将使用帧5到9（从左上角的帧0开始计数）。你将使用`AnimationPlayer`来更改下面的Frame属性。参考以下截图：
- en: '![](img/f663cd4f-8aca-4a47-910a-bb09fb1b5791.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f663cd4f-8aca-4a47-910a-bb09fb1b5791.png)'
- en: Next, create a new `RectangleShape2D` in the collision shape's Shape. Click
    on the new <RectangleShape2D> and set its Extents property in the Inspector to
    `(16, 16)`. Note that Extents measures the distance from the center in each direction,
    so this results in a collision shape that is 32 by 32 pixels.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在碰撞形状的形状中创建一个新的`RectangleShape2D`。点击新的<RectangleShape2D>，并在检查器中将它的范围属性设置为`(16,
    16)`。请注意，范围是从中心到每个方向的距离，因此这会产生一个32 x 32像素的碰撞形状。
- en: Because all the characters are drawn to the same scale, we can be confident
    that the same sized collision shape will work for all characters. If this isn’t
    the case with the art you’re using, you can skip setting the collision shape here
    and configure it later for the individual inherited scenes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有角色都是绘制到相同的比例，我们可以确信相同的碰撞形状将适用于所有角色。如果你的艺术作品中不是这样，你可以跳过在这里设置碰撞形状，稍后为继承的各个场景进行配置。
- en: Animations
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: 'Create four new animations in the `AnimationPlayer` node. Name them to match
    the four directions you used in the input actions (left, right, up, and down).
    It''s important that the spelling matches here: the names of the input actions
    must have the same spelling and capitalization as the animation names. If you
    are inconsistent in naming, it will make things much more difficult when you get
    to the scripting stage. Take a look at the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AnimationPlayer`节点中创建四个新的动画。将它们命名为与输入动作中使用的四个方向（左、右、上和下）相匹配。在这里拼写很重要：输入动作的名称必须与动画名称具有相同的拼写和大小写。如果你在命名上不一致，当你进入脚本阶段时，事情会变得困难得多。看看下面的截图：
- en: '![](img/ce46a833-f716-440f-965b-d9b467889a3f.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/ce46a833-f716-440f-965b-d9b467889a3f.png)'
- en: 'For each animation, set the Length to `1` and the Step to `0.2`. These properties
    are located at the bottom of the Animation panel:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个动画，将`Length`设置为`1`和`Step`设置为`0.2`。这些属性位于动画面板的底部：
- en: '![](img/fb366165-9935-422a-9104-3e26b79339ca.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/fb366165-9935-422a-9104-3e26b79339ca.png)'
- en: 'Starting with the down animation, click on the `Sprite` node and set its Frame
    property to `0`. Click the key icon next to the Frame property and confirm that
    you want to add a new track for the Frame property:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'Starting with the down animation, click on the `Sprite` node and set its Frame
    property to `0`. Click the key icon next to the Frame property and confirm that
    you want to add a new track for the Frame property:'
- en: '![](img/86edd2e7-02ab-4584-9de5-0fb163306411.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86edd2e7-02ab-4584-9de5-0fb163306411.png)'
- en: 'The Frame property will automatically be incremented by one and the animation
    track will be advanced by one step (0.2 seconds). Click the key again until you''ve
    reached frame 4\. You should now have five keyframes on the animation track. If
    you drag the bar back and forth, you''ll see the Frame property change as you
    reach each keyframe:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'The Frame property will automatically be incremented by one and the animation
    track will be advanced by one step (0.2 seconds). Click the key again until you''ve
    reached frame 4\. You should now have five keyframes on the animation track. If
    you drag the bar back and forth, you''ll see the Frame property change as you
    reach each keyframe:'
- en: '![](img/b444d4c1-bc7a-4f7c-a53d-ee51fa9c8108.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b444d4c1-bc7a-4f7c-a53d-ee51fa9c8108.png)'
- en: If, for some reason, you find that the frames aren't correct, you can delete
    any of the keyframes by clicking on the dot and pressing *Delete* on your keyboard,
    or right-clicking on the dot and choosing Remove Selection. Remember, whatever
    value you set Frame to, that will be the value of the keyframe when you press
    the Add Keyframe button. You can also click and drag keyframes to change their
    order in the timeline.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: If, for some reason, you find that the frames aren't correct, you can delete
    any of the keyframes by clicking on the dot and pressing *Delete* on your keyboard,
    or right-clicking on the dot and choosing Remove Selection. Remember, whatever
    value you set Frame to, that will be the value of the keyframe when you press
    the Add Keyframe button. You can also click and drag keyframes to change their
    order in the timeline.
- en: 'Repeat the process for the other animations, using the following table to guide
    you on which keyframes to use for each direction:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'Repeat the process for the other animations, using the following table to guide
    you on which keyframes to use for each direction:'
- en: '| **Animation** | **Frames** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **动画** | **帧数** |'
- en: '| Down | `0, 1, 2, 3, 4` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 向下 | `0, 1, 2, 3, 4` |'
- en: '| Left | `5, 6, 7, 8, 9` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 向左 | `5, 6, 7, 8, 9` |'
- en: '| Right | `10, 11, 12, 13, 14` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 向右 | `10, 11, 12, 13, 14` |'
- en: '| Up | `15, 16, 17, 18, 19` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 向上 | `15, 16, 17, 18, 19` |'
- en: As long as the spritesheet for a character follows the same 5 x 4 arrangement,
    this `AnimationPlayer` configuration will work, and you won't need to create separate
    animations for each character. In larger projects, it can be a huge time-saver
    to create all your spritesheet animations while following a common pattern.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: As long as the spritesheet for a character follows the same 5 x 4 arrangement,
    this `AnimationPlayer` configuration will work, and you won't need to create separate
    animations for each character. In larger projects, it can be a huge time-saver
    to create all your spritesheet animations while following a common pattern.
- en: Collision detection
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Because the characters are moving on a grid, they need to either move the full
    distance to the next tile or not at all. This means that, before moving, the character
    needs to check to see if the move is possible. One way to test if an adjacent
    square has anything in it is by using a *raycast*. **Raycasting** means extending
    a ray from the character's position to a given destination. If the ray encounters
    any object along the way, it will report that contact. By adding four rays to
    the character, it can *look* at the squares around it to see if they are unoccupied.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Because the characters are moving on a grid, they need to either move the full
    distance to the next tile or not at all. This means that, before moving, the character
    needs to check to see if the move is possible. One way to test if an adjacent
    square has anything in it is by using a *raycast*. **光线投射**意味着从角色的位置向一个指定的目的地延伸一条光线。如果光线在途中遇到任何物体，它将报告接触。通过向角色添加四个光线，它可以*观察*周围的方块，以查看它们是否被占用。
- en: 'Add four `RayCast2D` nodes and set their names and **Cast To** properties as
    follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'Add four `RayCast2D` nodes and set their names and **投射到** properties as follows:'
- en: '| **Name** | **Cast To** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **投射到** |'
- en: '| RayCastRight | `(64, 0)` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| RayCastRight | `(64, 0)` |'
- en: '| RayCastLeft | `(-64, 0)` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| RayCastLeft | `(-64, 0)` |'
- en: '| RayCastDown | `(0, 64)` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| RayCastDown | `(0, 64)` |'
- en: '| RayCastUp | `(0, -64)` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| RayCastUp | `(0, -64)` |'
- en: 'Make sure to set the Enabled property on each one (`RayCast2D` options are
    disabled by default). Your final node setup should look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'Make sure to set the Enabled property on each one (`RayCast2D` options are
    disabled by default). Your final node setup should look like this:'
- en: '![](img/bd237305-31ae-4e68-9b68-42f20a77f562.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd237305-31ae-4e68-9b68-42f20a77f562.png)'
- en: Character script
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色脚本
- en: 'Now, add a script to the `Character` node (make sure you''ve saved the scene
    first, and the script will automatically be named `Character.gd`). First, define
    the class variables:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now, add a script to the `Character` node (make sure you''ve saved the scene
    first, and the script will automatically be named `Character.gd`). First, define
    the class variables:'
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`speed` will control the movement and animation speed of the character, allowing
    you to customize the movement speed. As you learned in [Chapter 1](fee8a22d-c169-454d-be5e-cf6c0bc78ddb.xhtml),
    *Introduction*, using `export` allows you to set the value of a variable via the
    Inspector. Save the script and set the Speed property to `3` in the Inspector.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`speed` 将控制角色的移动和动画速度，允许您自定义移动速度。正如您在 [第 1 章](fee8a22d-c169-454d-be5e-cf6c0bc78ddb.xhtml)
    中所学的，*简介*，使用 `export` 允许您通过检查器设置变量的值。保存脚本，并在检查器中将速度属性设置为 `3`。'
- en: '`can_move` is a flag that will track whether the character is allowed to move
    during the current frame. It will be set to `false` while the movement is underway,
    preventing a second movement from being started before the previous one has finished.
    `facing` is a string denoting the current direction of movement (again, spelled
    and capitalized exactly like the input actions you created at the beginning of
    the project). The `moves` dictionary contains vectors describing the four directions,
    while the `raycasts` dictionary contains references to the four raycast nodes.
    Note that both dictionaries'' keys match the input action names.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`can_move` 是一个标志，用于跟踪角色在当前帧是否允许移动。在移动进行时，它将被设置为 `false`，以防止在上一移动完成之前启动第二次移动。`facing`
    是一个表示当前移动方向的字符串（再次强调，拼写和首字母大小写必须与项目开始时创建的输入动作完全一致）。`moves` 字典包含描述四个方向的向量，而 `raycasts`
    字典包含四个射线投射节点的引用。请注意，这两个字典的键与输入动作名称匹配。'
- en: 'When referencing another node during variable declaration, you must use `onready` to
    ensure that the variable isn''t set before the referenced node is ready. You can
    think of it as a shortcut to writing the code in the `_ready()` function. This
    line:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量声明期间引用另一个节点时，您必须使用 `onready` 来确保变量在引用的节点准备好之前不会被设置。您可以将它视为在 `_ready()` 函数中编写代码的快捷方式。以下这行代码：
- en: '`onready var sprite = $Sprite`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`onready var sprite = $Sprite`'
- en: 'Is equivalent to writing this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于以下代码：
- en: '`var sprite`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`var sprite`'
- en: '`func _ready():`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`func _ready():`'
- en: '`    sprite = $Sprite`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`    sprite = $Sprite`'
- en: 'The following is the code that will execute a movement from one square to another:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从一个方块移动到另一个方块的代码：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`move()` takes a direction as an argument. If the `RayCast2D` for the given
    direction detects a collision, the move is canceled and the function returns without
    executing further (note that the return value will be `null`). Otherwise, it changes
    `facing` to the new direction, disables additional movement with `can_move`, and
    starts playing the matching animation. To actually perform the movement, the `Tween`
    node interpolates the `position` property from its current value to its current
    value plus a tile-sized movement in the given direction. The duration (`1.0 /
    speed` seconds) is set to match the length of the animation.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`move()` 接收一个方向作为参数。如果给定方向的 `RayCast2D` 检测到碰撞，移动将被取消，函数将返回而不执行进一步操作（请注意，返回值将为
    `null`）。否则，它将 `facing` 改为新的方向，使用 `can_move` 禁止额外的移动，并开始播放匹配的动画。为了实际执行移动，`Tween`
    节点将 `position` 属性从当前值插值到当前值加上给定方向一个方块大小的移动。持续时间（`1.0 / speed` 秒）设置为与动画长度相匹配。'
- en: Using the `Tween.TRANS_SINE` transition type results in a pleasing, smooth movement
    that accelerates up and then down to the final position. Feel free to try other
    transition types here to alter the movement style.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Tween.TRANS_SINE` 过渡类型会产生令人愉悦、平滑的运动，先加速然后减速到最终位置。您可以随意尝试其他过渡类型来改变运动风格。
- en: 'Finally, to enable movement again, you need to reset `can_move` when the movement
    has finished. Connect the `tween_completed` signal from `MoveTween` and add the
    following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了再次启用移动，当移动完成后，您需要重置 `can_move`。将 `MoveTween` 的 `tween_completed` 信号连接起来，并添加以下代码：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Player scene
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家场景
- en: The player scene needs to contain all the same nodes we gave to `Character`.
    This is where you'll take advantage of the power of inheritance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家场景需要包含我们给 `Character` 的所有相同节点。这是您将利用继承的强大功能的地方。
- en: 'Start by making a new scene. However, instead of making a new empty scene,
    click on Scene | New Inherited Scene in the menu. In the Open Base Scene window,
    select `res://character/Character.tscn`, as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的场景。但是，不要创建一个新的空场景，而是在菜单中点击场景 | 新继承场景。在打开基本场景窗口中，选择 `res://character/Character.tscn`，如下截图所示：
- en: '![](img/e68733c2-c456-4970-9e21-17f83ce9e7b0.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e68733c2-c456-4970-9e21-17f83ce9e7b0.png)'
- en: Rename the root node of this new scene from `Character` to `Player` and save
    the new scene. Note that all the `Character` nodes are also present. If you make
    a change to `Character.tscn` and save it, the changes will also take effect in
    the `Player` scene.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将此新场景的根节点从`Character`重命名为`Player`并保存新场景。请注意，所有`Character`节点也都在其中。如果你修改了`Character.tscn`并保存，这些更改也将影响`Player`场景。
- en: 'Now, you need to set the Player''s physics layers, so find the Collision section
    in the Inspector and set the Layer and Mask properties. Layer should be set to
    player only, while Mask should show walls, enemies, and items. Refer to the following
    screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要设置玩家的物理层，所以在检查器中找到碰撞部分并设置层和掩码属性。层应设置为仅玩家，而掩码应显示墙壁、敌人和物品。参考以下截图：
- en: '![](img/c545783f-9bd2-45e5-b68e-899493a4baba.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c545783f-9bd2-45e5-b68e-899493a4baba.png)'
- en: The collision layers system is a powerful tool that allows you to customize
    which objects can detect each other. The Layer property places the object in one
    or more collision layers, while the Mask property defines what layers the object
    can *see*. If another object is not in one of its mask layers, it will not be
    detected or collided with.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞层系统是一个强大的工具，它允许你自定义哪些对象可以检测彼此。层属性将对象放置在一个或多个碰撞层中，而掩码属性定义了对象可以看到哪些层。如果另一个对象不在其掩码层之一中，它将不会被检测或碰撞。
- en: 'The only other node that needs to be changed is the `Sprite`, where you need
    to set the texture. Drag the player spritesheet from the `res://assets` folder
    and drop it in the Texture property of the `Sprite`. Go ahead and test out the
    animations in the `AnimationPlayer` and make sure they''re showing the correct
    directions. If you find a problem with any of the animations, make sure you fix
    it in the `Character` scene, and it will automatically be fixed in the `Player`
    scene as well:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更改的唯一其他节点是`Sprite`，在那里你需要设置纹理。将玩家精灵表从`res://assets`文件夹拖动并放入`Sprite`的纹理属性中。继续测试`AnimationPlayer`中的动画，确保它们显示正确的方向。如果你发现任何动画有问题，确保你在`Character`场景中修复它，它将在`Player`场景中自动修复：
- en: '![](img/353109fb-1fb2-4d8b-a357-5a3b9f997b9f.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/353109fb-1fb2-4d8b-a357-5a3b9f997b9f.png)'
- en: Add a `Camera` node as a child of `Player` and check its Current property to
    On. Godot will automatically render whatever the current camera sees in the game
    window. This will allow you to make maps of any size, and the camera will scroll
    the map as the player walks around on it. Note that when you add the camera, a
    purplish box appears, which is centered on the player. This represents the camera's
    visible region, and because it's a child of the player, it follows the player's
    movement. If you look at the camera's properties in the Inspector, you'll see
    four Limit properties. These are used to stop the camera from scrolling past a
    certain point; the edge of your map, for example. Try adjusting them and see how
    the box stops following the `Player` as you drag it around the screen (make sure
    you're moving the `Player` node itself and not one of its children). Later, the
    limits will be set automatically by the level itself so that the camera won't
    scroll "outside" the level.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个`Camera`节点作为`Player`的子节点添加，并检查其当前属性是否为开启。Godot将自动在游戏窗口中渲染当前相机看到的任何内容。这将允许你制作任何大小的地图，并且相机会随着玩家在地图上移动而滚动。请注意，当你添加相机时，会出现一个紫色的框，它位于玩家的中心。这代表相机的可见区域，因为它作为玩家的子节点，所以会跟随玩家的移动。如果你查看检查器中的相机属性，你会看到四个限制属性。这些属性用于阻止相机滚动过某个点；例如，你的地图边缘。尝试调整它们，看看当你拖动它时，框是如何停止跟随`Player`的（确保你移动的是`Player`节点本身，而不是其子节点）。稍后，这些限制将由关卡本身自动设置，这样相机就不会滚动到“关卡之外”。
- en: Player script
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家脚本
- en: 'The player''s script also needs to extend the character''s. Remove the attached
    script (`Character.gd`) by selecting the `Player` node and clicking the Clear
    script button:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的脚本也需要扩展角色的。通过选择`Player`节点并点击清除脚本按钮来移除附加的脚本（`Character.gd`）：
- en: '![](img/e7c51b12-110b-41a5-95f9-ff99ec221486.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7c51b12-110b-41a5-95f9-ff99ec221486.png)'
- en: 'Now, click the button again to attach a new script. In the Attach Node Script
    dialog, click the folder icon next to the Inherits option and select `Character.gd`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次点击按钮以附加新的脚本。在附加节点脚本对话框中，点击继承选项旁边的文件夹图标并选择`Character.gd`：
- en: '![](img/b4f9da4b-625b-4d06-ac50-7489945e1433.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4f9da4b-625b-4d06-ac50-7489945e1433.png)'
- en: 'Here is the player script (note that it `extends` the character script):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是玩家脚本（注意它`extends`了角色脚本）：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because it inherits all the behavior from `Character.gd`, the player will also
    have the `move()` function. You just need to extend it with code to call `move()`
    based on the input events. As you've seen before, you can use the `process()`
    function to check the input state each frame. However, only if `can_move` allows
    it do you actually check the inputs and call `move()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它继承了`Character.gd`的所有行为，玩家也将拥有`move()`函数。你只需要用代码扩展它，根据输入事件调用`move()`。正如你之前看到的，你可以使用`process()`函数来检查每一帧的输入状态。然而，只有当`can_move`允许时，你才实际上检查输入并调用`move()`。
- en: Because you used the names `up`, `down`, `left`, and `right` for the input actions
    as well as the keys to the `moves` and `raycasts` dictionaries, you can loop through
    those keys and check each one as an input as well.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在输入动作以及`moves`和`raycasts`字典的键中使用了`up`、`down`、`left`和`right`这些名称，你可以遍历这些键并检查每个键作为输入。
- en: Recall that `move()` returns `true` if it succeeds. If it does, the player emits
    the `moved` signal, which you'll be able to use later with the enemies.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`move()`函数在成功时返回`true`。如果成功，玩家将发出`moved`信号，你可以在之后与敌人一起使用这个信号。
- en: Run the scene and try moving the player character around the screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行场景并尝试移动玩家角色在屏幕上的位置。
- en: 'The player doesn''t have a level to walk around on yet, but you can go ahead
    and add the code the player will need later. As the player moves around the level,
    it will encounter various objects and needs to respond to them. By using signals,
    you can add the code for this before you''ve even created the level. Add three
    more signals to the script:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家目前还没有可以行走的关卡，但你可以先添加玩家稍后需要的代码。当玩家在关卡中移动时，会遇到各种对象并需要对其做出响应。通过使用信号，你可以在创建关卡之前就添加相应的代码。向脚本中添加三个更多的信号：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, connect the `area_entered` signal of the `Player` and add this code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，连接`Player`的`area_entered`信号并添加以下代码：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Whenever the player encounters another `Area2D`, this function will run. If
    the object is an enemy, the player loses the game. Note the use of `has_method()`.
    This allows you to identify collectible objects by checking whether they have
    a `pickup()` method and only call the method if it exists.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家遇到另一个`Area2D`时，此函数将运行。如果该对象是敌人，玩家将输掉游戏。注意`has_method()`的使用。这允许你通过检查是否有`pickup()`方法来识别可收集的对象，并且只有在方法存在时才调用该方法。
- en: Enemy scene
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人场景
- en: Hopefully, you're seeing how inheritance works by now. You'll create the `Enemy`
    scene using the same procedure. Make a new scene inheriting from `Character.tscn`
    and name it `Enemy`. Drag the mob spritesheet, `res://assets/slime.png`, to the
    `Sprite`'s Texture.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在已经看到了继承是如何工作的。你将使用相同的程序创建`Enemy`场景。创建一个新的场景，从`Character.tscn`继承，命名为`Enemy`。将精灵图集`res://assets/slime.png`拖放到`Sprite`的纹理上。
- en: In the Collision section of the Inspector, set the Layer and Mask properties. Layer should
    be set to enemies, while Mask should show walls and player.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器的碰撞部分，设置`Layer`和`Mask`属性。`Layer`应设置为敌人，而`Mask`应显示墙壁和玩家。
- en: 'As you did with the `Player`, remove the existing script and attach a new script
    inheriting from `Character.gd`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Player`一样，移除现有的脚本并附加一个新的脚本，从`Character.gd`继承：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code in the `_ready()` function serves an important purpose: because the
    enemies are added to the tree *below* the `TileMap` nodes, they''ll be processed
    first. You don''t want the enemies to start moving before the walls have been
    processed, or they could step onto a wall tile and get stuck. You need to have
    a small delay before they start, which also serves to give the player a moment
    to prepare. To do this, rather than add a `Timer` node to the scene, you can use
    the `create_timer()` function of the `SceneTree` to make a one-off timer, yielding
    execution until its timeout signal fires.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ready()`函数中的代码发挥着重要作用：因为敌人被添加到树中`TileMap`节点下方，它们将首先被处理。你不想让敌人在墙壁被处理之前开始移动，否则它们可能会踩到墙壁方块并卡住。在它们开始之前需要有一个小的延迟，这也有助于给玩家准备的时间。为此，你不需要在场景中添加`Timer`节点，而是可以使用`SceneTree`的`create_timer()`函数创建一个一次性定时器，直到其超时信号触发时才释放执行。'
- en: GDScript's `yield()` function provides a way to *pause* execution of a function
    until a later time, while allowing the rest of the game to continue running. When
    passed an object and a named signal, execution will resume when that object emits
    the given signal.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: GDScript的`yield()`函数提供了一种方法，可以在稍后时间暂停函数的执行，同时允许游戏的其他部分继续运行。当传递一个对象和一个命名信号时，当该对象发出给定信号时，执行将恢复。
- en: Every frame, the enemy will move if it is able to. If it runs into a wall (that
    is, when `move()` returns `null`), or sometimes just randomly, it changes direction.
    The result will be an unpredictable (and hard to dodge!) enemy movement. Remember
    that you can adjust the `Player` and `Enemy` speeds independently in their scenes,
    or change `speed` in the `Character` scene and it will affect them both.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧，如果敌人能够移动，它就会移动。如果它撞到墙壁（即`move()`返回`null`），或者有时是随机地，它会改变方向。结果将是一个不可预测的（并且难以躲避！）敌人移动。记住，你可以独立调整`Player`和`Enemy`在它们场景中的速度，或者改变`Character`场景中的`speed`，这将影响它们两个。
- en: Optional – turn-based movement
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选 - 轮流移动
- en: For a different style of game, you could put the `_process()` movement code
    in a function called `_on_Player_moved()` instead, and connect it to the player's `moved` signal.
    This would make the enemies move only when the player does, giving the game more
    of a strategic feel, rather than one of fast-paced action.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同风格的游戏，你可以将`_process()`移动代码放入一个名为`_on_Player_moved()`的函数中，并将其连接到玩家的`moved`信号。这将使敌人只在玩家移动时移动，使游戏更具策略感，而不是快节奏的动作游戏。
- en: Creating the level
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建关卡
- en: In this section, you'll create the map where all the action will take place.
    As the name implies, you'll probably want to make a maze-like level with lots
    of twists and turns.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建所有动作发生的地方的地图。正如其名所示，你可能想要创建一个迷宫般的关卡，有很多转弯和曲折。
- en: 'Here is a sample level:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例关卡：
- en: '![](img/c117363c-b5a1-45ae-b904-03e606451613.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c117363c-b5a1-45ae-b904-03e606451613.png)'
- en: The player's goal is to reach the star. Locked doors can only be opened by picking
    up the key. The green dots mark the spawn locations of enemies, while the red
    dot marks the player's start location. The coins are extra items that can be picked
    up along the way for bonus points. Note that the entire level is larger than the
    display window. The `Camera` will scroll the map as the player moves around it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的目标是到达星星。锁着的门只能通过捡起钥匙才能打开。绿色圆点标记了敌人的出生位置，而红色圆点标记了玩家的起始位置。硬币是可以在路上捡起的额外物品，可以获得额外分数。请注意，整个关卡比显示窗口大。`Camera`会随着玩家在地图上移动而滚动地图。
- en: You'll use the `TileMap` node to create the map. There are several benefits
    to using a `TileMap` for your level design. First, they make it possible to draw
    the level's layout by *painting* the tiles onto a grid, which is much faster than
    placing individual `Sprite` nodes one by one. Secondly, they allow for much larger
    levels because they are optimized for drawing large numbers of tiles efficiently
    by batching them together and only drawing the *chunks* of the map that are visible
    at a given time. Finally, you can add collision shapes to individual tiles and
    the entire map will act as a single collider, simplifying your collision code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`TileMap`节点来创建地图。使用`TileMap`进行关卡设计有几个好处。首先，它们通过在网格上*绘制*瓦片来绘制关卡布局，这比逐个放置`Sprite`节点要快得多。其次，它们允许创建更大的关卡，因为它们通过将瓦片批量一起优化，只绘制给定时间可见的地图的*块*，从而提高了绘制大量瓦片的效率。最后，你可以向单个瓦片和整个地图添加碰撞形状，这样整个地图将作为一个单独的碰撞体，简化你的碰撞代码。
- en: Once you've completed this section, you'll be able to create as many of these
    maps as you wish. You can put them in order to give a progression from level to
    level.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一部分后，你将能够创建你想要的任意数量的这些地图。你可以按顺序排列它们，以实现关卡到关卡的发展。
- en: Items
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物品
- en: 'First, create a new scene for the collectable objects that the player can pick
    up. These items will be spawned by the map when the game is run. Here is the scene
    tree:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为玩家可以捡起的可收集物品创建一个新的场景。这些物品将在游戏运行时由地图生成。以下是场景树：
- en: '![](img/6eeb8abf-8472-45e4-8bf4-d233da503d40.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6eeb8abf-8472-45e4-8bf4-d233da503d40.png)'
- en: Leave the `Sprite` Texture blank. Since you're using this object for multiple
    items, the texture can be set in the item's script when it's created.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Sprite`纹理留空。由于你使用这个对象用于多个物品，纹理可以在创建物品时在物品的脚本中设置。
- en: Set the `Pickup` Collision Layer to items and its Mask to player. You don't
    want the enemies collecting the coins before you get there (although that might
    make for a fun variation on the game where you race to get as many coins as you
    can before the bad guys gobble them up).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Pickup`碰撞层设置为物品，并将其掩码设置为玩家。你不想在到达之前让敌人收集硬币（尽管这可能是一种有趣的游戏变体，其中你需要在坏人吞掉它们之前尽可能多地收集硬币）。
- en: Give the `CollisionShape2D` node a rectangle shape and set its extents to `(32,
    32)` (strictly speaking, you can use any shape, as the player will move all the
    way onto the tile and completely overlap the item anyway).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 给 `CollisionShape2D` 节点设置矩形形状，并将其范围设置为 `(32, 32)`（严格来说，你可以使用任何形状，因为玩家会完全移动到瓦片上并完全重叠物品）。
- en: 'Here is the script for the `Pickup`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Pickup` 脚本：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `type` variable will be set when the item is created and used to determine
    what texture the object should use. Using `_type` as the variable name in the
    function argument lets you use the name without conflicting with `type`, which
    is already in use.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建和使用项目时，`type` 变量将被设置，并用于确定对象应使用哪种纹理。在函数参数中将 `_type` 作为变量名称使用，可以让你在不与已使用的
    `type` 冲突的情况下使用该名称。
- en: Some programming languages use the notion of *private* functions or variables,
    meaning they are only used locally. The `_` naming convention in GDScript is used
    to visually designate variables or functions that should be regarded as private.
    Note that they aren't actually any different from any other name; it is merely
    a visual indication for the programmer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言使用 *私有* 函数或变量的概念，这意味着它们仅用于本地。GDScript 中的 `_` 命名约定用于视觉上指定应被视为私有的变量或函数。请注意，它们实际上与其他名称没有任何不同；这仅仅是对程序员的一种视觉指示。
- en: 'The pickup effect using `Tween` is similar to the one you used for the coins
    in Coin Dash—animating the scale and opacity of `Sprite`. Connect the `tween_completed`
    signal of `Tween` so that the item can be deleted when the effect has finished:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Tween` 的拾取效果与你在 Coin Dash 中用于硬币的效果相似——动画 `Sprite` 的缩放和透明度。将 `Tween` 的 `tween_completed`
    信号连接起来，以便在效果完成后删除项目：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: TileSets
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瓦片集
- en: In order to draw a map using a `TileMap`, it must have a `TileSet` assigned
    to it. The `TileSet` contains all of the individual tile textures, along with
    any collision shapes they may have.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `TileMap` 绘制地图，它必须分配一个 `TileSet`。`TileSet` 包含所有单个瓦片的纹理，以及它们可能具有的任何碰撞形状。
- en: Depending on how many tiles you have, it can be time-consuming to create a `TileSet`,
    especially the first time. For that reason, there is a pre-generated `TileSet`
    included in the `assets` folder titled `tileset.tres`. Feel free to use that instead,
    but please don't skip the following section. It contains useful information to
    help you understand how the `TileSet` works.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你拥有的瓦片数量，创建 `TileSet` 可能会耗费时间，尤其是第一次。因此，在 `assets` 文件夹中包含了一个预先生成的 `TileSet`，名为
    `tileset.tres`。你可以自由使用它，但请勿跳过以下部分。它包含了一些有用的信息，可以帮助你理解 `TileSet` 的工作原理。
- en: Creating a TileSet
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `TileSet`
- en: A `TileSet` in Godot is a type of `Resource`. Examples of other resources include
    Textures, Animations, and Fonts. They are containers that hold a certain type
    of data, and are typically saved as `.tres` files.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Godot 中，`TileSet` 是一种 `Resource` 类型。其他资源的例子包括纹理、动画和字体。它们是包含特定类型数据的容器，通常保存为
    `.tres` 文件。
- en: By default, Godot saves files in text-based formats, indicated by the `t` in
    `.tscn` or `.tres`, for example. Text-based files are preferred over binary formats
    because they are human-readable. They are also more friendly for **Version Control
    Systems** (**VCS**), which allow you to track file changes over the course of
    building your project.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Godot 以基于文本的格式保存文件，例如 `.tscn` 或 `.tres` 中的 `t`。与二进制格式相比，基于文本的文件更易于人类阅读。它们也更友好地支持
    **版本控制系统**（**VCS**），这允许你在构建项目的过程中跟踪文件更改。
- en: To make a `TileSet`, you create a scene with a set of `Sprite` nodes containing
    the textures from your art assets. You can then add collisions and other properties
    to those `Sprite` tiles. Once you've created all the tiles, you export the scene
    as a `TileSet` resource, which can then be loaded by the `TileMap` node.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `TileSet`，你需要创建一个包含来自你的艺术资源的纹理的 `Sprite` 节点的场景。然后你可以向这些 `Sprite` 瓦片添加碰撞和其他属性。一旦创建了所有瓦片，你就可以将场景导出为
    `TileSet` 资源，然后它可以由 `TileMap` 节点加载。
- en: 'Here is a screenshot of the `TileSetMaker.tscn` scene, containing the tiles
    you''ll be using to build this game''s levels:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `TileSetMaker.tscn` 场景的截图，其中包含你将用于构建游戏级别的瓦片：
- en: '![](img/ba1919a2-d973-434c-86d0-589edea1136f.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba1919a2-d973-434c-86d0-589edea1136f.png)'
- en: 'Start by adding a `Sprite` node and setting its texture to `res://assets/sokoban_tilesheet.png`.
    To select a single tile, set the Region/Enabled property to On and click Texture
    Region at the bottom of the editor window to open the panel. Set Snap Mode to
    Grid Snap and the Step to 64px in both *x* and *y*. Now, when you click and drag
    in the texture, it will only allow you to select 64 x 64 sections of the texture:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加一个 `Sprite` 节点并将其纹理设置为 `res://assets/sokoban_tilesheet.png`。要选择单个瓷砖，将区域/启用属性设置为开启，并点击编辑器窗口底部的纹理区域以打开面板。将吸附模式设置为网格吸附，并将步长设置为64px，在
    *x* 和 *y* 方向上都一样。现在，当你点击并拖动纹理时，它只会允许你选择64 x 64的纹理区域：
- en: '![](img/e905b5a6-0c92-4a2e-93bb-56a74a93acf4.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e905b5a6-0c92-4a2e-93bb-56a74a93acf4.png)'
- en: Give the Sprite an appropriate name (`crate_brown` or `wall_red`, for example)—this
    name will appear as the tile's name in the `TileSet`. Add a `StaticBody2D` as
    a child, and then add a `CollisionPolygon2D` to that. It is important that the
    collision polygon be sized properly so that it aligns with the tiles placed next
    to it. The easiest way to do this is to turn on grid snapping in the editor window.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 给精灵起一个合适的名字（例如 `crate_brown` 或 `wall_red`）——这个名字将作为 `TileSet` 中瓷砖的名称出现。添加一个
    `StaticBody2D` 作为子节点，然后向其中添加一个 `CollisionPolygon2D`。确保碰撞多边形的大小适当，以便与相邻放置的瓷砖对齐。在编辑器窗口中启用网格吸附是最简单的方法。
- en: 'Click the Use Snap button (it looks like a magnet) and then open the snap menu
    by clicking on the three dots next to it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 点击使用吸附按钮（看起来像磁铁）然后通过点击旁边的三个点打开吸附菜单：
- en: '![](img/0dc8a750-5a5f-450f-9710-b9450f76b81f.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0dc8a750-5a5f-450f-9710-b9450f76b81f.png)'
- en: 'Choose Configure Snap... and set the Grid Step to `64` by `64`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 选择配置吸附...并将网格步长设置为 `64` by `64`：
- en: '![](img/72111e1d-9cf7-4acd-af66-9f222b0fe6ad.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72111e1d-9cf7-4acd-af66-9f222b0fe6ad.png)'
- en: 'Now, with the `CollisionPolygon2D` selected, you can click in the four corners
    of the tile one by one to create a closed square (it will appear as a reddish
    orange):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择 `CollisionPolygon2D`，你可以逐个点击瓷砖的四个角来创建一个封闭的方形（它将显示为红色橙色）：
- en: '![](img/00ff3738-828c-4c56-85fa-f1144725b12c.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00ff3738-828c-4c56-85fa-f1144725b12c.png)'
- en: This tile is now complete. You can duplicate it (*Ctrl* + *D*) and make another,
    and you only need to change the texture region. Note that collision bodies are
    only needed on the wall tiles. The ground and item tiles should not have them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个瓷砖已经完成了。你可以复制它（*Ctrl* + *D*）并制作另一个，你只需要更改纹理区域。请注意，只有墙壁瓷砖需要碰撞体。地面和物品瓷砖不应该有它们。
- en: 'When you''ve created all your tiles, click Scene | Convert To | TileSet and
    save it with an appropriate name, such as `tileset.tres`. If you come back and
    edit the scene again, you''ll need to redo the conversion. Pay special attention
    to the Merge With Existing option. If this is set to On, the current scene''s
    tiles will be *merged* with the ones already in the `tileset` file. Sometimes,
    this can result in changes to the tile indices and change your map in unwanted
    ways. Take a look at the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建完所有瓷砖后，点击场景 | 转换到 | 瓦片集，并以适当的名称保存，例如 `tileset.tres`。如果你回来再次编辑场景，你需要重新进行转换。特别注意合并现有选项。如果设置为开启，当前场景的瓷砖将与
    `tileset` 文件中已有的瓷砖合并。有时，这可能会导致瓷砖索引发生变化，并以不希望的方式更改你的地图。请查看以下截图：
- en: '![](img/a4557842-ba93-481f-85d8-44b394ef4c12.png)`tres` stands for text resource
    and is the most common format Godot stores its resource files in. Compare this
    with `tscn`, which is the text scene storage format.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/a4557842-ba93-481f-85d8-44b394ef4c12.png)`tres` 代表文本资源，是 Godot 存储资源文件最常用的格式。将其与
    `tscn` 进行比较，它是文本场景存储格式。'
- en: Your `TileSet` resource is ready to use!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `TileSet` 资源现在可以使用了！
- en: TileMaps
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瓦片地图
- en: Now, let's make a new scene for the game level. The level will be a self-contained
    scene, and will include the map and the player, and will handle spawning any items
    and enemies in the level. For the root, use a `Node2D` and name it `Level1` (later,
    you can duplicate this node setup to create more levels).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为游戏关卡创建一个新的场景。这个关卡将是一个独立的场景，包括地图和玩家，并将处理在关卡中生成任何物品和敌人。对于根节点，使用 `Node2D`
    并将其命名为 `Level1`（稍后，你可以复制这个节点设置以创建更多关卡）。
- en: You can open the `Level1.tscn` file from the assets folder to see the completed
    level scene from this section, although you're encouraged to create your own levels.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从资产文件夹中打开 `Level1.tscn` 文件来查看本节中完成的关卡场景，尽管你被鼓励创建自己的关卡。
- en: When using `TileMap`, you will often want more than one tile object to appear
    in a given location. You might want to place a tree, for example, but also have
    a ground tile appear below it. This can be done by using `TileMap` as many times
    as you like to create layers of data. For your level, you'll make three layers
    to display the ground, which the player can walk on; the walls, which are obstacles;
    and the collectible items, which are markers for spawning items like coins, keys,
    and enemies.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`TileMap`时，您可能希望在给定位置出现不止一个瓦片对象。例如，您可能想要放置一棵树，但同时也希望在它下面出现地面瓦片。这可以通过多次使用`TileMap`来创建数据层来实现。对于您的关卡，您将创建三个层来显示地面，玩家可以在上面行走；墙壁，它们是障碍物；以及可收集物品，它们是生成物品（如硬币、钥匙和敌人）的标记。
- en: 'Add a `TileMap` and name it `Ground`. Drag the `tileset.tres` into the Tile
    Set property and you''ll see the tiles appear, ready to be used, on the right-hand
    side of the editor window:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`TileMap`并将其命名为`Ground`。将`tileset.tres`拖入“瓦片集”属性，您将在编辑器窗口的右侧看到瓦片出现，准备使用：
- en: '![](img/3e9968ea-dac8-403b-99f2-42079abefcaa.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e9968ea-dac8-403b-99f2-42079abefcaa.png)'
- en: It's very easy to accidentally click and drag in the editor window and move
    your whole tile map. To prevent this, make sure you select the `Ground` node and
    click the Lock button: ![](img/5bba63ac-fb9b-4de8-9756-28e82114e973.png).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器窗口中不小心点击并拖动很容易移动整个瓦片地图。为了防止这种情况，请确保您已选择`Ground`节点并点击锁定按钮： ![](img/5bba63ac-fb9b-4de8-9756-28e82114e973.png)。
- en: Duplicate this `TileMap` twice and name the new `TileMap` nodes `Walls` and
    `Items`. Remember that Godot draws objects in the order listed in the node tree,
    from top to bottom, so `Ground` should be at the top, with `Walls` and `Items`
    underneath it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将此`TileMap`复制两次，并将新的`TileMap`节点命名为`Walls`和`Items`。请记住，Godot按节点树中列出的顺序从上到下绘制对象，因此`Ground`应该在顶部，`Walls`和`Items`在其下方。
- en: As you're drawing your level, be careful to note which layer you're drawing
    on! You should only place the item markers on the Items layer, for example, because
    that's where the code is going to look for objects to create. Don't place any
    other objects there, though, because the layer itself will be invisible during
    gameplay.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制您的关卡时，请注意您正在绘制哪个层！例如，您应该只在物品层放置物品标记，因为代码将在此处查找对象以创建。但是，不要在该层放置任何其他对象，因为在游戏过程中该层本身将是不可见的。
- en: 'Finally, add an instance of the `Player` scene. Make sure the `Player` node
    is below the three `TileMap` nodes, so it will be drawn on top. The final scene
    tree should look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个`Player`场景的实例。确保`Player`节点位于三个`TileMap`节点之下，这样它就会在上面绘制。最终的场景树应该看起来像这样：
- en: '![](img/e33b94ec-0d0d-4b3a-8ab1-2fb6f83c0cb6.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e33b94ec-0d0d-4b3a-8ab1-2fb6f83c0cb6.png)'
- en: Level script
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级别脚本
- en: 'Now that the level is complete, attach a script to create the level behavior.
    This script will first scan the `Items` map to spawn any enemies and collectibles.
    It will also serve to monitor for events that occur during gameplay, such as picking
    up a key or running into an enemy:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关卡完成，附加一个脚本以创建关卡行为。此脚本将首先扫描`Items`映射以生成任何敌人和可收集物品。它还将用于监控游戏过程中发生的事件，例如捡起钥匙或遇到敌人：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first two variables contain references to the scenes that will need to be
    instanced from the `Items` map. Since that particular map node will be referenced
    frequently, you can cache the `$Items` lookup in a variable to save some time.
    Finally, an array called `doors` will contain the door location(s) found on the
    map.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个变量包含从`Items`映射中需要实例化的场景的引用。由于该特定映射节点将被频繁引用，您可以将`$Items`查找缓存到变量中以节省一些时间。最后，一个名为`doors`的数组将包含地图上找到的门的位置。
- en: Save the script and drag the `Enemy.tscn` and `Pickup.tscn` files into their
    respective properties in the Inspector.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并将`Enemy.tscn`和`Pickup.tscn`文件拖入检查器中相应的属性。
- en: 'Now, add the following code for `_ready()`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加以下代码用于`_ready()`：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The function starts by ensuring that the `Items` tilemap is hidden. You don't
    want the player to see those tiles; they exist so the script can detect where
    to spawn items.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先确保`Items`瓦片地图是隐藏的。您不希望玩家看到这些瓦片；它们存在是为了让脚本检测生成物品的位置。
- en: Next, the camera limits must be set, ensuring that it can't scroll past the
    edges of the map. You'll create a function to handle that (see the following code).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，必须设置相机限制，确保它不能滚动到地图的边缘。您将创建一个函数来处理这个问题（见以下代码）。
- en: When the player finds a key, the door(s) need to be opened, so the next part
    searches the `Walls` map for any `door_red` tiles and stores them in an array.
    Note that you must first find the tile's `id` from the `TileSet`, because the
    cells of the `TileMap` only contain ID numbers that refer to the tile set.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家找到钥匙时，门需要打开，所以下一部分搜索`Walls`地图中的任何`door_red`瓷砖并将它们存储在数组中。请注意，您必须首先从`TileSet`中找到瓷砖的`id`，因为`TileMap`的单元格只包含指向瓷砖集的ID数字。
- en: More on the `spawn_items()` function follows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`spawn_items()`函数的更多内容。
- en: Finally, the `Player` signals are all connected to functions that will process
    their results.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Player`信号都连接到将处理其结果的函数。
- en: 'Here''s how to set the camera limits to match the size of the map:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何设置相机限制以匹配地图大小：
- en: '[PRE11]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`get_used_rect()` returns a `Vector2` containing the size of the `Ground` layer
    in cells. Multiplying this by the `cell_size` gives the total map size in pixels,
    which is used to set the four limit values on the `Camera` node. Setting these
    limits ensures you won''t see any *dead* space outside the map when you move near
    the edge.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_used_rect()`返回一个包含`Ground`层大小的`Vector2`。将其乘以`cell_size`给出整个地图的像素大小，这用于在`Camera`节点上设置四个限制值。设置这些限制确保您在靠近边缘时不会看到地图外的任何*死*空间。'
- en: 'Now, add the `spawn_items()` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加`spawn_items()`函数：
- en: '[PRE12]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function looks for the tiles in the `Items` layer, returned by `get_used_cells()`.
    Each cell has an `id` that maps to a name in the `TileSet` (the names that were
    assigned to each tile when the `TileSet` was made). If you made your own tile
    set, make sure you use the names that match your tiles in this function. The names
    used in the preceding code match the tile set that was included in the asset download.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在`Items`层中查找瓷砖，由`get_used_cells()`返回。每个单元格都有一个`id`，它映射到`TileSet`中的名称（在创建`TileSet`时分配给每个瓷砖的名称）。如果您创建了您自己的瓷砖集，请确保您在此函数中使用与您的瓷砖匹配的名称。前面代码中使用的名称与包含在资产下载中的瓷砖集相匹配。
- en: '`map_to_world()` converts the tile map position to pixel coordinates. This
    gives you the upper-left corner of the tile, so then you must add one half-size
    tile to find the center of the tile. Then, depending on what tile was found, the
    matching item object is instanced.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`map_to_world()`将瓷砖地图位置转换为像素坐标。这给出了瓷砖的左上角，因此您必须添加一个半大小的瓷砖以找到瓷砖的中心。然后，根据找到的瓷砖，实例化匹配的项目对象。'
- en: 'Finally, add the three functions for the player signals:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加玩家信号的三个函数：
- en: '[PRE13]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The player signals `dead` and `win` should end the game and go to a Game Over
    screen (which you haven't created yet). Since you can't write the code for those
    functions yet, use `pass` for the time being. The key pickup signal should remove
    any door tiles (by setting their tile index to `-1`, which means an empty tile).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家发出`dead`和`win`信号后，游戏应结束并跳转到游戏结束屏幕（您尚未创建）。由于您目前还不能为这些函数编写代码，暂时使用`pass`。拾取关键物品的信号应移除任何门瓷砖（通过将它们的瓷砖索引设置为`-1`，这意味着一个空瓷砖）。
- en: Adding more levels
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多级别
- en: If you want to make another level, you just need to duplicate this scene tree
    and attach the same script to it. The easiest way to do this is to use Scene |
    Save As and save the level as `Level2.tscn`. Then, you can use some of the existing
    tiles or draw a whole new level layout.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建另一个级别，只需复制这个场景树并将其相同的脚本附加到它上。这样做最简单的方法是使用`Scene | Save As`将级别保存为`Level2.tscn`。然后，您可以使用一些现有的瓷砖或绘制整个新的级别布局。
- en: Feel free to do this with as many levels as you like, making sure to save them
    all in the `levels` folder. In the next section, you'll see how to link them together
    so that each level will lead to the next. Don't worry if you number them incorrectly;
    you'll be able to put them in whatever order you like.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 随意地创建任意多级，确保将它们全部保存在`levels`文件夹中。在下一节中，您将看到如何将它们链接起来，以便每个级别都将引导到下一个级别。如果编号错误，不用担心；您可以将它们按任何顺序排列。
- en: Game flow
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏流程
- en: 'Now that you have the basic building blocks completed, you need to tie everything
    together. In this section, you''ll create:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成了基本构建块，您需要将所有这些内容结合起来。在本节中，您将创建：
- en: The Start and Game Over screens
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和游戏结束屏幕
- en: A global script to manage persistent data
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于管理持久数据的全局脚本
- en: 'The basic flow of the game follows the following chart:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的基本流程遵循以下图表：
- en: '![](img/d4459717-b5aa-4fb8-b372-a0162b345aa2.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4459717-b5aa-4fb8-b372-a0162b345aa2.png)'
- en: The player is sent to the end screen whenever he/she dies, or when they reach
    and complete the last level. After a brief time, the end screen returns the player
    to the start screen so that a new game can be played.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家在死亡或完成最后一个关卡后会被发送到结束屏幕。经过一段短暂的时间，结束屏幕会将玩家返回到起始屏幕，以便开始新的一局游戏。
- en: Start and end screens
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始和结束屏幕
- en: 'You need two scenes for this part: a start or title screen that shows before
    the game (and lets the player start the game), and a game over screen to notify
    the player that the game has ended.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为这部分创建两个场景：一个在游戏开始前显示的起始或标题屏幕，允许玩家开始游戏，以及一个游戏结束屏幕，通知玩家游戏已经结束。
- en: Make a new scene and add a `Control` node named `StartScreen`. Add a Label as
    a child and add `res://assets/Unique.ttf` as a new `DynamicFont` with a font size
    of `64`. Set the Align and Valign properties to Center and the Text to `Escape
    the Maze!`. In the Layout menu, select Full Rect. Now, duplicate this node and
    set the second label's Text to Press <space>.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并添加一个名为`StartScreen`的`Control`节点。添加一个子节点标签，并添加`res://assets/Unique.ttf`作为新的`DynamicFont`，字体大小为`64`。设置对齐和垂直对齐属性为居中，文本为`Escape
    the Maze!`。在布局菜单中，选择全矩形。现在，复制此节点并将第二个标签的文本设置为按<空格>键。
- en: For this demonstration, the `StartScreen` is being kept very plain. Once you
    have it working, feel free to add decorations, or even an `AnimationPlayer` to
    make a player Sprite run across the screen.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，`StartScreen`被保持得很简单。一旦它开始工作，你可以自由地添加装饰，甚至添加一个`AnimationPlayer`来让玩家精灵在屏幕上跑动。
- en: Choose Scene | Save As to save another copy of this scene and name it `EndScreen`.
    Delete the second `Label` (the one that says Press <space>) and add a `Timer`
    node. Set the Autostart property to On, One Shot to On, and Wait Time to `3`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“场景 | 另存为”来保存此场景的另一个副本，并将其命名为`EndScreen`。删除第二个`Label`（显示按<空格>键的那个），并添加一个`Timer`节点。设置自动启动属性为开启，单次触发为开启，等待时间为`3`。
- en: The `Timer` will send the game back to the `StartScreen` after it expires.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer`将在时间到后把游戏送回`StartScreen`。'
- en: However, before you can connect these other scenes together, you need to understand
    how to work with persistent data and *Autoloads*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在你可以连接这些其他场景之前，你需要了解如何处理持久数据和**自动加载（Autoloads**）。
- en: Globals
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量
- en: It is a very common scenario in game development that you have some data that
    needs to persist across multiple scenes. Data that is part of a scene is lost
    when the scene is switched, so persistent data must reside somewhere outside the
    current scene.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，有一个非常常见的场景，你需要一些需要在多个场景之间持久化的数据。当场景切换时，场景中的数据会丢失，因此持久化数据必须位于当前场景之外。
- en: Godot solves this problem with the use of AutoLoads. These are scripts or nodes
    that are automatically loaded in every scene. Because Godot does not support global
    variables, an autoload acts like a *Singleton.* This is a node (with attached
    script) that is automatically loaded in *every* scene. Common uses for AutoLoads
    include storing global data (score, player data, and so on), handling scene switching
    functions, or any other functions that need to be independent of the currently
    running scene.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Godot通过使用自动加载（AutoLoads）来解决此问题。这些是每个场景都会自动加载的脚本或节点。因为Godot不支持全局变量，所以自动加载就像一个**单例**。这是一个（附带脚本的）节点，它会在**每个**场景中自动加载。自动加载的常见用途包括存储全局数据（分数、玩家数据等）、处理场景切换函数，或任何需要独立于当前运行场景的函数。
- en: '**Singleton** is a well-known pattern in programming which describes a class
    that only allows for a single instance of itself, and provides direct access to
    its member variables and functions. In game development, it is often used for
    persistent data that needs to be accessible by various parts of the game.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**单例（Singleton**）是编程中一个著名的模式，它描述了一个只能有一个实例的类，并提供对其成员变量和函数的直接访问。在游戏开发中，它通常用于需要被游戏各个部分访问的持久数据。'
- en: When deciding if you need a singleton, ask yourself whether the object or data
    needs to *always* exist and if there will always be *only one* instance of that
    object.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定是否需要单例时，问问自己这个对象或数据是否需要**始终**存在，并且是否将始终只有一个该对象的实例。
- en: Global script
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局脚本
- en: 'First, make a new script by clicking File | New in the Script window. Make
    sure it inherits from `Node` (this is the default), and in the `Path` field, set
    the name to `Global.gd`. Click Create and add the following code to the new script:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在脚本窗口中点击“文件 | 新建”来创建一个新的脚本。确保它从`Node`继承（这是默认的），并在`路径`字段中设置名称为`Global.gd`。点击创建，并将以下代码添加到新脚本中：
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This script provides a number of functions you'll need.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本提供了你需要的一些函数。
- en: Most of the work is done by the `change_scene()` method of the `SceneTree`.
    The `SceneTree` represents the foundation of the currently running scene. When
    a scene is loaded or a new node is added, it becomes a member of the `SceneTree`.
    `change_scene()` replaces the current scene with a given one.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作都是由`SceneTree`的`change_scene()`方法完成的。`SceneTree`代表当前运行场景的基础。当加载场景或添加新节点时，它成为`SceneTree`的一个成员。`change_scene()`用给定场景替换当前场景。
- en: The `next_level()` function progresses through the list of levels you've made,
    which are listed in the `levels` array. If you reach the end of the list, the
    game ends.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_level()`函数会遍历你创建的水平列表，这些列表在`levels`数组中列出。如果你到达列表的末尾，游戏结束。'
- en: 'To add this script as an autoload, open Project Settings and click on the AutoLoad
    tab. Click the .. button next to Path and select your `Global.gd` script. The node
    Name will automatically be set to Global (this is the name you''ll use to reference
    the node in your scripts, as shown in the following screenshot):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此脚本作为自动加载，打开项目设置并点击自动加载选项卡。点击路径旁边的..按钮，选择你的`Global.gd`脚本。节点名称将自动设置为Global（这是你在脚本中引用节点时使用的名称，如以下截图所示）：
- en: '![](img/7d0b0839-4dd0-4f1c-9c6c-113677a7192c.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d0b0839-4dd0-4f1c-9c6c-113677a7192c.png)'
- en: Now, you can access any of the global script's properties by using its name
    in any script across your whole game, for example, `Global.current_level`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过在任何脚本中使用其名称来访问全局脚本的所有属性，例如，`Global.current_level`。
- en: 'Attach the following script to the `StartScreen`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下脚本附加到`StartScreen`：
- en: '[PRE16]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This script waits for the spacebar to be pressed and then calls the `new_game()`
    function of `Global`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本等待空格键被按下，然后调用`Global`的`new_game()`函数。
- en: 'Add this one to `EndScreen`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加到`EndScreen`：
- en: '[PRE17]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You'll also need to connect the `timeout` signal of `Timer`. To do this, you
    have to create the script first, then the `Connect` button will create the new
    function for you.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要连接`Timer`的`timeout`信号。为此，你必须首先创建脚本，然后`Connect`按钮将为你创建新函数。
- en: 'In the `Level.gd` script, you can now fill in the remaining two functions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Level.gd`脚本中，你现在可以填写剩下的两个函数：
- en: '[PRE18]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Score
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分数
- en: The global singleton is a great place to keep the player's score so that it
    will be persistent from level to level. Start by adding a `var score` variable
    at the top of the file, and then in `new_game()`, add `score = 0`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 全局单例是一个很好的地方来保存玩家的分数，以便它在关卡之间保持持久。首先在文件顶部添加一个`var score`变量，然后在`new_game()`中添加`score
    = 0`。
- en: 'Now, you need to add a point whenever a coin is collected. Go to `Pickup.gd`
    and add `signal coin_pickup` at the top. You can emit this signal in the `pickup()`
    function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当收集到硬币时，你需要添加一个点。转到`Pickup.gd`并在顶部添加`signal coin_pickup`。你可以在`pickup()`函数中发出此信号：
- en: '[PRE19]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The value of `1` is included here in case you want to later change the number
    of points that coins are worth, or add other objects that add different point
    amounts. This signal will be used to update the display, so now you can create
    the `HUD`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里包含`1`的值是为了以防你以后想更改硬币的分数值，或者添加其他增加不同分数的对象。这个信号将用于更新显示，因此现在你可以创建`HUD`。
- en: Make a new scene with a `CanvasLayer` named `HUD` and save the scene. Add a
    `MarginContainer` node as a child, and under that, a `Label` named `ScoreLabel`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`HUD`的`CanvasLayer`的新场景并保存场景。添加一个`MarginContainer`节点作为子节点，并在其下添加一个名为`ScoreLabel`的`Label`。
- en: 'Set the `MarginContainer` Layout to Top Wide and its four margin properties
    (found under Custom Constants) all to `20`. Add the same Custom Font properties
    you used before for the start and end screens, then attach a script:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MarginContainer`布局设置为Top Wide，并将其四个边距属性（在自定义常量下找到）都设置为`20`。添加与开始和结束屏幕相同的自定义字体属性，然后附加一个脚本：
- en: '[PRE20]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Add an instance of the `HUD` to the `Level` scene. Remember from the previous
    project that the `CanvasLayer` node will remain on top of the rest of the game.
    It will also ignore any camera movement, so the display will remain fixed in place
    as the player moves around the level.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将`HUD`的一个实例添加到`Level`场景中。记住，从上一个项目中，`CanvasLayer`节点将保持在游戏的其他部分之上。它还将忽略任何相机移动，因此显示将保持固定位置，当玩家在关卡中移动时。
- en: 'Finally, in the `Level.gd` script, when you spawn a new collectible object,
    connect the signal to the `HUD` function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Level.gd`脚本中，当你生成新的可收集对象时，将信号连接到`HUD`函数：
- en: '[PRE21]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the game and collect a few coins to confirm that the score is updating.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并收集一些硬币以确认分数正在更新。
- en: Saving the High Score
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存高分
- en: Many games require you to save some kind of information between play sessions.
    This is information that you want to remain available, even when the application
    itself has quit. Examples include saved games, user-created content, or downloadable
    resource packs. For this game, you'll save a High Score value that will persist
    across game sessions.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏要求你在游戏会话之间保存某种信息。这是你希望保持可用的信息，即使应用程序本身已经退出。例如包括保存的游戏、用户创建的内容或可下载的资源包。对于这个游戏，你将保存一个将在游戏会话之间持久存在的高分值。
- en: Reading and writing files
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: As you've seen before, Godot keeps all resources stored as files in the project
    folder. From code, these are accessible under the `res://` folder path. For example, `res://project.godot`
    will always point to the current project's configuration file, no matter where
    on your computer the project is actually stored.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Godot将所有资源存储为项目文件夹中的文件。从代码中，这些资源可以在`res://`文件夹路径下访问。例如，`res://project.godot`将始终指向当前项目的配置文件，无论项目实际上存储在电脑上的哪个位置。
- en: However, the `res://` filesystem is set as read-only for safety when the project
    is run. It is also read-only when the project is exported. Any data that needs
    to be retained by the user is placed in the `user://` file path. Where this folder
    physically exists will vary depending on what platform the game is running on.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当项目运行时，`res://`文件系统被设置为只读，以安全起见。当项目导出时也是如此。任何需要用户保留的数据都放置在`user://`文件路径中。这个文件夹的物理位置将根据游戏运行的平台而有所不同。
- en: You can find the current platform's user-writable data folder using `OS.get_user_data_dir()`.
    Add a `print()` statement to the `ready()` function of one of your scripts to
    see what the location is on your system.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`OS.get_user_data_dir()`找到当前平台的用户可写数据文件夹。将一个`print()`语句添加到你的脚本中的一个`ready()`函数中，以查看你的系统上的位置。
- en: Reading and writing to files is accomplished using a `File` object. This object
    is used to open the file in read and/or write mode, and can also be used to test
    for a file's existence.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`File`对象读取和写入文件。此对象用于以读取和/或写入模式打开文件，也可以用于测试文件的存在。
- en: 'Add the following code to `Global.gd`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Global.gd`：
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You first need to test whether the file exists. If it does, you can read the
    value, which is being stored as human-readable text, and assign it to the `highscore`
    variable. Binary data can also be stored in files, if needed, but text will allow
    you to look at the file yourself and check that everything is working.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要测试文件是否存在。如果存在，你可以读取值，该值以可读文本的形式存储，并将其分配给`highscore`变量。如果需要，文件中也可以存储二进制数据，但文本将允许你自己查看文件并检查一切是否正常工作。
- en: 'Add the following code to check if the player has beat the previous high score:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加以检查玩家是否打破了之前的高分：
- en: '[PRE23]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `save_score()` function opens the file to write the new value. Note that
    if the file doesn't exist, opening in `WRITE` mode will automatically create it.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_score()`函数打开文件以写入新值。请注意，如果文件不存在，以`WRITE`模式打开将自动创建它。'
- en: 'Next, you need to call the `setup()` function when the game starts, so add
    this to `Global.gd`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当游戏开始时，你需要调用`setup()`函数，所以将其添加到`Global.gd`中：
- en: '[PRE24]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, to display the high score, add another `Label` node to the `StartScreen`
    scene (you can duplicate one of the existing ones). Arrange it below the other
    Labels (or in whatever order you like) and name it `ScoreNotice`. Add the following
    to the script:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了显示高分，将另一个`Label`节点添加到`StartScreen`场景中（你可以复制一个现有的）。将其安排在其他的标签下面（或按你喜欢的任何顺序）并命名为`ScoreNotice`。将以下内容添加到脚本中：
- en: '[PRE25]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the game and check that your high score is increasing (when you beat it)
    and persisting when you quit and start the game again.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并检查你的高分是否在击败它时增加，并在退出并再次开始游戏时保持持久。
- en: Finishing touches
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的修饰
- en: Now that the main functionality of the game is complete, you can add a few more
    features to polish it up a little bit.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏的主要功能已经完成，你可以添加一些额外的功能来稍微润色一下。
- en: Death animation
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死亡动画
- en: When the enemy hits the player, you can add a small animation rather than just
    ending the game. The effect will spin the character around while shrinking its
    scale property.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人击中玩家时，你可以添加一个小动画，而不是直接结束游戏。效果将使角色围绕旋转并缩小其缩放属性。
- en: Start by selecting the `AnimationPlayer` node of the `Player` and clicking the
    New Animation button: ![](img/43736d1e-91f9-4bab-9b99-30f52c2b3ae9.png). Name
    the new animation `die`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择`Player`的`AnimationPlayer`节点并点击新建动画按钮：![](img/43736d1e-91f9-4bab-9b99-30f52c2b3ae9.png)。将新动画命名为`die`。
- en: In this animation, you'll be animating the Sprite's Rotation Degrees and Scale properties.
    Find the Rotation Degrees property in the Inspector and click the key, ![](img/7c017716-79c1-4a44-ad13-8312736b4175.png), to
    add a track. Move the scrubber to the end of the animation, change Rotation Degrees
    to 360, and click the key again. Try playing the animation to see the character
    spin.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动画中，你需要对Sprite的旋转角度和缩放属性进行动画处理。在检查器中找到旋转角度属性，点击![](img/7c017716-79c1-4a44-ad13-8312736b4175.png)键来添加一个轨道。将刮擦器移动到动画的末尾，将旋转角度更改为360，然后再次点击键。尝试播放动画以查看角色旋转。
- en: Keep in mind that while degrees are typically used for Inspector properties,
    when writing code most Godot functions expect angles to be measured in *radians*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，虽然度数通常用于检查器属性，但在编写代码时，大多数Godot函数期望角度以*弧度*为单位进行测量。
- en: Now, do the same thing with the *Scale* property. Add a keyframe (at the beginning!)
    for `(1, 1)` and then another at the end with the scale set to `(0.2, 0.2)`. Try
    playing the animation again to see the results.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对*Scale*属性做同样的事情。在开始时添加一个关键帧（为`(1, 1)`），然后在动画结束时添加另一个关键帧，将缩放设置为`(0.2, 0.2)`。再次尝试播放动画以查看结果。
- en: 'The new animation needs to be triggered when the player hits an enemy. Add
    the following code to the player''s `_on_Player_area_entered()` function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 新动画需要在玩家击中敌人时触发。将以下代码添加到玩家的`_on_Player_area_entered()`函数中：
- en: '[PRE26]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The added code takes care of a few things that need to happen. First, hiding
    the enemy that was hit makes sure that it doesn't cover the player and prevent
    you from seeing our new animation. Next, you use `set_process(false)` to stop
    the `_process()` function from running so that the player can't keep moving during
    the animation. You also need to disable the player's collision detection so that
    it doesn't detect another enemy if it happens to wander by.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的代码处理了一些需要发生的事情。首先，隐藏被击中的敌人确保它不会遮挡玩家并阻止你看到我们的新动画。接下来，使用`set_process(false)`停止`_process()`函数的运行，这样玩家在动画期间就不能继续移动。你还需要禁用玩家的碰撞检测，以免它检测到另一个敌人如果它恰好经过的话。
- en: After starting the `die` animation, you need to let it finish before emitting
    the `dead` signal, so `yield` is used to wait for the signal from `AnimationPlayer`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始`die`动画后，你需要等待动画完成再发出`dead`信号，因此使用`yield`来等待`AnimationPlayer`的信号。
- en: 'Try running the game and getting hit by an enemy to see the animation. If everything
    works fine, you''ll notice something wrong on the next playthrough: the player
    is tiny! The animation ends with the Sprite''s Scale set to `(0.2, 0.2)` and nothing
    is setting it back to normal size. Add the following to the Player''s script so
    that the scale will always start at the right value:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行游戏并让敌人击中玩家以查看动画。如果一切正常，你会在下一次游戏过程中注意到一些错误：玩家变得很小！动画结束时，Sprite的缩放设置为`(0.2,
    0.2)`，没有任何东西将其设置回正常大小。将以下代码添加到玩家的脚本中，以便缩放始终从正确的值开始：
- en: '[PRE27]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Sound effects
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音效
- en: 'There are six sound effects in the `res://assets/audio` folder for you to use
    in the game. These audio files are in OGG format. By default, Godot sets OGG files
    to loop when imported. Select the OGG files in the FileSystem tab (you can use
    *Shift* + Click to select multiple files) and click the Import tab on the right-hand
    side of the editor window. Uncheck Loop and click the Reimport button:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在`res://assets/audio`文件夹中有六个音效供你在游戏中使用。这些音频文件是OGG格式。默认情况下，Godot在导入时会将OGG文件设置为循环。在FileSystem标签页中选择OGG文件（你可以使用*Shift*
    + 点击来选择多个文件），然后在编辑器窗口右侧的Import标签页上点击。取消选择Loop并点击Reimport按钮：
- en: '![](img/cd3adef3-f21b-4fec-b70a-b88ca4926069.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd3adef3-f21b-4fec-b70a-b88ca4926069.png)'
- en: First, add the pickup sounds for the items. Add two `AudioStreamPlayer` nodes
    to the `Pickup` scene and name them `KeyPickup` and `CoinPickup`. Drag the corresponding
    audio file into the Stream property of each node.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为物品添加拾取音效。在`Pickup`场景中添加两个`AudioStreamPlayer`节点，并分别命名为`KeyPickup`和`CoinPickup`。将相应的音频文件拖动到每个节点的Stream属性中。
- en: 'You can also adjust the sound''s volume via its Volume Db property, as shown
    in the following screenshot:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过其Volume Db属性调整音量，如下面的截图所示：
- en: '![](img/a84abf45-bf1d-4dcd-9ebc-fbc9d34376c2.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a84abf45-bf1d-4dcd-9ebc-fbc9d34376c2.png)'
- en: 'Add the following code to the beginning of the `pickup()` function:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`pickup()`函数的开始部分：
- en: '[PRE28]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The other sound effects will be added to the `Player` scene. Add three of the `AudioStreamPlayer` and
    name them `Win`, `Lose`, and `Footsteps`, adding the matching sound file to each
    node''s Stream. Update the `_on_Player_area_entered()` function as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 其他音效将添加到 `Player` 场景中。添加三个 `AudioStreamPlayer` 并命名为 `Win`、`Lose` 和 `Footsteps`，将匹配的声音文件添加到每个节点的
    `Stream` 中。按照以下方式更新 `_on_Player_area_entered()` 函数：
- en: '[PRE29]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You need to disable the collision and `yield` for the sound to finish, or else
    it would be instantly terminated by the next level loading. This way, the player
    has time to hear the sound before moving on.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要禁用碰撞和 `yield` 以完成声音，否则它会被下一级加载立即终止。这样，玩家有足够的时间在移动之前听到声音。
- en: 'To play the footsteps, add `$Footsteps.play()` after `if move(dir):` in the
    `_process()` function. Note: you may want to reduce the sound of the footsteps
    so that they don''t overwhelm everything; they should be subtle background sounds.
    In the `Footsteps` node, set the Volume Db property to `-30`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放脚步声，在 `_process()` 函数中的 `if move(dir):` 之后添加 `$Footsteps.play()`。注意：你可能想要降低脚步声的音量，以免压倒一切；它们应该是微妙的背景声音。在
    `Footsteps` 节点中，将 `Volume Db` 属性设置为 `-30`。
- en: 'Finally, to play the `Lose` sound, add it to the enemy collision code here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了播放 `Lose` 声音，将其添加到敌人碰撞代码中：
- en: '[PRE30]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that you need to change the yield function. Since the sound is slightly
    longer than the animation, it will get cut off if you end it on the animation's
    completion. Alternatively, you could adjust the duration of the animation to match
    the length of the sound.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要更改 `yield` 函数。由于声音略长于动画，如果在动画完成时结束，它将被截断。或者，你可以调整动画的持续时间以匹配声音的长度。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this project, you have learned how to take advantage of Godot''s inheritance
    system to organize and share code between different objects in your game. This
    is a very powerful tool that you should keep in mind whenever you start building
    a new game. If you start making multiple objects that repeat the same properties
    and/or code, you should probably stop and think about what you''re doing. Ask
    yourself: *can I use inheritance here to share what these objects have in common?*
    In a bigger game with many more objects, this can save you a large amount of time.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你学习了如何利用 Godot 的继承系统来组织和共享游戏中不同对象之间的代码。这是一个非常强大的工具，每次开始构建新游戏时都应该牢记在心。如果你开始创建多个具有相同属性和/或代码的对象，你可能应该停下来思考一下你在做什么。问问自己：*我是否可以使用继承来共享这些对象共有的内容？*
    在一个包含更多对象的大游戏中，这可以为你节省大量时间。
- en: You saw how the `TileMap` node works and how it allows you to quickly design
    maps and spawn new objects. They have many uses across many game genres. As you'll
    see later in this book, TileMaps are also ideal for designing platform game levels
    as well.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了 `TileMap` 节点的工作原理以及它如何允许你快速设计地图和生成新对象。它们在许多游戏类型中都有很多用途。正如你将在本书后面的内容中看到的，TileMaps
    也非常适合设计平台游戏关卡。
- en: You were also introduced to the *AutoLoad* feature, which allows you to create
    a global script that contains persistent data used across multiple scenes. You
    also learned how to implement grid-based movement and used the `AnimationPlayer`
    to work with spritesheet animations.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你还介绍了 *AutoLoad* 功能，它允许你创建一个包含跨多个场景使用的持久数据的全局脚本。你还学习了如何实现基于网格的移动，并使用 `AnimationPlayer`
    来处理精灵图动画。
- en: 'In the next chapter, you''ll learn about Godot''s powerful physics body: the
    `RigidBody2D`. You''ll use it to create a game in a classic genre: the space shooter.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于 Godot 强大的物理体：`RigidBody2D`。你将使用它来创建一个经典类型的游戏：太空射击游戏。
