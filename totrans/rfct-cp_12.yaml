- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Software testing stands as a cornerstone in the edifice of software development,
    holding paramount importance in the assurance of software quality, reliability,
    and maintainability. It is through the meticulous process of testing that developers
    can ensure their creations meet the highest standards of functionality and user
    satisfaction. The inception of any software project is invariably intertwined
    with the potential for bugs and unforeseen issues; it is testing that illuminates
    these hidden pitfalls, allowing developers to address them proactively, thereby
    enhancing the overall integrity and performance of the software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试在软件开发的大厦中占据基石地位，在确保软件质量、可靠性和可维护性方面具有至关重要的意义。正是通过细致的测试过程，开发者可以确保他们的作品达到功能性和用户满意度最高的标准。任何软件项目的起点总是与潜在的错误和未预见到的问题交织在一起；正是测试揭示了这些隐藏的陷阱，使开发者能够积极应对，从而增强软件的整体完整性和性能。
- en: At the heart of software testing lies a diverse array of methodologies, each
    tailored to examine distinct facets of the software. Among these, unit testing
    serves as the foundational layer, focusing on the smallest testable parts of the
    software to ensure their correct behavior. This granular approach facilitates
    the early detection of errors, streamlining the development process by enabling
    immediate corrections. Ascending from the micro to the macro perspective, integration
    testing takes precedence, wherein the interaction between integrated units is
    scrutinized. This method is pivotal in identifying issues in the interfacing of
    components, ensuring seamless communication and functionality within the software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试的核心在于一系列多样化的方法论，每种方法都针对软件的不同方面进行定制。在这些方法中，单元测试作为基础层，专注于软件中最小的可测试部分，以确保其正确的行为。这种细粒度方法有助于早期发现错误，通过允许立即纠正来简化开发过程。从微观视角上升到宏观视角，集成测试占据主导地位，其中对集成单元之间的交互进行审查。这种方法在识别组件接口问题中至关重要，确保软件内部通信和功能的顺畅。
- en: Progressing further, system testing emerges as a comprehensive examination of
    the complete and integrated software system. This methodology delves into the
    software’s adherence to specified requirements, offering an overarching assessment
    of its behavior and performance. It is a crucial phase that validates the software’s
    readiness for deployment, ensuring that it functions correctly in its intended
    environment. Lastly, acceptance testing marks the culmination of the testing process,
    where the software is evaluated to determine whether it fulfills the criteria
    for delivery to end users. This final stage is instrumental in affirming the software’s
    alignment with user needs and expectations, serving as the ultimate testament
    to its quality and effectiveness.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步推进，系统测试成为对完整和集成软件系统的全面审查。这种方法深入到软件对指定要求的遵守情况，对其行为和性能进行总体评估。这是一个关键阶段，验证软件的部署准备情况，确保它在预期环境中正确运行。最后，验收测试标志着测试过程的完成，其中软件被评估以确定其是否满足交付给最终用户的标准。这一最终阶段对于确保软件与用户需求和期望的一致性至关重要，是软件质量和有效性的最终证明。
- en: Embarking on this chapter, you will be guided through the intricate landscape
    of software testing, gaining insights into the pivotal role it plays in the development
    life cycle. The exploration will encompass the nuanced distinctions between testing
    methodologies, shedding light on their unique objectives and the scope of their
    application. Through this journey, you will acquire a comprehensive understanding
    of how testing underpins the creation of robust, reliable, and user-centric software,
    setting the stage for the subsequent chapters that delve deeper into the specifics
    of unit testing and beyond in the realm of C++.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 开始这一章节，您将引导进入软件测试错综复杂的领域，深入了解它在开发生命周期中扮演的关键角色。探索将涵盖测试方法之间的细微差别，阐明它们的独特目标和应用范围。通过这次旅程，您将获得对如何通过测试支撑创建强大、可靠和以用户为中心的软件的全面理解，为后续章节深入探讨单元测试以及C++领域的其他具体内容奠定基础。
- en: Test-driven development
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '**Test-driven development**, commonly abbreviated as **TDD**, is a modern software
    development approach that has revolutionized the way code is written and tested.
    At its core, TDD inverts traditional development methodologies by advocating for
    the creation of tests before the development of the actual functional code. This
    paradigm shift is encapsulated in a cyclic process known as “Red-Green-Refactor.”
    Initially, a developer writes a test that defines a desired improvement or a new
    function, which inevitably fails on the first run – this is the “Red” phase, indicating
    the absence of the corresponding functionality. Subsequently, in the “Green” phase,
    the developer crafts the minimum amount of code necessary to pass the test, thereby
    ensuring that the functionality meets the specified requirements. The cycle culminates
    in the “Refactor” phase, where the new code is refined and optimized without altering
    its behavior, thus maintaining the test’s successful outcome.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**，通常缩写为**TDD**，是一种现代软件开发方法，它彻底改变了代码的编写和测试方式。在其核心，TDD通过提倡在开发实际功能代码之前创建测试来颠覆传统的开发方法。这种范式转变体现在被称为“红-绿-重构”的循环过程中。最初，开发者编写一个测试来定义期望的改进或新功能，这个测试在第一次运行时必然会失败——这是“红”阶段，表示缺少相应的功能。随后，在“绿”阶段，开发者编写必要的最少代码以通过测试，从而确保功能满足指定的要求。这个周期以“重构”阶段结束，在这个阶段，新代码被精炼和优化，而不改变其行为，从而保持测试的成功结果。'
- en: The adoption of TDD brings with it a plethora of advantages that contribute
    to a more robust and reliable code base. One of the most significant benefits
    is the marked improvement in code quality. Since TDD necessitates the definition
    of tests upfront, it inherently encourages a more thoughtful and deliberate design
    process, reducing the likelihood of bugs and errors. Moreover, tests crafted in
    the TDD process serve a dual purpose as detailed documentation of the code base.
    These tests provide clear insights into the code’s intended functionality and
    usage, offering valuable guidance for current and future developers. Additionally,
    TDD facilitates the design and refactoring of code by ensuring that changes do
    not inadvertently break existing functionalities, thereby fostering a code base
    that is both flexible and maintainable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 采用TDD（测试驱动开发）带来了众多优势，这些优势有助于构建更健壮和可靠的代码库。其中最显著的益处是代码质量的显著提升。由于TDD要求事先定义测试，因此它本质上鼓励更深思熟虑和审慎的设计过程，减少了错误和缺陷的可能性。此外，在TDD过程中编写的测试同时起到详细文档的作用。这些测试提供了对代码预期功能和用法的清晰洞察，为当前和未来的开发者提供了宝贵的指导。此外，TDD通过确保更改不会意外地破坏现有功能，从而促进了既灵活又易于维护的代码库的设计和重构。
- en: Despite its numerous benefits, TDD is not without its challenges and potential
    drawbacks. One of the initial hurdles encountered when adopting TDD is the perceived
    slowdown in the development process. Writing tests before functionality can feel
    counterintuitive and may extend the time to deliver features, particularly in
    the early stages of adoption. Furthermore, TDD demands a steep learning curve,
    requiring developers to acquire new skills and adapt to a different mindset, which
    can be a significant investment in time and resources. It’s also worth noting
    that TDD may not be universally applicable or ideal for all scenarios. Certain
    types of projects, such as those involving complex user interfaces or requiring
    extensive interaction with external systems, may pose challenges to the TDD methodology,
    necessitating a more nuanced or hybrid approach to testing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TDD具有许多益处，但它并非没有挑战和潜在的缺点。采用TDD时最初遇到的初步障碍之一是感觉开发过程会减慢。在功能开发之前编写测试可能感觉不合逻辑，可能会延长交付功能的时间，尤其是在采用初期。此外，TDD需要陡峭的学习曲线，要求开发者掌握新技能并适应不同的思维方式，这可能会在时间和资源上投入巨大。还值得注意的是，TDD可能并不适用于所有场景，也不是所有情况下都是理想的。某些类型的项目，如涉及复杂用户界面或需要与外部系统进行广泛交互的项目，可能会对TDD方法构成挑战，需要更细致或混合的测试方法。
- en: In conclusion, while TDD presents a transformative approach to software development
    with its emphasis on test-first methodology, it is essential to weigh its benefits
    against the potential challenges. The effectiveness of TDD is contingent upon
    the context of its application, the proficiency of the development team, and the
    nature of the project at hand. As we delve deeper into the subsequent sections,
    the nuances of unit testing, integration with testing frameworks, and practical
    considerations will further illuminate the role of TDD in shaping high-quality,
    maintainable C++ code bases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，虽然TDD（测试驱动开发）通过强调测试优先的方法为软件开发提供了一种变革性的方法，但在权衡其潜在挑战的同时，其益处也是至关重要的。TDD的有效性取决于其应用的上下文、开发团队的熟练程度以及手头项目的性质。随着我们深入到后续章节，单元测试的细微差别、与测试框架的集成以及实际考虑因素将进一步阐明TDD在塑造高质量、可维护的C++代码库中的作用。
- en: Unit testing in C++
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的单元测试
- en: Unit tests are a foundational aspect of TDD in software engineering, playing
    a pivotal role in the C++ development process. They focus on validating the smallest
    sections of code, known as units, which are typically individual functions, methods,
    or classes. By testing these components in isolation, unit tests ensure that each
    part of the software behaves as intended, which is crucial for the system’s overall
    functionality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是软件工程中TDD的基础性方面，在C++开发过程中发挥着关键作用。它们专注于验证代码的最小部分，称为单元，通常是单个函数、方法或类。通过单独测试这些组件，单元测试确保软件的每个部分都按预期运行，这对于系统的整体功能至关重要。
- en: In the TDD framework, unit tests take on an even more significant role. They
    are often written before the actual code, guiding the development process and
    ensuring that the software is designed with testability and correctness in mind
    from the outset. This approach to writing unit tests before the implementation
    helps in identifying bugs early in the development cycle, allowing for timely
    corrections that prevent the bugs from becoming more complex or affecting other
    parts of the system. This proactive bug detection not only saves time and resources
    but also contributes to the software’s stability.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD框架中，单元测试承担着更加重要的角色。它们通常在实际代码编写之前编写，指导开发过程，并确保软件从一开始就考虑到可测试性和正确性。在实现之前编写单元测试的方法有助于在开发周期早期发现错误，从而及时纠正，防止错误变得更加复杂或影响系统的其他部分。这种主动的错误检测不仅节省了时间和资源，而且有助于提高软件的稳定性。
- en: Moreover, unit tests act as a safety net for developers, enabling them to refactor
    code confidently without fear of breaking existing functionality. This is particularly
    valuable in TDD, where refactoring is a key step in the cycle of writing a test,
    making it pass, and then improving the code. Beyond their role in bug detection
    and facilitating refactoring, unit tests also serve as effective documentation,
    providing clear insights into the expected behavior of the system. This makes
    them an invaluable resource for developers, especially those new to the code base.
    Additionally, the process of writing unit tests in the TDD approach often highlights
    design improvements, leading to more robust and maintainable code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单元测试作为开发者的安全网，使他们能够自信地重构代码，而不用担心破坏现有的功能。这在TDD中尤其有价值，因为在TDD中，重构是编写测试、使其通过并改进代码的循环中的关键步骤。除了在错误检测和促进重构中的作用外，单元测试还充当有效的文档，提供对系统预期行为的清晰见解。这使得它们成为开发者的宝贵资源，尤其是对于新加入代码库的开发者来说。此外，在TDD方法中编写单元测试的过程通常突出了设计改进，从而导致了更健壮和可维护的代码。
- en: C++ unit testing frameworks
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++单元测试框架
- en: The C++ ecosystem is rich with unit testing frameworks designed to facilitate
    the creation, execution, and maintenance of tests. Among these, Google Test and
    Google Mock stand out for their comprehensive feature set, ease of use, and integration
    capabilities with C++ projects. In this section, we’ll delve into Google Test
    and Google Mock, highlighting their key features and syntax, and demonstrate how
    they can be integrated into a CMake project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++生态系统拥有丰富的单元测试框架，旨在促进测试的创建、执行和维护。在这些框架中，Google Test和Google Mock因其全面的功能集、易用性和与C++项目的集成能力而脱颖而出。在本节中，我们将深入探讨Google
    Test和Google Mock，突出它们的关键功能和语法，并演示如何将它们集成到CMake项目中。
- en: Google Test and Google Mock
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Test和Google Mock
- en: '`EXPECT_EQ` and `ASSERT_NE` to compare expected outcomes with actual results,
    ensuring precise validation of test conditions. Furthermore, Google Test simplifies
    the management of common test configurations through test fixtures, which define
    setup and teardown operations, providing a consistent environment for each test.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `EXPECT_EQ` 和 `ASSERT_NE` 来比较预期结果与实际结果，确保测试条件的精确验证。此外，Google Test 通过测试夹具简化了常见测试配置的管理，夹具定义了设置和清理操作，为每个测试提供一个一致的环境。
- en: Another significant feature is the support for parameterized tests, allowing
    developers to write a single test and run it with multiple inputs. This approach
    greatly enhances test coverage without the need for duplicative code. Complementing
    this, Google Test also supports type-parameterized tests, which permit the execution
    of the same test logic across different data types, broadening the scope of test
    coverage even further.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要特性是对参数化测试的支持，允许开发者编写单个测试并在多个输入上运行它。这种方法大大增强了测试覆盖率，而无需重复代码。与此相辅相成的是，Google
    Test 还支持类型参数化测试，允许在不同数据类型上执行相同的测试逻辑，进一步扩大测试覆盖范围。
- en: One of the most user-friendly features of Google Test is its automatic test
    discovery mechanism. This feature eliminates the need for manual test registration,
    as Google Test automatically identifies and executes tests within the project,
    streamlining the testing process and saving valuable development time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 最用户友好的特性之一是其自动测试发现机制。此功能消除了手动测试注册的需要，因为 Google Test 自动识别并执行项目中的测试，简化了测试过程并节省了宝贵的发展时间。
- en: '**Google Mock**, also known as **gMock**, complements Google Test by providing
    a robust mocking framework, which integrates seamlessly to simulate complex object
    behaviors. This capability is invaluable in creating conditions that mimic real-world
    scenarios, allowing for more thorough testing of code interactions. With Google
    Mock, developers gain the flexibility to set expectations on mocked objects, tailoring
    them to specific needs such as the number of times a function is called, the arguments
    it receives, and the sequence of calls. This level of control ensures that tests
    can verify not just the outcomes but also the interactions between different parts
    of the code.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Mock**，也称为 **gMock**，通过提供强大的模拟框架来补充 Google Test，该框架可以无缝集成以模拟复杂对象行为。这种能力在创建模拟真实世界场景的条件时非常有价值，允许更彻底地测试代码交互。使用
    Google Mock，开发者可以灵活地设置模拟对象期望，根据特定需求定制，例如函数被调用的次数、接收的参数以及调用顺序。这种控制水平确保测试不仅可以验证结果，还可以验证代码不同部分之间的交互。'
- en: Furthermore, Google Mock is specifically designed to work in harmony with Google
    Test, facilitating the creation of comprehensive tests that can leverage both
    actual objects and their mocked counterparts. This integration simplifies the
    process of writing tests that are both extensive and reflective of real application
    behavior, thereby enhancing the reliability and maintainability of the codebase.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Google Mock 特别设计用于与 Google Test 协同工作，简化了创建可以同时利用实际对象及其模拟对应物的全面测试的过程。这种集成简化了编写既广泛又反映真实应用程序行为的测试的过程，从而增强了代码库的可靠性和可维护性。
- en: Integrating Google Test into a C++ project
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Google Test 集成到 C++ 项目中
- en: We’re going to demonstrate how to incorporate Google Test into a CMake project,
    providing a step-by-step guide to configuring CMake to work with Google Test for
    unit testing in C++ projects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示如何将 Google Test 集成到 CMake 项目中，提供配置 CMake 以与 Google Test 一起进行 C++ 项目的单元测试的逐步指南。
- en: To start, ensure that Google Test is included in your project. This can be done
    by adding Google Test as a submodule in your project’s repository or downloading
    it via CMake. Once Google Test is part of your project, the next step is to configure
    your `CMakeLists.txt` file to include Google Test in the build process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保 Google Test 包含在您的项目中。这可以通过将 Google Test 添加为项目存储库中的子模块或通过 CMake 下载来实现。一旦
    Google Test 成为项目的一部分，下一步就是配置您的 `CMakeLists.txt` 文件以在构建过程中包含 Google Test。
- en: 'Here’s an example of how you might configure your `CMakeLists.txt` file to
    integrate Google Test via a submodule:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何配置您的 `CMakeLists.txt` 文件以通过子模块集成 Google Test 的示例：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Update `CMakeLists.txt` to include Google Test and Google Mock in the build:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `CMakeLists.txt` 以在构建中包含 Google Test 和 Google Mock：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this configuration, `add_subdirectory(external/googletest)` tells CMake to
    include Google Test in the build. `include_directories` ensures that the Google
    Test headers are accessible to your test files. `add_executable` defines a new
    executable for your tests, and `target_link_libraries` links the Google Test libraries
    to your test executable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，`add_subdirectory(external/googletest)` 告诉 CMake 将 Google Test 包含在构建中。`include_directories`
    确保Google Test 的头文件对您的测试文件是可访问的。`add_executable` 定义了一个新的可执行文件用于您的测试，而 `target_link_libraries`
    将 Google Test 库链接到您的测试可执行文件。
- en: After configuring `CMakeLists.txt`, you can build and run your tests using CMake
    and make commands. This setup not only integrates Google Test into your project
    but also leverages CMake’s testing capabilities to automate running the tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 `CMakeLists.txt` 之后，您可以使用 CMake 和 make 命令构建和运行您的测试。此设置不仅将 Google Test 集成到您的项目中，而且还利用
    CMake 的测试功能来自动运行测试。
- en: 'The following code snippet demonstrates another way to configure CMake to use
    Google Test, which is by downloading Google Test via CMake’s `FetchContent` module.
    This approach allows CMake to download Google Test during the build process, ensuring
    that the project’s dependencies are automatically managed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了另一种配置 CMake 以使用 Google Test 的方法，即通过 CMake 的 `FetchContent` 模块下载 Google
    Test。这种方法允许 CMake 在构建过程中下载 Google Test，确保项目的依赖项自动管理：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While this example focuses on integrating Google Test with CMake, it’s worth
    noting that Google Test is versatile and can be integrated into other build systems
    as well, such as Google’s own Bazel. For projects using different build systems
    or for more complex configurations, refer to the official Google Test documentation
    for comprehensive guidance and best practices. This documentation provides valuable
    insights into leveraging Google Test across various environments and build systems,
    ensuring that you can effectively implement unit testing in your C++ projects
    regardless of the development setup.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子侧重于将 Google Test 与 CMake 集成，但值得注意的是 Google Test 是灵活的，也可以集成到其他构建系统中，例如
    Google 自己的 Bazel。对于使用不同构建系统或更复杂配置的项目，请参考官方 Google Test 文档以获取全面指导和建议最佳实践。此文档提供了关于在各个环境和构建系统中利用
    Google Test 的宝贵见解，确保您可以在任何开发设置中有效地在您的 C++ 项目中实施单元测试。
- en: Usage of Google Test in C++ projects
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C++ 项目中使用 Google Test
- en: Google Test provides a comprehensive suite of functionalities to support various
    testing needs in C++ development. Understanding how to effectively leverage these
    features can significantly enhance your testing practices. Let’s explore the usage
    of Google Test through simple examples and explanations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 提供了一套全面的函数，以支持 C++ 开发中的各种测试需求。了解如何有效地利用这些功能可以显著提高您的测试实践。让我们通过简单的示例和解释来探讨
    Google Test 的使用。
- en: Writing a simple test
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的测试
- en: 'A simple test in Google Test can be written using the `TEST` macro, which defines
    a test function. Within this function, you can use various assertions to verify
    the behavior of your code. Here’s a basic example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Test 中编写一个简单的测试可以使用 `TEST` 宏，它定义了一个测试函数。在这个函数内部，您可以使用各种断言来验证您代码的行为。以下是一个基本示例：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, `EXPECT_EQ` is used to assert that the `add` function returns
    the expected sum of two positive numbers. Google Test provides a variety of assertions
    such as `EXPECT_GT` (greater than), `EXPECT_TRUE` (Boolean `true`), and many others
    for different testing scenarios.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，使用 `EXPECT_EQ` 断言 `add` 函数返回两个正数的预期和。Google Test 提供了各种断言，如 `EXPECT_GT`（大于）、`EXPECT_TRUE`（布尔
    `true`）等，以适应不同的测试场景。
- en: The key difference between `EXPECT_*` and `ASSERT_*` assertions lies in their
    behavior upon failure. While `EXPECT_*` assertions allow the test to continue
    running after a failure, `ASSERT_*` assertions will halt the current test function
    immediately upon failure. Use `EXPECT_*` when subsequent lines of the test do
    not depend on the success of the current assertion, and `ASSERT_*` when the failure
    of an assertion would make the continuation of the test meaningless or potentially
    cause errors.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPECT_*` 断言和 `ASSERT_*` 断言之间的关键区别在于它们在失败时的行为。虽然 `EXPECT_*` 断言允许测试在失败后继续运行，但
    `ASSERT_*` 断言将在失败时立即停止当前测试函数。当测试的后续行不依赖于当前断言的成功时，使用 `EXPECT_*`；当断言的失败会使测试的继续进行没有意义或可能引起错误时，使用
    `ASSERT_*`。'
- en: Using a test fixture
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试夹具
- en: 'For tests that require a common setup and teardown for multiple test cases,
    Google Test offers the concept of a test fixture. This is achieved by defining
    a class derived from `::testing::Test` and then using the `TEST_F` macro to write
    tests that use this fixture:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要为多个测试用例提供共同设置和清理的测试，Google Test 提供了测试夹具的概念。这是通过定义一个从 `::testing::Test` 派生的类，然后使用
    `TEST_F` 宏来编写使用此夹具的测试来实现的：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, `SetUp` and `TearDown` are overridden to provide a common setup
    (initializing a `Calculator` object) and teardown (cleaning up the `Calculator`
    object) for each test case. `TEST_F` is used to define test functions that automatically
    use this setup and teardown, ensuring that each test starts with a fresh `Calculator`
    instance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`SetUp` 和 `TearDown` 被覆盖以提供每个测试用例的共同设置（初始化一个 `Calculator` 对象）和清理（清理 `Calculator`
    对象）。使用 `TEST_F` 来定义自动使用此设置和清理的测试函数，确保每个测试从一个全新的 `Calculator` 实例开始。
- en: The main function
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: 'To run the tests, Google Test requires a main function that initializes the
    Google Test framework and runs all the tests. Here’s an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，Google Test 需要一个主函数来初始化 Google Test 框架并运行所有测试。以下是一个示例：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This main function initializes Google Test, passing the command-line arguments
    to it, which allows for controlling test execution from the command line. `RUN_ALL_TESTS()`
    runs all the tests that have been defined and returns `0` if all tests pass or
    `1` otherwise.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主函数初始化 Google Test，将命令行参数传递给它，这允许从命令行控制测试执行。`RUN_ALL_TESTS()` 运行所有已定义的测试，如果所有测试都通过则返回
    `0`，否则返回 `1`。
- en: By following these examples and explanations, you can start using Google Test
    to write comprehensive tests for your C++ projects, ensuring that your code behaves
    as expected across a wide range of scenarios.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些示例和解释，你可以开始使用 Google Test 为你的 C++ 项目编写全面的测试，确保你的代码在各种场景下都能按预期行为。
- en: Running Google Test tests
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Google Test 测试
- en: After setting up Google Test with your CMake project and compiling your tests,
    running them is straightforward. You execute the tests using the `ctest` command
    in your build directory, which CMake uses to run tests defined in your `CMakeLists.txt`
    file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Google Test 与你的 CMake 项目设置好并编译了测试之后，运行测试非常直接。你通过在构建目录中使用 `ctest` 命令来执行测试，CMake
    使用这个命令来运行你在 `CMakeLists.txt` 文件中定义的测试。
- en: 'When you run the tests for a `Calculator` class, the standard output to your
    terminal might look like this if you execute the test binary directly:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你直接执行测试二进制文件时，为 `Calculator` 类运行测试，你的终端的标准输出可能看起来像这样：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This output details each test suite and test case, showing which tests were
    run (`[ RUN      ]`) and their results (`[       OK ]` for passed tests). It provides
    a clear breakdown of the testing process, including setup and teardown phases,
    and aggregates the results at the end.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出详细说明了每个测试套件和测试用例，显示哪些测试被执行了（`[ RUN      ]`）以及它们的结果（通过测试的 `[       OK ]`）。它提供了测试过程的清晰分解，包括设置和清理阶段，并在最后汇总结果。
- en: 'If you run the tests using `ctest`, the output is more concise by default:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `ctest` 运行测试，默认情况下输出更简洁：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this `ctest` output, each line corresponds to a test case, showing its start
    order, name, and result. The summary at the end gives a quick overview of the
    total number of tests, how many passed, and how many failed. This format is useful
    for getting a quick assessment of your test suite’s health without the detailed
    breakdown provided by the Google Test output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `ctest` 输出中，每一行对应一个测试用例，显示其开始顺序、名称和结果。最后的总结提供了一个快速概览，包括测试总数、通过的数量和失败的数量。这种格式对于快速评估你的测试套件的健康状况非常有用，而不需要
    Google Test 输出提供的详细分解。
- en: Advanced features of Google Test
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Test 的高级功能
- en: Google Test offers a range of advanced features designed to handle complex testing
    scenarios, providing developers with powerful tools to ensure their code’s robustness.
    Among these features, one notable capability is the support for *death tests*.
    Death tests are particularly useful for verifying that your code exhibits the
    expected behavior when it encounters fatal conditions, such as failed assertions
    or explicit calls to `abort()`. This is crucial in scenarios where you want to
    ensure that your application responds appropriately to unrecoverable errors, enhancing
    its reliability and safety.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 提供了一系列旨在处理复杂测试场景的高级功能，为开发者提供了强大的工具，以确保其代码的健壮性。在这些功能中，一个值得注意的能力是支持
    *死亡测试*。死亡测试在验证代码在遇到致命条件（如失败的断言或显式调用 `abort()`）时表现出预期的行为特别有用。在需要确保应用程序能够适当地响应不可恢复的错误的情况下，这一点至关重要，从而增强了其可靠性和安全性。
- en: 'Here’s a brief example of a death test:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个死亡测试的简要示例：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, `EXPECT_DEATH_IF_SUPPORTED` checks that `risky_function(true)`
    indeed causes the program to exit (due to the failed assertion), and it matches
    the specified error message. This ensures that the function behaves as expected
    under fatal conditions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`EXPECT_DEATH_IF_SUPPORTED` 检查 `risky_function(true)` 是否确实导致程序退出（由于失败的断言），并且它与指定的错误消息相匹配。这确保了函数在致命条件下表现出预期的行为。
- en: Other advanced features of Google Test include *mocking* for simulating complex
    object interactions, *parameterized tests* for running the same test logic with
    various inputs, and *type-parameterized tests* for applying the same test logic
    across different data types. These features enable comprehensive testing strategies
    that can cover a wide range of scenarios and inputs, ensuring thorough validation
    of your code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test 的其他高级功能包括用于模拟复杂对象交互的 *mocking*，用于使用各种输入运行相同测试逻辑的 *参数化测试*，以及用于在不同数据类型上应用相同测试逻辑的
    *类型参数化测试*。这些功能使得可以实施全面的测试策略，覆盖广泛的场景和输入，确保对代码进行彻底的验证。
- en: For developers seeking to leverage the full potential of Google Test, including
    its advanced features such as death tests and more, the official Google Test documentation
    serves as an invaluable resource. It offers detailed explanations, examples, and
    best practices, guiding you through the nuances of effective test writing and
    execution in C++ projects. By referring to this documentation, you can deepen
    your understanding of Google Test’s capabilities and integrate them effectively
    into your testing workflow.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于寻求充分利用 Google Test 的全部潜力，包括死亡测试等高级功能的开发者来说，官方 Google Test 文档是一个无价资源。它提供了详细的解释、示例和最佳实践，指导你了解
    C++ 项目中有效编写和执行测试的细微差别。通过参考此文档，你可以加深对 Google Test 功能的理解，并有效地将其集成到测试工作流程中。
- en: Using gMock in C++ projects
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C++ 项目中使用 gMock
- en: In the world of software testing, particularly within the methodology of TDD,
    a mock object plays a crucial role. It’s designed to mimic the behavior of real
    objects by implementing the same interface, allowing it to stand in for the actual
    object in tests. However, the power of a mock object lies in its flexibility;
    developers can specify its behavior at runtime, including which methods are called,
    their call order, frequency, argument specifications, and the return values. This
    level of control turns mock objects into powerful tools for testing interactions
    and integrations within the code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件测试的世界中，尤其是在 TDD 方法论中，模拟对象扮演着至关重要的角色。它通过实现相同的接口来模拟真实对象的行为，允许它在测试中代替实际对象。然而，模拟对象的力量在于其灵活性；开发者可以在运行时指定其行为，包括调用的方法、调用顺序、频率、参数指定和返回值。这种程度的控制使模拟对象成为测试代码中交互和集成的强大工具。
- en: Mocks address several challenges in testing complex or interconnected systems.
    When developing prototypes or tests, relying solely on real objects might not
    be feasible or practical due to constraints such as external dependencies, execution
    time, or costs associated with real operations. In such cases, mocks provide a
    lightweight, controllable substitute that replicates the necessary interactions
    without the overhead or side effects of the real implementations. They enable
    developers to focus on the behavior and integration of components rather than
    their underlying implementations, facilitating more focused and efficient testing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象解决了测试复杂或相互关联的系统中的几个挑战。在开发原型或测试时，由于外部依赖、执行时间或与真实操作相关的成本等限制，仅依赖真实对象可能不可行或不切实际。在这种情况下，模拟对象提供了一个轻量级、可控制的替代品，它复制了必要的交互，而没有真实实现的开销或副作用。这使得开发者能够专注于组件的行为和集成，而不是其底层实现，从而促进更专注和高效的测试。
- en: 'The distinction between fake objects and mock objects is crucial to understanding
    their appropriate use cases. While both serve as substitutes for real objects
    in testing, they have different characteristics and purposes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 伪造对象与模拟对象之间的区别对于理解它们的适当用例至关重要。虽然两者都充当真实对象的替代品用于测试，但它们具有不同的特性和目的：
- en: '**Fake objects**: These are simplified implementations that mimic real objects
    but typically take shortcuts for the sake of testing efficiency. An example would
    be an in-memory database that replicates the functionality of a real database
    system without persistent storage. Fakes are practical for tests where the exact
    workings of the real object are not under scrutiny.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伪造对象**：这些是简化实现，模仿真实对象，但通常为了测试效率而采取捷径。一个例子是内存数据库，它复制了真实数据库系统的功能，但没有持久存储。伪造对象适用于那些对真实对象的精确工作原理不是审查重点的测试。'
- en: '**Mock objects**: Unlike fakes, mocks are pre-programmed with specific expectations
    that form a contract of how they should be used. They are ideal for testing the
    interactions between the system under test and its dependencies. For instance,
    when testing a class that relies on a service, a mock of the service can be used
    to ensure that the class interacts with the service as expected without actually
    invoking the service’s real implementation.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟对象**：与伪造对象不同，模拟对象预先编程了特定的期望，形成了一种如何使用的契约。它们非常适合测试被测试系统及其依赖项之间的交互。例如，当测试一个依赖于服务的类时，可以使用服务的模拟对象来确保该类以预期的方式与服务交互，而无需实际调用服务的真实实现。'
- en: gMock, Google’s framework for creating mock classes in C++, provides a comprehensive
    solution akin to what jMock and EasyMock offer for Java. With gMock, developers
    first describe the interface of the object to be mocked using macros, which then
    generate the mock class implementation. Developers can then instantiate mock objects,
    setting up their expected behaviors and interactions using gMock’s intuitive syntax.
    During test execution, gMock monitors these mock objects, ensuring that all specified
    interactions adhere to the defined expectations, and flagging any deviations as
    errors. This immediate feedback is invaluable for identifying issues in how components
    interact with their dependencies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: gMock是Google为C++创建模拟类的框架，它提供了一个类似于jMock和EasyMock为Java提供的全面解决方案。使用gMock，开发者首先使用宏描述要模拟的对象的接口，然后生成模拟类实现。然后，开发者可以实例化模拟对象，使用gMock直观的语法设置它们的预期行为和交互。在测试执行期间，gMock监控这些模拟对象，确保所有指定的交互都符合定义的期望，并将任何偏差标记为错误。这种即时反馈对于识别组件与其依赖项交互中的问题非常有价值。
- en: Example of using gMock
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gMock的使用示例
- en: 'In unit testing, particularly when interfacing with network operations, mocking
    is an invaluable technique. This is exemplified in the case of a `Socket` class,
    which serves as a foundational element for network communication. The `Socket`
    class abstracts the functionality of sending and receiving raw byte arrays over
    a network, providing methods such as `send` and `recv`. Concrete classes such
    as `TcpSocket`, `UdpSocket`, and `WebSocket` extend this base class to implement
    specific network protocols. The following code shows the definition of the `Socket`
    class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，尤其是在与网络操作接口时，模拟是一种非常有价值的技巧。这以`Socket`类为例，它是网络通信的基础元素。`Socket`类抽象了在网络中发送和接收原始字节数组的功能，提供了`send`和`recv`等方法。具体的类如`TcpSocket`、`UdpSocket`和`WebSocket`扩展了这个基类以实现特定的网络协议。以下代码显示了`Socket`类的定义：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For instance, the `DataSender` class relies on a `Socket` instance to send
    data. This class is meticulously designed to manage data transmission, attempting
    retries as necessary and handling various scenarios such as partial data sends,
    peer-initiated connection closures, and connection errors. The objective in unit
    testing `DataSender` is to validate its behavior across these different scenarios
    without engaging in actual network communication. The `DataSender` class is defined
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`DataSender`类依赖于一个`Socket`实例来发送数据。这个类精心设计以管理数据传输，必要时尝试重试，并处理各种场景，如部分数据发送、对等方发起的连接关闭和连接错误。在单元测试`DataSender`时的目标是验证它在这些不同场景中的行为，而不进行实际的网络通信。`DataSender`类的定义如下：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This requirement leads us to the use of a `MockSocket` class, derived from
    `Socket`, to simulate network interactions. Here’s how `MockSocket` is defined:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个要求引导我们使用一个从`Socket`派生的`MockSocket`类来模拟网络交互。以下是`MockSocket`的定义：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `MockSocket` class utilizes the `MOCK_METHOD` macro from gMock to mock the
    `send` and `recv` methods of the `Socket` class, allowing for the specification
    of expected behavior during tests. The `override` keyword ensures that these mock
    methods correctly override their counterparts in the `Socket` class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockSocket`类使用gMock的`MOCK_METHOD`宏来模拟`Socket`类的`send`和`recv`方法，允许在测试期间指定预期的行为。`override`关键字确保这些模拟方法正确地覆盖了`Socket`类中的对应方法。'
- en: 'Setting expectations in gMock is done using constructs such as `WillOnce` and
    `WillRepeatedly`, which define how mock methods behave when invoked:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在gMock中设置期望使用诸如`WillOnce`和`WillRepeatedly`之类的构造，这些构造定义了当调用模拟方法时它们的行为：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this `HappyPath` test, `EXPECT_CALL` sets an expectation that `send` will
    be called exactly once, successfully transmitting all the data in a single attempt.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个“HappyPath”测试中，`EXPECT_CALL`设置了一个期望，即`send`将被调用一次，成功地在单次尝试中传输所有数据。
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This test expects two calls to `send`: the first transmits only a portion of
    the data, while the second completes the transmission, simulating a successful
    `send` on the second attempt.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试期望对`send`进行两次调用：第一次只传输部分数据，而第二次完成传输，模拟第二次尝试成功的`send`。
- en: 'The rest of the tests check various error scenarios, such as partial data transmission,
    connection closure by the peer, and connection errors. Here’s an example of a
    test for the scenario where data is sent partially:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的测试检查各种错误场景，例如部分数据传输、由对等方关闭连接以及连接错误。以下是一个测试数据部分发送场景的示例：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running these tests with gMock and observing the output allows us to confirm
    the `DataSender` class’s behavior under various conditions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gMock运行这些测试并观察输出，使我们能够确认`DataSender`类在各种条件下的行为：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output succinctly reports the execution and outcomes of each test, indicating
    the successful validation of the `DataSender` class’s handling of different network
    communication scenarios. For more comprehensive details on utilizing gMock, including
    its full suite of features, the official gMock documentation serves as an essential
    resource, guiding developers through effective mocking strategies in C++ unit
    testing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出简洁地报告了每个测试的执行和结果，表明`DataSender`类成功处理了不同的网络通信场景。有关利用gMock的更全面细节，包括其完整功能套件，官方gMock文档是一个基本资源，指导开发者通过有效的模拟策略进行C++单元测试。
- en: Mocking non-virtual methods via dependency injection
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过依赖注入模拟非虚拟方法
- en: In certain scenarios, you might encounter the need to mock non-virtual methods
    for unit testing. This can be challenging, as traditional mocking frameworks such
    as gMock primarily target virtual methods due to C++’s polymorphism requirements.
    However, one effective strategy to overcome this limitation is through dependency
    injection, coupled with the use of templates. This approach enhances testability
    and flexibility by decoupling the class dependencies.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景下，你可能需要模拟非虚拟方法进行单元测试。这可能具有挑战性，因为传统的模拟框架如gMock主要针对虚拟方法，这是由于C++的多态性要求。然而，一种克服这种限制的有效策略是通过依赖注入，结合模板的使用。这种方法通过解耦类依赖来增强可测试性和灵活性。
- en: Refactoring for testability
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为了可测试性进行重构
- en: To illustrate this, let’s refactor the `Socket` class interface and the `DataSender`
    class to accommodate the mocking of non-virtual methods. We’ll introduce templates
    to `DataSender` to allow injecting either the real `Socket` class or its mock
    version.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们重构`Socket`类接口和`DataSender`类以适应非虚拟方法的模拟。我们将在`DataSender`中引入模板，允许注入真实的`Socket`类或其模拟版本。
- en: 'First, consider a simplified version of the `Socket` class without virtual
    methods:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑一个没有虚拟方法的`Socket`类的简化版本：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we modify the `DataSender` class to accept a `template` parameter for
    the socket type, enabling the injection of either a real socket or a mock socket
    at compile-time:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们修改`DataSender`类以接受一个用于socket类型的`template`参数，允许在编译时注入真实socket或模拟socket：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this template-based design, `DataSender` can now be instantiated with any
    type that conforms to the `Socket` interface, including mock types.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种基于模板的设计，`DataSender`现在可以用符合`Socket`接口的任何类型实例化，包括模拟类型。
- en: Mocking with templates
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板进行模拟
- en: 'For the mock version of `Socket`, we can define a `MockSocket` class as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Socket`的模拟版本，我们可以定义一个`MockSocket`类如下：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This `MockSocket` class mimics the `Socket` interface but uses gMock’s `MOCK_METHOD`
    to define mock methods.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`MockSocket`类模仿了`Socket`接口，但使用gMock的`MOCK_METHOD`来定义模拟方法。
- en: Unit testing with dependency injection
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于依赖注入的单元测试
- en: 'When writing tests for `DataSender`, we can now inject `MockSocket` using templates:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当为`DataSender`编写测试时，我们现在可以使用模板注入`MockSocket`：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this test, `DataSender` is instantiated with `MockSocket`, allowing the `send`
    method to be mocked as desired. This demonstrates how templates and dependency
    injection enable the mocking of non-virtual methods, providing a flexible and
    powerful approach to unit testing in C++.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，使用`MockSocket`实例化`DataSender`，允许按需模拟`send`方法。这展示了模板和依赖注入如何使非虚拟方法的模拟成为可能，为C++中的单元测试提供了一种灵活且强大的方法。
- en: This technique, while powerful, requires careful design consideration to ensure
    that the code remains clean and maintainable. For complex scenarios or further
    exploration of mocking strategies, the official gMock documentation remains an
    invaluable resource, offering a wealth of information on advanced mocking techniques
    and best practices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术虽然强大，但需要仔细的设计考虑，以确保代码保持整洁和可维护。对于复杂场景或对模拟策略的进一步探索，官方gMock文档仍然是一个无价资源，提供了关于高级模拟技术和最佳实践的丰富信息。
- en: Mocking singletons
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟Singleton
- en: Despite being considered an anti-pattern due to its potential to introduce a
    global state and tight coupling in software designs, the Singleton pattern is
    nevertheless prevalent in many code bases. Its convenience for ensuring a single
    instance of a class often leads to its use in scenarios such as database connections,
    where a single, shared resource is logically appropriate.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管由于其可能引入全局状态和软件设计中的紧密耦合而被视为反模式，但Singleton模式在许多代码库中仍然很普遍。它确保类只有一个实例的便利性通常导致其在数据库连接等场景中使用，在这些场景中，一个共享资源在逻辑上是合适的。
- en: The Singleton pattern’s characteristic of restricting class instantiation and
    providing a global access point presents a challenge for unit testing, particularly
    when the need arises to mock the singleton’s behavior.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Singleton模式限制类实例化和提供全局访问点的特性为单元测试带来了挑战，尤其是在需要模拟单例行为时。
- en: 'Consider the example of a `Database` class implemented as a singleton:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个实现为单例的`Database`类的示例：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this scenario, the `DataHandler` class interacts with the `Database` singleton
    to perform operations, such as querying data:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`DataHandler`类与`Database`单例交互以执行操作，例如查询数据：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To facilitate testing of the `DataHandler` class without relying on the real
    `Database` instance, we can introduce a templated variation, `DataHandler1`, that
    allows injecting a mock database instance:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于测试`DataHandler`类而不依赖于真实的`Database`实例，我们可以引入一个模板变体`DataHandler1`，允许注入模拟数据库实例：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This approach leverages templates to decouple `DataHandler1` from the concrete
    `Database` singleton, enabling the substitution of a `MockDatabase` during tests:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法利用模板将`DataHandler1`与具体的`Database`单例解耦，允许在测试期间用`MockDatabase`替换：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With `MockDatabase` in place, unit tests can now simulate database interactions
    without hitting the actual database, as demonstrated in the following test case:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MockDatabase`就位后，单元测试现在可以模拟数据库交互而不实际接触数据库，如下面的测试用例所示：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This test instantiates `DataHandler1` with `MockDatabase`, ensuring that the
    `doSomething` method interacts with the mock rather than the real database. The
    expected result is a predefined mock response, making the test predictable and
    isolated from external dependencies.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试实例化了`DataHandler1`与`MockDatabase`，确保`doSomething`方法与模拟对象而不是真实数据库交互。预期的结果是预定义的模拟响应，使测试可预测且与外部依赖隔离。
- en: This templated solution, a variation of the dependency injection technique discussed
    earlier, showcases the flexibility and power of templates in C++. It elegantly
    addresses the challenge of mocking singletons, thereby enhancing the testability
    of components that depend on singleton instances. For more complex scenarios or
    further exploration of mocking strategies, referring to the official gMock documentation
    is advisable, as it offers comprehensive insights into advanced mocking techniques
    and best practices.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板解决方案是之前讨论过的依赖注入技术的变体，展示了C++模板的灵活性和强大功能。它优雅地解决了模拟单例的挑战，从而增强了依赖于单例实例的组件的可测试性。对于更复杂的场景或对模拟策略的进一步探索，建议参考官方gMock文档，因为它提供了对高级模拟技术和最佳实践的全面见解。
- en: The Nice, the Strict, and the Naggy
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 和善的、严格的和挑剔的
- en: 'In the world of unit testing with gMock, managing the behavior of mock objects
    and their interactions with the system under test is crucial. gMock introduces
    three modes to control this behavior: Naggy, Nice, and Strict. These modes determine
    how gMock handles uninteresting calls – those not matched by any `EXPECT_CALL`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用gMock进行单元测试的世界中，管理模拟对象的行为及其与被测试系统的交互至关重要。gMock引入了三种模式来控制这种行为：挑剔的、和善的和严格的。这些模式决定了gMock如何处理不感兴趣的调用——那些与任何`EXPECT_CALL`不匹配的调用。
- en: Naggy mocks
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑剔的模拟
- en: By default, mock objects in gMock are “naggy.” This means that while they warn
    about uninteresting calls, these calls do not cause the test to fail. The warning
    serves as a reminder that there might be unexpected interactions with the mock,
    but it’s not critical enough to warrant a test failure. This behavior ensures
    that tests focus on the intended expectations without being too lenient or too
    strict about incidental interactions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，gMock中的模拟对象是“挑剔”的。这意味着虽然它们会警告不感兴趣的调用，但这些调用不会导致测试失败。警告的作用是提醒可能存在与模拟对象的意外交互，但这并不足以引起测试失败。这种行为确保测试专注于预期的期望，而不会对偶然的交互过于宽容或过于严格。
- en: 'Consider the following test scenario:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下测试场景：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, if there’s an uninteresting call to `recv`, gMock issues a warning
    but the test will pass, marking unanticipated interactions without failing the
    test.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果有一个对`recv`的不感兴趣调用，gMock会发出警告，但测试会通过，标记出未预料的交互而不使测试失败。
- en: Nice mocks
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 和善的模拟
- en: '`NiceMock` objects go a step further by suppressing warnings for uninteresting
    calls. This mode is useful when the test’s focus is strictly on specific interactions,
    and other incidental calls to the mock should be ignored without cluttering the
    test output with warnings.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`NiceMock`对象通过抑制不感兴趣调用的警告更进一步。这种模式在测试的重点严格限于特定交互时很有用，其他对模拟的偶然调用应该被忽略，而不会在测试输出中添加警告。'
- en: 'Using `NiceMock` in a test looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中使用`NiceMock`的示例如下：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this `Nice` mode, even if there are uninteresting calls to `recv`, gMock
    quietly ignores them, keeping the test output clean and focused on the defined
    expectations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`和善`模式下，即使有对`recv`的不感兴趣调用，gMock也会默默地忽略它们，保持测试输出干净并专注于定义的期望。
- en: Strict mocks
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格的模拟
- en: On the other end of the spectrum, `StrictMock` objects treat uninteresting calls
    as errors. This strictness ensures that every interaction with the mock is accounted
    for by an `EXPECT_CALL`. This mode is particularly useful in tests where precise
    control over mock interactions is necessary, and any deviation from the expected
    calls should lead to test failure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在光谱的另一端，`StrictMock`对象将不感兴趣的调用视为错误。这种严格性确保了与模拟对象的每次交互都通过`EXPECT_CALL`得到记录。这种模式在需要精确控制模拟交互的测试中特别有用，任何与预期调用不符的偏差都应导致测试失败。
- en: 'A test using `StrictMock` might look like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`StrictMock`的测试可能看起来像这样：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In `Strict` mode, any uninteresting call, such as to `recv`, results in a test
    failure, enforcing strict adherence to the defined expectations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`严格`模式下，任何不感兴趣的调用，例如对`recv`的调用，都会导致测试失败，强制遵守定义的期望。
- en: Test output and recommended settings
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试输出和推荐设置
- en: 'The behavior of these mocking modes is reflected in the test output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模拟模式的行为反映在测试输出中：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In `Naggy` mode, the test passes with a warning for uninteresting calls. `Nice`
    mode also passes but without any warnings. `Strict` mode, however, fails the test
    if there are uninteresting calls.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Naggy` 模式下，测试通过时会有关于不感兴趣调用的警告。`Nice` 模式同样通过测试，但没有警告。然而，`Strict` 模式如果存在不感兴趣的调用，则会失败测试。
- en: It is recommended to start with `StrickMock` and then relax the mode as needed.
    This approach ensures that tests are initially strict about interactions with
    mock objects, providing a safety net for unexpected calls. As the test suite matures
    and the expected interactions become clearer, the mode can be relaxed to `Naggy`
    or `Nice` to reduce noise in the test output.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 建议从 `StrickMock` 开始，根据需要逐步放宽模式。这种方法确保测试最初对与模拟对象的交互非常严格，为意外的调用提供安全网。随着测试套件的成熟和预期交互的日益清晰，模式可以放宽到
    `Naggy` 或 `Nice`，以减少测试输出中的噪音。
- en: For further exploration of these modes and advanced mocking techniques, the
    official gMock documentation provides comprehensive insights and examples, guiding
    developers through effective mock object management in unit testing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步探索这些模式和高级模拟技术，官方 gMock 文档提供了全面的见解和示例，指导开发者通过有效的模拟对象管理进行单元测试。
- en: Throughout this section, we delved into the functionalities and practical applications
    of Google Test (GTest) and Google Mock (GMock), essential tools for enhancing
    the testing framework and development workflow of C++ projects. GTest offers a
    robust environment for creating, managing, and executing unit tests, featuring
    test fixtures for shared setup and teardown routines, parameterized tests for
    varied input testing, and type-parameterized tests for applying the same tests
    across different data types. Its comprehensive assertion library ensures thorough
    validation of code behavior, contributing to the stability and durability of the
    software.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了 Google Test (GTest) 和 Google Mock (GMock) 的功能及其在 C++ 项目测试框架和开发工作流程中的应用。GTest
    提供了一个强大的环境，用于创建、管理和执行单元测试，包括用于共享设置和清理例程的测试固定装置，用于不同输入测试的参数化测试，以及用于在不同数据类型上应用相同测试的类型参数化测试。其全面的断言库确保了对代码行为的彻底验证，从而有助于提高软件的稳定性和耐用性。
- en: Complementing GTest, GMock allows for the seamless creation and utilization
    of mock objects, enabling isolated component testing by mimicking the behavior
    of dependencies. This is invaluable in complex systems where direct testing with
    real dependencies is either impractical or counterproductive. With GMock, developers
    gain access to a suite of features including automatic mock generation, versatile
    expectation settings, and detailed behavior verification, enabling in-depth testing
    of component interactions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 GTest 的补充，GMock 允许无缝创建和使用模拟对象，通过模拟依赖项的行为来实现隔离组件测试。这在复杂系统中非常有价值，因为直接使用真实依赖项进行测试要么不切实际，要么适得其反。使用
    GMock，开发者可以访问一系列功能，包括自动模拟生成、灵活的期望设置和详细的行为验证，从而实现组件交互的深入测试。
- en: By integrating GTest and GMock into the C++ development life cycle, developers
    can adopt a robust test-driven approach, ensuring code quality and facilitating
    continuous testing and integration practices, ultimately leading to more reliable
    and maintainable software projects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 GTest 和 GMock 集成到 C++ 开发生命周期中，开发者可以采用稳健的测试驱动方法，确保代码质量，并促进持续测试和集成实践，最终导致更可靠、更易于维护的软件项目。
- en: Other notable C++ unit testing frameworks
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他值得注意的 C++ 单元测试框架
- en: Beyond Google Test and Google Mock, the C++ ecosystem is rich with unit testing
    frameworks, each offering unique features and philosophies. These frameworks cater
    to various testing needs and preferences, providing developers with multiple options
    for integrating unit testing into their projects.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Google Test 和 Google Mock，C++ 生态系统还拥有丰富的单元测试框架，每个框架都提供独特的特性和哲学。这些框架满足各种测试需求和偏好，为开发者提供将单元测试集成到项目中的多种选择。
- en: Catch2
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Catch2
- en: Catch2 stands out for its simplicity and ease of use, requiring minimal boilerplate
    code to get started. It adopts a header-only distribution, making it straightforward
    to integrate into projects. Catch2 supports a variety of testing paradigms, including
    BDD-style test cases, and offers expressive assertion macros that enhance test
    readability and intent. Its standout feature is the “Sections” mechanism, which
    provides a natural way to share setup and teardown code among tests in a flexible
    and hierarchical manner.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Catch2以其简洁性和易用性而突出，启动时需要最少的样板代码。它采用头文件只读分发，使得将其集成到项目中变得简单。Catch2支持多种测试范式，包括BDD风格的测试用例，并提供增强测试可读性和意图的表达式断言宏。其突出特点是“部分”机制，它以灵活和分层的方式为测试之间的设置和清理代码提供了一种自然共享方式。
- en: Boost.Test
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost.Test
- en: Part of the extensive Boost libraries, Boost.Test offers robust support for
    unit testing in C++. It provides a comprehensive assertion framework, test organization
    facilities, and integration with the Boost build system. Boost.Test can be used
    in a header-only mode or compiled mode, offering flexibility in its deployment.
    It’s known for its detailed test result reports and wide range of built-in tools
    for test case management, making it suitable for both small and large-scale projects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Boost库的一部分，Boost.Test为C++的单元测试提供了稳健的支持。它提供了一个全面的断言框架、测试组织设施，并与Boost构建系统集成。Boost.Test可以以头文件只读模式或编译模式使用，提供了部署的灵活性。它以其详细的测试结果报告和广泛的内置测试用例管理工具而闻名，使其适用于小型和大型项目。
- en: Doctest
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Doctest
- en: Doctest is designed with a focus on simplicity and speed, positioning itself
    as the lightest feature-rich C++ testing framework. It’s particularly appealing
    for TDD due to its fast compile times. Inspired by Catch2, Doctest offers a similar
    syntax but aims to be more lightweight and faster to compile, making it ideal
    for including tests in everyday development without impacting build times significantly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest的设计重点是简单性和速度，定位为最轻量级的特性丰富C++测试框架。由于其快速的编译时间，它特别适合TDD。受到Catch2的启发，Doctest提供类似的语法，但旨在更轻量级和更快地编译，使其非常适合在日常开发中包含测试，而不会显著影响构建时间。
- en: Google Test versus Catch2 versus Boost.Test versus Doctest
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Test与Catch2与Boost.Test与Doctest的比较
- en: '**Simplicity**: Catch2 and Doctest excel in simplicity and ease of use, with
    Catch2 offering BDD-style syntax and Doctest being extremely lightweight'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：Catch2和Doctest在简单性和易用性方面表现出色，Catch2提供BDD风格的语法，而Doctest则非常轻量级'
- en: '**Integration**: Google Test and Boost.Test will provide more extensive integration
    capabilities, particularly suited for larger projects with complex testing needs'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：Google Test和Boost.Test将提供更广泛的集成功能，特别适合具有复杂测试需求的大型项目'
- en: '**Performance**: Doctest stands out for its compile-time and runtime performance,
    making it ideal for rapid development cycles'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：Doctest在编译时间和运行时性能方面突出，使其非常适合快速开发周期'
- en: '**Features**: Boost.Test and Google Test come with a more comprehensive set
    of features out of the box, including advanced test case management and detailed
    reporting'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特性**：Boost.Test和Google Test自带更全面的特性集，包括高级测试用例管理和详细报告'
- en: Choosing the right framework often comes down to project-specific requirements,
    developer preferences, and the desired balance between simplicity, performance,
    and feature richness. Developers are encouraged to explore these frameworks further
    to determine which best fits their unit testing needs, contributing to more reliable,
    maintainable, and high-quality C++ software.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的框架通常取决于项目特定的需求、开发者的偏好以及简单性、性能和特性丰富性之间的期望平衡。鼓励开发者进一步探索这些框架，以确定哪个最适合他们的单元测试需求，从而有助于构建更可靠、可维护和高质量的C++软件。
- en: Good candidates for unit tests
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适合单元测试的候选者
- en: 'Identifying the optimal candidates for unit testing is pivotal in establishing
    a robust testing strategy. Unit tests excel when applied to parts of the code
    base that are well-suited to isolation and fine-grained verification. Here are
    some key examples and recommendations:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 确定单元测试的最佳候选者对于建立稳健的测试策略至关重要。当应用于适合隔离和细粒度验证的代码库部分时，单元测试表现卓越。以下是一些关键示例和建议：
- en: Classes and functions with clear boundaries and well-defined responsibilities
    are prime candidates for unit testing. These components should ideally embody
    the Single Responsibility Principle, handling a specific aspect of the application’s
    functionality. Testing these isolated units allows for precise verification of
    their behavior, ensuring that they perform their intended tasks correctly under
    various conditions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 边界清晰且职责定义明确的类和函数是单元测试的理想候选者。这些组件理想情况下应体现单一职责原则，处理应用程序功能的一个特定方面。测试这些隔离的单元可以精确验证其行为，确保它们在各种条件下正确执行其预期任务。
- en: Pure functions, which depend solely on their input parameters and produce no
    side effects, are excellent targets for unit tests. Their deterministic nature
    – where a given input always results in the same output – makes them straightforward
    to test and verify. Pure functions are often found in utility libraries, mathematical
    computations, and data transformation operations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于其输入参数且不产生任何副作用的无副效应函数是单元测试的绝佳目标。它们的确定性——即给定的输入总是产生相同的输出——使得它们易于测试和验证。无副效应函数通常出现在实用库、数学计算和数据转换操作中。
- en: Components that interact with dependencies through well-defined interfaces are
    easier to test, especially when those dependencies can be easily mocked or stubbed.
    This facilitates testing the component in isolation, focusing on its logic rather
    than the implementation details of its dependencies.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义良好的接口与依赖项交互的组件更容易进行测试，尤其是当这些依赖项可以轻松模拟或存根时。这有助于在隔离的情况下测试组件，专注于其逻辑而不是其依赖项的实现细节。
- en: The business logic layer, which encapsulates the core functionality and rules
    of the application, is typically well-suited for unit testing. This layer often
    involves calculations, data processing, and decision-making that can be tested
    in isolation from the user interface and external systems.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 封装应用程序核心功能和规则的业务逻辑层通常非常适合单元测试。这一层通常涉及计算、数据处理和决策，这些可以在与用户界面和外部系统隔离的情况下进行测试。
- en: While many aspects of an application are suitable for unit testing, it’s prudent
    to recognize scenarios that pose challenges. Components that require complex interactions
    with external resources, such as databases, filesystems, and network services,
    might be difficult to effectively mock or might lead to flaky tests due to their
    reliance on external state or behavior. While mocking can simulate some of these
    interactions, the complexity and overhead might not always justify the effort
    in the context of unit testing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用程序的许多方面都适合进行单元测试，但认识到具有挑战性的场景是明智的。需要与数据库、文件系统、网络服务等外部资源进行复杂交互的组件可能难以有效地模拟，或者可能由于对外部状态或行为的依赖而导致测试不稳定。虽然模拟可以模拟这些交互的一部分，但复杂性和开销可能并不总是证明在单元测试的背景下付出努力是合理的。
- en: Although unit tests are invaluable for verifying individual components, they
    have their limitations, especially concerning integrations and end-to-end interactions.
    For code that is inherently difficult to isolate or requires complex external
    interactions, **end-to-end** (**E2E**) tests become crucial. E2E tests simulate
    real-world usage scenarios, covering the flow from the user interface through
    to the backend systems and external integrations. In the next section, we will
    delve into E2E testing, exploring its role in complementing unit tests and providing
    comprehensive coverage of the application’s functionality.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单元测试对于验证单个组件非常有价值，但它们也有其局限性，尤其是在集成和端到端交互方面。对于本质难以隔离或需要复杂外部交互的代码，**端到端**（**E2E**）测试变得至关重要。端到端测试模拟真实世界的使用场景，涵盖了从用户界面到后端系统和外部集成的流程。在下一节中，我们将深入探讨端到端测试，探讨其在补充单元测试和提供应用程序功能全面覆盖方面的作用。
- en: E2E testing in software development
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件开发中的端到端测试
- en: E2E testing is a comprehensive testing approach that evaluates the application’s
    functionality and performance from start to finish. Unlike unit testing, which
    isolates and tests individual components or units of code, E2E testing examines
    the application as an integrated whole, simulating real-world user scenarios.
    This method ensures that all the various components of the application, including
    its interfaces, databases, networks, and other services, work harmoniously to
    deliver the desired user experience.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: E2E 测试是一种全面的测试方法，它从开始到结束评估应用程序的功能和性能。与单元测试不同，单元测试是隔离和测试单个组件或代码单元，E2E 测试则将应用程序作为一个整体进行考察，模拟现实世界的用户场景。这种方法确保了应用程序的所有各种组件，包括其接口、数据库、网络和其他服务，能够和谐地工作，以提供预期的用户体验。
- en: E2E testing frameworks
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: E2E 测试框架
- en: 'Given that E2E testing often involves interacting with the application from
    the outside, it’s not confined to the language in which the application is written.
    For C++ applications, which might be part of a larger ecosystem or serve as backend
    systems, E2E testing can be conducted using a variety of frameworks across different
    languages. Some popular E2E testing frameworks include the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 E2E 测试通常涉及从外部与应用程序交互，它并不局限于应用程序所使用的语言。对于可能是更大生态系统的一部分或作为后端系统的 C++ 应用程序，可以使用不同语言的多种框架进行
    E2E 测试。以下是一些流行的 E2E 测试框架：
- en: '**Selenium**: Predominantly used for web applications, Selenium can automate
    browsers to simulate user interactions with web interfaces, making it a versatile
    tool for E2E testing'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Selenium**：主要用于 Web 应用程序，Selenium 可以自动化浏览器来模拟用户与 Web 界面的交互，使其成为 E2E 测试的多功能工具'
- en: '**Cypress**: Another powerful tool for web applications, Cypress offers a more
    modern and developer-friendly approach to E2E testing with rich debugging capabilities
    and a robust API'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cypress**：另一个强大的 Web 应用程序工具，Cypress 提供了一种更现代、更友好的 E2E 测试方法，具有丰富的调试功能和强大的
    API'
- en: '**Postman**: For applications exposing RESTful APIs, Postman allows comprehensive
    API testing, ensuring that the application’s endpoints perform as expected under
    various conditions'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Postman**：对于暴露 RESTful API 的应用程序，Postman 允许进行全面的 API 测试，确保应用程序的端点在各种条件下都能按预期执行'
- en: When to use E2E testing
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用 E2E 测试
- en: 'E2E testing is particularly valuable in scenarios where the application’s components
    must interact in complex workflows, often involving multiple systems and external
    dependencies. It’s crucial for the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的组件必须以复杂的工作流程进行交互的场景中，E2E 测试尤其有价值，这通常涉及多个系统和外部依赖。对于以下方面至关重要：
- en: '**Testing complex user workflows**: E2E testing shines in validating user journeys
    that span multiple application components, ensuring a seamless experience from
    the user’s perspective'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试复杂的用户工作流程**：E2E 测试在验证跨越多个应用程序组件的用户旅程方面表现出色，确保从用户的角度来看体验无缝'
- en: '**Integration scenarios**: When the application interacts with external systems
    or services, E2E testing verifies that these integrations work as intended, catching
    issues that might not be evident in isolation'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成场景**：当应用程序与外部系统或服务交互时，E2E 测试验证这些集成是否按预期工作，捕捉到在隔离情况下可能不明显的问题'
- en: '**Critical path testing**: For features and pathways that are critical to the
    application’s core functionality, E2E testing ensures reliability and performance
    under realistic usage conditions'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键路径测试**：对于对应用程序核心功能至关重要的功能和路径，E2E 测试确保在现实使用条件下可靠性和性能'
- en: Situations favoring E2E testing
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适合进行 E2E 测试的情况
- en: Complex interactions
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂交互
- en: 'In situations where the application’s components engage in intricate interactions,
    possibly spanning different technologies and platforms, unit tests might fall
    short. E2E testing is indispensable for ensuring that the collective behavior
    of these components aligns with the expected outcomes, especially in:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的组件进行复杂交互的情况下，可能跨越不同的技术和平台，单元测试可能不足以满足需求。E2E 测试对于确保这些组件的集体行为与预期结果一致至关重要，尤其是在以下情况下：
- en: The architecture outlined in the diagram represents a typical web application
    with several interconnected services, each serving a distinct role in the system.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中概述的架构代表了一个典型的 Web 应用程序，其中包含几个相互连接的服务，每个服务在系统中都扮演着独特的角色。
- en: '![Figure 12.1 – E2E testing](img/B19606_12_1.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – E2E 测试](img/B19606_12_1.jpg)'
- en: Figure 12.1 – E2E testing
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – E2E 测试
- en: At the frontend, there’s a **user UI**, which is the graphical interface where
    users interact with the application. It’s designed to send and receive data to
    and from the backend services through an **API gateway**. The API gateway acts
    as an intermediary that routes requests from the user UI to the appropriate backend
    services and aggregates responses to send back to the UI.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端，有一个**用户界面（UI**），这是用户与应用程序交互的图形界面。它设计用来通过**API网关**向和从后端服务发送和接收数据。API网关充当一个中介，将用户UI的请求路由到适当的后端服务，并将响应聚合后发送回UI。
- en: 'Several backend services are illustrated:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 几个后端服务如下所示：
- en: '**Account management**: This service handles user accounts, including authentication,
    profile management, and other user-related data'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**账户管理**：这项服务处理用户账户，包括身份验证、资料管理以及其他与用户相关的数据。'
- en: '**Billing**: Responsible for managing billing information, subscriptions, and
    invoicing'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计费**：负责管理计费信息、订阅和发票。'
- en: '**Payments**: Processes financial transactions, such as credit card processing
    or interfacing with payment gateways'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支付**：处理金融交易，例如信用卡处理或与支付网关接口。'
- en: '**Notifications**: Sends out alerts or messages to users, likely triggered
    by certain events in the account management or billing services'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知**：向用户发送警报或消息，可能由账户管理或计费服务中的某些事件触发。'
- en: External services, possibly third-party applications or data providers, can
    also interact with the API gateway, providing additional functionality or data
    that supports the main application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 外部服务，可能是第三方应用程序或数据提供者，也可以与API网关交互，提供支持主应用程序的附加功能或数据。
- en: For E2E testing of this system, tests would simulate user actions on the user
    UI, such as signing up for an account or making a payment. The tests would then
    verify that the UI correctly sends the appropriate requests through the API gateway
    to the backend services. Subsequently, the tests would confirm that the user UI
    responds correctly to the data received from the backend, ensuring that the entire
    workflow, from the user UI down to notifications, operates as expected. This comprehensive
    testing approach ensures that each component functions individually and in concert
    with the rest of the system, delivering a seamless experience for the user.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该系统的端到端测试，测试将模拟用户在用户UI上的操作，例如注册账户或进行支付。然后，测试将验证UI是否正确通过API网关向后端服务发送适当的请求。随后，测试将确认用户UI对从后端接收的数据做出正确响应，确保从用户UI到通知的整个工作流程按预期运行。这种全面的测试方法确保每个组件单独以及与系统其他部分协同工作，为用户提供无缝体验。
- en: 'To summarize, it is essential to consider E2E testing in scenarios where the
    application’s components engage in complex interactions, especially when these
    interactions span different technologies and platforms. E2E testing ensures that
    the collective behavior of these components aligns with the expected outcomes,
    providing a comprehensive assessment of the application’s functionality and performance.
    Here are some of the most common cases when E2E is beneficial:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在应用程序的组件进行复杂交互的场景中，尤其是在这些交互跨越不同技术和平台时，考虑端到端测试是至关重要的。端到端测试确保这些组件的整体行为与预期结果一致，从而对应用程序的功能和性能进行全面评估。以下是一些端到端测试有益的常见情况：
- en: '**Multi-layered applications**: Applications with multiple layers or tiers,
    such as client-server architectures, benefit from E2E testing to ensure the layers
    communicate effectively'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多层应用**：具有多个层或级别的应用，例如客户端-服务器架构，通过端到端测试（E2E testing）可以确保各层之间有效沟通。'
- en: '**Distributed systems**: For applications spread across different environments
    or services, E2E testing can validate the data flow and functionality across these
    distributed components'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式系统**：对于分布在不同环境或服务中的应用程序，端到端测试可以验证这些分布式组件之间的数据流和功能。'
- en: Real-world environment testing
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实环境测试
- en: 'One of the primary advantages of E2E testing is its ability to replicate the
    conditions close to the production environment. This includes testing the application
    on actual hardware, interacting with real databases, and navigating through the
    genuine network infrastructure. This level of testing is crucial for the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的主要优势之一是它能够复制接近生产环境的条件。这包括在实际硬件上测试应用程序，与真实数据库交互，并通过真正的网络基础设施导航。这种测试级别对于以下方面至关重要：
- en: '**Performance validation**: Ensuring that the application performs optimally
    under expected load conditions and user traffic'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能验证**：确保应用程序在预期的负载条件和用户流量下表现最优'
- en: '**Security assurance**: Verifying that the application’s security measures
    are effective in a realistic environment, protecting against potential vulnerabilities'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全保证**：验证应用程序的安全措施在现实环境中是否有效，以防止潜在的安全漏洞'
- en: E2E testing serves as the final checkpoint before software release, offering
    a comprehensive assessment of the application’s readiness for deployment. By simulating
    real-world scenarios, E2E testing ensures that the application not only meets
    its technical specifications but also delivers a reliable and user-friendly experience,
    making it an essential component of the software development life cycle.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试（E2E testing）作为软件发布前的最终检查点，提供对应用程序部署准备情况的全面评估。通过模拟真实世界场景，端到端测试确保应用程序不仅满足其技术规范，而且提供可靠且用户友好的体验，使其成为软件开发生命周期的一个基本组成部分。
- en: Automatic test coverage tracking tools
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动测试覆盖率跟踪工具
- en: In the quest to ensure comprehensive testing of software projects, automatic
    test coverage tracking tools play a pivotal role. These tools provide invaluable
    insights into the extent to which the source code of an application is executed
    during testing, highlighting areas that are well-tested and those that may need
    additional attention.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保软件项目全面测试的探索中，自动测试覆盖率跟踪工具扮演着关键角色。这些工具提供了宝贵的见解，了解应用程序源代码在测试期间执行的程度，突出了测试良好的区域以及可能需要额外注意的区域。
- en: Automatic test coverage tracking tools with examples
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动测试覆盖率跟踪工具及示例
- en: Ensuring comprehensive test coverage is a cornerstone of reliable software development.
    Tools such as `gcov` for the `llvm-cov` for LLVM projects automate the tracking
    of test coverage, providing crucial insights into how thoroughly the tests exercise
    the code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 确保全面的测试覆盖率是可靠软件开发的基础。例如，`gcov` 和 `llvm-cov` 等工具自动化了测试覆盖率的跟踪，提供了关于测试如何彻底执行代码的关键见解。
- en: Tool overview with examples
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具概述及示例
- en: 'There are two major tools used for automatic test coverage tracking in C++
    projects:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 项目中用于自动测试覆盖率跟踪的两个主要工具：
- en: '`gcov` analyzes the execution paths taken in your code during test runs. For
    instance, after compiling a C++ `example.cpp` file with `g++ -fprofile-arcs -ftest-coverage
    example.cpp`, running the corresponding test suite generates coverage data. Running
    `gcov example.cpp` afterward produces a report detailing the number of times each
    line of code was executed.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcov` 分析在测试运行期间代码中采取的执行路径。例如，使用 `g++ -fprofile-arcs -ftest-coverage example.cpp`
    编译 C++ `example.cpp` 文件后，运行相应的测试套件会生成覆盖率数据。随后运行 `gcov example.cpp` 会生成一份报告，详细说明每行代码被执行的次数。'
- en: '`llvm-cov` works with Clang to offer detailed coverage reports. Compiling with
    `clang++ -fprofile-instr-generate -fcoverage-mapping example.cpp` and then executing
    the test binary with `LLVM_PROFILE_FILE=”example.profraw” ./example` prepares
    the coverage data. `llvm-profdata merge -sparse example.profraw -o example.profdata`
    followed by `llvm-cov show ./example -instr-profile=example.profdata` generates
    a coverage report for `example.cpp`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm-cov` 与 Clang 合作提供详细的覆盖率报告。使用 `clang++ -fprofile-instr-generate -fcoverage-mapping
    example.cpp` 进行编译，然后使用 `LLVM_PROFILE_FILE="example.profraw" ./example` 执行测试二进制文件以准备覆盖率数据。接着使用
    `llvm-profdata merge -sparse example.profraw -o example.profdata`，然后使用 `llvm-cov
    show ./example -instr-profile=example.profdata` 为 `example.cpp` 生成覆盖率报告。'
- en: Integration with C++ projects
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 C++ 项目集成
- en: Integrating these tools into C++ projects involves compiling the source with
    coverage flags, executing the tests to generate coverage data, and then analyzing
    this data to produce reports.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些工具集成到 C++ 项目中涉及使用覆盖率标志编译源代码，执行测试以生成覆盖率数据，然后分析这些数据以生成报告。
- en: 'For a project with multiple files, you might compile with the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含多个文件的工程，你可能需要使用以下方式进行编译：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After running `./testExecutable` to execute your tests, use `gcov file1.cpp
    file2.cpp` to generate coverage reports for each source file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `./testExecutable` 执行测试后，使用 `gcov file1.cpp file2.cpp` 为每个源文件生成覆盖率报告。
- en: With `llvm-cov`, the process is similar but tailored for Clang. After compilation
    and test execution, merging profile data with `llvm-profdata` and generating the
    report with `llvm-cov` provides a comprehensive view of test coverage.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `llvm-cov`，过程类似，但针对 Clang 进行了优化。在编译和测试执行后，使用 `llvm-profdata` 合并配置文件数据，并用
    `llvm-cov` 生成报告，可以提供一个全面的测试覆盖率视图。
- en: Interpreting coverage reports
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释覆盖率报告
- en: 'The coverage reports generated by these tools offer several metrics:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具生成的覆盖率报告提供了几个指标：
- en: '`gcov` report might state `Lines executed:90.00% of 100`, meaning 90 out of
    100 lines were run during tests.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcov` 报告可能声明 `Lines executed:90.00% of 100`，意味着在测试中运行了 90 行中的 100 行。'
- en: '`gcov` report such as `Branches executed:85.00% of 40` shows that 85% of all
    branches were tested.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcov` 报告如 `Branches executed:85.00% of 40` 显示了 85% 的所有分支都被测试了。'
- en: '`Functions executed:95.00% of 20` in a `gcov` report indicates that 95% of
    functions were invoked during testing.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcov` 报告中的 `Functions executed:95.00% of 20` 指示在测试中调用了 95% 的函数。'
- en: 'For example, a simplified `gcov` report might look like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，简化的 `gcov` 报告可能看起来像这样：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Similarly, an `llvm-cov` report provides detailed coverage metrics, along with
    the specific lines and branches covered, enhancing the ability to pinpoint areas
    needing additional tests.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`llvm-cov` 报告提供了详细的覆盖率指标，包括具体的行和分支覆盖情况，增强了定位需要额外测试区域的能力。
- en: These reports guide developers in improving test coverage by highlighting untested
    code paths and functions, but they should not be the sole metric for test quality.
    High coverage with poorly designed tests can give a false sense of security. Effective
    use of these tools involves not just aiming for high coverage percentages but
    also ensuring that tests are meaningful and reflective of real-world usage scenarios.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些报告通过突出未测试的代码路径和函数，指导开发者提高测试覆盖率，但它们不应是测试质量的唯一指标。高覆盖率但设计不佳的测试可能会给人一种虚假的安全感。有效使用这些工具不仅需要追求高覆盖率百分比，还需要确保测试是有意义且反映真实世界使用场景的。
- en: Utilizing hit maps for enhanced test coverage analysis
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用命中图进行增强的测试覆盖率分析
- en: Hit maps, produced by test coverage tracking tools such as `gcov` and `llvm-cov`,
    offer a granular view of how tests exercise the code, serving as a detailed guide
    for developers aiming to improve test coverage. These hit maps go beyond simple
    percentage metrics, showing precisely which lines of code were executed during
    tests and how many times, thus enabling a more informed approach to enhance test
    suites.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `gcov` 和 `llvm-cov` 等测试覆盖率跟踪工具生成的命中图，提供了对测试如何执行代码的细粒度视图，为旨在提高测试覆盖率的开发者提供了详细的指南。这些命中图超越了简单的百分比指标，精确地显示了测试期间执行了哪些代码行以及执行了多少次，从而使得增强测试套件的方法更加明智。
- en: Understanding hit maps
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解命中图
- en: A hit map is essentially a detailed annotation of the source code, with each
    line accompanied by execution counts indicating how many times tests have run
    that particular line. This level of detail helps identify not only untested parts
    of the code but also areas that might be over-tested or need more varied testing
    scenarios.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 命中图本质上是对源代码的详细注释，每行都伴随着执行次数，表明测试运行了该特定行的次数。这种详细程度有助于识别代码中未测试的部分，以及可能过度测试或需要更多测试场景的区域。
- en: The `.gcov` files generated by `gcov` and the annotated source code produced
    by `llvm-cov` provide these hit maps, offering a clear picture of test coverage
    at the line level.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `gcov` 生成的 `.gcov` 文件和由 `llvm-cov` 生成的带注释的源代码提供了这些命中图，清晰地展示了行级别的测试覆盖率。
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, line 3 (`bool condition = checkCondition();`) was executed
    twice, while the `performAction();` line within the `if` statement was executed
    once, indicating that the condition was `true` in one of the test runs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第 3 行 (`bool condition = checkCondition();`) 执行了两次，而 `if` 语句内的 `performAction();`
    行只执行了一次，表明在某个测试运行中条件为 `true`。
- en: Similar to `gcov`, after compiling with `clang++` using the `-fprofile-instr-generate
    -fcoverage-mapping` flags and executing the tests, `llvm-cov` can produce a hit
    map using the `llvm-cov show` command with the `-instr-profile` flag pointing
    to the generated profile data. For example, `llvm-cov show ./example -instr-profile=example.profdata
    example.cpp` outputs the annotated source code with execution counts.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `gcov` 类似，在用 `-fprofile-instr-generate -fcoverage-mapping` 标志编译 `clang++`
    并执行测试后，`llvm-cov` 可以使用带有 `-instr-profile` 标志的 `llvm-cov show` 命令生成命中图，指向生成的配置文件数据。例如，`llvm-cov
    show ./example -instr-profile=example.profdata example.cpp` 输出带有执行次数的带注释的源代码。
- en: 'The output would resemble the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the execution count is prefixed to each line, providing a clear picture
    of test coverage at a glance.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，执行次数作为每行的前缀，提供了一目了然地测试覆盖率图。
- en: Leveraging hit maps for test improvement
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用命中图进行测试改进
- en: By examining hit maps, developers can identify code sections that are not covered
    by any test case, indicated by execution counts of zero. These areas represent
    potential risks for undetected bugs and should be prioritized for additional testing.
    Conversely, lines with exceptionally high execution counts might indicate areas
    where tests are redundant or overly focused, suggesting an opportunity to diversify
    test scenarios or refocus testing efforts on less-covered parts of the code base.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查击中图，开发者可以识别出没有任何测试用例覆盖的代码部分，这由零执行次数指示。这些区域代表未检测到的潜在风险，应优先考虑进行额外的测试。相反，执行次数异常高的行可能表明测试是冗余的或过度集中的，这表明有机会多样化测试场景或重新聚焦测试努力，以覆盖代码库中覆盖较少的部分。
- en: Incorporating hit map analysis into regular development workflows encourages
    a proactive approach to maintaining and enhancing test coverage, ensuring that
    tests remain effective and aligned with the evolving code base. As with all testing
    strategies, the goal is not merely to achieve high coverage numbers but to ensure
    that the test suite comprehensively validates the software’s functionality and
    reliability in a variety of scenarios.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将击中图分析纳入常规开发工作流程鼓励了一种积极主动的方法来维护和增强测试覆盖率，确保测试保持有效并与不断发展的代码库保持一致。与所有测试策略一样，目标不仅仅是实现高覆盖率数字，而是确保测试套件在各种场景下全面验证软件的功能性和可靠性。
- en: Incorporating hit maps into the development workflow has been made even more
    accessible with the advent of **integrated development environment** (**IDE**)
    plugins that integrate coverage visualization directly into the coding environment.
    A notable example is the “Code Coverage” plugin by Markis Taylor for **Visual
    Studio Code** (**VSCode**). This plugin overlays hit maps onto the source code
    within the VSCode editor, providing immediate, visual feedback on test coverage.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将击中图（hit maps）集成到开发工作流程中，随着集成开发环境（**IDE**）插件的推出变得更加容易，这些插件将覆盖率可视化直接集成到编码环境中。一个显著的例子是Markis
    Taylor为**Visual Studio Code**（**VSCode**）开发的“Code Coverage”插件。此插件将击中图叠加到VSCode编辑器中的源代码上，提供关于测试覆盖率的即时视觉反馈。
- en: The “Code Coverage” plugin processes coverage reports generated by tools such
    as `gcov` or `llvm-cov` and visually annotates the source code in VSCode. Lines
    of code covered by tests are highlighted, typically in green, while uncovered
    lines are marked in red. This immediate visual representation allows developers
    to quickly identify untested code regions without leaving the editor or navigating
    through external coverage reports.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: “Code Coverage”插件处理由`gcov`或`llvm-cov`等工具生成的覆盖率报告，并在VSCode中可视化地注释源代码。被测试覆盖的代码行通常以绿色突出显示，而未覆盖的行则以红色标记。这种即时的视觉表示允许开发者快速识别未测试的代码区域，而无需离开编辑器或通过外部覆盖率报告进行导航。
- en: Recommendations for code coverage
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率建议
- en: Code coverage is a vital metric in the realm of software testing, providing
    insights into the extent to which the code base is exercised by the test suite.
    For C++ projects, leveraging tools such as `gcov` for GCC and `llvm-cov` for LLVM
    projects can offer detailed coverage analysis. These tools are adept at not only
    tracking coverage from unit tests but also from E2E tests, allowing for a comprehensive
    assessment of test coverage across different testing levels.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是软件测试领域的一个关键指标，它提供了关于测试套件对代码库执行程度的见解。对于C++项目，利用`gcov`（用于GCC）和`llvm-cov`（用于LLVM项目）等工具可以提供详细的覆盖率分析。这些工具不仅擅长跟踪单元测试的覆盖率，还擅长跟踪端到端测试的覆盖率，从而允许对不同测试级别的测试覆盖率进行全面评估。
- en: A robust testing strategy involves a combination of focused unit tests, which
    validate individual components in isolation, and broader E2E tests, which assess
    the system’s functionality as a whole. By employing `gcov` or `llvm-cov`, teams
    can aggregate coverage data from both testing types, providing a holistic view
    of the project’s test coverage. This combined approach helps identify areas of
    the code that are either under-tested or not tested at all, guiding efforts to
    enhance the test suite’s effectiveness.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稳健的测试策略涉及集中单元测试的组合，这些测试在隔离的情况下验证单个组件，以及更广泛的端到端（E2E）测试，这些测试评估系统的整体功能。通过使用`gcov`或`llvm-cov`，团队可以聚合这两种测试类型的覆盖率数据，提供项目测试覆盖率的整体视图。这种结合的方法有助于识别代码中测试不足或根本未测试的区域，指导努力提高测试套件的有效性。
- en: It is recommended to keep a vigilant eye on code coverage metrics and strive
    to prevent any decrease in coverage percentages. A decline in coverage might indicate
    new code being added without adequate testing, potentially introducing undetected
    bugs into the system. To mitigate this risk, teams should integrate coverage checks
    into their **continuous integration** (**CI**) pipelines, ensuring that any changes
    that reduce coverage are promptly identified and addressed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 建议密切关注代码覆盖率指标，并努力防止覆盖率百分比下降。覆盖率下降可能表明添加了新代码但没有进行充分的测试，可能会将未检测到的错误引入系统中。为了减轻这种风险，团队应将覆盖率检查集成到他们的**持续集成**（**CI**）管道中，确保任何减少覆盖率的更改都能及时识别并解决。
- en: Periodically, it’s beneficial to allocate time specifically for increasing test
    coverage, especially in areas identified as critical or risky. This might involve
    writing additional tests for complex logic, edge cases, or error-handling paths
    that were previously overlooked. Investing in coverage improvement initiatives
    not only enhances the software’s reliability but also contributes to a more maintainable
    and robust code base in the long term.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 定期分配时间专门用于增加测试覆盖率是有益的，尤其是在被识别为关键或风险区域。这可能涉及为复杂的逻辑、边缘情况或之前被忽视的错误处理路径编写额外的测试。投资于覆盖率改进措施不仅提高了软件的可靠性，而且从长远来看有助于创建更易于维护和健壮的代码库。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a thorough overview of testing in C++, covering essential
    topics from unit testing basics to advanced E2E testing. You learned about unit
    testing’s role in ensuring individual components work correctly and how tools
    such as Google Test and Google Mock help write and manage these tests effectively.
    The chapter also touched on mocking techniques for simulating complex behaviors
    in tests.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全面概述了C++中的测试，涵盖了从单元测试基础到高级端到端测试的必要主题。你了解了单元测试在确保各个组件正确工作中的作用，以及像Google Test和Google
    Mock这样的工具如何帮助有效地编写和管理这些测试。本章还简要介绍了测试中模拟复杂行为的模拟技术。
- en: Additionally, the importance of tracking test coverage using tools such as `gcov`
    and `llvm-cov` was discussed, emphasizing the need to maintain and improve coverage
    over time. E2E testing was highlighted as crucial for checking the entire application’s
    functionality, complementing the more focused unit tests.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，讨论了使用`gcov`和`llvm-cov`等工具跟踪测试覆盖率的重要性，强调了随着时间的推移保持和改进覆盖率的需求。端到端测试被强调为检查整个应用程序功能的关键，它补充了更专注的单元测试。
- en: By exploring different C++ testing frameworks, the chapter offered insights
    into the various tools available for developers, helping them choose the right
    ones for their projects. In essence, this chapter equipped you with the knowledge
    to implement comprehensive and effective testing strategies in your C++ development
    endeavors, contributing to the creation of reliable and robust software.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索不同的C++测试框架，本章为开发者提供了各种工具的见解，帮助他们为项目选择正确的工具。本质上，本章为你提供了在C++开发中实施全面和有效测试策略的知识，有助于创建可靠和健壮的软件。
- en: In the next chapter, we will explore modern approaches to third-party management
    in C++, including Docker-based solutions and available package managers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨C++中第三方管理的现代方法，包括基于Docker的解决方案和可用的包管理器。
