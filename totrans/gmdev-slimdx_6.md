# 第六章 接下来去哪里

我们现在终于到达了这段旅程的终点，但关于游戏编程的学习还有很多。在这个过程中，我们学习了如何开始构建一个游戏开发框架，以便在未来继续构建，使用 DirectInput 和 XInput 处理用户输入，使用 Direct2D 渲染 2D 图形和基于瓦片的宇宙，使用 DirectSound 和 XAudio2 为我们的游戏世界添加声音和音乐，最后，如何使用 Direct3D 进行基本的 3D 图形渲染。因此，在本章中，我们将探讨如何继续扩展你的游戏开发知识，以及一些我们在本书中简要介绍的一些重要主题，以及一些我们没有涉及的主题。

在本章中，我们将涵盖以下主题：

+   裁剪

+   碰撞检测

+   人工智能

+   物理学

+   多线程编程

+   游戏设计

+   进一步阅读

# 剔除和裁剪

在我们构建*Cube*演示时，我们在上一章中简要讨论了这一概念。在 2D 术语中，**剔除**意味着移除或跳过屏幕边界之外的对象，而不是浪费时间绘制那些无论如何都不可见的东西。在 3D 术语中，意义大致相同，但由于需要处理第三个维度，所以显然要复杂一些。

**裁剪**是指移除游戏对象中那些在屏幕上无法完全看到的三角形部分。屏幕外的三角形部分会被移除。Direct3D 在我们的图形管道中为我们处理裁剪，但剔除则留给了我们。剔除是指移除或跳过场景中那些不需要绘制、当前不可见的整个对象。尽管 Direct3D 可以为我们处理背面剔除。这是移除面向相机的三角形背面。由于我们看不到它，因此不需要绘制它。

剔除和裁剪在大多数现代视频游戏中都被使用。这是一个非常重要的概念，因为它可以给你带来显著的性能提升。你的游戏世界中对象越多，计算机循环遍历并绘制每一个对象所需的时间就越长。因此，裁剪可以节省很多时间。

虽然这不是限制每帧绘制内容的唯一方法。许多游戏中使用了其他方法来确保对象不会被不必要地绘制。例如，如果玩家和对象之间有一堵墙或其他障碍物，我们不需要绘制那个对象，因为玩家无论如何都看不到它（除非，当然，有一个窗户或类似的东西）。这有点棘手。关键是，就像大多数事情一样，完成这项工作有不止一种方法。

# 碰撞检测

**碰撞检测**正如其名；检测游戏世界中对象的碰撞。在二维空间中，由于一切通常都具有简单的方形**边界框**，所以相对容易。边界框是围绕对象的一个想象中的形状，我们用它来检测碰撞。你只需测试两个对象的边界框是否相交，如果是的话，你就知道它们已经发生了碰撞。当然，它们对玩家来说是不可见的，因为我们从未在屏幕上绘制我们的边界框。然而，为调试目的添加代码以让你看到边界框可能很有用，并验证它们是否按预期工作。另一个好主意是在你的游戏中添加一个开发者控制台，就像在许多第一人称射击游戏中看到的那样，例如*半条命 2*。

在三维空间中，事情变得更加复杂。你可以使用各种类型的边界框。常用的有立方体或球形边界框。立方体不一定需要是完美的立方体。它们可以是任何大小，或者宽度比高度长，例如。球形边界框通常是一个围绕对象的完美球体，但如果对象的高度比宽度大，它也可能是细长的。球形边界框的行为也略有不同，因为你不会有两个边界框的角仅仅相交的情况，因为球体没有像立方体那样的角。当然，你也可以在二维中使用不同类型的边界框。

# 人工智能

**人工智能**（**AI**）指的是我们编码到游戏世界中生物的智能。这本质上是指控制生物行为的代码。这段代码的智能程度决定了我们的生物的智能程度。当然，这个概念也与**路径查找**紧密相关。路径查找是寻找一条路径，使生物能够到达其目标位置的过程。一种路径查找算法是`A*`算法（见[`en.wikipedia.org/wiki/A*_search_algorithm`](http://en.wikipedia.org/wiki/A*_search_algorithm)）。

当然，我们不能根据世界的几何形状来处理这个问题。这会太复杂，也太耗时。一种方法是用**航点**。航点本质上是在世界中的战略位置散布的标记。例如，几条路径的交汇处将是一个很好的航点位置。路径查找代码简单地找到生物当前位置最近的航点，然后从那里找到从航点到航点的路径，使其到达期望的目的地。这显然比尝试根据世界的实际几何形状计算路径要简单得多。

# 物理

物理与碰撞检测紧密相关，因为碰撞检测是游戏物理的核心。如果两个物体发生碰撞，我们需要检测这一点，以便让它们表现得更加真实。如果它们在碰撞时都突然停下来，或者像幽灵一样继续前进，看起来会很愚蠢。

物理学是一个非常复杂的学科，并且高度依赖于数学。它本质上只是使用数学来计算我们游戏世界中物体的运动。当然，如果你想达到不同的效果，你可以稍微调整一下你的物理设置。例如，如果你的游戏有一个卡通风格的世界而不是一个真实世界，你的物理可能就会有所不同。

我们在上一节中提到的边界框通常位于游戏的物理系统中，因为它们在那里被使用。游戏中的物理系统通常负责模拟游戏世界中物体的物理。通常也会给物体一个*睡眠*状态或*空闲*状态，通常被称为。当物体处于这种状态时，物理系统会忽略该物体，不会对其进行任何物理模拟。这允许你在需要之前关闭特定物体的物理，这样可以带来巨大的性能提升，因为物理，充满了数学，可能运行起来相对较慢。当你有更多处于这种状态的物体时（因为它们本来就没有移动或做任何事情），性能提升会更大，因此，你实际上是在有效地节省物理系统进行大量不必要的计算。毕竟，对一个不移动或不做任何事情的对象运行物理代码是浪费时间的。

# 多线程编程

通常，一个程序只有一个执行线程。线程基本上是正在由具有多核处理器的系统中的一个核心运行的代码。大多数现代处理器都有这个特性，尽管应该注意的是，即使在单核 CPU 上也可以有多个线程。我想包括这个主题，因为多线程在处理密集型应用，如视频游戏，中非常有用。

基本上，多线程允许你在应用程序中同时运行多个执行点。例如，你可以有一个线程执行一些后台工作，比如在一个类似《我的世界》的大型世界中加载资源（图形和声音）。随着玩家的移动，游戏需要加载世界的下一部分，并卸载那些现在离玩家太远的部分。因此，你可以有一个线程在玩家在世界中移动时处理加载新的世界块，而主线程则继续运行游戏代码。

当然，你也不必局限于仅仅两个线程。应用程序通常创建一组线程并将任务分配给它们。如果有许多任务需要完成，这会很有用。你只需创建一个线程管理器类，并传入你将调用的函数来完成需要完成的任务。线程管理器会查看其线程（统称为**线程池**），并找到空闲的那个。如果它找到一个空闲的**工作线程**，它将通过运行你传入的函数来启动它。工作线程只是线程池中的一个线程，它之所以得名是因为它为我们做各种工作。

同时运行多个代码片段显然可以带来显著的性能优势。然而，多线程编程也是一个相当棘手的话题。你必须确保不要有两个线程同时访问相同的数据，因为这可能会引起大问题。

# 游戏设计

游戏设计可能看起来相当简单，但其中包含的远比大多数人最初想象的要多。游戏设计包括决定图形的风格、世界将是什么样子、氛围、设计游戏的主要游戏玩法机制、玩家的整体目标以及基本的故事想法。当然，通常会有图形和声音艺术家来完成游戏图形和声音的实际工作。但图形和声音的风格首先需要在游戏设计中指定，否则艺术家不知道要创建什么样的图形和声音。

游戏可能最关键的一点是它很有趣。如果不好玩，玩家就不会玩。然而，这并不那么简单，因为不同的玩家喜欢不同类型的游戏。所以，对某个玩家来说有趣的东西可能对另一个玩家来说就不一定有趣。所以不要试图取悦所有人，因为这通常是不可能的。如果你这样做，你可能会发现自己追逐一个无法达到的目标。

在游戏设计的世界里，可能会有人争论最重要的元素是什么。有些人会说图形，而有些人会说游戏玩法。然而，在现实中，它们都非常重要。图形可以让游戏看起来很好，但图形不一定要逼真。它们可以是卡通风格，或者有其他看起来不逼真的风格。这并不意味着游戏不好。一个很好的例子是任天堂的《塞尔达传说：时之笛 HD》，它使用了一种名为**卡通渲染**的图形风格，使其世界看起来像卡通。

你从游戏中获得的最终体验并不仅仅取决于图形、游戏玩法或音效。它是所有结合在一起创造最终游戏体验的元素的综合体。当然，控制非常重要，因为它们是玩家与游戏之间的接口。如果接口奇怪或者工作不顺畅，玩家可能不会玩很多游戏。音效和音乐为游戏世界设定了氛围，而图形则提供了视觉元素，并有助于营造氛围。

## 游戏难度

游戏设计中可能最棘手的一个方面就是游戏难度。你不想让它太简单，否则一些玩家会感到无聊并放弃。同样，如果你让它太难，一些玩家可能会愤怒地退出。那么，我们如何处理这个问题呢？一种方法是为你的游戏设置多个难度级别，让玩家可以选择他们想要的难度。最常见的难度级别是“简单”、“普通”、“困难”，有时还有“非常困难”。另一种解决方案被称为**自适应难度**。这意味着游戏会观察玩家的表现，并根据需要调整难度。如果玩家表现非常好，它会稍微提高难度，如果玩家遇到困难，它会适当地降低难度。

难度的另一个方面被称为游戏**进度**。进度指的是随着你在游戏中前进，难度是如何增加的。它应该开始时缓慢增加，然后随着你进一步深入游戏，增加的速度会更快。因此，难度不应该从一个等级突然上升到下一个等级的 100%，因为这会在玩家中引起挫败感。

这引出了挑战的概念。一些游戏为硬核玩家提供了挑战级别以供享受。这是一个好主意，但它们不应该太难以至于需要花费很长时间才能击败。这只是我的个人观点，但一个设计良好的挑战应该是一个玩家在持续尝试中能够看到自己进步的地方。如果这是一个你需要尝试 1500 万次才能最终成功的等级，当然它很困难，但这不是一个设计良好的挑战，因为大多数玩家可能在他们成功之前就会放弃。为什么？因为他们可能会认为这是浪费时间。

那么如果你为击败它设置了酷炫的奖励会怎样呢？嗯，一些玩家会努力去获得它，但另一方面，一些玩家可能尝试了无数次后仍然无法获得它，他们会因为无法解锁而感到恼火。所以，挑战应该是困难的但又是合理的。正如我所说的，玩家应该看到他们的表现随着他们不断尝试而提高。看到他们在表现上的进步给了玩家一种希望的感觉。随着他们每次尝试都做得更好，他们感觉他们的目标越来越近。玩家感觉只要他们再稍微努力一点就能做到。另一方面，一个你需要重试 1500 万次才能幸运地完成关卡的水平，会产生相反的效果。如果玩家在尝试这个关卡时看不到任何明显的进步，他们会觉得自己没有变得更好，因此，继续尝试是浪费时间。玩家会失去希望。有一些非常困难的挑战是可以的，但它们应该是可选的，并且通常不应该有击败它们后解锁的内容。再次强调，这只是我的观点。

## 操作玩家的情绪

这引出了另一个有时被忽视的观点。如果你仔细想想，电子游戏在其核心功能之一就是操纵玩家的情绪。如果玩家变得愤怒，他们可能会退出，也许永远不再玩这个游戏。但除此之外，操纵玩家的情绪要深入得多。例如，游戏让玩家与某些角色产生情感上的联系，并让他们讨厌其他人。操纵玩家的情绪可以嵌入到基本的游戏玩法机制中。如果玩家定期获得奖励，这会让他们感觉良好，并给他们更多继续前进的理由。另一方面，一个深刻而强大的故事也能达到同样的效果。

所以，正如你所见，在游戏设计的世界中，有许多工具和问题需要克服。但如果你热爱电子游戏，并渴望创造它们，当你看到你的成品游戏在运行中，并且希望从你的粉丝那里得到很多积极的反馈时，所有的努力最终都是值得的。

最后，对于新游戏程序员来说，最好的建议之一是从小开始。不要过于雄心勃勃，因为如果你承担了超出你能力范围的工作，你很可能会结束一个永远无法完成的项目。那些绝对不是我们想要做的项目！

如果你真的成为了一名独立开发者，那么恭喜你！在这种情况下，你应该努力与你的粉丝进行良好的沟通。他们会非常感激，他们也是你可能会将它们整合到你的游戏中的伟大想法的来源。

### 注意

如前所述，不要忘记在你的代码中包含错误处理。例如，如果用户没有安装兼容的声卡或显卡，这一点尤为重要。因此，当你创建你的 DirectSound / XAudio2 或 Direct3D / DirectInput 设备时，确保它创建后不是 null，因为这显然不会工作得很好。你的程序可能会崩溃。

# 进一步阅读

在本节中，我们将探讨一些优秀的书籍和网站，如果你对游戏编程真正感兴趣的话。

## 网站

SlimDX 网站—[`slimdx.org/`](http://slimdx.org/)—有一个文档部分，你可以看到所有的 SlimDX 类及其成员。不幸的是，在撰写本文时，它是不完整的。

作为 SlimDX 网站的替代，你可以访问 SharpDX 网站，[`sharpdx.org/`](http://sharpdx.org/)。这个网站也有一个文档部分，目前它比 SlimDX 的文档更完整。

### 小贴士

大多数 SharpDX 类与它们的 SlimDX 对应类相同，但这两者之间有一些差异。SharpDX 只是 SlimDX 的一个替代品。所以，大多数时候，你可以查看它们的文档来帮助解决 SlimDX 的问题，但有时，由于两者之间的差异，它可能不会与 SlimDX 的文档完全准确。不过，它仍然是一个很好的资源。

GameDev.net 网站—[`www.Gamedev.net`](http://www.Gamedev.net)—是游戏开发者的一大资源。如果你真的遇到了难题，需要帮助解决 SlimDX 中的某个问题，他们的论坛是提问的好地方。网站上也有很多文章。

这个网站不仅涵盖了使用 SlimDX 和 C#进行游戏开发的内容，还有自网站重构以来的旧文章存档，可以在[`archive.gamedev.net/archive/reference/`](http://archive.gamedev.net/archive/reference/)找到。

Stack Overflow 网站—[`stackoverflow.com/`](http://http://stackoverflow.com/)—是一个提问的地方，人们可以对其评论并帮助你解决问题。实际上，我使用这个网站帮助我解决了一个我在创建本书第五章时遇到的特别棘手的问题！

这两个网站，[`braynzarsoft.net/index.php?p=DX11Lessons`](http://braynzarsoft.net/index.php?p=DX11Lessons)和[`www.rastertek.com/tutdx11.html`](http://www.rastertek.com/tutdx11.html)，上有许多优秀的 Direct3D 11 教程。只是要注意，这些教程使用的是 C++；因此，你将不得不找出如何在 SlimDX 中编写相同的代码。SlimDX 中的大多数对象与它们的原生 C++版本有相同的名称；所以，在大多数情况下，这个过程相对容易执行。

Riemers XNA 教程网站— [`www.riemers.net/`](http://www.riemers.net/)—为新手游戏程序员提供了一些非常棒的 XNA 教程，对于刚开始接触游戏编程并想了解更多的人来说，这是一个极好的资源。

ShaderX 书籍网站— [`tog.acm.org/resources/shaderx/`](http://tog.acm.org/resources/shaderx/)—有一系列名为*ShaderX*的书籍，其中几本可以免费下载！

NVIDIA 开发者区域网站上的*GPU Gems*书籍页面— [`http.developer.nvidia.com/GPUGems/gpugems_pref02.html`](http://http.developer.nvidia.com/GPUGems/gpugems_pref02.html)—提供了书籍的摘录，以给你一个关于书中内容的想法。

## 书籍

如果你想要了解更多关于底层概念，例如在游戏开发中图形是如何在最低级别实际渲染的，可以查看安德烈·拉莫特（André LaMothe）的这两本书：

+   *《Windows 游戏编程大师技巧，安德烈·拉莫特（André LaMothe），Sams Publishing》*

+   *《3D 游戏编程大师技巧：高级图形和光栅化，安德烈·拉莫特（André LaMothe），Sams Publishing》*

安德烈·拉莫特（André LaMothe）的这两本书都非常优秀。第一本专注于 2D 开发，DirectInput 的玩家输入，基本 AI，碰撞检测等。第二本书提供了关于 3D 视频游戏数学的非常好的入门，并专注于 3D 图形领域以及更多内容。

接下来，我想提到一本我在今年（2013 年）初接触到的书，结果证明它非常优秀：*《游戏编程完全指南：第四版，迈克·麦克沙弗里（Mike McShaffry）和大卫“Rez”格雷厄姆（David "Rez" Graham），Cengage Learning》*

这本书非常优秀，因为它涵盖了众多 DirectX 书籍中遗漏的内容。例如，许多书籍教你如何在屏幕上绘制图形，但它们并没有真正教你如何构建一个真正的游戏。这本书涵盖了创建每个视频游戏中发现的各个系统的许多方面。因此，这本书对于任何想要学习所有这些内容的严肃游戏程序员来说，确实是极其宝贵的。

书籍*《3D 图形和游戏开发数学入门》，弗莱彻·邓恩（Fletcher Dunn），伊恩·帕伯里（Ian Parberry），A K Peters/CRC Press*详细介绍了 3D 游戏的数学，并解释了概念背后的理论。

# 摘要

在本章中，我们讨论了一些在这本书中略过的杂项主题。其中许多主题本身就可以写成一本书。我们探讨了裁剪及其重要性，然后转向碰撞检测和物理。接着，我们探讨了多线程编程及其在视频游戏中的优势。之后，我们审视了一些游戏设计的问题和陷阱。最后，我们查看了一些进一步阅读的材料。

恭喜你完成了这本书！愿你在未来创造许多令人惊叹的游戏，并感谢你抽出时间阅读这本书。祝你在游戏设计之路上继续冒险好运！
