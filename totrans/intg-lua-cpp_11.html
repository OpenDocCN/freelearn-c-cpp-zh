<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer068">
<h1 class="chapter-number" id="_idParaDest-227"><a id="_idTextAnchor229"/>11</h1>
<h1 id="_idParaDest-228"><a id="_idTextAnchor230"/>Multithreading with Lua</h1>
<p>In the previous chapter, we learned some techniques to manage resources when integrating Lua into C++. In this chapter, we will learn how to work with multithreading with Lua. If you use Lua in a complex project, chances are that you need to create multiple Lua instances. First, we will learn how to contain the multithreading part in C++ and make Lua unaware of it. Then, we will see how Lua handles multithreading, in case you need to use it. Understanding multithreading will help with the technical planning for <span class="No-Break">your projects.</span></p>
<p>We will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Multithreading <span class="No-Break">in C++</span></li>
<li>Multithreading <span class="No-Break">in Lua</span></li>
<li>Using <strong class="source-inline">coroutine</strong> <span class="No-Break">with C++</span></li>
</ul>
<h1 id="_idParaDest-229"><a id="_idTextAnchor231"/>Technical requirements</h1>
<p>We will use the source code from <span class="No-Break"><em class="italic">Chapter 10</em></span> as a base to develop the examples in this chapter. Make sure you can access the source code for this <span class="No-Break">book: </span><a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter11"><span class="No-Break">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter11</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor232"/>Multithreading in C++</h1>
<p>What <span class="No-Break">is </span><span class="No-Break"><strong class="bold">multithreading</strong></span><span class="No-Break">?</span></p>
<p>There are <a id="_idIndexMarker475"/>a few definitions, depending on the point of view. From the CPU’s <a id="_idIndexMarker476"/>perspective, a multi-core processor that can execute multiple threads of instructions concurrently is real multithreading. From an application’s perspective, using multiple threads is multithreading. From a developer’s perspective, more focus might be on thread safety and various synchronization mechanisms, which are not multithreading itself, but <span class="No-Break">its implications.</span></p>
<p>In this section, we will learn how to use Lua with C++’s native multithreading support. Each C++ thread will have its own Lua state. Because the Lua library does not keep any state and Lua states<a id="_idIndexMarker477"/> are <a id="_idIndexMarker478"/>not shared among different threads, this <span class="No-Break">is thread-safe.</span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor233"/>How does C++ support multithreading?</h2>
<p>Since C++11, the<a id="_idIndexMarker479"/> standard library supports multithreading<a id="_idIndexMarker480"/> with <strong class="source-inline">std::thread</strong>. Each <strong class="source-inline">std::thread</strong> instance represents a thread of execution. The most important thing to provide to a thread is the thread function. This is what a thread executes. In its simplest form, we can create a thread <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void threadFunc(...) {}
std::thread t(threadFunc, ...);</pre>
<p>Here, we passed a C++ function as the thread function to create a thread. The function can optionally take arguments and the <strong class="source-inline">std::thread</strong> constructor will forward the arguments to the thread function. After the thread is created, the thread function starts to execute in its own thread. When the thread function finishes, the thread <span class="No-Break">is ended.</span></p>
<p>We can also use a class member function or a class static member function as the thread function by invoking different constructors. You can refer to a C++ reference manual to learn more <span class="No-Break">about </span><span class="No-Break"><strong class="source-inline">std::thread</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Before C++11</p>
<p class="callout">In the era before C++11, there was no standard multithreading support. People had to use third-party libraries or implement their own with a low-level library, such<a id="_idIndexMarker481"/> <span class="No-Break">as </span><span class="No-Break"><strong class="bold">pthreads</strong></span><span class="No-Break">.</span></p>
<p>This type of multithreading is unlikely to surprise you. This is the type of multithreading that people have talked about and have used most, which is <strong class="bold">preemptive multithreading</strong>. The<a id="_idIndexMarker482"/> thread function can be paused at any time and resumed at <span class="No-Break">any time.</span></p>
<p>Next, we will explore a real example to see C++ multithreading <span class="No-Break">in action.</span></p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor234"/>Using multiple Lua instances</h2>
<p>In this section, we <a id="_idIndexMarker483"/>will implement a thread function in which we’ll execute a Lua script. Then, we will create multiple threads to execute this same <span class="No-Break">thread function.</span></p>
<p>Based on the source code from <span class="No-Break"><em class="italic">Chapter 10</em></span>, wipe <strong class="source-inline">main.cpp</strong> clean and add the <span class="No-Break">following code:</span></p>
<pre class="source-code">
#include "LuaExecutor.h"
#include "LoggingLuaExecutorListener.h"
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
auto listener = std::make_unique
  &lt;LoggingLuaExecutorListener&gt;();
std::mutex coutMutex;</pre>
<p>Here, we added the necessary headers. <strong class="source-inline">listener</strong> is the Lua executor listener and will be shared for all Lua executor instances. <strong class="source-inline">coutMutex</strong> is a mutex for printing results with <strong class="source-inline">std::cout</strong>, whose usage we will <span class="No-Break">see next.</span></p>
<p>Next, implement the thread function, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void threadFunc(int threadNo, int a, int b, int c)
{
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    lua-&gt;execute("function add_params(a, b, c) return a + b
        + c end");
    auto result = lua-&gt;call("add_params",
        LuaNumber::make(a), LuaNumber::make(b),
        LuaNumber::make(c));
    std::lock_guard&lt;std::mutex&gt; lock(coutMutex);
    std::cout &lt;&lt; "[Thread " &lt;&lt; threadNo &lt;&lt; "] "
              &lt;&lt; a &lt;&lt; "+" &lt;&lt; b &lt;&lt; "+" &lt;&lt; c &lt;&lt; "="
              &lt;&lt; std::get&lt;LuaNumber&gt;(result).value
              &lt;&lt; std::endl;
}</pre>
<p>The thread function takes three integers as arguments, creates a Lua executor, and executes a Lua script to add the three integers. Then, it prints out <span class="No-Break">the result.</span></p>
<p>Because there is only one place the standard output can print to, we are guarding the standard output with a mutex. Otherwise, the output sequence will be a mix of different threads <span class="No-Break">and unreadable.</span></p>
<p>The way we use this mutex is by creating <strong class="source-inline">std::lock_guard</strong> instead of calling <strong class="source-inline">std::mutex::lock</strong> and <strong class="source-inline">std::mutex::unlock</strong> directly. The lock guard will acquire the mutex <a id="_idIndexMarker484"/>during construction and release the mutex when it goes out of scope and gets destroyed. This is an example of the <span class="No-Break"><em class="italic">RAII</em></span><span class="No-Break"> principle.</span></p>
<p class="callout-heading">Recap of RAII</p>
<p class="callout">In the previous chapter, we learned about Resource Acquisition is Initialization (RAII). The C++ standard <a id="_idIndexMarker485"/>library adopts this principle in numerous places. Suppose that we do not use the lock this way, but acquire and release it manually. If anything goes wrong in between, there is a risk that the lock is not released in a thread and breaks the whole application. With the lock guard, the lock is always released even if an exception is raised because the C++ language guarantees that the lock’s destructor is called when the lock goes out of scope. Before C++11, people would implement their own lock guard by creating a wrapper class that acquires the lock in the constructor and releases the lock in the destructor. This idiom is <a id="_idIndexMarker486"/>called <strong class="bold">scoped locking</strong>. C++17 also provides <strong class="source-inline">std::scoped_lock</strong>, which can lock on <span class="No-Break">multiple mutexes.</span></p>
<p>Finally, let’s implement the <strong class="source-inline">main</strong> function, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
int main()
{
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 5; i++)
    {
        int a = i * 3 + 1;
        threads.emplace_back(threadFunc, i + 1,
            a, a + 1, a + 2);
    }
    for (auto &amp;t : threads)
    {
        t.join();
    }
    return 0;
}</pre>
<p>This creates a list of threads and waits for the threads to <span class="No-Break">finish execution.</span></p>
<p>In the first <strong class="source-inline">for</strong> loop, we use <strong class="source-inline">std::vector::emplace_back</strong> to create the threads at the end of the vector in place. Internally, for most C++ implementations, it uses <em class="italic">placement new</em> and invokes <strong class="source-inline">std::thread(threadFunc, i, a, a + 1, a + 2)</strong>. We do this because <strong class="source-inline">std::thread</strong> is not copy-constructible. Understandably, it does not make sense to copy <span class="No-Break">a thread.</span></p>
<p>In the second <strong class="source-inline">for</strong> loop, we use <strong class="source-inline">std::thread::join</strong> to wait for all threads to finish execution. The <strong class="source-inline">main</strong> function <a id="_idIndexMarker487"/>runs in the main thread of the application process. When <strong class="source-inline">main</strong> exits, all other threads will be aborted, even if they have not <span class="No-Break">finished execution.</span></p>
<p>Next, we’ll test <span class="No-Break">our example.</span></p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor235"/>Testing it out</h2>
<p>Compile and <a id="_idIndexMarker488"/>execute the project. You should see an output similar to <span class="No-Break">the following:</span></p>
<pre class="source-code">
Chapter11 % ./executable
[Thread 2] 4+5+6=15
[Thread 3] 7+8+9=24
[Thread 5] 13+14+15=42
[Thread 1] 1+2+3=6
[Thread 4] 10+11+12=33</pre>
<p>If you run the project multiple times, you will see the order of the results from different threads changes. This verifies that we are using Lua with <span class="No-Break">multiple threads.</span></p>
<p>For most projects, when integrating Lua into C++, this mechanism should suffice for multithreading. This is multithreading with C++. The Lua part just works without any additional effort. Each <a id="_idIndexMarker489"/>C++ thread has its own Lua instance and executes its copy of the Lua scripts. Different Lua instances do not interfere with or know about <span class="No-Break">each other.</span></p>
<p>Next, we will explore multithreading <span class="No-Break">in Lua.</span></p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor236"/>Multithreading in Lua</h1>
<p>To understand<a id="_idIndexMarker490"/> multithreading<a id="_idIndexMarker491"/> in Lua, let’s begin with a <span class="No-Break">fundamental question.</span></p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor237"/>How does Lua support multithreading?</h2>
<p><em class="italic">Lua does not support </em><span class="No-Break"><em class="italic">multithreading. Period.</em></span></p>
<p>But we<a id="_idIndexMarker492"/> cannot finish this section yet. We will explain this <a id="_idIndexMarker493"/>further with two approaches – a contemporary one and an <span class="No-Break">old-school one.</span></p>
<h3>The contemporary approach</h3>
<p>Lua is a scripting<a id="_idIndexMarker494"/> language and it does not<a id="_idIndexMarker495"/> support <em class="italic">preemptive multithreading</em>. It simply does not provide a library function to create a new thread, so there is no way to <span class="No-Break">do it.</span></p>
<p>Nowadays, CPUs and operating systems are designed around <em class="italic">preemptive multithreading</em> – that is, a thread of execution can be paused and resumed at any time. A thread has no control over its <span class="No-Break">execution schedule.</span></p>
<p>However, Lua provides a <a id="_idIndexMarker496"/>mechanism for <strong class="bold">cooperative multithreading</strong> with <strong class="bold">coroutines</strong>. In a <em class="italic">cooperative multithreading</em> environment, the <a id="_idIndexMarker497"/>thread of execution is never preempted. Only when the thread <a id="_idIndexMarker498"/>willingly<a id="_idIndexMarker499"/> gives up its execution can another thread start to execute using the same CPU core. An application component that can be executed this way is called a <strong class="source-inline">coroutine</strong>, which is usually <span class="No-Break">a function.</span></p>
<p><strong class="source-inline">coroutine</strong> is also very popular with Kotlin for Android and <span class="No-Break">backend development.</span></p>
<p class="callout-heading">Cooperative multithreading</p>
<p class="callout">When we talk <a id="_idIndexMarker500"/>about threads, most of the time, the implication is that they are threads for CPU cores to execute. When we talk about <em class="italic">cooperative multithreading</em>, in some cases, such as the one for Lua, you may find that there is only one thread being executed and one CPU core used, even with coroutines. Arguably, this is not multithreading at all. But we do not need to judge. We need to understand this because multiple terms can be used for this in different contexts. We can also<a id="_idIndexMarker501"/> call this <strong class="bold">cooperative multitasking</strong>, which is technically more accurate from a historical point <span class="No-Break">of view.</span></p>
<p>Let’s <a id="_idIndexMarker502"/>see <a id="_idIndexMarker503"/>Lua’s <strong class="source-inline">coroutine</strong> in action and explain <span class="No-Break">it more.</span></p>
<h4>Implementing a Lua coroutine</h4>
<p>Replace<a id="_idIndexMarker504"/> the content of <strong class="source-inline">script.lua</strong> with the<a id="_idIndexMarker505"/> <span class="No-Break">following code:</span></p>
<pre class="source-code">
function create_square_seq_coroutine(n)
    return coroutine.create(function ()
        for i = 1, n do
            coroutine.yield(i * i)
        end
    end)
end</pre>
<p><strong class="source-inline">create_square_seq_coroutine</strong> creates a <strong class="source-inline">coroutine</strong> with <strong class="source-inline">coroutine.create</strong>, which, in turn, takes an anonymous function as its argument. You can roughly think that the inner anonymous function is <strong class="source-inline">coroutine</strong>. The inner function runs a loop and <strong class="bold">yield</strong> the squares from <strong class="source-inline">1</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">n</strong></span><span class="No-Break">.</span></p>
<p>You can only use <strong class="source-inline">yield</strong> with coroutines. A coroutine will stop execution when it reaches a <strong class="source-inline">yield</strong> statement. The values provided to <strong class="source-inline">yield</strong> will be returned to the call site, similar to what <strong class="source-inline">return</strong> does. The next time you execute <strong class="source-inline">coroutine</strong>, it will resume the execution from where it yielded until it reaches another <strong class="source-inline">yield</strong> statement or a <span class="No-Break"><strong class="source-inline">return</strong></span><span class="No-Break"> statement.</span></p>
<p>Let’s start an <a id="_idIndexMarker506"/>interactive Lua interpreter<a id="_idIndexMarker507"/> to test <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">coroutine</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
Chapter11 % ../lua/src/lua
Lua 5.4.6  Copyright (C) 1994-2023 Lua.org, PUC-Rio
&gt; dofile("script.lua")
&gt; co = create_square_seq_coroutine(3)
&gt; coroutine.resume(co)
true    1
&gt; coroutine.resume(co)
true    4
&gt; coroutine.resume(co)
true    9
&gt; coroutine.resume(co)
true
&gt; coroutine.resume(co)
false   cannot resume dead coroutine</pre>
<p>Here, we create a <strong class="source-inline">coroutine</strong> to return the squares from <strong class="source-inline">1</strong> to <strong class="source-inline">3</strong>. The first time we <strong class="source-inline">resume</strong> <strong class="source-inline">coroutine</strong>, it starts to execute from the beginning and returns two values, <strong class="source-inline">true</strong> and <strong class="source-inline">1</strong>. <strong class="source-inline">true</strong> is from <strong class="source-inline">coroutine.resume</strong> and means that <strong class="source-inline">coroutine</strong> is executed without any error. <strong class="source-inline">1</strong> is what <strong class="source-inline">coroutine</strong> yielded. The next time we <strong class="source-inline">resume</strong> <strong class="source-inline">coroutine</strong>, the loop continues with the next iteration and returns <strong class="source-inline">4</strong>. Pay special attention to the line when <strong class="source-inline">coroutine.resume</strong> only returns one value. The loop has finished but there is still code to be executed for <strong class="source-inline">coroutine</strong>, such as the implicit return statement. So, <strong class="source-inline">coroutine.resume</strong> returns <strong class="source-inline">true</strong>. After that, <strong class="source-inline">coroutine</strong> has finished and cannot be resumed and <strong class="source-inline">coroutine.resume</strong> will return <strong class="source-inline">false</strong> with an <span class="No-Break">error message.</span></p>
<p>If this is the first time you have used <strong class="source-inline">coroutine</strong> with any programming language, this may seem magical and non-logical to you. How could a function, not in a thread, not reach its end and get executed from the middle of it again? I will explain why this is so ordinary (but do say you know <strong class="source-inline">coroutine</strong> and why it is so glorious in an interview) in the last part of <a id="_idIndexMarker508"/>this <a id="_idIndexMarker509"/>section. Before that, let’s explore another example to see a case in which <strong class="source-inline">coroutine</strong> can be <span class="No-Break">very useful.</span></p>
<h4>Lua coroutine as iterator</h4>
<p>We have <a id="_idIndexMarker510"/>seen<a id="_idIndexMarker511"/> how<a id="_idIndexMarker512"/> to use iterators with the <em class="italic">generic for</em> to simplify our lives, for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">ipairs</strong></span><span class="No-Break">.</span></p>
<p>But what is <span class="No-Break">an iterator?</span></p>
<p>An <strong class="bold">iterator</strong> is something that can be called again and again to produce values until there are no more to produce. For Lua, <strong class="source-inline">iterator</strong> returns<a id="_idIndexMarker513"/> an <strong class="bold">iterator function</strong> that can be called again and again until it returns nil <span class="No-Break">or nothing.</span></p>
<p>Based on <strong class="source-inline">coroutine</strong> that we have just implemented to generate a sequence of squares, let’s build an iterator. In <strong class="source-inline">script.lua</strong>, add another function, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
function square_seq(n)
    local co = create_square_seq_coroutine(n)
    return function()
        local code, value = coroutine.resume(co)
        return value
    end
end</pre>
<p><strong class="source-inline">square_seq</strong> is a Lua <strong class="source-inline">iterator</strong> as it returns its inner function as an <strong class="source-inline">iterator</strong> <strong class="source-inline">function</strong>. The inner function continues to resume the coroutine created with <strong class="source-inline">create_square_seq_coroutine</strong>. It is the caller’s responsibility to stop calling the <strong class="source-inline">iterator</strong> <strong class="source-inline">function</strong> when the <strong class="source-inline">iterator</strong> <strong class="source-inline">function </strong>has returned nil <span class="No-Break">or nothing.</span></p>
<p>Let’s test this <strong class="source-inline">iterator</strong> in an interactive <span class="No-Break">Lua interpreter:</span></p>
<pre class="source-code">
Chapter11 % ../lua/src/lua
Lua 5.4.6  Copyright (C) 1994-2023 Lua.org, PUC-Rio
&gt; dofile("script.lua")
&gt; for v in square_seq(3) do print(v) end
1
4
9</pre>
<p>You can see that three values are printed as expected for <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">.</span></p>
<p>And by looking at the usage, you cannot even tell if any coroutine or cooperative multithreading is involved. This, I think, is one of the examples where this programming paradigm can be more valuable than <span class="No-Break">preemptive multithreading.</span></p>
<p>So far, we have explored Lua <strong class="source-inline">coroutine</strong> and Lua <strong class="source-inline">iterator</strong>. They can be more complex, but these examples are enough to show you how they work. You can refer to the Lua<a id="_idIndexMarker514"/> reference<a id="_idIndexMarker515"/> manual<a id="_idIndexMarker516"/> to learn more about <strong class="source-inline">coroutine</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">iterator</strong></span><span class="No-Break">.</span></p>
<p>Next, let me indulge myself by explaining this in my <span class="No-Break">own terms.</span></p>
<h4>Introducing multi-stacking</h4>
<p>Traditionally, a <a id="_idIndexMarker517"/>thread is an execution unit for a CPU<a id="_idIndexMarker518"/> core, with its associated execution stack and the <strong class="bold">program counter</strong> (<strong class="bold">PC</strong>). The <a id="_idIndexMarker519"/>PC is a CPU register for the address of the next instruction to be executed. As you can see, this is quite low-level and involves more details that we are not going to <span class="No-Break">talk about.</span></p>
<p>Because this traditional image has been imprinted in us too much, even implicitly, it may have become an obstacle for you to <span class="No-Break">understand coroutines.</span></p>
<p>Alternatively, let’s seek help with one of the fundamental <a id="_idIndexMarker520"/>principles in computer science – <span class="No-Break"><strong class="bold">decoupling</strong></span><span class="No-Break">.</span></p>
<p>The widely understood preemptive multithreading mechanism is already an application of decoupling. It decouples the thread from the CPU core. With it, you can have unlimited threads in the pool while you have limited physical <span class="No-Break">CPU cores.</span></p>
<p>When you accept this, we only need to go one step further. If you accept that the execution stack can be decoupled from the execution thread as well, that is how <span class="No-Break"><strong class="source-inline">coroutine</strong></span><span class="No-Break"> works.</span></p>
<p>In this cooperative multithreading mechanism, a thread can have its own pool of execution stacks. An execution stack contains the call stack and PC. So, now, we have a <span class="No-Break">three-tier system.</span></p>
<p>I call these <a id="_idIndexMarker521"/>coroutines multi-stacking, a term I coined<strong class="bold"> </strong>to better explain it. Have a look at <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.1</em>, which implicates <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">The relationship between the CPU and threads</strong>: There are more threads than CPU cores. A CPU core can execute any thread. When a thread is resumed, it can be picked up by any CPU core. This is the <em class="italic">preemptive multithreading</em> that we know of, which usually requires CPU hardware support and is managed by the operating <span class="No-Break">system transparently.</span></li>
<li><strong class="bold">The relationship between threads and coroutines</strong>: One thread can have multiple coroutines, each with its own execution stack. Because the operating system stops at the thread level, the operating system has no concept of coroutines. For a thread to execute another coroutine, the current coroutine must give up its execution and yield willingly. This is why it is called <em class="italic">cooperative multithreading</em>. The coroutine has no concept of threads either; its owning thread can be preempted and picked up by another CPU core later, but these are all transparent to the coroutine. A coroutine can also be picked up by different threads if the programming environment <span class="No-Break">supports that.</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer067">
<img alt="Figure 11.1 – Multi-stacking" height="844" src="image/B20927_11_01.jpg" width="906"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Multi-stacking</p>
<p>Take a moment and think about the two relationships, which are explained and illustrated in  <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.1</em>. This is one of the ways, albeit be unusual, to explain coroutines. The<a id="_idIndexMarker522"/> goal here is to find similarities between<a id="_idIndexMarker523"/> different mechanisms <span class="No-Break">and technologies.</span></p>
<p>Next, we will look at cooperative multithreading and <strong class="source-inline">coroutine</strong> from <span class="No-Break">another perspective</span><span class="No-Break">.</span></p>
<h3>The old-school approach</h3>
<p>So far in this<a id="_idIndexMarker524"/> section, we have focused on the<a id="_idIndexMarker525"/> contemporary approach to explain the <strong class="source-inline">coroutine</strong> concept. Hopefully, with the two relationships explained, you can understand and tell why <strong class="source-inline">coroutine</strong> adds another valuable layer of multithreading support in a modern <span class="No-Break">computing system.</span></p>
<p>However, this is nothing new. This is how computers have worked since <span class="No-Break">the beginning.</span></p>
<p>Of course, in the very beginning, as you know, we feed the machine paper tape with holes. So, it is hopeless <span class="No-Break">for multithreading.</span></p>
<p>Then, later, it becomes more complex. But still, there is only one processing unit in the CPU, and there is a privileged and primitive control program running in a dead loop. The main thing the loop does is check if another program wants to run. If there is one, it loads the starting address of that program into the PC – the program counter of the CPU. Then, the CPU starts to execute the <span class="No-Break">other program.</span></p>
<p>You have probably guessed the problem. What if there is yet another program that wants to run? As it used to be, it has to wait for the first program to finish. This, as you can imagine, is not fair. So, we improve it and regulate that all programs should play nicely and yield their execution once in a while. Doing this allows the privileged control program to resume and find out if another program needs <span class="No-Break">to run.</span></p>
<p>This is called <em class="italic">cooperative multithreading</em>. Each of the programs, besides the privileged one, is a <strong class="source-inline">coroutine</strong> instance, except that this term had not been invented in <span class="No-Break">that era.</span></p>
<p>It helps, but not always. Suppose that one program decides to wait for an I/O that never happens and does not yield; the computer will be waiting endlessly <span class="No-Break">in vain.</span></p>
<p>Much later, the computer became more powerful and could support running more complex operating<a id="_idIndexMarker526"/> systems. It moved the logic to decide which program to run into the operating system. If a program is waiting for I/O or has been running for enough time, the operating system will pause it and resume another program to run. This is <em class="italic">preemptive multithreading</em>. As it turns out, this is the right move. The operating system is fairer and the computer can <span class="No-Break">do more.</span></p>
<p>Fast-forward to recent years – Moore’s law no longer applies or at least has been paused. So, the CPU is not getting 1,000 cores, but the threads in a working computer are ever-increasing. Thus, the cost for the operating system to preempt and iterate through all the threads has now become <span class="No-Break">a concern.</span></p>
<p>What can <span class="No-Break">we do?</span></p>
<p>Some smart guys found out that we just need to do what we did in the beginning – use cooperative multithreading again. But this time, the controlling program is your main program – since you can’t be selfish with yourself, you will be fair to all your coroutines to the best of <span class="No-Break">your ability.</span></p>
<p>This is a simplified version of the evolution of the computer system. It is not historically perfect and has some dramatic touches to it. The goal is for you to realize that <strong class="source-inline">coroutine</strong> is a<a id="_idIndexMarker527"/> simple <a id="_idIndexMarker528"/>concept and that you can be comfortable <span class="No-Break">with it.</span></p>
<p>Next, we will learn how to use coroutines <span class="No-Break">with C++.</span></p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor238"/>Using coroutine with C++</h1>
<p>Do not <a id="_idIndexMarker529"/>use Lua <strong class="source-inline">coroutine</strong> with C++ if you have an alternative. As <a id="_idIndexMarker530"/>the iterator example showed, you can wrap <strong class="source-inline">coroutine</strong> in a normal function and keep calling it until it <span class="No-Break">returns nil.</span></p>
<p>But to be less opinionated and for completeness, we can use the following Lua library function to start or resume a coroutine <span class="No-Break">from C++:</span></p>
<pre class="source-code">
int lua_resume (lua_State *L, lua_State *from, int narg,
                int *nresults);</pre>
<p>The function is similar to <strong class="source-inline">pcall</strong>. It expects the function to be called and, optionally, its arguments on the stack. The function will be the coroutine. <strong class="source-inline">L</strong> is a stack for the coroutine. <strong class="source-inline">from</strong> is the stack from which the coroutine is called. <strong class="source-inline">narg</strong> is the number of arguments to the <strong class="source-inline">coroutine</strong> function. <strong class="source-inline">nresults</strong> points to an integer and Lua will output the number of values yielded or returned to <span class="No-Break">the integer.</span></p>
<p>Let’s see an example to understand how this works. In <strong class="source-inline">LuaExecutor.h</strong>, add a function declaration, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    LuaValue resume(const std::string &amp;function);
};</pre>
<p>The <strong class="source-inline">resume</strong> function supports <strong class="source-inline">coroutine</strong> in a limited way. It does not support passing parameters, but this is easy to do and you can refer to <strong class="source-inline">LuaExecutor::call</strong>. It only expects one return value as an integer. This is just to demonstrate the Lua API, not to add complete <a id="_idIndexMarker531"/>support<a id="_idIndexMarker532"/> for <strong class="source-inline">coroutine</strong> in our <span class="No-Break">Lua executor.</span></p>
<p>Implement <strong class="source-inline">resume</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
inline LuaValue
LuaExecutor::resume(const std::string &amp;function)
{
    lua_State *thd = lua_newthread(L);
    int type = lua_getglobal(thd, function.c_str());
    assert(LUA_TFUNCTION == type);
    int nresults = 0;
    const int status = lua_resume(thd, L, 0, &amp;nresults);
    if (status != LUA_OK &amp;&amp; status != LUA_YIELD)
    {
        lua_pop(thd, 1);
        return LuaNil::make();
    }
    if (nresults == 0)
    {
        return LuaNil::make();
    }
    const int value = lua_tointeger(thd, -1);
    lua_pop(thd, nresults);
    lua_pop(L, 1);
    return LuaNumber::make(value);
}</pre>
<p>This is a five-step process, separated by newlines, which is explained <span class="No-Break">as follows:</span></p>
<ol>
<li>It creates a new Lua state with <strong class="source-inline">lua_newthread</strong>. A reference to the new state is also pushed onto the main stack owned by <strong class="source-inline">L</strong>. We can call this new state the coroutine state. But <strong class="source-inline">thd</strong> is the coroutine stack. The Lua <strong class="source-inline">lua_newthread</strong> library function creates a new Lua state that shares the same global environment with the main state <strong class="source-inline">L</strong> but has its own execution stack. Yes, the API name is a bit misleading, but it is what <span class="No-Break">it is.</span></li>
<li>It pushes the function name to be executed as a coroutine onto the new <span class="No-Break">Lua stack.</span></li>
<li>It calls <strong class="source-inline">lua_resume</strong> to start or resume the coroutine. Since we are always creating a new state named <strong class="source-inline">thd</strong>, we are always starting the coroutine afresh. To resume it, we need to save <strong class="source-inline">thd</strong> somewhere and pass it in for <span class="No-Break">future calls.</span></li>
<li>It checks whether there is<a id="_idIndexMarker533"/> an<a id="_idIndexMarker534"/> error; or, in case the coroutine does not return any result, it means that it <span class="No-Break">has ended.</span></li>
<li>It retrieves the single integer that we expect, pops it from the coroutine stack, pops the reference to the coroutine stack from the main stack, and returns <span class="No-Break">the value.</span></li>
</ol>
<p class="callout-heading">Taking care of other Lua states</p>
<p class="callout">A coroutine needs its own Lua state to be executed. You need to keep a reference to its Lua state somewhere until you no longer need the coroutine. Without a reference, Lua will destroy the state during garbage collection. If you have many coroutines, keeping all of those extra Lua states in the main stack can be messy. So, if you want to work with coroutines in C++, you need to design a system to hold and query those <span class="No-Break">Lua states.</span></p>
<p>Next, add the following Lua function <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">script.lua</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
function squares()
    for i = 2, 3 do
        coroutine.yield(i * i)
    end
end</pre>
<p>This function yields two values. The <strong class="source-inline">for</strong> loop is hardcoded because we do not support passing arguments <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">LuaExecutor::resume</strong></span><span class="No-Break">.</span></p>
<p>For the last bit of<a id="_idIndexMarker535"/> the<a id="_idIndexMarker536"/> demonstration, write <strong class="source-inline">main.cpp</strong> <span class="No-Break">like so:</span></p>
<pre class="source-code">
#include "LuaExecutor.h"
#include "LoggingLuaExecutorListener.h"
#include &lt;iostream&gt;
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    lua-&gt;executeFile("script.lua");
    auto result = lua-&gt;resume("squares");
    if (getLuaType(result) == LuaType::number)
    {
    std::cout &lt;&lt; "Coroutine yields "
              &lt;&lt; std::get&lt;LuaNumber&gt;(result).value
              &lt;&lt; std::endl;
    }
    return 0;
}</pre>
<p>This sets up the Lua executor and calls the <strong class="source-inline">resume</strong> function to <span class="No-Break">start </span><span class="No-Break"><strong class="source-inline">coroutine</strong></span><span class="No-Break">.</span></p>
<p>Compile and run the project; you should see the <span class="No-Break">following output:</span></p>
<pre class="source-code">
Coroutine yields 4</pre>
<p>This shows how to work with <strong class="source-inline">lua_resume</strong>. You can read the Lua reference manual to get more detailed information about <span class="No-Break">this API.</span></p>
<p>C++ code can also be executed as a coroutine. This can be done where a <strong class="source-inline">lua_CFunction</strong> implementation is provided to <strong class="source-inline">lua_resume</strong>, or Lua code in a coroutine calls a <strong class="source-inline">lua_CFunction</strong> implementation. In this case, C++ code can also yield by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">lua_yieldk</strong></span><span class="No-Break">.</span></p>
<p>Using coroutine with C++ can be very complex, but if you have your use cases defined, this can be abstracted to<a id="_idIndexMarker537"/> hide <a id="_idIndexMarker538"/>the complex details. This section is only an eye-opener. You can decide whether to use Lua this way <span class="No-Break">or not.</span></p>
<h1 id="_idParaDest-237"><a id="_idTextAnchor239"/>Summary</h1>
<p>With that, we have wrapped up the final chapter of this book. In this chapter, we focused on multithreading mechanisms, preemptive multithreading and cooperative multithreading, and <span class="No-Break">Lua coroutines.</span></p>
<p>Lua coroutines can be used without C++ for advanced Lua programming and you can hide all these details from C++. We only touched the tip of the iceberg. You can read the Lua reference manual and practice more. You can also explore more on how to use coroutines with C++ by experimenting with the related Lua <span class="No-Break">library functions.</span></p>
<p>In this book, we implemented <strong class="source-inline">LuaExecutor</strong> progressively. Each chapter added more features to it. However, it is not perfect. For example, <strong class="source-inline">LuaValue</strong> can be improved to make it easier to work with, and <strong class="source-inline">LuaExecutor</strong> can support more table operations. You can use <strong class="source-inline">LuaExecutor</strong> as a base and adapt it to your project or implement your own in a completely different way after you have learned <span class="No-Break">the mechanisms.</span></p>
<p>I am confident that at this point, you can make improvements and add more features that suit you the best. You can always revisit the chapters as reminders and search the Lua reference manual for what <span class="No-Break">you need.</span></p>
</div>
</div></body></html>