<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-227"><a id="_idTextAnchor229"/>11</h1>
<h1 id="_idParaDest-228"><a id="_idTextAnchor230"/>Multithreading with Lua</h1>
<p>In the previous chapter, we learned some techniques to manage resources when integrating Lua into C++. In this chapter, we will learn how to work with multithreading with Lua. If you use Lua in a complex project, chances are that you need to create multiple Lua instances. First, we will learn how to contain the multithreading part in C++ and make Lua unaware of it. Then, we will see how Lua handles multithreading, in case you need to use it. Understanding multithreading will help with the technical planning for your projects.</p>
<p>We will cover the following topics:</p>
<ul>
<li>Multithreading in C++</li>
<li>Multithreading in Lua</li>
<li>Using <code>coroutine</code> with C++</li>
</ul>
<h1 id="_idParaDest-229"><a id="_idTextAnchor231"/>Technical requirements</h1>
<p>We will use the source code from <em class="italic">Chapter 10</em> as a base to develop the examples in this chapter. Make sure you can access the source code for this book: <a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter11">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter11</a>.</p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor232"/>Multithreading in C++</h1>
<p>What is <strong class="bold">multithreading</strong>?</p>
<p>There are <a id="_idIndexMarker475"/>a few definitions, depending on the point of view. From the CPU’s <a id="_idIndexMarker476"/>perspective, a multi-core processor that can execute multiple threads of instructions concurrently is real multithreading. From an application’s perspective, using multiple threads is multithreading. From a developer’s perspective, more focus might be on thread safety and various synchronization mechanisms, which are not multithreading itself, but its implications.</p>
<p>In this section, we will learn how to use Lua with C++’s native multithreading support. Each C++ thread will have its own Lua state. Because the Lua library does not keep any state and Lua states<a id="_idIndexMarker477"/> are <a id="_idIndexMarker478"/>not shared among different threads, this is thread-safe.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor233"/>How does C++ support multithreading?</h2>
<p>Since C++11, the<a id="_idIndexMarker479"/> standard library supports multithreading<a id="_idIndexMarker480"/> with <code>std::thread</code>. Each <code>std::thread</code> instance represents a thread of execution. The most important thing to provide to a thread is the thread function. This is what a thread executes. In its simplest form, we can create a thread as follows:</p>
<pre class="source-code">
void threadFunc(...) {}
std::thread t(threadFunc, ...);</pre>
<p>Here, we passed a C++ function as the thread function to create a thread. The function can optionally take arguments and the <code>std::thread</code> constructor will forward the arguments to the thread function. After the thread is created, the thread function starts to execute in its own thread. When the thread function finishes, the thread is ended.</p>
<p>We can also use a class member function or a class static member function as the thread function by invoking different constructors. You can refer to a C++ reference manual to learn more about <code>std::thread</code>.</p>
<p class="callout-heading">Before C++11</p>
<p class="callout">In the era before C++11, there was no standard multithreading support. People had to use third-party libraries or implement their own with a low-level library, such<a id="_idIndexMarker481"/> as <strong class="bold">pthreads</strong>.</p>
<p>This type of multithreading is unlikely to surprise you. This is the type of multithreading that people have talked about and have used most, which is <strong class="bold">preemptive multithreading</strong>. The<a id="_idIndexMarker482"/> thread function can be paused at any time and resumed at any time.</p>
<p>Next, we will explore a real example to see C++ multithreading in action.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor234"/>Using multiple Lua instances</h2>
<p>In this section, we <a id="_idIndexMarker483"/>will implement a thread function in which we’ll execute a Lua script. Then, we will create multiple threads to execute this same thread function.</p>
<p>Based on the source code from <em class="italic">Chapter 10</em>, wipe <code>main.cpp</code> clean and add the following code:</p>
<pre class="source-code">
#include "LuaExecutor.h"
#include "LoggingLuaExecutorListener.h"
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
auto listener = std::make_unique
  &lt;LoggingLuaExecutorListener&gt;();
std::mutex coutMutex;</pre>
<p>Here, we added the necessary headers. <code>listener</code> is the Lua executor listener and will be shared for all Lua executor instances. <code>coutMutex</code> is a mutex for printing results with <code>std::cout</code>, whose usage we will see next.</p>
<p>Next, implement the thread function, as follows:</p>
<pre class="source-code">
void threadFunc(int threadNo, int a, int b, int c)
{
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    lua-&gt;execute("function add_params(a, b, c) return a + b
        + c end");
    auto result = lua-&gt;call("add_params",
        LuaNumber::make(a), LuaNumber::make(b),
        LuaNumber::make(c));
    std::lock_guard&lt;std::mutex&gt; lock(coutMutex);
    std::cout &lt;&lt; "[Thread " &lt;&lt; threadNo &lt;&lt; "] "
              &lt;&lt; a &lt;&lt; "+" &lt;&lt; b &lt;&lt; "+" &lt;&lt; c &lt;&lt; "="
              &lt;&lt; std::get&lt;LuaNumber&gt;(result).value
              &lt;&lt; std::endl;
}</pre>
<p>The thread function takes three integers as arguments, creates a Lua executor, and executes a Lua script to add the three integers. Then, it prints out the result.</p>
<p>Because there is only one place the standard output can print to, we are guarding the standard output with a mutex. Otherwise, the output sequence will be a mix of different threads and unreadable.</p>
<p>The way we use this mutex is by creating <code>std::lock_guard</code> instead of calling <code>std::mutex::lock</code> and <code>std::mutex::unlock</code> directly. The lock guard will acquire the mutex <a id="_idIndexMarker484"/>during construction and release the mutex when it goes out of scope and gets destroyed. This is an example of the <em class="italic">RAII</em> principle.</p>
<p class="callout-heading">Recap of RAII</p>
<p class="callout">In the previous chapter, we learned about Resource Acquisition is Initialization (RAII). The C++ standard <a id="_idIndexMarker485"/>library adopts this principle in numerous places. Suppose that we do not use the lock this way, but acquire and release it manually. If anything goes wrong in between, there is a risk that the lock is not released in a thread and breaks the whole application. With the lock guard, the lock is always released even if an exception is raised because the C++ language guarantees that the lock’s destructor is called when the lock goes out of scope. Before C++11, people would implement their own lock guard by creating a wrapper class that acquires the lock in the constructor and releases the lock in the destructor. This idiom is <a id="_idIndexMarker486"/>called <code>std::scoped_lock</code>, which can lock on multiple mutexes.</p>
<p>Finally, let’s implement the <code>main</code> function, as follows:</p>
<pre class="source-code">
int main()
{
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 5; i++)
    {
        int a = i * 3 + 1;
        threads.emplace_back(threadFunc, i + 1,
            a, a + 1, a + 2);
    }
    for (auto &amp;t : threads)
    {
        t.join();
    }
    return 0;
}</pre>
<p>This creates a list of threads and waits for the threads to finish execution.</p>
<p>In the first <code>for</code> loop, we use <code>std::vector::emplace_back</code> to create the threads at the end of the vector in place. Internally, for most C++ implementations, it uses <em class="italic">placement new</em> and invokes <code>std::thread(threadFunc, i, a, a + 1, a + 2)</code>. We do this because <code>std::thread</code> is not copy-constructible. Understandably, it does not make sense to copy a thread.</p>
<p>In the second <code>for</code> loop, we use <code>std::thread::join</code> to wait for all threads to finish execution. The <code>main</code> function <a id="_idIndexMarker487"/>runs in the main thread of the application process. When <code>main</code> exits, all other threads will be aborted, even if they have not finished execution.</p>
<p>Next, we’ll test our example.</p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor235"/>Testing it out</h2>
<p>Compile and <a id="_idIndexMarker488"/>execute the project. You should see an output similar to the following:</p>
<pre class="source-code">
Chapter11 % ./executable
[Thread 2] 4+5+6=15
[Thread 3] 7+8+9=24
[Thread 5] 13+14+15=42
[Thread 1] 1+2+3=6
[Thread 4] 10+11+12=33</pre>
<p>If you run the project multiple times, you will see the order of the results from different threads changes. This verifies that we are using Lua with multiple threads.</p>
<p>For most projects, when integrating Lua into C++, this mechanism should suffice for multithreading. This is multithreading with C++. The Lua part just works without any additional effort. Each <a id="_idIndexMarker489"/>C++ thread has its own Lua instance and executes its copy of the Lua scripts. Different Lua instances do not interfere with or know about each other.</p>
<p>Next, we will explore multithreading in Lua.</p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor236"/>Multithreading in Lua</h1>
<p>To understand<a id="_idIndexMarker490"/> multithreading<a id="_idIndexMarker491"/> in Lua, let’s begin with a fundamental question.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor237"/>How does Lua support multithreading?</h2>
<p><em class="italic">Lua does not support </em><em class="italic">multithreading. Period.</em></p>
<p>But we<a id="_idIndexMarker492"/> cannot finish this section yet. We will explain this <a id="_idIndexMarker493"/>further with two approaches – a contemporary one and an old-school one.</p>
<h3>The contemporary approach</h3>
<p>Lua is a scripting<a id="_idIndexMarker494"/> language and it does not<a id="_idIndexMarker495"/> support <em class="italic">preemptive multithreading</em>. It simply does not provide a library function to create a new thread, so there is no way to do it.</p>
<p>Nowadays, CPUs and operating systems are designed around <em class="italic">preemptive multithreading</em> – that is, a thread of execution can be paused and resumed at any time. A thread has no control over its execution schedule.</p>
<p>However, Lua provides a <a id="_idIndexMarker496"/>mechanism for <code>coroutine</code>, which is usually a function.</p>
<p><code>coroutine</code> is also very popular with Kotlin for Android and backend development.</p>
<p class="callout-heading">Cooperative multithreading</p>
<p class="callout">When we talk <a id="_idIndexMarker500"/>about threads, most of the time, the implication is that they are threads for CPU cores to execute. When we talk about <em class="italic">cooperative multithreading</em>, in some cases, such as the one for Lua, you may find that there is only one thread being executed and one CPU core used, even with coroutines. Arguably, this is not multithreading at all. But we do not need to judge. We need to understand this because multiple terms can be used for this in different contexts. We can also<a id="_idIndexMarker501"/> call this <strong class="bold">cooperative multitasking</strong>, which is technically more accurate from a historical point of view.</p>
<p>Let’s <a id="_idIndexMarker502"/>see <a id="_idIndexMarker503"/>Lua’s <code>coroutine</code> in action and explain it more.</p>
<h4>Implementing a Lua coroutine</h4>
<p>Replace<a id="_idIndexMarker504"/> the content of <code>script.lua</code> with the<a id="_idIndexMarker505"/> following code:</p>
<pre class="source-code">
function create_square_seq_coroutine(n)
    return coroutine.create(function ()
        for i = 1, n do
            coroutine.yield(i * i)
        end
    end)
end</pre>
<p><code>create_square_seq_coroutine</code> creates a <code>coroutine</code> with <code>coroutine.create</code>, which, in turn, takes an anonymous function as its argument. You can roughly think that the inner anonymous function is <code>coroutine</code>. The inner function runs a loop and <code>1</code> to <code>n</code>.</p>
<p>You can only use <code>yield</code> with coroutines. A coroutine will stop execution when it reaches a <code>yield</code> statement. The values provided to <code>yield</code> will be returned to the call site, similar to what <code>return</code> does. The next time you execute <code>coroutine</code>, it will resume the execution from where it yielded until it reaches another <code>yield</code> statement or a <code>return</code> statement.</p>
<p>Let’s start an <a id="_idIndexMarker506"/>interactive Lua interpreter<a id="_idIndexMarker507"/> to test our <code>coroutine</code>:</p>
<pre class="source-code">
Chapter11 % ../lua/src/lua
Lua 5.4.6  Copyright (C) 1994-2023 Lua.org, PUC-Rio
&gt; dofile("script.lua")
&gt; co = create_square_seq_coroutine(3)
&gt; coroutine.resume(co)
true    1
&gt; coroutine.resume(co)
true    4
&gt; coroutine.resume(co)
true    9
&gt; coroutine.resume(co)
true
&gt; coroutine.resume(co)
false   cannot resume dead coroutine</pre>
<p>Here, we create a <code>coroutine</code> to return the squares from <code>1</code> to <code>3</code>. The first time we <code>resume</code> <code>coroutine</code>, it starts to execute from the beginning and returns two values, <code>true</code> and <code>1</code>. <code>true</code> is from <code>coroutine.resume</code> and means that <code>coroutine</code> is executed without any error. <code>1</code> is what <code>coroutine</code> yielded. The next time we <code>resume</code> <code>coroutine</code>, the loop continues with the next iteration and returns <code>4</code>. Pay special attention to the line when <code>coroutine.resume</code> only returns one value. The loop has finished but there is still code to be executed for <code>coroutine</code>, such as the implicit return statement. So, <code>coroutine.resume</code> returns <code>true</code>. After that, <code>coroutine</code> has finished and cannot be resumed and <code>coroutine.resume</code> will return <code>false</code> with an error message.</p>
<p>If this is the first time you have used <code>coroutine</code> with any programming language, this may seem magical and non-logical to you. How could a function, not in a thread, not reach its end and get executed from the middle of it again? I will explain why this is so ordinary (but do say you know <code>coroutine</code> and why it is so glorious in an interview) in the last part of <a id="_idIndexMarker508"/>this <a id="_idIndexMarker509"/>section. Before that, let’s explore another example to see a case in which <code>coroutine</code> can be very useful.</p>
<h4>Lua coroutine as iterator</h4>
<p>We have <a id="_idIndexMarker510"/>seen<a id="_idIndexMarker511"/> how<a id="_idIndexMarker512"/> to use iterators with the <em class="italic">generic for</em> to simplify our lives, for example, <code>ipairs</code>.</p>
<p>But what is an iterator?</p>
<p>An <code>iterator</code> returns<a id="_idIndexMarker513"/> an <strong class="bold">iterator function</strong> that can be called again and again until it returns nil or nothing.</p>
<p>Based on <code>coroutine</code> that we have just implemented to generate a sequence of squares, let’s build an iterator. In <code>script.lua</code>, add another function, as follows:</p>
<pre class="source-code">
function square_seq(n)
    local co = create_square_seq_coroutine(n)
    return function()
        local code, value = coroutine.resume(co)
        return value
    end
end</pre>
<p><code>square_seq</code> is a Lua <code>iterator</code> as it returns its inner function as an <code>iterator</code> <code>function</code>. The inner function continues to resume the coroutine created with <code>create_square_seq_coroutine</code>. It is the caller’s responsibility to stop calling the <code>iterator</code> <code>function</code> when the <code>iterator</code> <code>function </code>has returned nil or nothing.</p>
<p>Let’s test this <code>iterator</code> in an interactive Lua interpreter:</p>
<pre class="source-code">
Chapter11 % ../lua/src/lua
Lua 5.4.6  Copyright (C) 1994-2023 Lua.org, PUC-Rio
&gt; dofile("script.lua")
&gt; for v in square_seq(3) do print(v) end
1
4
9</pre>
<p>You can see that three values are printed as expected for <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p>And by looking at the usage, you cannot even tell if any coroutine or cooperative multithreading is involved. This, I think, is one of the examples where this programming paradigm can be more valuable than preemptive multithreading.</p>
<p>So far, we have explored Lua <code>coroutine</code> and Lua <code>iterator</code>. They can be more complex, but these examples are enough to show you how they work. You can refer to the Lua<a id="_idIndexMarker514"/> reference<a id="_idIndexMarker515"/> manual<a id="_idIndexMarker516"/> to learn more about <code>coroutine</code> and <code>iterator</code>.</p>
<p>Next, let me indulge myself by explaining this in my own terms.</p>
<h4>Introducing multi-stacking</h4>
<p>Traditionally, a <a id="_idIndexMarker517"/>thread is an execution unit for a CPU<a id="_idIndexMarker518"/> core, with its associated execution stack and the <strong class="bold">program counter</strong> (<strong class="bold">PC</strong>). The <a id="_idIndexMarker519"/>PC is a CPU register for the address of the next instruction to be executed. As you can see, this is quite low-level and involves more details that we are not going to talk about.</p>
<p>Because this traditional image has been imprinted in us too much, even implicitly, it may have become an obstacle for you to understand coroutines.</p>
<p>Alternatively, let’s seek help with one of the fundamental <a id="_idIndexMarker520"/>principles in computer science – <strong class="bold">decoupling</strong>.</p>
<p>The widely understood preemptive multithreading mechanism is already an application of decoupling. It decouples the thread from the CPU core. With it, you can have unlimited threads in the pool while you have limited physical CPU cores.</p>
<p>When you accept this, we only need to go one step further. If you accept that the execution stack can be decoupled from the execution thread as well, that is how <code>coroutine</code> works.</p>
<p>In this cooperative multithreading mechanism, a thread can have its own pool of execution stacks. An execution stack contains the call stack and PC. So, now, we have a three-tier system.</p>
<p>I call these <a id="_idIndexMarker521"/>coroutines multi-stacking, a term I coined<strong class="bold"> </strong>to better explain it. Have a look at <em class="italic">Figure 11</em><em class="italic">.1</em>, which implicates the following:</p>
<ul>
<li><strong class="bold">The relationship between the CPU and threads</strong>: There are more threads than CPU cores. A CPU core can execute any thread. When a thread is resumed, it can be picked up by any CPU core. This is the <em class="italic">preemptive multithreading</em> that we know of, which usually requires CPU hardware support and is managed by the operating system transparently.</li>
<li><strong class="bold">The relationship between threads and coroutines</strong>: One thread can have multiple coroutines, each with its own execution stack. Because the operating system stops at the thread level, the operating system has no concept of coroutines. For a thread to execute another coroutine, the current coroutine must give up its execution and yield willingly. This is why it is called <em class="italic">cooperative multithreading</em>. The coroutine has no concept of threads either; its owning thread can be preempted and picked up by another CPU core later, but these are all transparent to the coroutine. A coroutine can also be picked up by different threads if the programming environment supports that.</li>
</ul>
<div><div><img alt="Figure 11.1 – Multi-stacking" height="844" src="img/B20927_11_01.jpg" width="906"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Multi-stacking</p>
<p>Take a moment and think about the two relationships, which are explained and illustrated in  <em class="italic">Figure 11</em><em class="italic">.1</em>. This is one of the ways, albeit be unusual, to explain coroutines. The<a id="_idIndexMarker522"/> goal here is to find similarities between<a id="_idIndexMarker523"/> different mechanisms and technologies.</p>
<p>Next, we will look at cooperative multithreading and <code>coroutine</code> from another perspective.</p>
<h3>The old-school approach</h3>
<p>So far in this<a id="_idIndexMarker524"/> section, we have focused on the<a id="_idIndexMarker525"/> contemporary approach to explain the <code>coroutine</code> concept. Hopefully, with the two relationships explained, you can understand and tell why <code>coroutine</code> adds another valuable layer of multithreading support in a modern computing system.</p>
<p>However, this is nothing new. This is how computers have worked since the beginning.</p>
<p>Of course, in the very beginning, as you know, we feed the machine paper tape with holes. So, it is hopeless for multithreading.</p>
<p>Then, later, it becomes more complex. But still, there is only one processing unit in the CPU, and there is a privileged and primitive control program running in a dead loop. The main thing the loop does is check if another program wants to run. If there is one, it loads the starting address of that program into the PC – the program counter of the CPU. Then, the CPU starts to execute the other program.</p>
<p>You have probably guessed the problem. What if there is yet another program that wants to run? As it used to be, it has to wait for the first program to finish. This, as you can imagine, is not fair. So, we improve it and regulate that all programs should play nicely and yield their execution once in a while. Doing this allows the privileged control program to resume and find out if another program needs to run.</p>
<p>This is called <em class="italic">cooperative multithreading</em>. Each of the programs, besides the privileged one, is a <code>coroutine</code> instance, except that this term had not been invented in that era.</p>
<p>It helps, but not always. Suppose that one program decides to wait for an I/O that never happens and does not yield; the computer will be waiting endlessly in vain.</p>
<p>Much later, the computer became more powerful and could support running more complex operating<a id="_idIndexMarker526"/> systems. It moved the logic to decide which program to run into the operating system. If a program is waiting for I/O or has been running for enough time, the operating system will pause it and resume another program to run. This is <em class="italic">preemptive multithreading</em>. As it turns out, this is the right move. The operating system is fairer and the computer can do more.</p>
<p>Fast-forward to recent years – Moore’s law no longer applies or at least has been paused. So, the CPU is not getting 1,000 cores, but the threads in a working computer are ever-increasing. Thus, the cost for the operating system to preempt and iterate through all the threads has now become a concern.</p>
<p>What can we do?</p>
<p>Some smart guys found out that we just need to do what we did in the beginning – use cooperative multithreading again. But this time, the controlling program is your main program – since you can’t be selfish with yourself, you will be fair to all your coroutines to the best of your ability.</p>
<p>This is a simplified version of the evolution of the computer system. It is not historically perfect and has some dramatic touches to it. The goal is for you to realize that <code>coroutine</code> is a<a id="_idIndexMarker527"/> simple <a id="_idIndexMarker528"/>concept and that you can be comfortable with it.</p>
<p>Next, we will learn how to use coroutines with C++.</p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor238"/>Using coroutine with C++</h1>
<p>Do not <a id="_idIndexMarker529"/>use Lua <code>coroutine</code> with C++ if you have an alternative. As <a id="_idIndexMarker530"/>the iterator example showed, you can wrap <code>coroutine</code> in a normal function and keep calling it until it returns nil.</p>
<p>But to be less opinionated and for completeness, we can use the following Lua library function to start or resume a coroutine from C++:</p>
<pre class="source-code">
int lua_resume (lua_State *L, lua_State *from, int narg,
                int *nresults);</pre>
<p>The function is similar to <code>pcall</code>. It expects the function to be called and, optionally, its arguments on the stack. The function will be the coroutine. <code>L</code> is a stack for the coroutine. <code>from</code> is the stack from which the coroutine is called. <code>narg</code> is the number of arguments to the <code>coroutine</code> function. <code>nresults</code> points to an integer and Lua will output the number of values yielded or returned to the integer.</p>
<p>Let’s see an example to understand how this works. In <code>LuaExecutor.h</code>, add a function declaration, as follows:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    LuaValue resume(const std::string &amp;function);
};</pre>
<p>The <code>resume</code> function supports <code>coroutine</code> in a limited way. It does not support passing parameters, but this is easy to do and you can refer to <code>LuaExecutor::call</code>. It only expects one return value as an integer. This is just to demonstrate the Lua API, not to add complete <a id="_idIndexMarker531"/>support<a id="_idIndexMarker532"/> for <code>coroutine</code> in our Lua executor.</p>
<p>Implement <code>resume</code>, as follows:</p>
<pre class="source-code">
inline LuaValue
LuaExecutor::resume(const std::string &amp;function)
{
    lua_State *thd = lua_newthread(L);
    int type = lua_getglobal(thd, function.c_str());
    assert(LUA_TFUNCTION == type);
    int nresults = 0;
    const int status = lua_resume(thd, L, 0, &amp;nresults);
    if (status != LUA_OK &amp;&amp; status != LUA_YIELD)
    {
        lua_pop(thd, 1);
        return LuaNil::make();
    }
    if (nresults == 0)
    {
        return LuaNil::make();
    }
    const int value = lua_tointeger(thd, -1);
    lua_pop(thd, nresults);
    lua_pop(L, 1);
    return LuaNumber::make(value);
}</pre>
<p>This is a five-step process, separated by newlines, which is explained as follows:</p>
<ol>
<li>It creates a new Lua state with <code>lua_newthread</code>. A reference to the new state is also pushed onto the main stack owned by <code>L</code>. We can call this new state the coroutine state. But <code>thd</code> is the coroutine stack. The Lua <code>lua_newthread</code> library function creates a new Lua state that shares the same global environment with the main state <code>L</code> but has its own execution stack. Yes, the API name is a bit misleading, but it is what it is.</li>
<li>It pushes the function name to be executed as a coroutine onto the new Lua stack.</li>
<li>It calls <code>lua_resume</code> to start or resume the coroutine. Since we are always creating a new state named <code>thd</code>, we are always starting the coroutine afresh. To resume it, we need to save <code>thd</code> somewhere and pass it in for future calls.</li>
<li>It checks whether there is<a id="_idIndexMarker533"/> an<a id="_idIndexMarker534"/> error; or, in case the coroutine does not return any result, it means that it has ended.</li>
<li>It retrieves the single integer that we expect, pops it from the coroutine stack, pops the reference to the coroutine stack from the main stack, and returns the value.</li>
</ol>
<p class="callout-heading">Taking care of other Lua states</p>
<p class="callout">A coroutine needs its own Lua state to be executed. You need to keep a reference to its Lua state somewhere until you no longer need the coroutine. Without a reference, Lua will destroy the state during garbage collection. If you have many coroutines, keeping all of those extra Lua states in the main stack can be messy. So, if you want to work with coroutines in C++, you need to design a system to hold and query those Lua states.</p>
<p>Next, add the following Lua function to <code>script.lua</code>:</p>
<pre class="source-code">
function squares()
    for i = 2, 3 do
        coroutine.yield(i * i)
    end
end</pre>
<p>This function yields two values. The <code>for</code> loop is hardcoded because we do not support passing arguments in <code>LuaExecutor::resume</code>.</p>
<p>For the last bit of<a id="_idIndexMarker535"/> the<a id="_idIndexMarker536"/> demonstration, write <code>main.cpp</code> like so:</p>
<pre class="source-code">
#include "LuaExecutor.h"
#include "LoggingLuaExecutorListener.h"
#include &lt;iostream&gt;
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    lua-&gt;executeFile("script.lua");
    auto result = lua-&gt;resume("squares");
    if (getLuaType(result) == LuaType::number)
    {
    std::cout &lt;&lt; "Coroutine yields "
              &lt;&lt; std::get&lt;LuaNumber&gt;(result).value
              &lt;&lt; std::endl;
    }
    return 0;
}</pre>
<p>This sets up the Lua executor and calls the <code>resume</code> function to start <code>coroutine</code>.</p>
<p>Compile and run the project; you should see the following output:</p>
<pre class="source-code">
Coroutine yields 4</pre>
<p>This shows how to work with <code>lua_resume</code>. You can read the Lua reference manual to get more detailed information about this API.</p>
<p>C++ code can also be executed as a coroutine. This can be done where a <code>lua_CFunction</code> implementation is provided to <code>lua_resume</code>, or Lua code in a coroutine calls a <code>lua_CFunction</code> implementation. In this case, C++ code can also yield by calling <code>lua_yieldk</code>.</p>
<p>Using coroutine with C++ can be very complex, but if you have your use cases defined, this can be abstracted to<a id="_idIndexMarker537"/> hide <a id="_idIndexMarker538"/>the complex details. This section is only an eye-opener. You can decide whether to use Lua this way or not.</p>
<h1 id="_idParaDest-237"><a id="_idTextAnchor239"/>Summary</h1>
<p>With that, we have wrapped up the final chapter of this book. In this chapter, we focused on multithreading mechanisms, preemptive multithreading and cooperative multithreading, and Lua coroutines.</p>
<p>Lua coroutines can be used without C++ for advanced Lua programming and you can hide all these details from C++. We only touched the tip of the iceberg. You can read the Lua reference manual and practice more. You can also explore more on how to use coroutines with C++ by experimenting with the related Lua library functions.</p>
<p>In this book, we implemented <code>LuaExecutor</code> progressively. Each chapter added more features to it. However, it is not perfect. For example, <code>LuaValue</code> can be improved to make it easier to work with, and <code>LuaExecutor</code> can support more table operations. You can use <code>LuaExecutor</code> as a base and adapt it to your project or implement your own in a completely different way after you have learned the mechanisms.</p>
<p>I am confident that at this point, you can make improvements and add more features that suit you the best. You can always revisit the chapters as reminders and search the Lua reference manual for what you need.</p>
</div>
</div></body></html>