- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Local Bus Interfaces
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地总线接口
- en: 'The communication between an embedded system and other systems in its vicinity
    is enabled by a few protocols. Most microcontrollers designed for embedded systems
    support the most common interfaces that control and discipline the access to serial
    lines. Some of these protocols are so popular that they have become the standard
    for wired inter-chip communication among microcontrollers, and for controlling
    electronic devices, such as sensors, actuators, displays, wireless transceivers,
    and many other peripherals. This chapter describes how these protocols work, specifically
    focusing on the implementation of the system software, through examples running
    on the reference platform. In particular, we will cover the following topics in
    this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统与其周围其他系统之间的通信通过一些协议实现。大多数为嵌入式系统设计的微控制器支持最常用的接口，这些接口控制和规范对串行线的访问。其中一些协议非常流行，以至于它们已成为微控制器之间有线芯片通信的标准，以及控制电子设备（如传感器、执行器、显示器、无线收发器以及许多其他外围设备）的标准。本章描述了这些协议的工作原理，特别是通过在参考平台上运行的示例，具体关注系统软件的实现。特别是，本章将涵盖以下主题：
- en: Introducing serial communication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍串行通信
- en: A UART-based asynchronous serial bus
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于UART的异步串行总线
- en: An SPI bus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPI总线
- en: An I2C bus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I2C总线
- en: By the end of this chapter, you will learn how to integrate the common serial
    communication protocols.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学习如何集成常见的串行通信协议。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter7](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter7).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter7](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter7)。
- en: Introducing serial communication
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍串行通信
- en: All the protocols that we will analyze in this chapter manage the access to
    a serial bus, which may consist of one or more wires, transporting the information
    in the form of electrical signals corresponding to logic levels zeros and ones,
    when associated with specific time intervals. The protocols are different in the
    way they transmit and receive information on the data bus lines. To transmit a
    byte, the transceiver encodes it as a bit sequence, which is synchronized with
    a clock. The logic values of the bit are interpreted by the receiver reading its
    value on a specific front of the clock, depending on the clock’s polarity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将分析的协议管理对串行总线的访问，该总线可能由一根或多根线组成，以对应逻辑电平零和一的电气信号形式传输信息，当与特定的时间间隔相关联时。这些协议在数据总线线上传输和接收信息的方式上有所不同。为了传输一个字节，收发器将其编码为位序列，该序列与时钟同步。位逻辑值由接收器通过在时钟的特定前端读取其值来解释，这取决于时钟的极性。
- en: 'Each protocol specifies the polarity of the clock and the bit order required
    to transmit the data, which can start with either the most significant or the
    least significant bit. For example, a system transmitting the ASCII character
    *D* over a serial line regulated by raising clock fronts, with the most significant
    bit first, would produce a signal such as the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个协议指定了时钟的极性和传输数据所需的位顺序，这可以以最高有效位或最低有效位开始。例如，一个系统通过上升沿时钟调节的串行线传输ASCII字符*D*，并且以最高有效位首先发送，将产生如下信号：
- en: '![Figure 7.1 – The logic levels of the bus on clock raise fronts are interpreted
    MSB-first into the byte value of 0x44](img/B18730_07_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 在时钟上升沿的总线逻辑电平被解释为从最高有效位（MSB）开始，转换为字节值0x44](img/B18730_07_01.jpg)'
- en: Figure 7.1 – The logic levels of the bus on clock raise fronts are interpreted
    MSB-first into the byte value of 0x44
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 在时钟上升沿的总线逻辑电平被解释为从最高有效位（MSB）开始，转换为字节值0x44
- en: We will now define the characteristics of serial communication interfaces following
    different standards. In particular, we will indicate the options available for
    clock synchronization between two endpoints exchanging data; the wiring of the
    signals to be used, which are specified by each protocol to access the physical
    media; and finally, the implementation details to program the access to the peripheral,
    which may differ across different platforms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将根据不同的标准定义串行通信接口的特性。特别是，我们将指出两个交换数据的端点之间时钟同步的选项；指定每个协议用于访问物理媒体的信号布线；最后，编程访问外围设备的实现细节，这些细节可能在不同平台上有所不同。
- en: Clock and symbol synchronization
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时钟和符号同步
- en: In order for the receiving side to understand the message, the clock must be
    synchronized between the parts. The clock synchronization may be implicit, as
    in, setting the same data rate to read and write on the bus, or achieved by sharing
    the clock line from one side using an additional line to explicitly synchronize
    the transmit data rate. Serial protocols that do not foresee shared clock lines
    are called asynchronous.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使接收方理解消息，时钟必须在各个部分之间同步。时钟同步可能是隐式的，例如，在总线上设置相同的读写数据速率，或者通过使用额外的线从一侧共享时钟线来显式同步发送数据速率。不预见共享时钟线的串行协议称为异步。
- en: Symbol synchronization should be explicit instead. As we expect to send and
    receive information in the form of bytes, the beginning of each 8-bit sequence
    should be marked either using special preamble sequences on the data line or by
    turning the clock on and off at the right time. The symbol synchronization strategy
    is defined differently by each protocol.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 符号同步应该明确。因为我们期望以字节的形式发送和接收信息，所以每个8位序列的开始应该通过在数据线上使用特殊的预同步序列或在正确的时间打开和关闭时钟来标记。每个协议定义的符号同步策略不同。
- en: Bus wiring
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总线布线
- en: The number of lines needed to establish bidirectional communication depends
    on the specific protocol too. Since one wire can only transport 1 bit of information
    in one direction at a time, to achieve full-duplex communication, a transceiver
    should connect to two different wires for transmitting and receiving data. If
    the protocol supports half-duplex communication, it should provide a reliable
    mechanism to regulate media access instead and switch between receiving and transmitting
    data on the same wire.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 建立双向通信所需的线条数量也取决于特定的协议。由于一根线一次只能在一个方向上传输1位信息，为了实现全双工通信，收发器应该连接到两根不同的线，用于发送和接收数据。如果协议支持半双工通信，它应该提供一种可靠的机制来调节媒体访问，并在同一根线上在接收和发送数据之间切换。
- en: Important note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: The two endpoints must share a common reference ground voltage, which means
    that it might be required to add one extra wire to connect the ground lines if
    the devices do not already share a common ground.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 两个端点必须共享一个共同的参考地电压，这意味着如果设备本身没有共享一个共同的地线，可能需要额外添加一根线来连接地线。
- en: Depending on the protocol, devices accessing the bus may either share a similar
    implementation and act as peers or have different roles assigned when participating
    in the communication – for example, if a master device is in charge of synchronizing
    the clock or regulating access to the media.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据协议的不同，访问总线的设备可能要么共享类似的实现并作为对等体，要么在参与通信时分配不同的角色——例如，如果主设备负责同步时钟或调节对媒体访问的控制。
- en: 'A serial protocol may foresee communication among more than two devices on
    the same bus. This may be achieved by using extra slave selection wires, one per
    slave device sharing the same bus, or by assigning logical addresses to each endpoint,
    and including the destination address for the communication in the preamble of
    each transmission. Based on these classifications, an overview of the approach
    taken by the most popular serial protocols implemented in embedded targets is
    given in the following table:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 串行协议可能预见在同一总线上进行多于两个设备的通信。这可以通过为每个共享同一总线的从设备使用额外的从设备选择线，或者通过为每个端点分配逻辑地址，并在每个传输的预同步中包含通信的目的地址来实现。基于这些分类，以下表格给出了在嵌入式目标中实现的最流行的串行协议采用的方法概述：
- en: '![](img/B18730_07.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18730_07.jpg)'
- en: The protocols that are detailed in this chapter are only the first three, as
    they are the most widely used in communicating with embedded peripherals.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍的协议只有前三个，因为它们在与嵌入式外围设备通信中最广泛使用。
- en: Programming the peripherals
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程外围设备
- en: Multiple peripherals implementing the protocols described so far are usually
    integrated into microcontrollers, which means that the associated serial bus can
    be directly connected to specific pins of the microcontrollers. The peripherals
    can be enabled through clock gating and controlled by accessing configuration
    registries mapped in the peripheral region in the memory space. The pins connected
    to serial buses must also be configured to implement the corresponding alternate
    function, and the interrupt lines involved should be configured to be handled
    in the vector table.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了之前描述的协议的多个外围设备通常集成到微控制器中，这意味着相关的串行总线可以直接连接到微控制器的特定引脚。外围设备可以通过时钟门控启用，并通过访问映射在内存空间外围区域的配置寄存器进行控制。连接到串行总线的引脚也必须配置以实现相应的备用功能，并且涉及的中断线应配置为在向量表中处理。
- en: Some microcontrollers, including our reference platform, support **Direct Memory
    Access** (**DMA**) to speed up memory operations between the peripheral and the
    physical RAM. In many cases, this feature is useful to help process the communication
    data in a shorter time frame and to improve the responsiveness of the system.
    The DMA controller can be programmed to initiate a transfer operation and trigger
    an interrupt when it completes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些微控制器，包括我们的参考平台，支持**直接内存访问**（**DMA**）以加快外围设备和物理RAM之间的内存操作。在许多情况下，此功能有助于在更短的时间内处理通信数据，并提高系统的响应性。DMA控制器可以被编程来启动传输操作，并在完成时触发中断。
- en: The interface to control the features relative to each protocol is specific
    to the functionalities exposed by the peripheral. In the next sections, the interfaces
    exposed by UART, SPI, and I2C peripherals are analyzed, and code samples tailored
    to the reference platform are provided as examples of one of the possible implementations
    for similar device drivers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 控制与每个协议相关的功能的接口是针对外围设备暴露的功能特定的。在下一节中，将分析UART、SPI和I2C外围设备暴露的接口，并提供针对参考平台的代码示例，作为类似设备驱动程序可能实现的一种可能实现的示例。
- en: UART-based asynchronous serial bus
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于UART的异步串行总线
- en: Historically used for many different purposes, thanks to the simplicity of its
    asynchronous nature, UART dates back to the origins of computing, and it is still
    a very popular circuit used in many contexts. Personal computers up to the early
    2000s included at least one RS-232 serial port, realized with a UART controller
    and the transceivers allowing to operate at higher voltages. Nowadays, the USB
    has replaced serial communication on personal computers, but host computers can
    still access TTL serial buses using USB-UART peripherals. Microcontrollers have
    one or more pairs of pins that can be associated with an internal UART controller
    and connected to a serial bus to configure a bidirectional, asynchronous, full-duplex
    communication channel toward a device connected to the same bus.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其异步特性的简单性，UART在历史上被用于许多不同的目的，它可以追溯到计算机的起源，并且仍然是在许多环境中使用的一种非常流行的电路。直到2000年代初，个人电脑至少包含一个RS-232串行端口，该端口由UART控制器和允许在更高电压下操作的收发器实现。如今，USB已经取代了个人电脑上的串行通信，但主机计算机仍然可以通过USB-UART外围设备访问TTL串行总线。微控制器有一对或多对引脚可以与内部UART控制器相关联，并连接到串行总线，以配置一个双向、异步、全双工通信通道，用于连接到同一总线的设备。
- en: Protocol description
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议描述
- en: As previously mentioned, asynchronous serial communications rely on implicit
    synchronization of the bit rate between the transmitter and the receiver in order
    to guarantee that the data is correctly processed on the receiving end of the
    communication. If the peripheral clock is fast enough to keep the device running
    at a high frequency, asynchronous serial communication may be pushed up to several
    megabits per second.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，异步串行通信依赖于发送器和接收器之间位率的隐式同步，以确保数据在通信接收端被正确处理。如果外围时钟足够快，可以保持设备以高频率运行，异步串行通信可能达到每秒几兆比特。
- en: The symbol synchronization strategy is based on the identification of the beginning
    of the transmission of every single byte on the wire. When no device is transmitting,
    the bus is in an idle state.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 符号同步策略基于识别线上每个字节传输的开始。当没有设备传输时，总线处于空闲状态。
- en: To initiate the transmission, the transceiver pulls the TX line down to the
    low logic level, for a period of time that is at least half of the bit sampling
    period depending on the bit rate. The bits composing the byte being transferred
    are then translated into logical `0` or `1` values, which are held on the TX line
    for the time corresponding to each bit, according to the bit rate. After this
    start condition is easily recognized by the receiver, the bits composing the symbol
    follow in a specific order, from the least significant bit up to the most significant
    one.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始传输，收发器将 TX 线拉低到低逻辑电平，持续的时间至少是位采样周期的一半，具体取决于位速率。随后，正在传输的字节组成位被转换为逻辑 `0` 或
    `1` 值，这些值根据位速率保持在 TX 线上，对应于每个位的时间。在此启动条件被接收器轻松识别后，符号组成位按照特定的顺序依次传输，从最低有效位到最高有效位。
- en: The number of data bits composing the symbol is also configurable. The default
    data length of 8 bits allows each symbol to be converted into a byte. At the end
    of the data, an optional parity bit can be configured to count the number of active
    bits, as a very simplistic form of a redundant check. The parity bit, if present,
    can be configured to indicate whether the number of `1` values in the symbol is
    odd or even. While returning to the idle state, 1 or 2 stop bits must be used
    to indicate the end of the symbol.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 组成符号的数据位数也是可配置的。默认的数据长度为 8 位，允许每个符号转换为字节。在数据末尾，可以配置一个可选的奇偶校验位来计算活动位的数量，作为一种非常简单的冗余校验形式。如果存在奇偶校验位，可以配置为指示符号中
    `1` 值的数量是奇数还是偶数。在返回空闲状态时，必须使用 1 或 2 个停止位来指示符号的结束。
- en: A stop bit is transmitted by pulling the signal high for the entire duration
    of a bit transmission, marking the end of the current symbol, and forcing the
    receiver to initiate receiving the next one. A 1-stop bit is the most used default;
    the 1.5- and 2-stop bit settings provide a longer inter-symbol idling interval,
    which was useful in the past to communicate with slower, less responsive hardware
    but is rarely used today.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 停止位是通过在整个位传输期间将信号拉高来传输的，标记当前符号的结束，并迫使接收器开始接收下一个符号。1 个停止位是最常用的默认设置；1.5 和 2 个停止位设置提供了更长的符号间空闲间隔，这在过去与较慢、响应较慢的硬件通信时很有用，但今天很少使用。
- en: 'The two endpoints must be aware of these settings before initiating the communication.
    Serial controllers do not normally support the dynamic detection of the symbol
    rate or of any of the settings from the device connected to the other end, and,
    for this reason, the only way to successfully attempt any serial communication
    is to program both devices on the bus using the same well-known settings. As a
    recap, these settings are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始通信之前，两个端点必须了解这些设置。串行控制器通常不支持动态检测符号速率或连接到另一端的设备设置的任何设置，因此，成功尝试任何串行通信的唯一方法是在总线上使用相同的已知设置编程两个设备。作为回顾，这些设置如下：
- en: The bit rate, expressed in bits per second
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特率，以每秒比特数表示
- en: The number of data bits in each symbol (typically 8)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个符号中的数据位数（通常是 8 位）
- en: The meaning of parity bit, if present (`O` is odd, `E` is even, and `N` is not
    present)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇偶校验位的意义，如果存在（`O` 表示奇数，`E` 表示偶数，`N` 表示不存在）
- en: The number of stop bits
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止位的数量
- en: Additionally, the sender must be configured to send 1, 1.5, or 2 stop bits at
    the end of each transmission. 1.5 and 2 stop bits were more widely used in the
    past to synchronize communication with ancient electromechanical devices. Nowadays,
    parity checks and stop bits greater than 1 are not needed for communications using
    modern transceivers and are rarely used.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，发送器必须配置为在每个传输结束时发送 1、1.5 或 2 个停止位。1.5 和 2 个停止位在过去更广泛地使用，用于与古老的机电设备同步通信。如今，对于使用现代收发器的通信，奇偶校验和超过
    1 个的停止位不再需要，并且很少使用。
- en: This group of settings is often abbreviated into something such as 115200-8-N-1
    or 38400-8-O-2 to indicate, respectively, a 115.2 Kbps serial line with 8 data
    bits per symbol, no parity and 1 stop bit, and a 38400 line with the same data
    bits, odd parity, and 2 stop bits.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这组设置通常被缩写为例如 115200-8-N-1 或 38400-8-O-2，分别表示一个 115.2 Kbps 的串行线路，每个符号有 8 个数据位，无奇偶校验和
    1 个停止位，以及一个具有相同数据位、奇数奇偶校验和 2 个停止位的 38400 线路。
- en: Programming the controller
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程控制器
- en: 'Development boards usually provide multiple UARTs, and our reference, the STM32F407,
    is not an exception. According to the manual, `UART3` can be associated with the
    PD8 (TX) and PD9 (RX) pins, which we will use in this example. The code needed
    to turn on the clock for the `D` GPIO group and set the `8` and `9` pins in alternate
    mode, with an alternate function of `7`, is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 开发板通常提供多个 UART，我们的参考，STM32F407，也不例外。根据手册，`UART3` 可以与 PD8（TX）和 PD9（RX）引脚相关联，我们将在本例中使用这些引脚。打开
    `D` GPIO 组时钟并设置 `8` 和 `9` 引脚为交替模式，交替函数为 `7` 的代码如下：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The device has its own clock-gating configuration bit in the `APB1_CLOCK_ER`
    register, at position `18`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 设备在其 `APB1_CLOCK_ER` 寄存器中有一个自己的时钟门控配置位，位于位置 `18`：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each UART controller can be accessed using registers mapped in the peripheral
    region, with fixed offsets from the UART controller base address:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 UART 控制器都可以通过映射到外设区域的寄存器来访问，这些寄存器相对于 UART 控制器基本地址有固定的偏移量：
- en: '`0`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`'
- en: '`4`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`'
- en: '`8`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`8`'
- en: '`UART_CRx` registers at offset `12`, to set the serial port parameters, enable
    interrupts and DMA, and enable and disable the transceiver'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UART_CRx` 寄存器位于偏移量 `12`，用于设置串行端口参数、启用中断和 DMA，以及启用和禁用收发器'
- en: 'In this example, we define shortcut macros to access the following registers
    for `UART3`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们定义了快捷宏来访问以下 `UART3` 的寄存器：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We define the positions in the corresponding bit fields:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了对应位字段中的位置：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `uart3_pins_setup` helper function can be called at the beginning of the
    initialization function to set up the pin. The function accepts arguments to set
    the bit rate, parity bit, and stop bits on the `UART3` port:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`uart3_pins_setup` 辅助函数可以在初始化函数的开始处调用，以设置引脚。该函数接受参数来设置 `UART3` 端口的波特率、奇偶校验位和停止位：'
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The device is turned on:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 设备已开启：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `CR1` configuration register, the bit to enable the transmitter is set:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CR1` 配置寄存器中，设置启用发送器的位：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`UART_BRR` is set to contain the divisor between the clock speed and the desired
    bit rate:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`UART_BRR` 设置为包含时钟速度和所需波特率之间的除数：'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our function also accepts a character to indicate the desired parity. The options
    are `O` or `E` for odd or even. Any other character will keep the parity disabled:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能还接受一个字符来指示所需的奇偶校验。选项为 `O` 或 `E`，分别表示奇数或偶数。任何其他字符都将禁用奇偶校验：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The number of stop bits is set according to the parameter. The configuration
    is stored using 2 bits of the register, with a value of `0` meaning 1 stop bit,
    and a value of `2` meaning 2:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据参数设置停止位的数量。配置使用寄存器的 2 位存储，值为 `0` 表示 1 个停止位，值为 `2` 表示 2 个：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The configuration is now complete. The UART can be turned on to initiate transmissions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 配置现在完成。可以开启 UART 以开始传输：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Serial data can now be transmitted on PD8 simply by copying one byte at a time
    on the `UART_DR` register.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过在 `UART_DR` 寄存器上逐字节复制一个字节来在 PD8 上传输串行数据。
- en: Hello world!
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello world!
- en: 'One of the most useful functions when developing an embedded system is to convert
    one of the available UARTs into a logging port, where debug messages and other
    information produced during the execution can be read on the host computer using
    a serial-to-USB converter:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发嵌入式系统时，最有用的功能之一是将可用的 UART 之一转换为日志端口，这样就可以在主机计算机上使用串行到 USB 转换器读取执行期间产生的调试消息和其他信息：
- en: '![Figure 7.2 – The host is connected to the serial port of the target platform
    using a converter](img/B18730_07_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 主机通过转换器连接到目标平台的串行端口](img/B18730_07_02.jpg)'
- en: Figure 7.2 – The host is connected to the serial port of the target platform
    using a converter
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 主机通过转换器连接到目标平台的串行端口
- en: 'The UART logic includes FIFO buffers in both directions. The transmit FIFO
    is fed by writing on the `UART_DR` register. To actually output data on the UART
    TX line in polling mode, we choose to check that the FIFO is empty before writing
    each character, to ensure that no more than one character is put in the FIFO at
    a time. When the FIFO is empty, the bit associated with the `TX_FIFO_EMPTY` flag
    in `UART3_SR` is set to `1` by the device. The following function shows how to
    transmit an entire string of characters passed as an argument, waiting for the
    FIFO to empty after every byte:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: UART 逻辑在两个方向上都包含 FIFO 缓冲区。通过在 `UART_DR` 寄存器上写入数据来填充发送 FIFO。在轮询模式下实际在 UART TX
    线路上输出数据时，我们选择在写入每个字符之前检查 FIFO 是否为空，以确保一次不会将超过一个字符放入 FIFO。当 FIFO 为空时，设备会将 `UART3_SR`
    中与 `TX_FIFO_EMPTY` 标志相关联的位设置为 `1`。以下函数展示了如何通过将作为参数传递的整个字符字符串传递，并在每个字节后等待 FIFO
    为空来发送：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the main program, it is possible to call this function with a pre-formatted,
    `NULL`-terminated string:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序中，可以调用此函数，传递一个预格式化、以`NULL`结尾的字符串：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the host is connected to the other endpoint of the serial bus, as a result,
    we can visualize the `Hello World!` message using a serial terminal program, such
    as `minicom`, on the host.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机连接到串行总线的另一个端点，因此，我们可以使用主机上的串行终端程序，例如`minicom`，来可视化`Hello World!`消息。
- en: By capturing the output of the PD8 pin, used as `UART_TX` on the target, and
    setting the right option for the serial decoding, we have a better idea of how
    the serial flow is parsed on the receiving side. The logic analyzer can show how
    the data bits are sampled after every start condition, and reveal the ASCII character
    associated with the byte on the wire. Logic analyzer tools are usually capable
    of decoding the bits captured on the wire, and showing each byte transmitted back
    into its ASCII format. This feature offers a quick and accurate way to verify
    that our serial communication is compliant, the time in between the consecutive
    bits respects the selected baud rate, and the content on the wire matches the
    data sent to the UART transceiver, as in the following figure, which shows our
    embedded target sending “`Hello`” from the string and passing it to the `uart3_write`
    function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过捕获用作目标`UART_TX`的PD8引脚的输出，并设置正确的串行解码选项，我们可以更好地了解接收端如何解析串行流。逻辑分析仪可以显示在每个起始条件之后如何采样数据位，并揭示与线上的字节相关的ASCII字符。逻辑分析仪工具通常能够解码在线捕获的位，并将每个传输的字节转换回ASCII格式。此功能提供了一种快速准确的方法来验证我们的串行通信是否合规，连续位之间的时间符合所选波特率，线上的内容与发送到UART收发器的数据匹配，如下面的图所示，它显示了我们的嵌入式目标从字符串发送“`Hello`”并将其传递给`uart3_write`函数。
- en: "![Figure 7.3 – Screenshot of the logic analyzer tool showing the first 5 bytes\
    \ sent by the example to the\uFEFF host using UART3](img/B18730_07_03.jpg)"
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 使用UART3发送给主机的前5个字节的逻辑分析仪工具截图](img/B18730_07_03.jpg)'
- en: Figure 7.3 – Screenshot of the logic analyzer tool showing the first 5 bytes
    sent by the example to the host using UART3
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 使用UART3发送给主机的前5个字节的逻辑分析仪工具截图
- en: newlib printf
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: newlib printf
- en: 'Writing pre-formatted strings is not the most ideal API for accessing a serial
    port to provide debugging messages. Application developers would most certainly
    prefer if the system exposed a standard C `printf` function. When the toolchain
    includes an implementation of a standard C library, it usually gives you the possibility
    to connect the standard output of the main program to a serial interface. Luckily
    enough, the toolchain in use for the reference platform allows us to link to `newlib`
    functions. Similar to what we did in [*Chapter 5*](B18730_05.xhtml#_idTextAnchor149),
    *Memory Management*, using the `malloc` and `free` functions from `newlib`, we
    provide a backend function called `_write()`, which gets the output redirected
    from the string formatted by all the calls to `printf()`. The `_write` function
    implemented here will receive all the strings pre-formatted by `printf()`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编写预格式化字符串不是访问串行端口以提供调试消息的最理想API。应用程序开发者肯定会希望系统公开一个标准的C `printf`函数。当工具链包含标准C库的实现时，它通常给你连接主程序的标准输出的可能性。幸运的是，用于参考平台的工具链允许我们链接到`newlib`函数。类似于我们在[*第5章*](B18730_05.xhtml#_idTextAnchor149)中做的，*内存管理*，使用`newlib`中的`malloc`和`free`函数，我们提供了一个后端函数叫做`_write()`，它从所有调用`printf()`格式化的字符串中获取输出。这里实现的`_write`函数将接收所有由`printf()`预格式化的字符串：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, in this case, linking with `newlib` allows us to use `printf` to produce
    messages, including its variance-argument parsing, as in this example `main()`
    function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，与`newlib`链接使我们能够使用`printf`来生成消息，包括其变长参数解析，如本例中的`main()`函数：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This second example will produce the same output as the first one, but this
    time, using the `printf` function from `newlib`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例将产生与第一个示例相同的输出，但这次使用`newlib`中的`printf`函数。
- en: Receiving data
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收数据
- en: 'To enable the receiver on the same UART, the initialization function should
    also turn on the receiver using the corresponding switch in the `UART_CR1` register:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要在相同的UART上启用接收器，初始化函数还应该通过`UART_CR1`寄存器中的相应开关打开接收器：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This ensures that the receiving side of the transceiver is enabled too. To
    read data in polling mode, blocking until a character is received, we can use
    the following function, which will return the value of the byte read:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了收发器的接收端也被启用。为了在轮询模式下读取数据，阻塞直到接收到一个字符，我们可以使用以下函数，该函数将返回读取的字节值：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This way, we can, for example, echo back to the console each character received
    from the host:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，例如，我们可以将主机接收到的每个字符回显到控制台：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Interrupt-based input/output
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于中断的输入/输出
- en: The examples in this section are based on polling the status of the UART by
    continuously checking the flags of `UART_SR`. The write operation contains a busy
    loop that can spin for several milliseconds, depending on the length of the string.
    Even worse, the read function presented earlier spins within a busy loop until
    there is data to read from the peripheral, which means that the whole system is
    hanging until new data is received. In a single-thread embedded system, returning
    to the main loop with the shortest latency possible is important to keep the system
    responsive.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例基于通过连续检查`UART_SR`的标志来轮询UART的状态。写操作包含一个忙循环，该循环可以持续数毫秒，具体取决于字符串的长度。更糟糕的是，之前提供的读取函数在忙循环中旋转，直到从外围设备读取数据，这意味着整个系统在接收到新数据之前都会挂起。在单线程嵌入式系统中，以尽可能短的延迟返回主循环对于保持系统响应性非常重要。
- en: 'The correct way to perform UART communication without blocking is by using
    the interrupt line associated with the UART to trigger actions based on the event
    received. UART can be configured to raise the interrupt signal upon multiple types
    of events. As we have seen in the previous examples, to regulate input and output
    operations, we are interested in particular in two specific events:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不阻塞的情况下执行UART通信，请使用与UART相关联的中断线来根据接收的事件触发操作。UART可以配置为在多种事件上触发中断信号。正如我们之前在示例中看到的，为了调节输入和输出操作，我们特别关注两个特定的事件：
- en: A TX FIFO empty event, allowing more data to be transmitted
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个TX FIFO空事件，允许传输更多数据
- en: A RX FIFO not-empty event, signaling the presence of newly received data
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个RX FIFO非空事件，表示有新接收的数据
- en: 'The interrupt for these two events can be enabled by setting the corresponding
    bits in `UART_CR1`. We define two helper functions with the purpose of turning
    interrupts on and off, independently:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`UART_CR1`中的相应位，可以启用这两个事件的中断。我们定义了两个辅助函数，其目的是独立地打开和关闭中断：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A service routine can be associated with the interrupt events, and then check
    the flags in `UART_SR` to identify the cause of the interrupt:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务例程可以与中断事件相关联，然后检查`UART_SR`中的标志以确定中断的原因：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The implementation of the interrupt routine depends on the specific system design.
    An RTOS may decide to multiplex access to the serial port to multiple threads
    and wake up threads waiting to access the resource. In a single-thread application,
    it is possible to add intermediate system buffers to provide non-blocking calls,
    which return immediately after copying the data from the receiving buffer, or
    to the transmitting one. The interrupt service routine fills the receiving buffer
    with new data from the bus and transmits the data from the pending buffer. Using
    appropriate structures, such as circular buffers to implement system input and
    output queues, ensures that the use of the memory assigned is optimized.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 中断例程的实现取决于特定的系统设计。RTOS可能会决定将串行端口的多路复用访问到多个线程，并唤醒等待访问资源的线程。在单线程应用程序中，可以添加中间系统缓冲区以提供非阻塞调用，这些调用在从接收缓冲区或发送缓冲区复制数据后立即返回。中断服务例程从总线上填充接收缓冲区以包含新数据，并从挂起缓冲区发送数据。使用适当的结构，例如循环缓冲区来实现系统输入和输出队列，可以确保分配的内存使用得到优化。
- en: SPI bus
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPI总线
- en: The SPI bus provides a different approach, based on master-slave communication.
    As the name suggests, the interface was initially designed to control peripherals.
    This is reflected in the design, as all the communication is always initiated
    by the master on the bus. Thanks to the full-duplex pin configuration and the
    synchronized clock, it may be much faster than asynchronous communication, due
    to the better robustness to clock skews between the systems sharing the bus. An
    SPI is widely used as a communication protocol for several different devices,
    due to its simple logic and the flexibility given by the fact that the slave does
    not have to be preconfigured to communicate at a predefined speed that matches
    the one on the master. Multiple peripherals can share the same bus, as long as
    media access strategies are defined. A common way for a master to control one
    peripheral at a time is by using separate GPIO lines to control the slave selection,
    although this does require an additional wire for each slave.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SPI总线提供了一种基于主从通信的不同方法。正如其名所示，该接口最初是为了控制外围设备而设计的。这反映在设计上，因为所有通信总是由总线上的主设备发起。得益于全双工引脚配置和同步时钟，它可能比异步通信快得多，因为对共享总线的系统之间的时钟偏移具有更好的鲁棒性。SPI因其简单的逻辑和从设备无需预先配置以与主设备上预定义的速度通信的灵活性而被广泛用作多种不同设备的通信协议。只要定义了媒体访问策略，多个外围设备可以共享同一总线。主设备通常通过使用单独的GPIO线来控制从设备选择来控制一次控制一个外围设备，尽管这确实需要为每个从设备额外一根线。
- en: Protocol description
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议描述
- en: 'The configuration of the SPI transceiver is very flexible. Usually, a transceiver
    on a microcontroller is able to act as a master as well as a slave. A few predefined
    settings must be known in advance and shared between the master and all the slaves
    on the same bus:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: SPI收发器的配置非常灵活。通常，微控制器上的收发器既能作为主设备也能作为从设备。必须事先知道一些预定义的设置，并在同一总线上共享主设备和所有从设备之间：
- en: The clock polarity, indicating whether the clock tick corresponds to a raising
    or a falling edge of the clock
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟极性，指示时钟滴答对应于时钟的上升沿还是下降沿
- en: The clock phase, indicating whether the clock idle position is high or low
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟相位，指示时钟空闲位置是高电平还是低电平
- en: The length of the data packet, any value between 4 and 16 bits
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包的长度，介于4到16位之间的任何值
- en: The bit order, indicating whether the data is transmitted starting from the
    most significant bit or the least significant bit
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位顺序，指示数据是从最高有效位开始传输还是从最低有效位开始传输
- en: Since the clock is synchronous and imposed by the master at all times, the SPI
    does not have a predefined frequency of operation, although using too high a speed
    might not work with all peripherals and microcontrollers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于时钟是同步的，并且始终由主设备强制，因此SPI没有预定义的操作频率，尽管使用过高的速度可能无法与所有外围设备和微控制器一起工作。
- en: 'SPI communication toward a slave is disabled until the master initiates a transaction.
    At the beginning of each transaction, the master selects the slave by activating
    its slave-select line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在主设备启动事务之前，SPI与从设备的通信是禁用的。在每个事务的开始，主设备通过激活其从设备选择线来选择从设备：
- en: '![Figure 7.4 – An additional signal may be used to select a specific slave
    on the bus](img/B18730_07_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 可以使用一个额外的信号来选择总线上特定的从设备](img/B18730_07_04.jpg)'
- en: Figure 7.4 – An additional signal may be used to select a specific slave on
    the bus
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 可以使用一个额外的信号来选择总线上特定的从设备
- en: To initiate the communication, the master must activate the clock, and may send
    a command sequence to the slave on the MOSI line. When the clock is detected,
    the slave can immediately start transferring bytes in the opposite direction using
    the MISO line.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动通信，主设备必须激活时钟，并且可以在MOSI线上向从设备发送命令序列。当检测到时钟时，从设备可以立即开始使用MISO线向相反方向传输字节。
- en: Even if the master has finished transmitting, it must comply with the protocol
    implemented by the slave and permit it to reply by keeping the clock alive for
    the duration of the transaction. The slave is given a predefined number of byte
    slots to communicate with the master.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使主设备已经完成传输，它也必须遵守从设备实现的协议，并允许它在事务期间通过保持时钟活跃来回复。从设备被赋予一个预定义的字节数来与主设备通信。
- en: In order to keep the clock alive even when there is no data to transfer to the
    slave, the master can keep sending *dummy* bytes through the MOSI line, which
    are ignored by the slave. In the meantime, the slave is allowed to send data through
    the MISO line, as long as the master ensures that the clock keeps running. Unlike
    UART, in the master-slave communication model implemented in the SPI, the slaves
    can never spontaneously initiate SPI communication, as the master is the only
    device on the bus allowed to transmit a clock. Each SPI transaction is self-contained,
    and at the end, the slave is deselected by turning off the corresponding slave-select
    signal.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了即使在没有数据要传输给从设备的情况下也能保持时钟活跃，主设备可以通过MOSI线发送*哑字节*，这些字节会被从设备忽略。同时，只要主设备确保时钟持续运行，从设备就可以通过MISO线发送数据。与UART不同，在SPI中实现的从主通信模型中，从设备永远不会自发地启动SPI通信，因为主设备是唯一允许在总线上发送时钟的设备。每个SPI事务都是自包含的，在结束时，通过关闭相应的从设备选择信号来取消从设备的选中状态。
- en: Programming the transceiver
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程收发器
- en: On the reference board, an accelerometer is connected as a slave to the `SPI1`
    bus, so we can examine how to implement the master side of the communication on
    the microcontroller by configuring the transceiver and executing a bidirectional
    transaction toward the peripheral.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在参考板上，一个加速度计作为从设备连接到`SPI1`总线，因此我们可以通过配置收发器并执行一个双向事务到外围设备来检查如何在微控制器上实现通信的主设备部分。
- en: 'The `SPI1` bus has its configuration registers mapped in the peripherals region:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`SPI1`总线在其配置寄存器映射到外设区域：'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The peripheral exposes a total of four registers:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 外设公开了总共四个寄存器：
- en: Two bit-field configuration registers
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个位字段配置寄存器
- en: One status register
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个状态寄存器
- en: One bidirectional data register
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个双向数据寄存器
- en: It is clear that the interface is similar to that of the UART transceiver, as
    the configuration of the communication parameters goes through the `SPI_CRx` registers,
    the status of the FIFO can be monitored by looking at `SPI_SR`, and `SPI_DR` can
    be used to read and write data to the serial bus.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，接口与UART收发器类似，因为通信参数的配置是通过`SPI_CRx`寄存器进行的，FIFO的状态可以通过查看`SPI_SR`来监控，而`SPI_DR`可以用来读取和写入串行总线上的数据。
- en: 'The value for the configuration register CR1 contains the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 配置寄存器CR1的值包含以下内容：
- en: The clock phase, 0 or 1, in bit 0
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟相位，0或1，在位0
- en: The clock polarity in bit 1
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟极性在位1
- en: The SPI master mode flag in bit 2
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位2中的SPI主模式标志
- en: The bit rate scaling factor in bits 3-5
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位率缩放因子在位3-5
- en: The SPI enable flag in bit 6
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位6中的SPI使能标志
- en: Other configuration parameters, such as the word length, LSB-first, and other
    flags, which will not be used in this example, as the default will be kept for
    these parameters
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他配置参数，如字长、LSB-first和其他标志，在这个例子中不会使用，因为这些参数将保持默认值
- en: The `CR2` configuration register contains the flags to enable the interrupt
    events and the DMA transfers, as well as the **Slave Select Output Enable** (**SSOE**)
    flag, which is relevant in this example.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`CR2`配置寄存器包含启用中断事件和DMA传输的标志，以及与这个例子相关的**从设备选择输出使能**（**SSOE**）标志。'
- en: The `SPI1_SR` status register is similar to the UART status register in the
    previous section, as it contains flags to determine whether the transmit FIFO
    is empty, and when the FIFO on the receiving side is not empty, to regulate the
    phases of the transfer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`SPI1_SR`状态寄存器与上一节中的UART状态寄存器类似，因为它包含确定发送FIFO是否为空的标志，以及当接收侧的FIFO不为空时，调节传输的相位。'
- en: 'The bits corresponding to the flags that are used in this example are defined
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中使用的标志对应的位定义为以下：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The RCC controls the clock and the reset lines toward the `SPI1` transceiver
    connected to the `APB2` bus:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: RCC控制着指向连接到`APB2`总线的`SPI1`收发器的时钟和复位线：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The transceiver can be reset by sending a reset pulse from the RCC:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从RCC发送复位脉冲可以重置收发器：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The PA5, PA6, and PA7 pins can be associated with the `SPI1` transceiver by
    setting the appropriate alternate function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: PA5、PA6和PA7引脚可以通过设置适当的备用功能与`SPI1`收发器相关联：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The additional pin connected to the “chip select” line of the accelerometer
    is PE3, which is configured as output, with a pull-up internal resistor. The logic
    of this pin is active low so that a logical zero will turn the chip on:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到加速度计“片选”线的附加引脚是PE3，它被配置为输出，并带有上拉内部电阻。该引脚的逻辑是低电平有效，因此逻辑零将打开芯片：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The initialization of the transceiver begins with the configuration of the
    four pins involved. The clock gate is then activated, and the transceiver receives
    a reset via a pulse through the RCC:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 收发器的初始化从配置涉及的四个引脚开始。然后激活时钟门，并通过RCC通过脉冲接收复位信号：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The default parameters (MSB-first, 8-bit word length) are left untouched. The
    bit rate scaling factor of this controller is expressed in powers of 2, starting
    with `2` corresponding to a bit field value of `0`, and doubling at each increment.
    A generic driver should calculate the correct scaling factor, according to the
    desired clock rate and the peripheral clock frequency. In this simple case, we
    enforce a hardcoded scaling factor of 64, corresponding to the value `5`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数（MSB-first，8位字长）保持不变。此控制器的比特率缩放因子以2的幂表示，从`2`开始，对应于位字段值为`0`，每次增加时翻倍。通用驱动程序应根据所需的时钟速率和外设时钟频率计算正确的缩放因子。在这个简单的情况下，我们强制使用硬编码的缩放因子64，对应于值`5`。
- en: '`SPI1_CR1` is then set as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`SPI1_CR1`设置为以下内容：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we set the bit corresponding to the `SSOE` flag in `SPI1_CR2`, and
    the transceiver is enabled:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`SPI1_CR2`中设置对应于`SSOE`标志位的位，并启用收发器：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Read and write operations can now begin, as both the master and slave SPI controllers
    are ready to perform the transactions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 读写操作现在可以开始了，因为主从SPI控制器都已准备好执行事务。
- en: SPI transactions
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SPI事务
- en: The read and write functions represent the two different phases of the SPI transaction.
    Most SPI slave devices are capable of communicating using a full-duplex mechanism
    so that bytes are exchanged in both directions while the clock is active. During
    each interval, a byte is transmitted in both directions, using the MISO and MOSI
    lines independently.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 读写函数代表了SPI事务的两个不同阶段。大多数SPI从设备都能够使用全双工机制进行通信，这样在时钟活跃时，字节可以在两个方向上交换。在每一个间隔期间，一个字节在两个方向上独立地通过MISO和MOSI线进行传输。
- en: A common strategy, implemented by many slaves, consists of accessing registers
    for read and write operations in the slave devices, by using well-known command
    handles that are documented in the device’s datasheet.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 许多从设备实现的一种常见策略是通过使用设备数据表中记录的已知命令处理程序，在从设备中访问寄存器以进行读写操作。
- en: 'The STM32F407DISCOVERY board has an accelerometer connected to the `SPI1` bus,
    which responds to predefined commands accessing specific registers in the device
    memory for reading or writing. In these cases, the read and write operations are
    performed sequentially: during the first interval, the master transmits the command
    handle, while the device has nothing to transmit, then the actual bytes are transmitted
    in either direction at subsequent intervals.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F407DISCOVERY板上连接了一个加速度计到`SPI1`总线，该加速度计响应预定义的命令，访问设备内存中的特定寄存器以进行读写。在这些情况下，读写操作是顺序执行的：在第一个间隔期间，主设备传输命令处理程序，而设备没有要传输的内容，然后在随后的间隔中，实际字节在两个方向上传输。
- en: The example operation described here consists of reading the `WHOAMI` register
    in the accelerometer, using the `0x8F` command handle. The peripheral should respond
    with 1 byte containing the `0x3B` value, which correctly identifies the device
    and proves that the SPI communication is working correctly. However, during the
    transmission of the command byte, the device has nothing to transmit yet, so the
    result of the first read operation can be discarded. Similarly, after sending
    the command, the master has nothing else to communicate to the slave, so it outputs
    a `0xFF` value on the MOSI line while reading the byte transmitted by the slave
    through the MISO line at the same time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的示例操作包括使用`0x8F`命令处理程序读取加速度计中的`WHOAMI`寄存器。外围设备应该响应包含`0x3B`值的1个字节，这正确地识别了设备并证明了SPI通信是正常工作的。然而，在传输命令字节期间，设备还没有要传输的内容，因此第一次读操作的结果可以被丢弃。同样，在发送命令后，主设备没有其他要传达给从设备的内容，因此它在读取从设备通过MISO线传输的字节的同时，在MOSI线上输出`0xFF`值。
- en: 'The steps to perform to successfully perform a 1-byte read on this specific
    device are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在此特定设备上成功执行1字节读操作所需的步骤如下：
- en: Turn on the slave by pulling down the slave-select signal.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过拉低从设备选择信号来开启从设备。
- en: Send a byte containing the code for the 1-byte read operation.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一个包含1字节读操作代码的字节。
- en: Send 1 dummy byte while the slave transfers the reply using the clock.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从设备使用时钟传输回复时，发送1个空字节。
- en: Read back the value transferred from the slave during the second interval.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二次间隔期间读取从设备传输的值。
- en: Turn off the slave by pulling the slave-select signal back up.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将从设备选择信号拉高来关闭从设备。
- en: 'To do so, we define blocking read and write functions as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们定义如下阻塞读取和写入函数：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The read operation waits until the `RX_NOTEMPTY` flag is enabled on `SPI1_SR`
    before transferring the contents of the data register. The transmit function instead
    transfers the value of the byte to transmit onto the data register, and then polls
    for the end of the operation by waiting for the `TX_EMPTY` flag.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 读取操作等待`RX_NOTEMPTY`标志在`SPI1_SR`上启用，然后传输数据寄存器的内容。发送函数将传输的字节值传输到数据寄存器，然后通过等待`TX_EMPTY`标志来轮询操作结束。
- en: 'The two operations can now be concatenated. The master has to explicitly send
    2 data bytes in total, so our main application can query the accelerometer identification
    register by doing the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作现在可以连接起来。主设备必须明确发送总共2个数据字节，因此我们的主要应用可以通过以下方式查询加速度计识别寄存器：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is what happens on the bus:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在总线上发生的情况：
- en: During the first write, the command `0x8F` is sent to MOSI.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一次写入时，将命令`0x8F`发送到MOSI。
- en: The value read using the first `spi1_read` function is the dummy bit that the
    slave has put into MISO while listening for the incoming command. The value obtained
    has no meaning in this particular case – therefore, it is discarded.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第一个`spi1_read`函数读取的值是从设备在监听传入命令时放入MISO的空字节位。在这个特定情况下，获得的值没有意义 – 因此，它被丢弃。
- en: The second write puts the dummy bit on the MOSI line, as the master does not
    have anything else to transmit. This forces the clock generation for the second
    byte, which is needed by the slave to reply to the command.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次写入将空字节位放在MOSI线上，因为主设备没有其他要传输的内容。这强制生成第二个字节的时钟，这是从设备回复命令所需的。
- en: The second read processes the reply transferred using the MISO line during the
    write of the dummy byte from the master. The value obtained in this second transaction
    is a valid reply from the slave, according to the description of the command in
    the documentation.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次读取处理主设备在写入空字节时通过MISO线传输的回复。在这个第二次事务中获得的值是来自从设备的有效回复，根据文档中命令的描述。
- en: 'Looking at the serial transaction with the logic analyzer, we can clearly distinguish
    the two phases, and the alternate relevant content – first, on MOSI to transmit
    the command, and then on MISO to receive the reply:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逻辑分析仪查看串行事务，我们可以清楚地区分两个阶段，以及相关的交替内容 – 首先，在MOSI上发送命令，然后是在MISO上接收回复：
- en: '![Figure 7.5 – A bidirectional SPI transaction, containing a request from the
    master and a reply from the slave (from top to bottom: SPI1_MISO, SPI1_MOSI, SLAVE_SELECT,
    and SPI1_CLOCK)](img/B18730_07_05.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 双向SPI事务，包含主设备的请求和从设备的回复（从上到下：SPI1_MISO，SPI1_MOSI，SLAVE_SELECT，和SPI1_CLOCK）](img/B18730_07_05.jpg)'
- en: 'Figure 7.5 – A bidirectional SPI transaction, containing a request from the
    master and a reply from the slave (from top to bottom: SPI1_MISO, SPI1_MOSI, SLAVE_SELECT,
    and SPI1_CLOCK)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 双向SPI事务，包含主设备的请求和从设备的回复（从上到下：SPI1_MISO，SPI1_MOSI，SLAVE_SELECT，和SPI1_CLOCK）
- en: Once again, using blocking operations with a busy loop is a very bad practice.
    The reason why it is shown here is to explain the primitive operations needed
    to successfully complete bidirectional SPI transactions. In a real embedded system,
    it is always recommended to use interrupt-based transfers to ensure that the CPU
    is not busy looping while waiting for the transfer to complete. SPI controllers
    provide interrupt signals to indicate the state of the FIFO buffers of the controller,
    in order to synchronize the SPI transaction with the actions required upon data
    transfers in either direction.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，使用带有忙循环的阻塞操作是一种非常不好的做法。这里之所以展示它，是为了解释成功完成双向SPI事务所需的原始操作。在实际嵌入式系统中，始终建议使用基于中断的传输，以确保CPU在等待传输完成时不会被忙循环占用。SPI控制器提供中断信号，以指示控制器FIFO缓冲区的状态，以便将SPI事务与数据在任一方向上传输时所需采取的操作同步。
- en: Interrupt-based SPI transfers
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于中断的SPI传输
- en: The interface to enable the interrupt for the SPI transceiver is in fact very
    similar to that of UART as seen in the previous section. In order for non-blocking
    transactions to be correctly implemented, they have to be split between their
    read and write phases to allow events to trigger the associated actions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用于启用SPI收发器中断的接口实际上与上一节中看到的UART接口非常相似。为了正确实现非阻塞事务，必须在它们的读和写阶段之间进行拆分，以便允许事件触发相关操作。
- en: 'Setting these two bits in the `SPI1_CR2` register will enable the interrupt
    trigger upon an empty transmit FIFO and a non-empty receive FIFO, respectively:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SPI1_CR2`寄存器中设置这两个位将分别启用在发送FIFO为空和接收FIFO非空时触发中断：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The associated service routine, included in the interrupt vector, can still
    peek at the values in `SPI1_SR` to advance the transaction to the next phase:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在中断向量中的相关服务例程仍然可以查看`SPI1_SR`中的值，以推进事务到下一阶段：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once again, the implementation of the top half of the interrupt is left to the
    reader, as it depends on the API that the system is required to implement, the
    nature of the transactions, and their impact on the responsiveness of the system.
    Short, high-speed SPI transactions, however, may be short and scattered in time
    so that even implementing blocking operations has a smaller influence on the system
    latency.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，中断上半部分的实现留给读者来完成，因为它依赖于系统需要实现的API、事务的性质以及它们对系统响应性的影响。然而，短而高速的SPI事务可能会在时间上分散且短暂，以至于即使实现阻塞操作对系统延迟的影响也较小。
- en: I2C bus
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I2C总线
- en: The third serial communication protocol analyzed in this chapter is I2C. From
    the communication strategy point of view, this protocol shares some similarities
    with SPI. However, the default bit rate for I2C communication is much lower, as
    the protocol privileges lower-power consumption over throughput.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分析的第三种串行通信协议是I2C。从通信策略的角度来看，该协议与SPI有一些相似之处。然而，I2C通信的默认比特率要低得多，因为该协议优先考虑低功耗而不是吞吐量。
- en: 'The same two-wire bus can accommodate multiple participants, both masters and
    slaves, and there is no need for extra signals to physically select the slave
    of the transaction, as slaves have fixed logic addresses assigned:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的双线总线可以容纳多个参与者，包括主设备和从设备，并且不需要额外的信号来物理选择事务的从设备，因为从设备有固定的逻辑地址分配：
- en: '![Figure 7.6 – I2C bus with three slaves and external pull-up resistors](img/B18730_07_06.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 带有三个从机和外部上拉电阻的I2C总线](img/B18730_07_06.jpg)'
- en: Figure 7.6 – I2C bus with three slaves and external pull-up resistors
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 带有三个从机和外部上拉电阻的I2C总线
- en: One wire transports the clock generated by the master, and the other is used
    as a bidirectional synchronous data path. This is possible thanks to the unique
    mechanism of arbitration of the channel, which relies on the electronic design
    of the transceivers and may deal with the presence of multiple masters on the
    same bus in a very clean way.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一根线传输由主设备生成的时钟，另一根用作双向同步数据路径。这是由于通道仲裁的独特机制，该机制依赖于收发器的电子设计，并且可以非常干净地处理同一总线上存在多个主设备的情况。
- en: The two signals must be connected to the high-level voltage of the bus (typically
    3.3 V) using pull-up resistors. The controllers never drive the signal high and
    instead, they let it float to its default value imposed by the pull-ups while
    transmitting ones. As a consequence, logic level zero is always dominant; if any
    of the devices connected to the bus enforce a zero by pulling the line down, all
    the devices will read the line as low, no matter how many other senders are keeping
    the logic level 1 on the bus. This allows the bus to be controlled by multiple
    transceivers at the same time, and transmit operations can be coordinated by initiating
    new transactions only when the bus becomes available. In this section, we will
    see an introduction to the protocol, in order to introduce the software tools
    used to manage the I2C controller peripherals. More information on the I2C bus
    communication and the related documentation can be found at [https://www.i2c-bus.org/](https://www.i2c-bus.org/).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个信号必须通过上拉电阻连接到总线的较高电压（通常是3.3V）。控制器从不驱动信号到高电平，而是让它在传输1时通过上拉电阻浮动到其默认值。因此，逻辑电平零始终占主导地位；如果任何连接到总线的设备通过拉低线路来强制零，那么所有设备都将读取该线路为低电平，无论有多少其他发送器在总线上保持逻辑电平1。这使得总线可以由多个收发器同时控制，并且可以通过仅在总线可用时启动新事务来协调传输操作。在本节中，我们将介绍协议，以便介绍用于管理I2C控制器外设的软件工具。有关I2C总线通信和相关文档的更多信息，请参阅[https://www.i2c-bus.org/](https://www.i2c-bus.org/)。
- en: Protocol description
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议描述
- en: The synchronization between the master and slave is achieved by a recognizable
    **START condition** and a **STOP condition**, which determine the beginning and
    the end of a transaction, respectively. The bus is initially idle, with both signals
    at the high logic state when all the participants are idling.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 主从设备之间的同步是通过一个可识别的**START条件**和一个**STOP条件**来实现的，分别确定事务的开始和结束。总线最初处于空闲状态，当所有参与者都在空闲时，两个信号都处于高逻辑状态。
- en: The `START` condition is the only case when `STOP` condition can be identified
    by the SDA transaction from a low to a high level, while the SCL remains high.
    After a `STOP` condition, the bus is idle again, and initiating communication
    is only possible if a new `START` condition is transmitted.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`START`条件是唯一一个可以通过SDA事务从低电平到高电平来识别`STOP`条件的情况，而SCL保持高电平。在`STOP`条件之后，总线再次空闲，只有当发送新的`START`条件时，才能启动通信。'
- en: 'A master sends a `START` condition by pulling SDA and SCL low in this order.
    A frame is composed of nine clock periods. After the edge of each clock pulse
    is raised, the level of SDA does not change until the clock is low again. This
    allows us to transmit 1 frame of 8 bytes in the first 8 clock raise fronts. During
    the last clock pulse, the master does not drive the SDA line, which is then held
    high by the pull-up resistor. Any receiver that wants to acknowledge the reception
    of the frame can drive the signal low. This condition on the ninth clock pulse
    is known as **ACK**. If no receiving device acknowledges the frame, SDA remains
    high, and the sender understands that the frame did not reach the intended destination:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 主设备通过按此顺序将SDA和SCL拉低来发送一个`START`条件。一个帧由九个时钟周期组成。在每个时钟脉冲的边缘上升后，SDA的电平不会改变，直到时钟再次变低。这允许我们在前8个时钟上升沿中传输1帧8字节。在最后一个时钟脉冲期间，主设备不驱动SDA线，此时由上拉电阻将其保持在高电平。任何想要确认帧接收的接收器都可以驱动信号变低。这个在第9个时钟脉冲上的条件被称为**ACK**。如果没有接收设备确认帧，SDA保持高电平，发送器理解到帧没有达到预期的目的地：
- en: '![Figure 7.7 – A single-byte I2C transaction on the bus, with the correct START
    and STOP conditions and the ACK flag set by the receiver](img/B18730_07_07.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 总线上的单字节I2C事务，具有正确的START和STOP条件以及由接收器设置的ACK标志](img/B18730_07_07.jpg)'
- en: Figure 7.7 – A single-byte I2C transaction on the bus, with the correct START
    and STOP conditions and the ACK flag set by the receiver
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 总线上的单字节I2C事务，具有正确的START和STOP条件以及由接收器设置的ACK标志
- en: A transaction consists of two or more frames and is always initiated by a device
    operating in master mode. The first frame of each transaction is called the **address
    frame** and contains the address and the mode for the next operation. All the
    subsequent frames in the transaction are data frames, containing 1 byte each.
    The master decides how many frames compose the transaction and the direction of
    the data transfer by keeping the transaction active for the desired amount of
    frames before enforcing a **STOP condition**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一笔交易由两个或多个帧组成，并且始终由处于主模式的设备发起。每笔交易的第一帧被称为**地址帧**，其中包含下一个操作的地址和模式。交易中的所有后续帧都是数据帧，每个数据帧包含1个字节。主设备通过在执行**停止条件**之前保持交易活跃一定数量的帧数来决定交易由多少帧组成以及数据传输的方向。
- en: Slave devices have fixed 7-bit addresses where they can be contacted using the
    bus. A slave that notices a `START` condition on the bus must listen for the address
    frame and compare it with its address. If the address matches, the address frame
    must be acknowledged by pulling the SDA line low during the ninth clock pulse
    within the transmission of the frame.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从设备具有固定的7位地址，可以通过总线与之通信。当从设备在总线上检测到**启动条件**时，它必须监听地址帧并将其与自己的地址进行比较。如果地址匹配，必须在帧传输过程中的第九个时钟脉冲期间将SDA线拉低来确认地址帧。
- en: 'Data is always transferred with the leading **Most Significant Bit** (**MSB**),
    and the format for the address frame is the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 数据始终以**最高有效位**（**MSB**）为前缀进行传输，地址帧的格式如下：
- en: '![Figure 7.8 – Format of the address frame containing a destination 7-bit address
    and the R/W̅ flag](img/B18730_07_08.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 包含目标7位地址和R/W̅标志的地址帧格式](img/B18730_07_08.jpg)'
- en: Figure 7.8 – Format of the address frame containing a destination 7-bit address
    and the R/*W̅* flag
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 包含目标7位地址和R/*W̅*标志的地址帧格式
- en: The preceding diagram shows the format used by the address frame. The *R/W̅*
    bit is set by the master to indicate the direction of the transaction. *R/W̅*
    reads as read, not write, meaning that a value of `0` indicates a write operation,
    and a value of `1` indicates a read operation. Depending on the value of this
    bit, the data bytes following the transactions are either flowing toward the slave
    (a write operation) or from the selected slave to the master (a read operation).
    In a read operation, the direction of the ACK bit is also inverted for the data
    frames following the selection of the slave, and the master is supposed to acknowledge
    each frame received within the transaction. The master can decide to abort the
    transmission at any time by not pulling down the ACK bit on the last frame, and
    enforcing a `STOP` condition afterward.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了地址帧使用的格式。*R/W̅*位由主设备设置以指示交易的方向。*R/W̅*读作读取，而不是写入，这意味着`0`值表示写入操作，而`1`值表示读取操作。根据此位的值，交易后的数据字节要么流向从设备（写入操作），要么从选定的从设备流向主设备（读取操作）。在读取操作中，ACK位的方向也会在选定从设备后的数据帧中反转，并且主设备应确认交易中接收到的每个帧。主设备可以选择在任何时候通过不在最后一个帧上拉低ACK位来终止传输，并在之后执行`停止条件`。
- en: The transaction continues after the transfer of the address frame, and the data
    can be transferred using subsequent data frames, each containing 1 byte, that
    can be acknowledged by the receiver. If the value of the *R/W̅* bit in the address
    frame is set to `0`, the master intends to initiate a write operation. Once the
    slave has acknowledged the address frame by recognizing itself as the destination,
    it is ready to receive data, and acknowledges data frames, until the master sends
    the `STOP` condition.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输地址帧之后，交易继续进行，数据可以通过后续的数据帧进行传输，每个数据帧包含1个字节，并且可以被接收器确认。如果地址帧中的*R/W̅*位设置为`0`，则主设备意图发起一个写入操作。一旦从设备通过识别自己为目标地址来确认地址帧，它就准备好接收数据，并确认数据帧，直到主设备发送`停止条件`。
- en: The I2C protocol specifies that if a `START` condition is repeated at the end
    of a transaction, instead of sending the `STOP` condition, a new transaction can
    be started right away without setting the bus to its idling state. A repeated
    `START` condition ensures that two or more transactions can be performed on the
    same bus without interruptions, for example, preventing another master from starting
    a communication between them.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: I2C 协议规定，如果在事务结束时重复 `START` 条件，而不是发送 `STOP` 条件，可以直接开始新的交易，而不需要将总线设置为空闲状态。重复的
    `START` 条件确保可以在同一总线上执行两个或更多事务而不会中断，例如，防止另一个主设备在他们之间开始通信。
- en: A less popular format foresees 10-bit addresses for the slaves. 10-bit addresses
    are an extension of the standard, introduced at a later time, that provide compatibility
    with 7-bit addressable devices on the same bus. The address is selected using
    2 consecutive frames, and the first 5 bits, `11110` to indicate the selection
    of a 10-bit address. As per the protocol specification, addresses starting with
    `0000` or `1111` are reserved and must not be used by slaves. In the 10-bit format,
    the most significant 2 bits are contained in **A1** and **A0** of the first frame,
    while the second frame contains the remaining 8 bits. The *R/W̅* bit keeps its
    position in the first frame. This addressing mechanism is not very common, as
    only a few slave devices support it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不太流行的格式预计从设备有 10 位地址。10 位地址是标准的扩展，在后来引入，以与同一总线上可寻址的 7 位地址设备兼容。地址是通过使用 2 个连续帧来选择的，第一个
    5 位是 `11110`，以指示选择 10 位地址。根据协议规范，以 `0000` 或 `1111` 开头的地址是保留的，并且从设备不得使用。在 10 位格式中，最高两位位包含在第一个帧的
    **A1** 和 **A0** 中，而第二个帧包含剩余的 8 位。*R/W̅* 位在第一个帧中保持其位置。这种寻址机制并不常见，因为只有少数从设备支持它。
- en: Clock stretching
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时钟拉伸
- en: We have observed that the master is the only one driving the SCL signal during
    I2C transactions. This is always true, except when the slave is not yet ready
    to transmit the requested data from the master. In this particular case, the slave
    may decide to delay the transaction by keeping the clock line pulled low, which
    results in the transaction being put on hold. The master recognizes its inability
    to oscillate the clock, as releasing the SCL signal to a floating state does not
    result in a change to a high logic level on the bus. The master will keep trying
    to release the SCL signal to its natural high position until the requested data
    is finally available on the slave, which eventually releases the hold on the line.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到，在 I2C 事务中，主设备是唯一驱动 SCL 信号的设备。这始终是正确的，除非从设备尚未准备好从主设备传输请求的数据。在这种情况下，从设备可能会决定通过保持时钟线处于低电平来延迟交易，这会导致交易被挂起。主设备意识到其无法振荡时钟，因为释放
    SCL 信号到浮空状态不会导致总线上逻辑电平变为高电平。主设备将继续尝试将 SCL 信号释放到其自然的高电平位置，直到从设备最终提供所需的数据，从而释放对线的锁定。
- en: 'The transmission can now resume after being kept on hold for an indefinite
    amount of time, and the master is still expected to produce the nine clock pulses
    to conclude the transmission. Because no more frames are expected within this
    transaction, the master does not pull the ACK bit low in the end, and sends the
    `STOP` condition instead to correctly complete the transaction:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在被无限期挂起后，传输现在可以恢复，并且仍然期望主设备产生九个时钟脉冲以完成传输。因为在这个事务中不再期望有更多帧，所以主设备在最后不会将 ACK 位拉低，而是发送
    `STOP` 条件以正确完成交易：
- en: '![Figure 7.9 – I2C read transaction with the reply frame delayed by the slave
    using the clock-stretching technique](img/B18730_07_09.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 使用时钟拉伸技术延迟响应帧的 I2C 读取事务](img/B18730_07_09.jpg)'
- en: Figure 7.9 – I2C read transaction with the reply frame delayed by the slave
    using the clock-stretching technique
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 使用时钟拉伸技术延迟响应帧的 I2C 读取事务
- en: Even though not all devices support clock stretching, this mechanism is useful
    to complete transactions when the requested data is slightly late. Clock stretching
    is a very unique feature of I2C, making it a very versatile protocol to communicate
    with sensors and other input peripherals. Clock stretching is very important to
    communicate with slower devices that cannot provide the values to complete the
    transaction in time. It is advisable that this feature is correctly supported
    by a master device that is designed to communicate with generic I2C slaves. On
    the slave side, to enforce clock stretching, the device must provide a hardware
    configuration that allows us to keep the SCL line at a logical low value until
    it is ready again. This means that the SCL line must be bidirectional in this
    particular case, and the slave should be designed to access it to enforce a pull-down
    to keep the transaction alive while preparing the transfer of the next frame.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管并非所有设备都支持时钟拉伸，但这种机制在请求的数据略微延迟时完成事务非常有用。时钟拉伸是I2C的一个非常独特的特性，使其成为与传感器和其他输入外围设备通信的非常灵活的协议。与无法及时提供值以完成事务的较慢设备通信时，时钟拉伸非常重要。建议由设计用于与通用I2C从设备通信的主设备正确支持此功能。在从设备端，为了强制执行时钟拉伸，设备必须提供硬件配置，允许我们将SCL线保持在逻辑低电平，直到它再次准备好。这意味着在这种情况下，SCL线必须是双向的，从设备应该被设计为访问它，以强制下拉以保持事务活跃，同时准备下一帧的传输。
- en: Multiple masters
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个主设备
- en: I2C offers a deterministic mechanism to detect and react to the presence of
    multiple masters on the bus, which is, again, based on the electrical property
    of the SDA line.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: I2C提供了一种确定性的机制来检测和响应总线上的多个主设备的存在，这同样基于SDA线的电气特性。
- en: Before initiating any communication, the master ensures that the bus is available
    by sensing the SDA and SCL lines. The way the `START` condition is designed can
    already rule out most of the conflicts. Concurrent start conditions can be interrupted
    whenever the SDA line is sensed low in the initial grace time between the two
    edges. This mechanism alone does not prevent two I2C masters from accessing the
    channel at the same time, because conflicts are still possible due to the propagation
    time of the signal across the wire.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何通信之前，主设备通过检测SDA和SCL线来确保总线可用。`START`条件的设计方式本身就可以排除大多数冲突。当在两个边缘之间的初始宽限期内在SDA线上检测到低电平时，可以随时中断并发启动条件。仅此机制本身并不能防止两个I2C主设备同时访问通道，因为由于信号在电线上的传播时间，冲突仍然可能发生。
- en: Two master devices that initiate a transaction at the same time continuously
    compare the status of the line, after each bit has been transmitted. In the case
    of two masters perfectly synchronized for two different transmissions, the first
    bit with a different value on the two sources will only be noticed by the master
    transmitting a `1` value, because the expected value is not reflected by the actual
    line status. That master aborts the transaction immediately, and the transmitter
    can detect the error as a conflict on the network, which, in this context, means
    that the arbitration was lost in favor of another master. Meanwhile, the other
    master will not notice anything, and neither will the slaves, because the transaction
    will continue despite the silently contended bus line.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 两个同时发起事务的主设备会持续比较线的状态，在每个比特被传输后。在两个主设备为两个不同传输完美同步的情况下，两个源上具有不同值的第一个比特只会被发送`1`值的主设备注意到，因为预期的值没有反映实际的线状态。该主设备会立即中止事务，发送器可以检测到网络上的冲突错误，在这种情况下，意味着仲裁权被让给了另一个主设备。同时，另一个主设备以及从设备都不会注意到任何事情，因为尽管总线线被无声地竞争，事务仍然会继续。
- en: Programming the controller
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器编程
- en: 'Microcontrollers may provide one or more I2C controllers on board that can
    be bound to specific pins using alternate functions. On our reference board, to
    enable the `I2C1` bus, we activate the clock gating and start the initialization
    procedure by accessing the control, data, and status register mapped in the peripheral
    memory region:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器可能提供一个或多个I2C控制器，这些控制器可以使用备用功能绑定到特定的引脚。在我们的参考板上，为了启用`I2C1`总线，我们激活时钟门控，并通过访问映射在外围内存区域的控制、数据和状态寄存器来启动初始化过程：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `I2C1` controller on the STM32F407 is associated with pins PB6 and PB9
    when they are configured with the `AF 4` alternate function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置为`AF 4`备用功能时，STM32F407上的`I2C1`控制器与PB6和PB9引脚相关联：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The initialization function accesses the configuration registers of the I2C
    controller, mapped in the peripheral region. After the pin configuration and the
    RCC startup sequence, the transceiver speed is calibrated by using the frequency
    of the `APB1` bus clock, in MHz. When the clocks are calibrated, the transceiver
    is enabled by setting a bit in the `CR1` register. The parameters used here configure
    the master bus clock to run at 400 kHz. While the default setting for the protocol
    foresees a clock of 100 kHz, the 400 kHz option was added later on, and is now
    supported by many devices:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化函数访问I2C控制器的配置寄存器，这些寄存器映射在周边区域。在完成引脚配置和RCC启动序列后，通过使用`APB1`总线时钟的频率（MHz）来校准收发器的速度。当时钟校准完成后，通过在`CR1`寄存器中设置一个位来启用收发器。这里使用的参数将主总线时钟配置为以400
    kHz运行。虽然协议的默认设置预见到100 kHz的时钟，但400 kHz选项后来被添加，并且现在许多设备都支持：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'From this moment on, the controller is ready to be configured and used, either
    in master or slave mode. Data can be read and written using `I2C1_DR`, in the
    same way as SPI and UART. The main difference here is that, for a master I2C device,
    the `START` and `STOP` conditions must be manually triggered by setting the corresponding
    values in the `I2C1_CR1` register. Functions such as the following are intended
    for this purpose:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从此刻起，控制器已准备好配置和使用，无论是主模式还是从模式。可以使用`I2C1_DR`读取和写入数据，就像SPI和UART一样。这里的主要区别是，对于主I2C设备，必须在`I2C1_CR1`寄存器中手动触发`START`和`STOP`条件。以下函数旨在实现此目的：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At the end of each condition, the bus must be tested for possible errors or
    abnormal events. The combination of the flags in `I2C1_CR1` and `I2C1_CR2` must
    reflect the expected status for the transaction to continue, or it must be gracefully
    aborted in the case of timeouts or unrecoverable errors.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个条件的末尾，必须测试总线以检查可能出现的错误或异常事件。`I2C1_CR1`和`I2C1_CR2`中的标志组合必须反映事务继续所需的预期状态，或者在超时或不可恢复的错误发生时，必须优雅地终止。
- en: Due to the complexity caused by the high number of events possible during the
    setup of the transaction, it is necessary to implement a complete state machine
    that keeps track of the phases of the transmission to use the transceiver in master
    mode.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事务设置期间可能发生的大量事件引起的复杂性，有必要实现一个完整的有限状态机，以跟踪传输的各个阶段，以便在主模式下使用收发器。
- en: 'As a demonstration of basic interactions with the transceiver, we can write
    a sequential interaction with the bus, but a real-life scenario would require
    us to keep track of the state of each transaction and react to the many scenarios
    possible within the combination of the flags contained in `I2C1_SR1` and `I2C1_SR2`.
    This sequence initiates a transaction toward an I2C slave with an address of `0x42`,
    and if the slave responds, it sends 2 bytes with values of `0x00` and `0x01`,
    respectively. The only purpose of this sequence is to show the interaction with
    the transceiver, and it does not recover from any of the possible errors. At the
    beginning of the transaction, we zero the flags related to the ACK or the `STOP`
    condition, and we enable the transceiver using the lowest bit in `CR1`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 作为与收发器基本交互的演示，我们可以编写与总线进行顺序交互的代码，但在现实场景中，我们需要跟踪每个事务的状态，并对`I2C1_SR1`和`I2C1_SR2`中包含的标志组合可能出现的多种场景做出反应。此序列启动一个针对地址为`0x42`的I2C从设备的事务，如果从设备响应，它将发送两个字节，值分别为`0x00`和`0x01`。此序列的唯一目的是展示与收发器的交互，并且不会从任何可能的错误中恢复。在事务开始时，我们将与ACK或`STOP`条件相关的标志清零，并使用`CR1`中的最低位启用收发器：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To ensure that no other master is occupying the bus, the procedure hangs until
    the busy flag is cleared in the transceiver:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保没有其他主设备占用总线，程序将挂起，直到收发器中的忙标志被清除：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A `START` condition is sent, using the function defined earlier, which will
    also wait until the same `START` condition appears on the bus:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前定义的函数发送`START`条件，这将等待总线出现相同的`START`条件：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The destination address is set to the highest 7 bits of the byte we are about
    to transmit. The lowest bit is off as well, indicating a write operation. To proceed
    after a correct address selection that has been acknowledged by the receiving
    slave, two flags must be set in `I2C1_SR2`, indicating that the master mode has
    been selected and the bus is still taken:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 目标地址设置为即将发送的字节的最高7位。最低位也关闭，表示写操作。在接收从设备确认正确的地址选择后，必须将`I2C1_SR2`中的两个标志设置，以指示已选择主模式并且总线仍然被占用：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The data communication with the slave has now been initiated, and the 2 data
    bytes can be transmitted. The TX FIFO `EMPTY` event indicates when each byte has
    been transferred within a frame in the transaction:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与从设备的数据通信现在已经启动，可以传输2个数据字节。TX FIFO `EMPTY` 事件指示在事务中的帧内每个字节何时已传输：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, the `STOP` condition is set, and the transaction is over:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置`STOP`条件，事务结束：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Interrupt handling
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断处理
- en: The event interface of the I2C controller on the reference target is complex
    enough to provide two separate interrupt handlers for each transceiver. The suggested
    implementation for a generic I2C master includes a proper interrupt setup and
    the definition of all the combinations between states and events. The I2C controller
    can be configured to associate interrupts with all the relevant events happening
    on the bus, allowing for the fine-tuning of specific corner cases, and a more-or-less
    complete implementation of the I2C protocol.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 参考目标上的I2C控制器的事件接口足够复杂，可以为每个收发器提供两个独立的中断处理程序。针对通用I2C主机的建议实现包括适当的中断设置和定义所有状态和事件之间的组合。I2C控制器可以配置为将中断与总线上发生的所有相关事件相关联，允许对特定角落情况进行微调，并实现I2C协议的更多或更完整的实现。
- en: That brings us to the end of this chapter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了本章的结尾。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has given us the necessary information to start programming system
    support for the most popular local bus communication interfaces available on embedded
    targets. Accessing peripherals and other microcontrollers in the same geographical
    location is one of the typical requirements of embedded systems interacting with
    sensors, actuators, and other devices in proximity of the embedded system.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了开始编程嵌入式目标上最流行的本地总线通信接口系统支持所需的信息。访问同一地理位置的外围设备和其他微控制器是嵌入式系统与传感器、执行器和其他设备交互的典型要求。
- en: Several implementations providing a higher level of abstraction to the transceivers
    analyzed here already exist. The serial communication protocols covered in this
    chapter, namely UART, SPI, and I2C, are usually accessible through drivers that
    are part of the board support kit and do not need to be reimplemented from scratch.
    This chapter, however, purposely focused on studying the behavior of the components
    from the closest possible point of view, to better understand the interface provided
    by the hardware manufacturer, and possibly provide the tools to design new ways
    of accessing the interfaces, tailored or optimized, for a specific platform or
    scenario, while also understanding the choices behind some of the protocol design
    characteristics.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 已经存在几种实现，为这里分析的收发器提供了更高层次的抽象。本章涵盖的串行通信协议，即UART、SPI和I2C，通常可以通过作为板级支持包一部分的驱动程序访问，无需从头重新实现。然而，本章故意专注于从尽可能接近的角度研究组件的行为，以更好地理解硬件制造商提供的接口，并可能提供设计新方法访问接口的工具，这些方法针对特定平台或场景进行了定制或优化，同时理解某些协议设计特性背后的选择。
- en: In the next chapter, we will describe the mechanisms used to reduce the power
    consumption of embedded systems by studying the low-power and ultra-low-power
    features present in modern embedded devices.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将描述通过研究现代嵌入式设备中存在的低功耗和超低功耗特性来降低嵌入式系统功耗的机制。
