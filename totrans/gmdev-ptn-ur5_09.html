<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-117"><a id="_idTextAnchor130"/>9</h1>
<h1 id="_idParaDest-118"><a id="_idTextAnchor131"/>Structuring Code with Behavioral Patterns – Template, Subclass Sandbox, and Type Object</h1>
<p>This chapter focuses on the three most common structural patterns. Structural patterns allow us to plan our code with the end usage in mind. For example, if we know that the end users of our system are likely to be designers with no code experience, we could plan to use the type object pattern to provide a system for easy dynamic expansion. We have already covered some of the concepts around code structure when we discussed using interfaces and events to achieve anonymous modular design in <a href="B18297_07.xhtml#_idTextAnchor090"><em class="italic">Chapter 7</em></a>. The three patterns in this chapter (template, subclass sandbox, and type object) are a little more zoomed-in in terms of scope compared to what we have looked at before. The first two are interchangeable depending on your preference, both working as extensions to the standard inheritance property of the C++ programming language. The last is by far the most useful pattern in game design, giving designers the ability to define variants of classes with ease without getting in the programmers’ way while they make new functionality.</p>
<p>The topics we will cover in this chapter are the following:</p>
<ul>
<li>Exploring the <strong class="bold">Template</strong> pattern</li>
<li>Understanding <strong class="bold">Subclass Sandbox</strong></li>
<li>The <strong class="bold">Type </strong><strong class="bold">Object</strong> pattern</li>
</ul>
<h1 id="_idParaDest-119"><a id="_idTextAnchor132"/>Technical requirements</h1>
<p>Unlike previous chapters, we will be starting with the project files in the <code>chapter9</code> branch on GitHub, which can be downloaded from <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter09">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter09</a></p>
<p>We have made a few small changes to the project to facilitate the following pattern examples. These changes are a bit too tedious to walk through in this chapter but if you would like to see what has changed, then download both this and the previous chapters’ branches and run them through a diffing program such as DiffMerge.</p>
<p>Let’s get started.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor133"/>Exploring the template pattern</h1>
<p>The template pattern<a id="_idIndexMarker371"/> exists as an extension to standard inheritance, where we define a structure in an abstract parent class and the children are given the opportunity to override the pieces of that structure. They can change how individual parts function but not the order of execution. The simplest example of this within Unreal is the <code>AActor</code> base class. Any child of AActor gets access to the Begin Play, Tick, and End Play events, to name but a few. The child class can hook functionality onto these events, and they will fire when expected. The constraint we place on inheritance to make this into the template pattern is that the child has no way of changing the order or timing of these events. There is no way to make End Play fire before Begin Play as this order has been defined in the parent.</p>
<p>We can see an example of a class implementing the template pattern in the following code. The <code>ProcessGame()</code> function is the only one with a body, defining the order of the private abstract function:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Template pattern parent pseudocode</p>
<pre class="source-code">
public class AActor
{
public:
void ProcessGame() {
BeginPlay();
while(gameRunning)
    Tick();
    EndPlay();
    }
protected:
    abstract void BeginPlay();
    abstract void Tick();
    abstract void EndPlay();
}</pre> <p>We can see the <code>AActor</code> class has four functions with only one of them not marked as abstract or virtual. This function is our spine that defines the order of execution. From there, each of the other functions may have some form of implementation in the base but they are designed to be ultimately overridden. The best situation is for each of these extra utility functions to be abstract with no implementation in the base to retain the lightweight nature of the pattern, but if that means that a lot of the implementations will be repeated, then a virtual base with the common code would be better. The goal is to keep this class as <a id="_idIndexMarker372"/>light as possible while cutting down as much repetition as we can.</p>
<p class="callout-heading">Important caveat</p>
<p class="callout">Strictly speaking, the actual structure of <code>AActor</code> doesn’t implement the Template pattern, as shown in the pseudocode; we collapsed the tree a little to make a point. In reality, that loop is dealt with by the world object and filtered down to all the actors and subsystems within it.</p>
<p>To demonstrate this, we are going to give our elite unit some weapons. In the GitHub branch for this chapter, the <code>EliteUnit</code> C++ class has already been augmented to spawn a weapon from a base class defined in the class defaults. This spawned weapon is an actor that we have attached to a <code>SceneComponent</code>, positioned just in front of the character. The code is also modified to call the fire function on this weapon instead of running a line trace from within the character. As it currently stands, this code will not run as there are no classes available for the character to spawn from that are not marked as abstract. Our first step is to build the template parent class as a child of this generic weapon in C++. We can then leave the creation of the functional child weapons to a Blueprint, giving us an excellent way to understand how the two systems work together and allowing programmers to do the groundwork in C++ before the technical designers and designers <a id="_idIndexMarker373"/>explore variations in Blueprints. This allows for quick prototyping and iteration of weapon designs to achieve the intended game feel without breaking any of the underlying systems.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor134"/>Building the template (parent class)</h2>
<p>As mentioned earlier, our<a id="_idIndexMarker374"/> first step is to make a new C++ child class of <code>AWeapon_Base</code>. With that made, we can set about putting the template main function in place which, as we can see in the code below, is called <code>Fire()</code>. The parent class has a lot of the data and a core system for dealing with a brief cooldown delay between shots. These variables have been added at the top level as they will be universal to all weapon types and so it makes sense to consolidate them in the common parent. This does mean that the <code>Fire()</code> function here is an override, whereas in a straight implementation of the template pattern, this would be at the top level. We are only doing things differently here to create a shared hierarchy with the Sandbox pattern that we’ll see in the next section to highlight the differences.</p>
<p>The other functions in the template weapon base class include a public function for reloading, as you may want to actively call that function even though we will be triggering it by default anyway. This is followed by a bunch of utility functions that are marked as either <code>BlueprintNativeEvent</code> if they have a default implementation in the base, or <code>BlueprintImplementableEvent</code> if they do not. Each of these protected functions exists to be overridden by the children to change the behavior of the weapon:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">TemplateWeapon_Base.h excerpt</p>
<pre class="source-code">
UCLASS(Abstract)
class RTS_AI_API ATemplateWeapon_Base : public AWeapon_Base
{
    GENERATED_BODY()
public:
    virtual void Fire() override;
    UFUNCTION(BlueprintCallable, BlueprintNativeEvent)
    void Reload();
protected:
    UFUNCTION(BlueprintNativeEvent)
    bool CheckAmmo();
    UFUNCTION(BlueprintImplementableEvent)
    void ProcessFiring();
    UFUNCTION(BlueprintImplementableEvent)
    void PlayEffects();
    UFUNCTION(BlueprintNativeEvent)
    void UpdateAmmo();
};</pre> <p>The only function in the<a id="_idIndexMarker375"/> implementation of this class is the template spine we are calling <code>Fire()</code>. In this function, we define the execution order of all the other functions in a way that becomes concrete. In the following implementation, we check whether we can fire; if not, we use an early return to exit the function. Then we check whether we have the ammo to fire; if not, then we’ll reload. If the weapon is able to fire, then the process outlined by this function starts with the effects, then runs the gameplay logic for actually firing with the reduction in ammo calculated after that. The last thing it does is call the parent, where we have set up the code to deal with the firing delay (which is used to prevent the fire button being spammed or exploited with auto-clickers and macros):</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">TemplateWeapon_Base.cpp main template function</p>
<pre class="source-code">
void ATemplateWeapon_Base::Fire()
{
    if(!_CanFire) return;
    if(CheckAmmo())
    {
        PlayEffects();
        ProcessFiring();
        UpdateAmmo();
        Super::Fire();
        return;
    }
    Reload();
}</pre> <p>The next few<a id="_idIndexMarker376"/> functions are just default implementations that make sense and are likely to be repeated code if not defined here. The reload function resets the ammo counter and calls the fire delay reset function. <code>CheckAmmo</code> is a one-line Boolean check that could be made pure as an extension to this. Finally, <code>UpdateAmmo</code> just takes the predefined <code>_AmmoPerFire</code> from our ammo counter:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">TemplateWeapon_Base.cpp utility functions</p>
<pre class="source-code">
void ATemplateWeapon_Base::Reload_Implementation()
{
    _CurrentAmmo = _MaxAmmo;
    Handle_FireDelay();
}
bool ATemplateWeapon_Base::CheckAmmo_Implementation()
{
    return _AmmoPerFire &lt;= _CurrentAmmo;
}
void ATemplateWeapon_Base::UpdateAmmo_Implementation()
{
    _CurrentAmmo -= _AmmoPerFire;
}</pre> <p>That forms <a id="_idIndexMarker377"/>the C++ base for our template pattern. All that is left is to make an implementation or two with Blueprint child classes in the editor.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor135"/>Creating child classes</h2>
<p>We are now<a id="_idIndexMarker378"/> going to create two child classes in a Blueprint. This task offers us a great opportunity to explore how C++ and Blueprints can work together to create efficient solutions. To do this, we need to create new child Blueprints, one for a pistol and a second for a shotgun. These weapons both utilize a line-trace approach with variation for multiple projectiles in a spread. This allows us to focus on creating two different solutions with a small but significant change to build a solid example for the template pattern. To do this, we are going to use the same menu from before, but instead of selecting <strong class="bold">Actor</strong> from the dialog, we need to dig a bit deeper to find the C++ parent class:</p>
<ol>
<li>Start by right-clicking in the Content Browser and clicking <strong class="bold">Blueprint Class</strong>.</li>
<li>If it isn’t already visible, expand the <strong class="bold">ALL CLASSES</strong> rollout by clicking the title.</li>
<li>In the search box, type <code>template</code> to reduce the number of options displayed in the results box, as shown in <em class="italic">Figure 9</em><em class="italic">.1</em>.</li>
</ol>
<div><div><img alt="Figure 9.1: ﻿The Blueprint creation window for a template weapon" src="img/Figure_09.01_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: The Blueprint creation window for a template weapon</p>
<ol>
<li value="4">Select <strong class="bold">TemplateWeapon_Base </strong>from the list, then click <strong class="bold">Select</strong>, which will only <a id="_idIndexMarker379"/>appear once you’ve made your selection.</li>
<li>Name this new Blueprint <code>BP_TemplatePistol</code>.</li>
</ol>
<p>With the pistol child Blueprint created, we next need to create a child Blueprint for the shotgun. To do this, repeat the preceding steps but name the second blueprint <code>BP_TemplateShotgun</code>.</p>
<p>Now that the child classes have been created, we can move on to creating the behaviors inside them, making use of the template pattern to only modify the part of the class necessary to achieve the desired functionality of each child.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor136"/>Template pistol</h2>
<p>Now that we have our Blueprint for the <a id="_idIndexMarker380"/>Pistol set up, we can move on to overriding the parts of the template that will be unique to this class. The <code>CheckAmmo</code> and <code>UpdateAmmo</code> functions will remain the same for our pistol class as in the parent template. We will be overriding <code>PlayEffects</code>, <code>ProcessFiring</code>, and <code>Reload</code>.</p>
<p>We’ve overridden functions before, namely in <a href="B18297_08.xhtml#_idTextAnchor113"><em class="italic">Chapter 8</em></a> when looking at utility blueprints. The process here is exactly the same.</p>
<p class="callout-heading">Note on overriding C++ functions</p>
<p class="callout">When we override functions in a Blueprint that are included within a C++ parent, we don’t get a choice between creating a function or an event. The result we get when selecting to override the C++ function will depend on whether the function has a return or not. If a function does not contain a return, the override in the Blueprint will automatically create an Event node in the main Blueprint Event Graph. If the function does have a return (like <code>CheckAmmo</code> does), the override will provide a Blueprint function.</p>
<p>First, we are going to override the <code>PlayEffects</code> function. This is where we would typically add a muzzle flash particle effect and play an animation and a sound. In the interest of keeping the repository for this exercise small, and the number of steps short to allow us to focus on learning, we will just add a sound effect. Again, in the interest of keeping the required download small, we will use a sound from the Engine Content as opposed to finding a purpose-selected sound for the gun. Let’s do this as follows:</p>
<ol>
<li>Open the Blueprint and on the left side, hover over the <strong class="bold">Functions</strong> section of the <strong class="bold">My Blueprint</strong> tab. This should reveal the <strong class="bold">Override</strong> dropdown. From this, select <strong class="bold">Play Effects</strong>.</li>
<li>This should have added an <strong class="bold">Event Play Effects</strong> node to the Event Graph.</li>
<li>Drag from the pin on the <code>Play Sound at </code><code>Location</code> node.</li>
<li>Expand the <code>VR_Teleport</code>. If nothing appears, you will need to enable <strong class="bold">Show Engine Content</strong> from the <strong class="bold">Settings</strong> dropdown, which can be accessed by clicking the cog icon in the top right of the dropdown.</li>
<li>Drag from the <code>Get Actor </code><code>Location</code> node.</li>
</ol>
<div><div><img alt="Figure 9.2: The overridden Event Play Effects function in the Blueprint" src="img/Figure_09.02_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: The overridden Event Play Effects function in the Blueprint</p>
<p>Next, we will <a id="_idIndexMarker381"/>override <strong class="bold">ProcessFiring</strong>. This is where we are going to put all of our firing logic. The precise contents of this function will differ depending on the type of weapon. For the pistol, we can use a simple line trace similar to the approach taken for attacking enemies that we created in <a href="B18297_04.xhtml#_idTextAnchor057"><em class="italic">Chapter 4</em></a> when making the Behavior Tree for the Elite Unit. To begin, let’s set up the trace:</p>
<ol>
<li>Drag from the pin on the <code>Line Trace by Channel</code> node to the graph.</li>
<li>Drag in the <code>Get World Location</code> node and then repeat this again to add a <code>Get Forward </code><code>Vector</code> node.</li>
<li>Connect the <strong class="bold">Return Value</strong> pin on <strong class="bold">Get World Location</strong> node to the <strong class="bold">Start</strong> pin on the <strong class="bold">Line Trace By </strong><strong class="bold">Channel</strong> node.</li>
<li>Drag from the <code>Multiply</code> (<code>x</code>) node by typing <code>*</code> in the search box.</li>
<li>Right-click the lower pin on the <strong class="bold">Multiply </strong>node and select <strong class="bold">Convert Pin | Float (single-precision)</strong>. This will turn the yellow pin green, indicating that the variable expected is no longer a vector but now a float.</li>
<li>Drag from the green pin and add a <code>Get Range</code> node. This will add the <code>Range</code> variable defined in the parent class.</li>
<li>Once again drag from the <strong class="bold">Get World Location</strong> node and create an <strong class="bold">Add</strong> node (reached by typing <strong class="bold">+</strong>).</li>
<li>Connect the lower input vector pin of the <strong class="bold">Add</strong> node to the output vector pin of the <strong class="bold">Multiply</strong> node.</li>
<li>Connect the output of the <strong class="bold">Add</strong> node to the <strong class="bold">End</strong> pin on the <strong class="bold">Line Trace By </strong><strong class="bold">Channel</strong> node.</li>
</ol>
<p>Next, we need to tell the line<a id="_idIndexMarker382"/> trace to ignore the character when shooting, or else the only character the gun will damage will be the one firing it:</p>
<ol>
<li>Right-click in the event graph and create a <code>Get </code><code>Owner</code> node.</li>
<li>Drag from the <strong class="bold">Return Value</strong> output of the <strong class="bold">Get Owner</strong> node and add a <strong class="bold">Make </strong><strong class="bold">Array</strong> node.</li>
<li>Connect the <strong class="bold">Array</strong> output pin of the <strong class="bold">Make Array</strong> node to the <strong class="bold">Actors to Ignore</strong> pin on the <strong class="bold">Line Trace By </strong><strong class="bold">Channel</strong> node.</li>
</ol>
<p>The line trace is now set up and should look like the graph shown in <em class="italic">Figure 9</em><em class="italic">.3</em>.</p>
<div><div><img alt="Figure 9.3: The Line Trace node with the inputs setup" src="img/Figure_09.03_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: The Line Trace node with the inputs setup</p>
<p class="callout-heading">Drag and drop variables defined in the parent class</p>
<p class="callout">If you’d like to be able to drag the variables we defined in the parent class into the graph in the same way you would with a variable created in a blueprint, click the cog in the top right of the <strong class="bold">My Blueprint</strong> tab and enable <strong class="bold">Show </strong><strong class="bold">Inherited Variables</strong>.</p>
<p>Next, we need to <a id="_idIndexMarker383"/>do something with the result of the trace. In this case, we are going to use the Apply Damage approach, just as we did in <a href="B18297_04.xhtml#_idTextAnchor057"><em class="italic">Chapter 4</em></a>:</p>
<ol>
<li>Drag from the <code>Break Hit </code><code>Result</code> node.</li>
<li>Drag from the <code>Apply </code><code>Damage</code> node.</li>
<li>To make the graph easier to read, click the collapse arrow (<strong class="bold">^</strong>) on the bottom of the <strong class="bold">Break Hit Result</strong> node. This will collapse the node to only show the top two bool pins and any pins that have been used, hiding any unused pins. In this case, just the <strong class="bold">Hit Actor</strong> pin will remain visible along with the top two bool pins (<strong class="bold">Blocking Hit</strong> and <strong class="bold">Initial Overlap</strong>).</li>
<li>Drag back from the <code>Get Damage Per Hit</code> node, once again grabbing a variable defined in the parent.</li>
<li>Lastly, drag from the <code>Branch</code> node (<code>If</code>) and connect the three nodes together as shown in <em class="italic">Figure 9</em><em class="italic">.4</em>.</li>
</ol>
<div><div><img alt="Figure 9.4: The result of the trace used to apply damage to the enemy unit" src="img/Figure_09.04_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4: The result of the trace used to apply damage to the enemy unit</p>
<p>The last thing to do is to check the values of each of the inherited variables. You can do this by clicking on the variable nodes or, if you chose to show inherited variables, you can select them from the variables list in the <strong class="bold">My </strong><strong class="bold">Blueprint</strong> tab.</p>
<p>Ensure that the <code>1000.0</code> and <code>20.0</code>.</p>
<p>With the firing of<a id="_idIndexMarker384"/> the weapon sorted, we can next turn our attention to the reload function. Unlike the previous two overrides, the reload function is not an abstract function. The parent template class already handles the functional aspect of the reload, adding the ammo back into the weapon, so we need to ensure we retain that in the child class. We can then add all the extra elements such as sounds, animations, particle effects, and so on. Once again, let’s keep this simple by just adding a sound. First, let’s override the Reload function and ensure we are maintaining the functionality from the parent class:</p>
<ol>
<li>Override the <strong class="bold">Reload </strong>in function in the same way as we did for the previous two functions. This will add the <strong class="bold">Event Reload</strong> node to the <strong class="bold">Event Graph</strong>.</li>
<li>Right-click on the <strong class="bold">Event Reload</strong> node and select <strong class="bold">Add call to parent function</strong>. This will add a <strong class="bold">Parent: Reload</strong> node for you.</li>
<li>Move the <strong class="bold">Parent: Reload</strong> node beside the <strong class="bold">Event Reload</strong> node and connect them together.</li>
</ol>
<div><div><img alt="Figure 9.5: The Event Reload and Parent: Reload nodes" src="img/Figure_09.05_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5: The Event Reload and Parent: Reload nodes</p>
<p>The <strong class="bold">Parent: Reload</strong> node tells <a id="_idIndexMarker385"/>Unreal to do all the steps from the parent version of this function at this point in the logic chain.</p>
<p>Now that we have the behavior from the parent included in the child, we can add the sound. We do this just in the same way as we did for the <strong class="bold">PlayEffects</strong> event, however this time, we will select the <strong class="bold">Gizmo_Handle_Clicked</strong> sound.</p>
<div><div><img alt="Figure 9.6: The completed Event Reload function in our Blueprint" src="img/Figure_09.06_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6: The completed Event Reload function in our Blueprint</p>
<p>With the reload function sorted, our pistol is complete. Let’s test it out on the character to make sure it works. The <strong class="bold">EliteUnit</strong> modifications included an automated system for spawning and attaching weapons to the character based on a drop-down box. Set the weapon as follows:</p>
<ol>
<li>Select the <strong class="bold">BP_EliteUnit</strong> that is in the level.</li>
<li>Search in the details panel for <code>Weapon </code><code>to Spawn</code>.</li>
<li>Change the value in the drop-down box to <strong class="bold">BP_TemplatePistol</strong>.</li>
</ol>
<p>If you<a id="_idIndexMarker386"/> see <code>UCLASS</code> block includes the <code>Abstract</code> property so that no one can ever spawn an instance of the base class.</p>
<p>With the pistol now set up, tested, and functional, let’s look at the shotgun.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor137"/>Template shotgun</h2>
<p>For the sake of <a id="_idIndexMarker387"/>simplicity and to avoid this being a very long chapter, with the shotgun the only unique approach we will apply is to the <strong class="bold">Process Firing</strong> function. Because the Play Effects and Reload functions are abstract in the parent, we must override them, so before we get started on the Process Firing for the shotgun, replicate the other two functions from the pistol in the <strong class="bold">BP_TemplateShotgun</strong> Event Graph. You can do this by creating them again manually or by copying and pasting them between graphs.</p>
<p>With that done, let’s move on to sorting the firing out. Rather than going through this version step by step, let’s look at the differences so you can make the necessary changes to create a shotgun rather than a pistol. Begin by copying over the firing logic from the pistol before modifying it to replicate each of the changes that follow.</p>
<p>Unlike a pistol, we need to consider that when fired, a shotgun doesn’t fire a single projectile. Rather, shotgun shells often contain between nine and eighteen small pellets that are fired out of the barrel in a cluster.</p>
<p>To replicate this, we simply increase the number of traces we perform and add variation to the direction, maintaining the same start point (the end of the barrel) but adjusting the end point of each trace to mimic the spread of the shot exiting the barrel</p>
<p>Let’s get started by using multiple traces to replicate the shotgun shell’s behavior.</p>
<h3>Adding a for loop to fire multiple pellets</h3>
<p>To perform<a id="_idIndexMarker388"/> multiple line traces, we need to add a <code>For Loop</code> as the first node in the <strong class="bold">Event Process Firing</strong> logic chain, connecting the <strong class="bold">Line Trace By Channel</strong>, <strong class="bold">Branch</strong> and <strong class="bold">Apply Damage</strong> nodes into the <strong class="bold">Loop Body</strong>.</p>
<p>The <strong class="bold">For Loop</strong> node will complete each of the steps in the <em class="italic">Loop Body</em>, incrementing its index from the <strong class="bold">First Index</strong> value to the <strong class="bold">Last </strong><strong class="bold">Index</strong> value.</p>
<p>For the shotgun, set <code>1</code>. Typically, we would use <code>0</code>, however we are going to create an integer variable called <code>NumberOfPellets</code> for the <code>5</code>. If we were to keep <strong class="bold">First Index</strong> at zero, the shotgun <a id="_idIndexMarker389"/>would fire six pellets, so instead of requiring a designer to remember to reduce the variable by 1 to get their desired number of traces, we simply start at 1 to make the system more user friendly.</p>
<div><div><img alt="Figure 9.7: The For Loop node and Number Of Pellets variable" src="img/Figure_09.07_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7: The For Loop node and Number Of Pellets variable</p>
<p>With multiple<a id="_idIndexMarker390"/> traces firing, we now need to make each trace slightly different so that we aren’t just doing multiple identical traces. Let’s do that next.</p>
<h3>Adding spread to the pellet trajectories</h3>
<p>To add<a id="_idIndexMarker391"/> variation to the <strong class="bold">End</strong> vector input of the <strong class="bold">Line Trace By Channel</strong> node, we need to rotate the result of the <strong class="bold">Get Forward Vector</strong> node slightly before multiplying it by the range.</p>
<p>To do this, we add a <code>Random Unit Vector in Cone in Degrees</code> node. This uses a <strong class="bold">Cone Dir</strong> input (the initial direction the cone is facing) and a <strong class="bold">Cone Half Angle in Degrees</strong> input (the amount of rotation to be applied from the center line of the cone).</p>
<p>For <strong class="bold">Cone Dir</strong>, we connect in the <strong class="bold">Return Value</strong> of the <strong class="bold">Get Forward </strong><strong class="bold">Vector</strong> node.</p>
<p>For <code>HalfSpreadDegrees.</code></p>
<p>Set<a id="_idIndexMarker392"/> the <code>15</code>.</p>
<div><div><img alt="Figure 9.8: The adjusted firing trajectories" src="img/Figure_09.08_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8: The adjusted firing trajectories</p>
<p>Once you’ve added the <strong class="bold">Random Unit Vector in Cone in Degrees</strong> node, the calculations should be connected together as shown in <em class="italic">Figure 9</em><em class="italic">.8</em> with the vector connections going into the <strong class="bold">Line Trace By </strong><strong class="bold">Channel</strong> node.</p>
<p>With all that<a id="_idIndexMarker393"/> now set up, you are ready to test the shotgun. Change the variable once more on the Elite Unit in the level and give it a go.</p>
<p>Once that’s all finished and working, let’s move on to another parent-child structural pattern where everything is the exact opposite.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor138"/>Understanding subclass sandbox</h1>
<p>The Subclass Sandbox pattern<a id="_idIndexMarker394"/> takes the idea of the template’s limited extension through subclasses (to provide security) and applies it the exact opposite way round. Here, the children define the order of execution for a set of pre-defined code blocks through an abstract spine function. These blocks take the form of functions that are defined in the parent class and can never be overridden. Each function deals with one thing to do with an external system in a standardized way. The following pseudocode makes a better visual point of how this is literally the opposite of the template pattern we explored previously, where everything previously marked as abstract gets functionality and the one function we had code in is now abstract:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Subclass sandbox pattern parent pseudocode</p>
<pre class="source-code">
public class Sandbox_Parent
{
public:
    abstract void DoAThing();
protected:
    void PlaySound() { //Plays sound correctly }
    void FireParticle() { //Fires particle correctly }
    void AddForce() { //Adds force correctly }
    void DealDamage() { //Deals damage correctly }
}</pre> <p>The workflow for this pattern starts with the programmer building black-box tools for the technical designer to string together in interesting ways. This can lead to interesting innovation as the programmer isn’t making tools to specification, rather just for the sake of having tools, which leaves their application open for the technical designer to interpret. The flip side of this is that there could be a lot of wastage where tools either don’t get used or they are used in ways they could be better designed for. Thus, this process works better as an iteration on both sides to ensure that the toolset is useful and efficient, as well <a id="_idIndexMarker395"/>as actually being used.</p>
<p>Enough speaking in the abstract: let’s look at the implementation of this for our weapons alongside the template pattern.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor139"/>Building the sandbox (parent class)</h2>
<p>The first step is to copy what <a id="_idIndexMarker396"/>we did in the template section and make another C++ child of our <code>Weapon_Base</code> class, but this time call it <code>SandboxWeapon_Base</code>. The whole point of this pattern is that the Blueprint children will implement the <code>Fire</code> function in whatever way they see fit, but for that we would have to add <code>UFUNCTION(BlueprintNativeEvent)</code> at the very least. However, because we have joined our patterns together with this common parent, it means the function has to be marked as virtual and so cannot have a standard function specifier. This will never be the case in any production code. It is only a problem here due to us showing both patterns linked by a common parent. Our solution for this is a second <code>Fire</code> function called <code>SandboxFire</code>. We will pass the execution off to this function within <code>Fire</code> so that everything behaves as normal. No sensible project architecture would implement both patterns side by side like this, so it should not be an issue in your future projects.</p>
<p>The other<a id="_idIndexMarker397"/> thing we must define are the building block functions, which we have chosen to keep similar to the previous example, but for which you can make as many as you deem necessary. The key is to keep each function short and to the point as their purpose is to standardize the method for interacting with external systems so that future changes are easily maintained. The most important aspect of the functions laid out in the following code are that they are protected and marked as <code>BlueprintCallable</code>. This means they are just for children of this class to use, not override, and also ensures they have no external access.</p>
<p>Lets start with the base class for the sandbox weapon:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">SandboxWeapon_Base.h excerpt</p>
<pre class="source-code">
UCLASS(Abstract)
class RTS_AI_API ASandboxWeapon_Base : public AWeapon_Base
{
    GENERATED_BODY()
public:
    virtual void Fire() override;
    UFUNCTION(BlueprintImplementableEvent)
    void SandboxFire();
    UFUNCTION(BlueprintCallable)
    void Reload();
protected:
    UFUNCTION(BlueprintCallable)
    bool CheckAmmo();
    UFUNCTION(BlueprintCallable)
    void LinetraceOneShot(FVector direction);
    UFUNCTION(BlueprintCallable)
    void PlaySound(USoundBase* sound);
    UFUNCTION(BlueprintCallable)
    void UpdateAmmo();
};</pre> <p>With the header declared, we can turn to the definitions in the following implementation.  Our <code>Fire</code> function override simply calls <code>SandboxFire()</code> to pass the signal through to a function with the correct properties. As <code>SandboxFire</code> is marked as <code>BlueprintImplementableEvent</code> it doesn’t have a definition in this class and instead can be completely left to the Blueprint children to define. Our <code>Reload</code>, <code>CheckAmmo</code>, and <code>UpdateAmmo</code> functions are basically the same as before, but this is dependent on the systems that are being hooked into and where it is best to build lots of small specific functions. <code>PlaySound</code> is a more specific version of <code>PlayEffects</code> from before, where we were able to leave the implementation to the designer, but now we must be specific<a id="_idIndexMarker398"/> in function name and use:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">SandboxWeapon_Base.cpp simple function definitions</p>
<pre class="source-code">
void ASandboxWeapon_Base::Fire()
{
    SandboxFire();
}
void ASandboxWeapon_Base::Reload()
{
    _CurrentAmmo = _MaxAmmo; Handle_FireDelay();
}
bool ASandboxWeapon_Base::CheckAmmo()
{
    return _AmmoPerFire &lt;= _CurrentAmmo;
}
void ASandboxWeapon_Base::PlaySound(USoundBase* sound)
{
    UGameplayStatics::PlaySoundAtLocation(this, sound,
        GetActorLocation());
}
void ASandboxWeapon_Base::UpdateAmmo()
{
    _CurrentAmmo -= _AmmoPerFire;
}</pre> <p>On the topic of <a id="_idIndexMarker399"/>being specific, we now have a <code>LinetraceOneShot</code> function in place of the <code>ProcessFiring</code> function from before. While the utility of this, specifying that it is one shot, will become apparent later, this function is one of many ways to handle the gameplay logic of the gun firing. It acts as a wrapper for the line trace function working off a direction vector the user must pass in. This then applies damage to whatever it has hit through the standard Unreal method:</p>
<p>We can now add that to the sandbox weapon:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">SandboxWeapon_Base.cpp LinetraceOneShot function definition</p>
<pre class="source-code">
void ASandboxWeapon_Base::LinetraceOneShot(FVector direction)
{
    FHitResult hit(ForceInit);
    FVector start = _FirePoint-&gt;GetComponentLocation();
    FVector end = start + (direction * _Range);
    if(!UKismetSystemLibrary::LineTraceSingle(GetWorld(),
        start, end,
        UEngineTypes::ConvertToTraceType(ECC_Visibility),
        false,
        {this, GetOwner()},
        EDrawDebugTrace::ForDuration,
        hit,
        true,
        FLinearColor::Red, FLinearColor::Green, 5))
            return;
    UGameplayStatics::ApplyDamage(hit.GetActor(),
        _DamagePerHit, GetInstigatorController(),
            GetOwner(), UDamageType::StaticClass());
}</pre> <p>Now that our sandbox base is kitted out with a basic suite of tools; we can make the Blueprint child weapons equivalent to the template pattern by using the Sandbox_Fire function. Comparing the Blueprint implementations of each pattern should show a lot of the differences in approach and how each can be used for the same system with differing approaches. </p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor140"/>Creating child classes</h2>
<p>Just like with the <a id="_idIndexMarker400"/>template pattern, we are going to create two child classes of the Sandbox Weapon Base in a Blueprint. To do this, we follow the same steps except when searching in the <code>sandbox</code> and select <code>BP_SandboxPistol</code> and <code>BP_SandboxShotgun</code>.</p>
<p>With those created we can move on to setting them up. Unlike with the template pattern, we don’t need to create the functional behaviors. Instead, we determine the order (and reuse) of the functions in the parent.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor141"/>Sandbox pistol</h2>
<p>Once again, we <a id="_idIndexMarker401"/>begin with the pistol as this is probably the simplest weapon type to implement. First, we do all of our checks to make sure the weapon can fire, as follows:</p>
<ol>
<li>Override <strong class="bold">Sandbox Fire Function </strong>using the <strong class="bold">Override </strong>list.</li>
<li>Add a <code>Branch</code> based on the <code>CanFire</code> Boolean.</li>
<li>From the <code>Check Ammo</code> and add a second <code>Branch</code> based on the <strong class="bold">Return Value</strong></li>
</ol>
<div><div><img alt="Figure 9.9: The start of the Sandbox Fire Event" src="img/Figure_09.09_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9: The start of the Sandbox Fire Event</p>
<p>Next, we’ll add the logic to the <strong class="bold">False</strong> output from the <strong class="bold">Branch</strong> node, calling <strong class="bold">Reload</strong> and playing a sound (sounds haven’t been implemented in the parent class as that is something that will typically be different per weapon):</p>
<ol>
<li>Call the <code>Reload</code> function.</li>
<li>Add a <code>Play Sound</code> node, selecting<a id="_idIndexMarker402"/> the <strong class="bold">Gizmo_Handle_Clicked</strong> sound from the dropdown.</li>
</ol>
<div><div><img alt="Figure 9.10: The false logic for the Sandbox Fire Event" src="img/Figure_09.10_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10: The false logic for the Sandbox Fire Event</p>
<p>Lastly, we can add the True logic, which essentially fires the weapon. As the functional behavior already exists in the parent, we simply need to call the functions and provide the required inputs. We’re going to do this in two chunks. The first will play a sound before performing the line trace and updating the ammo. The second chunk will use a timer to call the function to manage the rate of fire:</p>
<ol>
<li>Add a <code>Play Sound</code> node, selecting the <code>VR_Teleport</code> sound once again.</li>
<li>Call the <code>Linetrace One Shot</code> function, providing it with the <code>Forward Vector</code> of the <strong class="bold">Fire </strong><strong class="bold">Point</strong> component.</li>
<li>Call <code>Update Ammo</code>.</li>
</ol>
<div><div><img alt="Figure 9.11: The start of the true logic that fires the sandbox pistol" src="img/Figure_09.11_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11: The start of the true logic that fires the sandbox pistol</p>
<ol>
<li value="4">Add a <code>Set Timer by Function </code><code>Name</code> node.</li>
<li>Type <code>Handle_FireDelay</code> in for <strong class="bold">Function Name</strong>.</li>
<li>Divide <code>1</code> by the <strong class="bold">RoF</strong> float variable and connect it to the <strong class="bold">Time</strong> pin of the <strong class="bold">Set Timer by Function </strong><strong class="bold">Name</strong> node.</li>
<li>Promote the <code>TimerFireDelay</code>.</li>
</ol>
<div><div><img alt="Figure 9.12: The Hand_FireDelay timer added to the end of the chain" src="img/Figure_09.12_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12: The Hand_FireDelay timer added to the end of the chain</p>
<p>With the pistol complete, test it the same as we did with the two template weapons and then we can move on to implementing the shotgun using the Sandbox pattern.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor142"/>Sandbox shotgun</h2>
<p>The shotgun follows much <a id="_idIndexMarker404"/>of the same setup as the pistol except for where we once again need to complete multiple line traces. The parent has a single line trace that requires a forward vector input. So, just like in the template example, we will use a <strong class="bold">For Loop</strong> and once again utilize the <strong class="bold">Random Unit Vector in Cone in Degrees</strong> node when providing the forward vector input to the <strong class="bold">Linetrace One </strong><strong class="bold">Shot</strong> function:</p>
<ol>
<li>Start by copying the logic from the pistol. This just saves us a little bit of time.</li>
<li>Disconnect both sides of the <strong class="bold">Linetrace One Shot </strong>node by holding down <em class="italic">Alt</em> and clicking on the pins.</li>
<li>Add in a <code>For Each</code> loop just as we did in the template shotgun, connecting it after the <code>True</code> logic and once again using the <code>Number of Pellets</code> integer variable.</li>
<li>For the <strong class="bold">Direction</strong> vector input on the <strong class="bold">Linetrace One Shot</strong> node, set up <strong class="bold">Random Unit Vector in Cone in Degrees</strong> in the same way we did for the template shotgun, as<a id="_idIndexMarker405"/> shown in <em class="italic">Figure 9</em><em class="italic">.13</em></li>
</ol>
<div><div><img alt="Figure 9.13: The For Loop’s Loop Body logic for ﻿the BP_SandboxShotgun" src="img/Figure_09.13_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13: The For Loop’s Loop Body logic for the BP_SandboxShotgun</p>
<p>Now we have the multiple line traces happening, we need to add back in the rest of the firing chain, that is, the Update Ammo function and Fire Delay Timer. Since these steps need to be done after we fire, they need to be connected to the <strong class="bold">Completed</strong> pin on the <strong class="bold">For Loop</strong> node, not part of the <strong class="bold">Loop Body.</strong></p>
<p>Move the nodes from the previous steps around to make a clear path for the connection from the <strong class="bold">Completed</strong> pin and connect the other nodes back in, as shown in <em class="italic">Figure 9</em><em class="italic">.14</em>.</p>
<div><div><img alt="Figure 9.14: The Update Ammo and Timer connected to the Completed pin" src="img/Figure_09.14_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14: The Update Ammo and Timer connected to the Completed pin</p>
<p>As before, test this out by selecting the weapon on the Elite Unit in the level.</p>
<p>Provided everything works as it should, we can then move on to exploring the type object pattern, which allows us to easily expand the content available in a game.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor143"/>Type object pattern</h1>
<p>If you need a fast way of<a id="_idIndexMarker406"/> creating many variants of something in your game as a form of expanding the content available to players, then the type object pattern is for you. Type object takes the ideas of implicit and explicit data we covered as part of the flyweight pattern back in <a href="B18297_03.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a> and expands it into the world of gameplay. The principle is the same: we separate out all data that is common across all instances of a type, but instead of just linking to it from everywhere, we mix it up and produce lots of variations of this data. The result is a connected web of objects that all have the same functionality but vary in which set of implicit data they use.</p>
<div><div><img alt="Figure 9.15: Diagram from Chapter 3 where we discussed the ﻿Flyweight pattern" src="img/Figure_09.15_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15: Diagram from <a href="B18297_03.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a> where we discussed the Flyweight pattern</p>
<p><em class="italic">Figure 9</em><em class="italic">.15</em> shows the Flyweight pattern saving space by storing implicit data about the idea of a tree in one place in memory.</p>
<div><div><img alt="Figure 9.16: Diagram showing the expansion of the ﻿Flyweight pattern provided by the ﻿﻿type ﻿﻿object pattern" src="img/Figure_09.16_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16: Diagram showing the expansion of the Flyweight pattern provided by the type object pattern</p>
<p>Expanding the <a id="_idIndexMarker407"/>pattern from Flyweight to type object in <em class="italic">Figure 9</em><em class="italic">.16</em>, we define more types as different sets of the implicit data. This diagram makes it clear the cost of this added expandability will be memory. Now only objects sharing a type can be batched together, so the number of batch calls increases but we are still way beyond defining every tree explicitly.</p>
<p>This is not the only way of achieving this outcome though. We could keep our Flyweight pattern and make a new class for each of our types. That would work, so why don’t we do that? Because code takes up space. In the next chapter, we’ll cover the idea of data locality, it builds on the knowledge that instructions in code, such as values we manipulate, take up space in memory. Duplicating a class also duplicates the code that needs to be stored to run, not to mention the overhead cost of defining and storing a new class. Our aim is to make an elegant solution that streamlines the content creation process and increases efficiency.</p>
<p>To make the type object pattern work in Unreal, we need to store a collection of data as an asset that can be loaded into the RAM at runtime for referencing. This could be achieved with writing text files or some other structured file format like JSON or XML. The problem there is that designers need to have the data files open in a separate text editor to make changes, and the process of saving and reloading the editor preview can become tedious when many small changes are made iteratively. Thankfully, Unreal Engine gives us a few options of built-in structures we can use. We will be looking at Variants and the Variant Manager, Data Assets, and Data Tables. There are undoubtedly more<a id="_idIndexMarker408"/> ways to make this work but these three should cover most of the general implementations of the type object pattern.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor144"/>Variants</h2>
<p>The <strong class="bold">Variant Manager</strong> is a <a id="_idIndexMarker409"/>tool within Unreal Engine that allows us to create multiple swapable Variants of actors in a level. The Variants store values for Actor properties and can also call functions from within the actor when the Variant is selected.</p>
<p>The Variants<a id="_idIndexMarker410"/> are held within <a id="_idIndexMarker411"/>the level by a <strong class="bold">Level Variant Sets Actor</strong>, which links to a <strong class="bold">Level Variant Sets</strong> asset where the various actors, their properties to change, and the functions within them to call, are all stored.</p>
<p>Variants are activated either via the <strong class="bold">Variant Manager Panel</strong> while in the editor (as shown in <em class="italic">Figure 9</em><em class="italic">.17</em>) or via Blueprint functions at runtime.</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 9.17 The Variant Manager panel" src="img/Figure_09.17_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 The Variant Manager panel</p>
<p>Variants and the Variant Manager <a id="_idIndexMarker412"/>are more commonly used in interactive experiences such as architectural visualization projects or product-based applications such as car configurators.</p>
<p>The Variant Manager approach could be used for a character creation screen like those seen in RPG-type games such as World of Warcraft or Cyberpunk 2077, or the modular character/vehicle <a id="_idIndexMarker413"/>setup systems in <a id="_idIndexMarker414"/>games such as Fortnite, Fall Guys, or Rocket League, where the player can select different parts to be added to their character.</p>
<p>The drawback with the Variant Manager approach for ever-expanding games such as Fortnite or Fall Guys is the time required to create variants and fully set them up. An in-game character customization system would be much more suited to using a data table approach, where additional data can quickly be added in a table editor or imported from a spreadsheet. Let’s take a look at this next.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor145"/>Data Tables</h2>
<p>Data Tables<a id="_idIndexMarker415"/> are an asset type created for the purpose of storing values with no functionality. We define them in our project with a struct, each member becoming a column in the table. Each row of the table then represents a set of values we call a type to fit in with our pattern. Data Tables<a id="_idIndexMarker416"/> are designed for large-scale storage of data in one place to be queried when necessary. They can store values pointing to other assets, but these are cumbersome to work with in this form and are generally avoided in favor of storing everything as primitive types. This soft limit of primitive data means that, although possible, working with nested information is advised against. This could affect systems where one customization affects what is available in a level below.</p>
<p>The main benefit of this asset is its ability to import directly from a CSV or JSON file, making it the preferred method of balancing for designers with external tools. The flipside of this is because everything is stored together, even if you aren’t using all the types in a given scene, all the data will still be loaded into memory, making it less viable for high-level types and more applicable to utility-type patterns such as quest systems that are universal and always need to be loaded. There is also an argument for using Data Tables for language localization, as with all the types in one place, searches for specific records become way easier and faster.</p>
<div><div><img alt="Figure 9.18: Screenshot of an example Data Table with weapon balancing data" src="img/Figure_09.18_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18: Screenshot of an example Data Table with weapon balancing data</p>
<p><em class="italic">Figure 9</em><em class="italic">.18</em> shows a Data Table in use for balancing the different enemy types in a game where the only changes are stat values as the enemy rank increases. This could have been imported from an external balancing tool as all the values are primitive types.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor146"/>Data Assets</h2>
<p>A <a id="_idIndexMarker417"/>Data Asset takes the idea of <a id="_idIndexMarker418"/>Data Tables and breaks it down into individual rows. Each row then becomes its own asset that can be created and managed via the editor. When we define a Data Asset it looks very much like a struct definition but on instancing it, we do not get a new item in the world. Instead, we get a new Data Asset instance in the project, similar to the way materials and material instances work. Once a Data Asset instance is referenced in active code, that instance is loaded into memory, just like a texture or static mech asset. Due to the editor being responsible for the creation and management of Data Assets, they have easy tools for holding references to other assets. This makes them useful for defining type data for high-level class specialization. They also deal with nested information well, as if it has been serialized properly, the editor has space to show the drop-down menus where sub-values can be manipulated.</p>
<p>The best way to explain how to use Data Assets for a type object pattern is to make something with them. So, let’s turn our attention back to the project we have been working on through this <a id="_idIndexMarker419"/>chapter to implement some <a id="_idIndexMarker420"/>Data Assets:</p>
<ol>
<li>Start by defining a new type of Data Asset by right-clicking in the C++ folder. Make sure to do this from the editor as there are no templates available within Rider, meaning you’ll have to make a lot of unnecessary changes.</li>
<li>When selecting the base class to inherit from, choose <strong class="bold">UDataAsset</strong> from the <strong class="bold">All </strong><strong class="bold">Classes</strong> menu.</li>
<li>Then give it a name. We have called ours <code>EnemyType</code>.</li>
</ol>
<div><div><img alt="Figure 9.19: Class creation menu setup to make a new Data Asset" src="img/Figure_09.19_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19: Class creation menu setup to make a new Data Asset</p>
<p>Next, we consider what data we need to store inside the asset. There could be any number of things we want to vary between different enemy types. The key is to make sure you only store data specifically about the enemy here, and not the other classes that could be different within the enemy class, such as the weapon fire rate. Weapons would need another parallel implementation of the type object pattern, which could even be nested within this one with the weapon type defined within the enemy type:</p>
<ol>
<li>Give the class the <code>BlueprintType</code> property in the <code>UCLASS</code> block.</li>
<li>We are only changing the health and materials on the enemy with its type, so add a float for health and a couple of object pointers to the <code>UmaterialInstance</code> variables.</li>
<li>Make sure each<a id="_idIndexMarker421"/> variable <a id="_idIndexMarker422"/>has the <code>EditAnywhere</code> and <code>BlueprintReadWrite</code> property specifiers, and we are all done with the C++ side:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">EnemyType.h exerpt</p>
<pre class="source-code">
UCLASS(BlueprintType)
class RTS_AI_API UEnemyType : public UDataAsset
{
    GENERATED_BODY()
public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float _Health;
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TObjectPtr&lt;UMaterialInstance&gt; _Material1;
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TObjectPtr&lt;UMaterialInstance&gt; _Material2;
};</pre> <p>The next step is to <a id="_idIndexMarker423"/>define some<a id="_idIndexMarker424"/> Data Assets from the template we have just created:</p>
<ol>
<li>Build back into the editor and right-click on the <strong class="bold">RTS/Data</strong> folder.</li>
<li>Select <strong class="bold">Miscellaneous</strong> &gt; <strong class="bold">Data Asset</strong>.</li>
</ol>
<div><div><img alt="Figure 9.20: The Data Asset option is in the right-click menu" src="img/Figure_09.20_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20: The Data Asset option is in the right-click menu</p>
<ol>
<li value="3">Select <strong class="bold">EnemyType</strong> from the list of classes to be the parent.</li>
<li>Give the new asset a name that represents the type we are making (we have gone with <code>Enemy_Basic</code>) and then open it up.</li>
<li>Set the health value to <code>100</code> and select <strong class="bold">MI_EnemyUnit_01</strong> and <strong class="bold">MI_EnemyUnit_02</strong> for the material slots.</li>
</ol>
<p>The last step is to apply these values to the unit on spawn:</p>
<ol>
<li>Open <strong class="bold">BP_EnemyUnit</strong>, found in the <strong class="bold">RTS/Blueprints</strong> folder.</li>
<li>Add a new variable of type <strong class="bold">EnemyType</strong> and make it editable by clicking the eye icon, as shown in <em class="italic">Figure 9</em><em class="italic">.21</em>. Then set its default value to <strong class="bold">Enemy_Basic</strong>.</li>
</ol>
<div><div><img alt="Figure 9.21: The BP_EnemyUnit variables" src="img/Figure_09.21_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21: The BP_EnemyUnit variables</p>
<ol>
<li value="3">Add a <strong class="bold">BeginPlay</strong> event node to the event graph.</li>
<li>Check whether the new <strong class="bold">TypeData</strong> variable has a value.</li>
<li>Then <a id="_idIndexMarker425"/>place each value from the <strong class="bold">TypeData</strong> variable into its relevant place as <a id="_idIndexMarker426"/>shown in <em class="italic">Figure 9</em><em class="italic">.22</em>.</li>
</ol>
<div><div><img alt="Figure 9.22 Screenshot showing BP_EnemyUnit event graph applying Type Data" src="img/Figure_09.22_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 Screenshot showing BP_EnemyUnit event graph applying Type Data</p>
<p>Doing all this should make nothing appear or behave differently, but it does now give us the flexibility to define new types of enemy with different materials in the Content Browser. We can then set spawned enemies to be different types using the editable variable. As an extension to this, see if you can define a new enemy type with 200 health that uses the B versions of the material instances we used for the basic type. These can be found in the same folder as the materials we were using before but are tinted blue. Another extension you could try is to set the type variable to expose on spawn and dynamically spawn a few enemies in the level. This will allow you to set the type in the code, hopefully demonstrating the power of this system.</p>
<p>We’ve explored the ways in which the type object can be utilized in gameplay to facilitate large numbers of variants using three different approaches in Unreal Engine: Variants, Data Tables, and Data Assets. With the completion of our type object example, we have come to the end of our exploration of patterns that can be used to build structured solutions.</p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor147"/>Summary</h1>
<p>The three patterns we have covered in this chapter are the most widely used structural patterns. Use of the first two is a personal preference, as we saw they can both be used to achieve the same thing in different ways. Template and subclass sandbox are also being superseded by other techniques in modern code, such as interfaces and modular design, but understanding where they came from and the workflow they encourage is useful. Template and subclass Sandbox both highlight the need to constrain designers with limited access to ensure the maintainability of the codebase. The type object pattern, on the other hand, is one of the most useful patterns in game development with widespread application across all aspects of game design. Its utility in allowing artists, designers, and programmers to work together is invaluable.</p>
<p>In the next chapter, we will dive into a few patterns that we can apply once we have a working game to improve our performance using the concepts of object pooling, data locality, and dirty flags.</p>
</div>
</body></html>