<html><head></head><body>
<div id="_idContainer177">
<h1 class="chapter-number" id="_idParaDest-117"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-118"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.2.1">Structuring Code with Behavioral Patterns – Template, Subclass Sandbox, and Type Object</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter focuses on the three most common structural patterns. </span><span class="koboSpan" id="kobo.3.2">Structural patterns allow us to plan our code with the end usage in mind. </span><span class="koboSpan" id="kobo.3.3">For example, if we know that the end users of our system are likely to be designers with no code experience, we could plan to use the type object pattern to provide a system for easy dynamic expansion. </span><span class="koboSpan" id="kobo.3.4">We have already covered some of the concepts around code structure when we discussed using interfaces and events to achieve anonymous modular design in </span><a href="B18297_07.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">The three patterns in this chapter (template, subclass sandbox, and type object) are a little more zoomed-in in terms of scope compared to what we have looked at before. </span><span class="koboSpan" id="kobo.5.3">The first two are interchangeable depending on your preference, both working as extensions to the standard inheritance property of the C++ programming language. </span><span class="koboSpan" id="kobo.5.4">The last is by far the most useful pattern in game design, giving designers the ability to define variants of classes with ease without getting in the programmers’ way while they make </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">new functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">The topics we will cover in this chapter are </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Exploring the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.10.1">Template</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.11.1"> pattern</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Understanding </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.13.1">Subclass Sandbox</span></strong></span></li>
<li><span class="koboSpan" id="kobo.14.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.15.1">Type </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.16.1">Object</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.17.1"> pattern</span></span></li>
</ul>
<h1 id="_idParaDest-119"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">Unlike previous chapters, we will be starting with the project files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">chapter9</span></strong><span class="koboSpan" id="kobo.21.1"> branch on GitHub, which can be downloaded </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">from </span></span><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter09"><span class="No-Break"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter09</span></span></a></p>
<p><span class="koboSpan" id="kobo.24.1">We have made a few small changes to the project to facilitate the following pattern examples. </span><span class="koboSpan" id="kobo.24.2">These changes are a bit too tedious to walk through in this chapter but if you would like to see what has changed, then download both this and the previous chapters’ branches and run them through a diffing program such </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">as DiffMerge.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">get started.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.28.1">Exploring the template pattern</span></h1>
<p><span class="koboSpan" id="kobo.29.1">The template pattern</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.30.1"> exists as an extension to standard inheritance, where we define a structure in an abstract parent class and the children are given the opportunity to override the pieces of that structure. </span><span class="koboSpan" id="kobo.30.2">They can change how individual parts function but not the order of execution. </span><span class="koboSpan" id="kobo.30.3">The simplest example of this within Unreal is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">AActor</span></strong><span class="koboSpan" id="kobo.32.1"> base class. </span><span class="koboSpan" id="kobo.32.2">Any child of AActor gets access to the Begin Play, Tick, and End Play events, to name but a few. </span><span class="koboSpan" id="kobo.32.3">The child class can hook functionality onto these events, and they will fire when expected. </span><span class="koboSpan" id="kobo.32.4">The constraint we place on inheritance to make this into the template pattern is that the child has no way of changing the order or timing of these events. </span><span class="koboSpan" id="kobo.32.5">There is no way to make End Play fire before Begin Play as this order has been defined in </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the parent.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">We can see an example of a class implementing the template pattern in the following code. </span><span class="koboSpan" id="kobo.34.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">ProcessGame()</span></strong><span class="koboSpan" id="kobo.36.1"> function is the only one with a body, defining the order of the private </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">abstract function:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.38.1">Template pattern parent pseudocode</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.39.1">
public class AActor
{
public:
void ProcessGame() {
BeginPlay();
while(gameRunning)
    Tick();
    EndPlay();
    }
protected:
    abstract void BeginPlay();
    abstract void Tick();
    abstract void EndPlay();
}</span></pre> <p><span class="koboSpan" id="kobo.40.1">We can see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">AActor</span></strong><span class="koboSpan" id="kobo.42.1"> class has four functions with only one of them not marked as abstract or virtual. </span><span class="koboSpan" id="kobo.42.2">This function is our spine that defines the order of execution. </span><span class="koboSpan" id="kobo.42.3">From there, each of the other functions may have some form of implementation in the base but they are designed to be ultimately overridden. </span><span class="koboSpan" id="kobo.42.4">The best situation is for each of these extra utility functions to be abstract with no implementation in the base to retain the lightweight nature of the pattern, but if that means that a lot of the implementations will be repeated, then a virtual base with the common code would be better. </span><span class="koboSpan" id="kobo.42.5">The goal is to keep this class as </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.43.1">light as possible while cutting down as much repetition as </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">we can.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.45.1">Important caveat</span></p>
<p class="callout"><span class="koboSpan" id="kobo.46.1">Strictly speaking, the actual structure of </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">AActor</span></strong><span class="koboSpan" id="kobo.48.1"> doesn’t implement the Template pattern, as shown in the pseudocode; we collapsed the tree a little to make a point. </span><span class="koboSpan" id="kobo.48.2">In reality, that loop is dealt with by the world object and filtered down to all the actors and subsystems </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">within it.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">To demonstrate this, we are going to give our elite unit some weapons. </span><span class="koboSpan" id="kobo.50.2">In the GitHub branch for this chapter, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">EliteUnit</span></strong><span class="koboSpan" id="kobo.52.1"> C++ class has already been augmented to spawn a weapon from a base class defined in the class defaults. </span><span class="koboSpan" id="kobo.52.2">This spawned weapon is an actor that we have attached to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">SceneComponent</span></strong><span class="koboSpan" id="kobo.54.1">, positioned just in front of the character. </span><span class="koboSpan" id="kobo.54.2">The code is also modified to call the fire function on this weapon instead of running a line trace from within the character. </span><span class="koboSpan" id="kobo.54.3">As it currently stands, this code will not run as there are no classes available for the character to spawn from that are not marked as abstract. </span><span class="koboSpan" id="kobo.54.4">Our first step is to build the template parent class as a child of this generic weapon in C++. </span><span class="koboSpan" id="kobo.54.5">We can then leave the creation of the functional child weapons to a Blueprint, giving us an excellent way to understand how the two systems work together and allowing programmers to do the groundwork in C++ before the technical designers and designers </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.55.1">explore variations in Blueprints. </span><span class="koboSpan" id="kobo.55.2">This allows for quick prototyping and iteration of weapon designs to achieve the intended game feel without breaking any of the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">underlying systems.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.57.1">Building the template (parent class)</span></h2>
<p><span class="koboSpan" id="kobo.58.1">As mentioned earlier, our</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.59.1"> first step is to make a new C++ child class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">AWeapon_Base</span></strong><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">With that made, we can set about putting the template main function in place which, as we can see in the code below, is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">Fire()</span></strong><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">The parent class has a lot of the data and a core system for dealing with a brief cooldown delay between shots. </span><span class="koboSpan" id="kobo.63.3">These variables have been added at the top level as they will be universal to all weapon types and so it makes sense to consolidate them in the common parent. </span><span class="koboSpan" id="kobo.63.4">This does mean that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">Fire()</span></strong><span class="koboSpan" id="kobo.65.1"> function here is an override, whereas in a straight implementation of the template pattern, this would be at the top level. </span><span class="koboSpan" id="kobo.65.2">We are only doing things differently here to create a shared hierarchy with the Sandbox pattern that we’ll see in the next section to highlight </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">the differences.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">The other functions in the template weapon base class include a public function for reloading, as you may want to actively call that function even though we will be triggering it by default anyway. </span><span class="koboSpan" id="kobo.67.2">This is followed by a bunch of utility functions that are marked as either </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">BlueprintNativeEvent</span></strong><span class="koboSpan" id="kobo.69.1"> if they have a default implementation in the base, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">BlueprintImplementableEvent</span></strong><span class="koboSpan" id="kobo.71.1"> if they do not. </span><span class="koboSpan" id="kobo.71.2">Each of these protected functions exists to be overridden by the children to change the behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">the weapon:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.73.1">TemplateWeapon_Base.h excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.74.1">
UCLASS(Abstract)
class RTS_AI_API ATemplateWeapon_Base : public AWeapon_Base
{
    GENERATED_BODY()
public:
    virtual void Fire() override;
    UFUNCTION(BlueprintCallable, BlueprintNativeEvent)
    void Reload();
protected:
    UFUNCTION(BlueprintNativeEvent)
    bool CheckAmmo();
    UFUNCTION(BlueprintImplementableEvent)
    void ProcessFiring();
    UFUNCTION(BlueprintImplementableEvent)
    void PlayEffects();
    UFUNCTION(BlueprintNativeEvent)
    void UpdateAmmo();
};</span></pre> <p><span class="koboSpan" id="kobo.75.1">The only function in the</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.76.1"> implementation of this class is the template spine we are calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">Fire()</span></strong><span class="koboSpan" id="kobo.78.1">. </span><span class="koboSpan" id="kobo.78.2">In this function, we define the execution order of all the other functions in a way that becomes concrete. </span><span class="koboSpan" id="kobo.78.3">In the following implementation, we check whether we can fire; if not, we use an early return to exit the function. </span><span class="koboSpan" id="kobo.78.4">Then we check whether we have the ammo to fire; if not, then we’ll reload. </span><span class="koboSpan" id="kobo.78.5">If the weapon is able to fire, then the process outlined by this function starts with the effects, then runs the gameplay logic for actually firing with the reduction in ammo calculated after that. </span><span class="koboSpan" id="kobo.78.6">The last thing it does is call the parent, where we have set up the code to deal with the firing delay (which is used to prevent the fire button being spammed or exploited with auto-clickers </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">and macros):</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.80.1">TemplateWeapon_Base.cpp main template function</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.81.1">
void ATemplateWeapon_Base::Fire()
{
    if(!_CanFire) return;
    if(CheckAmmo())
    {
        PlayEffects();
        ProcessFiring();
        UpdateAmmo();
        Super::Fire();
        return;
    }
    Reload();
}</span></pre> <p><span class="koboSpan" id="kobo.82.1">The next few</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.83.1"> functions are just default implementations that make sense and are likely to be repeated code if not defined here. </span><span class="koboSpan" id="kobo.83.2">The reload function resets the ammo counter and calls the fire delay reset function. </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">CheckAmmo</span></strong><span class="koboSpan" id="kobo.85.1"> is a one-line Boolean check that could be made pure as an extension to this. </span><span class="koboSpan" id="kobo.85.2">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">UpdateAmmo</span></strong><span class="koboSpan" id="kobo.87.1"> just takes the predefined </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">_AmmoPerFire</span></strong><span class="koboSpan" id="kobo.89.1"> from our </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">ammo counter:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.91.1">TemplateWeapon_Base.cpp utility functions</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.92.1">
void ATemplateWeapon_Base::Reload_Implementation()
{
    _CurrentAmmo = _MaxAmmo;
    Handle_FireDelay();
}
bool ATemplateWeapon_Base::CheckAmmo_Implementation()
{
    return _AmmoPerFire &lt;= _CurrentAmmo;
}
void ATemplateWeapon_Base::UpdateAmmo_Implementation()
{
    _CurrentAmmo -= _AmmoPerFire;
}</span></pre> <p><span class="koboSpan" id="kobo.93.1">That forms </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.94.1">the C++ base for our template pattern. </span><span class="koboSpan" id="kobo.94.2">All that is left is to make an implementation or two with Blueprint child classes in </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">the editor.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.96.1">Creating child classes</span></h2>
<p><span class="koboSpan" id="kobo.97.1">We are now</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.98.1"> going to create two child classes in a Blueprint. </span><span class="koboSpan" id="kobo.98.2">This task offers us a great opportunity to explore how C++ and Blueprints can work together to create efficient solutions. </span><span class="koboSpan" id="kobo.98.3">To do this, we need to create new child Blueprints, one for a pistol and a second for a shotgun. </span><span class="koboSpan" id="kobo.98.4">These weapons both utilize a line-trace approach with variation for multiple projectiles in a spread. </span><span class="koboSpan" id="kobo.98.5">This allows us to focus on creating two different solutions with a small but significant change to build a solid example for the template pattern. </span><span class="koboSpan" id="kobo.98.6">To do this, we are going to use the same menu from before, but instead of selecting </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">Actor</span></strong><span class="koboSpan" id="kobo.100.1"> from the dialog, we need to dig a bit deeper to find the C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">parent class:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.102.1">Start by right-clicking in the Content Browser and clicking </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.103.1">Blueprint Class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.105.1">If it isn’t already visible, expand the </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">ALL CLASSES</span></strong><span class="koboSpan" id="kobo.107.1"> rollout by clicking </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">the title.</span></span></li>
<li><span class="koboSpan" id="kobo.109.1">In the search box, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">template</span></strong><span class="koboSpan" id="kobo.111.1"> to reduce the number of options displayed in the results box, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.112.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.113.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer155">
<span class="koboSpan" id="kobo.115.1"><img alt="Figure 9.1: ﻿The Blueprint creation window for a template weapon" src="image/Figure_09.01_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.116.1">Figure 9.1: The Blueprint creation window for a template weapon</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.117.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">TemplateWeapon_Base </span></strong><span class="koboSpan" id="kobo.119.1">from the list, then click </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Select</span></strong><span class="koboSpan" id="kobo.121.1">, which will only </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.122.1">appear once you’ve made </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">your selection.</span></span></li>
<li><span class="koboSpan" id="kobo.124.1">Name this new </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">Blueprint </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">BP_TemplatePistol</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.128.1">With the pistol child Blueprint created, we next need to create a child Blueprint for the shotgun. </span><span class="koboSpan" id="kobo.128.2">To do this, repeat the preceding steps but name the second </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">blueprint </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">BP_TemplateShotgun</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Now that the child classes have been created, we can move on to creating the behaviors inside them, making use of the template pattern to only modify the part of the class necessary to achieve the desired functionality of </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">each child.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.134.1">Template pistol</span></h2>
<p><span class="koboSpan" id="kobo.135.1">Now that we have our Blueprint for the </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.136.1">Pistol set up, we can move on to overriding the parts of the template that will be unique to this class. </span><span class="koboSpan" id="kobo.136.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">CheckAmmo</span></strong><span class="koboSpan" id="kobo.138.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">UpdateAmmo</span></strong><span class="koboSpan" id="kobo.140.1"> functions will remain the same for our pistol class as in the parent template. </span><span class="koboSpan" id="kobo.140.2">We will be overriding </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">PlayEffects</span></strong><span class="koboSpan" id="kobo.142.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">ProcessFiring</span></strong><span class="koboSpan" id="kobo.144.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">Reload</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">We’ve overridden functions before, namely in </span><a href="B18297_08.xhtml#_idTextAnchor113"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.149.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.150.1"> when looking at utility blueprints. </span><span class="koboSpan" id="kobo.150.2">The process here is exactly </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">the same.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.152.1">Note on overriding C++ functions</span></p>
<p class="callout"><span class="koboSpan" id="kobo.153.1">When we override functions in a Blueprint that are included within a C++ parent, we don’t get a choice between creating a function or an event. </span><span class="koboSpan" id="kobo.153.2">The result we get when selecting to override the C++ function will depend on whether the function has a return or not. </span><span class="koboSpan" id="kobo.153.3">If a function does not contain a return, the override in the Blueprint will automatically create an Event node in the main Blueprint Event Graph. </span><span class="koboSpan" id="kobo.153.4">If the function does have a return (like </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">CheckAmmo</span></strong><span class="koboSpan" id="kobo.155.1"> does), the override will provide a </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">Blueprint function.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">First, we are going to override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">PlayEffects</span></strong><span class="koboSpan" id="kobo.159.1"> function. </span><span class="koboSpan" id="kobo.159.2">This is where we would typically add a muzzle flash particle effect and play an animation and a sound. </span><span class="koboSpan" id="kobo.159.3">In the interest of keeping the repository for this exercise small, and the number of steps short to allow us to focus on learning, we will just add a sound effect. </span><span class="koboSpan" id="kobo.159.4">Again, in the interest of keeping the required download small, we will use a sound from the Engine Content as opposed to finding a purpose-selected sound for the gun. </span><span class="koboSpan" id="kobo.159.5">Let’s do this </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.161.1">Open the Blueprint and on the left side, hover over the </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">Functions</span></strong><span class="koboSpan" id="kobo.163.1"> section of the </span><strong class="bold"><span class="koboSpan" id="kobo.164.1">My Blueprint</span></strong><span class="koboSpan" id="kobo.165.1"> tab. </span><span class="koboSpan" id="kobo.165.2">This should reveal the </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">Override</span></strong><span class="koboSpan" id="kobo.167.1"> dropdown. </span><span class="koboSpan" id="kobo.167.2">From this, select </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.168.1">Play Effects</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.170.1">This should have added an </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">Event Play Effects</span></strong><span class="koboSpan" id="kobo.172.1"> node to the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">Event Graph.</span></span></li>
<li><span class="koboSpan" id="kobo.174.1">Drag from the pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">Event Play Effects</span></strong><span class="koboSpan" id="kobo.176.1"> node and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">Play Sound at </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.179.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.180.1">Expand the </span><strong class="bold"><span class="koboSpan" id="kobo.181.1">Sound</span></strong><span class="koboSpan" id="kobo.182.1"> dropdown and search for </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">VR_Teleport</span></strong><span class="koboSpan" id="kobo.184.1">. </span><span class="koboSpan" id="kobo.184.2">If nothing appears, you will need to enable </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">Show Engine Content</span></strong><span class="koboSpan" id="kobo.186.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.187.1">Settings</span></strong><span class="koboSpan" id="kobo.188.1"> dropdown, which can be accessed by clicking the cog icon in the top right of </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">the dropdown.</span></span></li>
<li><span class="koboSpan" id="kobo.190.1">Drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">Location</span></strong><span class="koboSpan" id="kobo.192.1"> pin to the </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">Play Sound at Location</span></strong><span class="koboSpan" id="kobo.194.1"> node and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">Get Actor </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1"> node.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer156">
<span class="koboSpan" id="kobo.198.1"><img alt="Figure 9.2: The overridden Event Play Effects function in the Blueprint" src="image/Figure_09.02_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.199.1">Figure 9.2: The overridden Event Play Effects function in the Blueprint</span></p>
<p><span class="koboSpan" id="kobo.200.1">Next, we will </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.201.1">override </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">ProcessFiring</span></strong><span class="koboSpan" id="kobo.203.1">. </span><span class="koboSpan" id="kobo.203.2">This is where we are going to put all of our firing logic. </span><span class="koboSpan" id="kobo.203.3">The precise contents of this function will differ depending on the type of weapon. </span><span class="koboSpan" id="kobo.203.4">For the pistol, we can use a simple line trace similar to the approach taken for attacking enemies that we created in </span><a href="B18297_04.xhtml#_idTextAnchor057"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.204.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.205.1"> when making the Behavior Tree for the Elite Unit. </span><span class="koboSpan" id="kobo.205.2">To begin, let’s set up </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">the trace:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.207.1">Drag from the pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">Event Process Firing</span></strong><span class="koboSpan" id="kobo.209.1"> node and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">Line Trace by Channel</span></strong><span class="koboSpan" id="kobo.211.1"> node to </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">the graph.</span></span></li>
<li><span class="koboSpan" id="kobo.213.1">Drag in the </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">Fire Point</span></strong><span class="koboSpan" id="kobo.215.1"> component from the </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">Components</span></strong><span class="koboSpan" id="kobo.217.1"> tab. </span><span class="koboSpan" id="kobo.217.2">From the resulting node, drag out and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">Get World Location</span></strong><span class="koboSpan" id="kobo.219.1"> node and then repeat this again to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">Get Forward </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">Vector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.222.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.223.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">Return Value</span></strong><span class="koboSpan" id="kobo.225.1"> pin on </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">Get World Location</span></strong><span class="koboSpan" id="kobo.227.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">Start</span></strong><span class="koboSpan" id="kobo.229.1"> pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">Line Trace By </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.231.1">Channel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.232.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.233.1">Drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.234.1">Return Value</span></strong><span class="koboSpan" id="kobo.235.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">Get Forward Vector</span></strong><span class="koboSpan" id="kobo.237.1"> node and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Multiply</span></strong><span class="koboSpan" id="kobo.239.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">x</span></strong><span class="koboSpan" id="kobo.241.1">) node by typing </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">*</span></strong><span class="koboSpan" id="kobo.243.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">search box.</span></span></li>
<li><span class="koboSpan" id="kobo.245.1">Right-click the lower pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">Multiply </span></strong><span class="koboSpan" id="kobo.247.1">node and select </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">Convert Pin | Float (single-precision)</span></strong><span class="koboSpan" id="kobo.249.1">. </span><span class="koboSpan" id="kobo.249.2">This will turn the yellow pin green, indicating that the variable expected is no longer a vector but now </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">a float.</span></span></li>
<li><span class="koboSpan" id="kobo.251.1">Drag from the green pin and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">Get Range</span></strong><span class="koboSpan" id="kobo.253.1"> node. </span><span class="koboSpan" id="kobo.253.2">This will add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">Range</span></strong><span class="koboSpan" id="kobo.255.1"> variable defined in the </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">parent class.</span></span></li>
<li><span class="koboSpan" id="kobo.257.1">Once again drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">Get World Location</span></strong><span class="koboSpan" id="kobo.259.1"> node and create an </span><strong class="bold"><span class="koboSpan" id="kobo.260.1">Add</span></strong><span class="koboSpan" id="kobo.261.1"> node (reached by </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">typing </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.263.1">+</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.265.1">Connect the lower input vector pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.266.1">Add</span></strong><span class="koboSpan" id="kobo.267.1"> node to the output vector pin of the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.268.1">Multiply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.269.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.270.1">Connect the output of the </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">Add</span></strong><span class="koboSpan" id="kobo.272.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.273.1">End</span></strong><span class="koboSpan" id="kobo.274.1"> pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">Line Trace By </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.276.1">Channel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.277.1"> node.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.278.1">Next, we need to tell the line</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.279.1"> trace to ignore the character when shooting, or else the only character the gun will damage will be the one </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">firing it:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.281.1">Right-click in the event graph and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">Get </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">Owner</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.284.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.285.1">Drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">Return Value</span></strong><span class="koboSpan" id="kobo.287.1"> output of the </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">Get Owner</span></strong><span class="koboSpan" id="kobo.289.1"> node and add a </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">Make </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.291.1">Array</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.292.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.293.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.294.1">Array</span></strong><span class="koboSpan" id="kobo.295.1"> output pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">Make Array</span></strong><span class="koboSpan" id="kobo.297.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">Actors to Ignore</span></strong><span class="koboSpan" id="kobo.299.1"> pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">Line Trace By </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.301.1">Channel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1"> node.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.303.1">The line trace is now set up and should look like the graph shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.304.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.305.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer157">
<span class="koboSpan" id="kobo.307.1"><img alt="Figure 9.3: The Line Trace node with the inputs setup" src="image/Figure_09.03_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.308.1">Figure 9.3: The Line Trace node with the inputs setup</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.309.1">Drag and drop variables defined in the parent class</span></p>
<p class="callout"><span class="koboSpan" id="kobo.310.1">If you’d like to be able to drag the variables we defined in the parent class into the graph in the same way you would with a variable created in a blueprint, click the cog in the top right of the </span><strong class="bold"><span class="koboSpan" id="kobo.311.1">My Blueprint</span></strong><span class="koboSpan" id="kobo.312.1"> tab and enable </span><strong class="bold"><span class="koboSpan" id="kobo.313.1">Show </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.314.1">Inherited Variables</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">Next, we need to </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.317.1">do something with the result of the trace. </span><span class="koboSpan" id="kobo.317.2">In this case, we are going to use the Apply Damage approach, just as we did in </span><a href="B18297_04.xhtml#_idTextAnchor057"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.318.1">Chapter 4</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.319.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.320.1">Drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">Out Hit</span></strong><span class="koboSpan" id="kobo.322.1"> pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">Line Trace By Channel</span></strong><span class="koboSpan" id="kobo.324.1"> node and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">Break Hit </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">Result</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.327.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.328.1">Drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">Hit Actor</span></strong><span class="koboSpan" id="kobo.330.1"> pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">Break Hit Result</span></strong><span class="koboSpan" id="kobo.332.1"> node and add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Apply </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">Damage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.336.1">To make the graph easier to read, click the collapse arrow (</span><strong class="bold"><span class="koboSpan" id="kobo.337.1">^</span></strong><span class="koboSpan" id="kobo.338.1">) on the bottom of the </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">Break Hit Result</span></strong><span class="koboSpan" id="kobo.340.1"> node. </span><span class="koboSpan" id="kobo.340.2">This will collapse the node to only show the top two bool pins and any pins that have been used, hiding any unused pins. </span><span class="koboSpan" id="kobo.340.3">In this case, just the </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">Hit Actor</span></strong><span class="koboSpan" id="kobo.342.1"> pin will remain visible along with the top two bool pins (</span><strong class="bold"><span class="koboSpan" id="kobo.343.1">Blocking Hit</span></strong><span class="koboSpan" id="kobo.344.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.345.1">Initial Overlap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.347.1">Drag back from the </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">Base Damage</span></strong><span class="koboSpan" id="kobo.349.1"> pin and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Get Damage Per Hit</span></strong><span class="koboSpan" id="kobo.351.1"> node, once again grabbing a variable defined in </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">the parent.</span></span></li>
<li><span class="koboSpan" id="kobo.353.1">Lastly, drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">Return Value</span></strong><span class="koboSpan" id="kobo.355.1"> bool pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.356.1">Line Trace By Channel</span></strong><span class="koboSpan" id="kobo.357.1"> and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">Branch</span></strong><span class="koboSpan" id="kobo.359.1"> node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">If</span></strong><span class="koboSpan" id="kobo.361.1">) and connect the three nodes together as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.362.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.363.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer158">
<span class="koboSpan" id="kobo.365.1"><img alt="Figure 9.4: The result of the trace used to apply damage to the enemy unit" src="image/Figure_09.04_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.366.1">Figure 9.4: The result of the trace used to apply damage to the enemy unit</span></p>
<p><span class="koboSpan" id="kobo.367.1">The last thing to do is to check the values of each of the inherited variables. </span><span class="koboSpan" id="kobo.367.2">You can do this by clicking on the variable nodes or, if you chose to show inherited variables, you can select them from the variables list in the </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">My </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.369.1">Blueprint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.370.1"> tab.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Ensure that the </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">Default Value</span></strong><span class="koboSpan" id="kobo.373.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.374.1">Range</span></strong><span class="koboSpan" id="kobo.375.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">1000.0</span></strong><span class="koboSpan" id="kobo.377.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.378.1">Damage Per Hit</span></strong><span class="koboSpan" id="kobo.379.1"> is set </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">20.0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">With the firing of</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.384.1"> the weapon sorted, we can next turn our attention to the reload function. </span><span class="koboSpan" id="kobo.384.2">Unlike the previous two overrides, the reload function is not an abstract function. </span><span class="koboSpan" id="kobo.384.3">The parent template class already handles the functional aspect of the reload, adding the ammo back into the weapon, so we need to ensure we retain that in the child class. </span><span class="koboSpan" id="kobo.384.4">We can then add all the extra elements such as sounds, animations, particle effects, and so on. </span><span class="koboSpan" id="kobo.384.5">Once again, let’s keep this simple by just adding a sound. </span><span class="koboSpan" id="kobo.384.6">First, let’s override the Reload function and ensure we are maintaining the functionality from the </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">parent class:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.386.1">Override the </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">Reload </span></strong><span class="koboSpan" id="kobo.388.1">in function in the same way as we did for the previous two functions. </span><span class="koboSpan" id="kobo.388.2">This will add the </span><strong class="bold"><span class="koboSpan" id="kobo.389.1">Event Reload</span></strong><span class="koboSpan" id="kobo.390.1"> node to the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.391.1">Event Graph</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.393.1">Right-click on the </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">Event Reload</span></strong><span class="koboSpan" id="kobo.395.1"> node and select </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">Add call to parent function</span></strong><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">This will add a </span><strong class="bold"><span class="koboSpan" id="kobo.398.1">Parent: Reload</span></strong><span class="koboSpan" id="kobo.399.1"> node </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">for you.</span></span></li>
<li><span class="koboSpan" id="kobo.401.1">Move the </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">Parent: Reload</span></strong><span class="koboSpan" id="kobo.403.1"> node beside the </span><strong class="bold"><span class="koboSpan" id="kobo.404.1">Event Reload</span></strong><span class="koboSpan" id="kobo.405.1"> node and connect </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">them together.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer159">
<span class="koboSpan" id="kobo.407.1"><img alt="Figure 9.5: The Event Reload and Parent: Reload nodes" src="image/Figure_09.05_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.408.1">Figure 9.5: The Event Reload and Parent: Reload nodes</span></p>
<p><span class="koboSpan" id="kobo.409.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.410.1">Parent: Reload</span></strong><span class="koboSpan" id="kobo.411.1"> node tells </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.412.1">Unreal to do all the steps from the parent version of this function at this point in the </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">logic chain.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">Now that we have the behavior from the parent included in the child, we can add the sound. </span><span class="koboSpan" id="kobo.414.2">We do this just in the same way as we did for the </span><strong class="bold"><span class="koboSpan" id="kobo.415.1">PlayEffects</span></strong><span class="koboSpan" id="kobo.416.1"> event, however this time, we will select the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.417.1">Gizmo_Handle_Clicked</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.418.1"> sound.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer160">
<span class="koboSpan" id="kobo.419.1"><img alt="Figure 9.6: The completed Event Reload function in our Blueprint" src="image/Figure_09.06_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.420.1">Figure 9.6: The completed Event Reload function in our Blueprint</span></p>
<p><span class="koboSpan" id="kobo.421.1">With the reload function sorted, our pistol is complete. </span><span class="koboSpan" id="kobo.421.2">Let’s test it out on the character to make sure it works. </span><span class="koboSpan" id="kobo.421.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.422.1">EliteUnit</span></strong><span class="koboSpan" id="kobo.423.1"> modifications included an automated system for spawning and attaching weapons to the character based on a drop-down box. </span><span class="koboSpan" id="kobo.423.2">Set the weapon </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.425.1">Select the </span><strong class="bold"><span class="koboSpan" id="kobo.426.1">BP_EliteUnit</span></strong><span class="koboSpan" id="kobo.427.1"> that is in </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">the level.</span></span></li>
<li><span class="koboSpan" id="kobo.429.1">Search in the details panel for </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">Weapon </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">to Spawn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.433.1">Change the value in the drop-down box </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.435.1">BP_TemplatePistol</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.437.1">If you</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.438.1"> see </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">TemplateWeapon_Base</span></strong><span class="koboSpan" id="kobo.440.1"> in your drop-down list, then you need to make sure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">UCLASS</span></strong><span class="koboSpan" id="kobo.442.1"> block includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">Abstract</span></strong><span class="koboSpan" id="kobo.444.1"> property so that no one can ever spawn an instance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">base class.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">With the pistol now set up, tested, and functional, let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">the shotgun.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.448.1">Template shotgun</span></h2>
<p><span class="koboSpan" id="kobo.449.1">For the sake of </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.450.1">simplicity and to avoid this being a very long chapter, with the shotgun the only unique approach we will apply is to the </span><strong class="bold"><span class="koboSpan" id="kobo.451.1">Process Firing</span></strong><span class="koboSpan" id="kobo.452.1"> function. </span><span class="koboSpan" id="kobo.452.2">Because the Play Effects and Reload functions are abstract in the parent, we must override them, so before we get started on the Process Firing for the shotgun, replicate the other two functions from the pistol in the </span><strong class="bold"><span class="koboSpan" id="kobo.453.1">BP_TemplateShotgun</span></strong><span class="koboSpan" id="kobo.454.1"> Event Graph. </span><span class="koboSpan" id="kobo.454.2">You can do this by creating them again manually or by copying and pasting them </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">between graphs.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">With that done, let’s move on to sorting the firing out. </span><span class="koboSpan" id="kobo.456.2">Rather than going through this version step by step, let’s look at the differences so you can make the necessary changes to create a shotgun rather than a pistol. </span><span class="koboSpan" id="kobo.456.3">Begin by copying over the firing logic from the pistol before modifying it to replicate each of the changes </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">that follow.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">Unlike a pistol, we need to consider that when fired, a shotgun doesn’t fire a single projectile. </span><span class="koboSpan" id="kobo.458.2">Rather, shotgun shells often contain between nine and eighteen small pellets that are fired out of the barrel in </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">a cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">To replicate this, we simply increase the number of traces we perform and add variation to the direction, maintaining the same start point (the end of the barrel) but adjusting the end point of each trace to mimic the spread of the shot exiting </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">the barrel</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">Let’s get started by using multiple traces to replicate the shotgun </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">shell’s behavior.</span></span></p>
<h3><span class="koboSpan" id="kobo.464.1">Adding a for loop to fire multiple pellets</span></h3>
<p><span class="koboSpan" id="kobo.465.1">To perform</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.466.1"> multiple line traces, we need to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">For Loop</span></strong><span class="koboSpan" id="kobo.468.1"> as the first node in the </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">Event Process Firing</span></strong><span class="koboSpan" id="kobo.470.1"> logic chain, connecting the </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">Line Trace By Channel</span></strong><span class="koboSpan" id="kobo.472.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.473.1">Branch</span></strong><span class="koboSpan" id="kobo.474.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">Apply Damage</span></strong><span class="koboSpan" id="kobo.476.1"> nodes into the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.477.1">Loop Body</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.480.1">For Loop</span></strong><span class="koboSpan" id="kobo.481.1"> node will complete each of the steps in the </span><em class="italic"><span class="koboSpan" id="kobo.482.1">Loop Body</span></em><span class="koboSpan" id="kobo.483.1">, incrementing its index from the </span><strong class="bold"><span class="koboSpan" id="kobo.484.1">First Index</span></strong><span class="koboSpan" id="kobo.485.1"> value to the </span><strong class="bold"><span class="koboSpan" id="kobo.486.1">Last </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.487.1">Index</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.488.1"> value.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">For the shotgun, set </span><strong class="bold"><span class="koboSpan" id="kobo.490.1">First Index</span></strong><span class="koboSpan" id="kobo.491.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">1</span></strong><span class="koboSpan" id="kobo.493.1">. </span><span class="koboSpan" id="kobo.493.2">Typically, we would use </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">0</span></strong><span class="koboSpan" id="kobo.495.1">, however we are going to create an integer variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">NumberOfPellets</span></strong><span class="koboSpan" id="kobo.497.1"> for the </span><strong class="bold"><span class="koboSpan" id="kobo.498.1">Last Index</span></strong><span class="koboSpan" id="kobo.499.1"> and set the </span><strong class="bold"><span class="koboSpan" id="kobo.500.1">Default Value</span></strong><span class="koboSpan" id="kobo.501.1"> of </span><strong class="bold"><span class="koboSpan" id="kobo.502.1">NumberOfPellets</span></strong><span class="koboSpan" id="kobo.503.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">5</span></strong><span class="koboSpan" id="kobo.505.1">. </span><span class="koboSpan" id="kobo.505.2">If we were to keep </span><strong class="bold"><span class="koboSpan" id="kobo.506.1">First Index</span></strong><span class="koboSpan" id="kobo.507.1"> at zero, the shotgun </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.508.1">would fire six pellets, so instead of requiring a designer to remember to reduce the variable by 1 to get their desired number of traces, we simply start at 1 to make the system more </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">user friendly.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer161">
<span class="koboSpan" id="kobo.510.1"><img alt="Figure 9.7: The For Loop node and Number Of Pellets variable" src="image/Figure_09.07_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.511.1">Figure 9.7: The For Loop node and Number Of Pellets variable</span></p>
<p><span class="koboSpan" id="kobo.512.1">With multiple</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.513.1"> traces firing, we now need to make each trace slightly different so that we aren’t just doing multiple identical traces. </span><span class="koboSpan" id="kobo.513.2">Let’s do </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">that next.</span></span></p>
<h3><span class="koboSpan" id="kobo.515.1">Adding spread to the pellet trajectories</span></h3>
<p><span class="koboSpan" id="kobo.516.1">To add</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.517.1"> variation to the </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">End</span></strong><span class="koboSpan" id="kobo.519.1"> vector input of the </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">Line Trace By Channel</span></strong><span class="koboSpan" id="kobo.521.1"> node, we need to rotate the result of the </span><strong class="bold"><span class="koboSpan" id="kobo.522.1">Get Forward Vector</span></strong><span class="koboSpan" id="kobo.523.1"> node slightly before multiplying it by </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">the range.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">To do this, we add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">Random Unit Vector in Cone in Degrees</span></strong><span class="koboSpan" id="kobo.527.1"> node. </span><span class="koboSpan" id="kobo.527.2">This uses a </span><strong class="bold"><span class="koboSpan" id="kobo.528.1">Cone Dir</span></strong><span class="koboSpan" id="kobo.529.1"> input (the initial direction the cone is facing) and a </span><strong class="bold"><span class="koboSpan" id="kobo.530.1">Cone Half Angle in Degrees</span></strong><span class="koboSpan" id="kobo.531.1"> input (the amount of rotation to be applied from the center line of </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">the cone).</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">For </span><strong class="bold"><span class="koboSpan" id="kobo.534.1">Cone Dir</span></strong><span class="koboSpan" id="kobo.535.1">, we connect in the </span><strong class="bold"><span class="koboSpan" id="kobo.536.1">Return Value</span></strong><span class="koboSpan" id="kobo.537.1"> of the </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">Get Forward </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.539.1">Vector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.540.1"> node.</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">For </span><strong class="bold"><span class="koboSpan" id="kobo.542.1">Cone Half Angle in Degrees</span></strong><span class="koboSpan" id="kobo.543.1">, create a new </span><strong class="bold"><span class="koboSpan" id="kobo.544.1">Float</span></strong><span class="koboSpan" id="kobo.545.1"> variable (either by promoting the pin to a variable or from the </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">Variables</span></strong><span class="koboSpan" id="kobo.547.1"> rollout) and name </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">HalfSpreadDegrees.</span></strong></span></p>
<p><span class="koboSpan" id="kobo.550.1">Set</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.551.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.552.1">Default Value</span></strong><span class="koboSpan" id="kobo.553.1"> of </span><strong class="bold"><span class="koboSpan" id="kobo.554.1">HalfSpreadDegrees</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.555.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">15</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer162">
<span class="koboSpan" id="kobo.558.1"><img alt="Figure 9.8: The adjusted firing trajectories" src="image/Figure_09.08_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.559.1">Figure 9.8: The adjusted firing trajectories</span></p>
<p><span class="koboSpan" id="kobo.560.1">Once you’ve added the </span><strong class="bold"><span class="koboSpan" id="kobo.561.1">Random Unit Vector in Cone in Degrees</span></strong><span class="koboSpan" id="kobo.562.1"> node, the calculations should be connected together as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.563.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.564.1">.8</span></em><span class="koboSpan" id="kobo.565.1"> with the vector connections going into the </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">Line Trace By </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.567.1">Channel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.568.1"> node.</span></span></p>
<p><span class="koboSpan" id="kobo.569.1">With all that</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.570.1"> now set up, you are ready to test the shotgun. </span><span class="koboSpan" id="kobo.570.2">Change the variable once more on the Elite Unit in the level and give it </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">a go.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">Once that’s all finished and working, let’s move on to another parent-child structural pattern where everything is the </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">exact opposite.</span></span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.574.1">Understanding subclass sandbox</span></h1>
<p><span class="koboSpan" id="kobo.575.1">The Subclass Sandbox pattern</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.576.1"> takes the idea of the template’s limited extension through subclasses (to provide security) and applies it the exact opposite way round. </span><span class="koboSpan" id="kobo.576.2">Here, the children define the order of execution for a set of pre-defined code blocks through an abstract spine function. </span><span class="koboSpan" id="kobo.576.3">These blocks take the form of functions that are defined in the parent class and can never be overridden. </span><span class="koboSpan" id="kobo.576.4">Each function deals with one thing to do with an external system in a standardized way. </span><span class="koboSpan" id="kobo.576.5">The following pseudocode makes a better visual point of how this is literally the opposite of the template pattern we explored previously, where everything previously marked as abstract gets functionality and the one function we had code in is </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">now abstract:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.578.1">Subclass sandbox pattern parent pseudocode</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.579.1">
public class Sandbox_Parent
{
public:
    abstract void DoAThing();
protected:
    void PlaySound() { //Plays sound correctly }
    void FireParticle() { //Fires particle correctly }
    void AddForce() { //Adds force correctly }
    void DealDamage() { //Deals damage correctly }
}</span></pre> <p><span class="koboSpan" id="kobo.580.1">The workflow for this pattern starts with the programmer building black-box tools for the technical designer to string together in interesting ways. </span><span class="koboSpan" id="kobo.580.2">This can lead to interesting innovation as the programmer isn’t making tools to specification, rather just for the sake of having tools, which leaves their application open for the technical designer to interpret. </span><span class="koboSpan" id="kobo.580.3">The flip side of this is that there could be a lot of wastage where tools either don’t get used or they are used in ways they could be better designed for. </span><span class="koboSpan" id="kobo.580.4">Thus, this process works better as an iteration on both sides to ensure that the toolset is useful and efficient, as well </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.581.1">as actually </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">being used.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">Enough speaking in the abstract: let’s look at the implementation of this for our weapons alongside the </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">template pattern.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.585.1">Building the sandbox (parent class)</span></h2>
<p><span class="koboSpan" id="kobo.586.1">The first step is to copy what </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.587.1">we did in the template section and make another C++ child of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">Weapon_Base</span></strong><span class="koboSpan" id="kobo.589.1"> class, but this time call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">SandboxWeapon_Base</span></strong><span class="koboSpan" id="kobo.591.1">. </span><span class="koboSpan" id="kobo.591.2">The whole point of this pattern is that the Blueprint children will implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">Fire</span></strong><span class="koboSpan" id="kobo.593.1"> function in whatever way they see fit, but for that we would have to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">UFUNCTION(BlueprintNativeEvent)</span></strong><span class="koboSpan" id="kobo.595.1"> at the very least. </span><span class="koboSpan" id="kobo.595.2">However, because we have joined our patterns together with this common parent, it means the function has to be marked as virtual and so cannot have a standard function specifier. </span><span class="koboSpan" id="kobo.595.3">This will never be the case in any production code. </span><span class="koboSpan" id="kobo.595.4">It is only a problem here due to us showing both patterns linked by a common parent. </span><span class="koboSpan" id="kobo.595.5">Our solution for this is a second </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">Fire</span></strong><span class="koboSpan" id="kobo.597.1"> function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">SandboxFire</span></strong><span class="koboSpan" id="kobo.599.1">. </span><span class="koboSpan" id="kobo.599.2">We will pass the execution off to this function within </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">Fire</span></strong><span class="koboSpan" id="kobo.601.1"> so that everything behaves as normal. </span><span class="koboSpan" id="kobo.601.2">No sensible project architecture would implement both patterns side by side like this, so it should not be an issue in your </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">future projects.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">The other</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.604.1"> thing we must define are the building block functions, which we have chosen to keep similar to the previous example, but for which you can make as many as you deem necessary. </span><span class="koboSpan" id="kobo.604.2">The key is to keep each function short and to the point as their purpose is to standardize the method for interacting with external systems so that future changes are easily maintained. </span><span class="koboSpan" id="kobo.604.3">The most important aspect of the functions laid out in the following code are that they are protected and marked as </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">BlueprintCallable</span></strong><span class="koboSpan" id="kobo.606.1">. </span><span class="koboSpan" id="kobo.606.2">This means they are just for children of this class to use, not override, and also ensures they have no </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">external access.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">Lets start with the base class for the </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">sandbox weapon:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.610.1">SandboxWeapon_Base.h excerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.611.1">
UCLASS(Abstract)
class RTS_AI_API ASandboxWeapon_Base : public AWeapon_Base
{
    GENERATED_BODY()
public:
    virtual void Fire() override;
    UFUNCTION(BlueprintImplementableEvent)
    void SandboxFire();
    UFUNCTION(BlueprintCallable)
    void Reload();
protected:
    UFUNCTION(BlueprintCallable)
    bool CheckAmmo();
    UFUNCTION(BlueprintCallable)
    void LinetraceOneShot(FVector direction);
    UFUNCTION(BlueprintCallable)
    void PlaySound(USoundBase* sound);
    UFUNCTION(BlueprintCallable)
    void UpdateAmmo();
};</span></pre> <p><span class="koboSpan" id="kobo.612.1">With the header declared, we can turn to the definitions in the following implementation.  </span><span class="koboSpan" id="kobo.612.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">Fire</span></strong><span class="koboSpan" id="kobo.614.1"> function override simply calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">SandboxFire()</span></strong><span class="koboSpan" id="kobo.616.1"> to pass the signal through to a function with the correct properties. </span><span class="koboSpan" id="kobo.616.2">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">SandboxFire</span></strong><span class="koboSpan" id="kobo.618.1"> is marked as </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">BlueprintImplementableEvent</span></strong><span class="koboSpan" id="kobo.620.1"> it doesn’t have a definition in this class and instead can be completely left to the Blueprint children to define. </span><span class="koboSpan" id="kobo.620.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">Reload</span></strong><span class="koboSpan" id="kobo.622.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">CheckAmmo</span></strong><span class="koboSpan" id="kobo.624.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">UpdateAmmo</span></strong><span class="koboSpan" id="kobo.626.1"> functions are basically the same as before, but this is dependent on the systems that are being hooked into and where it is best to build lots of small specific functions. </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">PlaySound</span></strong><span class="koboSpan" id="kobo.628.1"> is a more specific version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">PlayEffects</span></strong><span class="koboSpan" id="kobo.630.1"> from before, where we were able to leave the implementation to the designer, but now we must be specific</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.631.1"> in function name </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">and use:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.633.1">SandboxWeapon_Base.cpp simple function definitions</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.634.1">
void ASandboxWeapon_Base::Fire()
{
    SandboxFire();
}
void ASandboxWeapon_Base::Reload()
{
    _CurrentAmmo = _MaxAmmo; Handle_FireDelay();
}
bool ASandboxWeapon_Base::CheckAmmo()
{
    return _AmmoPerFire &lt;= _CurrentAmmo;
}
void ASandboxWeapon_Base::PlaySound(USoundBase* sound)
{
    UGameplayStatics::PlaySoundAtLocation(this, sound,
        GetActorLocation());
}
void ASandboxWeapon_Base::UpdateAmmo()
{
    _CurrentAmmo -= _AmmoPerFire;
}</span></pre> <p><span class="koboSpan" id="kobo.635.1">On the topic of </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.636.1">being specific, we now have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">LinetraceOneShot</span></strong><span class="koboSpan" id="kobo.638.1"> function in place of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">ProcessFiring</span></strong><span class="koboSpan" id="kobo.640.1"> function from before. </span><span class="koboSpan" id="kobo.640.2">While the utility of this, specifying that it is one shot, will become apparent later, this function is one of many ways to handle the gameplay logic of the gun firing. </span><span class="koboSpan" id="kobo.640.3">It acts as a wrapper for the line trace function working off a direction vector the user must pass in. </span><span class="koboSpan" id="kobo.640.4">This then applies damage to whatever it has hit through the standard </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">Unreal method:</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">We can now add that to the </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">sandbox weapon:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.644.1">SandboxWeapon_Base.cpp LinetraceOneShot function definition</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.645.1">
void ASandboxWeapon_Base::LinetraceOneShot(FVector direction)
{
    FHitResult hit(ForceInit);
    FVector start = _FirePoint-&gt;GetComponentLocation();
    FVector end = start + (direction * _Range);
    if(!UKismetSystemLibrary::LineTraceSingle(GetWorld(),
        start, end,
        UEngineTypes::ConvertToTraceType(ECC_Visibility),
        false,
        {this, GetOwner()},
        EDrawDebugTrace::ForDuration,
        hit,
        true,
        FLinearColor::Red, FLinearColor::Green, 5))
            return;
    UGameplayStatics::ApplyDamage(hit.GetActor(),
        _DamagePerHit, GetInstigatorController(),
            GetOwner(), UDamageType::StaticClass());
}</span></pre> <p><span class="koboSpan" id="kobo.646.1">Now that our sandbox base is kitted out with a basic suite of tools; we can make the Blueprint child weapons equivalent to the template pattern by using the Sandbox_Fire function. </span><span class="koboSpan" id="kobo.646.2">Comparing the Blueprint implementations of each pattern should show a lot of the differences in approach and how each can be used for the same system with differing approaches. </span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.647.1">Creating child classes</span></h2>
<p><span class="koboSpan" id="kobo.648.1">Just like with the </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.649.1">template pattern, we are going to create two child classes of the Sandbox Weapon Base in a Blueprint. </span><span class="koboSpan" id="kobo.649.2">To do this, we follow the same steps except when searching in the </span><strong class="bold"><span class="koboSpan" id="kobo.650.1">ALL CLASSES</span></strong><span class="koboSpan" id="kobo.651.1"> list, we now type </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">sandbox</span></strong><span class="koboSpan" id="kobo.653.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.654.1">SandboxWeapon_Base</span></strong><span class="koboSpan" id="kobo.655.1">. </span><span class="koboSpan" id="kobo.655.2">Name the two child classes </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">BP_SandboxPistol</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.657.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">BP_SandboxShotgun</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.660.1">With those created we can move on to setting them up. </span><span class="koboSpan" id="kobo.660.2">Unlike with the template pattern, we don’t need to create the functional behaviors. </span><span class="koboSpan" id="kobo.660.3">Instead, we determine the order (and reuse) of the functions in </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">the parent.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.662.1">Sandbox pistol</span></h2>
<p><span class="koboSpan" id="kobo.663.1">Once again, we </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.664.1">begin with the pistol as this is probably the simplest weapon type to implement. </span><span class="koboSpan" id="kobo.664.2">First, we do all of our checks to make sure the weapon can fire, </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.666.1">Override </span><strong class="bold"><span class="koboSpan" id="kobo.667.1">Sandbox Fire Function </span></strong><span class="koboSpan" id="kobo.668.1">using the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.669.1">Override </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">list.</span></span></li>
<li><span class="koboSpan" id="kobo.671.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">Branch</span></strong><span class="koboSpan" id="kobo.673.1"> based on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">CanFire</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.675.1"> Boolean.</span></span></li>
<li><span class="koboSpan" id="kobo.676.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.677.1">True </span></strong><span class="koboSpan" id="kobo.678.1">pin, call </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">Check Ammo</span></strong><span class="koboSpan" id="kobo.680.1"> and add a second </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">Branch</span></strong><span class="koboSpan" id="kobo.682.1"> based on the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.683.1">Return Value</span></strong></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer163">
<span class="koboSpan" id="kobo.684.1"><img alt="Figure 9.9: The start of the Sandbox Fire Event" src="image/Figure_09.09_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.685.1">Figure 9.9: The start of the Sandbox Fire Event</span></p>
<p><span class="koboSpan" id="kobo.686.1">Next, we’ll add the logic to the </span><strong class="bold"><span class="koboSpan" id="kobo.687.1">False</span></strong><span class="koboSpan" id="kobo.688.1"> output from the </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">Branch</span></strong><span class="koboSpan" id="kobo.690.1"> node, calling </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">Reload</span></strong><span class="koboSpan" id="kobo.692.1"> and playing a sound (sounds haven’t been implemented in the parent class as that is something that will typically be different </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">per weapon):</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.694.1">Call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">Reload</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.696.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.697.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">Play Sound</span></strong><span class="koboSpan" id="kobo.699.1"> node, selecting</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.700.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.701.1">Gizmo_Handle_Clicked</span></strong><span class="koboSpan" id="kobo.702.1"> sound from </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">the dropdown.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer164">
<span class="koboSpan" id="kobo.704.1"><img alt="Figure 9.10: The false logic for the Sandbox Fire Event" src="image/Figure_09.10_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.705.1">Figure 9.10: The false logic for the Sandbox Fire Event</span></p>
<p><span class="koboSpan" id="kobo.706.1">Lastly, we can add the True logic, which essentially fires the weapon. </span><span class="koboSpan" id="kobo.706.2">As the functional behavior already exists in the parent, we simply need to call the functions and provide the required inputs. </span><span class="koboSpan" id="kobo.706.3">We’re going to do this in two chunks. </span><span class="koboSpan" id="kobo.706.4">The first will play a sound before performing the line trace and updating the ammo. </span><span class="koboSpan" id="kobo.706.5">The second chunk will use a timer to call the function to manage the rate </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">of fire:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.708.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">Play Sound</span></strong><span class="koboSpan" id="kobo.710.1"> node, selecting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">VR_Teleport</span></strong><span class="koboSpan" id="kobo.712.1"> sound </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">once again.</span></span></li>
<li><span class="koboSpan" id="kobo.714.1">Call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">Linetrace One Shot</span></strong><span class="koboSpan" id="kobo.716.1"> function, providing it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">Forward Vector</span></strong><span class="koboSpan" id="kobo.718.1"> of the </span><strong class="bold"><span class="koboSpan" id="kobo.719.1">Fire </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.720.1">Point</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.721.1"> component.</span></span></li>
<li><span class="koboSpan" id="kobo.722.1">Call </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">Update Ammo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer165">
<span class="koboSpan" id="kobo.725.1"><img alt="Figure 9.11: The start of the true logic that fires the sandbox pistol" src="image/Figure_09.11_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.726.1">Figure 9.11: The start of the true logic that fires the sandbox pistol</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.727.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">Set Timer by Function </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">Name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.730.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.731.1">Type </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">Handle_FireDelay</span></strong><span class="koboSpan" id="kobo.733.1"> in for </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.734.1">Function Name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.736.1">Divide </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">1</span></strong><span class="koboSpan" id="kobo.738.1"> by the </span><strong class="bold"><span class="koboSpan" id="kobo.739.1">RoF</span></strong><span class="koboSpan" id="kobo.740.1"> float variable and connect it to the </span><strong class="bold"><span class="koboSpan" id="kobo.741.1">Time</span></strong><span class="koboSpan" id="kobo.742.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.743.1">Set Timer by Function </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.744.1">Name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.745.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.746.1">Promote the </span><strong class="bold"><span class="koboSpan" id="kobo.747.1">Return Value</span></strong><span class="koboSpan" id="kobo.748.1"> to a </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.749.1">variable and call </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">TimerFireDelay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer166">
<span class="koboSpan" id="kobo.753.1"><img alt="Figure 9.12: The Hand_FireDelay timer added to the end of the chain" src="image/Figure_09.12_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.754.1">Figure 9.12: The Hand_FireDelay timer added to the end of the chain</span></p>
<p><span class="koboSpan" id="kobo.755.1">With the pistol complete, test it the same as we did with the two template weapons and then we can move on to implementing the shotgun using the </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">Sandbox pattern.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.757.1">Sandbox shotgun</span></h2>
<p><span class="koboSpan" id="kobo.758.1">The shotgun follows much </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.759.1">of the same setup as the pistol except for where we once again need to complete multiple line traces. </span><span class="koboSpan" id="kobo.759.2">The parent has a single line trace that requires a forward vector input. </span><span class="koboSpan" id="kobo.759.3">So, just like in the template example, we will use a </span><strong class="bold"><span class="koboSpan" id="kobo.760.1">For Loop</span></strong><span class="koboSpan" id="kobo.761.1"> and once again utilize the </span><strong class="bold"><span class="koboSpan" id="kobo.762.1">Random Unit Vector in Cone in Degrees</span></strong><span class="koboSpan" id="kobo.763.1"> node when providing the forward vector input to the </span><strong class="bold"><span class="koboSpan" id="kobo.764.1">Linetrace One </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.765.1">Shot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.766.1"> function:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.767.1">Start by copying the logic from the pistol. </span><span class="koboSpan" id="kobo.767.2">This just saves us a little bit </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">of time.</span></span></li>
<li><span class="koboSpan" id="kobo.769.1">Disconnect both sides of the </span><strong class="bold"><span class="koboSpan" id="kobo.770.1">Linetrace One Shot </span></strong><span class="koboSpan" id="kobo.771.1">node by holding down </span><em class="italic"><span class="koboSpan" id="kobo.772.1">Alt</span></em><span class="koboSpan" id="kobo.773.1"> and clicking on </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">the pins.</span></span></li>
<li><span class="koboSpan" id="kobo.775.1">Add in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">For Each</span></strong><span class="koboSpan" id="kobo.777.1"> loop just as we did in the template shotgun, connecting it after the </span><strong class="bold"><span class="koboSpan" id="kobo.778.1">Play Sound</span></strong><span class="koboSpan" id="kobo.779.1"> node in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">True</span></strong><span class="koboSpan" id="kobo.781.1"> logic and once again using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">Number of Pellets</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.783.1">integer variable.</span></span></li>
<li><span class="koboSpan" id="kobo.784.1">For the </span><strong class="bold"><span class="koboSpan" id="kobo.785.1">Direction</span></strong><span class="koboSpan" id="kobo.786.1"> vector input on the </span><strong class="bold"><span class="koboSpan" id="kobo.787.1">Linetrace One Shot</span></strong><span class="koboSpan" id="kobo.788.1"> node, set up </span><strong class="bold"><span class="koboSpan" id="kobo.789.1">Random Unit Vector in Cone in Degrees</span></strong><span class="koboSpan" id="kobo.790.1"> in the same way we did for the template shotgun, as</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.791.1"> shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.792.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.793.1">.13</span></em></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer167">
<span class="koboSpan" id="kobo.794.1"><img alt="Figure 9.13: The For Loop’s Loop Body logic for ﻿the BP_SandboxShotgun" src="image/Figure_09.13_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.795.1">Figure 9.13: The For Loop’s Loop Body logic for the BP_SandboxShotgun</span></p>
<p><span class="koboSpan" id="kobo.796.1">Now we have the multiple line traces happening, we need to add back in the rest of the firing chain, that is, the Update Ammo function and Fire Delay Timer. </span><span class="koboSpan" id="kobo.796.2">Since these steps need to be done after we fire, they need to be connected to the </span><strong class="bold"><span class="koboSpan" id="kobo.797.1">Completed</span></strong><span class="koboSpan" id="kobo.798.1"> pin on the </span><strong class="bold"><span class="koboSpan" id="kobo.799.1">For Loop</span></strong><span class="koboSpan" id="kobo.800.1"> node, not part of the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.801.1">Loop Body.</span></strong></span></p>
<p><span class="koboSpan" id="kobo.802.1">Move the nodes from the previous steps around to make a clear path for the connection from the </span><strong class="bold"><span class="koboSpan" id="kobo.803.1">Completed</span></strong><span class="koboSpan" id="kobo.804.1"> pin and connect the other nodes back in, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.805.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.806.1">.14</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer168">
<span class="koboSpan" id="kobo.808.1"><img alt="Figure 9.14: The Update Ammo and Timer connected to the Completed pin" src="image/Figure_09.14_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.809.1">Figure 9.14: The Update Ammo and Timer connected to the Completed pin</span></p>
<p><span class="koboSpan" id="kobo.810.1">As before, test this out by selecting the weapon on the Elite Unit in </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">the level.</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">Provided everything works as it should, we can then move on to exploring the type object pattern, which allows us to easily expand the content available in </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">a game.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.814.1">Type object pattern</span></h1>
<p><span class="koboSpan" id="kobo.815.1">If you need a fast way of</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.816.1"> creating many variants of something in your game as a form of expanding the content available to players, then the type object pattern is for you. </span><span class="koboSpan" id="kobo.816.2">Type object takes the ideas of implicit and explicit data we covered as part of the flyweight pattern back in </span><a href="B18297_03.xhtml#_idTextAnchor046"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.817.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.818.1"> and expands it into the world of gameplay. </span><span class="koboSpan" id="kobo.818.2">The principle is the same: we separate out all data that is common across all instances of a type, but instead of just linking to it from everywhere, we mix it up and produce lots of variations of this data. </span><span class="koboSpan" id="kobo.818.3">The result is a connected web of objects that all have the same functionality but vary in which set of implicit data </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">they use.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer169">
<span class="koboSpan" id="kobo.820.1"><img alt="Figure 9.15: Diagram from Chapter 3 where we discussed the ﻿Flyweight pattern" src="image/Figure_09.15_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.821.1">Figure 9.15: Diagram from </span><a href="B18297_03.xhtml#_idTextAnchor046"><em class="italic"><span class="koboSpan" id="kobo.822.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.823.1"> where we discussed the Flyweight pattern</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.824.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.825.1">.15</span></em><span class="koboSpan" id="kobo.826.1"> shows the Flyweight pattern saving space by storing implicit data about the idea of a tree in one place </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">in memory.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer170">
<span class="koboSpan" id="kobo.828.1"><img alt="Figure 9.16: Diagram showing the expansion of the ﻿Flyweight pattern provided by the ﻿﻿type ﻿﻿object pattern" src="image/Figure_09.16_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.829.1">Figure 9.16: Diagram showing the expansion of the Flyweight pattern provided by the type object pattern</span></p>
<p><span class="koboSpan" id="kobo.830.1">Expanding the </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.831.1">pattern from Flyweight to type object in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.832.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.833.1">.16</span></em><span class="koboSpan" id="kobo.834.1">, we define more types as different sets of the implicit data. </span><span class="koboSpan" id="kobo.834.2">This diagram makes it clear the cost of this added expandability will be memory. </span><span class="koboSpan" id="kobo.834.3">Now only objects sharing a type can be batched together, so the number of batch calls increases but we are still way beyond defining every </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">tree explicitly.</span></span></p>
<p><span class="koboSpan" id="kobo.836.1">This is not the only way of achieving this outcome though. </span><span class="koboSpan" id="kobo.836.2">We could keep our Flyweight pattern and make a new class for each of our types. </span><span class="koboSpan" id="kobo.836.3">That would work, so why don’t we do that? </span><span class="koboSpan" id="kobo.836.4">Because code takes up space. </span><span class="koboSpan" id="kobo.836.5">In the next chapter, we’ll cover the idea of data locality, it builds on the knowledge that instructions in code, such as values we manipulate, take up space in memory. </span><span class="koboSpan" id="kobo.836.6">Duplicating a class also duplicates the code that needs to be stored to run, not to mention the overhead cost of defining and storing a new class. </span><span class="koboSpan" id="kobo.836.7">Our aim is to make an elegant solution that streamlines the content creation process and </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">increases efficiency.</span></span></p>
<p><span class="koboSpan" id="kobo.838.1">To make the type object pattern work in Unreal, we need to store a collection of data as an asset that can be loaded into the RAM at runtime for referencing. </span><span class="koboSpan" id="kobo.838.2">This could be achieved with writing text files or some other structured file format like JSON or XML. </span><span class="koboSpan" id="kobo.838.3">The problem there is that designers need to have the data files open in a separate text editor to make changes, and the process of saving and reloading the editor preview can become tedious when many small changes are made iteratively. </span><span class="koboSpan" id="kobo.838.4">Thankfully, Unreal Engine gives us a few options of built-in structures we can use. </span><span class="koboSpan" id="kobo.838.5">We will be looking at Variants and the Variant Manager, Data Assets, and Data Tables. </span><span class="koboSpan" id="kobo.838.6">There are undoubtedly more</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.839.1"> ways to make this work but these three should cover most of the general implementations of the type </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">object pattern.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.841.1">Variants</span></h2>
<p><span class="koboSpan" id="kobo.842.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.843.1">Variant Manager</span></strong><span class="koboSpan" id="kobo.844.1"> is a </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.845.1">tool within Unreal Engine that allows us to create multiple swapable Variants of actors in a level. </span><span class="koboSpan" id="kobo.845.2">The Variants store values for Actor properties and can also call functions from within the actor when the Variant </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">is selected.</span></span></p>
<p><span class="koboSpan" id="kobo.847.1">The Variants</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.848.1"> are held within </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.849.1">the level by a </span><strong class="bold"><span class="koboSpan" id="kobo.850.1">Level Variant Sets Actor</span></strong><span class="koboSpan" id="kobo.851.1">, which links to a </span><strong class="bold"><span class="koboSpan" id="kobo.852.1">Level Variant Sets</span></strong><span class="koboSpan" id="kobo.853.1"> asset where the various actors, their properties to change, and the functions within them to call, are </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">all stored.</span></span></p>
<p><span class="koboSpan" id="kobo.855.1">Variants are activated either via the </span><strong class="bold"><span class="koboSpan" id="kobo.856.1">Variant Manager Panel</span></strong><span class="koboSpan" id="kobo.857.1"> while in the editor (as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.858.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.859.1">.17</span></em><span class="koboSpan" id="kobo.860.1">) or via Blueprint functions </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">at runtime.</span></span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer171">
<span class="koboSpan" id="kobo.862.1"><img alt="Figure 9.17 The Variant Manager panel" src="image/Figure_09.17_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.863.1">Figure 9.17 The Variant Manager panel</span></p>
<p><span class="koboSpan" id="kobo.864.1">Variants and the Variant Manager </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.865.1">are more commonly used in interactive experiences such as architectural visualization projects or product-based applications such as </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">car configurators.</span></span></p>
<p><span class="koboSpan" id="kobo.867.1">The Variant Manager approach could be used for a character creation screen like those seen in RPG-type games such as World of Warcraft or Cyberpunk 2077, or the modular character/vehicle </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.868.1">setup systems in </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.869.1">games such as Fortnite, Fall Guys, or Rocket League, where the player can select different parts to be added to </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">their character.</span></span></p>
<p><span class="koboSpan" id="kobo.871.1">The drawback with the Variant Manager approach for ever-expanding games such as Fortnite or Fall Guys is the time required to create variants and fully set them up. </span><span class="koboSpan" id="kobo.871.2">An in-game character customization system would be much more suited to using a data table approach, where additional data can quickly be added in a table editor or imported from a spreadsheet. </span><span class="koboSpan" id="kobo.871.3">Let’s take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">this next.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.873.1">Data Tables</span></h2>
<p><span class="koboSpan" id="kobo.874.1">Data Tables</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.875.1"> are an asset type created for the purpose of storing values with no functionality. </span><span class="koboSpan" id="kobo.875.2">We define them in our project with a struct, each member becoming a column in the table. </span><span class="koboSpan" id="kobo.875.3">Each row of the table then represents a set of values we call a type to fit in with our pattern. </span><span class="koboSpan" id="kobo.875.4">Data Tables</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.876.1"> are designed for large-scale storage of data in one place to be queried when necessary. </span><span class="koboSpan" id="kobo.876.2">They can store values pointing to other assets, but these are cumbersome to work with in this form and are generally avoided in favor of storing everything as primitive types. </span><span class="koboSpan" id="kobo.876.3">This soft limit of primitive data means that, although possible, working with nested information is advised against. </span><span class="koboSpan" id="kobo.876.4">This could affect systems where one customization affects what is available in a </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">level below.</span></span></p>
<p><span class="koboSpan" id="kobo.878.1">The main benefit of this asset is its ability to import directly from a CSV or JSON file, making it the preferred method of balancing for designers with external tools. </span><span class="koboSpan" id="kobo.878.2">The flipside of this is because everything is stored together, even if you aren’t using all the types in a given scene, all the data will still be loaded into memory, making it less viable for high-level types and more applicable to utility-type patterns such as quest systems that are universal and always need to be loaded. </span><span class="koboSpan" id="kobo.878.3">There is also an argument for using Data Tables for language localization, as with all the types in one place, searches for specific records become way easier </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">and faster.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer172">
<span class="koboSpan" id="kobo.880.1"><img alt="Figure 9.18: Screenshot of an example Data Table with weapon balancing data" src="image/Figure_09.18_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.881.1">Figure 9.18: Screenshot of an example Data Table with weapon balancing data</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.882.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.883.1">.18</span></em><span class="koboSpan" id="kobo.884.1"> shows a Data Table in use for balancing the different enemy types in a game where the only changes are stat values as the enemy rank increases. </span><span class="koboSpan" id="kobo.884.2">This could have been imported from an external balancing tool as all the values are </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">primitive types.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.886.1">Data Assets</span></h2>
<p><span class="koboSpan" id="kobo.887.1">A </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.888.1">Data Asset takes the idea of </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.889.1">Data Tables and breaks it down into individual rows. </span><span class="koboSpan" id="kobo.889.2">Each row then becomes its own asset that can be created and managed via the editor. </span><span class="koboSpan" id="kobo.889.3">When we define a Data Asset it looks very much like a struct definition but on instancing it, we do not get a new item in the world. </span><span class="koboSpan" id="kobo.889.4">Instead, we get a new Data Asset instance in the project, similar to the way materials and material instances work. </span><span class="koboSpan" id="kobo.889.5">Once a Data Asset instance is referenced in active code, that instance is loaded into memory, just like a texture or static mech asset. </span><span class="koboSpan" id="kobo.889.6">Due to the editor being responsible for the creation and management of Data Assets, they have easy tools for holding references to other assets. </span><span class="koboSpan" id="kobo.889.7">This makes them useful for defining type data for high-level class specialization. </span><span class="koboSpan" id="kobo.889.8">They also deal with nested information well, as if it has been serialized properly, the editor has space to show the drop-down menus where sub-values can </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">be manipulated.</span></span></p>
<p><span class="koboSpan" id="kobo.891.1">The best way to explain how to use Data Assets for a type object pattern is to make something with them. </span><span class="koboSpan" id="kobo.891.2">So, let’s turn our attention back to the project we have been working on through this </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.892.1">chapter to implement some </span><a id="_idIndexMarker420"/><span class="No-Break"><span class="koboSpan" id="kobo.893.1">Data Assets:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.894.1">Start by defining a new type of Data Asset by right-clicking in the C++ folder. </span><span class="koboSpan" id="kobo.894.2">Make sure to do this from the editor as there are no templates available within Rider, meaning you’ll have to make a lot of </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">unnecessary changes.</span></span></li>
<li><span class="koboSpan" id="kobo.896.1">When selecting the base class to inherit from, choose </span><strong class="bold"><span class="koboSpan" id="kobo.897.1">UDataAsset</span></strong><span class="koboSpan" id="kobo.898.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.899.1">All </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.900.1">Classes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.901.1"> menu.</span></span></li>
<li><span class="koboSpan" id="kobo.902.1">Then give it a name. </span><span class="koboSpan" id="kobo.902.2">We have called </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">ours </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">EnemyType</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer173">
<span class="koboSpan" id="kobo.906.1"><img alt="Figure 9.19: Class creation menu setup to make a new Data Asset" src="image/Figure_09.19_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.907.1">Figure 9.19: Class creation menu setup to make a new Data Asset</span></p>
<p><span class="koboSpan" id="kobo.908.1">Next, we consider what data we need to store inside the asset. </span><span class="koboSpan" id="kobo.908.2">There could be any number of things we want to vary between different enemy types. </span><span class="koboSpan" id="kobo.908.3">The key is to make sure you only store data specifically about the enemy here, and not the other classes that could be different within the enemy class, such as the weapon fire rate. </span><span class="koboSpan" id="kobo.908.4">Weapons would need another parallel implementation of the type object pattern, which could even be nested within this one with the weapon type defined within the </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">enemy type:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.910.1">Give the class the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">BlueprintType</span></strong><span class="koboSpan" id="kobo.912.1"> property in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">UCLASS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.914.1"> block.</span></span></li>
<li><span class="koboSpan" id="kobo.915.1">We are only changing the health and materials on the enemy with its type, so add a float for health and a couple of object pointers to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">UmaterialInstance</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.917.1"> variables.</span></span></li>
<li><span class="koboSpan" id="kobo.918.1">Make sure each</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.919.1"> variable </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.920.1">has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">EditAnywhere</span></strong><span class="koboSpan" id="kobo.922.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">BlueprintReadWrite</span></strong><span class="koboSpan" id="kobo.924.1"> property specifiers, and we are all done with the </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">C++ side:</span></span></li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.926.1">EnemyType.h exerpt</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.927.1">
UCLASS(BlueprintType)
class RTS_AI_API UEnemyType : public UDataAsset
{
    GENERATED_BODY()
public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float _Health;
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TObjectPtr&lt;UMaterialInstance&gt; _Material1;
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TObjectPtr&lt;UMaterialInstance&gt; _Material2;
};</span></pre> <p><span class="koboSpan" id="kobo.928.1">The next step is to </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.929.1">define some</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.930.1"> Data Assets from the template we have </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">just created:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.932.1">Build back into the editor and right-click on the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.933.1">RTS/Data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.934.1"> folder.</span></span></li>
<li><span class="koboSpan" id="kobo.935.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.936.1">Miscellaneous</span></strong><span class="koboSpan" id="kobo.937.1"> &gt; </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.938.1">Data Asset</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer174">
<span class="koboSpan" id="kobo.940.1"><img alt="Figure 9.20: The Data Asset option is in the right-click menu" src="image/Figure_09.20_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.941.1">Figure 9.20: The Data Asset option is in the right-click menu</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.942.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.943.1">EnemyType</span></strong><span class="koboSpan" id="kobo.944.1"> from the list of classes to be </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">the parent.</span></span></li>
<li><span class="koboSpan" id="kobo.946.1">Give the new asset a name that represents the type we are making (we have gone with </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">Enemy_Basic</span></strong><span class="koboSpan" id="kobo.948.1">) and then open </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">it up.</span></span></li>
<li><span class="koboSpan" id="kobo.950.1">Set the health value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">100</span></strong><span class="koboSpan" id="kobo.952.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.953.1">MI_EnemyUnit_01</span></strong><span class="koboSpan" id="kobo.954.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.955.1">MI_EnemyUnit_02</span></strong><span class="koboSpan" id="kobo.956.1"> for the </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">material slots.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.958.1">The last step is to apply these values to the unit </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">on spawn:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.960.1">Open </span><strong class="bold"><span class="koboSpan" id="kobo.961.1">BP_EnemyUnit</span></strong><span class="koboSpan" id="kobo.962.1">, found in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.963.1">RTS/Blueprints</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.964.1"> folder.</span></span></li>
<li><span class="koboSpan" id="kobo.965.1">Add a new variable of type </span><strong class="bold"><span class="koboSpan" id="kobo.966.1">EnemyType</span></strong><span class="koboSpan" id="kobo.967.1"> and make it editable by clicking the eye icon, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.968.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.969.1">.21</span></em><span class="koboSpan" id="kobo.970.1">. </span><span class="koboSpan" id="kobo.970.2">Then set its default value </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.972.1">Enemy_Basic</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer175">
<span class="koboSpan" id="kobo.974.1"><img alt="Figure 9.21: The BP_EnemyUnit variables" src="image/Figure_09.21_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.975.1">Figure 9.21: The BP_EnemyUnit variables</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.976.1">Add a </span><strong class="bold"><span class="koboSpan" id="kobo.977.1">BeginPlay</span></strong><span class="koboSpan" id="kobo.978.1"> event node to the </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">event graph.</span></span></li>
<li><span class="koboSpan" id="kobo.980.1">Check whether the new </span><strong class="bold"><span class="koboSpan" id="kobo.981.1">TypeData</span></strong><span class="koboSpan" id="kobo.982.1"> variable has </span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">a value.</span></span></li>
<li><span class="koboSpan" id="kobo.984.1">Then </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.985.1">place each value from the </span><strong class="bold"><span class="koboSpan" id="kobo.986.1">TypeData</span></strong><span class="koboSpan" id="kobo.987.1"> variable into its relevant place as </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.988.1">shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.989.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.990.1">.22</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer176">
<span class="koboSpan" id="kobo.992.1"><img alt="Figure 9.22 Screenshot showing BP_EnemyUnit event graph applying Type Data" src="image/Figure_09.22_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.993.1">Figure 9.22 Screenshot showing BP_EnemyUnit event graph applying Type Data</span></p>
<p><span class="koboSpan" id="kobo.994.1">Doing all this should make nothing appear or behave differently, but it does now give us the flexibility to define new types of enemy with different materials in the Content Browser. </span><span class="koboSpan" id="kobo.994.2">We can then set spawned enemies to be different types using the editable variable. </span><span class="koboSpan" id="kobo.994.3">As an extension to this, see if you can define a new enemy type with 200 health that uses the B versions of the material instances we used for the basic type. </span><span class="koboSpan" id="kobo.994.4">These can be found in the same folder as the materials we were using before but are tinted blue. </span><span class="koboSpan" id="kobo.994.5">Another extension you could try is to set the type variable to expose on spawn and dynamically spawn a few enemies in the level. </span><span class="koboSpan" id="kobo.994.6">This will allow you to set the type in the code, hopefully demonstrating the power of </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">this system.</span></span></p>
<p><span class="koboSpan" id="kobo.996.1">We’ve explored the ways in which the type object can be utilized in gameplay to facilitate large numbers of variants using three different approaches in Unreal Engine: Variants, Data Tables, and Data Assets. </span><span class="koboSpan" id="kobo.996.2">With the completion of our type object example, we have come to the end of our exploration of patterns that can be used to build </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">structured solutions.</span></span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.998.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.999.1">The three patterns we have covered in this chapter are the most widely used structural patterns. </span><span class="koboSpan" id="kobo.999.2">Use of the first two is a personal preference, as we saw they can both be used to achieve the same thing in different ways. </span><span class="koboSpan" id="kobo.999.3">Template and subclass sandbox are also being superseded by other techniques in modern code, such as interfaces and modular design, but understanding where they came from and the workflow they encourage is useful. </span><span class="koboSpan" id="kobo.999.4">Template and subclass Sandbox both highlight the need to constrain designers with limited access to ensure the maintainability of the codebase. </span><span class="koboSpan" id="kobo.999.5">The type object pattern, on the other hand, is one of the most useful patterns in game development with widespread application across all aspects of game design. </span><span class="koboSpan" id="kobo.999.6">Its utility in allowing artists, designers, and programmers to work together </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">is invaluable.</span></span></p>
<p><span class="koboSpan" id="kobo.1001.1">In the next chapter, we will dive into a few patterns that we can apply once we have a working game to improve our performance using the concepts of object pooling, data locality, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">dirty flags.</span></span></p>
</div>
</body></html>