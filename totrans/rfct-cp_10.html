<html><head></head><body>
<div id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-185"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.2.1">Introduction to Static Analysis in C++</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the complex and demanding world of software development, ensuring the quality and reliability of code is not just a necessity but a discipline in itself. </span><span class="koboSpan" id="kobo.3.2">As C++ developers, we constantly seek methodologies and tools that can aid us in this quest. </span><span class="koboSpan" id="kobo.3.3">This chapter is dedicated to one such powerful approach: static analysis. </span><span class="koboSpan" id="kobo.3.4">Renowned for being both the fastest and the cheapest way to identify bugs, static analysis stands as a pillar in the software quality assurance process. </span><span class="koboSpan" id="kobo.3.5">We will delve into its intricacies, explore popular tools such as Clang-Tidy, PVS-Studio, and SonarQube, and understand how to effectively integrate static analysis into your C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">development workflow.</span></span></p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.5.1">The essence of static analysis</span></h1>
<p><span class="koboSpan" id="kobo.6.1">Static analysis is the examination</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.7.1"> of source code without executing it. </span><span class="koboSpan" id="kobo.7.2">This process, typically automated by various tools, involves scanning the code to identify potential errors, code smells, security vulnerabilities, and other issues. </span><span class="koboSpan" id="kobo.7.3">It’s akin to a thorough proofreading session where the code is scrutinized for quality and reliability before it </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">ever runs.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Why static analysis? </span><span class="koboSpan" id="kobo.9.2">Here</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.10.1"> are </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">the reasons:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.12.1">Speed and cost-effectiveness</span></strong><span class="koboSpan" id="kobo.13.1">: The foremost advantage of static analysis is its speed and cost-effectiveness. </span><span class="koboSpan" id="kobo.13.2">It is arguably the fastest and cheapest method to find bugs. </span><span class="koboSpan" id="kobo.13.3">Automating the detection of issues drastically reduces the time and effort required compared to manual code reviews and other testing methods. </span><span class="koboSpan" id="kobo.13.4">Catching and resolving issues early in the development cycle significantly lowers the cost of fixes, which escalates if bugs are found later </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">in production.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.15.1">Pre-execution bug detection</span></strong><span class="koboSpan" id="kobo.16.1">: Static analysis occurs before the code is executed, making it a proactive measure in software quality assurance. </span><span class="koboSpan" id="kobo.16.2">This pre-execution analysis allows developers to identify and rectify issues without the overhead of setting up testing environments or dealing with the complexities of running </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">the code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.18.1">Coding standard enforcement</span></strong><span class="koboSpan" id="kobo.19.1">: It helps in maintaining a consistent coding standard, ensuring that the code base adheres to the best practices and conventions of C++ programming. </span><span class="koboSpan" id="kobo.19.2">This enforcement not only improves code quality but also enhances maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">and readability.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.21.1">Comprehensive coverage</span></strong><span class="koboSpan" id="kobo.22.1">: With the ability to scan the entire code base, static analysis provides a level of thoroughness that is challenging to achieve through manual methods. </span><span class="koboSpan" id="kobo.22.2">This comprehensive coverage ensures that no part of the code </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">is overlooked.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.24.1">Security and reliability</span></strong><span class="koboSpan" id="kobo.25.1">: Early detection of security vulnerabilities is another critical benefit. </span><span class="koboSpan" id="kobo.25.2">Static analysis contributes significantly to the security and reliability of the application by catching vulnerabilities that might otherwise go unnoticed </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">until exploitation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.27.1">Educational aspect</span></strong><span class="koboSpan" id="kobo.28.1">: It also serves an educational purpose, enhancing developers’ understanding of C++ and familiarizing</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.29.1"> them with common pitfalls and </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">best practices.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.31.1">In the subsequent sections, we’ll explore how to leverage static analysis to its fullest potential in C++ projects. </span><span class="koboSpan" id="kobo.31.2">Following this, in the next chapter, we will compare and contrast these insights with dynamic analysis, offering a complete picture of the analysis landscape in C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">software development.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.33.1">Leveraging newer compiler versions for enhanced static analysis</span></h2>
<p><span class="koboSpan" id="kobo.34.1">While the production environment</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.35.1"> often mandates specific, sometimes older, compiler versions for various reasons, including stability and compatibility, there is immense value in periodically building your project with newer versions of compilers. </span><span class="koboSpan" id="kobo.35.2">This practice serves as a forward-looking static analysis strategy, harnessing the advancements and improvements made in the latest </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">compiler releases.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Newer compiler versions are frequently equipped with enhanced analysis capabilities, more sophisticated warning mechanisms, and updated interpretations of the C++ standard. </span><span class="koboSpan" id="kobo.37.2">They can identify issues and potential code improvements that older compilers might overlook. </span><span class="koboSpan" id="kobo.37.3">By compiling with these cutting-edge tools, developers can proactively discover and address latent issues in their code base, ensuring that the code remains robust and compliant with evolving </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">C++ standards.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Additionally, this approach offers a preview of potential issues that might arise when an eventual update to the production compiler is undertaken. </span><span class="koboSpan" id="kobo.39.2">It provides an opportunity to future-proof the code base, making the transition to newer compiler versions smoother and </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">more predictable.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">In essence, incorporating newer compiler versions into the build process, even if they are not used for production builds, is a strategic measure. </span><span class="koboSpan" id="kobo.41.2">It not only elevates the quality of the code through advanced static analysis but also prepares the code base for future technological shifts, ensuring a state of continuous</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.42.1"> improvement and readiness </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">for advancement.</span></span></p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.44.1">Compiler settings to harden C++ code</span></h1>
<p><span class="koboSpan" id="kobo.45.1">In the pursuit of robust and secure C++ code, configuring compiler settings plays a pivotal role. </span><span class="koboSpan" id="kobo.45.2">Compiler flags and options can significantly enhance code quality by enabling stricter error checking, warnings, and security features. </span><span class="koboSpan" id="kobo.45.3">This section focuses on recommended settings for three major compilers in the C++ ecosystem: the </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">GNU Compiler Collection</span></strong><span class="koboSpan" id="kobo.47.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.48.1">GCC</span></strong><span class="koboSpan" id="kobo.49.1">), Clang, and </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">Microsoft Visual C++</span></strong><span class="koboSpan" id="kobo.51.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.52.1">MSVC</span></strong><span class="koboSpan" id="kobo.53.1">). </span><span class="koboSpan" id="kobo.53.2">These settings are particularly valuable in a static analysis context as they enable the detection of potential issues at </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">compile time.</span></span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.55.1">GCC</span></h2>
<p><span class="koboSpan" id="kobo.56.1">GCC is known for its extensive set of options</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.57.1"> that can help</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.58.1"> harden C++ code. </span><span class="koboSpan" id="kobo.58.2">Key flags include </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">-Wall -Wextra</span></strong><span class="koboSpan" id="kobo.61.1">: Enables most warning messages, catching potential issues such as uninitialized variables, unused parameters, </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">and more</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">-Werror</span></strong><span class="koboSpan" id="kobo.64.1">: Treats all warnings as errors, forcing them to </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">be addressed</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">-Wshadow</span></strong><span class="koboSpan" id="kobo.67.1">: Warns whenever a local variable shadows another variable, which can lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">confusing bugs</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">-Wnon-virtual-dtor</span></strong><span class="koboSpan" id="kobo.70.1">: Warns if a class with virtual functions has a non-virtual destructor, which can lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">undefined behavior</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">-pedantic</span></strong><span class="koboSpan" id="kobo.73.1">: Enforces strict ISO C++ compliance, rejecting </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">non-standard code</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">-Wconversion</span></strong><span class="koboSpan" id="kobo.76.1">: Warns on implicit conversions that may alter a value, useful for preventing </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">data loss</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">-Wsign-conversion</span></strong><span class="koboSpan" id="kobo.79.1">: Warns on implicit conversions that change the sign of </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">a value</span></span></li>
</ul>
<h2 id="_idParaDest-191"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.81.1">Clang</span></h2>
<p><span class="koboSpan" id="kobo.82.1">Clang, part of the LLVM</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.83.1"> project, shares</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.84.1"> many flags with GCC but also provides additional checks and a reputation for generating more </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">human-readable warnings:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">-Weverything</span></strong><span class="koboSpan" id="kobo.87.1">: Enables every warning available in Clang, providing a comprehensive check of the code. </span><span class="koboSpan" id="kobo.87.2">This can be overwhelming, so it’s often used with selective disabling of less </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">critical warnings.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">-Werror</span></strong><span class="koboSpan" id="kobo.90.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">-Wall</span></strong><span class="koboSpan" id="kobo.92.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">-Wextra</span></strong><span class="koboSpan" id="kobo.94.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">-Wshadow</span></strong><span class="koboSpan" id="kobo.96.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">-Wnon-virtual-dtor</span></strong><span class="koboSpan" id="kobo.98.1">,              </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">-pedantic</span></strong><span class="koboSpan" id="kobo.100.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">-Wconversion</span></strong><span class="koboSpan" id="kobo.102.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">-Wsign-conversion</span></strong><span class="koboSpan" id="kobo.104.1">: Similar to GCC, these flags are also applicable in Clang and serve the </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">same purposes.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">-Wdocumentation</span></strong><span class="koboSpan" id="kobo.107.1">: Warns about documentation inconsistencies, which is useful when maintaining large code bases with </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">extensive comments.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">-fsanitize=address</span></strong><span class="koboSpan" id="kobo.110.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">-fsanitize=undefined</span></strong><span class="koboSpan" id="kobo.112.1">: Enables </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">AddressSanitizer</span></strong><span class="koboSpan" id="kobo.114.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">UndefinedBehaviorSanitizer</span></strong><span class="koboSpan" id="kobo.116.1"> to catch memory corruption and undefined </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">behavior issues.</span></span></li>
</ul>
<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.118.1">MSVC</span></h2>
<p><span class="koboSpan" id="kobo.119.1">MSVC, while having a different</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.120.1"> set of flags, also offers</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.121.1"> robust options for enhancing </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">code safety:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">/W4</span></strong><span class="koboSpan" id="kobo.124.1">: Enables a higher warning level, similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">-Wall</span></strong><span class="koboSpan" id="kobo.126.1"> in GCC/Clang. </span><span class="koboSpan" id="kobo.126.2">This includes most of the useful warnings for </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">common issues.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">/WX</span></strong><span class="koboSpan" id="kobo.129.1">: Treats all compiler warnings </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">as errors.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">/sdl</span></strong><span class="koboSpan" id="kobo.132.1">: Enables additional security checks, such as buffer overflow detection and integer </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">overflow checks.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">/GS</span></strong><span class="koboSpan" id="kobo.135.1">: Provides buffer security checks, helping prevent common </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">security vulnerabilities.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">/analyze</span></strong><span class="koboSpan" id="kobo.138.1">: Enables static code analysis to detect issues such as memory leaks, uninitialized variables, and other potential errors at </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">compile time.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.140.1">By utilizing these compiler settings, developers can significantly harden their C++ code, making it more secure, robust, and compliant with best practices. </span><span class="koboSpan" id="kobo.140.2">While the default settings of compilers catch many issues, enabling these additional flags ensures a much stricter and more thorough analysis of the code. </span><span class="koboSpan" id="kobo.140.3">It is important</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.141.1"> to note that while these settings</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.142.1"> can greatly enhance code quality, they should be complemented with good programming practices and regular code reviews for the best results. </span><span class="koboSpan" id="kobo.142.2">In the next chapter, we will shift our focus to dynamic analysis, another key component in ensuring the overall quality and security of </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">C++ applications.</span></span></p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.144.1">Static analysis via multiple compilers</span></h1>
<p><span class="koboSpan" id="kobo.145.1">In the realm of C++ development, leveraging</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.146.1"> the capabilities of compilers for static analysis is an often underutilized strategy. </span><span class="koboSpan" id="kobo.146.2">Compilers such as GCC and Clang come equipped with a plethora of compilation flags that enable rigorous static analysis, helping to identify potential issues without the need for additional tools. </span><span class="koboSpan" id="kobo.146.3">Employing these flags is not only convenient but also highly effective in enhancing </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">code quality.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">One best practice that I advocate for is building C++ projects with multiple compilers. </span><span class="koboSpan" id="kobo.148.2">Each compiler has its unique set of diagnostics, and by utilizing more than one, projects can gain a more comprehensive insight into potential issues. </span><span class="koboSpan" id="kobo.148.3">GCC and Clang are particularly notable for their similarity in supported flags, as well as their wide-ranging support for various architectures and operating systems. </span><span class="koboSpan" id="kobo.148.4">This compatibility makes it feasible to integrate both into a project’s build process for </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">cross-checking code.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">However, incorporating these practices in a Windows environment can present additional challenges. </span><span class="koboSpan" id="kobo.150.2">While GCC and Clang are versatile, projects often also benefit from the distinct diagnostics provided by MSVC. </span><span class="koboSpan" id="kobo.150.3">MSVC integrates seamlessly with the Windows ecosystem and brings to the table a different perspective on code analysis, which can be especially beneficial for projects targeting Windows platforms. </span><span class="koboSpan" id="kobo.150.4">Although managing multiple compilers might introduce some complexity, the payoff in identifying a broader spectrum of potential issues is invaluable. </span><span class="koboSpan" id="kobo.150.5">By embracing this multi-compiler approach, projects can significantly enhance their static analysis rigor, leading to more robust and reliable </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">C++ code.</span></span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.152.1">Highlighting compiler differences – unused private members in GCC versus Clang</span></h2>
<p><span class="koboSpan" id="kobo.153.1">A nuanced understanding</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.154.1"> of the diagnostic capabilities</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.155.1"> of different compilers can be crucial in C++ development. </span><span class="koboSpan" id="kobo.155.2">This is exemplified in the way GCC and Clang handle unused private member variables. </span><span class="koboSpan" id="kobo.155.3">Consider the following </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">class definition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.157.1">
#include &lt;iostream&gt;
class NumberWrapper {
    int number;
public:
    NumberWrapper() {
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.158.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">number</span></strong><span class="koboSpan" id="kobo.160.1"> private member in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">NumberWrapper</span></strong><span class="koboSpan" id="kobo.162.1"> class is initialized but never used. </span><span class="koboSpan" id="kobo.162.2">This situation presents a potential</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.163.1"> issue in the code that could </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">indicate redundancy.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">Let’s compare how GCC and Clang</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.166.1"> handle unused </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">private members:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.168.1">GCC’s diagnostic approach</span></strong><span class="koboSpan" id="kobo.169.1">: In version 13, GCC does not typically warn about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">number</span></strong><span class="koboSpan" id="kobo.171.1"> unused private member. </span><span class="koboSpan" id="kobo.171.2">This lack of warning might lead to unintentional neglect of inefficiencies or redundancies in the </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">class design.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.173.1">Clang’s diagnostic approach</span></strong><span class="koboSpan" id="kobo.174.1">: Conversely, Clang version 17 actively flags this issue with a specific warning: </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">warning: private field 'number' is not used</span></strong><span class="koboSpan" id="kobo.176.1">. </span><span class="koboSpan" id="kobo.176.2">This precise diagnostic helps in promptly identifying and addressing potential oversights in the </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">class’s implementation.</span></span></li>
</ul>
<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.178.1">Highlighting compiler differences – compiler checks for uninitialized variables</span></h2>
<p><span class="koboSpan" id="kobo.179.1">When dealing with class</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.180.1"> variables in C++, ensuring proper initialization is crucial to prevent undefined behavior. </span><span class="koboSpan" id="kobo.180.2">This aspect is highlighted in how different compilers detect uninitialized but used variables. </span><span class="koboSpan" id="kobo.180.3">Consider the example of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">NumberWrapper</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.182.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
#include &lt;iostream&gt;
class NumberWrapper {
    int number;
public:
    NumberWrapper(int n) {
        (void)n; // to avoid warning: unused parameter 'n'
        std::cout &lt;&lt; "init with: " &lt;&lt; number &lt;&lt; std::endl;
    }
};
int main() {
    auto num = NumberWrapper{1};
    (void) num;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.184.1">In this code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">number</span></strong><span class="koboSpan" id="kobo.186.1"> member variable</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.187.1"> is not initialized, leading to undefined behavior when it’s used in the constructor. </span><span class="koboSpan" id="kobo.187.2">It can print something such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">init </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">with: 32767</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">We’ll now compare the approaches</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.192.1"> used by GCC and Clang in </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">this regard:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.194.1">GCC’s diagnostic approach</span></strong><span class="koboSpan" id="kobo.195.1">: GCC version 13 effectively flags this critical issue with a warning: </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">warning: 'num.NumberWrapper::number' is used uninitialized</span></strong><span class="koboSpan" id="kobo.197.1">. </span><span class="koboSpan" id="kobo.197.2">This warning serves as an important alert to developers, drawing attention to the risk of using uninitialized variables, which can lead to unpredictable program behavior or </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">subtle bugs.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.199.1">Clang’s diagnostic approach</span></strong><span class="koboSpan" id="kobo.200.1">: Interestingly, Clang version 17 does not generate a warning for the same code, potentially allowing this oversight to go unnoticed in environments where only Clang is used. </span><span class="koboSpan" id="kobo.200.2">This demonstrates a case where relying solely on Clang might miss certain classes of errors that GCC </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">can catch.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.202.1">The two examples discussed previously offer compelling insights into the distinctive strengths and nuances of GCC and Clang’s diagnostic capabilities. </span><span class="koboSpan" id="kobo.202.2">These instances – one highlighting Clang’s ability to flag unused private fields and the other showcasing GCC’s proficiency in warning about uninitialized class variables – exemplify the importance of a multi-compiler strategy in </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">C++ development.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">By utilizing both Clang and GCC, developers can harness a more comprehensive and diversified static analysis process. </span><span class="koboSpan" id="kobo.204.2">Each compiler, with its unique set of warnings and checks, can reveal different potential issues or optimizations. </span><span class="koboSpan" id="kobo.204.3">Clang, known for its detailed and specific warnings, such as flagging unused private fields, complements GCC’s vigilant checks for fundamental yet critical issues such as uninitialized variables. </span><span class="koboSpan" id="kobo.204.4">This synergy between the compilers ensures a more thorough vetting of the code, leading to higher quality and more reliable and </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">maintainable software.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">In essence, the combination of Clang</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.207.1"> and GCC does</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.208.1"> not just add value in terms of the sum of their individual capabilities; it creates a more robust and holistic environment for static analysis. </span><span class="koboSpan" id="kobo.208.2">As the C++ language and its compilers continue to evolve, staying adaptable and open to multiple tools for static analysis remains a best practice for developers aiming for excellence in their craft. </span><span class="koboSpan" id="kobo.208.3">This approach aligns well with the ever-present goal in software development: writing clean, efficient, and </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">error-free code.</span></span></p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.210.1">Exploring static analysis with Clang-Tidy</span></h1>
<p><span class="koboSpan" id="kobo.211.1">As we delve deeper</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.212.1"> into the realm</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.213.1"> of static analysis, a tool that stands out for its versatility and depth is Clang-Tidy. </span><span class="koboSpan" id="kobo.213.2">Developed by the LLVM Foundation, the same organization behind the Clang compiler, Clang-Tidy is a linter and static analysis tool designed for C++ code. </span><span class="koboSpan" id="kobo.213.3">It extends beyond the capabilities of what a traditional compiler would check, offering a range of diagnostics that include stylistic errors, programming mistakes, and even subtle bugs that are often missed during regular code reviews. </span><span class="koboSpan" id="kobo.213.4">Previously, we explored how Clang-Tidy can be adept at code formatting; now, we will explore its prowess in static analysis, uncovering its ability to scrutinize C++ code at a level that ensures not just conformity but also excellence in </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">coding standards.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">Clang-Tidy works by using the Clang frontend to parse C++ code, enabling it to understand the code’s structure and syntax in depth. </span><span class="koboSpan" id="kobo.215.2">This deep understanding allows Clang-Tidy to perform complex checks that go beyond mere textual analysis, examining the code’s semantics and even the flow of execution. </span><span class="koboSpan" id="kobo.215.3">It’s not just about finding syntactic discrepancies; it’s about understanding the code’s behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">and intent.</span></span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.217.1">Categories of checks in Clang-Tidy</span></h2>
<p><span class="koboSpan" id="kobo.218.1">Clang-Tidy categorizes</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.219.1"> its checks into several groups, each targeting specific types of issues. </span><span class="koboSpan" id="kobo.219.2">Let’s break down these categories and explore examples </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">for each:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.221.1">Performance checks</span></strong><span class="koboSpan" id="kobo.222.1">: Focus on identifying inefficient</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.223.1"> patterns in the code that can slow down execution; for example, unnecessary copying of objects. </span><span class="koboSpan" id="kobo.223.2">Clang-Tidy can flag cases where an object is copied but could be moved or passed by reference to avoid the overhead </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">of copying:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.225.1">
#include &lt;vector&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.226.1">
std::vector&lt;int&gt; createLargeVector();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.227.1">
void processVector(std::vector&lt;int&gt; vec);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.228.1">
int main() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.229.1">
    std::vector&lt;int&gt; vec = createLargeVector();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.230.1">
    processVector(vec); // Clang-Tidy: Use std::move to avoid copying</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.231.1">
    return 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.232.1">
}</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.233.1">Modernize checks</span></strong><span class="koboSpan" id="kobo.234.1">: Aim to upgrade code to</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.235.1"> modern C++ standards, such</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.236.1"> as C++11 and beyond; for example, replacing traditional </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">for</span></strong><span class="koboSpan" id="kobo.238.1"> loops with range-based </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">for</span></strong><span class="koboSpan" id="kobo.240.1"> loops for better readability </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">and safety:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.242.1">
std::vector&lt;int&gt; myVec = {1, 2, 3};</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.243.1">
for (std::size_t i = 0; i &lt; myVec.size(); ++i) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.244.1">
    // Clang-Tidy: Use a range-based for loop instead</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.245.1">
    std::cout &lt;&lt; myVec[i] &lt;&lt; std::endl;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.246.1">
}</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.247.1">Bug detection</span></strong><span class="koboSpan" id="kobo.248.1">: Identify potential errors</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.249.1"> or logical bugs in the code; for example, detecting null </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">pointer dereferences:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.251.1">
int* ptr = nullptr;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.252.1">
int value = *ptr; // Clang-Tidy: Dereference of null pointer</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.253.1">Style checks</span></strong><span class="koboSpan" id="kobo.254.1">: Enforce specific coding styles</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.255.1"> for consistency and readability; for example, enforcing variable </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">naming conventions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.257.1">
int MyVariable = 42; // Clang-Tidy: Variable name should be lower_case</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.258.1">Readability checks</span></strong><span class="koboSpan" id="kobo.259.1">: Focus on making the code</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.260.1"> more understandable and maintainable; for example, simplifying complex </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">Boolean expressions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.262.1">
bool a, b, c;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.263.1">
if (a &amp;&amp; (b || c)) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.264.1">
    // Clang-Tidy: Simplify logical expression</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.265.1">
}</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.266.1">Security checks</span></strong><span class="koboSpan" id="kobo.267.1">: Target potential security vulnerabilities; for example, highlighting</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.268.1"> uses of dangerous functions known to pose</span><a id="_idIndexMarker511"/> <span class="No-Break"><span class="koboSpan" id="kobo.269.1">security risks:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.270.1">
strcpy(dest, src); // Clang-Tidy: Use of function 'strcpy' is insecure</span></pre></li>
</ul>
<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.271.1">Expanding Clang-Tidy’s capabilities with custom checks</span></h2>
<p><span class="koboSpan" id="kobo.272.1">Clang-Tidy’s versatility</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.273.1"> is further enhanced by its support for custom checks, allowing companies and projects to tailor static analysis to their specific needs and coding standards. </span><span class="koboSpan" id="kobo.273.2">This customization capability has led to the creation of various categories of checks, each aligning with the guidelines of different organizations or projects. </span><span class="koboSpan" id="kobo.273.3">Next, we explore some </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">notable examples:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.275.1">Google checks (google-*)</span></strong><span class="koboSpan" id="kobo.276.1">: These checks enforce the guidelines specified in Google’s C++ style guide. </span><span class="koboSpan" id="kobo.276.2">They include rules about naming conventions, runtime references, and build issues. </span><span class="koboSpan" id="kobo.276.3">For instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">google-runtime-references</span></strong><span class="koboSpan" id="kobo.278.1"> enforces Google’s preference for pointers over </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">non-const references.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.280.1">Google’s Abseil checks</span></strong><span class="koboSpan" id="kobo.281.1">: Abseil is an open source collection of C++ library code developed by Google. </span><span class="koboSpan" id="kobo.281.2">Checks specific to Abseil ensure adherence to the library’s best practices, such as avoiding certain deprecated functions </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">or classes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.283.1">Fuchsia checks</span></strong><span class="koboSpan" id="kobo.284.1">: Tailored for the Fuchsia operating system, these checks enforce coding standards and best practices specific to the Fuchsia project. </span><span class="koboSpan" id="kobo.284.2">They help maintain consistency and quality in the code base contributing to </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">this OS.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.286.1">Zircon checks</span></strong><span class="koboSpan" id="kobo.287.1">: Zircon is the core platform that powers the Fuchsia OS. </span><span class="koboSpan" id="kobo.287.2">Clang-Tidy includes checks tailored to Zircon’s development, focusing on its unique architecture and </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">development standards.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.289.1">Darwin checks</span></strong><span class="koboSpan" id="kobo.290.1">: These checks are specifically designed for Darwin, the open source Unix-like operating system released by Apple. </span><span class="koboSpan" id="kobo.290.2">They ensure compliance with Darwin’s </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">development practices.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.292.1">LLVM checks (llvm-*)</span></strong><span class="koboSpan" id="kobo.293.1">: These checks are designed to enforce LLVM coding standards. </span><span class="koboSpan" id="kobo.293.2">They are particularly useful for developers contributing to LLVM or </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">its subprojects.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.295.1">C++ Core Guidelines checks</span></strong><span class="koboSpan" id="kobo.296.1">: Clang-Tidy includes checks that enforce the C++ Core Guidelines, a set of best practices for writing modern C++. </span><span class="koboSpan" id="kobo.296.2">This includes rules for type safety, resource management, </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">and performance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.298.1">Type safety checks (cppcoreguidelines-*)</span></strong><span class="koboSpan" id="kobo.299.1">: These checks ensure type safety</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.300.1"> in various scenarios. </span><span class="koboSpan" id="kobo.300.2">For instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">cppcoreguidelines-pro-type-member-init</span></strong><span class="koboSpan" id="kobo.302.1"> ensures that class members are properly initialized. </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">cppcoreguidelines-pro-type-reinterpret-cast</span></strong><span class="koboSpan" id="kobo.304.1"> warns against the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.306.1">, encouraging safer </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">casting alternatives.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.308.1">Interface guidelines</span></strong><span class="koboSpan" id="kobo.309.1">: These checks enforce rules for designing clean and manageable interfaces. </span><span class="koboSpan" id="kobo.309.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">cppcoreguidelines-non-private-member-variables-in-classes</span></strong><span class="koboSpan" id="kobo.311.1"> discourages the use of non-private member variables to </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">maintain encapsulation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.313.1">Concurrency guidelines</span></strong><span class="koboSpan" id="kobo.314.1">: Checks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">cppcoreguidelines-avoid-magic-numbers</span></strong><span class="koboSpan" id="kobo.316.1"> help identify hardcoded numbers that may not have an obvious meaning, promoting readability </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">and maintainability.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.318.1">Performance enhancement checks</span></strong><span class="koboSpan" id="kobo.319.1">: These include checks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">cppcoreguidelines-avoid-c-arrays</span></strong><span class="koboSpan" id="kobo.321.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">cppcoreguidelines-avoid-non-const-global-variables</span></strong><span class="koboSpan" id="kobo.323.1">, which promote the use of modern C++ constructs such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">std::array</span></strong><span class="koboSpan" id="kobo.325.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">std::vector</span></strong><span class="koboSpan" id="kobo.327.1"> over C-style arrays and discourage the use of non-const </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">global variables.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.329.1">Bounds safety checks</span></strong><span class="koboSpan" id="kobo.330.1">: Ensuring bounds safety is crucial in C++, and checks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">cppcoreguidelines-pro-bounds-array-to-pointer-decay</span></strong><span class="koboSpan" id="kobo.332.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">cppcoreguidelines-pro-bounds-constant-array-index</span></strong><span class="koboSpan" id="kobo.334.1"> warn against</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.335.1"> common pitfalls that can lead to </span><strong class="bold"><span class="koboSpan" id="kobo.336.1">out-of-bounds</span></strong><span class="koboSpan" id="kobo.337.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.338.1">OOB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">) errors.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.340.1">Ownership and smart pointers checks</span></strong><span class="koboSpan" id="kobo.341.1">: These checks emphasize the correct usage of smart pointers to manage resource ownership. </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">cppcoreguidelines-owning-memory</span></strong><span class="koboSpan" id="kobo.343.1"> guides developers on when and how to use smart pointers such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">std::unique_ptr</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.345.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">std::shared_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.348.1">Rule of Five and Rule of Zero checks</span></strong><span class="koboSpan" id="kobo.349.1">: Clang-Tidy enforces the Rule of Five and Rule of Zero in C++ class design, ensuring that classes managing resources correctly implement copy and move constructors/assignment operators or avoid managing resources </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">manually, respectively.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.351.1">Miscellaneous checks</span></strong><span class="koboSpan" id="kobo.352.1">: Other miscellaneous checks include </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">cppcoreguidelines-special-member-functions</span></strong><span class="koboSpan" id="kobo.354.1"> (ensuring the correct implementation of special member functions) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">cppcoreguidelines-interfaces-global-init</span></strong><span class="koboSpan" id="kobo.356.1"> (avoiding global initialization </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">order issues).</span></span><p class="list-inset"><span class="koboSpan" id="kobo.358.1">Adherence to the C++ Core Guidelines</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.359.1"> via Clang-Tidy checks can significantly improve the quality of C++ code, making it more robust, maintainable, and aligned with modern C++ practices. </span><span class="koboSpan" id="kobo.359.2">These checks cover a wide range of best practices and are generally considered good to follow for most C++ projects, especially those aiming to leverage modern C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">features effectively.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.361.1">Check packages for standards compliance</span></strong><span class="koboSpan" id="kobo.362.1">: Clang-Tidy offers “packages” of checks that help ensure compliance with certain </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">high-level standards:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.364.1">High-performance C++ (hi-cpp)</span></strong><span class="koboSpan" id="kobo.365.1">: These checks focus on ensuring that the code is optimized </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">for performance.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.367.1">Certifications</span></strong><span class="koboSpan" id="kobo.368.1">: For projects that require adherence to specific certification standards (such as MISRA, CERT, and so on), Clang-Tidy offers checks that help align the code with these standards, although it’s important to note that using these checks alone may not be sufficient for full compliance with </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">such certifications.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.370.1">The ability to add custom checks means that Clang-Tidy is not just a static analysis tool but a platform that can adapt</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.371.1"> to various coding standards and practices. </span><span class="koboSpan" id="kobo.371.2">This adaptability makes it an ideal choice for projects ranging from open source libraries to commercial software, each with its unique set of requirements and standards. </span><span class="koboSpan" id="kobo.371.3">By leveraging these specialized checks, teams can ensure that their code not only adheres to general best practices in C++ but also aligns with specific guidelines and nuances of their project </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">or organization.</span></span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.373.1">Fine-tuning Clang-Tidy for customized static analysis</span></h2>
<p><span class="koboSpan" id="kobo.374.1">Configuring Clang-Tidy effectively</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.375.1"> is key to harnessing its full potential in a C++ project. </span><span class="koboSpan" id="kobo.375.2">This involves not just enabling and disabling certain checks but also controlling how specific parts of the code are analyzed. </span><span class="koboSpan" id="kobo.375.3">By customizing its behavior, developers can ensure that Clang-Tidy’s output is both relevant and actionable, focusing on the most important aspects of their code base. </span><span class="koboSpan" id="kobo.375.4">Let’s take a closer look </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">at this:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.377.1">Enabling and disabling checks</span></strong><span class="koboSpan" id="kobo.378.1">: Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">--checks=</span></strong><span class="koboSpan" id="kobo.380.1"> option to enable specific checks, and prepend </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">-</span></strong><span class="koboSpan" id="kobo.382.1"> to disable others. </span><span class="koboSpan" id="kobo.382.2">For instance, to turn on performance checks while turning off a specific one, you might use </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.384.1">
clang-tidy my_code.cpp --checks='performance-*, -performance-noexcept-move-constructor'</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.385.1">Ignoring specific warnings</span></strong><span class="koboSpan" id="kobo.386.1">: Clang-Tidy allows the suppression of warnings in two </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">primary ways:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.388.1">General suppression with NOLINT</span></strong><span class="koboSpan" id="kobo.389.1">: You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">NOLINT</span></strong><span class="koboSpan" id="kobo.391.1"> comment to suppress all warnings for a specific line of code. </span><span class="koboSpan" id="kobo.391.2">This is a broad approach and might hide more </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">than intended:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.393.1">
int x = 0; // NOLINT</span></pre></li><li><strong class="bold"><span class="koboSpan" id="kobo.394.1">Specific suppression</span></strong><span class="koboSpan" id="kobo.395.1">: A more targeted approach is to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">NOLINT(check-name)</span></strong><span class="koboSpan" id="kobo.397.1"> to suppress specific warnings. </span><span class="koboSpan" id="kobo.397.2">This approach is preferable as it prevents over-suppression of potentially </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">useful warnings:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.399.1">
int x = 0; // NOLINT(bugprone-integer-division)</span></pre></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.400.1">Treating warnings as errors</span></strong><span class="koboSpan" id="kobo.401.1">: To enforce code quality rigorously, convert warnings to errors using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">--warnings-as-errors=</span></strong><span class="koboSpan" id="kobo.403.1"> option. </span><span class="koboSpan" id="kobo.403.2">This can be applied globally or to </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">specific checks:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.405.1">
clang-tidy my_code.cpp --warnings-as-errors='bugprone-*'</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.406.1">Using a configuration file</span></strong><span class="koboSpan" id="kobo.407.1">: For consistent and shared settings across a project, place a </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">.clang-tidy</span></strong><span class="koboSpan" id="kobo.409.1"> file at the project’s root. </span><span class="koboSpan" id="kobo.409.2">This file should list  enabled checks and other configurations, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">following example:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.411.1">
Checks: 'performance-*, -performance-noexcept-move-constructor'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.412.1">
  WarningsAsErrors: 'bugprone-*'</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.413.1">Proper configuration of Clang-Tidy is crucial for effective static analysis in C++. </span><span class="koboSpan" id="kobo.413.2">By selectively enabling checks, specifically suppressing warnings where necessary, and treating critical warnings as errors, teams can maintain high code quality standards. </span><span class="koboSpan" id="kobo.413.3">The ability to fine-tune the analysis on a line-by-line basis with specific suppression</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.414.1"> comments ensures that Clang-Tidy provides focused and relevant feedback, making it an invaluable tool in the C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">developer’s toolkit.</span></span></p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.416.1">Overview of static analysis tools – comparing PVS-Studio, SonarQube, and others to Clang-Tidy</span></h1>
<p><span class="koboSpan" id="kobo.417.1">Static analysis tools are essential for ensuring code quality and adherence to best practices. </span><span class="koboSpan" id="kobo.417.2">While Clang-Tidy is a prominent tool in this space, particularly for C++ projects, there are other significant tools such as PVS-Studio and SonarQube, each with its unique features and strengths. </span><span class="koboSpan" id="kobo.417.3">Let’s compare these tools to Clang-Tidy and also mention a few other </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">notable options.</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.419.1">PVS-Studio</span></h2>
<p><span class="koboSpan" id="kobo.420.1">Using PVS-Studio</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.421.1"> has the </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">following benefits:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.423.1">Focus</span></strong><span class="koboSpan" id="kobo.424.1">: PVS-Studio is renowned for its deep analysis capabilities, particularly in detecting potential bugs, security flaws, and compliance with </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">coding standards.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.426.1">Languages supported</span></strong><span class="koboSpan" id="kobo.427.1">: While Clang-Tidy is focused primarily on C and C++, PVS-Studio supports a broader range of languages, including C#, Java, and even mixed C/C++/C# </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">code bases.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.429.1">Integration and usage</span></strong><span class="koboSpan" id="kobo.430.1">: PVS-Studio can be integrated into various IDEs and </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">continuous integration</span></strong><span class="koboSpan" id="kobo.432.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.433.1">CI</span></strong><span class="koboSpan" id="kobo.434.1">) systems. </span><span class="koboSpan" id="kobo.434.2">It differs from Clang-Tidy in that it’s a standalone tool, not tied to a specific compiler such </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">as Clang.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.436.1">Unique features</span></strong><span class="koboSpan" id="kobo.437.1">: It offers extensive checks for potential code vulnerabilities and is often praised for its detailed </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">diagnostic messages.</span></span></li>
</ul>
<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.439.1">SonarQube</span></h2>
<p><span class="koboSpan" id="kobo.440.1">SonarQube offers</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.441.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">following benefits:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.443.1">Focus</span></strong><span class="koboSpan" id="kobo.444.1">: SonarQube offers a comprehensive suite of code quality checks, including bugs, code smells, and </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">security vulnerabilities</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.446.1">Languages supported</span></strong><span class="koboSpan" id="kobo.447.1">: It supports a wide range of programming languages, making it a versatile choice for </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">multi-language projects</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.449.1">Integration and usage</span></strong><span class="koboSpan" id="kobo.450.1">: SonarQube stands out with its web-based dashboard that provides a detailed overview of the code quality, offering a more holistic view compared </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">to Clang-Tidy</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.452.1">Unique features</span></strong><span class="koboSpan" id="kobo.453.1">: It includes features for code coverage and technical debt estimation, which are not the primary focus </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">of Clang-Tidy</span></span></li>
</ul>
<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.455.1">Other notable tools</span></h2>
<p><span class="koboSpan" id="kobo.456.1">Other notable tools in this field include </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.458.1">Cppcheck</span></strong><span class="koboSpan" id="kobo.459.1">: Focused specifically on C and C++ languages, Cppcheck</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.460.1"> is a static analysis tool that emphasizes detecting undefined behavior, dangerous coding constructs, and other subtle bugs that other tools might miss. </span><span class="koboSpan" id="kobo.460.2">It’s lightweight and can complement </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">Clang-Tidy well.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.462.1">Coverity</span></strong><span class="koboSpan" id="kobo.463.1">: Known for its high accuracy</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.464.1"> and support for a wide range of programming languages, Coverity is a tool used in both commercial and open source projects to detect software defects and </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">security vulnerabilities.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.466.1">Visual Studio Static Analysis</span></strong><span class="koboSpan" id="kobo.467.1">: Integrated into the Visual Studio IDE, this</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.468.1"> tool provides checks specifically tailored for Windows development. </span><span class="koboSpan" id="kobo.468.2">It’s highly useful for developers working primarily in the </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">Windows ecosystem.</span></span></li>
</ul>
<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.470.1">Comparison with Clang-Tidy</span></h2>
<p><span class="koboSpan" id="kobo.471.1">Let’s now</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.472.1"> compare</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.473.1"> the</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.474.1"> aforementioned</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.475.1"> tools</span><a id="_idIndexMarker528"/> <span class="No-Break"><span class="koboSpan" id="kobo.476.1">with</span></span><span class="No-Break"><a id="_idIndexMarker529"/></span><span class="No-Break"><span class="koboSpan" id="kobo.477.1"> Clang-Tidy:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.478.1">Language support</span></strong><span class="koboSpan" id="kobo.479.1">: Clang-Tidy is primarily focused on C and C++, while tools such as PVS-Studio, SonarQube, and Coverity support a broader range </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">of languages.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.481.1">Integration and reporting</span></strong><span class="koboSpan" id="kobo.482.1">: Clang-Tidy is closely integrated with the LLVM/Clang ecosystem, making it an excellent choice for projects already using these tools. </span><span class="koboSpan" id="kobo.482.2">In contrast, SonarQube offers a comprehensive dashboard and PVS-Studio provides detailed reports, which are beneficial for larger projects </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">or teams.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.484.1">Specific use cases</span></strong><span class="koboSpan" id="kobo.485.1">: Tools such as Cppcheck and Visual Studio Static Analysis have specific niches – Cppcheck for its lightweight nature and focus on C/C++, and Visual Studio Static Analysis for its </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">Windows-specific checks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.487.1">Commercial versus open source</span></strong><span class="koboSpan" id="kobo.488.1">: Clang-Tidy is open source and free to use, whereas tools</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.489.1"> such as Coverity</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.490.1"> and PVS-Studio</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.491.1"> are commercial products, offering</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.492.1"> enterprise-level</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.493.1"> features </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">and</span></span><span class="No-Break"><a id="_idIndexMarker535"/></span><span class="No-Break"><span class="koboSpan" id="kobo.495.1"> support.</span></span></li>
</ul>
<h1 id="_idParaDest-205"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.496.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.497.1">In this chapter, we took a deep dive into the world of static analysis for C++ development, exploring a variety of tools and methodologies. </span><span class="koboSpan" id="kobo.497.2">We began with an overview of Clang-Tidy, developed by the LLVM Foundation, and its extensive capabilities in checking code for performance issues, modernization, bugs, style, readability, and security. </span><span class="koboSpan" id="kobo.497.3">We also covered other significant tools in the static analysis domain, including PVS-Studio, known for its vulnerability detection and multi-language support; SonarQube, with its comprehensive code quality checks and intuitive dashboard; and others such as Cppcheck, Coverity, and Visual Studio Static Analysis, each bringing unique strengths to </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">the table.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">A significant focus was on configuring Clang-Tidy, detailing how to fine-tune it for specific project needs, such as enabling or disabling diagnostics, managing warnings, and setting up configuration files. </span><span class="koboSpan" id="kobo.499.2">We also discussed the tool’s extensibility, highlighting custom checks for different coding standards and compliance packages for various requirements such as high-performance C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">and certifications.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">This exploration provided us with a broader understanding of the static analysis landscape in C++, revealing how these tools can significantly enhance code quality. </span><span class="koboSpan" id="kobo.501.2">As we wrap up this chapter, we prepare to shift gears in the next one, where we will explore the realm of dynamic analysis, complementing our knowledge of static analysis with insights into the behavior of running code. </span><span class="koboSpan" id="kobo.501.3">This will complete our comprehensive look at tools and techniques essential for mastering C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">code quality.</span></span></p>
</div>
</body></html>