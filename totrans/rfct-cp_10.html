<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-185"><a id="_idTextAnchor184"/>10</h1>
<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/>Introduction to Static Analysis in C++</h1>
<p>In the complex and demanding world of software development, ensuring the quality and reliability of code is not just a necessity but a discipline in itself. As C++ developers, we constantly seek methodologies and tools that can aid us in this quest. This chapter is dedicated to one such powerful approach: static analysis. Renowned for being both the fastest and the cheapest way to identify bugs, static analysis stands as a pillar in the software quality assurance process. We will delve into its intricacies, explore popular tools such as Clang-Tidy, PVS-Studio, and SonarQube, and understand how to effectively integrate static analysis into your C++ development workflow.</p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>The essence of static analysis</h1>
<p>Static analysis is the examination<a id="_idIndexMarker478"/> of source code without executing it. This process, typically automated by various tools, involves scanning the code to identify potential errors, code smells, security vulnerabilities, and other issues. It’s akin to a thorough proofreading session where the code is scrutinized for quality and reliability before it ever runs.</p>
<p>Why static analysis? Here<a id="_idIndexMarker479"/> are the reasons:</p>
<ul>
<li><strong class="bold">Speed and cost-effectiveness</strong>: The foremost advantage of static analysis is its speed and cost-effectiveness. It is arguably the fastest and cheapest method to find bugs. Automating the detection of issues drastically reduces the time and effort required compared to manual code reviews and other testing methods. Catching and resolving issues early in the development cycle significantly lowers the cost of fixes, which escalates if bugs are found later in production.</li>
<li><strong class="bold">Pre-execution bug detection</strong>: Static analysis occurs before the code is executed, making it a proactive measure in software quality assurance. This pre-execution analysis allows developers to identify and rectify issues without the overhead of setting up testing environments or dealing with the complexities of running the code.</li>
<li><strong class="bold">Coding standard enforcement</strong>: It helps in maintaining a consistent coding standard, ensuring that the code base adheres to the best practices and conventions of C++ programming. This enforcement not only improves code quality but also enhances maintainability and readability.</li>
<li><strong class="bold">Comprehensive coverage</strong>: With the ability to scan the entire code base, static analysis provides a level of thoroughness that is challenging to achieve through manual methods. This comprehensive coverage ensures that no part of the code is overlooked.</li>
<li><strong class="bold">Security and reliability</strong>: Early detection of security vulnerabilities is another critical benefit. Static analysis contributes significantly to the security and reliability of the application by catching vulnerabilities that might otherwise go unnoticed until exploitation.</li>
<li><strong class="bold">Educational aspect</strong>: It also serves an educational purpose, enhancing developers’ understanding of C++ and familiarizing<a id="_idIndexMarker480"/> them with common pitfalls and best practices.</li>
</ul>
<p>In the subsequent sections, we’ll explore how to leverage static analysis to its fullest potential in C++ projects. Following this, in the next chapter, we will compare and contrast these insights with dynamic analysis, offering a complete picture of the analysis landscape in C++ software development.</p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>Leveraging newer compiler versions for enhanced static analysis</h2>
<p>While the production environment<a id="_idIndexMarker481"/> often mandates specific, sometimes older, compiler versions for various reasons, including stability and compatibility, there is immense value in periodically building your project with newer versions of compilers. This practice serves as a forward-looking static analysis strategy, harnessing the advancements and improvements made in the latest compiler releases.</p>
<p>Newer compiler versions are frequently equipped with enhanced analysis capabilities, more sophisticated warning mechanisms, and updated interpretations of the C++ standard. They can identify issues and potential code improvements that older compilers might overlook. By compiling with these cutting-edge tools, developers can proactively discover and address latent issues in their code base, ensuring that the code remains robust and compliant with evolving C++ standards.</p>
<p>Additionally, this approach offers a preview of potential issues that might arise when an eventual update to the production compiler is undertaken. It provides an opportunity to future-proof the code base, making the transition to newer compiler versions smoother and more predictable.</p>
<p>In essence, incorporating newer compiler versions into the build process, even if they are not used for production builds, is a strategic measure. It not only elevates the quality of the code through advanced static analysis but also prepares the code base for future technological shifts, ensuring a state of continuous<a id="_idIndexMarker482"/> improvement and readiness for advancement.</p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor188"/>Compiler settings to harden C++ code</h1>
<p>In the pursuit of robust and secure C++ code, configuring compiler settings plays a pivotal role. Compiler flags and options can significantly enhance code quality by enabling stricter error checking, warnings, and security features. This section focuses on recommended settings for three major compilers in the C++ ecosystem: the <strong class="bold">GNU Compiler Collection</strong> (<strong class="bold">GCC</strong>), Clang, and <strong class="bold">Microsoft Visual C++</strong> (<strong class="bold">MSVC</strong>). These settings are particularly valuable in a static analysis context as they enable the detection of potential issues at compile time.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/>GCC</h2>
<p>GCC is known for its extensive set of options<a id="_idIndexMarker483"/> that can help<a id="_idIndexMarker484"/> harden C++ code. Key flags include the following:</p>
<ul>
<li><code>-Wall -Wextra</code>: Enables most warning messages, catching potential issues such as uninitialized variables, unused parameters, and more</li>
<li><code>-Werror</code>: Treats all warnings as errors, forcing them to be addressed</li>
<li><code>-Wshadow</code>: Warns whenever a local variable shadows another variable, which can lead to confusing bugs</li>
<li><code>-Wnon-virtual-dtor</code>: Warns if a class with virtual functions has a non-virtual destructor, which can lead to undefined behavior</li>
<li><code>-pedantic</code>: Enforces strict ISO C++ compliance, rejecting non-standard code</li>
<li><code>-Wconversion</code>: Warns on implicit conversions that may alter a value, useful for preventing data loss</li>
<li><code>-Wsign-conversion</code>: Warns on implicit conversions that change the sign of a value</li>
</ul>
<h2 id="_idParaDest-191"><a id="_idTextAnchor190"/>Clang</h2>
<p>Clang, part of the LLVM<a id="_idIndexMarker485"/> project, shares<a id="_idIndexMarker486"/> many flags with GCC but also provides additional checks and a reputation for generating more human-readable warnings:</p>
<ul>
<li><code>-Weverything</code>: Enables every warning available in Clang, providing a comprehensive check of the code. This can be overwhelming, so it’s often used with selective disabling of less critical warnings.</li>
<li><code>-Werror</code>, <code>-Wall</code>, <code>-Wextra</code>, <code>-Wshadow</code>, <code>-Wnon-virtual-dtor</code>,              <code>-pedantic</code>, <code>-Wconversion</code>, and <code>-Wsign-conversion</code>: Similar to GCC, these flags are also applicable in Clang and serve the same purposes.</li>
<li><code>-Wdocumentation</code>: Warns about documentation inconsistencies, which is useful when maintaining large code bases with extensive comments.</li>
<li><code>-fsanitize=address</code>, <code>-fsanitize=undefined</code>: Enables <code>AddressSanitizer</code> and <code>UndefinedBehaviorSanitizer</code> to catch memory corruption and undefined behavior issues.</li>
</ul>
<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>MSVC</h2>
<p>MSVC, while having a different<a id="_idIndexMarker487"/> set of flags, also offers<a id="_idIndexMarker488"/> robust options for enhancing code safety:</p>
<ul>
<li><code>/W4</code>: Enables a higher warning level, similar to <code>-Wall</code> in GCC/Clang. This includes most of the useful warnings for common issues.</li>
<li><code>/WX</code>: Treats all compiler warnings as errors.</li>
<li><code>/sdl</code>: Enables additional security checks, such as buffer overflow detection and integer overflow checks.</li>
<li><code>/GS</code>: Provides buffer security checks, helping prevent common security vulnerabilities.</li>
<li><code>/analyze</code>: Enables static code analysis to detect issues such as memory leaks, uninitialized variables, and other potential errors at compile time.</li>
</ul>
<p>By utilizing these compiler settings, developers can significantly harden their C++ code, making it more secure, robust, and compliant with best practices. While the default settings of compilers catch many issues, enabling these additional flags ensures a much stricter and more thorough analysis of the code. It is important<a id="_idIndexMarker489"/> to note that while these settings<a id="_idIndexMarker490"/> can greatly enhance code quality, they should be complemented with good programming practices and regular code reviews for the best results. In the next chapter, we will shift our focus to dynamic analysis, another key component in ensuring the overall quality and security of C++ applications.</p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor192"/>Static analysis via multiple compilers</h1>
<p>In the realm of C++ development, leveraging<a id="_idIndexMarker491"/> the capabilities of compilers for static analysis is an often underutilized strategy. Compilers such as GCC and Clang come equipped with a plethora of compilation flags that enable rigorous static analysis, helping to identify potential issues without the need for additional tools. Employing these flags is not only convenient but also highly effective in enhancing code quality.</p>
<p>One best practice that I advocate for is building C++ projects with multiple compilers. Each compiler has its unique set of diagnostics, and by utilizing more than one, projects can gain a more comprehensive insight into potential issues. GCC and Clang are particularly notable for their similarity in supported flags, as well as their wide-ranging support for various architectures and operating systems. This compatibility makes it feasible to integrate both into a project’s build process for cross-checking code.</p>
<p>However, incorporating these practices in a Windows environment can present additional challenges. While GCC and Clang are versatile, projects often also benefit from the distinct diagnostics provided by MSVC. MSVC integrates seamlessly with the Windows ecosystem and brings to the table a different perspective on code analysis, which can be especially beneficial for projects targeting Windows platforms. Although managing multiple compilers might introduce some complexity, the payoff in identifying a broader spectrum of potential issues is invaluable. By embracing this multi-compiler approach, projects can significantly enhance their static analysis rigor, leading to more robust and reliable C++ code.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>Highlighting compiler differences – unused private members in GCC versus Clang</h2>
<p>A nuanced understanding<a id="_idIndexMarker492"/> of the diagnostic capabilities<a id="_idIndexMarker493"/> of different compilers can be crucial in C++ development. This is exemplified in the way GCC and Clang handle unused private member variables. Consider the following class definition:</p>
<pre class="source-code">
#include &lt;iostream&gt;
class NumberWrapper {
    int number;
public:
    NumberWrapper() {
    }
};</pre>
<p>Here, the <code>number</code> private member in the <code>NumberWrapper</code> class is initialized but never used. This situation presents a potential<a id="_idIndexMarker494"/> issue in the code that could indicate redundancy.</p>
<p>Let’s compare how GCC and Clang<a id="_idIndexMarker495"/> handle unused private members:</p>
<ul>
<li><code>number</code> unused private member. This lack of warning might lead to unintentional neglect of inefficiencies or redundancies in the class design.</li>
<li><code>warning: private field 'number' is not used</code>. This precise diagnostic helps in promptly identifying and addressing potential oversights in the class’s implementation.</li>
</ul>
<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>Highlighting compiler differences – compiler checks for uninitialized variables</h2>
<p>When dealing with class<a id="_idIndexMarker496"/> variables in C++, ensuring proper initialization is crucial to prevent undefined behavior. This aspect is highlighted in how different compilers detect uninitialized but used variables. Consider the example of the <code>NumberWrapper</code> class:</p>
<pre class="source-code">
#include &lt;iostream&gt;
class NumberWrapper {
    int number;
public:
    NumberWrapper(int n) {
        (void)n; // to avoid warning: unused parameter 'n'
        std::cout &lt;&lt; "init with: " &lt;&lt; number &lt;&lt; std::endl;
    }
};
int main() {
    auto num = NumberWrapper{1};
    (void) num;
    return 0;
}</pre>
<p>In this code, the <code>number</code> member variable<a id="_idIndexMarker497"/> is not initialized, leading to undefined behavior when it’s used in the constructor. It can print something such as <code>init </code><code>with: 32767</code>.</p>
<p>We’ll now compare the approaches<a id="_idIndexMarker498"/> used by GCC and Clang in this regard:</p>
<ul>
<li><code>warning: 'num.NumberWrapper::number' is used uninitialized</code>. This warning serves as an important alert to developers, drawing attention to the risk of using uninitialized variables, which can lead to unpredictable program behavior or subtle bugs.</li>
<li><strong class="bold">Clang’s diagnostic approach</strong>: Interestingly, Clang version 17 does not generate a warning for the same code, potentially allowing this oversight to go unnoticed in environments where only Clang is used. This demonstrates a case where relying solely on Clang might miss certain classes of errors that GCC can catch.</li>
</ul>
<p>The two examples discussed previously offer compelling insights into the distinctive strengths and nuances of GCC and Clang’s diagnostic capabilities. These instances – one highlighting Clang’s ability to flag unused private fields and the other showcasing GCC’s proficiency in warning about uninitialized class variables – exemplify the importance of a multi-compiler strategy in C++ development.</p>
<p>By utilizing both Clang and GCC, developers can harness a more comprehensive and diversified static analysis process. Each compiler, with its unique set of warnings and checks, can reveal different potential issues or optimizations. Clang, known for its detailed and specific warnings, such as flagging unused private fields, complements GCC’s vigilant checks for fundamental yet critical issues such as uninitialized variables. This synergy between the compilers ensures a more thorough vetting of the code, leading to higher quality and more reliable and maintainable software.</p>
<p>In essence, the combination of Clang<a id="_idIndexMarker499"/> and GCC does<a id="_idIndexMarker500"/> not just add value in terms of the sum of their individual capabilities; it creates a more robust and holistic environment for static analysis. As the C++ language and its compilers continue to evolve, staying adaptable and open to multiple tools for static analysis remains a best practice for developers aiming for excellence in their craft. This approach aligns well with the ever-present goal in software development: writing clean, efficient, and error-free code.</p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor195"/>Exploring static analysis with Clang-Tidy</h1>
<p>As we delve deeper<a id="_idIndexMarker501"/> into the realm<a id="_idIndexMarker502"/> of static analysis, a tool that stands out for its versatility and depth is Clang-Tidy. Developed by the LLVM Foundation, the same organization behind the Clang compiler, Clang-Tidy is a linter and static analysis tool designed for C++ code. It extends beyond the capabilities of what a traditional compiler would check, offering a range of diagnostics that include stylistic errors, programming mistakes, and even subtle bugs that are often missed during regular code reviews. Previously, we explored how Clang-Tidy can be adept at code formatting; now, we will explore its prowess in static analysis, uncovering its ability to scrutinize C++ code at a level that ensures not just conformity but also excellence in coding standards.</p>
<p>Clang-Tidy works by using the Clang frontend to parse C++ code, enabling it to understand the code’s structure and syntax in depth. This deep understanding allows Clang-Tidy to perform complex checks that go beyond mere textual analysis, examining the code’s semantics and even the flow of execution. It’s not just about finding syntactic discrepancies; it’s about understanding the code’s behavior and intent.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>Categories of checks in Clang-Tidy</h2>
<p>Clang-Tidy categorizes<a id="_idIndexMarker503"/> its checks into several groups, each targeting specific types of issues. Let’s break down these categories and explore examples for each:</p>
<ul>
<li><strong class="bold">Performance checks</strong>: Focus on identifying inefficient<a id="_idIndexMarker504"/> patterns in the code that can slow down execution; for example, unnecessary copying of objects. Clang-Tidy can flag cases where an object is copied but could be moved or passed by reference to avoid the overhead of copying:<pre class="source-code">
#include &lt;vector&gt;</pre><pre class="source-code">
std::vector&lt;int&gt; createLargeVector();</pre><pre class="source-code">
void processVector(std::vector&lt;int&gt; vec);</pre><pre class="source-code">
int main() {</pre><pre class="source-code">
    std::vector&lt;int&gt; vec = createLargeVector();</pre><pre class="source-code">
    processVector(vec); // Clang-Tidy: Use std::move to avoid copying</pre><pre class="source-code">
    return 0;</pre><pre class="source-code">
}</pre></li>
<li><code>for</code> loops with range-based <code>for</code> loops for better readability and safety:<pre class="source-code">
std::vector&lt;int&gt; myVec = {1, 2, 3};</pre><pre class="source-code">
for (std::size_t i = 0; i &lt; myVec.size(); ++i) {</pre><pre class="source-code">
    // Clang-Tidy: Use a range-based for loop instead</pre><pre class="source-code">
    std::cout &lt;&lt; myVec[i] &lt;&lt; std::endl;</pre><pre class="source-code">
}</pre></li>
<li><strong class="bold">Bug detection</strong>: Identify potential errors<a id="_idIndexMarker507"/> or logical bugs in the code; for example, detecting null pointer dereferences:<pre class="source-code">
int* ptr = nullptr;</pre><pre class="source-code">
int value = *ptr; // Clang-Tidy: Dereference of null pointer</pre></li>
<li><strong class="bold">Style checks</strong>: Enforce specific coding styles<a id="_idIndexMarker508"/> for consistency and readability; for example, enforcing variable naming conventions:<pre class="source-code">
int MyVariable = 42; // Clang-Tidy: Variable name should be lower_case</pre></li>
<li><strong class="bold">Readability checks</strong>: Focus on making the code<a id="_idIndexMarker509"/> more understandable and maintainable; for example, simplifying complex Boolean expressions:<pre class="source-code">
bool a, b, c;</pre><pre class="source-code">
if (a &amp;&amp; (b || c)) {</pre><pre class="source-code">
    // Clang-Tidy: Simplify logical expression</pre><pre class="source-code">
}</pre></li>
<li><strong class="bold">Security checks</strong>: Target potential security vulnerabilities; for example, highlighting<a id="_idIndexMarker510"/> uses of dangerous functions known to pose<a id="_idIndexMarker511"/> security risks:<pre class="source-code">
strcpy(dest, src); // Clang-Tidy: Use of function 'strcpy' is insecure</pre></li>
</ul>
<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Expanding Clang-Tidy’s capabilities with custom checks</h2>
<p>Clang-Tidy’s versatility<a id="_idIndexMarker512"/> is further enhanced by its support for custom checks, allowing companies and projects to tailor static analysis to their specific needs and coding standards. This customization capability has led to the creation of various categories of checks, each aligning with the guidelines of different organizations or projects. Next, we explore some notable examples:</p>
<ul>
<li><code>google-runtime-references</code> enforces Google’s preference for pointers over non-const references.</li>
<li><strong class="bold">Google’s Abseil checks</strong>: Abseil is an open source collection of C++ library code developed by Google. Checks specific to Abseil ensure adherence to the library’s best practices, such as avoiding certain deprecated functions or classes.</li>
<li><strong class="bold">Fuchsia checks</strong>: Tailored for the Fuchsia operating system, these checks enforce coding standards and best practices specific to the Fuchsia project. They help maintain consistency and quality in the code base contributing to this OS.</li>
<li><strong class="bold">Zircon checks</strong>: Zircon is the core platform that powers the Fuchsia OS. Clang-Tidy includes checks tailored to Zircon’s development, focusing on its unique architecture and development standards.</li>
<li><strong class="bold">Darwin checks</strong>: These checks are specifically designed for Darwin, the open source Unix-like operating system released by Apple. They ensure compliance with Darwin’s development practices.</li>
<li><strong class="bold">LLVM checks (llvm-*)</strong>: These checks are designed to enforce LLVM coding standards. They are particularly useful for developers contributing to LLVM or its subprojects.</li>
<li><strong class="bold">C++ Core Guidelines checks</strong>: Clang-Tidy includes checks that enforce the C++ Core Guidelines, a set of best practices for writing modern C++. This includes rules for type safety, resource management, and performance.</li>
<li><code>cppcoreguidelines-pro-type-member-init</code> ensures that class members are properly initialized. <code>cppcoreguidelines-pro-type-reinterpret-cast</code> warns against the use of <code>reinterpret_cast</code>, encouraging safer casting alternatives.</li>
<li><code>cppcoreguidelines-non-private-member-variables-in-classes</code> discourages the use of non-private member variables to maintain encapsulation.</li>
<li><code>cppcoreguidelines-avoid-magic-numbers</code> help identify hardcoded numbers that may not have an obvious meaning, promoting readability and maintainability.</li>
<li><code>cppcoreguidelines-avoid-c-arrays</code> and <code>cppcoreguidelines-avoid-non-const-global-variables</code>, which promote the use of modern C++ constructs such as <code>std::array</code> or <code>std::vector</code> over C-style arrays and discourage the use of non-const global variables.</li>
<li><code>cppcoreguidelines-pro-bounds-array-to-pointer-decay</code> and <code>cppcoreguidelines-pro-bounds-constant-array-index</code> warn against<a id="_idIndexMarker514"/> common pitfalls that can lead to <strong class="bold">out-of-bounds</strong> (<strong class="bold">OOB</strong>) errors.</li>
<li><code>cppcoreguidelines-owning-memory</code> guides developers on when and how to use smart pointers such as <code>std::unique_ptr</code> or <code>std::shared_ptr</code>.</li>
<li><strong class="bold">Rule of Five and Rule of Zero checks</strong>: Clang-Tidy enforces the Rule of Five and Rule of Zero in C++ class design, ensuring that classes managing resources correctly implement copy and move constructors/assignment operators or avoid managing resources manually, respectively.</li>
<li><code>cppcoreguidelines-special-member-functions</code> (ensuring the correct implementation of special member functions) and <code>cppcoreguidelines-interfaces-global-init</code> (avoiding global initialization order issues).<p class="list-inset">Adherence to the C++ Core Guidelines<a id="_idIndexMarker515"/> via Clang-Tidy checks can significantly improve the quality of C++ code, making it more robust, maintainable, and aligned with modern C++ practices. These checks cover a wide range of best practices and are generally considered good to follow for most C++ projects, especially those aiming to leverage modern C++ features effectively.</p></li>
<li><strong class="bold">Check packages for standards compliance</strong>: Clang-Tidy offers “packages” of checks that help ensure compliance with certain high-level standards:<ul><li><strong class="bold">High-performance C++ (hi-cpp)</strong>: These checks focus on ensuring that the code is optimized for performance.</li><li><strong class="bold">Certifications</strong>: For projects that require adherence to specific certification standards (such as MISRA, CERT, and so on), Clang-Tidy offers checks that help align the code with these standards, although it’s important to note that using these checks alone may not be sufficient for full compliance with such certifications.</li></ul></li>
</ul>
<p>The ability to add custom checks means that Clang-Tidy is not just a static analysis tool but a platform that can adapt<a id="_idIndexMarker516"/> to various coding standards and practices. This adaptability makes it an ideal choice for projects ranging from open source libraries to commercial software, each with its unique set of requirements and standards. By leveraging these specialized checks, teams can ensure that their code not only adheres to general best practices in C++ but also aligns with specific guidelines and nuances of their project or organization.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>Fine-tuning Clang-Tidy for customized static analysis</h2>
<p>Configuring Clang-Tidy effectively<a id="_idIndexMarker517"/> is key to harnessing its full potential in a C++ project. This involves not just enabling and disabling certain checks but also controlling how specific parts of the code are analyzed. By customizing its behavior, developers can ensure that Clang-Tidy’s output is both relevant and actionable, focusing on the most important aspects of their code base. Let’s take a closer look at this:</p>
<ul>
<li><code>--checks=</code> option to enable specific checks, and prepend <code>-</code> to disable others. For instance, to turn on performance checks while turning off a specific one, you might use the following:<pre class="source-code">
clang-tidy my_code.cpp --checks='performance-*, -performance-noexcept-move-constructor'</pre></li>
<li><code>NOLINT</code> comment to suppress all warnings for a specific line of code. This is a broad approach and might hide more than intended:<pre class="source-code">
int x = 0; // NOLINT</pre></li><li><code>NOLINT(check-name)</code> to suppress specific warnings. This approach is preferable as it prevents over-suppression of potentially useful warnings:<pre class="source-code">
int x = 0; // NOLINT(bugprone-integer-division)</pre></li></ul></li>
<li><code>--warnings-as-errors=</code> option. This can be applied globally or to specific checks:<pre class="source-code">
clang-tidy my_code.cpp --warnings-as-errors='bugprone-*'</pre></li>
<li><code>.clang-tidy</code> file at the project’s root. This file should list  enabled checks and other configurations, as in the following example:<pre class="source-code">
Checks: 'performance-*, -performance-noexcept-move-constructor'</pre><pre class="source-code">
  WarningsAsErrors: 'bugprone-*'</pre></li>
</ul>
<p>Proper configuration of Clang-Tidy is crucial for effective static analysis in C++. By selectively enabling checks, specifically suppressing warnings where necessary, and treating critical warnings as errors, teams can maintain high code quality standards. The ability to fine-tune the analysis on a line-by-line basis with specific suppression<a id="_idIndexMarker518"/> comments ensures that Clang-Tidy provides focused and relevant feedback, making it an invaluable tool in the C++ developer’s toolkit.</p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor199"/>Overview of static analysis tools – comparing PVS-Studio, SonarQube, and others to Clang-Tidy</h1>
<p>Static analysis tools are essential for ensuring code quality and adherence to best practices. While Clang-Tidy is a prominent tool in this space, particularly for C++ projects, there are other significant tools such as PVS-Studio and SonarQube, each with its unique features and strengths. Let’s compare these tools to Clang-Tidy and also mention a few other notable options.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/>PVS-Studio</h2>
<p>Using PVS-Studio<a id="_idIndexMarker519"/> has the following benefits:</p>
<ul>
<li><strong class="bold">Focus</strong>: PVS-Studio is renowned for its deep analysis capabilities, particularly in detecting potential bugs, security flaws, and compliance with coding standards.</li>
<li><strong class="bold">Languages supported</strong>: While Clang-Tidy is focused primarily on C and C++, PVS-Studio supports a broader range of languages, including C#, Java, and even mixed C/C++/C# code bases.</li>
<li><strong class="bold">Integration and usage</strong>: PVS-Studio can be integrated into various IDEs and <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) systems. It differs from Clang-Tidy in that it’s a standalone tool, not tied to a specific compiler such as Clang.</li>
<li><strong class="bold">Unique features</strong>: It offers extensive checks for potential code vulnerabilities and is often praised for its detailed diagnostic messages.</li>
</ul>
<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>SonarQube</h2>
<p>SonarQube offers<a id="_idIndexMarker520"/> the following benefits:</p>
<ul>
<li><strong class="bold">Focus</strong>: SonarQube offers a comprehensive suite of code quality checks, including bugs, code smells, and security vulnerabilities</li>
<li><strong class="bold">Languages supported</strong>: It supports a wide range of programming languages, making it a versatile choice for multi-language projects</li>
<li><strong class="bold">Integration and usage</strong>: SonarQube stands out with its web-based dashboard that provides a detailed overview of the code quality, offering a more holistic view compared to Clang-Tidy</li>
<li><strong class="bold">Unique features</strong>: It includes features for code coverage and technical debt estimation, which are not the primary focus of Clang-Tidy</li>
</ul>
<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>Other notable tools</h2>
<p>Other notable tools in this field include the following:</p>
<ul>
<li><strong class="bold">Cppcheck</strong>: Focused specifically on C and C++ languages, Cppcheck<a id="_idIndexMarker521"/> is a static analysis tool that emphasizes detecting undefined behavior, dangerous coding constructs, and other subtle bugs that other tools might miss. It’s lightweight and can complement Clang-Tidy well.</li>
<li><strong class="bold">Coverity</strong>: Known for its high accuracy<a id="_idIndexMarker522"/> and support for a wide range of programming languages, Coverity is a tool used in both commercial and open source projects to detect software defects and security vulnerabilities.</li>
<li><strong class="bold">Visual Studio Static Analysis</strong>: Integrated into the Visual Studio IDE, this<a id="_idIndexMarker523"/> tool provides checks specifically tailored for Windows development. It’s highly useful for developers working primarily in the Windows ecosystem.</li>
</ul>
<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>Comparison with Clang-Tidy</h2>
<p>Let’s now<a id="_idIndexMarker524"/> compare<a id="_idIndexMarker525"/> the<a id="_idIndexMarker526"/> aforementioned<a id="_idIndexMarker527"/> tools<a id="_idIndexMarker528"/> with<a id="_idIndexMarker529"/> Clang-Tidy:</p>
<ul>
<li><strong class="bold">Language support</strong>: Clang-Tidy is primarily focused on C and C++, while tools such as PVS-Studio, SonarQube, and Coverity support a broader range of languages.</li>
<li><strong class="bold">Integration and reporting</strong>: Clang-Tidy is closely integrated with the LLVM/Clang ecosystem, making it an excellent choice for projects already using these tools. In contrast, SonarQube offers a comprehensive dashboard and PVS-Studio provides detailed reports, which are beneficial for larger projects or teams.</li>
<li><strong class="bold">Specific use cases</strong>: Tools such as Cppcheck and Visual Studio Static Analysis have specific niches – Cppcheck for its lightweight nature and focus on C/C++, and Visual Studio Static Analysis for its Windows-specific checks.</li>
<li><strong class="bold">Commercial versus open source</strong>: Clang-Tidy is open source and free to use, whereas tools<a id="_idIndexMarker530"/> such as Coverity<a id="_idIndexMarker531"/> and PVS-Studio<a id="_idIndexMarker532"/> are commercial products, offering<a id="_idIndexMarker533"/> enterprise-level<a id="_idIndexMarker534"/> features and<a id="_idIndexMarker535"/> support.</li>
</ul>
<h1 id="_idParaDest-205"><a id="_idTextAnchor204"/>Summary</h1>
<p>In this chapter, we took a deep dive into the world of static analysis for C++ development, exploring a variety of tools and methodologies. We began with an overview of Clang-Tidy, developed by the LLVM Foundation, and its extensive capabilities in checking code for performance issues, modernization, bugs, style, readability, and security. We also covered other significant tools in the static analysis domain, including PVS-Studio, known for its vulnerability detection and multi-language support; SonarQube, with its comprehensive code quality checks and intuitive dashboard; and others such as Cppcheck, Coverity, and Visual Studio Static Analysis, each bringing unique strengths to the table.</p>
<p>A significant focus was on configuring Clang-Tidy, detailing how to fine-tune it for specific project needs, such as enabling or disabling diagnostics, managing warnings, and setting up configuration files. We also discussed the tool’s extensibility, highlighting custom checks for different coding standards and compliance packages for various requirements such as high-performance C++ and certifications.</p>
<p>This exploration provided us with a broader understanding of the static analysis landscape in C++, revealing how these tools can significantly enhance code quality. As we wrap up this chapter, we prepare to shift gears in the next one, where we will explore the realm of dynamic analysis, complementing our knowledge of static analysis with insights into the behavior of running code. This will complete our comprehensive look at tools and techniques essential for mastering C++ code quality.</p>
</div>
</body></html>