- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recapping Lua-C++ Communication Mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part 2* of this book, we learned how to call Lua from C++. In *Part 3*,
    we learned how to call C++ from Lua. In the course of this book, we have explored
    many examples, some of which depend on advanced C++ techniques.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will summarize all the communication mechanisms between Lua and
    C++, stripping away most of the C++ details. We will also dig deeper into some
    of the topics that we have not demonstrated in the examples yet.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this chapter to recap what you have learned. For each topic, we
    will list some important Lua library functions. You can check the Lua reference
    manual for more related functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, as you progress in your programming journey, you might adopt
    different C++ techniques in your projects. In such cases, this chapter will be
    a useful source for quick reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Lua from C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling C++ from Lua
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing standalone C++ modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing state in Lua
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Userdata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can access the source code for this chapter at [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter09](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: You can access the Lua reference manual and develop the habit of frequently
    checking for API details at [https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/).
  prefs: []
  type: TYPE_NORMAL
- en: The stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Lua stack can serve two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Exchange data between C++ and Lua.* Passing function arguments and retrieving
    function return values fit into this usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Keep intermediate results.* For example, we can keep a table reference in
    the stack until we are done with the table; we can push some values onto the stack
    and then pop and use them as upvalues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Lua stack comes in two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The public stack that comes with the Lua state.* Once a Lua state is created
    via `luaL_newstate` or `lua_newstate`, you can pass the state around and the same
    Lua stack is accessible to all functions that can access the Lua state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The private stack for each* `lua_CFunction` *call.* The stack is only accessible
    to a function call. Calling the same `lua_CFunction` multiple times will not share
    the same stack. So, the stack that is passed to a `lua_CFunction` call is private
    to the function call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing onto the stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use `lua_pushXXX` functions to push a value or an object reference onto
    the stack – for example, `lua_pushstring`.
  prefs: []
  type: TYPE_NORMAL
- en: Check the Lua reference manual for a list of such functions.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use `lua_isXXX` functions to check if a given stack position holds an
    item of a certain type.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `lua_toXXX` functions to convert a given stack position into a certain
    type. Those functions will always succeed, although the resulting values might
    be a surprise if the stack position is holding an item of a different type.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the Lua reference manual for a list of such functions.
  prefs: []
  type: TYPE_NORMAL
- en: Other stack operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some other frequently used stack operations.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring stack size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Lua stack is created with a predefined size that should be big enough for
    most operations. If you need to push a lot of items onto the stack, you can ensure
    that the stack size can meet your needs by calling the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`n` is the required size.'
  prefs: []
  type: TYPE_NORMAL
- en: Counting items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To check the number of items in the stack, use `lua_gettop`. The return value
    is the count.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the stack top
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set the top of the stack to a certain index, use the `lua_settop` function,
    whose declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This can either clear some items from the top of the stack or pad the stack
    with nils. We can use it to clear temporary items from the stack efficiently,
    as can be seen in `LuaModuleExporter::luaNew` from our examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In `luaNew`, we passed the Lua state, thus the Lua stack, to an external factory
    method. Because we do not know how the factory method will use the Lua stack,
    we cleared the stack after the factory method returned to get rid of any possible
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Copying another item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If an item is already in the stack, you can push a copy of it onto the top
    of the stack quickly by calling this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This can save you some trouble if the value or object backing the item is hard
    to get.
  prefs: []
  type: TYPE_NORMAL
- en: Some other stack operations are supported by the Lua library, but they are used
    infrequently to achieve complex effects. You can check them out in the reference
    manual.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Lua from C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To call Lua code from C++, we can use `lua_pcall`, which is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will call a Lua callable, which can be a function or a chunk. You can push
    the Lua function to be called onto the stack, or compile a file or a string into
    a chunk and then place it onto the stack. `nargs` is the number of arguments for
    the callable. The arguments are pushed onto the stack above the callable. `nresults`
    is the count of return values the callable would return. Use `LUA_MULTRET` to
    indicate that you expect a variable count of return values. `msgh` is the stack
    index for an error message handler.
  prefs: []
  type: TYPE_NORMAL
- en: '`lua_pcall` calls the callable in *protected mode*, which means that any error
    that may have occurred in the call chain is not propagated. Instead, an error
    status code is returned from `lua_pcall`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LuaExecutor` class that we have implemented, you can find many examples
    of calling Lua from C++.
  prefs: []
  type: TYPE_NORMAL
- en: In the Lua reference manual, you can find other library functions similar to
    `lua_pcall`, although `lua_pcall` is the most frequently used one.
  prefs: []
  type: TYPE_NORMAL
- en: Calling C++ from Lua
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To call C++ code from Lua, the C++ code needs to be exported via a `lua_CFunction`
    implementation, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, in `LuaExecutor`, we implemented a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a single integer value to the Lua code. A simple way to export
    this function to the global table can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can use `lua_pushcfunction` to push `lua_CFunction` onto the stack and then
    assign it to a variable of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: However, more than likely, you should export a group of functions as a module.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting C++ modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To export a C++ module, you simply need to export a table of functions to Lua.
    In `LuaExecutor`, we have implemented it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The process is to first create a table and push the reference onto the stack
    with `lua_createtable`. Then, you can push *shared upvalues* (we will recap upvalues
    later in this chapter), and finally add the list of functions to the table with
    `luaL_setfuncs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not need upvalues, there is a shortcut that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `luaL_newlib` and `luaL_setfuncs` take a list of the following structure
    to describe the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The structure provides `lua_CFunction` with a `name` value, which is used as
    the table entry key.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing standalone C++ modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have only explicitly registered C++ modules to Lua in
    C++ code. However, there is another way to provide a C++ module to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: You can produce a shared library for a module and place it in Lua’s search path.
    When the Lua code *requires* the module, Lua will load the shared library automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'By reusing our `Destinations` class, this is simple to implement. Create a
    file named `DestinationsModule.cpp` and fill it exactly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The module that’s been implemented is called `destinations`. The code-level
    contract Lua requires is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to provide `lua_CFunction`, whose name must begin with `luaopen_`,
    and then have the module name appended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lua_CFunction` needs to leave what it creates in the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for `luaopen_destinations` is almost identical to that of `LuaExecutor::registerModule`,
    which we explained in the previous section. The only difference is that we have
    left the table reference in the stack because the Lua `require` function will
    pop it.
  prefs: []
  type: TYPE_NORMAL
- en: extern “C”
  prefs: []
  type: TYPE_NORMAL
- en: By default, the C++ compiler will mangle the C++ function name. This means that
    after the function is compiled, the function will have a symbol name more complex
    than what it declares to be in the source code. To prevent this from happening,
    you can place the function declaration inside an `extern "C"` block. Otherwise,
    Lua won’t be able to find the function as the contract is broken after compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the standalone module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compile the shared library, add the following lines to your `Makefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In a Terminal, execute `make destinations` to create the shared library. You
    will get a file named `destinations.so`, which is the binary file Lua will load.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the standalone module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the standalone module, in the folder where `destinations.so` resides,
    start a Lua interactive interpreter and execute the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The most important statement is the `require` statement. This loads `destinations.so`
    and assigns the module to the `Destinations` global variable.
  prefs: []
  type: TYPE_NORMAL
- en: We started the Lua interactive interpreter in the same folder where the module
    binary resides because `require` will search the current working directory for
    modules. Alternatively, you can put the library in a system search path. You can
    check the reference manual to learn more about `require` and its behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: A standalone C++ module is useful when you need to reuse the module in the binary
    form across multiple projects or enforce code isolation on the C++ side, but this
    is just a design choice.
  prefs: []
  type: TYPE_NORMAL
- en: Storing state in Lua
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to store state in Lua for `lua_CFunction`: *upvalues* and
    *the registry*. Let’s recap them and dig deeper into upvalues.'
  prefs: []
  type: TYPE_NORMAL
- en: Upvalues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To introduce the complete definition for upvalues, we need to introduce **Lua
    C closures** at the same time. To quote the Lua reference manual:'
  prefs: []
  type: TYPE_NORMAL
- en: When a C function is created, it is possible to associate some values with it,
    thus creating a C closure; these values are called upvalues and are accessible
    to the function whenever it is called.
  prefs: []
  type: TYPE_NORMAL
- en: To put it simply, the closure is still our old friend `lua_CFunction`. When
    you associate some values with it, it becomes a closure, and the values become
    upvalues.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that Lua C closures and upvalues are inseparable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a closure, use the following library function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This creates a closure from `lua_CFunction` and associates `n` values with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see it in action, let’s solve the design problem from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We are creating objects in `LuaModuleDef` but destroying them in `LuaModuleExporter`.
    For a better design, the same class should destroy the objects it creates.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Lua C closure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following feature is a continuation of the previous chapter. You can revisit
    the previous chapter to get a better understanding if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can implement a `destroyInstance` member variable for `LuaModuleDef`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, objects will be created and destroyed in the same `LuaModuleDef` entity.
    To use `destroyInstance`, modify `LuaModuleExporter::luaDelete`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that `getExporter` is used to retrieve the first upvalue, which is a
    pointer to the exporter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This works for `luaNew` because `LuaModuleExporter` is inherited from `LuaModule`,
    which pushes `this` as an upvalue in its default implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the pushed upvalue is used as shared upvalues for all exported functions
    in `LuaExecutor::registerModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Shared upvalues are pushed onto the stack once and get associated with all the
    functions provided to `luaL_setfuncs`.
  prefs: []
  type: TYPE_NORMAL
- en: Shared upvalues are not really shared
  prefs: []
  type: TYPE_NORMAL
- en: The so-called shared upvalues are copied for each function during setup. Afterward,
    the functions access their own copies of the upvalues. In the Lua reference manual,
    these are called shared upvalues because they are only pushed onto the stack once
    and used for all functions to be registered, which is only relevant to API invocations.
    I think this term is misleading. You should think of these as just plain upvalues.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `getExporter` will not work for `luaDelete` because `luaDelete` is
    not an exported function and is not passed to `luaL_setfuncs`. To support `luaDelete`,
    modify `luaNew`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We only need to push `exporter` as an upvalue for `luaDelete` and make `luaDelete`
    a closure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, `LuaModuleExporter` has a better design as it delegates both object construction
    and object destruction to `LuaModuleDef`. Also, it utilizes both upvalues (for
    `luaDelete`) and shared upvalues (for `luaNew`) at the same time in the `getExporter`
    helper function. This shows that shared upvalues are no different from upvalues
    after they are set up.
  prefs: []
  type: TYPE_NORMAL
- en: The registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The registry is a predefined Lua table that is only accessible to C/C++ code.
    For a Lua state, the registry is shared for all C/C++ functions, so table key
    names should be selected carefully to avoid collision.
  prefs: []
  type: TYPE_NORMAL
- en: Notably, by convention, *full userdata* places its metatable in the registry
    via `luaL_newmetatable`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Put simply, the registry is a Lua table that the Lua language treats specially
    and provides a few helper* *functions for.*'
  prefs: []
  type: TYPE_NORMAL
- en: Userdata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Lua userdata can be categorized into *light userdata* and *full userdata*.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that they are different things. In the Lua library,
    conventionally, light userdata is named lightuserdata, while full userdata is
    named userdata.
  prefs: []
  type: TYPE_NORMAL
- en: Light userdata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Light userdata represents a C/C++ pointer. It is a value type and the value
    is passed around. You push a pointer in C/C++ code onto the stack with `lua_pushlightuserdata`.
    You cannot create light userdata with the Lua library.
  prefs: []
  type: TYPE_NORMAL
- en: Full userdata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Full userdata is a raw memory area allocated by the Lua library with a call
    to `lua_newuserdatauv`. It is an object type and only its reference is passed
    around.
  prefs: []
  type: TYPE_NORMAL
- en: Because full userdata is created by Lua in the heap, Lua garbage collection
    comes into the picture. On the C++ side, you can provide a *finalizer* by providing
    the `__gc` metamethod.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete example of how to utilize full userdata to access C++ objects
    in Lua, check `LuaModuleExporter`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we briefly recapped all communication mechanisms between Lua
    and C++. This should have sufficiently reinforced your learnings so far.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to produce a standalone C++ module as a shared library.
    This opens new ways for you to organize your projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk more about resource management.
  prefs: []
  type: TYPE_NORMAL
