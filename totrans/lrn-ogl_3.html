<html><head></head><body>
        

                            
                    <h1 class="header-title">Transformations, Projections, and Camera</h1>
                
            
            
                
<p>In the previous chapter, we discussed about how to create shapes in OpenGL using our libraries. We learned to add colors to our shapes and we'll also discussed how to add texture to the shapes. This chapter will be the continuation of the previous chapter and we'll discuss how to apply transformations such as rotation or translate to our shapes. We'll also discuss the projection and the coordinate system and try to implement that in our game world. You'll also get to learn about the camera class and we'll use that to view and navigate through our multiple objects we'll create in this chapter. </p>
<p>The following topics will be covered in this chapter: </p>
<ul>
<li>Applying transformations such as rotations and translate to our shapes</li>
<li>Implementation of projection and the coordinate system in the game world</li>
<li>Adding multiple objects to our game world</li>
<li>Creating and using camera class for a better view of objects </li>
</ul>
<p>So let's begin... </p>
<p>You can refer to all the code files for this chapter in the <kbd>Chapter03</kbd> folder on GitHub. The GitHub link can be found in the preface of the book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transformations using GLM</h1>
                
            
            
                
<p> We'll be looking at making transformations to our shape and the texture applied to it. To do the transformations, we'll be using the OpenGL Mathematics library that is GLM. For transformations, we need to use vectors and matrices, and GLM handles a lot of that in the backend for us. All we have to do is call the correct method (for example, translate or rotate), and it'll do the appropriate matrices and vector transformations for us. </p>
<p>It is recommended that you go to <a href="https://learnopengl.com/">learnopengl.com</a> and <a href="https://www.opengl.org/">open.gl</a>. These sites have got some great resources that showcase all the different vectors and matrices and how to use them, and it goes into more depth about the mathematics behind it. So, if you're interested, you should definitely visit these sites.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up a project to use GLM on Windows / Mac</h1>
                
            
            
                
<p>So, to begin with, we need to download and install the GLM library onto our system. It's very similar to installing the other frameworks that we learned to install in the previous chapters, whether it's GLFW, SDL, or SFML. But if you wish to review this, please refer to the <em>Setting up a project to use SOIL on Windows or Mac</em> section in <a href="674fc755-f955-4a25-b241-bd882af16879.xhtml" target="_blank">Chapter 2</a>, <em>Drawing Shapes and Applying Textures</em>. The setup process for GLM will be very much similar to what was discussed in the mentioned section. For the further sections we'll assume that you've install the GLM library in your system and set the project up too.</p>
<p>Now that the GLM library is installed and our project is setup, let's move on to make some modifications to our code so that we can transform our shapes and textures applied to it. In further sections, we'll make some modifications to our code from the previous chapter to transform our shapes.</p>
<p>So, to begin with, we will first need to update our shader files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating shader files</h1>
                
            
            
                
<p>Let's follow the below mentioned steps to update the shader files: </p>
<ol>
<li>We'll go to our vertex shader that is <kbd>core.vs</kbd> file and perform the following highlighted modifications to the code: </li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>layout (location = 0) in vec3 position;<br/>layout (location = 1) in vec3 color;<br/>layout (location = 2) in vec2 texCoord;<br/>out vec3 ourColor;<br/>out vec2 TexCoord; <br/><br/><strong>uniform mat4 transform;</strong><br/><br/>void main()<br/>{<br/> gl_Position = <strong>transform *</strong> vec4(position, 1.0f);<br/> ourColor = color;<br/> TexCoord = vec2(texCoord.x, 1.0 - texCoord.y);<br/>}</pre>
<ol start="2">
<li>For the fragment shader, we don't need to do anything as we'll be requiring that code as it is. </li>
</ol>
<p>Now we can go to <kbd>main.cpp</kbd> and carry out the modification to our main code to apply transformations to our objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying transformations to the objects</h1>
                
            
            
                
<p>Take a look at the following steps to understand the modifications that we need to carry out to incorporate transformations in our main code:</p>
<ol>
<li>To make changes to our main code, we'll begin by including the <kbd>GLM</kbd> header file in our code, so add the following highlighted include terms in your code:</li>
</ol>
<pre style="padding-left: 60px"><strong>#include &lt;glm/glm.hpp&gt;</strong><br/><strong>#include &lt;glm/gtc/matrix_transform.hpp&gt;</strong><br/><strong>#include &lt;glm/gtc/type_ptr.hpp&gt;</strong></pre>
<ol start="2">
<li>The next thing that we are going to do is create the transformation matrix that we want to apply. To do this, go to the while loop, and somewhere in the loop between defining the shader and activating the texture we'll need to add the code described as follows:
<ol>
<li>First of all, we're going to just create the transformation matrix. So, we'll begin by typing <kbd>glm::mat4</kbd> and we'll call it <kbd>transform</kbd>. </li>
<li>Then we'll add the type of transformation. For the translate transformation we'll define it as <kbd>transform = glm::translate();</kbd>. For the <kbd>translate ()</kbd> function, the first parameter that we will need to specify is the 4x4 matrix that we're going to use. Next, we'll specify the vector, which is <kbd>glm::vec3()</kbd>. This takes three parameters—the x, y, and z coordinates—and for those we'll pass the values <kbd>0.5f</kbd> , <kbd>-0.5f</kbd> and <kbd>0.0f</kbd>. Remember, the values should range between -1 and 1, for now.</li>
<li>Next, we'll define the rotate transformation, <kbd>transform = glm::rotate()</kbd>, and for the <kbd>rotate()</kbd> function we'll pass parameters: for the <kbd>matrix</kbd>, we're going to specify <kbd>transform</kbd> again. For the <kbd>angle</kbd>, we need to state how much we want it to rotate by, because we don't want it just to rotate once. We want it to constantly rotate. Therefore, we'll add <kbd>glfwGetTime()</kbd> and cast it to <kbd>GLfloat</kbd>. The <kbd>glfwGetTime()</kbd> function will be the amount of time that has passed since GLFW was initialized and use that to rotate our object. </li>
</ol>
</li>
</ol>
<p>For more information on <strong>time methods</strong>, you can visit the following links:<br/>
for GLFW time input, visit <a href="https://www.glfw.org/docs/3.0/group__time.html">https://www.glfw.org/docs/3.0/group__time.html</a>;<br/>
for SDL time input, you can use the <kbd>SDL_GetTicks</kbd> method and read the information at<a href="https://wiki.libsdl.org/SDL_GetTicks"> https://wiki.libsdl.org/SDL_GetTicks</a>; and, for SFML, you can use the <kbd>getElapsedTime</kbd> method and for more info on that you can visit <a href="https://www.sfml-dev.org/tutorials/2.5/system-time.php">https://www.sfml-dev.org/tutorials/2.5/system-time.php</a></p>
<p style="padding-left: 120px">We will need to time the method so that the texture rotates at a certain speed. So, we will multiply the method <kbd>glfwGetTime( )</kbd> by <kbd>-5.0f</kbd>. This will make the object rotate in one way. If you add a positive number, it rotates the other way. Try experimenting with the value. By increasing the value you will make it rotate faster, and by reducing the value you will make it go slower. </p>
<p style="padding-left: 120px">The third parameter that we need to pass is <kbd>glm::vec3()</kbd>, and for the vector you have to specify what axes you want the shapes to rotate around. So, either use <kbd>1.0f</kbd> or <kbd>0.0f</kbd>. Adding <kbd>0.0f</kbd> means you don't want it to rotate around that particular axis. So, we'll define it as <kbd>0.0f, 0.0f, 1.0f</kbd>. This means that our texture will rotate around the z axis. The reason we've chosen z is because, at the moment, we're not doing anything in 3D. So, by rotating round the z axis, it'll just look like it's a 2D transformation.</p>
<p style="padding-left: 60px">Take a look at the following code to get a clear understanding of the preceding description:</p>
<pre style="padding-left: 60px">// Create transformations<br/> glm::mat4 transform;<br/> transform = glm::translate( transform, glm::vec3( 0.5f, -0.5f, 0.0f ) );<br/><strong>transform = glm::rotate( transform, ( GLfloat)glfwGetTime( ) * -5.0f, glm::vec3( 0.0f, 0.0f, 1.0f ) ); </strong>  </pre>
<ol start="3">
<li>Now that we've created our transformation matrix, we can actually get on to applying it. Therefore, we need to get the matrix uniform location and set the matrix up for our shader to use. So we need to create a <kbd>GLint</kbd> variable <kbd>transformLocation</kbd> and to that we'll assign the value of <kbd>glGetUniformLocation()</kbd>, and to this function need to pass <kbd>ourShader.Program</kbd> and our transformation matrix <kbd>"transform"</kbd>. Next, we need to define uniform matrix in our code, so add the <kbd>glUniformMatrix4fv()</kbd> function to our code, and this takes a few parameters. First of all is the <kbd>transformLocation</kbd>, then <kbd>1</kbd>, and then <kbd>GL_FALSE</kbd> and <kbd>glm::value_ptr()</kbd>, and to this function we need to specify the transformation matrix that we're using: </li>
</ol>
<pre style="padding-left: 60px">// Get matrix's uniform location and set matrix<br/> GLint transformLocation = glGetUniformLocation( ourShader.Program, "transform" );<br/> glUniformMatrix4fv( transformLocation, 1, GL_FALSE, glm::value_ptr( transform ) );</pre>
<p>If you want to know more about what these parameters are doing, it is recommended that you check out <a href="http://learnopengl.com">learnopengl.com</a> and <a href="http://open.gl">open.gl</a>, because these sites explain a lot of this in more depth. </p>
<p>And now we're all set and ready to run. If we run this, we should get our image rotating in the top-right corner, as shown in the following screenshot:</p>
<div><img src="img/465fb17b-3d25-4d0d-bc0b-4dc0d544e3a1.png" style=""/></div>
<p>The illustration used in this chapter is for explanatory purposes only. We do not recommend you to misuse these in any way. For more information please consult the terms and conditions of the publisher mentioned in the Disclaimer section of this book.</p>
<p>It is recommended that you try experimenting with the following line of code to vary the location and speed of rotation:</p>
<pre>transform = glm::rotate( transform, ( GLfloat)glfwGetTime( ) * -5.0f, glm::vec3( 0.0f, 0.0f, 1.0f ) );</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Projections and coordinate systems</h1>
                
            
            
                
<p>In this section, we're going to look at the projections and the coordinate systems. So let's first understand what the coordinate systems are? There are two types of coordinate system: a left-handed and a right-handed coordinate system. The best way to visualize them is to put up both of your hands, as shown in the following image:</p>
<div><img class="aligncenter size-full wp-image-309 image-border" src="img/a4e1f039-aea0-4962-929b-cea2fbd1bd56.png" style=""/></div>
<p>As per the image, the index fingers of both your hands should point up. Your middle fingers should point towards you and your thumbs should point to the left and right directions, respectively. Once you've done that, the direction that your fingers and your thumbs are pointing is the positive direction for that axis. So, the way the index finger is pointing (upward) is the positive y axis. The direction in which the middle finger is pointing is the positive z axis and the thumbs are pointing in the direction of the positive x axis. OpenGL uses the right-handed coordinate system, while the DirectX uses the left-handed coordinate system. </p>
<p>For more information on the coordinate system, you can check out the following links: <br/>
<a href="https://learnopengl.com/">https://learnopengl.com/</a> and <a href="https://open.gl./">https://open.gl./</a></p>
<p>Now that we've discussed the coordinate system, let's understand the different types of projection we've got in OpenGL. We have the perspective projection and orthographic projection. Perspective projection takes depth into consideration, which, generally speaking, every game in production would, whereas, orthographic projection doesn't take depth into consideration. So, in orthographic projection, an object or part of an object that is further away from you still looks the same size. If you have two identical objects and one is further away, it will still look the same size. However, in perspective projection, just like in real life, the object, that is further away would look smaller. You might be wondering, where orthographic projection would ever be useful? One example is in architecture, when you're creating a laid-out design and you want to have objects behind other objects, but, because you're giving measurements, you don't want them to vary in size.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifications to the code</h1>
                
            
            
                
<p>In this section, we will make some modifications to our texture code to integrate projection and coordinate system in our game world. </p>
<p> We'll begin our modifications by updating the shader files. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making modifications to the shader files</h1>
                
            
            
                
<p>Check out the next steps to understand what modifications we need to do to our shader files:</p>
<ol>
<li>The first thing that we want to do is go to our vertex shader and carry out the following highlighted changes to the code:</li>
</ol>
<pre style="padding-left: 60px">#version 330 core<br/>layout (location = 0) in vec3 position;<br/>layout (location = 2) in vec2 texCoord;<br/>out vec2 TexCoord;<br/><strong>uniform mat4 model;</strong><br/><strong>uniform mat4 view;</strong><br/><strong>uniform mat4 projection;</strong><br/>void main()<br/>{<br/> gl_Position = <strong>projection * view * model *</strong> vec4(position, 1.0f);<br/> TexCoord = vec2(texCoord.x, 1.0 - texCoord.y);<br/>}</pre>
<p style="padding-left: 60px">In the preceding code, we have removed all the color values because we are just using textures now. Second, we deleted the uniform matrix transform as well because we're going to use a few different ways of transforming. Third, we created a uniform 4x4 matrix, which is going to be the model matrix. Fourth, we created a uniform 4x4 matrix, which is the view matrix, and another uniform 4x4 matrix, which is the projection matrix. These three different types of matrices do very important stuff. The model matrix converts local-object coordinates to camera coordinates. The projection matrix converts the camera coordinates to normalized coordinates, so the coordinates are between 0 and 1, and the view matrix converts the normalized coordinates to window coordinates. Finally, we assigned the value of multiplication for the matrix to the <kbd>gl_position</kbd> to implement it.</p>
<ol start="2">
<li>Next, we'll move on to the core-fragment shader, and in here we'll get rid of <kbd>vec3 ourColor</kbd>; and the rest will remain as it is. The reason for deleting the color parameter is the same as described in the previous step. </li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifications to the main code</h1>
                
            
            
                
<p>Now that we have updated our shader files, we'll go ahead and make some modifications to our main code to implement the projection and the coordinate system. Follow the below mentioned steps:</p>
<ol>
<li>First of all, we'll get rid of the EBO, as we're not using the element buffer object anymore; we'll get rid of any other instances of element buffer object, and we'll remove the <kbd>glDeleteBuffers( 1, &amp;EBO )</kbd>, too. Then, we'll delete the color attribute.</li>
<li>Now that we have cleaned our project, we are going to enable depth in our code; the reason we need to enable it is because if we've got 3D objects or objects that are further away from us or nearer to us, we need to plan for depth. So, let's go to our code and below <kbd>glViewport</kbd> we'll add the <kbd>glEnable()</kbd> function; to do this, we'll pass <kbd>GL_DEPTH_TEST</kbd>. Then, we'll go to the while loop, and in the <kbd>glClear()</kbd> function we'll need to specify depth to clear the depth buffer, so add <kbd>| GL_DEPTH_BUFFER_BIT</kbd> to it.</li>
<li>Now that we've implemented depth in our application, we're going update the indices and the vertices present in our code. We are implementing a 3D cube in this section to help illustrate perspective and orthographic projection. Therefore, we'll have to make modifications to our vertices and get rid of our indices. To add the updated vertices to your code, please refer to the <kbd>main.cpp</kbd> present inside the <kbd>Projections and Coordinate Systems</kbd> folder. You'll observe that there are vertices for two types of projections: orthographic projection and the perspective projection. We'll be switching between the two of them to understand the difference between the two projections. In the updated vertices, we have defined six sets of vertices and texture coordinates, each one for a face of the cube. For your reference, check out a set of vertices for one side of the cube that is mentioned in the following and let's try to understand what it defines:</li>
</ol>
<pre style="padding-left: 60px"> // Positions            //Texture Coordinates    <br/>-0.5f, -0.5f, -0.5f,     0.0f, 0.0f,<br/> 0.5f, -0.5f, -0.5f,     1.0f, 0.0f,<br/> 0.5f,  0.5f, -0.5f,     1.0f, 1.0f,<br/> 0.5f,  0.5f, -0.5f,     1.0f, 1.0f,<br/>-0.5f,  0.5f, -0.5f,     0.0f, 1.0f,<br/>-0.5f, -0.5f, -0.5f,     0.0f, 0.0f,</pre>
<p style="padding-left: 60px">In the preceding code, the first three values in a row are the x, y and z positions, and the next two are the normalized texture coordinates. We covered pretty much all of this in the previous section. It is recommended that you take a look at each one of these sets and try to figure out which face of the cube they correlate to.</p>
<ol start="4">
<li>Next, once we've updated the vertices, we need to make some modifications to our attributes, so take look at the updated attributes, as follows, and make similar changes to our code:</li>
</ol>
<pre style="padding-left: 60px">// Position attribute<br/> glVertexAttribPointer( 0, 3, GL_FLOAT , GL_FALSE, <strong>5</strong> * sizeof( GLfloat ), ( GLvoid * )0 );<br/> glEnableVertexAttribArray( 0 );<br/> <br/>// TexCoord attribute<br/> glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE,<strong> 5</strong> * sizeof( GLfloat ), ( GLvoid * )( 3 * sizeof( GLfloat ) ) );<br/> glEnableVertexAttribArray( 2 );</pre>
<p style="padding-left: 60px">In the preceding code, we have updated the factor by which we multiply size of vertices to <kbd>5</kbd> because there are five different pieces of information on each row in our updated vertices. </p>
<ol start="5">
<li>In terms of our texture loading, we won't touch any of that code whatsoever, as that is defining our texture perfectly.</li>
<li>So, after we've unbinded the texture and cleaned it up, and before the <kbd>while</kbd> loop starts, we are going to define the projection matrix <kbd>glm::mat4 projection;</kbd>, The first one we're going to discuss is perspective projection, because that's the one that you'll probably be using most of the time. Therefore, we'll add <kbd>projection = glm::perspective()</kbd>; the <kbd>perspective()</kbd> takes a few values:
<ul>
<li>The first value is the field of view, and, for that, we're going to use 45 degrees. This is a very common value for video games.</li>
<li>The second value is the aspect ratio, and, for that, we'll add <kbd>screenWidth / screenHeight</kbd>. This keeps it dynamic. We're going to cast each to <kbd>GLfloat</kbd>.</li>
<li>For the third value (the near clipping plane), we'll just add <kbd>0.1f</kbd>.</li>
<li>For the fourth value (the far clipping plane), we'll use <kbd>1000.0f</kbd>.</li>
</ul>
</li>
</ol>
<p>Take a look at the following highlighted code to understand the previous description:</p>
<pre>// Unbind texture when done,so we won't accidentily mess up our texture.<br/>glBindTexture( GL_TEXTURE_2D, 0 ); <br/> <br/> <strong>glm::mat4 projection;</strong><br/><strong> projection = glm::perspective( 45.0f, ( GLfloat )screenWidth / ( GLfloat )screenHeight, 0.1f, 100.0f );</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">View Frustum</h1>
                
            
            
                
<p>Let's try to understand the preceding description of code with the help of a simple View Frustum image, as follows:</p>
<div><img class="aligncenter size-full wp-image-302 image-border" src="img/1fb8ca0b-0f34-4afa-bccb-b183108d6da2.png" style=""/></div>
<p> The center of projection is where the virtual camera is placed. <strong>zNear</strong> is the near clipping plane, which we have defined as <kbd>0.1f</kbd> in our code. The <kbd>1000.0f</kbd> value refers to the far clipping plane, which is <strong>zFar</strong>. These two values mean that anything nearer than the near clipping plane won't be drawn for you on the screen, anything further than the far clipping plane won't be drawn for you, and anything outside of the view frustum box won't be drawn for you either. The aspect ratio is the <strong>width</strong> divided by the <strong>height</strong>, and the field of view is basically how tall it is.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifications to while loop </h1>
                
            
            
                
<p>Now that we've created the projection matrix, we can actually start creating the model and the view matrices, and you need to do that within our while loop. Let's take a look at the following steps: </p>
<ol>
<li>So, to begin with, we're going to get rid of the code that defines our transformation matrix, as we're no longer using that. We'll move the <kbd>glActiveTexture()</kbd> code before we activate our shader.</li>
<li>After that, we're going to create the model and view matrices, for which we'll add the following code to our while loop after we have activated our shader. We'll begin with adding the <kbd>glm:: mat4 model</kbd> and <kbd>glm::mat4 view</kbd> matrix. The model will be <kbd>model = glm::rotate ()</kbd>, and we'll just put an initial sort of rotation in <kbd>rotate ()</kbd>. For the <kbd>rotate ()</kbd>, we're going to pass following parameters:
<ul>
<li>First we'll pass <kbd>model</kbd>, which refers to the model matrix</li>
</ul>
</li>
</ol>
<pre style="padding-left: 60px">// Activate shader<br/> ourShader.Use( );<br/> <br/> // Create transformations<br/><strong> glm::mat4 model;</strong><br/><strong> glm::mat4 view;</strong><br/><strong> model = glm::rotate( model, ( GLfloat)glfwGetTime( ) * 1.0f, glm::vec3( 0.5f, 1.0f, 0.0f ) );</strong> // use with perspective projection<br/> <br/>//model = glm::rotate( model, 0.5f, glm::vec3( 1.0f, 0.0f, 0.0f ) ); // use to compare orthographic and perspective projection<br/> //view = glm::translate( view, glm::vec3( screenWidth / 2, screenHeight / 2, -700.0f ) ); // use with orthographic projection<br/> <br/><strong>view = glm::translate( view, glm::vec3( 0.0f, 0.0f, -3.0f ) );</strong> // use with perspective projection</pre>
<ul>
<li style="padding-left: 60px">Second for the angle of rotation, we're just going to pass the <kbd>glfwGetTime()</kbd>, which will get the time between starting GLFW and now. This is obviously only going to constantly increase, hence we can use this as a nice way of providing rotation. We'll cast this function to <kbd>GLfloat</kbd>, then we'll multiply it by <kbd>1.0f</kbd>. This is a great way of increasing and decreasing the speed, as all you have do is vary the value. </li>
</ul>
<p>For more information about angle of rotation, please refer to the information box that was provided earlier with links for SFML, SDL, and GLFW, for you to check out. </p>
<ul>
<li style="padding-left: 60px">The next parameter that we're going to provide is the vector 3 matrix <kbd>glm::vec3()</kbd>, and for <kbd>vec3()</kbd> we're going to use <kbd>0.5f</kbd> in the x axis, <kbd>1.0f</kbd> in the y axis and we're not going to have any rotation in the z axis. This is going to add a nice effect to our cube.</li>
</ul>
<ol start="3">
<li>Next, we are going to type <kbd>view = glm::translate()</kbd>. In here, we're going to move the view slightly. So, in the <kbd>translate ()</kbd>, we'll first pass our view matrix; then we specify what sort of movement we want, so will type <kbd>glm::vec3() </kbd>; and to <kbd>vec3()</kbd> we're going to pass <kbd>0.0f</kbd>, <kbd>0.0f</kbd>, <kbd>-3.0f</kbd> for the axes. So we're going to be moving the camera, which is essentially so we can actually see what is going on. Otherwise, we'd principally be within our cube only.</li>
</ol>
<p style="padding-left: 60px">Take a look at the following code to understand the preceding description:</p>
<pre style="padding-left: 60px">// Create transformations<br/>view = glm::translate( view, glm::vec3( 0.0f, 0.0f, -3.0f ) ); // use with perspective projection</pre>
<p style="padding-left: 60px">Now that we've got that sorted, you might be wondering why we are adding a rotation and a translation matrix. This is just for this particular section to get a better view of the projections. You may not want to add a rotation or a translation matrix to further sections.</p>
<ol start="4">
<li>Next, to get the uniform location, we'll add following highlighted lines of code:</li>
</ol>
<pre style="padding-left: 60px">// Get their uniform location<br/> <strong>GLint modelLoc = glGetUniformLocation( ourShader.Program, "model" );</strong><br/><strong> GLint viewLoc = glGetUniformLocation( ourShader.Program, "view" );</strong><br/><strong> GLint projLoc = glGetUniformLocation( ourShader.Program, "projection"</strong> );<br/> // Pass them to the shaders<br/><strong> glUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );</strong><br/><strong> glUniformMatrix4fv( viewLoc, 1, GL_FALSE, glm::value_ptr( view ) );</strong><br/><strong> glUniformMatrix4fv( projLoc, 1, GL_FALSE, glm::value_ptr( projection )</strong> );</pre>
<ol start="5">
<li>Next, we need to draw our object, so we're going to add <kbd>glBindVertexArray()</kbd>, and to that we'll pass the the vertex array object <kbd>VAO</kbd>.</li>
</ol>
<ol start="6">
<li>We'll then add <kbd>glDrawArrays ()</kbd> to that, firstly, we'll pass: 
<ul>
<li>Firstly <kbd>GL_TRIANGLES</kbd>.</li>
<li>Secondly, the first vertex will start at <kbd>0</kbd> </li>
<li>For the count we'll pass <kbd>36</kbd>, because there are two triangles per face and each triangle has three coordinates. The two triangles result in six coordinates, so 6 x 6 = 36. </li>
</ul>
</li>
</ol>
<ol start="7">
<li>Next, we'll unbind it, so we're going to add <kbd>glBindVertexArray()</kbd> to which we'll pass <kbd>0</kbd>.</li>
</ol>
<pre style="padding-left: 60px"> // Draw container<br/> glBindVertexArray( VAO );<br/> glDrawArrays( GL_TRIANGLES, 0, 36 );<br/> glBindVertexArray( 0 );</pre>
<p>Now we are all sorted, let's recheck the code once and then run it. If you don't come across any errors, you will get a similar rotating cube on your screen to the following:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-303 image-border" src="img/a2070aef-a86f-4d35-9055-beaede154c82.png" style="width:30.67em;height:28.50em;"/> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Orthgraphic projection</h1>
                
            
            
                
<p>Now let's just see how orthgraphic projection looks, and understand the difference between orthographic and perspective projections. So, we're going to comment the perspective-projection coordinates and add the orthagraphic-projection coordinates from the <kbd>main.cpp</kbd> present inside the <kbd>Projections and Coordinate Systems</kbd> folder.</p>
<p>Then we'll go to our <kbd>glm::mat4 projection;</kbd> and comment out the perspective projection, and add the following highlighted line of code for the orthographic projection: </p>
<pre><strong>projection = glm::ortho(0.0f, ( GLfloat )screenWidth, 0.0f, ( GLfloat )screenHeight, 0.1f, 1000.0f);</strong></pre>
<p>You may be wondering where the field of view and the ratio are. We don't need those because the cube is more like the box shown in the following image:</p>
<div><img class="aligncenter size-full wp-image-304 image-border" src="img/586e2d48-4151-4342-85b5-2e6fc2342905.png" style=""/></div>
<p>Now we've only other two things that needs to be changed, those are the model and the view matrices, simply because this will help to demonstrate what we're trying to show. So, comment out the perspective-projection model and view definitions, and add the following lines of code:</p>
<pre>model = glm::rotate( model, 0.5f, glm::vec3( 1.0f, 0.0f, 0.0f ) ); <br/>// use to compare orthographic and perspective projection<br/><br/>view = glm::translate( view, glm::vec3( screenWidth / 2, screenHeight / 2, -700.0f ) ); <br/>// use with orthographic projection</pre>
<p>Now, let's run this code and see what our cube looks like:</p>
<div><img class="aligncenter size-full wp-image-305 image-border" src="img/d27bd157-402e-4567-94e0-344ab418e48f.png" style=""/></div>
<p>So we've got our cube, but this looks a bit weird. It just looks like a big, long rectangle. But what's actually happening is that the image facing us is the front face of the cube and the top rectangular image is the top face of the cube. We've rotated the cube, but without perspective, and it's hard to tell which face is which. But let's try an experiment and watch what happens when we comment out the orthagraphic <kbd>view</kbd> and uncomment the perspective <kbd>view</kbd>. Let's bring in the perspective projection again, uncomment the perspective array, and comment out the orthagraphic array. Now if we run the code with the perspective projection, you'll see a key difference between orthographic and perspective projections; take a look at the following image: </p>
<div><img class="aligncenter size-full wp-image-306 image-border" src="img/446d1a27-20fc-4c92-9ff8-f3a4ce252efb.png" style=""/></div>
<p>Looking at the preceding image now, it blatantly looks more like a cube. Obviously, we can't see the sides, the bottom, or the back face, but, based on what we're seeing here, it looks much more like a cube compared to how it looked before.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a Camera class to the project</h1>
                
            
            
                
<p>In the previous section, we learned how to add objects to our screen and how to apply texture, transformation and projection to the objects. As we progress ahead in the book, we will add various objects to our screen, but as we add more objects to it and if we wish to view those from different angles, we don't want to have specific code to be able to do that or to move freely around the objects. Therefore, in this chapter, we'll be looking at implementing a <kbd>Camera</kbd> class, which will help us to move around our world freely, using the keyboard, and view those objects from different angles. Implementing this class will help us to improvise a walking style of movement and take a look at the virtual world around the player with the help of the mouse. As we learned in the previous chapter, what we've got currently is the single cube we've created. As we are seeking to implement multiple objects in this chapter, we'll basically get rid of the vertices that describe our single cube, and use a simple array of vertices and a loop to draw multiple cubes. Instead of just moving around one cube, we'll see multiple cubes, which will be fantastic.</p>
<p>Here are the things we're going to cover in this section:</p>
<ul>
<li>Learning how to draw multiple cubes</li>
<li>Creating the <kbd>Camera</kbd> class and implementing it in our current application</li>
</ul>
<p>There are just a few prerequisites before we get started. We'll use the source code from the previous chapter, which was on projections and coordinate systems. If you don't have the source code, you can download it from the GitHub link provided in the preface of this book. Also, in this chapter, we'll be using GLFW as the framework. This means we will be using some GLFW coding here, but this is actually only for the input of what we're doing. Feel free to check out the input guides for other libraries too, try to swap the code with other libraries, and try experimenting. The <kbd>Camera</kbd> class that we are going to define in this chapter won't be affected by your experimentation, as it isn't going to have any framework-specific code. Only the main code will be affected, as it's going to be used to detect the input.</p>
<p>Let's get started.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Camera.h header file</h1>
                
            
            
                
<p>We'll begin by creating a header file for our <kbd>Camera</kbd> class, so we'll create an empty header file in our project and add it to our target. We'll name it <kbd>Camera.h</kbd>. We'll only have a header because the methods that we're going to implement are very simple methods. But you can extract it into a separate CPP file if you want to. It is recommended that you try experimenting that way as well, because it will be a great way to learn. Let's begin coding our camera header. Follow these steps:</p>
<ol>
<li>First, let's get rid of the default code that is already present in the file. Then, add <kbd>#pragma</kbd> when the code is a simpler version. This doesn't work on all compilers, but most compilers will support this.</li>
<li>Then, we'll add the <kbd>#include</kbd> vector. We'll be using the <kbd>vector</kbd> class for stuff such as positioning. Let's then add <kbd>#define GLEW_STATIC</kbd>, because we're going to be using GLEW in here, which we've already linked to our project. Next, we'll add <kbd>#include GL/glew.h</kbd>. We're also going to include some OpenGL Mathematics libraries, so let’s add <kbd>glm/glm.hpp</kbd> and <kbd>#include glm/gtc/matrix_transform.hpp</kbd>.</li>
<li>Next, we're going to create an enumeration to define several possible options for camera movement. Let’s add <kbd>enum Camera_Movements</kbd>. This will contain <kbd>FORWARD</kbd>, <kbd>BACKWARD</kbd>, <kbd>LEFT</kbd> and <kbd>RIGHT</kbd>, which we need to use to find out which way the user wants to move the camera -- essentially, to identify which way a user wants to walk.</li>
</ol>
<ol start="4">
<li>Now, we're going to create some constant camera values for the yaw, pitch, and speed of the camera movement, and sensitivity and zoom. We're not going to have methods for these, apart from for the zoom, but you can have methods for all the other ones. You can create getters and setters; it is recommended that you do this as an extra task. It's a great way of learning and you'll be able to use them later on.</li>
<li>So, we're going to add <kbd>const</kbd>. Obviously, at the moment, because we're using a constant, you won't be able to modify it, but if you do want to modify it, that's not a problem. But these are the default values, so you wouldn't be manipulating this particular variable specifically. You'd be manipulating the variables within the Camera class, which we're going to create in a short while. So, add <kbd>const GLfloat YAW = -90.0f;</kbd>. Then add <kbd>const GLfloat PITCH = 0.0f</kbd> and <kbd>const GLfloat SPEED = 6.0f</kbd>. This is the value of speed that we’ve discovered works well with the camera and screen; you can manipulate it to make it slower and faster, as you desire. A higher value is faster and a lower value is slower. Next, add <kbd>const GLfloat SENSITIVITY = 0.25f</kbd>. This defines the sensitivity of our mouse movement. Again, the higher the value, the faster the mouse movement, and the lower the value, the slower the mouse movement. Now we're going to include <kbd>const GLfloat ZOOM</kbd>. The zoom value is the field of view, so a value of 45 degrees is very common. A higher value would basically mean a taller screen. It's essentially what the old games used, so you can try that. Check out the following code to understand the preceding description:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/>// Std. Includes<br/>#include &lt;vector&gt;<br/>// GL Includes<br/>#define GLEW_STATIC<br/>#include &lt;GL/glew.h&gt;<br/><br/>#include &lt;glm/glm.hpp&gt;<br/>#include &lt;glm/gtc/matrix_transform.hpp&gt;<br/><br/>// Defines several possible options for camera movement. Used as abstraction to stay away from window-system specific input methods<br/>enum Camera_Movement<br/>{<br/>    FORWARD,<br/>    BACKWARD,<br/>    LEFT,<br/>    RIGHT<br/>};<br/><br/>// Default camera values<br/>const GLfloat YAW        = -90.0f;<br/>const GLfloat PITCH      =  0.0f;<br/>const GLfloat SPEED      =  6.0f;<br/>const GLfloat SENSITIVTY =  0.25f;  <br/>const GLfloat ZOOM       =  45.0f;</pre>
<ol start="6">
<li>Next, we're going to create a Camera class and then type <kbd>public</kbd>. We're going to create a constructor with vectors first, and then a constructor with scalar values. Let’s begin by adding <kbd>Camera ()</kbd>, which will take the parameters shown in the following code:</li>
</ol>
<pre style="padding-left: 60px">//Constructor with vectors<br/>Camera( glm::vec3 position = glm::vec3( 0.0f, 0.0f, 0.0f ), glm::vec3 up = glm::vec3( 0.0f, 1.0f, 0.0f ), GLfloat yaw = YAW, GLfloat pitch = PITCH ) : front( glm::vec3( 0.0f, 0.0f, -1.0f ) ), movementSpeed( SPEED ), mouseSensitivity( SENSITIVTY ), zoom( ZOOM )</pre>
<ol start="7">
<li>Then, we're going to quickly implement our camera constructor, so add the following lines for the constructor:</li>
</ol>
<pre style="padding-left: 60px">{<br/>     this-&gt;position = position;<br/>     this-&gt;worldUp = up;<br/>     this-&gt;yaw = yaw;<br/>     this-&gt;pitch = pitch;<br/>     this-&gt;updateCameraVectors( );<br/>}</pre>
<ol start="8">
<li>Now that we're done with this particular constructor, we're going to add the constructor with scalar values to our code. Add the following lines to your code:</li>
</ol>
<pre style="padding-left: 60px">// Constructor with scalar values<br/>    Camera( GLfloat posX, GLfloat posY, GLfloat posZ, GLfloat upX, GLfloat upY, GLfloat upZ, GLfloat yaw, GLfloat pitch ) : front( glm::vec3( 0.0f, 0.0f, -1.0f ) ), movementSpeed( SPEED ), mouseSensitivity( SENSITIVTY ), zoom( ZOOM )<br/>    {<br/>        this-&gt;position = glm::vec3( posX, posY, posZ );<br/>        this-&gt;worldUp = glm::vec3( upX, upY, upZ );<br/>        this-&gt;yaw = yaw;<br/>        this-&gt;pitch = pitch;<br/>        this-&gt;updateCameraVectors( );<br/>    }</pre>
<ol start="9">
<li>Now we're going to implement a getter for getting the view matrix, because this'll return the view matrix that is calculated using Euler angles and the <kbd>lookAt</kbd> matrix. We're going to add <kbd>glm::mat4</kbd>, and we’re going to call it <kbd>GetViewMatrix( )</kbd>. We'll use this in our <kbd>main.cpp</kbd>, and we’ll add the following highlighted line of code to that class:</li>
</ol>
<pre style="padding-left: 60px">// Returns the view matrix calculated using Eular Angles and the LookAt Matrix<br/>    glm::mat4 GetViewMatrix( )<br/>    {<br/>        <strong>return glm::lookAt( this-&gt;position, this-&gt;position + this-&gt;front, this-&gt;up );</strong><br/>    }</pre>
<p style="padding-left: 60px">This is basically just stating where we want to look; we want to be looking in front, obviously; and we want to use the up vector so we've made it relative.</p>
<ol start="10">
<li>Now we're going to just process some keyboard input; using this keyboard input, we'll detect if we're going forward, backward, left, or right, and we'll move in that direction. So let’s add the following line of code:</li>
</ol>
<pre style="padding-left: 60px">void ProcessKeyboard( Camera_Movement direction, GLfloat deltaTime )     {</pre>
<p style="padding-left: 60px">This <kbd>Camera_Movement</kbd> is the <kbd>enum</kbd> that we created in the preceding steps. <kbd>GLfloat deltaTime</kbd> is the time between frames, so we can create frame-independent movement, because the last thing you want is to have 60 frames per second and suddenly dip to 30 frames, which is half the speed. You want it to be the same speed, obviously. It won't look as smooth, but you'll still get a consistent movement, and that is what is important.</p>
<ol start="11">
<li>Next, in the code file, we're going to add the following lines of code:</li>
</ol>
<pre style="padding-left: 60px">// Processes input received from any keyboard-like input system. Accepts input parameter in the form of camera defined ENUM (to abstract it from windowing systems)<br/>    void ProcessKeyboard( Camera_Movement direction, GLfloat deltaTime )<br/>    {<br/>        GLfloat velocity = this-&gt;movementSpeed * deltaTime;<br/><br/>        if ( direction == FORWARD )<br/>        {<br/>            this-&gt;position += this-&gt;front * velocity;<br/>        }<br/><br/>        if ( direction == BACKWARD )<br/>        {<br/>            this-&gt;position -= this-&gt;front * velocity;<br/>        }<br/><br/>        if ( direction == LEFT )<br/>        {<br/>            this-&gt;position -= this-&gt;right * velocity;<br/>        }<br/><br/>        if ( direction == RIGHT )<br/>        {<br/>            this-&gt;position += this-&gt;right * velocity;<br/>        }<br/>    }</pre>
<p style="padding-left: 60px">In the preceding lines of code, we added <kbd>GLfloat velocity</kbd> and assigned it the value of <kbd>movementSpeed * deltaTime</kbd>. So, let's say the <kbd>movementSpeed</kbd> is <kbd>5</kbd>, for example, and the <kbd>deltaTime</kbd> is <kbd>0.1</kbd>, so the <kbd>GLfloat velocity</kbd> would be <kbd>0.5</kbd>. Hence, if it's a higher delta time, it'll have a higher movement speed. If it's a lower delta time, it'll have a lower movement speed. This just keeps it all frame-rate independent. Next, we added <kbd>if</kbd> statements to check the direction in which the user is moving. If the user is moving in any particular direction, then the <kbd>position += this front * velocity</kbd>, where <kbd>velocity</kbd> is equal to the value that we've already calculated.</p>
<p style="padding-left: 60px">You might be wondering why we aren't using a switch statement or why we aren't using an <kbd>if else/if else</kbd> series. First, let's say you clicked the forward key and the left key, then you want to be able to move essentially in a northwest direction. Ignoring which way we're looking—so let's assume we're just looking north - you want to be able to move northwest. You don't want to have to press one key, then let go, then press another key. Likewise, if you're moving forward and you click backwards, you'll stop. You don't want to be having to release keys; this is the reason we're using separate <kbd>if</kbd> statements.</p>
<ol start="12">
<li>The next thing we'll do is process the mouse movement. This will process the input received from our mouse system, whether that's GLFW, SDL, or SFML, and it will use an offset value so it can adjust the x and y direction. So, we're going to add <kbd>void ProcessMouseMovement()</kbd> and pass <kbd>GLfloat xOffset</kbd> to it. This is essentially the difference between the mouse movements, because, otherwise, how do we know where we're moving to? We essentially need to think about the speed. Then add <kbd>GLfloat yOffset, GLboolean constrainPitch</kbd> to constrain the pitch and set that equal to true. Now we're going to calculate the offset, and we'll adjust that using our <kbd>mouseSensitivity</kbd>. We'll add the following lines of code:</li>
</ol>
<pre>       xOffset *= this-&gt;mouseSensitivity;<br/>       yOffset *= this-&gt;mouseSensitivity;<br/><br/>        this-&gt;yaw   += xOffset;<br/>        this-&gt;pitch += yOffset;</pre>
<ol start="13">
<li>Now, we're going to check if the pitch is constrained by using the if statement. We want to prevent the user from being able to go out of bounds, so that the screen doesn't get flipped if we move our mouse, or effectively the way we look, to the left and to the right; if we move to the left for too long, we'll loop back round. The same is true for the right direction (that is, anti-clockwise and clockwise. When you look up and down, you generally only want to be able to look up by about 90 degrees, which is roughly what your head can do, and then just look down by roughly 90 degrees to your feet, which is again approximately what your head can do. You don't want to be able to just keep looping back round, because you'll start getting all sorts of different problems, such as gimbal lock. But, in general, that's not the sort of movement that you have in games, because games are based on real life and the constraints of the human body. So we're going to check the pitch. If <kbd>pitch &gt; 89.0f</kbd>, then we'll assign the pitch as <kbd>89.0f</kbd>. If <kbd>pitch &lt; -89.0f</kbd>, we'll assign the pitch as <kbd>-89.0f</kbd>. Finally, we’ll update the camera vectors by adding <kbd>this-&gt;updateCameraVectors( );</kbd>. This will update the front, right, and up vectors using the Euler angles that we've defined here. Take a look at the following code to understand the preceding description:</li>
</ol>
<pre style="padding-left: 60px">// Processes input received from a mouse input system. Expects the offset value in both the x and y direction.<br/>    void ProcessMouseMovement( GLfloat xOffset, GLfloat yOffset, GLboolean constrainPitch = true )<br/>    {<br/>        xOffset *= this-&gt;mouseSensitivity;<br/>        yOffset *= this-&gt;mouseSensitivity;<br/><br/>        this-&gt;yaw   += xOffset;<br/>        this-&gt;pitch += yOffset;<br/><br/>        // Make sure that when pitch is out of bounds, screen doesn't get flipped<br/>        if ( constrainPitch )<br/>        {<br/>            if ( this-&gt;pitch &gt; 89.0f )<br/>            {<br/>                this-&gt;pitch = 89.0f;<br/>            }<br/>            if ( this-&gt;pitch &lt; -89.0f )<br/>            {<br/>                this-&gt;pitch = -89.0f;<br/>            }<br/>        }<br/><br/>        // Update Front, Right and Up Vectors using the updated Eular angles<br/>        this-&gt;updateCameraVectors( );<br/>    }</pre>
<ol start="14">
<li>Now that we've processed the mouse movement, we're going to process the mouse scroll, so we’ll add <kbd>void ProcessMouseScroll()</kbd>, and we'll pass <kbd>GLfloat yOffset</kbd> to that.
<p>You can use <kbd>xOffset</kbd> if you want to be able to detect the horizontal scroll. A lot of mice don't have horizontal scroll, but quite a few new mice, especially gaming mice and productivity mice, do. But, generally speaking, you probably only want to detect movement in the y axis--that is, vertical scroll. But you can easily extend this method, and this class in general, to suit your requirements.<br/>
Add the following <kbd>if</kbd> statements to your code:</p>
</li>
</ol>
<pre style="padding-left: 60px">if ( this-&gt;zoom &gt;= 1.0f &amp;&amp; this-&gt;zoom &lt;= 45.0f )<br/>        {
<br/>            this-&gt;zoom -= yOffset;<br/>        }<br/><br/>        if ( this-&gt;zoom &lt;= 1.0f )<br/>        {<br/>            this-&gt;zoom = 1.0f;<br/>        }<br/><br/>        if ( this-&gt;zoom &gt;= 45.0f )<br/>        {<br/>            this-&gt;zoom = 45.0f;<br/>        }</pre>
<p style="padding-left: 60px">Now, we're going to create a getter for getting the zoom, because the zoom variable will be private. Actually, all the variables are private in this class. We're only really creating the zoom getter simply because it's the only one we're using outside of this class for now. But if you need to use something such as the up vector, the yaw, the pitch, or any of the other variables that we're creating, feel free to create appropriate getters and setters. Therefore, we’ll next add following code:</p>
<pre style="padding-left: 60px">GLfloat GetZoom( )<br/>    {<br/>        return this-&gt;zoom;<br/>    }</pre>
<ol start="15">
<li>Now we're going to do define the camera attributes, so we’ll add following lines of code to our camera class:</li>
</ol>
<pre style="padding-left: 60px">private:<br/>    // Camera Attributes<br/>    glm::vec3 position;<br/>    glm::vec3 front;<br/>    glm::vec3 up;<br/>    glm::vec3 right;<br/>    glm::vec3 worldUp;</pre>
<div><p style="padding-left: 60px">Feel free to visit <a href="http://learnopengl.com">learnopengl.com</a> and <a href="http://open.gl">open.gl</a>, and check out those websites for more in-depth written information and some nice diagrams regarding all the different variables and the methods that we have discussed in this chapter.</p>
</div>
<ol start="16">
<li>Then we’ll add some Euler angles to our class:</li>
</ol>
<pre style="padding-left: 60px">// Eular Angles<br/>    GLfloat yaw;<br/>    GLfloat pitch;</pre>
<ol start="17">
<li>All of these parameters that we've been using are finally getting created. Next, we’ll add some camera options to our code:</li>
</ol>
<pre style="padding-left: 60px">// Camera options<br/>    GLfloat movementSpeed;<br/>    GLfloat mouseSensitivity;<br/>    GLfloat zoom;</pre>
<ol start="18">
<li>The last thing we need to add into this class is <kbd>void updateCameraVectors</kbd>, and, when we're updating the camera vectors, we need to calculate the new front vector, so we'll add <kbd>glm::vec3 front</kbd>, which is temporary storage for it. Then we'll add <kbd>front.x</kbd>, and we’ll assign a value of <kbd>cos ( glm::radians( this-&gt;yaw ))</kbd> multiplied by <kbd>cos( glm::radians( this-&gt;pitch ) )</kbd> to it. Again, the mathematical calculations here are obviously quite complex and quite in depth, so we would recommend you check out the aforementioned links. Take a look at the following code to understand what other elements will be added to <kbd>updateCameraVectors</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void updateCameraVectors( )<br/>    {<br/>        // Calculate the new Front vector<br/>        glm::vec3 front;<br/>        front.x = cos( glm::radians( this-&gt;yaw ) ) * cos( glm::radians( this-&gt;pitch ) );<br/>        front.y = sin( glm::radians( this-&gt;pitch ) );<br/>        front.z = sin( glm::radians( this-&gt;yaw ) ) * cos( glm::radians( this-&gt;pitch ) );<br/>        this-&gt;front = glm::normalize( front );<br/>        // Also re-calculate the Right and Up vector        this-&gt;right = glm::normalize( glm::cross( this-&gt;front, this-&gt;worldUp ) );  // Normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.<br/>        this-&gt;up = glm::normalize( glm::cross( this-&gt;right, this-&gt;front ) );<br/>    }</pre>
<p> With this last line of code, we have finally completed the <kbd>Camera</kbd> class. Please check out the <kbd>camera.h</kbd> file for the entire code. This file is present inside the <kbd>camera</kbd> folder in the <kbd>Getting started</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">  Making modifications to main.cpp</h1>
                
            
            
                
<p>Now that we have created our <kbd>Camera</kbd> class, let’s go back to our <kbd>main.cpp</kbd> and make some modifications to it, such as implementing multiple cubes on our screens, adding a camera class, and moving through the multiple objects. </p>
<p>In our <kbd>main.cpp</kbd>, we'll start implementing the input stuff that we've been doing. So, we're going to use the GLFW for our input system, but, again, feel free to check out the previous links for more information on the GLFW, SFML, and SDL input systems.</p>
<ol>
<li>We’ll begin with including our <kbd>Camera</kbd> class in our code. Add <kbd>#include Camera.h</kbd> at the start of the code,</li>
<li>Then, in the section where we define our screen dimensions, we’ll make the following modifications:</li>
</ol>
<pre style="padding-left: 60px">const GLuint WIDTH = 800, HEIGHT = 600;<br/>int SCREEN_WIDTH, SCREEN_HEIGHT;</pre>
<ol start="3">
<li>Now, let's just replace every <kbd>screenWidth</kbd> and <kbd>screenHeight</kbd> we’ve used with <kbd>SCREEN_WIDTH</kbd>, and <kbd>SCREEN_HEIGHT</kbd>.</li>
<li>As we’ll be using perspective projection, we need to get rid of all the orthographic projection code as we're not using that anymore.</li>
<li>Now, before we start with our <kbd>int main</kbd>, we’re going to create some function prototypes. Add the following lines of code to your <kbd>main.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">// Function prototypes<br/>void KeyCallback( GLFWwindow *window, int key, int scancode, int action, int mode );<br/>void ScrollCallback( GLFWwindow *window, double xOffset, double yOffset );<br/>void MouseCallback( GLFWwindow *window, double xPos, double yPos );<br/>void DoMovement( );</pre>
<p style="padding-left: 60px">In the preceding code, we first added <kbd>void KeyCallback( )</kbd>; this is where the framework-specific code starts. To that function we passed <kbd>GLFWwindow *window</kbd>, and then we needed to check what key was pressed, so we added <kbd>int key</kbd>, <kbd>scancode</kbd>, <kbd>action</kbd> and <kbd>mode</kbd>. We then added the rest of the functions. In the <kbd>MouseCallback( )</kbd>, we passed <kbd>double xPos</kbd> and <kbd>double yPos</kbd>. These are the x and y positions of our mouse in our window. We're actually going to hide the mouse cursor to provide a more immersive experience. Then, we added one final method prototype to the preceding code: <kbd>void DoMovement</kbd>. This method will be called in every single frame, and this'll move our camera. Even if we haven't made any movement, it'll still be called, but it won't obviously move our camera.</p>
<ol start="6">
<li>Now, we just need to initially set some values up for our camera, so we're going to add <kbd>Camera</kbd>, create a <kbd>camera ( )</kbd> object, and we’ll pass <kbd>glm::vec3 ( )</kbd> to it. To the <kbd>vec3( )</kbd>, we’ll pass <kbd>0.0f</kbd>, <kbd>0.0f</kbd>, <kbd>3.0f</kbd>. These are just the initial values. Next, we’ll add <kbd>GLfloat lastX</kbd>, which is the last position of the camera, initially. We'll make it equal to the center of the screen, so this is going to be our mouse movement. We'll add <kbd>WIDTH / 2.0</kbd> and <kbd>GLfloat lastY = WIDTH / 2.0f;</kbd>. Take a look at the following to understand this description:</li>
</ol>
<pre style="padding-left: 60px">// Camera<br/>Camera  camera(glm::vec3( 0.0f, 0.0f, 3.0f ) );<br/>GLfloat lastX = WIDTH / 2.0;<br/>GLfloat lastY = HEIGHT / 2.0;</pre>
<p style="padding-left: 60px">Below this will be a <kbd>bool</kbd> of keys, which will be an array of 1,024 different types of key. We’re going to add <kbd>bool firstMouse = true</kbd>, as we’re handling one type of mouse:</p>
<pre style="padding-left: 60px">bool keys[1024];<br/>bool firstMouse = true;</pre>
<p style="padding-left: 60px">Next, we will add <kbd>deltatime</kbd> and <kbd>lastframe</kbd>, which will be used in the code to determine the time between frames:</p>
<pre style="padding-left: 60px">GLfloat deltaTime = 0.0f;<br/>GLfloat lastFrame = 0.0f;</pre>
<ol start="7">
<li>Now, in our int main, after our <kbd>glfwMakeContextCurrent( window );</kbd> we are going to add <kbd>glfwSetKeyCallback( );</kbd> and to that we’ll provide <kbd>window</kbd>; we'll provide the method that we're using, which is <kbd>KeyCallback</kbd>; and then we'll duplicate this line of code three times and make following highlighted modifications to it:</li>
</ol>
<pre style="padding-left: 60px">// Set the required callback functions<br/>glfwSetKeyCallback( window, KeyCallback );<br/><strong>glfwSetCursorPosCallback( window, MouseCallback );</strong><br/><strong>glfwSetScrollCallback( window, ScrollCallback );</strong></pre>
<p style="padding-left: 60px">Here, we are calling the function prototypes that we have defined previously.</p>
<ol start="8">
<li>Next, we want to fix our mouse to the center of our screen, within the window itself, so we’ll add <kbd>glfwSetInputMode( )</kbd> and we’ll pass <kbd>window</kbd>to it. As the mode that we're changing is the cursor, we'll pass <kbd>GLFW_CURSOR</kbd> with a value of <kbd>GLFW_CURSOR_ DISABLED</kbd> to it, as we don't want the cursor to be totally disabled.</li>
</ol>
<pre style="padding-left: 60px">// Options, removes the mouse cursor for a more immersive experience     glfwSetInputMode( window, GLFW_CURSOR, GLFW_CURSOR_DISABLED );</pre>
<ol start="9">
<li>As we are going to render multiple cubes in this code, we'll create an array of vectors, which will contain the cubes' positions. These are just arbitrary positions, so you can change them later to experiment with those. Go to the <kbd>main.cpp</kbd> file in the <kbd>Camera</kbd> folder, and copy and paste the array of vectors <kbd>glm::vec3 cubePositions[]</kbd> to your code.<br/>
Next, we're going to move the projection code inside the while loop, because we're going to change the field of view using the mouse scroll, so we want to be able to update the projection every single frame if we're actually changing the field-of-view value. So, after we’ve activated our shader code and binded texture using texture units, add the projection code and make the following changes to it:</li>
</ol>
<pre style="padding-left: 60px">// Draw our first triangle<br/><br/>   ourShader.Use( );<br/><br/>   // Bind Textures using texture units<br/>   glActiveTexture( GL_TEXTURE0 );<br/>   glBindTexture( GL_TEXTURE_2D, texture );<br/>   glUniform1i( glGetUniformLocation( ourShader.Program, "ourTexture1" ), 0 );<br/><br/>   glm::mat4 projection;<br/>   <strong>projection = glm::perspective(camera.GetZoom( ), (GLfloat)SCREEN_WIDTH/(GLfloat)SCREEN_HEIGHT, 0.1f, 1000.0f);</strong></pre>
<ol start="10">
<li>After the start of the while loop, we'll set the frame time, so we’ll add <kbd>GLfloat currentFrame = glfwGetTime()</kbd>. Then we’ll add <kbd>deltaTime = currentFrame - lastFrame</kbd>. This is our way of detecting the time between the frames. If, let's say, our current frame is at time 100 and our last frame was at time 80, the time between the last frame and the current frame would be 20--though it'd normally be a second or millisecond. Then we’ll add <kbd>lastFrame = the currentFrame</kbd>, as the last frame will be the current frame when we restart this while loop on the next iteration, because we'll have a different frame at that particular moment. Refer to the following code to understand the description:</li>
</ol>
<pre style="padding-left: 60px">while( !glfwWindowShouldClose( window ) )<br/>    {
<br/>        // Set frame time        <br/>        GLfloat currentFrame = glfwGetTime( );<br/>        deltaTime = currentFrame - lastFrame;<br/>        lastFrame = currentFrame;  </pre>
<ol start="11">
<li>After we've handled all the events, we're actually going to handle the movement, so add <kbd>DoMovement()</kbd>.</li>
<li>Now we’ll go to the section in the code where we have defined the <kbd>view</kbd> and model matrix, and make the following modifications:</li>
</ol>
<pre style="padding-left: 60px">// Create camera transformation<br/>        glm::mat4 view;<br/>        view = camera.GetViewMatrix( );</pre>
<p style="padding-left: 60px">In the preceding code, you must have noticed that we got rid of model-matrix code, which is because we're going to put that inside a for loop that will iterate over our cube-position array, draw the objects in different locations, and use the model to generate sort of a random rotation.</p>
<ol start="13">
<li>Between binding the vertex array to the vertex-array object, and unbinding it, we're essentially going to add a for loop in which we're going to pass a parameter as <kbd>GLuint i = 0; i &lt; 10; i++</kbd>. It is recommended that you to try to make it dynamic, so you can add more cube positions and you can draw more cubes. That'd be another great task for you. We’ll add the following highlighted statements to the for loop. First of all, we're going to calculate the model matrix for each object, and then pass it to our shader before we start drawing:</li>
</ol>
<pre style="padding-left: 60px">for( GLuint i = 0; i &lt; 10; i++ )<br/>        {<br/>            <strong>// Calculate the model matrix for each object and pass it to shader before drawing</strong><br/><strong>           glm::mat4 model;</strong><br/><strong>            model = glm::translate( model, cubePositions[i] );</strong><br/><strong>            GLfloat angle = 20.0f * i;</strong><br/><strong>            model = glm::rotate(model, angle, glm::vec3( 1.0f, 0.3f, 0.5f ) );</strong><br/><strong>            glUniformMatrix4fv( modelLoc, 1, GL_FALSE, glm::value_ptr( model ) );</strong><br/><br/><strong>            glDrawArrays( GL_TRIANGLES, 0, 36 );</strong><br/>        }</pre>
<p style="padding-left: 60px">We used a value of <kbd>20.0</kbd> in the preceding code as it's just a calculated value. Try varying this value and see what happens. You might find a better value than that. We have cut and pasted the <kbd>glUniformMatrix4fv();</kbd> from the while loop. Now we are done with our while loop.</p>
<ol start="14">
<li>Now we can start to implement those function prototypes, which is the last thing to do before we can run the code and observe our output. After the end of while loop, we'll add <kbd>void DoMovement()</kbd>, which is going to handle our movement and call the appropriate keyboard method in our Camera class. So, this is not going to take in any parameters, but we will add some if statements. We want to use the <em>W, A, S, D</em> and arrow keys, so we’re going to pass the condition as <kbd>keys[GLFW_KEY_W] || keys[GLFW_KEY_UP]</kbd>. In the if statement, we’ll add <kbd>camera.ProcessKeyboard( FORWARD, deltaTime );</kbd> because we're moving forward, and we'll add <kbd>deltaTime</kbd>, which we've already calculated in our while loop. This is the code for moving forward. Similarly, we’ll add statements for all other directions; take a look at the following highlighted code:</li>
</ol>
<pre style="padding-left: 60px">// Moves/alters the camera positions based on user input<br/>void DoMovement( )<br/>{<br/>    // Camera controls<br/>    if( keys[GLFW_KEY_W] || keys[GLFW_KEY_UP] )<br/>    {<br/>        camera.ProcessKeyboard( FORWARD, deltaTime );<br/>    }<br/><br/>    <strong>if( keys[GLFW_KEY_S] || keys[GLFW_KEY_DOWN] )</strong><br/><strong>    {</strong><br/><strong>        camera.ProcessKeyboard( BACKWARD, deltaTime );</strong><br/><strong>    }</strong><br/><br/><strong>    if( keys[GLFW_KEY_A] || keys[GLFW_KEY_LEFT] )</strong><br/><strong>    {</strong><br/><strong>        camera.ProcessKeyboard( LEFT, deltaTime );</strong><br/><strong>    }</strong><br/><strong>    if( keys[GLFW_KEY_D] || keys[GLFW_KEY_RIGHT] )    </strong><br/><strong>    {</strong><br/><strong>        camera.ProcessKeyboard( RIGHT, deltaTime );</strong><br/><strong>    }</strong><br/><strong>}</strong></pre>
<ol start="15">
<li>Then, we're going to do a callback, so we'll add the following code:</li>
</ol>
<pre style="padding-left: 60px">// Is called whenever a key is pressed/released via GLFW<br/>void KeyCallback( GLFWwindow *window, int key, int scancode, int action, int mode )<br/>{<br/>    if( key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS )<br/>    {<br/>        glfwSetWindowShouldClose(window, GL_TRUE);<br/>    }<br/>    if ( key &gt;= 0 &amp;&amp; key &lt; 1024 )<br/>    {<br/>        if( action == GLFW_PRESS )<br/>        {<br/>            keys[key] = true;<br/>        }<br/>        else if( action == GLFW_RELEASE )<br/>        {<br/>            keys[key] = false;<br/>        }<br/>    }<br/>}</pre>
<ol start="16">
<li>Now we can add the <kbd>MouseCallback</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void MouseCallback( GLFWwindow *window, double xPos, double yPos )<br/>{<br/>    if( firstMouse )<br/>    {<br/>        lastX = xPos;<br/>        lastY = yPos;<br/>        firstMouse = false;<br/>    }<br/>    GLfloat xOffset = xPos - lastX;<br/>    GLfloat yOffset = lastY - yPos;  // Reversed since y-coordinates go from bottom to left<br/><br/>    lastX = xPos;<br/>    lastY = yPos;<br/><br/>    camera.ProcessMouseMovement( xOffset, yOffset );<br/>} </pre>
<ol start="17">
<li>Then we are going to add <kbd>void ScrollCallback()</kbd>, to which we will pass the following parameters: <kbd>GLFWwindow *window, double xOffset, double yOffset</kbd></li>
</ol>
<p style="padding-left: 60px">Inside that method we are going to add the following code:</p>
<pre style="padding-left: 60px">camera.ProcessMouseScroll( yOffset );</pre>
<p>Now we're ready to see if this works, so run it. Once it has been compiled error free, you’ll get to see the following output :</p>
<div><img class="aligncenter size-full wp-image-308 image-border" src="img/8d57175b-37ee-4583-a692-932065bfdf0c.png" style=""/></div>
<p>We've created our multiple cubes, and we can look around and move. We can use the <em>W</em>, <em>A</em>, <em>S</em>, and <em>D</em> keys and arrow keys to move around. So we can move not just forward and backward, but forward and right, forward and left, back and right, and back and left. What's great about this camera system is the forward is relative to the way we're looking. So, if we look at a particular cube, then press forward, it moves towards our cube. If we try to go through the cube, we'll go through and we’ll get to see the inverse of the textures. The reason we can go through it is simply because there's no collision detection.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned how to apply transformations such as rotation to our shape, and learned to draw a cube and apply texture to it. Then, we explored the concepts of projections, Perspective and Orthographic, and implemented those in our game world.</p>
<p>In the next chapter, we'll talk about lighting, its effects and sources of light that we have in OpenGL</p>


            

            
        
    </body></html>