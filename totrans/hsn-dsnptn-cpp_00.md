# 前言

当考虑这本书时，你们中的一些人可能会问：*又有一本关于 C++设计模式的书籍？为什么是现在，为什么是这个？关于设计模式的所有知识不是都已经* *被写出来了？*

写了关于*设计模式*的又一本书，有几个原因，但首先，这是一本非常典型的 C++书籍——这不是一本关于 C++中*设计模式*的书，而是一本关于在 C++中*设计模式*的书，这种强调使其与众不同。C++拥有传统面向对象语言的所有功能，因此所有经典面向对象设计模式，如工厂模式和策略模式，都可以在 C++中实现。本书涵盖了其中的一些。但是，当你利用其泛型编程能力时，C++的强大功能才得以实现。记住，设计模式是经常出现的设计挑战和普遍接受的解决方案——模式的两面同样重要。从逻辑上讲，当新的工具变得可用时，新的解决方案也成为可能。随着时间的推移，社区将一些解决方案确定为最有利的整体解决方案，从而产生了旧设计模式的新变体——相同的挑战，但不同的首选解决方案。但是，扩展功能也开辟了新的领域——有了我们手中的新工具，新的设计挑战也随之产生。

另一些人可能会期待找到经典书籍“*《设计模式：可复用面向对象软件元素》*”的新版本。但这“*不是那本书，我也不认为现在是出版这样一本书的好时机*”。“*四人帮*”的书籍是新颖的，甚至是革命性的，它将设计模式的语言引入了广泛的编程社区。这已经一劳永逸地完成了。它还建立了一个整洁的设计模式分类法，但这一部分并没有像我们想象的那么经久不衰：随着我们的模式词汇量的扩大，我们发现有些模式并不容易融入特定的类别。我们还扩展了设计模式的概念，超越了面向对象编程，并发现其中一些模式与面向对象的近亲非常相似，而另一些则是全新的、不同的。此外，在 C++和其他具有显著不同功能的语言中，解决相同需求的设计模式可能看起来完全不同。总的来说，原始的模式分类法虽然仍然有用，但现在有更多的例外而不是典型例子，模式景观变得过于分歧，以至于新的分类法似乎过于人为。也许随着时间的推移，当我们进一步发展这门艺术时，从对扩展模式景观的鸟瞰中可能会出现新的趋势，但这种情况尚未发生。

这本书的目标不那么雄心勃勃，但非常实用。在这本书中，我们专注于 C++至少对模式的两面都有重要贡献的设计模式。一方面，我们有像访问者（Visitor）这样的模式，C++的泛型编程能力允许有更好的解决方案。这种更好的解决方案是通过语言从 C++11 到 C++17 的演变中添加的新特性而实现的。另一方面，泛型编程仍然是编程（只是程序的执行发生在编译时）；编程需要设计，而设计有常见的挑战，这些挑战与传统编程的挑战并不完全不同。因此，许多传统模式在泛型编程中都有其双胞胎，或者至少是近亲，我们在这本书中主要关注这些模式。一个主要的例子是策略模式（Strategy pattern），在泛型编程社区中更广为人知的是它的别名，策略模式（Policy pattern）。此外，随着语言中添加了新特性，它可以提供解决新问题或旧问题的解决方案，这两种解决方案最终都发展成为设计模式。这是 C++协程的情况，它在最后一章中有所体现。

最后，像 C++这样复杂的语言必然会有一些独特的特性，这些特性往往会导致 C++特有的挑战，这些挑战有共同或**标准**的解决方案。虽然这些 C++特有的惯用用法不完全值得被称为**模式**，但本书也涵盖了这些惯用用法。

关于第二版的一些改动：首先，新增了一章关于并发模式的章节。所有示例都已更新，以使用 C++17 或 C++20，只要合理，但绝不为追求而使用。许多模式、惯用用法以及展示它们使用的示例都随着最近几年的发展进行了更新——这是 C++编程社区工作的结果。

所有这些话，这本书被写出来的主要有三个原因：

+   为了涵盖针对其他通用、**经典**设计模式的 C++特定解决方案。

+   展示在新的泛型编程领域中，当旧的设计挑战出现时，C++特定的模式变体。

+   为了使我们的模式与语言的演变保持同步。

# 这本书面向的对象

这本书旨在为想要从**社区智慧**中学习的 C++程序员提供帮助——从公认的优良解决方案到常见的设计问题。另一种说法是，这本书是程序员从他人错误中学习的一种方式。

这不是一本**学习**C++的书籍；目标读者主要是对工具和语言语法有相当了解的程序员，他们更感兴趣的是了解这些工具应该如何以及为什么应该被使用。然而，这本书对想要了解更多关于 C++的程序员来说也将非常有用，尤其是那些希望他们的学习能够通过具体和实际例子来指导的程序员（对于这样的程序员，我们建议同时手头备有一本 C++参考书）。最后，对于那些不仅想了解 C++17 或 C++20 中有什么新内容，还想了解所有这些新功能可以用来做什么的程序员，这本书也许也能提供一些启发。

# 本书涵盖的内容

*第一章*“继承和多态简介”，简要概述了 C++的面向对象特性。本章的目的不是作为 C++面向对象编程的参考，而是突出其对于后续章节重要性的方面。

*第二章*“类和函数模板”，概述了 C++的泛型编程功能——类模板、函数模板和 lambda 表达式。本章涵盖了模板实例化和特化，以及模板函数参数推导和重载解析，为后续章节中更复杂的模板使用做准备。

*第三章*“内存和所有权”，描述了在 C++中表达不同类型内存所有权的现代惯用法。这是一系列约定或惯用法——编译器不会强制执行这些规则，但如果程序员使用共享的惯用法词汇，他们将更容易理解彼此。

*第四章*“从简单到微妙地交换”，探讨了 C++中最基本的一个操作，即两个值的交换或交换操作。这一操作与其他在章节中讨论的 C++特性有着惊人的复杂交互。

*第五章*“全面了解 RAII”，详细探讨了 C++的一个基本概念，即资源管理，并介绍了可能是最受欢迎的 C++惯用法，即 RAII，这是 C++管理资源的标准方法。

*第六章*“理解类型擦除”，深入探讨了 C++中一种已经存在很长时间的技术，自从 C++11 引入以来，其受欢迎程度和重要性也在不断增长。类型擦除允许程序员编写不显式提及某些类型的抽象程序。

*第七章**，SFINAE、概念和重载解析管理*，讨论了 SFINAE——一种 C++惯用语，一方面对于 C++中模板的使用是必不可少的，而且“恰好”透明地使用，另一方面，在有意使用时，需要对 C++模板有非常深入和微妙的理解。

*第八章**，奇特重复的模板模式*，描述了一种*令人着迷的*基于模板的模式，它结合了面向对象编程的优点和模板的灵活性。本章解释了该模式，并教你如何正确地使用它来解决实际问题。最后，本章为你准备在后续章节中识别这种模式。

*第九章**，命名参数、方法链和构建者模式*，介绍了一种在 C++中调用函数的不寻常技术，使用命名参数而不是位置参数。这是我们在每个 C++程序中隐式使用的那些惯用语之一，但它的明确目的性使用需要一些思考。

*第十章**，局部缓冲区优化*，是本书中唯一纯粹以性能为导向的章节。性能和效率是影响语言本身每个设计决策的关键考虑因素——在标准被接受之前，没有一项特性不是从效率的角度进行审查的。为提高 C++程序的性能而使用的常见惯用语，设立一个章节是公平的。

*第十一章**，作用域保护*，介绍了一种几乎在 C++最新版本中无法辨认的旧 C++模式。本章教你如何轻松编写异常安全或更普遍的错误安全代码。

*第十二章**，友元工厂*，描述了另一种在现代 C++中找到新用途的旧模式。这种模式用于生成与模板相关的函数，例如每个由模板生成的类型的算术运算符。

*第十三章**，虚构造函数和工厂*，涵盖了应用于 C++的另一个经典面向对象编程模式，即工厂模式。在这个过程中，本章还展示了如何从 C++构造函数中获得多态行为的外观，尽管构造函数不能是虚的。

*第十四章**，模板方法模式和非常量惯用语*，描述了经典面向对象模式、模板和非常 C++中心的惯用语之间的有趣交叉。它们共同形成了一个模式，描述了在 C++中最佳使用虚函数的方法。

*第十五章**，基于策略的设计*，涵盖了 C++设计模式中的瑰宝之一，即策略模式（更常见的是策略模式），它在编译时应用，即作为一种泛型编程模式，而不是面向对象模式。

*第十六章**，适配器和装饰器*，讨论了两种非常广泛且密切相关的设计模式，它们适用于 C++。本章考虑了这些模式在面向对象设计以及泛型程序中的应用。

*第十七章**，访问者模式和多重分派*，通过永受欢迎的访问者模式结束我们的经典面向对象编程模式系列。本章解释了该模式本身，然后重点介绍了现代 C++如何使访问者模式的实现更加简单、健壮和错误率更低。

*第十八章**，并发模式*，是本书的新增内容。虽然 C++在 C++11 为我们提供“官方”工具之前就已经被用来编写并发程序，但广泛的特定问题解决方案使得识别常见模式变得困难。本章介绍了成为设计 C++并发软件基本构建块的模式。

# 要充分利用本书

要运行本书中的示例，您需要一个运行 Windows、Linux 或 macOS 的计算机（C++程序可以在像树莓派这样小的设备上构建）。您还需要一个支持 C++语言至 C++20 的现代 C++编译器，如 GCC、Clang、Visual Studio 或其他编译器。您还需要具备 GitHub 和 Git 的基本知识，以便克隆带有示例的项目。

# 下载示例代码文件

您可以从 GitHub（[`github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/`](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/)）下载本书的示例代码文件。如果代码有更新，它将在 GitHub 仓库中更新。

我们还有来自我们丰富的图书和视频目录的其他代码包，可在[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)找到。查看它们！

# 使用的约定

本书使用了多种文本约定。

`文本中的代码`: 表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 昵称。以下是一个示例：“`insert()`函数的实现必须将记录插入存储和索引中，别无他法。”

代码块应如下设置：

```cpp
class Database {
  class Storage { ... };    // Disk storage Storage S;
  class Index { ... };    // Memory index Index I;
  public:
  void insert(const Record& r);
  ...
};
```

任何命令行输入或输出都应如下编写：

```cpp
Benchmark                              Time
-------------------------------------------
BM_delete_explicit                  4.54 ns
BM_delete_type_erased               13.4 ns
BM_delete_type_erased_fast          12.7 ns
BM_delete_template                  4.56 ns
```

小贴士或重要注意事项

看起来像这样。

# 联系我们

我们读者的反馈总是受欢迎的。

**一般反馈**：如果您对本书的任何方面有任何疑问，请通过电子邮件与我们联系 customercare@packtpub.com，并在邮件主题中提及书名。

**勘误表**：尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果您在本书中发现错误，我们将不胜感激，如果您能向我们报告，我们将不胜感激。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)并填写表格。

**盗版**：如果您在互联网上以任何形式发现我们作品的非法副本，我们将不胜感激，如果您能提供位置地址或网站名称，我们将不胜感激。请通过 copyright@packt.com 与我们联系，并提供材料的链接。

**如果您有兴趣成为作者**：如果您在某个主题上具有专业知识，并且您有兴趣撰写或为本书做出贡献，请访问[authors.packtpub.com](http://authors.packtpub.com)。

# 分享您的想法

一旦您阅读了《动手实践 C++设计模式（第 2 版）》，我们很乐意听听您的想法！请[点击此处直接访问亚马逊评论页面](https://packt.link/r/1-804-61155-7)并分享您的反馈。

您的评论对我们和科技社区非常重要，并将帮助我们确保我们提供高质量的内容。

# 下载本书的免费 PDF 副本

感谢您购买本书！

您喜欢在路上阅读，但无法携带您的印刷书籍到处走？

您的电子书购买是否与您选择的设备不兼容？

别担心，现在，随着每本 Packt 书籍，您都可以免费获得该书的 DRM 免费 PDF 版本。

在任何地方、任何设备上阅读。直接从您最喜欢的技术书籍中搜索、复制和粘贴代码到您的应用程序中。

优惠远不止于此，您还可以获得独家折扣、时事通讯和每日免费内容的每日电子邮件。

按照以下简单步骤获取这些好处：

1.  扫描下面的二维码或访问以下链接

![](img/B19262_QR_Free_PDF.jpg)

https://packt.link/free-ebook/9781804611555

1.  提交您的购买证明

1.  就这样！我们将直接将免费 PDF 和其他好处发送到您的电子邮件。

# 第一部分：C++特性和概念入门

本部分介绍了 C++面向对象编程、泛型编程以及一些其他高级语言工具的特性，这些工具对于您理解本书的其余部分是必要的。我们还讨论了语言强加的一些更令人烦恼的限制：我们在后续章节中展示的许多模式只是对这些限制的普遍认可解决方案。这并不是对任何特性的完整指南，而是帮助本书作为一个面向程序员的实战指南更加自包含。本部分包含以下章节：

+   *第一章*, *继承与多态简介*

+   *第二章*, *类与函数模板*

+   *第三章*, *内存与所有权*
