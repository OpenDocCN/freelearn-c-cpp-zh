- en: '*Chapter 10*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*'
- en: Learning
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引言
- en: When you started doing this stuff, whether "this stuff" is writing iPhone apps,
    UNIX minicomputer software, or whatever future programming you meals-in-pill-form
    types get up to, you didn't know how to do it; you had to learn. Maybe you took
    a training course, or a computer science degree. Perhaps you read a book or two.
    However you did it, you started with no information and ended with… some.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始做这些事情时，无论是写iPhone应用、UNIX迷你计算机软件还是未来编程的任何形式，你不知道如何做；你必须学习。也许你参加了一个培训课程，或者获得了计算机科学学位。也许你读了一两本书。无论如何，你开始时一无所知，最后……有一些知识。
- en: 'It doesn''t stop there. As Lewis Carroll said:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这还没有结束。正如刘易斯·卡罗尔所说：
- en: '*It takes all the running you can do, to keep in the same place.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*你需要尽你所能奔跑，才能保持在原地。*'
- en: He was talking about the Red Queen's race, but I'm talking about learning and
    personal development. If you stopped when you had read that first book, you might
    have been *OK* as beginner programmers go, but if the woman next to you in the
    library read another book, then she would have been a step ahead.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 他是在谈论红后赛跑，但我在谈论学习和个人发展。如果你在读完第一本书后就停止了，你可能作为初学者程序员来说是“OK”的，但如果图书馆旁边的那位女士又读了一本书，那么她就会领先一步。
- en: We live in what is often called a knowledge economy. Francis Bacon said, "knowledge
    is power." If you're not learning, and improving yourself based on the things
    you learn, then you're falling behind the people who are. Your education is like
    the race of the Red Queen, constantly running to keep in the same place.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个经常被称为知识经济的时代。弗朗西斯·培根说，“知识就是力量”。如果你不学习，不根据你所学的东西来提升自己，那么你将落后于那些人。你的教育就像红后的赛跑，不断地奔跑以保持在原地。
- en: Do as Much as You Can
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尽可能多做
- en: There's no such thing as too much learning (though the real problem of "not
    enough working" can sometimes be found in proximity to a *lot* of learning). Not
    all education comes through formal settings such as training or university courses.
    (Indeed, much material from university-level computer science programs is now
    available for free through schemes such as iTunes U and Coursera. That can make
    for some interesting lunchtime reading, but I find I learn better when I've got
    the structure of a taught course and the pressure of a submission deadline. That
    said, you're not me and you might benefit from a more relaxed learning environment.)
    Reading a book, magazine article, or blog post in your lunch break can be very
    helpful, as can going to birds-of-a-feather developer meetings.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 没有所谓的学习过多（尽管“工作不足”的真正问题有时会在大量学习附近被发现）。并非所有的教育都来自正式的设置，如培训或大学课程。（实际上，许多大学计算机科学课程的材料现在可以通过iTunes
    U和Coursera等计划免费获得。这可以成为一些有趣的午餐阅读，但我发现当我有一个教授课程的框架和提交截止日期的压力时，我学得更好。话虽如此，你不是我，你可能从更轻松的学习环境中受益。）在午餐时间阅读一本书、杂志文章或博客文章可能会有很大帮助，参加鸟类的开发者会议也是如此。
- en: Bigger items such as training courses and conferences obviously involve a larger
    time commitment. There is, obviously, such a thing as "not enough working," and
    that's a balance you'll need to address. If you're self-employed, then you need
    to balance the opportunity cost (How much work will you be turning down by attending
    the course?) and financial cost against the benefits (How much better will you
    be after taking the course? How much extra work will you be able to get? What
    good contacts will you meet at the conference?).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 像培训课程和会议这样的大项目显然需要更大的时间投入。显然，有“工作不足”这样的事情，这是你需要解决的问题。如果你是自雇的，那么你需要平衡机会成本（通过参加课程，你将放弃多少工作？）和财务成本与收益（通过参加课程，你会变得多好？你将能够完成多少额外的工作？你将在会议上遇到哪些有价值的联系人？）。
- en: Of course, if you're employed, this decision may be made for you by your manager.
    You can help the decision along if you know how the training course fits with
    the company's direction… But I'll leave that to the chapters 12 and 13 Business
    on and Teamwork respectively.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你有工作，这个决定可能是由你的经理为你做出的。如果你知道培训课程如何与公司的方向相匹配，你可以帮助这个决定……但我将把这个留给第12章和第13章关于商业和团队合作的章节。
- en: Don't Stick to Your Own Discipline
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要局限于自己的学科
- en: 'Every field has its champions and superheroes: the people with tens of thousands
    of followers, whose blog posts are always read and quoted and who speak at all
    the conferences. People look to these champions to analyze and direct the way
    their community works. Often, the leaders in one field will be contrasted with
    "them," the leaders in a different field: that iPhone programmer is one of "us,"
    and the Android programmer giving a talk in the other room is talking to "them."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个领域都有其拥护者和超级英雄：那些有成千上万名追随者的人，他们的博客文章总是被阅读和引用，并在所有会议上发言。人们会向这些拥护者寻求分析和建议，以指导他们的社区如何运作。通常，一个领域的领导者会被与“他们”，即另一个领域的领导者进行对比：那个在iPhone上编程的人是“我们”中的一员，而在另一个房间里发表演讲的Android程序员是在与“他们”对话。
- en: 'This definition of "us" and "them" is meaningless. It needs to be, in order
    to remain fluid enough that a new "them" can always be found. Looking through
    my little corner of history, I can see a few distinctions that have come and gone
    over time: Cocoa versus Carbon; CodeWarrior versus Project Builder; Mach-O versus
    CFM; iPhone versus Android; Windows versus Mac; UNIX versus VMS; BSD versus System
    V; SuSE versus Red Hat; RPM versus dpkg; KDE versus GNOME; Java versus Objective-C;
    Browser versus native; BitKeeper versus Monotone; Dots versus brackets.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“我们”和“他们”的定义毫无意义。它需要保持足够的流动性，以便总能找到新的“他们”。回顾我的历史小角落，我可以看到一些随着时间的推移而来又去的区别：Cocoa与Carbon；CodeWarrior与Project
    Builder；Mach-O与CFM；iPhone与Android；Windows与Mac；UNIX与VMS；BSD与System V；SuSE与Red Hat；RPM与dpkg；KDE与GNOME；Java与Objective-C；浏览器与本地；点与括号。
- en: Sometimes, it takes an idea from a different field to give you a fresh perspective
    on your own work. As an example, I've found lots of new ideas on writing object-oriented
    code by listening to people in the functional programming community. You might
    find that the converse it true, or that you can find new ways to write Java code
    by listening to some C# programmers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，需要从不同领域的一个想法来给你自己工作带来新的视角。例如，我发现通过倾听函数式编程社区的人，我得到了很多关于编写面向对象代码的新想法。你可能会发现相反的情况是真实的，或者通过倾听一些C#程序员，你可能会找到编写Java代码的新方法。
- en: You could even find that leaving the programmers behind altogether for a bit
    and doing some learning in another field inspires you – or at least lets you relax
    and come back to the coding afresh later. The point is that, if you focus on your
    narrow discipline to the exclusion of all others, you'll end up excluding a lot
    of clever people and ideas from your experience.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可能会发现，暂时放下程序员的工作，去其他领域学习一段时间会激发你的灵感——或者至少让你放松，之后以全新的状态回到编码。关键是，如果你只关注自己的狭窄学科，而排除所有其他学科，你最终会排除掉很多聪明的人和想法。
- en: Put it into Practice
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将其付诸实践
- en: At various points in history, I've learned a collection of languages, of the
    inter-human and computer programming varieties. The only ones I can remember anything
    about are the ones I use all the time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在历史的各个阶段，我学过各种语言，包括人际和计算机编程语言。我唯一记得的只是那些我经常使用的。
- en: 'I expect the same''s true for you. The reason I expect this is not that I believe
    everyone''s like me, but that there''s basis for it in theory. The **Kolb learning
    cycle**—[http://www.businessballs.com/kolblearningstyles.htm](http://www.businessballs.com/kolblearningstyles.htm)
    says that there are four processes that form the practice of learning:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计这对你来说也是一样的。我之所以预计这一点，并不是因为我相信每个人都像我一样，而是因为这在理论上有依据。**科尔布学习周期**——[http://www.businessballs.com/kolblearningstyles.htm](http://www.businessballs.com/kolblearningstyles.htm)表明，有四个过程构成了学习的实践：
- en: '**Concrete Experience**: Actually doing a thing.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体经验**：实际上做某件事。'
- en: '**Reflective Observation**: Analyzing how you (or someone else) did a thing.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反思观察**：分析你（或其他人）是如何做某件事的。'
- en: '**Abstract Conceptualization**: Building a model of how things should be done.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象概念化**：构建一个模型，说明事情应该如何做。'
- en: '**Active Experimentation**: Just playing with the plasticine and seeing what
    comes out.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**积极实验**：只是玩玩橡皮泥，看看会出来什么。'
- en: 'Not everybody goes through all of the items in the cycle, but most people start
    out somewhere and progress through at least a couple of the points, probably in
    the order presented (acknowledging that, as a cycle, it should be, well, cyclic).
    Therefore, almost everyone who learns something goes through either an experimentation
    or building experience: it''s very hard to learn something without trying it out.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个人都经历过这个循环中的所有项目，但大多数人都是从某个地方开始的，并至少通过几个点进行进步，可能按照展示的顺序（承认作为一个循环，它应该是循环的）。因此，几乎每个学到东西的人都会经历实验或构建经验：不尝试很难学到东西。
- en: Perhaps more importantly, it's hard to adapt what you've learned to fit everything
    else you do if you don't try it out. An idea on its own doesn't really do anything
    useful; when it's put into practice, it becomes combined with other ideas and
    techniques and adds something valuable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不尝试，很难将你所学的知识适应到你所做的其他事情中。一个想法本身并不能真正做任何事情；当它付诸实践时，它就会与其他想法和技术相结合，增加一些有价值的东西。
- en: Collaborate and Share what you Learn
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作并分享你所学的知识
- en: There are numerous benefits to sharing the things that you learn. The first
    is that everybody you share with will have had different experiences and can tell
    you how what you've learned applies (or doesn't) to their context. That insight
    can give you a more complete picture of what you learned, especially of where
    it might be limited. Conference talks and books are often delivered with a spin
    on being persuasive—not because the author is being disingenuous, but because
    the material will be more successful if you go away wanting to apply what you've
    learned.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 分享你所学的东西有很多好处。首先，你分享给每个人的经历都不同，他们可以告诉你你所学的知识如何（或不如何）适用于他们的情境。这种洞察力可以给你一个更全面的了解你所学的知识，特别是它可能存在的局限性。会议演讲和书籍往往带有一种说服性的倾向——并不是因为作者在说谎，而是因为如果你离开后想要应用你所学的知识，材料会更有成功的机会。
- en: Listening to other people who've found that what you want to do does (or doesn't)
    work in particular situations, then, can give you a more complete picture of a
    concept and its applications than just relying on the first source you discovered.
    In return, you'll probably tell the person you're talking to about *your* experiences
    and problems, so you both get to learn.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 听取那些在你想要做的事情在特定情况下是否有效（或无效）的人的意见，可以让你对某个概念及其应用有一个比仅仅依赖你最初发现的第一个来源更全面的了解。作为回报，你可能会向你交谈的人讲述你自己的经验和问题，这样你们双方都能学到东西。
- en: That's the real reason I'm keen on shared learning—everyone benefits. That includes
    the teacher, if you're collaborating in a formal learning environment such as
    a training course or a class. Even if you've got a lot less experience than the
    teacher, you'll have unique insight and ideas that are more useful out in the
    open than being kept quiet.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我热衷于共享学习的原因——每个人都受益。这包括如果你在一个正式的学习环境中，如培训课程或班级中合作，老师也会受益。即使你的经验比老师少得多，你也会有一些独特的见解和想法，这些见解和想法在公开场合比保持沉默更有用。
- en: Publications such as *Communications of the ACM* frequently cover problems associated
    with teaching computing. Indeed, in the issue that was current at the time of
    writing, **two articles**—[http://cacm.acm.org/magazines/2012/11/156579-learning-to-teach-computer-science/fulltext
    **articles**—http://cacm.acm.org/blogs/blog-cacm/156531-why-isnt-there-more-computer-science-in-us-high-schools/fulltext](http://cacm.acm.org/magazines/2012/11/156579-learning-to-teach-computer-science/fulltext
    articles—http://cacm.acm.org/blogs/blog-cacm/156531-why-isnt-there-more-computer-science-in-us-high-schools/fulltext)
    discuss a shortage of computer science teaching. I believe that to address such
    problems, we need to get feedback not from experts (who managed to make it through
    the initial learning phase – no matter how shoddy the resources available) but
    from neophytes. We need to get more feedback on what's currently making it hard
    for beginners to make progress, if we're to scale the industry and allow new colleagues
    to quickly get to the point of doing better than we do.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *Communications of the ACM* 这样的出版物经常涵盖与教学计算相关的问题。确实，在撰写时的当前期号中，**两篇文章**—[http://cacm.acm.org/magazines/2012/11/156579-learning-to-teach-computer-science/fulltext
    **articles**—http://cacm.acm.org/blogs/blog-cacm/156531-why-isnt-there-more-computer-science-in-us-high-schools/fulltext](http://cacm.acm.org/magazines/2012/11/156579-learning-to-teach-computer-science/fulltext
    articles—http://cacm.acm.org/blogs/blog-cacm/156531-why-isnt-there-more-computer-science-in-us-high-schools/fulltext)
    讨论了计算机科学教学的短缺。我相信要解决这些问题，我们需要从新手而不是专家那里获得反馈（专家们设法通过了初始学习阶段——无论可用的资源多么糟糕）。我们需要更多地了解目前是什么让初学者难以取得进步，如果我们想要扩大行业规模，让新同事能够快速达到比我们做得更好的水平。
- en: Of course, listening to newbies will work best if the newbies are talking to
    us; specifically, telling us what's going well and what's going wrong. A great
    way to encourage that is to lead by example. Unfortunately, it doesn't seem like
    this is popular. In the world of Objective-C programming, two great aggregators
    of blog content are **the Cocoa Literature List**—[http://cocoalit.com](http://cocoalit.com)
    and **iOS Dev Weekly**—[http://iosdevweekly.com/issues/](http://iosdevweekly.com/issues/).
    Maybe I'm just getting jaded, but it seems like a lot of the content on both of
    those sites comprises tutorials and guides. These either rehash topics covered
    in the first-party documentation or demonstrate some wrapper class the author
    has created without going into much depth on the tribulations of getting there.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果新手在和我们交谈，那么倾听新手会是最有效的；具体来说，告诉我们在哪些方面做得好，哪些方面出了问题。鼓励这种做法的一个好方法是以身作则。不幸的是，这似乎并不受欢迎。在
    Objective-C 编程的世界里，两个优秀的博客内容聚合器是 **Cocoa 文献列表**—[http://cocoalit.com](http://cocoalit.com)
    和 **iOS Dev Weekly**—[http://iosdevweekly.com/issues/](http://iosdevweekly.com/issues/)。也许我只是变得过于挑剔，但似乎这两个网站上的大部分内容都是教程和指南。这些内容要么重复了第一方文档中涵盖的主题，要么展示了作者创建的一些包装类，而没有深入探讨达到那里的艰辛。
- en: What we really need to understand, from neophytes to experienced developers
    alike, is actually closer to the content of **Stack Overflow**—[http://www.stackoverflow.com](http://www.stackoverflow.com)
    than the content of the blogosphere. If lots of inexperienced programmers are
    having trouble working out how two objects communicate (and *plenty do*—[http://stackoverflow.com/questions/6494055/set-object-in-another-class](http://stackoverflow.com/questions/6494055/set-object-in-another-class)),
    then maybe OOP isn't an appropriate paradigm for people new to programming; or
    perhaps the way that it's taught needs changing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要理解的是，无论是新手还是经验丰富的开发者，实际上更接近于 **Stack Overflow**—[http://www.stackoverflow.com](http://www.stackoverflow.com)
    的内容，而不是博客圈的内容。如果许多缺乏经验的程序员在解决如何让两个对象进行通信（而且确实有很多——[http://stackoverflow.com/questions/6494055/set-object-in-another-class](http://stackoverflow.com/questions/6494055/set-object-in-another-class)）的问题上有困难，那么也许面向对象编程（OOP）不是适合编程新手的范式；或者也许需要改变其教学方法。
- en: So, this is a bit of a request for people who want to improve the field of programming
    to mine Stack Overflow and related sites to find out what the common problems
    are—trying to decide the experience level of any individual user can be difficult
    so organizing problems into "newbie problems" versus "expert problems" would be
    difficult. It's also a request for people who are having trouble to post more
    Stack Overflow questions. The reasons?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个对那些想要提升编程领域的人的请求，让他们挖掘 Stack Overflow 和相关网站，以了解常见的问题——试图决定任何用户的经验水平可能会很困难，所以将问题组织成“新手问题”与“专家问题”将会很困难。这也是对那些在
    Stack Overflow 上发帖有困难的人的请求。原因是什么？
- en: Usually, in the process of crafting a good question, you end up working out
    what the answer is anyway. The effort isn't wasted on Stack Overflow; you can
    answer your own question when you post it, then everyone can see the problem and
    how you solved it.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，在构思一个好问题的过程中，你最终也会弄清楚答案是什么。这种努力并没有浪费在Stack Overflow上；你可以在发布问题时回答自己的问题，然后每个人都可以看到问题和解决方案。
- en: The reputation system (to a first approximation) rewards good questions and
    answers, so the chances that you'll get a useful answer to the question are high.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声望系统（第一次近似）奖励好的问题和答案，所以你得到有用答案的机会很高。
- en: Such questions and answers can then be mined as discussed above.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如上所述，可以挖掘这样的问题和答案。
- en: 'There are downsides, of course:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有缺点：
- en: Duplicate questions cannot easily be measured, because they're usually closed,
    and often deleted. Or people will find existing questions that cover the same
    ground (as they're supposed to, within the "rules") and not ask their duplicate.
    The voting system and view count have to be used as proxies to the "popularity"
    of a question; an inexact system.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复的问题不容易衡量，因为它们通常会被关闭，并且经常被删除。或者人们会发现现有的问题覆盖了相同的内容（按照“规则”应该是这样），因此不会提出重复的问题。投票系统和查看次数必须用作问题“流行度”的代理；这是一个不精确的系统。
- en: The voting system tends to reward received dogma over novel ideas or technical
    accuracy; upvoted answers are "popular," which is not the same as being "correct."
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票系统往往奖励陈词滥调而不是新颖的想法或技术准确性；被点赞的答案是“受欢迎的”，但这并不意味着“正确”。
- en: A better system for teaching programming would base its content on the total
    collection of all feedback received by instructors at programming classes ever.
    But we're unlikely to get that. In the meantime, Stack Overflow's pretty good.
    What I'm saying is that you shouldn't just share what you learn, you should share
    what you're stuck on too.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的编程教学系统应该基于所有编程课程中教师收到的所有反馈的总和。但我们不太可能得到这个。与此同时，Stack Overflow相当不错。我的意思是，你不应该只分享你学到的知识，还应该分享你遇到的难题。
- en: Opportunities to Learn
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习机会
- en: So, your training budgets used up, the conference you like was last month and
    won't be around for another year; is that it? When else are you going to get a
    chance to get yourself into the learning frame of mind?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你的培训预算已经用完，你喜欢的会议在上个月举行，而且一年内不会再有；就这样吗？你什么时候还能有机会让自己进入学习状态？
- en: '*All the time*. Here are a couple of examples of how I squeeze a little extra
    study into life:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*一直如此*。以下是我如何挤时间进行额外学习的一些例子：'
- en: I drive about an hour each way on my commute. That's two podcast episodes per
    day, ten per week.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我每天通勤大约一个小时。这意味着每天有两个播客剧集，每周十个。
- en: Once a week, my developer team has "code club," an hour-long meeting in which
    one member makes a presentation or leads a discussion. Everybody else is invited
    to ask questions or share their experiences.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周一次，我的开发团队有“代码俱乐部”，这是一个小时的会议，其中一位成员做演示或引导讨论。其他所有人被邀请提问或分享他们的经验。
- en: There's a little time at lunch to read some articles.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 午餐时间可以读一些文章。
- en: I go to one or two local developer groups a month.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我每个月参加一到两个当地的开发者小组。
- en: You don't necessarily need to deep-dive into some information in order to make
    use of it. Just knowing that it's out there and that you can find it again is
    enough to give it a space in your mental pigeonhole. When you've got a related
    problem in the future, you'll likely remember that you read about it in *this*
    article or made *that* note in Evernote. Then, you can go back and find the actual
    data you need.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定需要深入研究某些信息才能使用它。仅仅知道它存在，并且你可以再次找到它，就足以在你的思维抽屉中给它留一个位置。当你将来遇到相关问题时，你可能会记得你在*这篇文章*中读到过它，或者在Evernote中做了*那个*笔记。然后，你可以回去找到你需要的数据。
- en: Of course, conferences and training courses *are* great places to learn a lot.
    One reason is that you can (to some extent, anyway) put aside everything else
    and concentrate on what's being delivered.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，会议和培训课程确实是学习大量知识的好地方。一个原因是你可以（在某种程度上）放下其他一切，专注于正在提供的内容。
- en: Ranty aside
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 虽然有些抱怨
- en: One of the saddest things to see at a conference is someone who's doing some
    work on their laptop instead of focusing on the session. They're missing out—not
    just on the content, but on the shared experience to talk about it with other
    delegates during the next break. It's not a good environment to work in because
    of the noise and the projected images, and they don't get anything out of the
    sessions either.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在会议上看到的最令人难过的事情之一是有人在笔记本电脑上做工作，而不是专注于会议。他们错过了——不仅内容，还有与其他代表在下一个休息期间讨论的共享经验。由于噪音和投影图像，这不是一个良好的工作环境，而且他们也没有从会议中获得任何东西。
- en: Rediscovering Lost Knowledge
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新发现失落的知识
- en: You might think that, with software being such a fast-moving field, everything
    we're doing now is based on everything we were doing last year, with induction
    proving that there's a continuous unbroken history linking current practice to
    the "ENIAC girls" and Colossus wrens of the 1940s. In fact, the truth is pretty
    much the exact opposite of that; practices seen as out of date are just as likely
    to be rejected and forgotten as to be synthesized into modern practice.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，随着软件领域的快速发展，我们现在所做的一切都是基于去年所做的一切，归纳证明有一个连续不断的历史将当前实践与20世纪40年代的“ENIAC女孩”和巨像鸟联系起来。事实上，真相几乎正好相反；被视为过时的做法，与被综合到现代实践中的做法一样，可能会被拒绝和遗忘。
- en: As an example, I present my own experience with programming. I was born into
    the microcomputer revolution, and the first generation of home computers. Programming
    taught on these machines was based on either the BASIC language of the 1960s or
    using assemblers. The advances made by structured programming, object-oriented
    programming, procedural programming, and functional programming were all either
    ignored or thought of as advanced topics inappropriate to microprogramming. It
    wasn't until much later that I was introduced to "new" concepts such as 1973's
    C and had to come to grips with any form of code organization or modularity.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以编程为例，我分享自己的经历。我出生在微型计算机革命时期，第一代家用电脑。在这些机器上教授的编程基于20世纪60年代的BASIC语言或使用汇编器。结构化编程、面向对象编程、过程编程和函数式编程的进步都被忽视或被认为是不适合微编程的高级主题。直到很久以后，我才接触到“新”的概念，比如1973年的C语言，并不得不掌握任何形式的代码组织或模块化。
- en: Armed with a history book, or a collection of contemporary literature, on computer
    programming, it's easy to see that I'm not alone in ignoring or losing earlier
    results in the discipline. After all, what is agile programming's "self-organizing
    team" but a reinvention of Weinberg's **adaptive programming**—[http://dl.acm.org/citation.cfm?id=61465](http://dl.acm.org/citation.cfm?id=61465)?
    Is there a clear lineage, or has the concept been reinvented? Is the "new" field
    of UX really so different from the "human-relations aspects" of Boehm's **software
    engineering economics**—[https://dl.acm.org/citation.cfm?id=944370](https://dl.acm.org/citation.cfm?id=944370)?
    As described in *Chapter 8, Documentation*, many developers no longer use UML;
    how long until UML is invented to replace it?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一本关于计算机编程的历史书或当代文献集，很容易看出，我不是唯一一个忽视或失去学科早期成果的人。毕竟，敏捷编程的“自我组织团队”不就是对Weinberg的**适应性编程**的再发明——[http://dl.acm.org/citation.cfm?id=61465](http://dl.acm.org/citation.cfm?id=61465)？是否存在清晰的血统，或者这个概念已经被重新发明？用户体验的“新”领域真的与Boehm的**软件工程经济学**的“人际关系方面”——[https://dl.acm.org/citation.cfm?id=944370](https://dl.acm.org/citation.cfm?id=944370)有什么不同？正如*第8章，文档*中所述，许多开发者不再使用UML；多久之后UML会被发明来取代它？
- en: The Teaching Of Software Creation
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件创作的教学
- en: My mitigation for the rediscovery problem outlined above could be that you undertake
    the heroic effort of discovering what's out there from nearly 70 years of literature,
    identify the relevant parts, and synthesize a view on software creation from that.
    That would be crazy. But in the short term, that's probably the only route available.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述重新发现问题的缓解，可能是你付出巨大的努力，从近70年的文献中找出什么，识别相关部分，并从那里综合出一个关于软件创作的观点。那将是疯狂的。但在短期内，这可能是一条唯一的途径。
- en: Like many people, I learned programming by experimentation, and by studying
    books and magazines of varying quality. This means that, like many programmers,
    my formative experiences were not guided (or tainted, depending on your position)
    by a consistent theory of the pedagogy of programming. Indeed, I don't think that
    one exists. Programming is taught differently by professional trainers and by
    university departments; indeed, it's taught differently by different departments
    in the same university (as I discovered, when I was teaching it in one of them).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 和许多人一样，我是通过实验、阅读不同质量的书籍和杂志来学习编程的。这意味着，和许多程序员一样，我的形成性经验并没有受到一致的编程教学法理论的指导（或者根据你的立场，是被污染的）；实际上，我认为这样的理论并不存在。编程教学由专业培训师和大学系所进行，确实，同一所大学的不同系所也会以不同的方式教授编程（正如我在其中教授编程时发现的）。
- en: There's no consistent body of knowledge that's applied or even referred to,
    and different courses will teach very different things. I'm not talking about
    differences at the idiomatic level, which are true across all types of teaching;
    you could learn the same programming language from two different teachers and
    discover two disjoint sets of concepts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一套一致的知识体系被应用或甚至被引用，不同的课程会教授非常不同的内容。我说的不是在语言习惯层面的差异，这种差异在所有类型的教学中都是真实的；你可能会从两位不同的老师那里学习同一种编程语言，并发现两组完全不同的概念集。
- en: This is consistent with the idea of programming being merely a tool to solve
    problems; different courses will be written with solving different problems in
    mind. But it means there isn't a shared collection of experiences and knowledge
    among neophyte programmers; we're doomed to spend the first few years of our careers
    repeating everyone else's mistakes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这与编程仅仅是一个解决问题的工具的想法是一致的；不同的课程会针对解决不同的问题而编写。但这意味着新手程序员之间没有共享的经验和知识集合；我们注定要在职业生涯的前几年重复别人的错误。
- en: 'Unfortunately, I don''t have a quick solution to this: all I can do is make
    you aware that there''s likely to be *loads* of experience in the industry that
    you haven''t even been able to make secondary use of. The effort to which you
    go to discover, understand, and share this experience is up to you, but hopefully
    this chapter has convinced you that the more you share knowledge with the community,
    the better your work and that of the community as a whole will be.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我并没有快速解决这个问题的方法：我所能做的就是让你意识到，在行业中很可能有大量的经验是你甚至没有能够加以利用的。你为了发现、理解和分享这些经验所付出的努力取决于你自己，但希望这一章已经说服了你，你与社区分享的知识越多，你的工作和整个社区的工作就会越好。
- en: The particular material I learned from was long on descriptions of how operators
    work and how to use the keywords of the language, but short on organization, on
    planning, and on readability (There's an essay on what it means for code to be
    readable in *Chapter 11, Critical Analysis*); that is, on everything that's beyond
    writing code and goes into writing *usable* code. Yes, I learned how to use GOSUB,
    but not *when* to use GOSUB.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我所学习的特定材料在描述操作符的工作原理和如何使用语言的关键词方面内容丰富，但在组织、规划和可读性方面却显得不足（关于代码可读性的意义在*第11章，批判性分析*中有论述）；也就是说，关于编写代码之外的一切，以及编写*可用的*代码的一切。是的，我学会了如何使用GOSUB，但不知道*何时*使用GOSUB。
- en: 'There''s a lot of good material out there on these other aspects of coding.
    When it comes to organization, for example, even back when I was teaching myself
    programming, there were books out there that explained this stuff and made a good
    job of it: **The Structure and Interpretation of Computer Programs**—[http://mitpress.mit.edu/sicp/full-text/book/book.html](http://mitpress.mit.edu/sicp/full-text/book/book.html);
    **Object-Oriented Programming: an evolutionary approach**—[http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y](http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y);
    **Object-Oriented Software Construction**—[http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition](http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition).
    The problem then was not that the information did not exist, but that I did not
    know I needed to learn it. It was, if you like, an unknown unknown.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些编码的其他方面，有很多好的资料。例如，在组织方面，即使在自我学习编程的时候，也有书籍解释了这些内容，并且做得很好：**《计算机程序的构造与解释》**——[http://mitpress.mit.edu/sicp/full-text/book/book.html](http://mitpress.mit.edu/sicp/full-text/book/book.html)；**面向对象编程：一种进化方法**——[http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y](http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y)；**面向对象软件构造**——[http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition](http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition)。问题不是信息不存在，而是我不知道我需要学习这些内容。如果你愿意，这是一个未知的未知。
- en: You could argue that the organization of code is an intermediate or advanced
    topic, beyond the scope of an introductory book or training course. Or you could
    argue that while it *is* something a beginner should know, putting it in the same
    book as the "this is how you use the `+` operator" material would make things
    look overwhelmingly complex, and could put people off.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以争论说，代码的组织是一个中级或高级话题，超出了入门书籍或培训课程的范畴。或者你可以争论说，虽然它确实是初学者应该知道的东西，但将它与“这是如何使用`+`运算符”的内容放在同一本书中，会使事情看起来过于复杂，可能会让人望而却步。
- en: Firstly, let me put forward the position that neither of these is true. I argue
    from analogy with Roger Penrose's book **The Road to Reality**—[http://books.google.co.uk/books/about/The_Road_to_Reality.html?id=ykV8cZxZ80MC](http://books.google.co.uk/books/about/The_Road_to_Reality.html?id=ykV8cZxZ80MC),
    which starts from fundamental math's (Pythagoras' theorem, geometry, and so on)
    and ends up at quantum gravity and cosmology. Each chapter is challenging, more
    so than the previous one, but can be understood, given an understanding of what
    came before. People (I included) have been known to spend years working through
    the book – working through the exercises at the end of each chapter before starting
    the next. And yet, it's a single book, barely more than 1,100 pages long.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我提出一个立场，即这两个说法都不正确。我通过类比罗杰·彭罗斯的书籍《现实之路》——[http://books.google.co.uk/books/about/The_Road_to_Reality.html?id=ykV8cZxZ80MC](http://books.google.co.uk/books/about/The_Road_to_Reality.html?id=ykV8cZxZ80MC)
    来进行论证，这本书从基本的数学（毕达哥拉斯定理、几何学等）开始，最终结束于量子引力和宇宙学。每一章都极具挑战性，比上一章更难，但只要理解了前面的内容，就可以理解。人们（包括我自己）都曾花费数年时间来研读这本书——在开始下一章之前，先完成每一章末尾的练习。然而，这仅仅是一本单本书，长度不超过1,100页。
- en: 'Could the same be done for computing? Could a "The Road to Virtual Reality"
    take people from an introduction to programming to a comprehensive overview of
    software creation? I''ll say this: the field is *much* smaller than theoretical
    physics.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计算来说，是否也可以做到同样的事情？是否可以有一本“虚拟现实之路”，将人们从编程入门带到软件创作的全面概述？我会这么说：这个领域的范围比理论物理学要小得多。
- en: 'Now, here''s a different argument. I''ll accept the idea that the field is
    either too big or too complex to all go into a single place, even for a strongly
    motivated learner. What''s needed in this case is a curriculum: a guide to how
    the different parts of software creation are related, which build on the others,
    and a proposed order in which to learn them.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一个不同的论点。我会接受这个观点，即这个领域要么太大，要么太复杂，以至于无法全部放入一个地方，即使是对于有强烈动机的学习者来说也是如此。在这种情况下，需要的是一个课程：一个关于软件创作不同部分之间关系的指南，它们建立在其他部分之上，以及一个建议的学习顺序。
- en: Such curricula exist, of course. In the UK, **A-level computing**—[http://www.cie.org.uk/qualifications/academic/uppersec/alevel/subject?assdef_id=738](http://www.cie.org.uk/qualifications/academic/uppersec/alevel/subject?assdef_id=738)
    doesn't just teach programming, but how to identify a problem that can be solved
    by a computer, design, and build that solution, and document it. Now where do
    you go from there? Being able to estimate the cost and risk associated with building
    the solution would be helpful; working on solutions built by more than one person;
    maintaining existing software; testing the proposed solution... These are all
    things that build on the presented topics. They're covered by *Postgraduate courses
    in software engineering*—[http://www.cs.ox.ac.uk/softeng/courses/subjects.html](http://www.cs.ox.ac.uk/softeng/courses/subjects.html);
    there's some kind of gap in between learning how to program and improving as a
    professional programmer, where you're on your own.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样的课程是存在的。在英国，**A-level计算机科学**——[http://www.cie.org.uk/qualifications/academic/uppersec/alevel/subject?assdef_id=738](http://www.cie.org.uk/qualifications/academic/uppersec/alevel/subject?assdef_id=738)不仅教授编程，还教授如何识别可以用计算机解决的问题、设计并构建解决方案以及记录它。那么接下来该怎么做呢？能够估计构建解决方案的成本和风险会有所帮助；在由多个人构建的解决方案上工作；维护现有软件；测试拟议的解决方案……这些都是建立在所呈现主题之上的。它们由**软件工程研究生课程**——[http://www.cs.ox.ac.uk/softeng/courses/subjects.html](http://www.cs.ox.ac.uk/softeng/courses/subjects.html)涵盖；在学习如何编程和作为专业程序员提高之间似乎存在某种差距，在那里你只能依靠自己。
- en: And these curricula are only designed for taught courses. Need the self-taught
    programmer be left out? (Some in the field would say, yes; that programming should
    be a professional discipline open only to professionals—or at least that there
    should be a designated *title* available only to those in the know, in the way
    that anybody can be a nutritionist but only the qualified may call themselves
    dieticians. Some of these people call themselves "software engineers" and think
    that software should be an exclusive profession, like an engineering discipline;
    others call themselves "software craftsmen" and use the mediaeval trade guilds
    as their models for exclusivity. I will leave my appraisal of those positions
    for later. But for now, it's worth reflecting on the implicit baggage that comes
    with *any* description of our work.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些课程仅是为授课课程设计的。难道自学成才的程序员应该被排除在外吗？（该领域的某些人可能会说，是的；编程应该是一门只有专业人士才能从事的专业学科——或者至少应该有一个只有知情者才能获得的指定**头衔**，就像任何人都可以成为营养师，但只有合格的人才能称自己为营养师一样。这些人中的一些人自称“软件工程师”，认为软件应该是一个专属的职业，就像工程学科一样；其他人则自称“软件工匠”，并以中世纪的行会作为他们追求专属性的模式。我将把对这些立场的评价留到以后。但现在，值得反思的是，对**任何**关于我们工作的描述都伴随着隐含的负担。）
- en: 'There are numerous series of books on programming: the **Kent Beck signature
    series**—[http://www.informit.com/imprint/series_detail.aspx?ser=2175138](http://www.informit.com/imprint/series_detail.aspx?ser=2175138)
    on management methodologies and approaches to testing, for example, or the **Spring
    Into**—[http://www.informit.com/imprint/series_detail.aspx?st=61172](http://www.informit.com/imprint/series_detail.aspx?st=61172)
    series of short introductions.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编程的书籍系列有很多：例如，**Kent Beck签名系列**——[http://www.informit.com/imprint/series_detail.aspx?ser=2175138](http://www.informit.com/imprint/series_detail.aspx?ser=2175138)关于管理方法和测试方法，或者**Spring
    Into**——[http://www.informit.com/imprint/series_detail.aspx?st=61172](http://www.informit.com/imprint/series_detail.aspx?st=61172)系列简短介绍。
- en: These published series are often clustered around either the beginner level
    or are deep and focus on experienced developers looking for information on specific
    tasks. There's no clear route from one to the other, whether editorially curated
    by some publisher or as an external resource. Try a web search for "what programming
    books to read" and you'll get more than one result for every programmer who has
    opined on the topic—as Jeff Atwood has written about it more than once.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些已发表的系列通常集中在初学者水平或深入且专注于寻求特定任务信息的经验丰富的开发者。无论是通过某个出版商的编辑策划还是作为外部资源，从一种水平到另一种水平都没有明确的路线。尝试在网络上搜索“应该阅读哪些编程书籍”，你会为每个对这一主题发表过意见的程序员得到多个结果——就像Jeff
    Atwood多次写过的那样。
- en: Building a curriculum is hard – harder than building a list of books you've
    read, and you'd like to pretend you'd read, then telling people they can't be
    a programmer until they read them. You need to decide what's really relevant and
    what to leave aside. You need to work out whether different material fits with
    a consistent theory of learning; whether people who get value from one book would
    derive anything from another. You need to decide where people need to get more
    experience, need to try things out before proceeding, and how appropriate it is
    for their curriculum to tell them to do that. You need to accept that different
    people learn in different ways and be ready for the fact that your curriculum
    won't work for everyone.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 构建课程是件困难的事情——比列出你读过的书单，或者假装你读过，然后告诉人们他们必须读过这些书才能成为程序员还要困难。你需要决定哪些内容真正相关，哪些可以省略。你需要弄清楚不同的材料是否与一致的学习理论相符；从一本书中获得价值的人是否可以从另一本书中获得什么。你需要决定人们需要获得更多经验的地方，在继续前进之前需要尝试的事情，以及他们的课程告诉他们这样做是否合适。你需要接受不同的人以不同的方式学习，并准备好你的课程不会对每个人都有效的事实。
- en: What all of this means is that there is still, despite 45 years of systematic
    computer science education, room for *multiple* curricula on the teaching of making
    software; that the possibility to help the next generation of programmers avoid
    the minefields that we (and the people before us, and the people before them)
    blundered into is open; that the "heroic effort" of rediscovery described at the
    beginning of this section needs be done, but only a small number of times.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着，尽管有45年的系统计算机科学教育，但在软件教学的课程设置上仍然有*多种*课程的空间；帮助下一代程序员避免我们（以及我们之前和之前的人）所犯的错误的可能性是开放的；在本节开头描述的“英雄般的努力”需要重做，但只需要做几次。
- en: Reflective Learning
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反思性学习
- en: Many higher education institutions promote the concept of **reflective learning**
    analyzing what you're learning introspectively and retrospectively, deciding what's
    gone well and what hasn't, and planning changes to favor the good parts over the
    bad. Bearing in mind what we've seen in this chapter – that there are manifold
    sources of information and that different people learn well from different media,
    reflective learning is a good way to sort through all of this information and
    decide what works for you.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 许多高等教育机构推广反思性学习的概念，即通过内省和回顾分析你所学的，决定哪些做得好，哪些不好，并计划做出改变，以使好的部分胜过不好的部分。考虑到我们在本章中看到的情况——即有无数的信息来源，不同的人从不同的媒介中学习得很好，反思性学习是整理所有这些信息并决定哪些对你有效的好方法。
- en: This is far from being a novel idea. In his book **The Psychology of Computer
    Programming**—[http://www.geraldmweinberg.com/Site/Home.html](http://www.geraldmweinberg.com/Site/Home.html),
    Gerald M. Weinberg describes how some programmers will learn well from lectures,
    some from books, and some from audio recordings. Some will—as we saw when discussing
    the Kolb cycle—want to start out with experimentation, whereas others will want
    to start with the theory. As he tells us to try these things out and discover
    which we benefit from most, he's telling us to *reflect* on our learning experiences
    and use that reflection to improve those experiences.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是一个新颖的想法。在他的书《计算机编程心理学》——[http://www.geraldmweinberg.com/Site/Home.html](http://www.geraldmweinberg.com/Site/Home.html)中，Gerald
    M. Weinberg描述了一些程序员如何从讲座、书籍和音频记录中学习得很好。有些人——正如我们在讨论Kolb循环时所看到的——想要从实验开始，而有些人则想要从理论开始。当他告诉我们尝试这些事情并发现哪些对我们最有益时，他实际上是在告诉我们要*反思*我们的学习经历，并利用这种反思来改进这些经历。
- en: 'Reflective learning is also a good way to derive lessons from your everyday
    experiences. I have a small notebook here in which, about 4 years ago, I wrote
    a paragraph every day based on the work I did that day. I thought about the problems
    I''d seen, and whether I could do anything to address them. I also thought about
    what had gone well and whether I could derive anything general from those successes.
    Here''s an example entry:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 反思性学习也是从日常经验中汲取教训的好方法。我这里有一本小笔记本，大约4年前，我每天都会根据当天的工作写一段话。我会思考我遇到的问题，以及我是否可以采取任何措施来解决它们。我也会思考哪些事情做得很好，以及我是否可以从这些成功中提炼出一些普遍的东西。以下是一个例子：
- en: '*Delegated review of our code inspection process to [colleague]. Did I give
    him enough information, and explain why I gave him the task? Discovered a common
    problem in code I write, there have been multiple crashes due to inserting* `nil`
    *into a collection. In much ObjC, the* `nil` *object can be used as normal but
    not in collections, and I already knew this. Why do I miss this out when writing
    code? Concentrate on ensuring failure conditions are handled in future code &
    get help to see them in code reviews. Chasing a problem with [product] which turned
    out to be something I''d already fixed on trunk & hadn''t integrated into my work
    branch. What could I have done to identify that earlier? Frequent integrations
    of fixes from trunk onto my branch would have obviated the issue.*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*将我们的代码审查流程委托给[同事]。我是否给了他足够的信息，并解释了为什么给他这个任务？在我的代码中发现了一个常见问题，由于向集合中插入* `nil`
    *而导致多次崩溃。在许多ObjC中，* `nil` *对象可以像正常对象一样使用，但不能在集合中使用，而且我已经知道这一点。为什么我在编写代码时会忽略这一点？专注于确保未来的代码中处理失败条件，并在代码审查中获得帮助以查看它们。追逐一个与[产品]相关的问题，结果发现这是我已经在主干上修复了但没有集成到我的工作分支中的问题。我本可以做些什么来更早地识别这个问题？频繁地将主干上的修复集成到我的分支上本可以消除这个问题。*'
- en: You don't necessarily have to write your reflections down, although I find that
    keeping a journal or a blog does make me structure my thoughts more than entirely
    internal reflection does. In a way, this very book is a reflective learning exercise
    for me. I'm thinking about what I've had to do in my programming life that isn't
    directly about writing code, and documenting that. Along the way, I'm deciding
    that some things warrant further investigation, discovering more about them, and
    writing about those discoveries.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定要把你的反思写下来，尽管我发现保持日记或博客确实能让我比完全的内省更有条理。从某种意义上说，这本书本身就是我的一种反思性学习练习。我在思考在我的编程生活中我不得不做的事情，这些事情并不是直接关于编写代码，而是在记录这些事情。在这个过程中，我决定有些事情值得进一步调查，了解更多关于它们的信息，并撰写关于这些发现的报告。
