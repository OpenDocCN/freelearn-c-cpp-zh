- en: '*Chapter 6*: Concepts and Constraints'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++20 standard provides a series of significant improvements to template
    metaprogramming with concepts and constraints. A **constraint** is a modern way
    to define requirements on template parameters. A **concept** is a set of named
    constraints. Concepts provide several benefits to the traditional way of writing
    templates, mainly improved readability of code, better diagnostics, and reduced
    compilation times.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will address the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring requires expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the ordering of templates with constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraining non-template member functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraining class templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraining variable templates and template aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning more ways to specify constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using concepts to constrain auto parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the standard concepts library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of the C++20
    concepts, and an overview of what concepts the standard library provides.
  prefs: []
  type: TYPE_NORMAL
- en: We will start the chapter by discussing what led to the development of concepts
    and what their main benefits are.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As briefly mentioned in the introduction to this chapter, there are some important
    benefits that concepts provide. Arguably, the most important ones are code readability
    and better error messages. Before we look at how to use concepts, let’s revisit
    an example we saw previously and see how it stands in relation to these two programming
    aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This simple function template takes two arguments and returns their sum. In
    fact, it does not return the sum, but the result of applying the plus operator
    to the two arguments. A user-defined type can overload this operator and perform
    some particular operation. The term *sum* only makes sense when we discuss mathematical
    types, such as integral types, floating-point types, the `std::complex` type,
    matrix types, vector types, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a string type, for instance, the plus operator can mean concatenation.
    And for most types, its overloading does not make sense at all. Therefore, just
    by looking at the declaration of the function, without inspecting its body, we
    cannot really say what this function may accept as input and what it does. We
    can call this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first three calls are all good; the first call adds two integers, the second
    adds two `double` values, and the third concatenates two `std::string` objects.
    However, the fourth call will produce a compiler error because `const char *`
    is substituted for the `T` type template parameter, and the plus operator is not
    overloaded for pointer types.
  prefs: []
  type: TYPE_NORMAL
- en: The intention for this `add` function template is to allow passing only values
    of arithmetic types, that is, integer and floating-point types. Before C++20,
    we could do this in several ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to use `std::enable_if` and SFINAE, as we saw in the previous chapter.
    Here is such an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to notice here is that the readability has decreased. The second
    type template parameter is difficult to read and requires good knowledge of templates
    to understand. However, this time, both the calls on the lines marked with `[3]`
    and `[4]` are producing a compiler error. Different compilers are issuing different
    error messages. Here are the ones for the three major compilers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **VC++ 17**, the output is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **GCC 12**, the output is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **Clang 13**, the output is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The error message in GCC is very verbose, and VC++ doesn’t say what the reason
    for failing to match the template argument is. Clang does, arguably, a better
    job at providing an understandable error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to define restrictions for this function, prior to C++20, is with
    the help of a `static_assert` statement, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With this implementation, however, we returned to the original problem that
    just by looking at the declaration of the function, we wouldn’t know what kind
    of parameters it would accept, provided that any restriction exists. The error
    messages, on the other hand, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **VC++ 17**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **GCC 12**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **Clang 13**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The use of the `static_assert` statement results in similar error messages received
    regardless of the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can improve these two discussed aspects (readability and error messages)
    in C++20 by using constraints. These are introduced with the new `requires` keyword
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `requires` keyword introduces a clause, called the **requires clause**,
    that defines the constraints on the template parameters. There are, actually,
    two alternative syntaxes: one when the requires clause follows the template parameter
    list, as seen previously, and one when the requires clause follows the function
    declaration, as shown in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Choosing between these two syntaxes is a matter of personal preference. However,
    in both cases, the readability is much better than in the pre-C++20 implementations.
    You know just by reading the declaration that the `T` type template parameter
    must be of an arithmetic type. Also, this implies that the function is simply
    adding two numbers. You don’t really need to see the definition to know that.
    Let’s see how the error message changes when we call the function with invalid
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **VC++ 17**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **GCC 12**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **Clang 13**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The error messages follow the same patterns seen already: GCC is too verbose,
    VC++ is missing essential information (the constraint that is not met), while
    Clang is more concise and better pinpoints the cause of the error. Overall, there
    is an improvement in the diagnostic messages, although there is still room for
    improvement.'
  prefs: []
  type: TYPE_NORMAL
- en: A constraint is a predicate that evaluates to true or false at compile-time.
    The expression used in the previous example, `std::is_arithmetic_v<T>`, is simply
    using a standard type trait (which we saw in the previous chapter). However, these
    are different kinds of expressions that can be used in a constraint, and we will
    learn about them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at how to define and use named constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Defining concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The constraints seen previously are nameless predicates defined in the places
    they are used. Many constraints are generic and can be used in multiple places.
    Let’s consider the following example of a function similar to the `add` function.
    This function performs the multiplication of arithmetic values and is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The same requires clause seen with the `add` function is present here. To avoid
    this repetitive code, we can define a name constraint that can be reused in multiple
    places. A named constraint is called a `concept` keyword and template syntax.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though they are assigned a Boolean value, concept names should not contain
    verbs. They represent requirements and are used as attributes or qualifiers on
    template parameters. Therefore, you should prefer names such as *arithmetic*,
    *copyable*, *serializable*, *container*, and more, and not *is_arithmetic*, *is_copyable*,
    *is_serializable*, and *is_container*. The previously defined arithmetic concept
    can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see from this snippet that the concept is used instead of the `typename`
    keyword. It qualifies the `T` type with the arithmetic quality, meaning that only
    the types that satisfy this requirement can be used as template arguments. The
    same arithmetic concept can be defined with a different syntax, shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses a *requires expression*. A requires expression uses curly branches,
    `{}`, whereas a *requires clause* does not. A requires expression can contain
    a sequence of requirements of different kinds: simple requirements, type requirements,
    compound requirements, and nested requirements. The one seen here is a simple
    requirement. For the purpose of defining this particular concept, this syntax
    is more complicated but has the same final effect. However, in some cases, complex
    requirements are needed. Let’s look at an example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the case when we want to define a template that should only take container
    types for an argument. Before concepts were available, this could have been solved
    with the help of a type trait and SFINAE or a `static_assert` statement, as we
    saw at the beginning of this chapter. However, a container type is not really
    easy to define formally. We can do it based on some properties of the standard
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: They have the member types `value_type`, `size_type`, `allocator_type`, `iterator`,
    and `const_iterator`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have the member function `size` that returns the number of elements in
    the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have the member functions `begin`/`end` and `cbegin`/`cend` that return
    iterators and constant iterators to the first and one-past-the-last element in
    the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the knowledge accumulated from [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*, we can define an `is_containter` type
    trait as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify with the help of `static_assert` statements that the type trait
    correctly identifies container types. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Concepts make writing such a template constraint much easier. We can employ
    the concept syntax and requires expressions to define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition is both shorter and more readable. It uses both simple requirements,
    such as `t.size()`, and type requirements, such as `typename T::value_type`. It
    can be used to constrain template parameters in the manner seen previously but
    can also be used with the `static_assert` statements (since constraints evaluate
    to a compile-time Boolean value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we will explore in depth the various kinds of requirements
    that can be used in requires expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring requires expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A requires expression may be a complex expression, as seen earlier in the example
    with the container concept. The actual form of a requires expression is very similar
    to function syntax and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The `parameter-list` is a comma-separated list of parameters. The only difference
    from a function declaration is that default values are not allowed. However, the
    parameters that are specified in this list do not have storage, linkage, or lifetime.
    The compiler does not allocate any memory for them; they are only used to define
    requirements. However, they do have a scope, and that is the closing curly brace
    of the requires expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `requirements-seq` is a sequence of requirements. Each such requirement
    must end with a semicolon, like any statement in C++. There are four types of
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compound requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These requirements may refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Template parameters that are in scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local parameters introduced in the parameter list of the requires expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other declaration that is visible from the enclosing context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following subsections, we will explore all the mentioned types of requirements.
    In the beginning, we’ll look at the simple requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Simple requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `true`. The expression must not start with the `requires` keyword as that
    defines a nested requirement (which will be discussed later).
  prefs: []
  type: TYPE_NORMAL
- en: 'We already saw examples of simple statements when we defined the `arithmetic`
    and `container` concepts earlier. Let’s see a few more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The first concept, `arithmetic`, is the same one we defined earlier. The `std::is_arithmetic_v<T>`
    expression is a simple requirement. Notice that when the parameter list is empty
    it can be completely omitted, as seen in this case, where we only check that the
    `T` type template parameter is an arithmetic type.
  prefs: []
  type: TYPE_NORMAL
- en: The `addable` and `logger` concepts both have a parameter list because we are
    checking operations on values of the `T` type. The expression `a + b` is a simple
    requirement, as the compiler just checks that the plus operator is overloaded
    for the `T` type. In the last example, we make sure that the `T` type has three
    member functions called `error`, `warning`, and `info` that take a single parameter
    of the `const char*` type or some type that can be constructed from `const char*`.
    Keep in mind that the actual values passed as arguments have no importance since
    these calls are never performed; they are only checked for correctness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s elaborate briefly on the last example and consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The `log_error` function template requires an argument of a type that meets
    the `logger` requirements. We have two classes, called `console_logger` and `stream_logger`.
    The first meets the `logger` requirements, but the second does not. That is because
    the `info` function cannot be invoked with a single argument of type `const char*`.
    This function also requires a second, Boolean, argument. The first two methods,
    `error` and `warning`, define a default value for the second argument, so they
    can be invoked with calls such as `t.error("just")` and `warning("a")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, because of the third member function, `stream_logger` is not a log
    class that meets the expected requirements and, therefore, cannot be used with
    the `log_error` function. The use of `console_logger` and `stream_logger` is exemplified
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we look at the second category of requirements, type requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Type requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`typename` followed by the name of a type. We have already seen several examples
    when we defined the `container` constraint. The name of the type must be valid
    for the requirement to be true. Type requirements can be used for several purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: To verify that a nested type exists (such as in `typename T::value_type;`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To verify that a class template specialization names a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To verify that an alias template specialization names a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see several examples to learn how to use type requirements. In the first
    example, we check whether a type contains the inner types, `key_type` and `value_type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The type, `key_value_pair<int, std::string>`, satisfies these type requirements,
    but `std::pair<int, std::string>` does not. The `std::pair` type does have inner
    types, but they are called `first_type` and `second_type`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example, we check whether a class template specialization names
    a type. The class template is `container`, and the specialization is `container<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, `container` is a class template that can only be specialized
    for arithmetic types, such as `int`, `long`, `float`, or `double`. Therefore,
    specializations such as `container<int>` exist, but `container<std::string>` does
    not. The `containerizeable` concept specifies a requirement for a type `T` to
    define a valid specialization of `container`. Therefore, `containerizeable<int>`
    is true, but `containerizeable<std::string>` is false.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood simple requirements and type requirements it is
    time to explore the more complex category of requirements. The first to look at
    is compound requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Compound requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simple requirements allow us to verify that an expression is valid. However,
    sometimes we need to verify some properties of an expression not just that it
    is valid. This can include whether an expression does not throw exceptions or
    requirements on the result type (such as the return type of a function). The general
    form is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the `noexcept` specification and the `type_constraint` (with the leading
    `->`) are optional. The substitution process and the checking of the constraints
    occur as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The template arguments are substituted in the expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `noexcept` is specified, then the expression must not throw exceptions; otherwise,
    the requirement is false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the type constraint is present, then the template arguments are also substituted
    into `type_contraint` and `decltype((expression))` must satisfy the conditions
    imposed by `type_constraint`; otherwise, the requirement is false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will discuss a couple of examples to learn how to use compound requirements.
    In the first example, we check whether a function is marked with the `noexcept`
    specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, there are two function templates: `f` is declared `noexcept`;
    therefore, it shall not throw any exception, and `g`, which potentially throws
    exceptions. The `NonThrowing` concept imposes the requirement that the variadic
    function of type `F` must not throw exceptions. Therefore, of the following two
    invocations, only the first is valid and the second will produce a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'The error messages generated by Clang are shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: These error messages tell us that the `invoke(g<int>, 42)` call is not valid
    because `g<int>` may throw an exception, which results in `NonThrowing<F, T…>`
    to evaluating as `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second example, we will define a concept that provides requirements
    for timer classes. Specifically, it requires that a function called `start` exists,
    that it can be invoked without any parameters, and that it returns `void`. It
    also requires that a second function called `stop` exists, that it can be invoked
    without any parameters, and that it returns a value that can be converted to `long
    long`. The concept is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the type constraint cannot be any compile-time Boolean expression,
    but an actual type requirement. Therefore, we use other concepts for specifying
    the return type. Both `std::same_as` and `std::convertible_to` are concepts available
    in the standard library in the `<concepts>` header. We’ll learn more about these
    in the *Exploring the standard concepts library* section. Now, let’s consider
    the following classes that implement timers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `timerA` satisfies the timer concept because it contains the
    two required methods: `start` that returns `void` and `stop` that returns `long
    long`. Similarly, `timerB` also satisfies the timer concept because it features
    the same methods, even though `stop` returns an `int`. However, the `int` type
    is implicitly convertible to the `long long` type; therefore, the type requirement
    is met. Lastly, `timerC` also has the same methods, but both of them return `void`,
    which means the type requirement for the return type of `stop` is not met, and
    therefore, the constraints imposed by the `timer` concept are not satisfied.'
  prefs: []
  type: TYPE_NORMAL
- en: The last category of requirements left to look into is nested requirements.
    We will do this next.
  prefs: []
  type: TYPE_NORMAL
- en: Nested requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last category of requirements is nested requirements. A nested requirement
    is introduced with the `requires` keyword (remember we mentioned that a simple
    requirement is a requirement that is not introduced with the `requires` keyword)
    and has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: The expression must be satisfied by the substituted arguments. The substitution
    of the template arguments into `constraint-expression` is done only to check whether
    the expression is satisfied or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we want to define a function that performs addition
    on a variable number of arguments. However, we want to impose some conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: There is more than one argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the arguments have the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression `arg1 + arg2 + … + argn` is valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To ensure this, we define a concept called `HomogenousRange` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: This concept contains one simple requirement and two nested requirements. One
    nested requirement uses the `are_same_v` variable template whose value is determined
    by the conjunction of one or more type traits (`std::is_same`), and the other,
    the compile-time Boolean expression `size…(T) > 1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this concept, we can define the `add` variadic function template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: The first call exemplified previously is correct, as there are two arguments,
    and both are of type `int`. The second call produces an error because the types
    of the arguments are different (`int` and `double`). Similarly, the third call
    also produces an error because only one argument was supplied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HomogenousRange` concept can also be tested with the help of several `static_assert`
    statements, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: We have walked through all the categories of the requires expressions that can
    be used for defining constraints. However, constraints can also be composed, and
    this is what we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Composing constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen multiple examples of constraining template arguments but in all
    the cases so far, we used a single constraint. It is possible though for constraints
    to be composed using the `&&` and `||` operators. A composition of two constraints
    using the `&&` operator is called a `||` operator is called a **disjunction**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a conjunction to be true, both constraints must be true. Like in the case
    of logical **AND** operations, the two constraints are evaluated from left to
    right, and if the left constraint is false, the right constraint is not evaluated.
    Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we have a function template that returns the decremented value
    of the received argument. However, it only accepts signed integral values. This
    is specified with the conjunction of two constraints, `std::is_integral_v<T> &&
    std::is_signed_v<T>`. The same result can be achieved using a different approach
    to defining the conjunction, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see three concepts defined here: one that constrains integral types,
    one that constrains signed types, and one that constrains integral and signed
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disjunctions work in a similar way. For a disjunction to be true, at least
    one of the constraints must be true. If the left constraint is true, then the
    right one is not evaluated. Again, let’s see an example. If you recall the `add`
    function template from the first section of the chapter, we constrained it with
    the `std::is_arithmetic` type trait. However, we can get the same result using
    `std::is_integral` and `std::is_floating_point`, used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression `std::is_integral_v<T> || std::is_floating_point_v<T>` defines
    a disjunction of two atomic constraints. We will look at this kind of constraint
    in more detail later. For the time being, keep in mind that an atomic constraint
    is an expression of the `bool` type that cannot be decomposed into smaller parts.
    Similarly, to what we’ve done previously, we can also build a disjunction of concepts
    and use that. Here is how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: As already mentioned, conjunctions and disjunctions are short-circuited. This
    has an important implication in checking the correctness of a program. Considering
    a conjunction of the form `A<T> && B<T>`, then `A<T>` is checked and evaluated
    first, and if it is false, the second constraint, `B<T>`, is not checked anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, for the `A<T> || B<T>` disjunction, after `A<T>` is checked, if
    it evaluates to true, the second constraint, `B<T>`, will not be checked. If you
    want both conjunctions to be checked for well-formedness and then their Boolean
    value determined, then you must use the `&&` and `||` operators differently. A
    conjunction or disjunction is formed only when the `&&` and `||` tokens, respectively,
    appear nested in parentheses or as an operand of the `&&` or `||` tokens. Otherwise,
    these operators are treated as logical operators. Let’s explain this with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'In all these examples, the `||` token defines a disjunction. However, when
    used inside a cast expression or a logical `&&` and `||` tokens define a logical
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: In these cases, the entire expression is first checked for correctness, and
    then its Boolean value is determined. It is worth mentioning that in this latter
    example both expressions, `!(A<T> || B<T>)` and `static_cast<bool>(A<T> || B<T>)`,
    need to be wrapped inside another set of parentheses because the expression of
    a requires clause cannot start with the `!` token or a cast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conjunctions and disjunctions cannot be used to constrain template parameter
    packs. However, there is a workaround to make it happen. Let’s consider a variadic
    implementation of the `add` function template with the requirement that all arguments
    must be integral types. One would attempt to write such a constraint in the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a compiler error because the ellipsis is not allowed in
    this context. What we can do to avoid this error is to wrap the expression in
    a set of parentheses, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression, `(std::is_integral_v<T> && ...)`, is now a fold expression.
    It is not a conjunction, as one would expect. Therefore, we get a single atomic
    constraint. The compiler will first check the correctness of the entire expression
    and then determine its Boolean value. To build a conjunction we first need to
    define a concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'What we need to do next is change the requires clause so that it uses the newly
    defined concept and not the Boolean variable, `std::is_integral_v<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: It does not look like much of a change but, in fact, because of the use of concepts,
    validating the correctness and determining the Boolean value occur individually
    for each template argument. If the constraint is not met for a type, the rest
    is short-circuited, and the validation stops.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must have noticed that earlier in this section I used the term *atomic
    constraint* twice. Therefore, one would ask, what is an atomic constraint? It
    is an expression of the `bool` type that cannot be decomposed further. Atomic
    constraints are formed during the process of constraint normalization when the
    compiler decomposes constraints into conjunction and disjunctions of atomic constraints.
    This works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The expression, `E1 && E2`, is decomposed into the conjunction of `E1` and `E2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression, `E1 || E2`, is decomposed into the disjunction of `E1` and `E2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept, `C<A1, A2, … An>`, is replaced with its definition after substituting
    all the template arguments into its atomic constraints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomic constraints are used for determining the partial ordering of constraints
    that, in turn, determine the partial ordering of function templates and class
    template specializations, as well as the next candidate for non-template functions
    in overload resolution. We will discuss this topic next.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the ordering of templates with constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a compiler encounters function calls or class template instantiations,
    it needs to figure out what overload (for a function) or specialization (for a
    class) is the best match. A function may be overloaded with different type constraints.
    Class templates can also be specialized with different type constraints. In order
    to decide which is the best match, the compiler needs to figure out which one
    is the most constrained and, at the same time, evaluates to `true` after substituting
    all the template parameters. In order to figure this out, it performs the **constraints
    normalization**. This is the process of transforming the constraint expression
    into conjunctions and disjunctions of atomic constraints, as described at the
    end of the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: An atomic constraint `A` is said to subsume another atomic constraint `B` if
    `A` implies `B`. A constraint declaration `D1` whose constraints subsume the constraints
    of another declaration `D2` is said to be at least as constrained as `D2`. Moreover,
    if `D1` is at least as constrained as `D2` but the reciprocal is not true, then
    it’s said that `D1` is more constrained than `D2`. More constrained overloads
    are selected as the best match.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss several examples in order to understand how constraints affect
    overload resolution. First, let’s start with the following two overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: The first overload is a non-template function that takes two `int` arguments
    and returns their sum. The second is the template implementation we have seen
    already in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having these two, let’s consider the following calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: The first call (at line `[1]`) takes two `double` values so only the template
    overload is a match. Therefore, its instantiation for the `double` type will be
    called. The second invocation of the `add` function (at line `[2]`) takes two
    integer arguments. Both overloads are a possible match. The compiler will select
    the most specific one, which is the non-template overload.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if both overloads are templates but one of them is constrained? Here is
    an example to discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: The first overload is the function template seen previously. The second has
    an identical implementation except that it specifies a requirement for the template
    argument, which is restricted to integral types. If we consider the same two calls
    from the previous snippet, for the call at line `[1]` with two `double` values,
    only the first overload is a good match. For the call at line `[2]` with two integer
    values, both overloads are a good match. However, the second overload is more
    constrained (it has one constraint compared to the first one that has no constraint)
    so the compiler will select this one for the invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, both overloads are constrained. The first overload requires
    that the size of the template argument is four, and the second overload requires
    that the template argument must be an integral type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s consider the following calls to this overloaded function template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: The call at line `[1]` uses arguments of the `short` type. This is an integral
    type with the size `2`; therefore, only the second overload is a match. However,
    the call at line `[2]` uses arguments of the `int` type. This is an integral type
    of size `4`. Therefore, both overloads are a good match. However, this is an ambiguous
    situation, and the compiler is not able to select between the two and it will
    trigger an error.
  prefs: []
  type: TYPE_NORMAL
- en: What happens, though, if we change the two overloads slightly, as shown in the
    next snippet?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: Both overloads require that the template argument must be an integral type,
    but the second also requires that the size of the integral type must be `4` bytes.
    So, for the second overload, we use a conjunction of two atomic constraints. We
    will discuss the same two calls, with `short` arguments and with `int` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the call at line `[1]`, passing two `short` values, only the first overload
    is a good match, so this one will be invoked. For the call at line `[2]` that
    takes two `int` arguments, both overloads are a match. The second, however, is
    more constrained. Yet, the compiler is not able to decide which is a better match
    and will issue an ambiguous call error. This may be surprising to you because,
    in the beginning, I said that the most constrained overload will be selected from
    the overload set. It does not work in our example because we used type traits
    to constrain the two functions. The behavior is different if we instead use concepts.
    Here is how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no ambiguity anymore; the compiler will select the second overload
    as the best match from the overload set. This demonstrates that concepts are handled
    preferentially by the compiler. Remember, there are different ways to use constraints
    using concepts, but the preceding definition simply replaced a type trait with
    a concept; therefore, they are arguably a better choice for demonstrating this
    behavior than the next implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: All the examples discussed in this chapter involved constraining function templates.
    However, it’s possible to constrain non-template member functions as well as class
    templates and class template specializations. We will discuss these in the next
    sections, and we will start with the former.
  prefs: []
  type: TYPE_NORMAL
- en: Constraining non-template member functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Non-template functions that are members of class templates can be constrained
    in a similar way to what we have seen so far. This enables template classes to
    define member functions only for types that satisfy some requirements. In the
    following example, the equality operator is constrained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wrapper` class holds a value of a `T` type and defines the `operator==`
    member only for types that are convertible to `std::string_view`. Let’s see how
    this can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: We have two instantiations of the `wrapper` class here, one for `int` and one
    for `char const*`. The attempt to compare the `a` object with the literal `42`
    generates a compiler error, because the `operator==` is not defined for this type.
    However, comparing the `b` object with the string literal `"42"` is possible because
    the equality operator is defined for types that can be implicitly converted to
    `std::string_view`, and `char const*` is such a type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraining non-template members is useful because it’s a cleaner solution
    than forcing members to be templates and using SFINAE. To understand this better
    let’s consider the following implementation of the `wrapper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: 'This class template can be instantiated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: The first line compiles successfully, but the second generates a compiler error.
    There are different messages issued by different compilers, but at the core of
    the error is the call to the implicitly deleted copy constructor of `std::unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want to do is restrict the copy construction of `wrapper` from objects
    of the `T` type so that it only works for `T` types that are copy-constructible.
    The approach available before C++20 was to transform the copy constructor into
    a template and employ SFINAE. This would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we also get an error when trying to initialize a `wrapper<std::unique_ptr<int>>`
    from an `std::unique_ptr<int>` value but the errors are different. For instance,
    here are the error messages generated by Clang:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important message to help understand the cause of the problem is the
    last one. It says that the requirement that `U` substituted with `std::unique_ptr<int>`
    does not satisfy the Boolean condition. In C++20, we can do a better job at implementing
    the same restriction on the `T` template argument. This time, we can use constraints
    and the copy constructor does not need to be a template anymore. The implementation
    in C++20 can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only there is less code that does not require complicated SFINAE machinery,
    but it is simpler and easier to understand. It also generates potentially better
    error messages. In the case of Clang, the last note listed earlier is replaced
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'Before closing this section, it’s worth mentioning that not only non-template
    functions that are members of classes can be constrained but also free functions.
    The use cases for non-template functions are rare and can be achieved with alternative
    simple solutions such as constexpr if. Let’s look at an example, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we have two overloads of the `handle` function. The first
    overload takes an `int` value and the second a `long` value. The body of these
    overloaded functions is not important but they should do different things, if
    and only if the size of `long` is different from the size of `int`. The standard
    specifies that the size of `int` is at least 16 bits, although on most platforms
    it is 32 bits. The size of `long` is at least 32 bits. However, there are platforms,
    such as `int` is 32 bits and `long` is 64 bits. On these platforms, both overloads
    should be available. On all the other platforms, where the two types have the
    same size, only the first overload should be available. This can be defined in
    the form shown earlier, although the same can be achieved in C++17 with constexpr
    if as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll learn how to use constraints to define restrictions
    on template arguments of class templates.
  prefs: []
  type: TYPE_NORMAL
- en: Constraining class templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class templates and class template specializations can also be constrained
    just like function templates. To start, we’ll consider the `wrapper` class template
    again, but this time with the requirement that it should only work for template
    arguments of integral types. This can be simply specified in C++20 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: Instantiating the template for the `int` type is fine but does not work for
    `double` because this is not an integral type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Requirements that also be specified with requires clauses and class template
    specializations can also be constrained. To demonstrate this, let’s consider the
    scenario when we want to specialize the `wrapper` class template but only for
    types whose size is `4` bytes. This can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this class template as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: The object `a` is an instance of `wrapper<short>`; therefore, the primary template
    is used. On the other hand, the object `b` is an instance of `wrapper<int>`. Since
    `int` has a size of 4 bytes (on most platforms) the specialization is used and
    we can access the individual types of the wrapped value through the `byte1`, `byte2`,
    `byte3`, and `byte4` members.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly on this topic, we will discuss how variable templates and template aliases
    can also be constrained.
  prefs: []
  type: TYPE_NORMAL
- en: Constraining variable templates and template aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you well know, apart from function templates and class templates we also
    have variable templates and alias templates in C++. These make no exception of
    the need to define constraints. The same rules for constraining the template arguments
    discussed so far apply to these two. In this section, we will demonstrate them
    shortly. Let’s start with variable templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a typical example to define the `PI` constant for showing how variable
    templates work. Indeed, it is a simple definition that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this only makes sense for floating-point types (and maybe other types
    such as `decimal`, which does not exist in C++ yet). Therefore, this definition
    should be restricted to floating-point types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: The use of `PI<double>` is correct but `PI<int>` produces a compiler error.
    This is what constraints can provide in a simple and readable manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last category of templates that we have in the language, alias
    templates, can also be constrained. In the following snippet, we can see such
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: 'The `integral_vector` template is an alias for `std::vector<T>` when `T` is
    an integral type. The very same can be achieved with the following alternative,
    although longer, declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this `integral_vector` alias template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: Defining the `v1` object works fine since `int` is an integral type. However,
    defining the `v2` vector generates a compiler error because `double` is not an
    integral type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you paid attention to the examples in this section, you will have noticed
    that they don’t use the type traits (and the associated variable templates) we
    used previously in the chapter, but a couple of concepts: `std::integral` and
    `std::floating_point`. These are defined in the `<concepts>` header and help us
    avoid repeatedly defining the same concepts based on available C++11 (or newer)
    type traits. We will look at the content of the standard concepts library shortly.
    Before we do that, let’s see what other ways we can employ to define constraints
    in C++20.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning more ways to specify constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have discussed in this chapter about requires clauses and requires expressions.
    Although both are introduced with the new `requires` keyword, they are different
    things and should be fully understood:'
  prefs: []
  type: TYPE_NORMAL
- en: A *requires clause* determines whether a function participates in overload resolution
    or not. This happens based on the value of a compile-time Boolean expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *requires expression* determines whether a set of one or more expressions
    is well-formed, without having any side effects on the behavior of the program.
    A requires expression is a Boolean expression that can be used with a requires
    clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see an example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: The construct at line `[1]` that starts with the `requires` keyword is a requires
    expression. It verifies that the expression, `a + b`, is well-formed for any `T`.
    On the other hand, the construct at line `[2]` is a requires clause. If the Boolean
    expression `addable<T>` evaluates to `true`, the function takes part in overload
    resolution; otherwise, it does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although requires clauses are supposed to use concepts, a requires expression
    can also be used. Basically, anything that can be placed on the right-hand side
    of the `=` token in a concept definition can be used with a requires clause. That
    means we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Although this is perfectly legal code it is arguable whether it’s a good way
    of using constraints. I would recommend avoiding creating constructs that start
    with `requires requires`. They are less readable and may create confusion. Moreover,
    named concepts can be used anywhere, while a requires clause with a requires expression
    will have to be duplicated if it needs to be used for multiple functions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to constrain template arguments in several ways using
    constraints and concepts, let’s see how we can simplify function template syntax
    and constrain the template arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Using concepts to constrain auto parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B18367_02_ePub.xhtml#_idTextAnchor024), *Template Fundamentals*,
    we discussed generic lambdas, introduced in C++14, as well as lambda templates,
    introduced in C++20\. A lambda that uses the `auto` specifier for at least one
    parameter is called a **generic lambda**. The function object generated by the
    compiler will have a templated call operator. Here is an example to refresh your
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++20 standard generalizes this feature for all functions. You can use
    the `auto` specifier in the function parameter list. This has the effect of transforming
    the function into a template function. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a function that takes two parameters and returns their sum (or to be
    more precise, the result of applying `operator+` on the two values). Such a function
    using `auto` for function parameters is called an **abbreviated function template**.
    It is basically shorthand syntax for a function template. The equivalent template
    for the previous function is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call this function as we would call any template function, and the compiler
    will generate the proper instantiations by substituting the template arguments
    with the actual types. For instance, let’s consider the following calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the [cppinsights.io](http://cppinsights.io) website to check the
    compiler-generated code for the `add` abbreviated function template based on these
    two calls. The following specializations are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: 'Since an abbreviated function template is nothing but a regular function template
    with a simplified syntax, such a function can be explicitly specialized by the
    user. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: This is a full specialization for the `char const*` type. This specialization
    enables us to make calls such as `add("4", "2")`, although the result is a `std::string`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This category of abbreviated function templates is called `add` function constrained
    for integral types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: 'If we consider again the same calls we saw earlier, the first would be successful,
    but the second would produce a compiler error because there is no overload that
    takes a `double` and an `int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: 'Constrained `auto` can also be used for variadic abbreviated function templates.
    An example is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, constrained `auto` can be used with generic lambdas too.
    If we would like the generic lambda shown at the beginning of this section to
    be used only with integral types, then we can constrain it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: With the closing of this section, we have seen all the language features related
    to concepts and constraints in C++20\. What is left to discuss is the set of concepts
    provided by the standard library, of which we have seen a couple already. We will
    do this next.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the standard concepts library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library provides a set of fundamental concepts that can be used
    to define requirements on the template arguments of function templates, class
    templates, variable templates, and alias templates, as we have seen throughout
    this chapter. The standard concepts in C++20 are spread across several headers
    and namespaces. We will present some of them in this section although not all
    of them. You can find all of them online at [https://en.cppreference.com/](https://en.cppreference.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main set of concepts is available in the `<concepts>` header and the `std`
    namespace. Most of these concepts are equivalent to one or more existing type
    traits. For some of them, their implementation is well-defined; for some, it is
    unspecified. They are grouped into four categories: core language concepts, comparison
    concepts, object concepts, and callable concepts. This set of concepts contains
    the following (but not only):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_06_Table1.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_06_Table1.2.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these concepts are defined using type traits, some are a combination
    of other concepts or concepts and type traits, and some have, at least partially,
    an unspecified implementation. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: 'C++20 also introduces a new system of iterators, based on concepts, and defines
    a set of concepts in the `<iterator>` header. Some of these concepts are listed
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_06_Table2.1.jpg)![Table 6.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_06_Table2.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the `random_access_iterator` concept is defined in the C++ standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it uses several concepts (some of them not listed here) as well
    as a requires expression to ensure that some expressions are well-formed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the `<iterator>` header, there is a set of concepts designed to simplify
    the constraining of general-purpose algorithms. Some of these concepts are listed
    in the next table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_06_Table3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.3
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the several major features included in C++20 (along with concepts, modules,
    and coroutines) are ranges. The `ranges` library defines a series of classes and
    functions for simplifying operations with ranges. Among these is a set of concepts.
    These are defined in the `<ranges>` header and the `std::ranges` namespace. Some
    of these concepts are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.4'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_06_Table4.1.jpg)![Table 6.4'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_06_Table4.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.4
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how some of these concepts are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned already, there are more concepts than those listed here. Others
    will probably be added in the future. This section is not intended as a complete
    reference to the standard concepts but rather as an introduction to them. You
    can learn more about each of these concepts from the official C++ reference documentation
    available at [https://en.cppreference.com/](https://en.cppreference.com/). As
    for ranges, we will learn more about them and explore what the standard library
    provides in [*Chapter 8*](B18367_08_ePub.xhtml#_idTextAnchor179), *Ranges and
    Algorithms*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++20 standard introduced some new major features to the language and the
    standard library. One of these is concepts, which was the topic of this chapter.
    A concept is a named constraint that can be used to define requirements on template
    arguments for function templates, class templates, variable templates, and alias
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have explored in detail how we can use constraints and concepts
    and how they work. We have learned about requires clauses (that determine whether
    a template participates in overload resolution) and requires expressions (that
    specify requirements for well-formedness of expressions). We have seen what various
    syntaxes are for specifying constraints. We also learned about abbreviated function
    templates that provide a simplified syntax for function templates. At the end
    of the chapter, we explored the fundamental concepts available in the standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift our attention toward applying the knowledge
    accumulated so far to implement various template-based patterns and idioms.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are constraints and what are concepts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are a requires clause and a requires expression?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the categories of requires expressions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do constraints affect the ordering of templates in overload resolution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are abbreviated function templates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*C++20 Concepts - A Quick Introduction*, Bartlomiej Filipek, [https://www.cppstories.com/2021/concepts-intro/](https://www.cppstories.com/2021/concepts-intro/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How C++20 Concepts can simplify your code*, Andreas Fertig, [https://andreasfertig.blog/2020/07/how-cpp20-concepts-can-simplify-your-code/](https://andreasfertig.blog/2020/07/how-cpp20-concepts-can-simplify-your-code/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What are C++20 concepts and constraints? How to use them?*, Sorush Khajepor,
    [https://iamsorush.com/posts/concepts-cpp/](https://iamsorush.com/posts/concepts-cpp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Requires-clause*, Andrzej Krzemieński, [https://akrzemi1.wordpress.com/2020/03/26/requires-clause/](https://akrzemi1.wordpress.com/2020/03/26/requires-clause/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ordering by constraints*, Andrzej Krzemieński, [https://akrzemi1.wordpress.com/2020/05/07/ordering-by-constraints/](https://akrzemi1.wordpress.com/2020/05/07/ordering-by-constraints/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
