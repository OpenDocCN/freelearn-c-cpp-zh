<html><head></head><body>
		<div id="_idContainer041">
			<h1 id="_idParaDest-69"><a id="_idTextAnchor070"/><em class="italic">Chapter 2</em>: Variables, Operators, and Decisions – Animating Sprites</h1>
			<p>In this chapter, we will do quite a bit more drawing on the screen and, to achieve this, we will need to learn about some of the basics of C++. We will learn how to use variables to remember and manipulate values, and we will begin to add more graphics to the game. As this chapter progresses, we will find out how we can manipulate these values to animate the graphics. These values are known as variables.</p>
			<p>Here is what is in store:</p>
			<ul>
				<li>Learning all about C++ variables</li>
				<li>Seeing how to manipulate the values stored in variables</li>
				<li>Adding a static tree graphic, ready for the player to chop away at</li>
				<li>Drawing and animating a bee and three clouds</li>
			</ul>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/>C++ variables</h1>
			<p><strong class="bold">Variables</strong> are the way that our C++ games store and manipulate values/data. If we want to know how much health the player has, we need a variable. Perhaps you want to know how many zombies are left in the current wave. That is a variable as well. If you need to remember the name of the player who got a high score, you guessed it—we need a variable for that. Is the game over or still playing? Yes, that's a variable too.</p>
			<p>Variables are named identifiers for locations in the memory of the PC. The memory of the PC is where computer programs are stored as they are being executed. So, we might name a variable <strong class="source-inline">numberOfZombies</strong> and that variable could refer to a place in memory that stores a value to represent the number of zombies that are left in the current wave.</p>
			<p>The way that computer systems address locations in memory is complex. Programming languages use variables to give us a human-friendly way to manage our data in that memory.</p>
			<p>The small amount we have just mentioned about variables implies that there must be different <strong class="bold">types</strong> of variable.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>Types of variables</h2>
			<p>There is a wide variety of C++ variable types (see the next tip about variables in a couple of pages). It would easily be possible to spend an entire chapter discussing them. What follows is a table of the most commonly used types of variable in this book. Then, in the next section, we will look at how to use each of these variable types:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B14278_02_1.jpg" alt=""/>
				</div>
			</div>
			<p>The compiler must be told what type of variable it is so that it can allocate the right amount of memory for it. It is good practice to use the best and most appropriate type for each variable you use. In practice, however, you will often get away with promoting a variable. Perhaps you need a floating-point number with just five significant digits? The compiler won't complain if you store it as a <strong class="source-inline">double</strong>. However, if you tried to store a <strong class="source-inline">float</strong> or a <strong class="source-inline">double</strong> in an <strong class="source-inline">int</strong>, it will <strong class="bold">change</strong>/<strong class="bold">cast</strong> the value to fit the <strong class="source-inline">int</strong>. As we progress through this book, I will make it plain what the best variable type to use in each case is, and we will even see a few instances where we deliberately convert/cast between variable types.</p>
			<p>A few extra details worth noticing in the preceding table include the <strong class="source-inline">f</strong> postfix next to all of the <strong class="source-inline">float</strong> values. This <strong class="source-inline">f</strong> postfix tells the compiler that the value is a <strong class="source-inline">float</strong> type, not <strong class="source-inline">double</strong>. A floating-point value without the <strong class="source-inline">f</strong> prefix is assumed to be <strong class="source-inline">double</strong>. See the next tip about variables for more about this.</p>
			<p>As we mentioned previously, there are many more types. If you want to find out more about types, see the next tip about variables. </p>
			<h3>User-defined types</h3>
			<p>User-defined types are way more advanced than the types we have just seen. When we talk about user-defined types in C++, we are usually talking about classes. We briefly talked about classes and their related objects in the previous chapter. We would write code in a separate file, sometimes two. We are then able to declare, initialize, and use them. We will leave how we define/create our own types until <a href="B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154"><em class="italic">Chapter 6</em></a><em class="italic">, Object-Oriented Programming – Starting the Pong Game</em>.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/>Declaring and initializing variables</h2>
			<p>So far, we know that variables are for storing the data/values that our games need in order to work. For example, a variable would represent the number of lives a player has or the player's name. We also know that there is a wide selection of different types of values that these variables can represent, such as <strong class="source-inline">int</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">bool</strong>, and so on. Of course, what we haven't seen yet is how we would actually go about using a variable.</p>
			<p>There are two stages when it comes to creating and preparing a new variable. These stages are called <strong class="bold">declaration</strong> and <strong class="bold">initialization</strong>.</p>
			<h3>Declaring variables</h3>
			<p>We can declare variables in C++ like this:</p>
			<p class="source-code">// What is the player's score?</p>
			<p class="source-code">int playerScore;</p>
			<p class="source-code">// What is the player's first initial</p>
			<p class="source-code">char playerInitial;</p>
			<p class="source-code">// What is the value of pi</p>
			<p class="source-code">float valuePi;</p>
			<p class="source-code">// Is the player alive or dead?</p>
			<p class="source-code">bool isAlive;</p>
			<p>Once we have written the code to declare a variable, it exists and is ready to be used in our code. However, we will usually want to give the variable an appropriate value, which is where initialization comes in.</p>
			<h3>Initializing variables</h3>
			<p>Now that we have declared the variables with meaningful names, we can initialize those same variables with appropriate values, like this:</p>
			<p class="source-code">playerScore = 0;</p>
			<p class="source-code">playerInitial = 'J';</p>
			<p class="source-code">valuePi = 3.141f;</p>
			<p class="source-code">isAlive = true;</p>
			<p>At this point, the variable exists and holds a specific value. Soon, we will see how we can change, test, and respond to these values. Next, we will see that we can combine declaring and initializing into one step.</p>
			<h3>Declaring and initializing in one step</h3>
			<p>When it suits us, we can combine the declaration and initialization steps into one. Sometimes, we know what value a variable must start the program with, and declaring and initializing in one step is appropriate. Often, we won't, and we will first declare the variable and then initialize it later in the program, like so:</p>
			<p class="source-code">int playerScore = 0;</p>
			<p class="source-code">char playerInitial = 'J';</p>
			<p class="source-code">float valuePi = 3.141f;</p>
			<p class="source-code">bool isAlive = true;</p>
			<p class="callout-heading">Variables tip</p>
			<p class="callout">As promised, here is the tip on variables. If you want to see a complete list of C++ types, then check out this web page: <a href="http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm">http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm</a>. If you want a deeper discussion on <strong class="source-inline">float</strong>, <strong class="source-inline">double</strong>, and the <strong class="source-inline">f</strong> postfix, then read this: <a href="http://www.cplusplus.com/forum/beginner/24483/">http://www.cplusplus.com/forum/beginner/24483/</a>. Finally, if you want to know the ins and outs of the ASCII character codes, then there is some more information here: <a href="http://www.cplusplus.com/doc/ascii/">http://www.cplusplus.com/doc/ascii/</a>. Note that these links are for the extra curious reader and we have already discussed enough in order to proceed.</p>
			<h3>Constants</h3>
			<p>Sometimes, we need to make sure that a value can never be changed. To achieve this, we can declare and initialize a <strong class="bold">constant</strong> using the <strong class="source-inline">const</strong> keyword:</p>
			<p class="source-code">const float PI = 3.141f;</p>
			<p class="source-code">const int PLANETS_IN_SOLAR_SYSTEM = 8;</p>
			<p class="source-code">const int NUMBER_OF_ENEMIES = 2000;</p>
			<p>It is convention to declare constants in all uppercase. The values of the preceding constants can never be altered. We will see some constants in action in <a href="B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a><em class="italic">, Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics</em>.</p>
			<h3>Declaring and initializing user-defined types</h3>
			<p>We have already seen examples of how we can declare and initialize some SFML defined types. It is because of the way that we can create/define these types (classes) so flexibly that the way we declare and initialize them is also so varied. Here are a couple of reminders for declaring and initializing user-defined types from the previous chapter.</p>
			<p>Create an object of the <strong class="source-inline">VideoMode</strong> type called <strong class="source-inline">vm</strong> and initialize it with two <strong class="source-inline">int</strong> values, <strong class="source-inline">1920</strong> and <strong class="source-inline">1080</strong>:</p>
			<p class="source-code">// Create a video mode object</p>
			<p class="source-code">VideoMode vm(1920, 1080);</p>
			<p>Create an object of the <strong class="source-inline">Texture</strong> type called <strong class="source-inline">textureBackground</strong>, but don't do any initialization:</p>
			<p class="source-code">// Create a texture to hold a graphic on the GPU</p>
			<p class="source-code">Texture textureBackground;</p>
			<p>Note that it is possible (in fact, very likely) that even though we are not suggesting any specific values with which to initialize <strong class="source-inline">textureBackground</strong>, some setup of variables may take place internally. Whether or not an object needs/has the option of giving initialization values at this point is entirely dependent on how the class is coded and is almost infinitely flexible. This further suggests that, when we get to write our own classes, there will be some complexity. Fortunately, this also means we will have significant power to design our types/classes to be just what we need to make our games! Add this huge flexibility to the power of the SFML designed classes and the potential for our games is almost limitless.</p>
			<p>We will see a few more user created types/classes provided by SFML in this chapter too, and loads more throughout this book.</p>
			<p>We have now seen that a variable is a named location in the computer's memory and that a variable can be a simple integer through to a more powerful object. Now that we know we can initialize these variables, we will look at how we can manipulate the values they hold.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor074"/>Manipulating variables</h1>
			<p>At this point, we know exactly what variables are, the main types they can be, and how to declare and initialize them. We still can't do that much with them, however. We need to manipulate our variables; add them; take them away; and multiply, divide, and test them.</p>
			<p>First, we will deal with how we can manipulate them and then we will look at how and why we test them.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>C++ arithmetic and assignment operators </h2>
			<p>In order to manipulate variables, C++ has a range of <strong class="bold">arithmetic operators </strong>and<strong class="bold"> assignment operators</strong>. Fortunately, most arithmetic and assignment operators are quite intuitive to use and those that aren't are quite easy to explain. To get us started, let's look at a table of arithmetic operators, followed by a table of assignment operators, all of which we will regularly use throughout this book:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B14278_02_2.jpg" alt=""/>
				</div>
			</div>
			<p>And now for the assignment operators:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B14278_02_3.jpg" alt=""/>
				</div>
			</div>
			<p class="callout-heading">Important note</p>
			<p class="callout">Technically, all of these operators, except for <strong class="source-inline">=</strong>, <strong class="source-inline">--</strong>, and <strong class="source-inline">++</strong>, are called <strong class="bold">compound assignment operators</strong> because they comprise more than one operator.</p>
			<p>Now that we have seen a good range of arithmetic and assignment operators, we can actually look at how we can manipulate our variables by combining operators, variables, and values to form <strong class="bold">expressions</strong>.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor076"/>Getting things done with expressions</h2>
			<p><strong class="bold">Expressions</strong> are the result of combining variables, operators, and values. Using expressions, we can arrive at a result. Furthermore, as we will soon see, we can use an expression in a test. These tests can be used to decide what our code should do next. First, let's look at some simple expressions we might see in our game code. Here is one example of a simple expression:</p>
			<p class="source-code">// Player gets a new high score</p>
			<p class="source-code">hiScore = score;</p>
			<p>In the preceding code, the value held in the <strong class="source-inline">score</strong> variable is used to change the value in the <strong class="source-inline">hiScore</strong> variable. The two variables now hold the same value, but note that they are still separate and distinct variables (places in memory). This would likely be just what we need when the player beats a high score. Here is another example:</p>
			<p class="source-code">// Set the score to 100</p>
			<p class="source-code">score = 100;</p>
			<p>Let's take a look at the addition operator, which used in conjunction with the assignment operator:</p>
			<p class="source-code">// Add to the score when an alien is shot</p>
			<p class="source-code">score = aliensShot + wavesCleared;</p>
			<p>In the preceding code, the values held by <strong class="source-inline">aliensShot</strong> and <strong class="source-inline">wavesCleared</strong> are added together using the addition operator and then the result of the addition is assigned to the <strong class="source-inline">score</strong> variable. Now, let's take a look at the following code:</p>
			<p class="source-code">// Add 100 to whatever the score currently is</p>
			<p class="source-code">score = score + 100;</p>
			<p>Note that it is perfectly acceptable to use the same variable on both sides of an operator. In the preceding code, 100 is added to the value held by the <strong class="source-inline">score</strong> variable and then this new value is then assigned back into <strong class="source-inline">score</strong>.</p>
			<p>Look at the subtraction operator in conjunction with the assignment operator. The following code subtracts the value on the right-hand side of the subtraction operator from the value on the left. It is usually used in conjunction with the assignment operator, perhaps like so:</p>
			<p class="source-code">// Uh oh lost a life</p>
			<p class="source-code">lives = lives - 1;</p>
			<p>It can also be used like this:</p>
			<p class="source-code">// How many aliens left at end of game</p>
			<p class="source-code">aliensRemaining = aliensTotal - aliensDestroyed;</p>
			<p>Next, we will see how we might use the division operator. The following code divides the number on the left by the number on the right. Again, it is usually used with the assignment operator, like this:</p>
			<p class="source-code">// Make the remaining hit points lower based on swordLevel</p>
			<p class="source-code">hitPoints = hitPoints / swordLevel;</p>
			<p>It can also be used like this:</p>
			<p class="source-code">// Give something, but not everything, back for recycling a block</p>
			<p class="source-code">recycledValueOfBlock = originalValue / .9f;</p>
			<p>Obviously, in the previous example, the <strong class="source-inline">recycledValueOfBlock</strong> variable will need to be of the <strong class="source-inline">float</strong> type to accurately store the answer to a calculation like that.</p>
			<p>Perhaps unsurprisingly, we could use the multiplication operator like this:</p>
			<p class="source-code">// answer is equal to 100, of course</p>
			<p class="source-code">answer = 10 * 10;</p>
			<p>It can also be used like this:</p>
			<p class="source-code">// biggerAnswer = 1000, of course</p>
			<p class="source-code">biggerAnswer = 10 * 10 * 10;</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">As a side note, have you ever wondered how C++ got its name? C++ is an extension of the C language. Its inventor, <strong class="bold">Bjarne Stroustrup</strong>, originally called it "C with classes", but the name evolved. If you are interested, you can read the story of C++ at <a href="http://www.cplusplus.com/info/history/">http://www.cplusplus.com/info/history/</a>.</p>
			<p>Now, let's look at the increment operator in action. This is a neat way to add 1 to the value of one of our game's variables.</p>
			<p>Take a look at the following code:</p>
			<p class="source-code">// Add one to myVariable</p>
			<p class="source-code">myVariable = myVariable + 1;</p>
			<p>The preceding code gives the same result as the following code:</p>
			<p class="source-code">// Much neater and quicker</p>
			<p class="source-code">myVariable ++;</p>
			<p>The decrement operator, <strong class="source-inline">--</strong>, is, you guessed it, a quick way to subtract 1 from something, like so:</p>
			<p class="source-code">playerHealth = playerHealth -1;</p>
			<p>This is the same as doing the following:</p>
			<p class="source-code">playerHealth --;</p>
			<p>Let's look at a few more operators in action and then we can get back to building the Timber!!! game. The addition, subtraction, multiplication, and division operators each have a related operator that combines their primary function (adding, subtracting, and so on) with assignment. They allow us to use more concise code when we want to perform the primary function of the operator, followed by assignment. Have a look at the four examples (one for each operator) that follow:</p>
			<p class="source-code">someVariable = 10;</p>
			<p class="source-code">// Multiply the variable by 10 and put the answer </p>
			<p class="source-code">// back in the variable</p>
			<p class="source-code">someVariable *= 10;</p>
			<p class="source-code">// someVariable now equals 100</p>
			<p class="source-code">// Divide someVariable by 5 put the answer back </p>
			<p class="source-code">// into the variable</p>
			<p class="source-code">someVariable /= 5;</p>
			<p class="source-code">// someVariable now equals 20</p>
			<p class="source-code">// Add 3 to someVariable and put the answer back </p>
			<p class="source-code">// into the variable</p>
			<p class="source-code">someVariable += 3;</p>
			<p class="source-code">// someVariable now equals 23</p>
			<p class="source-code">// Take 25 from someVariable and put the answer back </p>
			<p class="source-code">// into the variable</p>
			<p class="source-code">someVariable -= 25;</p>
			<p class="source-code">// someVariable now equals -2</p>
			<p>In the preceding four examples, we can see that the <strong class="source-inline">*=</strong>, <strong class="source-inline">/=</strong>, <strong class="source-inline">+=</strong>, and <strong class="source-inline">-=</strong> operators can be used to shorten the syntax when we want to use one of the four arithmetic operators followed by an assignment. We will do this quite a bit throughout this book. </p>
			<p>It's time to add some more sprites to our game.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor077"/>Adding clouds, a tree, and a buzzing bee</h1>
			<p>In this section, we will add clouds, a tree, and a buzzing bee to our Timber!!! game. First, we will add a tree. This is going to be easy. The reason for this is because the tree doesn't move. We will use the same procedure that we used in the previous chapter when we drew the background. The bee and the clouds will also be easy to draw in their starting positions, but we will need to combine what we have just learned about manipulating variables with some new C++ topics to make them move.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor078"/>Preparing the tree</h2>
			<p>Let's get ready to draw the tree! Add the following highlighted code. Notice the unhighlighted code, which is the code we have already written. This should help you to identify that the new code should be typed immediately after we set the position of the background but before the start of the main game loop. We will provide a recap regarding what is going on in the new code after we have added it:</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Create a video mode object</p>
			<p class="source-code">    VideoMode vm(1920, 1080);</p>
			<p class="source-code">    // Create and open a window for the game</p>
			<p class="source-code">    RenderWindow window(vm, "Timber!!!", Style::Fullscreen);</p>
			<p class="source-code">    // Create a texture to hold a graphic on the GPU</p>
			<p class="source-code">    Texture textureBackground;</p>
			<p class="source-code">    // Load a graphic into the texture</p>
			<p class="source-code">    textureBackground.loadFromFile("graphics/background.png");</p>
			<p class="source-code">    // Create a sprite</p>
			<p class="source-code">    Sprite spriteBackground;</p>
			<p class="source-code">    // Attach the texture to the sprite</p>
			<p class="source-code">    spriteBackground.setTexture(textureBackground);</p>
			<p class="source-code">    // Set the spriteBackground to cover the screen</p>
			<p class="source-code">    spriteBackground.setPosition(0, 0);</p>
			<p class="source-code"><strong class="bold">    // Make a tree sprite</strong></p>
			<p class="source-code"><strong class="bold">    Texture textureTree;</strong></p>
			<p class="source-code"><strong class="bold">    textureTree.loadFromFile("graphics/tree.png");</strong></p>
			<p class="source-code"><strong class="bold">    Sprite spriteTree;</strong></p>
			<p class="source-code"><strong class="bold">    spriteTree.setTexture(textureTree);</strong></p>
			<p class="source-code"><strong class="bold">    spriteTree.setPosition(810, 0);</strong></p>
			<p class="source-code">    </p>
			<p class="source-code">    while (window.isOpen())</p>
			<p class="source-code">    {</p>
			<p>This is what the following five lines of code (excluding the comment) do:</p>
			<ol>
				<li>First, we create an object of the <strong class="source-inline">Texture</strong> type called <strong class="source-inline">textureTree</strong>. </li>
				<li>Next, we load a graphic into the texture from the <strong class="source-inline">tree.png</strong> graphics file.</li>
				<li>Then, we declare an object of the <strong class="source-inline">Sprite</strong> type called <strong class="source-inline">spriteTree</strong></li>
				<li>After, we associate <strong class="source-inline">textureTree</strong> with <strong class="source-inline">spriteTree</strong>. Whenever we draw <strong class="source-inline">spriteTree</strong>, it will show the <strong class="source-inline">textureTree</strong> texture, which is a neat tree graphic.</li>
				<li>Finally, we set the position of the tree using the coordinates <strong class="source-inline">810</strong> on the <em class="italic">x</em> axis and <strong class="source-inline">0</strong> on the <em class="italic">y</em> axis. </li>
			</ol>
			<p>The tree sprite is ready to draw, along with the tree texture. Let's move on to the bee object, which is handled in an almost identical manner.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/>Preparing the bee</h2>
			<p>Preparing the bee sprite is very similar but not identical to preparing the tree sprite. The difference between the following code and the tree code is small but important. Since the bee needs to move, we also declare two bee-related variables. Add the following highlighted code and see whether you can work out how we might use the <strong class="source-inline">beeActive</strong> and <strong class="source-inline">beeSpeed</strong> variables:</p>
			<p class="source-code">// Make a tree sprite</p>
			<p class="source-code">Texture textureTree;</p>
			<p class="source-code">textureTree.loadFromFile("graphics/tree.png");</p>
			<p class="source-code">Sprite spriteTree;</p>
			<p class="source-code">spriteTree.setTexture(textureTree);</p>
			<p class="source-code">spriteTree.setPosition(810, 0);</p>
			<p class="source-code"><strong class="bold">// Prepare the bee</strong></p>
			<p class="source-code"><strong class="bold">Texture textureBee;</strong></p>
			<p class="source-code"><strong class="bold">textureBee.loadFromFile("graphics/bee.png");</strong></p>
			<p class="source-code"><strong class="bold">Sprite spriteBee;</strong></p>
			<p class="source-code"><strong class="bold">spriteBee.setTexture(textureBee);</strong></p>
			<p class="source-code"><strong class="bold">spriteBee.setPosition(0, 800);</strong></p>
			<p class="source-code"><strong class="bold">// Is the bee currently moving?</strong></p>
			<p class="source-code"><strong class="bold">bool beeActive = false;</strong></p>
			<p class="source-code"><strong class="bold">// How fast can the bee fly</strong></p>
			<p class="source-code"><strong class="bold">float beeSpeed = 0.0f;</strong></p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p>We create a bee in the same way we created a background and a tree. We use a <strong class="source-inline">Texture</strong>, a <strong class="source-inline">Sprite</strong>, and associate the two. Note that, in the previous bee code, there's some new code we haven't seen before. There is a <strong class="source-inline">bool</strong> variable for determining whether the bee is active. Remember that a <strong class="source-inline">bool</strong> variable can be either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. We initialize <strong class="source-inline">beeActive</strong> to <strong class="source-inline">false</strong> for now.</p>
			<p>Next, we declare a new <strong class="source-inline">float</strong> variable called <strong class="source-inline">beeSpeed</strong>. This will hold the speed in pixels per second that our bee will fly across the screen at.</p>
			<p>Soon, we will see how we use these two new variables to move the bee. Before we do, let's set up some clouds in an almost identical manner.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor080"/>Preparing the clouds</h2>
			<p>Add the following highlighted code. Study the new code and try and work out what it will do:</p>
			<p class="source-code">// Prepare the bee</p>
			<p class="source-code">Texture textureBee;</p>
			<p class="source-code">textureBee.loadFromFile("graphics/bee.png");</p>
			<p class="source-code">Sprite spriteBee;</p>
			<p class="source-code">spriteBee.setTexture(textureBee);</p>
			<p class="source-code">spriteBee.setPosition(0, 800);</p>
			<p class="source-code">// Is the bee currently moving?</p>
			<p class="source-code">bool beeActive = false;</p>
			<p class="source-code">// How fast can the bee fly</p>
			<p class="source-code">float beeSpeed = 0.0f;</p>
			<p class="source-code"><strong class="bold">// make 3 cloud sprites from 1 texture</strong></p>
			<p class="source-code"><strong class="bold">Texture textureCloud;</strong></p>
			<p class="source-code"><strong class="bold">// Load 1 new texture</strong></p>
			<p class="source-code"><strong class="bold">textureCloud.loadFromFile("graphics/cloud.png");</strong></p>
			<p class="source-code"><strong class="bold">// 3 New sprites with the same texture</strong></p>
			<p class="source-code"><strong class="bold">Sprite spriteCloud1;</strong></p>
			<p class="source-code"><strong class="bold">Sprite spriteCloud2;</strong></p>
			<p class="source-code"><strong class="bold">Sprite spriteCloud3;</strong></p>
			<p class="source-code"><strong class="bold">spriteCloud1.setTexture(textureCloud);</strong></p>
			<p class="source-code"><strong class="bold">spriteCloud2.setTexture(textureCloud);</strong></p>
			<p class="source-code"><strong class="bold">spriteCloud3.setTexture(textureCloud);</strong></p>
			<p class="source-code"><strong class="bold">// Position the clouds on the left of the screen</strong></p>
			<p class="source-code"><strong class="bold">// at different heights</strong></p>
			<p class="source-code"><strong class="bold">spriteCloud1.setPosition(0, 0);</strong></p>
			<p class="source-code"><strong class="bold">spriteCloud2.setPosition(0, 250);</strong></p>
			<p class="source-code"><strong class="bold">spriteCloud3.setPosition(0, 500);</strong></p>
			<p class="source-code"><strong class="bold">// Are the clouds currently on screen?</strong></p>
			<p class="source-code"><strong class="bold">bool cloud1Active = false;</strong></p>
			<p class="source-code"><strong class="bold">bool cloud2Active = false;</strong></p>
			<p class="source-code"><strong class="bold">bool cloud3Active = false;</strong></p>
			<p class="source-code"><strong class="bold">// How fast is each cloud?</strong></p>
			<p class="source-code"><strong class="bold">float cloud1Speed = 0.0f;</strong></p>
			<p class="source-code"><strong class="bold">float cloud2Speed = 0.0f;</strong></p>
			<p class="source-code"><strong class="bold">float cloud3Speed = 0.0f;</strong></p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p>The only thing about the code we have just added that might seem a little odd is that we have only one object of the <strong class="source-inline">Texture</strong> type. It is completely normal for multiple <strong class="source-inline">Sprite</strong> objects to share a texture. Once a <strong class="source-inline">Texture</strong> is stored in GPU memory, it can be associated with a <strong class="source-inline">Sprite</strong> object very quickly. It is only the initial loading of the graphic in the <strong class="source-inline">loadFromFile</strong> code that is a relatively slow operation. Of course, if we wanted three different shaped clouds, then we would need three textures.</p>
			<p>Apart from the minor texture issue, the code we have just added is nothing new compared to the bee. The only difference is that there are three cloud sprites, three <strong class="source-inline">bool </strong>variables to determine whether each cloud is active, and three <strong class="source-inline">float</strong> variables to hold the speed for each cloud.</p>
			<p>At this stage, all of the sprites and variables have been prepared. We can now move on to drawing them.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor081"/>Drawing the tree, the bee, and the clouds</h2>
			<p>Finally, we can draw them all to the screen by adding the following highlighted code in the drawing section:</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p class="source-code">// Clear everything from the last run frame</p>
			<p class="source-code">window.clear();</p>
			<p class="source-code">// Draw our game scene here</p>
			<p class="source-code">window.draw(spriteBackground);</p>
			<p class="source-code"><strong class="bold">// Draw the clouds</strong></p>
			<p class="source-code"><strong class="bold">window.draw(spriteCloud1);</strong></p>
			<p class="source-code"><strong class="bold">window.draw(spriteCloud2);</strong></p>
			<p class="source-code"><strong class="bold">window.draw(spriteCloud3);</strong></p>
			<p class="source-code"><strong class="bold">// Draw the tree</strong></p>
			<p class="source-code"><strong class="bold">window.draw(spriteTree);</strong></p>
			<p class="source-code"><strong class="bold">// Draw the insect</strong></p>
			<p class="source-code"><strong class="bold">window.draw(spriteBee);</strong></p>
			<p class="source-code">// Show everything we just drew</p>
			<p class="source-code">window.display();</p>
			<p>Drawing the three clouds, the bee, and the tree is done in the same way that the background was drawn. Note, however, the order in which we draw the different objects to the screen. We must draw all of the graphics after the background, or they will be covered, and we must draw the clouds before the tree, or they will look a bit odd drifting in front of the tree. The bee would look OK either in front or behind the tree. I opted to draw the bee in front of the tree so that it can try and distract our lumberjack, a bit like a real bee might.</p>
			<p>Run Timber!!! and gaze in awe at the tree, three clouds, and a bee that… don't do anything! They look like they are lining up for a race; a race where the bee has to go backward:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B14278_02_01.jpg" alt=""/>
				</div>
			</div>
			<p>Using what we know about operators, we could try and move the graphics we have just added, but there's a problem. The problem is that real clouds and bees move in a non-uniform manner. They don't have a set speed or location, with these elements determined by factors such as wind speed or how much of a hurry the bee might be in. To the casual observer, the path they take and their speed appear to be <em class="italic">random</em>.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor082"/>Random numbers</h1>
			<p><strong class="bold">Random numbers</strong> are useful for lots of reasons in games—perhaps determining what card the player is dealt or how much damage within a certain range is subtracted from an enemy's health. We will now learn how to generate random numbers to determine the starting location and speed of the bee and the clouds.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor083"/>Generating random numbers in C++</h2>
			<p>To generate random numbers, we will need to use some more C++ functions—two more, to be precise. Don't add any code to the game yet. Let's just look at the syntax and the steps that are required with some hypothetical code.</p>
			<p>Computers can't genuinely pick random numbers. They can only use <strong class="bold">algorithms</strong>/<strong class="bold">calculations</strong> to pick a number that <em class="italic">appears</em> to be random. So that this algorithm doesn't constantly return the same value, we must <strong class="bold">seed</strong> the random number generator. The seed can be any integer number, although it must be a different seed each time you require a unique random number. Look at the following code, which seeds the random number generator:</p>
			<p class="source-code">// Seed the random number generator with the time</p>
			<p class="source-code">srand((int)time(0));</p>
			<p>The preceding code gets the time from the PC using the <strong class="source-inline">time</strong> function, that is, <strong class="source-inline">time(0)</strong>. The call to the <strong class="source-inline">time</strong> function is enclosed as the value to be sent to the <strong class="source-inline">srand</strong> function. The result of this is that the current time is used as the seed. </p>
			<p>The previous code is made to look a little more complicated because of the slightly unusual looking <strong class="source-inline">(int)</strong> syntax. What this does is convert/cast the value that's returned from <strong class="source-inline">time</strong> into an <strong class="source-inline">int</strong>. This is required by the <strong class="source-inline">srand</strong> function in this situation.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The term that's used to describe a conversion from one type to another is <strong class="bold">cast</strong>.</p>
			<p>So, in summary, the previous line of code does the following:</p>
			<ul>
				<li>Gets the time using <strong class="source-inline">time</strong></li>
				<li>Converts it into an <strong class="source-inline">int</strong></li>
				<li>Sends this resulting value to <strong class="source-inline">srand</strong>, which seeds the random number generator</li>
			</ul>
			<p>The time is, of course, always changing. This makes the <strong class="source-inline">time</strong> function a great way to seed the random number generator. However, think about what might happen if we seed the random number generator more than once and in such quick succession that <strong class="source-inline">time</strong> returns the same value. We will see and solve this problem when we animate our clouds.</p>
			<p>At this stage, we can create the random number, between a range, and save it to a variable for later use, like so:</p>
			<p class="source-code">// Get the random number &amp; save it to a variable called number</p>
			<p class="source-code">int number = (rand() % 100);</p>
			<p>Notice the odd-looking way we assign a value to <strong class="source-inline">number</strong>. By using the Modulo operator (<strong class="source-inline">%</strong>) and the value of <strong class="source-inline">100</strong>, we are asking for the remainder, after dividing the number returned from <strong class="source-inline">rand</strong>, by 100. When you divide by 100, the highest number you can possibly have as a remainder is 99. The lowest number possible is 0. Therefore, the previous code will generate a number between 0 and 99 inclusive. This knowledge will be useful for generating a random speed and starting location for our bees and clouds. </p>
			<p>But before we can implement our random bees and clouds, we will need to learn how to make decisions in C++.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/>Making decisions with if and else</h1>
			<p>The C++ <strong class="bold">if</strong> and <strong class="bold">else</strong> keywords are what allow us to make decisions. We have already seen <strong class="source-inline">if</strong> in action in the previous chapter when we detected whether the player had pressed the <em class="italic">Esc</em> key each frame:</p>
			<p class="source-code">if (Keyboard::isKeyPressed(Keyboard::Escape))</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.close();</p>
			<p class="source-code">}</p>
			<p>So far, we have seen how we can use arithmetic and assignment operators to create expressions. Now, we will look at some new operators.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor085"/>Logical operators</h2>
			<p><strong class="bold">Logical operators</strong> are going to help us to make decisions by building expressions that can be tested for a value of either true or false. At first, this might seem like quite a narrow choice and insufficient for the kind of choices that might be needed in an advanced PC game. Once we dig a little deeper, we will see that we can make all of the required decisions we will need with just a few of the logical operators.</p>
			<p>Here is a table of the most useful logical operators. Look at them and the associated examples, and then we will see how we can put them to use:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B14278_02_4.jpg" alt=""/>
				</div>
			</div>
			<p>Let's take a look at the C++ <strong class="source-inline">if</strong> and <strong class="source-inline">else</strong> keywords, which will allow us to put all of these logical operators to good use.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor086"/>C++ if and else</h2>
			<p>Let's make the previous examples less abstract. Meet the C++ <strong class="bold">if</strong> keyword. We will use <strong class="source-inline">if</strong> and a few operators along with a small story to demonstrate their use. Next follows a made-up military situation that will hopefully be less abstract than the previous examples.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor087"/>If they come over the bridge, shoot them!</h2>
			<p>The captain is dying and, knowing that his remaining subordinates are not very experienced, he decides to write a C++ program to convey his last orders for after he has died. The troops must hold one side of a bridge while waiting for reinforcements. </p>
			<p>The first command the captain wants to make sure his troops understand is this:</p>
			<p>"If they come over the bridge, shoot them!"</p>
			<p>So, how do we simulate this situation in C++? We need a <strong class="source-inline">bool</strong> variable, <strong class="source-inline">isComingOverBridge</strong>. The following bit of code assumes that the <strong class="source-inline">isComingOverBridge</strong> variable has been declared and initialized to either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>.</p>
			<p>We can then use <strong class="source-inline">if</strong> like this: </p>
			<p class="source-code">if(isComingOverBridge)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Shoot them</p>
			<p class="source-code">}</p>
			<p>If the <strong class="source-inline">isComingOverBridge</strong> variable is equal to <strong class="source-inline">true</strong>, the code inside the opening and closing curly braces <strong class="source-inline">{...}</strong> will run. If not, the program continues after the <strong class="source-inline">if</strong> block and without running the code within it.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor088"/>Shoot them … or else do this instead</h2>
			<p>The captain also wants to tell his troops to stay put if the enemy is not coming over the bridge.</p>
			<p>Now, we can introduce another C++ keyword, <strong class="bold">else</strong>. When we want to explicitly do something when the <strong class="source-inline">if</strong> does <strong class="bold">not</strong> evaluate to <strong class="source-inline">true</strong>, we can use <strong class="source-inline">else</strong>.</p>
			<p>For example, to tell the troops to stay put if the enemy is not coming over the bridge, we could write the following code:</p>
			<p class="source-code">if(isComingOverBridge)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Shoot them</p>
			<p class="source-code">}</p>
			<p class="source-code">else</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Hold position</p>
			<p class="source-code">}</p>
			<p>The captain then realized that the problem wasn't as simple as he first thought. What if the enemy comes over the bridge, but has too many troops? His squad would be overrun and slaughtered. So, he came up with the following code (we'll use some variables as well this time):</p>
			<p class="source-code">bool isComingOverBridge;</p>
			<p class="source-code">int enemyTroops;</p>
			<p class="source-code">int friendlyTroops;</p>
			<p class="source-code">// Initialize the previous variables, one way or another</p>
			<p class="source-code">// Now the if</p>
			<p class="source-code">if(isComingOverBridge &amp;&amp; friendlyTroops &gt; enemyTroops)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // shoot them</p>
			<p class="source-code">}</p>
			<p class="source-code">else if(isComingOverBridge &amp;&amp; friendlyTroops &lt; enemyTroops) </p>
			<p class="source-code">{</p>
			<p class="source-code">    // blow the bridge</p>
			<p class="source-code">}</p>
			<p class="source-code">else</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Hold position</p>
			<p class="source-code">}</p>
			<p>The preceding code has three possible paths of execution. First, if the enemy is coming over the bridge and the friendly troops are greater in number:</p>
			<p class="source-code">if(isComingOverBridge &amp;&amp; friendlyTroops &gt; enemyTroops)</p>
			<p>The second occurs if the enemy troops are coming over the bridge but outnumber the friendly troops:</p>
			<p class="source-code">else if(isComingOveBridge &amp;&amp; friendlyTroops &lt; enemyTroops)</p>
			<p>Then, the third and final possible outcome, which will execute if neither of the others is <strong class="source-inline">true</strong>, is captured by the final <strong class="source-inline">else</strong>, without an <strong class="source-inline">if</strong> condition.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor089"/>Reader challenge</h2>
			<p>Can you spot a flaw with the preceding code? One that might leave a bunch of inexperienced troops in complete disarray? The possibility of the enemy troops and friendly troops being exactly equal in number has not been handled explicitly and would therefore be handled by the final <strong class="source-inline">else</strong>. The final <strong class="source-inline">else</strong> is meant for when there are no enemy troops. I guess any self-respecting captain would expect his troops to fight in this situation. He could change the first <strong class="source-inline">if</strong> statement to accommodate this possibility, like so:</p>
			<p class="source-code">if(isComingOverBridge &amp;&amp; friendlyTroops <strong class="bold">&gt;= </strong> enemyTroops)</p>
			<p>Finally, the captain's last concern was that if the enemy came over the bridge waving the white flag of surrender and were promptly slaughtered, then his men would end up as war criminals. The C++ code that was needed was obvious. Using the <strong class="source-inline">wavingWhiteFlag</strong> Boolean variable, he wrote this test:</p>
			<p class="source-code">if (wavingWhiteFlag)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Take prisoners</p>
			<p class="source-code">}</p>
			<p>But where to put this code was less clear. In the end, the captain opted for the following nested solution and changed the test for <strong class="source-inline">wavingWhiteFlag</strong> to logical NOT, like this:</p>
			<p class="source-code">if (!wavingWhiteFlag)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // not surrendering so check everything else	</p>
			<p class="source-code">    if(isComingOverTheBridge &amp;&amp; friendlyTroops &gt;= enemyTroops)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // shoot them</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    else if(isComingOverTheBridge &amp;&amp; friendlyTroops &lt; enemyTroops) </p>
			<p class="source-code">    {</p>
			<p class="source-code">        // blow the bridge</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">else</p>
			<p class="source-code">{</p>
			<p class="source-code">    // this is the else for our first if</p>
			<p class="source-code">    // Take prisoners</p>
			<p class="source-code">}</p>
			<p class="source-code">// Holding position</p>
			<p>This demonstrates that we can nest <strong class="source-inline">if</strong> and <strong class="source-inline">else</strong> statements inside one another to create quite deep and detailed decisions. </p>
			<p>We could go on making more and more complicated decisions with <strong class="source-inline">if</strong> and <strong class="source-inline">else</strong> but what we have seen is more than enough as an introduction. It is probably worth pointing out, that often, there is more than one way to arrive at a solution to a problem. The <em class="italic">right</em> way will usually be the way that solves the problem in the clearest and simplest manner.</p>
			<p>We are getting closer to having all of the C++ knowledge we need to be able to animate our clouds and bee. We have one final animation issue to discuss and then we can get back to the game.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor090"/>Timing</h1>
			<p>Before we can move the bee and the clouds, we need to consider timing. As we already know, the main game loop executes repeatedly until the player presses the <em class="italic">Escape</em> key.</p>
			<p>We have also learned that C++ and SFML are exceptionally fast. In fact, my aging laptop executes a simple game loop (like the current one) at around five thousand times per second.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/>The frame rate problem</h2>
			<p>Let's consider the speed of the bee. For the purpose of discussion, we could pretend that we are going to move it at 200 pixels per second. On a screen that is 1,920 pixels wide, it would take, very approximately, 10 seconds to cross the entire width, because 10 x 200 is 2,000 (near enough to 1,920).</p>
			<p>Furthermore, we know that we can position any of our sprites with <strong class="source-inline">setPosition(...,...)</strong>. We just need to put the x and the y coordinates in the parentheses.</p>
			<p>In addition to setting the position of a sprite, we can also get the current position of a sprite. To get the horizontal x coordinate of the bee for example, we would use the following code:</p>
			<p class="source-code">int currentPosition = spriteBee.getPosition().x;</p>
			<p>The current x coordinate of the bee is now stored in <strong class="source-inline">currentPosition</strong>. To move the bee to the right, we need to add the appropriate fraction of 200 (our intended speed) divided by 5,000 (the approximate frames per second on my laptop) to <strong class="source-inline">currentPosition</strong>, like this:</p>
			<p class="source-code">currentPosition += 200/5000;</p>
			<p>Now, we would use <strong class="source-inline">setPosition </strong>to move our bee. It would smoothly move from left to right by 200 divided by 5,000 pixels each frame. But there are two big problems with this approach.</p>
			<p>Frame rate is the number of times per second that our game loop is processed. That is, the number of times that we handle the players input, update the game objects, and draw them to the screen. We will expand on and discuss matters of frame rate now and throughout the rest of this book.</p>
			<p>The frame rate on my laptop might not always be constant. The bee might look like it is intermittently "boosting" its way across the screen.</p>
			<p>And of course, we want a wider audience for our game than just my laptop! Every PC's frame rate will vary, at least slightly. If you have an old PC, the bee will appear to be weighed down with lead, and if you have the latest gaming rig, it will probably be something of a blurry turbo bee.</p>
			<p>Fortunately, this problem is the same for every game, and SFML has provided a solution. The easiest way to understand this solution is to implement it.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor092"/>The SFML frame rate solution</h2>
			<p>We will now measure and use the frame rate to control our game. To get started with implementing this, add the following code just before the main game loop:</p>
			<p class="source-code">// How fast is each cloud?</p>
			<p class="source-code">float cloud1Speed = 0;</p>
			<p class="source-code">float cloud2Speed = 0;</p>
			<p class="source-code">float cloud3Speed = 0;</p>
			<p class="source-code">    </p>
			<p class="source-code"><strong class="bold">// Variables to control time itself</strong></p>
			<p class="source-code"><strong class="bold">Clock clock;</strong></p>
			<p class="source-code">while (window.isOpen())</p>
			<p class="source-code">{</p>
			<p>In the previous code, we declare an object of the <strong class="source-inline">Clock</strong> type and we name it <strong class="source-inline">clock</strong>. The class name starts with a capital letter and the object name (which we will actually use) starts with a lowercase letter. The object name is arbitrary, but <strong class="source-inline">clock</strong> seems like an appropriate name for, well, a clock. We will add some more time-related variables here soon as well.</p>
			<p>Now, in the update section of our game code, add the following highlighted code:</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Update the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p class="source-code"><strong class="bold">// Measure time</strong></p>
			<p class="source-code"><strong class="bold">Time dt = clock.restart();</strong></p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>The <strong class="source-inline">clock.restart()</strong> function, as you might expect, restarts the clock. We want to restart the clock every frame so that we can time how long each and every frame takes. In addition, however, it returns the amount of time that has elapsed since the last time we restarted the clock.</p>
			<p>As a result of this, in the previous code, we are declaring an object of the <strong class="source-inline">Time</strong> type called <strong class="source-inline">dt</strong> and using it to store the value returned by the <strong class="source-inline">clock.restart()</strong> function. </p>
			<p>Now, we have a <strong class="source-inline">Time</strong> object called <strong class="source-inline">dt</strong> that holds the amount of time that elapsed since the last time we updated the scene and restarted the clock. Maybe you can see where this is going? We will be using the elapsed time each frame to control how far we move the bee and the clouds.</p>
			<p>Let's add some more code to the game and use everything we have learned so far about manipulating variables, generating random numbers, the <strong class="source-inline">if</strong> keyword, and the <strong class="source-inline">else</strong> keyword. Then, we will see how we can overcome the framerate problem with a <strong class="source-inline">Clock</strong> object and <strong class="source-inline">dt</strong>. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="source-inline">dt</strong> stands for <strong class="bold">delta time</strong>, which is the time between two updates.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor093"/>Moving the clouds and the bee</h1>
			<p>Let's use the elapsed time since the last frame to breathe life into the bee and the clouds. This will solve the problem of having a consistent frame rate across different PCs.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor094"/>Giving life to the bee</h2>
			<p>The first thing we want to do is set up the bee at a certain height and a certain speed. We only want to do this when the bee is inactive. Due to this, we will wrap the following code in an <strong class="source-inline">if</strong> block. Examine and add the following highlighted code, and then we will discuss it:</p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Update the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p class="source-code">// Measure time</p>
			<p class="source-code">Time dt = clock.restart();</p>
			<p class="source-code"><strong class="bold">// Setup the bee</strong></p>
			<p class="source-code"><strong class="bold">if (!beeActive)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    // How fast is the bee</strong></p>
			<p class="source-code"><strong class="bold">    srand((int)time(0));</strong></p>
			<p class="source-code"><strong class="bold">    beeSpeed = (rand() % 200) + 200;</strong></p>
			<p class="source-code"><strong class="bold">    // How high is the bee</strong></p>
			<p class="source-code"><strong class="bold">    srand((int)time(0) * 10);</strong></p>
			<p class="source-code"><strong class="bold">    float height = (rand() % 500) + 500;</strong></p>
			<p class="source-code"><strong class="bold">    spriteBee.setPosition(2000, height);</strong></p>
			<p class="source-code"><strong class="bold">    beeActive = true;</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>Now, if the bee is not active, just like it won't be when the game first starts, <strong class="source-inline">if(!beeActive)</strong> will be <strong class="source-inline">true</strong> and the preceding code will do the following things, in this order:</p>
			<ul>
				<li>Seed the random number generator.</li>
				<li>Get a random number between 200 and 399 and assign the result to <strong class="source-inline">beeSpeed</strong>.</li>
				<li>Seed the random number generator again.</li>
				<li>Get a random number between 500 and 999 and assign the result to a new <strong class="source-inline">float</strong> variable called <strong class="source-inline">height</strong>.</li>
				<li>Set the position of the bee to <strong class="source-inline">2000</strong> on the x axis (just off-screen to the right) and to whatever <strong class="source-inline">height</strong> equals on the y axis.</li>
				<li>Set <strong class="source-inline">beeActive</strong> to true.<p class="callout-heading">Important note</p><p class="callout">Note that the <strong class="source-inline">height</strong> variable is the first variable we have ever declared inside the game loop. Furthermore, because it was declared inside an <strong class="source-inline">if</strong> block, it is actually "invisible" outside of the <strong class="source-inline">if</strong> block. This is fine for our use because once we have set the height of the bee, we don't need it anymore. This phenomenon that affects variables is called <strong class="bold">scope</strong>. We will explore this more fully in <a href="B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a><em class="italic">, Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics</em>.</p></li>
			</ul>
			<p>If we run the game, nothing will happen to the bee yet, but now the bee is active, we can write some code that runs when <strong class="source-inline">beeActive</strong> is <strong class="source-inline">true</strong>.</p>
			<p>Add the following highlighted code which, as you can see, executes whenever <strong class="source-inline">beeActive</strong> is <strong class="source-inline">true</strong>. This is because it follows with <strong class="source-inline">else</strong> after the <strong class="source-inline">if(!beeActive)</strong> block:</p>
			<p class="source-code">// Set up the bee</p>
			<p class="source-code">if (!beeActive)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // How fast is the bee</p>
			<p class="source-code">    srand((int)time(0) );</p>
			<p class="source-code">    beeSpeed = (rand() % 200) + 200;</p>
			<p class="source-code">    // How high is the bee</p>
			<p class="source-code">    srand((int)time(0) * 10);</p>
			<p class="source-code">    float height = (rand() % 1350) + 500;</p>
			<p class="source-code">    spriteBee.setPosition(2000, height);</p>
			<p class="source-code">    beeActive = true;</p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">else</strong></p>
			<p class="source-code"><strong class="bold">// Move the bee</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    spriteBee.setPosition(</strong></p>
			<p class="source-code"><strong class="bold">        spriteBee.getPosition().x - </strong></p>
			<p class="source-code"><strong class="bold">         (beeSpeed * dt.asSeconds()),</strong></p>
			<p class="source-code"><strong class="bold">        spriteBee.getPosition().y);</strong></p>
			<p class="source-code"><strong class="bold">    // Has the bee reached the left-hand edge of the screen?</strong></p>
			<p class="source-code"><strong class="bold">    if (spriteBee.getPosition().x &lt; -100)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Set it up ready to be a whole new bee next frame</strong></p>
			<p class="source-code"><strong class="bold">        beeActive = false;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>In the <strong class="source-inline">else</strong> block, the following things happen.</p>
			<p>The bee's position is changed using the following criteria. The <strong class="source-inline">setPosition</strong> function uses the <strong class="source-inline">getPosition</strong> function to get the current horizontal coordinate of the bee. It then subtracts <strong class="source-inline">beeSpeed * dt.asSeconds()</strong> from that coordinate.</p>
			<p>The <strong class="source-inline">beeSpeed</strong> variable value is many pixels per second and was randomly assigned in the previous <strong class="source-inline">if </strong>block. The value of <strong class="source-inline">dt.asSeconds()</strong> will be a fraction of 1 that represents how long the previous frame of animation took.</p>
			<p>Let's assume that the bee's current horizontal coordinate is <strong class="bold">1000</strong>. Now, suppose a basic PC loops at 5,000 frames per second. This would mean that <strong class="source-inline">dt.asSeconds</strong> would be <strong class="bold">0.0002</strong>. Now, let's also suppose that <strong class="source-inline">beeSpeed</strong> was set to the maximum <strong class="bold">399</strong> pixels per second. With this information, we can say that the code that determines the value that <strong class="source-inline">setPosition</strong> uses for the horizontal coordinate is as follows:</p>
			<p class="source-code">1000 - 0.0002 x 399</p>
			<p>Therefore, the new position on the horizontal axis for the bee would be 999.9202. We can see that the bee is very, very smoothly drifting to the left, at well under a pixel per frame. If the frame rate fluctuates, then the formula will produce a new value to suit. If we run the same code on a PC that only achieves 100 frames per second or a PC that achieves a million frames per second, the bee will move at the same speed. </p>
			<p>The <strong class="source-inline">setPosition</strong> function uses <strong class="source-inline">getPosition().y</strong> to keep the bee in exactly the same vertical coordinate throughout this cycle of being active.</p>
			<p>The final part of the code in the <strong class="source-inline">else</strong> block we just added is as follows:</p>
			<p class="source-code">// Has the bee reached the right hand edge of the screen?</p>
			<p class="source-code">if (<strong class="bold">spriteBee.getPosition().x &lt; -100</strong>)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Set it up ready to be a whole new bee next frame</p>
			<p class="source-code">    beeActive = false;</p>
			<p class="source-code">}</p>
			<p>This code tests, in each and every frame (when <strong class="source-inline">beeActive</strong> is <strong class="source-inline">true</strong>), whether the bee has disappeared off of the left-hand side of the screen. If the <strong class="source-inline">getPosition</strong> function returns less than -100, it will certainly be out of view of the player. When this occurs, <strong class="source-inline">beeActive</strong> is set to <strong class="source-inline">false</strong> and, on the next frame, a "new" bee will be set flying at a new random height and a new random speed.</p>
			<p>Try running the game and watch our bee dutifully fly from right to left and then come back to the right again at a new height and speed. It's almost like a new bee every time.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Of course, a real bee would stick around for ages and pester you while you're trying to concentrate on chopping the tree. We will make some smarter game characters in later projects.</p>
			<p>Now, we will get the clouds moving in a very similar way.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/>Blowing the clouds</h2>
			<p>The first thing we want to do is set up the first cloud at a certain height and a certain speed. We only want to do this when the cloud is inactive. Consequently, we will wrap the code that follows in an <strong class="source-inline">if</strong> block. Examine and add the following highlighted code, just after the code we added for the bee, and then we will discuss it. It is almost identical to the code we used on the bee:</p>
			<p class="source-code">else</p>
			<p class="source-code">// Move the bee</p>
			<p class="source-code">{</p>
			<p class="source-code">    spriteBee.setPosition(</p>
			<p class="source-code">        spriteBee.getPosition().x - </p>
			<p class="source-code">         (beeSpeed * dt.asSeconds()),</p>
			<p class="source-code">        spriteBee.getPosition().y);</p>
			<p class="source-code">    // Has the bee reached the right hand edge of the screen?</p>
			<p class="source-code">    if (spriteBee.getPosition().x &lt; -100)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Set it up ready to be a whole new bee next frame</p>
			<p class="source-code">        beeActive = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">// Manage the clouds</strong></p>
			<p class="source-code"><strong class="bold">// Cloud 1</strong></p>
			<p class="source-code"><strong class="bold">if (!cloud1Active)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    // How fast is the cloud</strong></p>
			<p class="source-code"><strong class="bold">    srand((int)time(0) * 10);</strong></p>
			<p class="source-code"><strong class="bold">    cloud1Speed = (rand() % 200);</strong></p>
			<p class="source-code"><strong class="bold">    // How high is the cloud</strong></p>
			<p class="source-code"><strong class="bold">    srand((int)time(0) * 10);</strong></p>
			<p class="source-code"><strong class="bold">    float height = (rand() % 150);</strong></p>
			<p class="source-code"><strong class="bold">    spriteCloud1.setPosition(-200, height);</strong></p>
			<p class="source-code"><strong class="bold">    cloud1Active = true;</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>The only difference between the code we have just added and the bee-related code is that we work on a different sprite and use different ranges for our random numbers. Also, we multiply by ten (<strong class="source-inline">* 10</strong> ) to the result returned by <strong class="source-inline">time(0)</strong> so that we are always guaranteed to get a different seed for each of the clouds. When we code the other cloud movement next, you will see that we use <strong class="source-inline">* 20</strong> and <strong class="source-inline">* 30</strong>, respectively.</p>
			<p>Now, we can act when the cloud is active. We will do so in the <strong class="source-inline">else</strong> block. Like the <strong class="source-inline">if</strong> block, the code is identical to that of the bee-related code, except that all of the code works on the cloud and not the bee:</p>
			<p class="source-code">// Manage the clouds</p>
			<p class="source-code">if (!cloud1Active)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // How fast is the cloud</p>
			<p class="source-code">    srand((int)time(0) * 10);</p>
			<p class="source-code">    cloud1Speed = (rand() % 200);</p>
			<p class="source-code">    // How high is the cloud</p>
			<p class="source-code">    srand((int)time(0) * 10);</p>
			<p class="source-code">    float height = (rand() % 150);</p>
			<p class="source-code">    spriteCloud1.setPosition(-200, height);</p>
			<p class="source-code">    cloud1Active = true;</p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">else</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    spriteCloud1.setPosition(</strong></p>
			<p class="source-code"><strong class="bold">        spriteCloud1.getPosition().x + </strong></p>
			<p class="source-code"><strong class="bold">        (cloud1Speed * dt.asSeconds()),</strong></p>
			<p class="source-code"><strong class="bold">        spriteCloud1.getPosition().y);</strong></p>
			<p class="source-code"><strong class="bold">    // Has the cloud reached the right hand edge of the screen?</strong></p>
			<p class="source-code"><strong class="bold">    if (spriteCloud1.getPosition().x &gt; 1920)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Set it up ready to be a whole new cloud next frame</strong></p>
			<p class="source-code"><strong class="bold">        cloud1Active = false;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>Now that we know what to do, we can duplicate the same code for the second and third clouds. Add the following highlighted code, which handles the second and third clouds, immediately after the code for the first cloud:</p>
			<p class="source-code">...</p>
			<p class="source-code"><strong class="bold">// Cloud 2</strong></p>
			<p class="source-code"><strong class="bold">if (!cloud2Active)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    // How fast is the cloud</strong></p>
			<p class="source-code"><strong class="bold">    srand((int)time(0) * 20);</strong></p>
			<p class="source-code"><strong class="bold">    cloud2Speed = (rand() % 200);</strong></p>
			<p class="source-code"><strong class="bold">    // How high is the cloud</strong></p>
			<p class="source-code"><strong class="bold">    srand((int)time(0) * 20);</strong></p>
			<p class="source-code"><strong class="bold">    float height = (rand() % 300) - 150;</strong></p>
			<p class="source-code"><strong class="bold">    spriteCloud2.setPosition(-200, height);</strong></p>
			<p class="source-code"><strong class="bold">    cloud2Active = true;</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code"><strong class="bold">else</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    spriteCloud2.setPosition(</strong></p>
			<p class="source-code"><strong class="bold">        spriteCloud2.getPosition().x + </strong></p>
			<p class="source-code"><strong class="bold">         (cloud2Speed * dt.asSeconds()),</strong></p>
			<p class="source-code"><strong class="bold">        spriteCloud2.getPosition().y);</strong></p>
			<p class="source-code"><strong class="bold">    // Has the cloud reached the right hand edge of the screen?</strong></p>
			<p class="source-code"><strong class="bold">    if (spriteCloud2.getPosition().x &gt; 1920)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Set it up ready to be a whole new cloud next frame</strong></p>
			<p class="source-code"><strong class="bold">        cloud2Active = false;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code"><strong class="bold">if (!cloud3Active)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    // How fast is the cloud</strong></p>
			<p class="source-code"><strong class="bold">    srand((int)time(0) * 30);</strong></p>
			<p class="source-code"><strong class="bold">    cloud3Speed = (rand() % 200);</strong></p>
			<p class="source-code"><strong class="bold">    // How high is the cloud</strong></p>
			<p class="source-code"><strong class="bold">    srand((int)time(0) * 30);</strong></p>
			<p class="source-code"><strong class="bold">    float height = (rand() % 450) - 150;</strong></p>
			<p class="source-code"><strong class="bold">    spriteCloud3.setPosition(-200, height);</strong></p>
			<p class="source-code"><strong class="bold">    cloud3Active = true;</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code"><strong class="bold">else</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    spriteCloud3.setPosition(</strong></p>
			<p class="source-code"><strong class="bold">        spriteCloud3.getPosition().x + </strong></p>
			<p class="source-code"><strong class="bold">        (cloud3Speed * dt.asSeconds()),</strong></p>
			<p class="source-code"><strong class="bold">        spriteCloud3.getPosition().y);</strong></p>
			<p class="source-code"><strong class="bold">    // Has the cloud reached the right hand edge of the screen?</strong></p>
			<p class="source-code"><strong class="bold">    if (spriteCloud3.getPosition().x &gt; 1920)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Set it up ready to be a whole new cloud next frame</strong></p>
			<p class="source-code"><strong class="bold">        cloud3Active = false;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">/*</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">Draw the scene</p>
			<p class="source-code">****************************************</p>
			<p class="source-code">*/</p>
			<p>Now, you can run the game and the clouds will randomly and continuously drift across the screen. The bee will also buzz from right to left before respawning once more back on the right. The following screenshot shows what we've achieved in this chapter:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B14278_02_02.jpg" alt=""/>
				</div>
			</div>
			<p class="callout-heading">Tip</p>
			<p class="callout">Does all of this cloud and bee handling seem a little bit repetitious? We will see how we could save lots of typing and make our code more readable as, in C++, there are ways of handling multiple instances of the same type of variable or object. One such way is called <strong class="bold">arrays</strong>, and we will learn about them in <a href="B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a><em class="italic">, Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics</em>. At the end of this project, once we have learned about arrays, we will discuss how we can improve our cloud code.</p>
			<p>Take a look at a few frequently asked questions related to the topics in this chapter.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor096"/>Summary</h1>
			<p>In this chapter, we learned that a variable is a named storage location in memory in which we can keep values of a specific type. The types include <strong class="source-inline">int</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">double</strong>, <strong class="source-inline">bool</strong>, <strong class="source-inline">String</strong>, and <strong class="source-inline">char</strong>.</p>
			<p>We can declare and initialize all of the variables we need to store the data for our game. Once we have our variables, we can manipulate them using the arithmetic and assignment operators, as well as use them in tests with the logical operators. Used in conjunction with the <strong class="source-inline">if</strong> and <strong class="source-inline">else</strong> keywords, we can branch our code depending on the current situation in the game.</p>
			<p>Using all of this new knowledge, we animated some clouds and a bee. In the next chapter, we will use these skills some more to add a <strong class="bold">Heads Up Display</strong> (<strong class="bold">HUD</strong>) and add more input options for the player, as well as represent time visually using a time-bar.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor097"/>FAQ</h1>
			<p>Q) Why do we set the bee to inactive when it gets to -100? Why not just zero since zero is the left-hand side of the window?</p>
			<p>A) The bee graphic is 60 pixels wide and its origin is at the top left pixel. As a result, when the bee is drawn with its origin at x equals zero, the entire bee graphic is still on screen for the player to see. By waiting until it is at -100, we can be sure it is out of the player's view.</p>
			<p>Q) How do I know how fast my game loop is?</p>
			<p>A) If you have a modern NVIDIA graphics card, you might be able to already by configuring your GeForce Experience overlay to show the frame rate. To measure this explicitly using our own code, however, we will need to learn a few more things. We will add the ability to measure and display the current frame rate in <a href="B14278_05_Final_AG_ePub.xhtml#_idTextAnchor138"><em class="italic">Chapter 5</em></a><em class="italic">, Collisions, Sound, and End Conditions – Making the Game Playable</em>.</p>
		</div>
	</body></html>