<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer067">
			<h1 id="_idParaDest-151"><a id="_idTextAnchor206"/>Assignment Answers</h1>
			<h1 id="_idParaDest-152"><em class="italic"><a id="_idTextAnchor207"/></em><a href="B18367_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, Introduction to Templates</h1>
			<p><strong class="bold">Question 1</strong></p>
			<p>Why do we need templates? What advantages do they provide?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>There are several benefits to using templates: they help us avoid writing repetitive code, they foster the creation of generic libraries, and they can help us write less and better code.</p>
			<p><strong class="bold">Question 2</strong></p>
			<p>How do you call a function that is a template? What about a class that is a template?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>A function that is a template is called a function template. Similarly, a class that is a template is called a class template.</p>
			<p><strong class="bold">Question 3</strong></p>
			<p>How many kinds of template parameters exist and what are they? </p>
			<p><strong class="bold">Answer</strong></p>
			<p>There are three kinds of template parameters: type template parameters, non-type template parameters, and template template parameters.</p>
			<p><strong class="bold">Question 4</strong></p>
			<p>What is partial specialization? What about full specialization?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Specialization is the technique of providing an alternative implementation for a template, called the primary template. Partial specialization is an alternative implementation provided for only some of the template parameters. A full specialization is an alternative implementation when arguments are provided for all the template parameters.</p>
			<p><strong class="bold">Question 5</strong></p>
			<p>What are the main disadvantages of using templates?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>The main disadvantages of using templates include the following: complex and cumbersome syntax, compiler errors that are often long and hard to read and understand, and increased compilation times.</p>
			<h1 id="_idParaDest-153"><em class="italic"><a id="_idTextAnchor208"/></em><a href="B18367_02_ePub.xhtml#_idTextAnchor024"><em class="italic">Chapter 2</em></a>, Template Fundamentals</h1>
			<p><strong class="bold">Question 1</strong></p>
			<p>What category of types can be used for non-type template parameters? </p>
			<p><strong class="bold">Answer</strong></p>
			<p>Non-type template parameters can only have structural types. Structure types are integral types, floating-point types (as of C++20), enumeration types, pointer types (either to objects or functions), pointer to member types (either to member objects or member functions), lvalue reference types (either to objects or functions), and literal class types that meet several requirements: all base classes are public and non-mutable, all non-static data members are public and non-mutable, and the types of all the base classes and the non-static data members are also structural types or arrays thereof. <strong class="source-inline">const</strong> and <strong class="source-inline">volatile</strong> qualified versions of these types are also allowed.</p>
			<p><strong class="bold">Question 2</strong></p>
			<p>Where are default template arguments not allowed?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Default template arguments cannot be used for parameter packs, in declarations of friend class templates, and in the declaration or definition of an explicit specialization of a function template or member function template.</p>
			<p><strong class="bold">Question 3</strong></p>
			<p>What is explicit instantiation declaration and how does it differ syntactically from explicit instantiation definition? </p>
			<p><strong class="bold">Answer</strong></p>
			<p>Explicit instantiation declaration is the way you can tell the compiler that the definition of a template instantiation is found in a different translation unit and that a new definition should not be generated. The syntax is the same as for explicit instantiation definitions, except that the <strong class="source-inline">extern</strong> keyword is used in front of the declaration.</p>
			<p><strong class="bold">Question 4</strong></p>
			<p>What is an alias template? </p>
			<p><strong class="bold">Answer</strong></p>
			<p>An alias template is a name that, unlike type aliases, which refer to another type, refers to a template or, in other words, a family of types. Alias templates are introduced with using declarations. They cannot be introduced with <strong class="source-inline">typedef</strong> declarations.</p>
			<p><strong class="bold">Question 5</strong></p>
			<p>What are template lambdas?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Template lambdas are an improved form of generic lambdas, introduced in C++20. They allow us to use the template syntax to explicitly specify the shape of the templatized function-call operator of the function object that the compiler is generating for a lambda expression.</p>
			<h1 id="_idParaDest-154"><em class="italic"><a id="_idTextAnchor209"/></em><a href="B18367_03_ePub.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, Variadic Templates</h1>
			<p><strong class="bold">Question 1</strong></p>
			<p>What are variadic templates and why are they useful? </p>
			<p><strong class="bold">Answer</strong></p>
			<p>Variadic templates are templates with a variable number of arguments. They allow us to write not only functions with variable number of arguments but also class templates, variable templates, and alias templates. Unlike other approaches, such as the use of the <strong class="source-inline">va_</strong> macros, they are type-safe, do not require macros, and do not require us to explicitly specify the number of arguments.</p>
			<p><strong class="bold">Question 2</strong></p>
			<p>What is a parameter pack? </p>
			<p><strong class="bold">Answer</strong></p>
			<p>There are two kinds of parameter packs: template parameter packs and function parameter packs. The former are template parameters that accept zero, one, or more template arguments. The latter are function parameters that accept zero, one, or more function arguments.</p>
			<p><strong class="bold">Question 3</strong></p>
			<p>What are the contexts where parameter packs can be expanded?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Parameter packs can be expanded in a multitude of contexts, as follows: template parameter lists, template argument lists, function parameter lists, function argument lists, parenthesized initializers, brace-enclosed initializers, base specifiers and member initializer lists, fold expressions, using declarations, lambda captures, the <strong class="source-inline">sizeof…</strong> operator, alignment specifiers, and attribute lists.</p>
			<p><strong class="bold">Question 4</strong></p>
			<p>What are fold expressions? </p>
			<p><strong class="bold">Answer</strong></p>
			<p>A fold expression is an expression involving a parameter pack that folds (or reduces) the elements of the parameter pack over a binary operator.</p>
			<p><strong class="bold">Question 5</strong></p>
			<p>What are the benefits of using fold expressions?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>The benefits of using fold expressions include having less and simpler code to write, fewer template instantiations, which lead to faster compile times, and potentially faster code, since multiple function calls are replaced with a single expression.</p>
			<h1 id="_idParaDest-155"><em class="italic"><a id="_idTextAnchor210"/></em><a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, Advanced Template Concepts</h1>
			<p><strong class="bold">Question 1</strong></p>
			<p>When is name lookup performed? </p>
			<p><strong class="bold">Answer</strong></p>
			<p>Name lookup is performed at the point of template instantiation for dependent names (those that depend on the type or value of a template parameter) and at the point of template definition for non-dependent names (those that don’t depend on template parameters).</p>
			<p><strong class="bold">Question 2</strong></p>
			<p>What are deduction guides? </p>
			<p><strong class="bold">Answer</strong></p>
			<p>Deduction guides are a mechanism that tells the compiler how to perform class template argument deduction. Deduction guides are fictional function templates representing constructor signatures of a fictional class type. If overload resolution fails on the constructed set of fictional function templates, then the program is ill-formed and an error is generated. Otherwise, the return type of the selected function template specialization becomes the deduced class template specialization.</p>
			<p><strong class="bold">Question 3</strong></p>
			<p>What are forwarding references? </p>
			<p><strong class="bold">Answer</strong></p>
			<p>A forward reference (also known as universal reference) is a reference in a template that behaves as an rvalue reference if an rvalue was passed as an argument or an lvalue reference if an lvalue was passed as an argument. A forwarding reference must have the <strong class="source-inline">T&amp;&amp;</strong> form such as in <strong class="source-inline">template &lt;typename T&gt; void f(T&amp;&amp;)</strong>. Forms such as <strong class="source-inline">T const &amp;&amp;</strong> or <strong class="source-inline">std::vector&lt;T&gt;&amp;&amp;</strong> do not represent forwarding references but normal rvalue references.</p>
			<p><strong class="bold">Question 4</strong></p>
			<p>What does <strong class="source-inline">decltype</strong> do? </p>
			<p><strong class="bold">Answer</strong></p>
			<p>The <strong class="source-inline">decltype</strong> specifier is a type specifier. It returns the type of an expression. It is usually used in templates together with the <strong class="source-inline">auto</strong> specifier in order to declare the return type of a function template that depends on its template arguments, or the return type of a function that wraps another function and returns the result from executing the wrapped function.</p>
			<p><strong class="bold">Question 5</strong></p>
			<p>What does <strong class="source-inline">std::declval</strong> do?</p>
			<p><strong class="bold">Answer</strong></p>
			<p><strong class="source-inline">std::declval</strong> is a utility function template from the <strong class="source-inline">&lt;utility&gt;</strong> header that adds an rvalue reference to its type template argument. It can only be used in unevaluated contexts (compile-time-only contexts that are not evaluated during runtime), and its purpose is to help with dependent type evaluation for types that do not have a default constructor or one that cannot be accessed because it’s private or protected.</p>
			<h1 id="_idParaDest-156"><em class="italic"><a id="_idTextAnchor211"/></em><a href="B18367_05_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, Type Traits and Conditional Compilation</h1>
			<p><strong class="bold">Question 1</strong></p>
			<p>What are type traits?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Type traits are small class templates that enable us to either query properties of types or perform transformations of types.</p>
			<p><strong class="bold">Question 2</strong></p>
			<p>What is SFINAE? </p>
			<p><strong class="bold">Answer</strong></p>
			<p><strong class="bold">SFINAE</strong> is an acronym for <strong class="bold">Substitution Failure Is Not An Error</strong>. This is a rule for template substitution and works as follows: when the compiler encounters the use of a function template, it substitutes the arguments in order to instantiate the template; if an error occurs at this point, it is not regarded as an ill-formed code, only as a deduction failure. As a result, the function is removed from the overload set instead of causing an error. Therefore, an error only occurs if there is no match in the overload set for a particular function call.</p>
			<p><strong class="bold">Question 3</strong></p>
			<p>What is <strong class="source-inline">constexpr if</strong>? </p>
			<p><strong class="bold">Answer</strong></p>
			<p><strong class="source-inline">constexpr if</strong> is a compile-time version of the <strong class="source-inline">if</strong> statement. The syntax for it is <strong class="source-inline">if</strong> <strong class="source-inline">constexpr(condition)</strong>. It’s been available since C++17 and allows us to discard a branch, at compile time, based on the value of a compile-time expression.</p>
			<p><strong class="bold">Question 4</strong></p>
			<p>What does <strong class="source-inline">std::is_same</strong> do? </p>
			<p><strong class="bold">Answer</strong></p>
			<p><strong class="source-inline">std::is_same</strong> is a type trait that checks whether two types are the same. It includes checks for the <strong class="source-inline">const</strong> and <strong class="source-inline">volatile</strong> qualifiers, yielding <strong class="source-inline">false</strong> for two types that have different qualifiers (such as <strong class="source-inline">int</strong> and <strong class="source-inline">int const</strong>).</p>
			<p><strong class="bold">Question 5</strong></p>
			<p>What does <strong class="source-inline">std::conditional</strong> do?</p>
			<p><strong class="bold">Answer</strong></p>
			<p><strong class="source-inline">std::conditional</strong> is a metafunction that chooses one type or another based on a compile-time constant.</p>
			<h1 id="_idParaDest-157"><em class="italic"><a id="_idTextAnchor212"/></em><a href="B18367_06_ePub.xhtml#_idTextAnchor099"><em class="italic">Chapter 6</em></a>, Concepts and Constraints</h1>
			<p><strong class="bold">Question 1</strong></p>
			<p>What are constraints? What about concepts?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>A constraint is a requirement imposed on a template argument. A concept is a named set of one or more constraints.</p>
			<p><strong class="bold">Question 2</strong></p>
			<p>What is a requires clause and a requires expression?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>A requires clause is a construct that allows us to specify a constraint on a template argument or function declaration. This construct is composed of the <strong class="source-inline">requires</strong> keyword followed by a compile-time Boolean expression. A requires clause affects the behavior of a function, including it for overload resolution only if the Boolean expression is <strong class="source-inline">true</strong>. On the other hand, a requires expression has the <strong class="source-inline">requires (parameters-list) expression;</strong> form, where <strong class="source-inline">parameters-list</strong> is optional. Its purpose is to verify that some expressions are well-formed, without having any side effects or affecting the behavior of the function. Requires expressions can be used with requires clauses, although named concepts are preferred, mainly for readability.</p>
			<p><strong class="bold">Question 3</strong></p>
			<p>What are the categories of requires expressions?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>There are four categories of requires expressions: simple requirements, type requirements, compound requirements, and nested requirements.</p>
			<p><strong class="bold">Question 4</strong></p>
			<p>How do constraints affect the ordering of templates in overload resolution?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>The constraining of functions affects their order in the overload resolution set. When multiple overloads match the set of arguments, the overload that is more constrained is selected. However, keep in mind that constraining with type traits (or Boolean expressions in general) and concepts is not semantically equal. For details on this topic, revisit the <em class="italic">Learning about the ordering of templates with constraints</em> section.</p>
			<p><strong class="bold">Question 5</strong></p>
			<p>What are abbreviated function templates?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Abbreviated function templates are a new feature introduced in C++20 that provides a simplified syntax for function templates. The <strong class="source-inline">auto</strong> specifier can be used to define function parameters and the template syntax can be skipped. The compiler will automatically generate a function template from an abbreviated function template. Such functions can be constrained using concepts, therefore imposing requirements on the template arguments.</p>
			<h1 id="_idParaDest-158"><em class="italic"><a id="_idTextAnchor213"/></em><a href="B18367_07_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 7</em></a>, Patterns and Idioms</h1>
			<p><strong class="bold">Question 1</strong></p>
			<p>What are typical problems for which the Curiously Recuring Template Pattern is used?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>The <strong class="bold">Curiously Recurring Template Pattern</strong> (<strong class="bold">CRTP</strong>) is typically used for solving problems such as adding common functionality to types and avoiding code duplication, limiting the number of times a type can be instantiated, or implementing the composite design pattern.</p>
			<p><strong class="bold">Question 2</strong></p>
			<p>What are mixins and what is their purpose?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Mixins are small classes that are designed to add functionality to other classes, by inheriting from the classes they are supposed to complement. This is the opposite of the CRTP pattern.</p>
			<p><strong class="bold">Question 3</strong></p>
			<p>What is type erasure?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Type erasure is the term used to describe a pattern that removes information from types, making it possible for types that are not related to be treated in a generic way. Although forms of type erasure can be achieved with <strong class="source-inline">void</strong> pointers or polymorphism, the true type erasure pattern is achieved in C++ with templates.</p>
			<p><strong class="bold">Question 4</strong></p>
			<p>What is tag dispatching and what are its alternatives?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Tag dispatching is a technique that enables us to select one or another function overload at compile time. Although tag dispatching itself is an alternative to <strong class="source-inline">std::enable_if</strong> and SFINAE, it also has its own alternatives. These are constexpr if in C++17 and concepts in C++20.</p>
			<p><strong class="bold">Question 5</strong></p>
			<p>What are expression templates and where are they used?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Expression templates are a metaprogramming technique that enables a lazy evaluation of a computation at compile-time. The benefit of this technique is that it avoids performing inefficient operations at runtime at the expense of more complex code that could be difficult to comprehend. Expression templates are typically used to implement linear algebra libraries.</p>
			<h1 id="_idParaDest-159"><em class="italic"><a id="_idTextAnchor214"/></em><a href="B18367_08_ePub.xhtml#_idTextAnchor179"><em class="italic">Chapter 8</em></a>, Ranges and Algorithms</h1>
			<p><strong class="bold">Question 1</strong></p>
			<p>What are the sequence containers from the standard library?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>The sequence containers from the C++ standard library are <strong class="source-inline">std::vector</strong>, <strong class="source-inline">std::deque</strong>, <strong class="source-inline">std::list</strong>, <strong class="source-inline">std::array</strong>, and <strong class="source-inline">std::forward_list</strong>.</p>
			<p><strong class="bold">Question 2</strong></p>
			<p>What are the common member functions defined in the standard containers?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>The member functions that are defined for most containers in the standard library are <strong class="source-inline">size</strong> (not present in <strong class="source-inline">std::forward_list</strong>), <strong class="source-inline">empty</strong>, <strong class="source-inline">clear</strong> (not present in <strong class="source-inline">std::array</strong>, <strong class="source-inline">std::stack</strong>, <strong class="source-inline">std::queue</strong>, and <strong class="source-inline">std::priority_queue</strong>), <strong class="source-inline">swap</strong>, <strong class="source-inline">begin</strong>, and <strong class="source-inline">end</strong>.</p>
			<p><strong class="bold">Question 3</strong></p>
			<p>What are iterators and how many categories exist?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>An iterator is an abstraction that enables us to access the elements of a container in a generic way, without having to know the implementation details of each container. Iterators are key for writing general-purpose algorithms. There are six categories of iterators in C++: input, forward, bidirectional, random-access, contiguous (as of C++17), and output.</p>
			<p><strong class="bold">Question 4</strong></p>
			<p>What operations does a random-access iterator support?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>The random-access iterators must support the following operations (in addition to those required for input, forward, and bidirectional iterators): the <strong class="source-inline">+</strong> and <strong class="source-inline">-</strong> arithmetic operators, inequality comparison (with other iterators), compound assignment, and offset dereference operators.</p>
			<p><strong class="bold">Question 5</strong></p>
			<p>What are range access functions?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Range access functions are non-member functions that provide a uniform way to access the data or properties of containers, arrays, and the <strong class="source-inline">std::initializer_list</strong> class. These functions include <strong class="source-inline">std::size</strong>/<strong class="source-inline">std::ssize</strong>, <strong class="source-inline">std::empty</strong>, <strong class="source-inline">std::data</strong>, <strong class="source-inline">std::begin</strong>, and <strong class="source-inline">std::end</strong>.</p>
			<h1 id="_idParaDest-160"><em class="italic"><a id="_idTextAnchor215"/></em><a href="B18367_09_ePub.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, The Ranges Library</h1>
			<p><strong class="bold">Question 1</strong></p>
			<p>What is a range?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>A range is an abstraction for a sequence of elements, defined with a beginning and end iterator. The beginning iterator points to the first element in the sequence. The end iterator points to the one-past-last element of the sequence.</p>
			<p><strong class="bold">Question 2</strong></p>
			<p>What is a view in the ranges library?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>A view in the C++ ranges library, also called a range adaptor, is an object that implements an algorithm that takes one or more ranges as input and perhaps other arguments and returns an adapted range. Views are lazy-evaluated, meaning they do not perform the adaptation until their elements are iterated.</p>
			<p><strong class="bold">Question 3</strong></p>
			<p>What are constrained algorithms?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>Constrained algorithms are implementations of the existing standard library algorithms but in the C++20 ranges library. They are called constrained because their template arguments are constrained using C++20 concepts. In these algorithms, instead of requiring a begin-end pair of iterators for specifying, a range of values accepts a single range argument. However, overloads that accept an iterator-sentinel pair also exist.</p>
			<p><strong class="bold">Question 4</strong></p>
			<p>What is a sentinel?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>A sentinel is an abstraction for an end iterator. This makes it possible for the end iterator to have a different type than the range iterator. Sentinels cannot be dereferenced or incremented. Sentinels are useful when the test for the end of a range depends on some variable (dynamic) condition and you don’t know you are at the end of the range until something happens (for instance, a condition becomes false).</p>
			<p><strong class="bold">Question 5</strong></p>
			<p>How can you check that a sentinel type corresponds to an iterator type?</p>
			<p><strong class="bold">Answer</strong></p>
			<p>You can check that a sentinel type can be used with an iterator type by using the <strong class="source-inline">std::sentinel_for</strong> concept from the <strong class="source-inline">&lt;iterator&gt;</strong> header.</p>
		</div>
		<div>
			<div id="_idContainer068">
			</div>
		</div>
	</div></body></html>