<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-188"><a id="_idTextAnchor205"/>12</h1>
<h1 id="_idParaDest-189"><a id="_idTextAnchor206"/>Getting Started with Ray Tracing</h1>
<p>In this chapter, we are introducing ray tracing into our rendering pipeline. Thanks to the addition of hardware support for ray tracing in modern GPUs, it’s now possible to integrate ray tracing techniques into real-time rendering.</p>
<p>Ray tracing requires a different setup compared to the traditional rendering pipeline, which is why we are dedicating a whole chapter to setting up a ray tracing pipeline. We are going to cover in detail how to set up a shader binding table to tell the API which shaders to invoke when an intersection test for a given ray succeeds or fails.</p>
<p>Next, we are going to explain how to create the <strong class="bold">Bottom Level Acceleration Structure</strong> (<strong class="bold">BLAS</strong>) and <strong class="bold">Top Level Acceleration Structure</strong> (<strong class="bold">TLAS</strong>). These <strong class="bold">Acceleration Structures</strong> (<strong class="bold">AS</strong>) are needed to speed up scene ray traversal and ensure that ray tracing can be performed at an interactive rate.</p>
<p>In this chapter, we’ll cover the following main topics:</p>
<ul>
<li>Introduction to ray tracing in Vulkan</li>
<li>Building the BLAS and TLAS</li>
<li>Defining and creating a ray tracing pipeline</li>
</ul>
<h1 id="_idParaDest-190"><a id="_idTextAnchor207"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following URL: <a href="https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter12">https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter12</a>.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor208"/>Introduction to ray tracing in Vulkan</h1>
<p>Ray tracing<a id="_idIndexMarker613"/> support in hardware<a id="_idIndexMarker614"/> was first introduced<a id="_idIndexMarker615"/> in 2018 with the NVidia RTX series. Originally, ray tracing support in Vulkan was only available through an NVidia extension, but later, the functionality was ratified through a Khronos extension to allow multiple vendors to support the ray tracing API in Vulkan. We are dedicating a full chapter just to the setup of a ray tracing pipeline, as it requires new constructs that are specific to ray tracing.</p>
<p>The first departure<a id="_idIndexMarker616"/> from the traditional rendering<a id="_idIndexMarker617"/> pipeline is the need to organize our scene into Acceleration Structures. These structures are needed to speed up scene traversal, as they allow us to skip entire meshes that the ray has no chance to intersect with.</p>
<p>These Acceleration Structures <a id="_idIndexMarker618"/>are usually implemented as a <strong class="bold">Bounded Volume Hierarchy</strong> (<strong class="bold">BVH</strong>). A BVH subdivides the scene and individual<a id="_idIndexMarker619"/> meshes into bounding boxes and then organizes them into a tree. Leaf nodes of this tree are the only nodes containing geometry data, while parent nodes define the position and extent of the volume that encompasses the children.</p>
<p>A simple scene and its BVH representation is illustrated by the following image:</p>
<div><div><img alt="Figure 12.1 – A scene example on the left and its BVH representation on the right (source: Wikipedia)" height="424" src="img/B18395_12_01.jpg" width="1556"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – A scene example on the left and its BVH representation on the right (source: Wikipedia)</p>
<p>The Vulkan API makes a further distinction between a TLAS and BLAS. A BLAS contains individual mesh definitions. These can then be grouped into a TLAS, where multiple instances of the same mesh can be placed in the scene by defining their transform matrices.</p>
<p>This organization is pictured in the following figure:</p>
<div><div><img alt="Figure 12.2 – Each BLAS can be added multiple times to a TLAS with different shading and transform details (source: Vulkan spec)" height="641" src="img/B18395_12_02.jpg" width="706"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Each BLAS can be added multiple times to a TLAS with different shading and transform details (source: Vulkan spec)</p>
<p>Now that we have<a id="_idIndexMarker620"/> defined our Acceleration Structures, we can turn our attention to the ray tracing<a id="_idIndexMarker621"/> pipeline. The major change introduced with ray tracing pipelines is the ability to call other shaders within a shader. This is achieved by defining shader binding tables. Each slot in these tables defines one of the following shader types:</p>
<ul>
<li><strong class="bold">Ray generation</strong>: In a traditional ray tracing pipeline, this<a id="_idIndexMarker622"/> is the entry point from which rays are generated. As we will see in later chapters, rays can also be spawned from fragments and compute shaders.</li>
<li><strong class="bold">Intersection</strong>: This shader allows the application<a id="_idIndexMarker623"/> to implement custom geometry primitives. In Vulkan, we<a id="_idIndexMarker624"/> can only define triangles and <strong class="bold">Axis-Aligned Bounding </strong><strong class="bold">Boxes</strong> (<strong class="bold">AABB</strong>).</li>
<li><strong class="bold">Any-hit</strong>: This is executed after an intersection<a id="_idIndexMarker625"/> shader is triggered. Its main use is to determine whether the hit should be processed further or ignored.</li>
<li><strong class="bold">Closest hit</strong>: This shader is triggered the first time<a id="_idIndexMarker626"/> a ray hits a primitive.</li>
<li><strong class="bold">Miss</strong>: This shader is triggered<a id="_idIndexMarker627"/> if the ray doesn’t hit any primitive.</li>
<li><strong class="bold">Callable</strong>: These are shaders that can be called<a id="_idIndexMarker628"/> from within an existing shader.</li>
</ul>
<p>The flow is summarized in the following figure:</p>
<div><div><img alt="Figure 12.3 – The shader flow of a ray tracing pipeline (source: Vulkan spec)" height="284" src="img/B18395_12_03.jpg" width="690"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – The shader flow of a ray tracing pipeline (source: Vulkan spec)</p>
<p>In this section, we have provided<a id="_idIndexMarker629"/> an overview of how<a id="_idIndexMarker630"/> ray tracing is implemented in the Vulkan API. In the next section, we are going to have a better look at how to create Acceleration Structures.</p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor209"/>Building the BLAS and TLAS</h1>
<p>As we mentioned in the previous<a id="_idIndexMarker631"/> section, ray tracing pipelines<a id="_idIndexMarker632"/> require geometry to be organized into Acceleration Structures to speed up the ray traversal of the scene. In this section, we are going to explain how to accomplish this in Vulkan.</p>
<p>We start by creating<a id="_idIndexMarker633"/> a list of <code>VkAccelerationStructureGeometryKHR</code> when parsing<a id="_idIndexMarker634"/> our scene. For each mesh, this data structure is defined as follows:</p>
<pre class="source-code">
VkAccelerationStructureGeometryKHR geometry{
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR };
geometry.geometryType = VK_GEOMETRY_TYPE_TRIANGLES_KHR;
geometry.flags =  mesh.is_transparent() ? 0 :
    VK_GEOMETRY_OPAQUE_BIT_KHR;</pre>
<p>Each geometry structure can define three types of entries: triangles, AABBs, and instances. We are going to use triangles here, as that’s how our meshes are defined. We are going to use instances later when defining the TLAS.</p>
<p>The following code demonstrates how the <code>triangles</code> structure is used:</p>
<pre class="source-code">
geometry.geometry.triangles.sType =
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY
        _TRIANGLES_DATA_KHR;
geometry.geometry.triangles.vertexFormat =
    VK_FORMAT_R32G32B32_SFLOAT;
geometry.geometry.triangles.vertexData.deviceAddress =
    renderer-&gt;gpu-&gt;get_buffer_device_address(
        mesh.position_buffer ) + mesh.position_offset;
geometry.geometry.triangles.vertexStride = sizeof( float )
    * 3;
geometry.geometry.triangles.maxVertex = vertex_count;
geometry.geometry.triangles.indexType = mesh.index_type;
geometry.geometry.triangles.indexData.deviceAddress =
    renderer-&gt;gpu-&gt;get_buffer_device_address(
        mesh.index_buffer );</pre>
<p>Geometry data<a id="_idIndexMarker635"/> is defined as it normally would <a id="_idIndexMarker636"/>be for traditional draws: we need to provide a vertex and index buffer, a vertex stride, and a vertex format. The primitive count is defined in the next structure.</p>
<p>Finally, we also need to fill a <code>VkAccelerationStructureBuildRangeInfoKHR</code> structure to store the primitive definition for our mesh:</p>
<pre class="source-code">
VkAccelerationStructureBuildRangeInfoKHR build_range_info{ };
build_range_info.primitiveCount = vertex_count;
build_range_info.primitiveOffset = mesh.index_offset;</pre>
<p>Now that we have the details for our meshes, we can start building the BLAS. This is a two-step process. First, we need to query how much memory our AS requires. We do so by defining a <code>VkAccelerationStructureBuildGeometryInfoKHR</code> structure:</p>
<pre class="source-code">
VkAccelerationStructureBuildGeometryInfoKHR as_info{
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD
        _GEOMETRY_INFO_KHR };
as_info.type =
    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
as_info.mode =
    VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR;
as_info.geometryCount = scene-&gt;geometries.size;
as_info.pGeometries = scene-&gt;geometries.data;</pre>
<p>These flags tell the Vulkan API that this BLAS could be updated or compacted in the future:</p>
<pre class="source-code">
as_info.flags =
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR |
        VK_BUILD_ACCELERATION_STRUCTURE_ALLOW
            _COMPACTION_BIT_KHR;</pre>
<p>When querying<a id="_idIndexMarker637"/> the size of the AS, we need to provide<a id="_idIndexMarker638"/> a list with the maximum number of primitives for each geometry entry:</p>
<pre class="source-code">
for ( u32 range_index = 0; range_index &lt; scene-&gt;
    geometries.size; range_index++ ) {
        max_primitives_count[ range_index ] = scene-&gt;
           build_range_infos[ range_index ].primitiveCount;
}</pre>
<p>We are now ready to query the size of our AS:</p>
<pre class="source-code">
VkAccelerationStructureBuildSizesInfoKHR as_size_info{
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD
        _SIZES_INFO_KHR };
vkGetAccelerationStructureBuildSizesKHR( gpu.vulkan_device,
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
      &amp;as_info, max_primitives_count.data, &amp;as_size_info );</pre>
<p>When building an AS, we need to provide two buffers: one for the actual AS data, and one for a scratch buffer that is used in the building process. The two buffers are created as follows:</p>
<pre class="source-code">
as_buffer_creation.set(
    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR,
        ResourceUsageType::Immutable,
            as_size_info.accelerationStructureSize )
                .set_device_only( true )
                    .set_name( "blas_buffer" );
scene-&gt;blas_buffer = gpu.create_buffer(
    as_buffer_creation );
as_buffer_creation.set(
VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR,
        ResourceUsageType::Immutable,
            as_size_info.buildScratchSize )
                .set_device_only( true )
                    .set_name( "blas_scratch_buffer" );
BufferHandle blas_scratch_buffer_handle =
    gpu.create_buffer( as_buffer_creation );</pre>
<p>This is similar to the code<a id="_idIndexMarker639"/> for creating buffers that we<a id="_idIndexMarker640"/> have used many times before, but there are two key differences that we want to highlight:</p>
<ul>
<li>The AS buffer needs to be created with the <code>VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR</code> usage flag</li>
<li>The scratch buffer needs to be created with <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR</code>. The ray tracing extension also requires the <code>VK_KHR_buffer_device_address</code> extension. This allows us to query the GPU virtual address for a given buffer, but it has to be created with this usage flag.</li>
</ul>
<p>Now we have everything we need to create our BLAS. First, we retrieve a handle for our AS:</p>
<pre class="source-code">
VkAccelerationStructureCreateInfoKHR as_create_info{
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE
        _CREATE_INFO_KHR };
as_create_info.buffer = blas_buffer-&gt;vk_buffer;
as_create_info.offset = 0;
as_create_info.size =
    as_size_info.accelerationStructureSize;
as_create_info.type =
    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
vkCreateAccelerationStructureKHR( gpu.vulkan_device,
    &amp;as_create_info, gpu.vulkan_allocation_callbacks,
        &amp;scene-&gt;blas );</pre>
<p>At this point, <code>scene-&gt;blas</code> is only a handle. To build<a id="_idIndexMarker641"/> our acceleration, we populate<a id="_idIndexMarker642"/> the remaining fields of our <code>VkAccelerationStructureBuildGeometryInfoKHR</code> structure:</p>
<pre class="source-code">
as_info.dstAccelerationStructure = scene-&gt;blas;
as_info.scratchData.deviceAddress =
    gpu.get_buffer_device_address(
        blas_scratch_buffer_handle );
VkAccelerationStructureBuildRangeInfoKHR* blas_ranges[] = {
    scene-&gt;build_range_infos.data
};</pre>
<p>Finally, we record the command to build the AS:</p>
<pre class="source-code">
vkCmdBuildAccelerationStructuresKHR( gpu_commands-&gt;
    vk_command_buffer, 1, &amp;as_info, blas_ranges );
gpu.submit_immediate( gpu_commands );</pre>
<p>Notice that we submit this command immediately. This is required because it’s not possible to build a BLAS and TLAS on the same submission, as the TLAS depends on a fully constructed BLAS.</p>
<p>The next and final step it to build<a id="_idIndexMarker643"/> the TLAS. The process<a id="_idIndexMarker644"/> is similar to the one we just described for the BLAS and we are going to highlight the differences. The TLAS is defined by specifying instances to multiple BLASes, where each BLAS can have its own transform. This is very similar to traditional instancing: we define our geometry once and it can be rendered multiple times by simply changing its transform.</p>
<p>We start by defining a <code>VkAccelerationStructureInstanceKHR</code> structure:</p>
<pre class="source-code">
VkAccelerationStructureInstanceKHR tlas_structure{ };
tlas_structure.transform.matrix[ 0 ][ 0 ] = 1.0f;
tlas_structure.transform.matrix[ 1 ][ 1 ] = 1.0f;
tlas_structure.transform.matrix[ 2 ][ 2 ] = 1.0f;
tlas_structure.mask = 0xff;
tlas_structure.flags = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR;
tlas_structure.accelerationStructureReference =
    blas_address;</pre>
<p>As mentioned previously, we provide a BLAS reference and its transform. We then need to create a buffer to hold this data:</p>
<pre class="source-code">
as_buffer_creation.reset().set(
    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE
    _BUILD_INPUT_READ_ONLY_BIT_KHR | VK_BUFFER_USAGE_
    SHADER_DEVICE_ADDRESS_BIT,
    ResourceUsageType::Immutable, sizeof(
    VkAccelerationStructureInstanceKHR ) )
    .set_data( &amp;tlas_structure )
    .set_name( "tlas_instance_buffer" );
BufferHandle tlas_instance_buffer_handle =
    gpu.create_buffer( as_buffer_creation );</pre>
<p>Notice the <code>VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR</code> usage flag, which<a id="_idIndexMarker645"/> is required for buffers<a id="_idIndexMarker646"/> that are going to be used during the AS build.</p>
<p>Next, we define a <code>VkAccelerationStructureGeometryKHR</code> structure:</p>
<pre class="source-code">
VkAccelerationStructureGeometryKHR tlas_geometry{
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR };
tlas_geometry.geometryType =
    VK_GEOMETRY_TYPE_INSTANCES_KHR;
tlas_geometry.geometry.instances.sType =
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE
        _GEOMETRY_INSTANCES_DATA_KHR;
tlas_geometry.geometry.instances.arrayOfPointers = false;
tlas_geometry.geometry.instances.data.deviceAddress =
    gpu.get_buffer_device_address(
        tlas_instance_buffer_handle );</pre>
<p>Now that we have defined the structure of our TLAS, we need to query its size. We won’t repeat the full code, but here are the differences in the <code>VkAccelerationStructureBuildGeometryInfoKHR</code> structure compared to when creating a BLAS:</p>
<pre class="source-code">
as_info.type =
    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;
as_info.geometryCount = 1;
as_info.pGeometries = &amp;tlas_geometry;</pre>
<p>After creating the data<a id="_idIndexMarker647"/> and scratch buffer for the TLAS, we<a id="_idIndexMarker648"/> are ready to get the TLAS handle:</p>
<pre class="source-code">
as_create_info.buffer = tlas_buffer-&gt;vk_buffer;
as_create_info.offset = 0;
as_create_info.size =
    as_size_info.accelerationStructureSize;
as_create_info.type =
    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;
vkCreateAccelerationStructureKHR( gpu.vulkan_device,
                                  &amp;as_create_info, 
                                  gpu.vulkan_allocation_
                                     callbacks,
                                  &amp;scene-&gt;tlas );</pre>
<p>Finally, we can build our TLAS:</p>
<pre class="source-code">
as_info.dstAccelerationStructure = scene-&gt;tlas;
as_info.scratchData.deviceAddress =
    gpu.get_buffer_device_address(
        tlas_scratch_buffer_handle );
VkAccelerationStructureBuildRangeInfoKHR tlas_range_info{ };
    tlas_range_info.primitiveCount = 1;
VkAccelerationStructureBuildRangeInfoKHR* tlas_ranges[] = {
    &amp;tlas_range_info
};
vkCmdBuildAccelerationStructuresKHR( gpu_commands-&gt;
    vk_command_buffer, 1, &amp;as_info, tlas_ranges );</pre>
<p>As before, we submit this command immediately so that the TLAS is ready when we start rendering. While it’s not possible to build BLAS and TLAS in the same submission, it is possible to create multiple BLAS and TLAS in parallel.</p>
<p>Our Acceleration Structures<a id="_idIndexMarker649"/> are now ready to be used for ray tracing!</p>
<p>In this section, we have detailed<a id="_idIndexMarker650"/> the steps required<a id="_idIndexMarker651"/> to create BLASes and TLASes. We started by recording the triangle primitives for our geometry. We then used this data to create a BLAS instance, which was then used as part of a TLAS.</p>
<p>In the next section, we are going to define a ray tracing pipeline that makes use of these Acceleration Structures.</p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor210"/>Defining and creating a ray tracing pipeline</h1>
<p>Now that we have defined our Acceleration Structures, we can<a id="_idIndexMarker652"/> turn our attention<a id="_idIndexMarker653"/> to ray tracing pipelines. As we mentioned previously, ray tracing shaders work differently compared to traditional graphics and compute shaders. Ray tracing shaders are setup to call other shaders according to the shader binding table setup.</p>
<p>If you are familiar with C++, you can think of this setup as a simple form of polymorphism: the interface of a ray tracing pipeline is always the same, but we can dynamically override which shaders (methods) get called at runtime. We don’t have to define all the entry points though.</p>
<p>In this example, for instance, we are going to define only a ray generation, the closest hit, and the miss shader. We are ignoring any-hit and intersection shaders for now. </p>
<p>As the name implies, the shader binding table can be represented in table form. This is the binding table we are going to build in our example:</p>
<div><div><img alt="" height="240" src="img/B18395_12_Table_01.jpg" width="817"/>
</div>
</div>
<p>The order in the table is important, as that’s the order used by the driver to tell the GPU which shader to invoke according to the stage that has been triggered.</p>
<p>Before we start building<a id="_idIndexMarker654"/> our pipeline, let’s have a look at three example shaders<a id="_idIndexMarker655"/> we are going to use. We start with the ray generation shader, which is responsible for spawning the rays to traverse our scene. First, we have to enable the GLSL extension for ray tracing:</p>
<pre class="source-code">
#extension GL_EXT_ray_tracing : enable</pre>
<p>Next, we have to define a variable that is going to be populated by other shaders:</p>
<pre class="source-code">
layout( location = 0 ) rayPayloadEXT vec4 payload;</pre>
<p>We then define a uniform variable that will contain a reference to our AS:</p>
<pre class="source-code">
layout( binding = 1, set = MATERIAL_SET ) uniform
    accelerationStructureEXT as;</pre>
<p>Finally, we define the parameters for our ray generation call:</p>
<pre class="source-code">
layout( binding = 2, set = MATERIAL_SET ) uniform rayParams
{
    uint sbt_offset;
    uint sbt_stride;
    uint miss_index;
    uint out_image_index;
};</pre>
<p><code>sbt_offset</code> is the offset into our shader binding table, which can be used in case multiple shaders of the same type are defined within a shader binding table. In our case, this will be <code>0</code>, as we only have one entry for each shader.</p>
<p><code>sbt_stride</code> is the size of each entry<a id="_idIndexMarker656"/> in the binding table. This value has to be queried<a id="_idIndexMarker657"/> for each device by passing a <code>VkPhysicalDeviceRayTracingPipelinePropertiesKHR</code> structure to <code>vkGetPhysicalDeviceProperties2</code>.</p>
<p><code>miss_index</code> is used to compute the index of the miss shader. This can be used if multiple miss shaders are present within a binding table. It will be <code>0</code> in our use case.</p>
<p>Finally, <code>out_image_index</code> is the index of the image in our bindless image array to which we are going to write.</p>
<p>Now that we have defined the inputs and outputs of our ray generation shader, we can invoke the function to trace rays into the scene!</p>
<pre class="source-code">
traceRayEXT( as, // top level acceleration structure
                gl_RayFlagsOpaqueEXT, // rayFlags
                0xff, // cullMask
                sbt_offset,
                sbt_stride,
                miss_index,
                camera_position.xyz, // origin
                0.0, // Tmin
                compute_ray_dir( gl_LaunchIDEXT,
                gl_LaunchSizeEXT ),
                100.0, // Tmax
                0 // payload
            );</pre>
<p>The first parameter is the TLAS we want to traverse. Since this is a parameter to the <code>traceRayEXT</code> function, we could cast rays into multiple Acceleration Structures in the same shader.</p>
<p><code>rayFlags</code> is a bit mask that determines which geometry is going to trigger a callback to our shaders. In this case, we are only interested in geometry that has the opaque flag.</p>
<p><code>cullMask</code> is used to match only the entries in the AS that have the same mask value defined. This allows us to define a single AS that can be used for multiple purposes.</p>
<p>Finally, the payload<a id="_idIndexMarker658"/> determines the location index of the ray tracing payload<a id="_idIndexMarker659"/> we have defined here. This allows us to invoke <code>traceRayEXT</code> multiple times, with each invocation using a different payload variable.</p>
<p>The other fields are self-explanatory or have been explained previously. Next, we are going to have a better look at how ray directions are computed:</p>
<pre class="source-code">
vec3 compute_ray_dir( uvec3 launchID, uvec3 launchSize) {</pre>
<p>Ray tracing shaders are very similar to compute shaders, and, like compute shaders, each invocation has an ID. For a ray tracing shader this is defined in the <code>gl_LaunchIDEXT</code> variable. Likewise, <code>gl_LaunchSizeEXT</code> defines the total invocation size. This is akin to the workgroup size for compute shaders.</p>
<p>In our case, we have one invocation<a id="_idIndexMarker660"/> per pixel in the image. We compute <code>x</code> and <code>y</code> in <strong class="bold">normalized device coordinates</strong> (<strong class="bold">NDCs</strong>) as follows:</p>
<pre class="source-code">
    float x = ( 2 * ( float( launchID.x ) + 0.5 ) / float(
        launchSize.x ) - 1.0 );
    float y = ( 1.0 - 2 * ( float( launchID.y ) + 0.5 ) /
        float( launchSize.y ) );</pre>
<p>Notice that we have to invert <code>y</code>, as otherwise, our final image will be upside-down.</p>
<p>Finally, we compute our world space direction by multiplying the coordinates by the <code>inverse_view_projection</code> matrix:</p>
<pre class="source-code">
   vec4 dir = inverse_view_projection * vec4( x, y, 1, 1 );
   dir = normalize( dir );
   return dir.xyz;
}</pre>
<p>Once <code>traceRayEXT</code> returns, the payload variable<a id="_idIndexMarker661"/> will contain the value computed<a id="_idIndexMarker662"/> through the other shaders. The final step of the ray generation is to save the color for this pixel:</p>
<pre class="source-code">
imageStore( global_images_2d[ out_image_index ], ivec2(
    gl_LaunchIDEXT.xy ), payload );</pre>
<p>We are now going to have a look at an example of a closest hit shader:</p>
<pre class="source-code">
layout( location = 0 ) rayPayloadInEXT vec4 payload;
void main() {
    payload = vec4( 1.0, 0.0, 0.0, 1.0 );
}</pre>
<p>The main difference from the ray generation shader is that the payload is now defined with the <code>rayPayloadInEXT</code> qualifier. It’s also important that the location matches the one defined in the ray generation shader.</p>
<p>The miss shader is identical, except we use a different color to distinguish between the two.</p>
<p>Now that we have defined our shader code, we can start building our pipeline. Compiling ray tracing shader modules works in the same way as other shaders. The main difference is the shader type. For ray tracing, these enumerations have been added:</p>
<ul>
<li><code>VK_SHADER_STAGE_RAYGEN_BIT_KHR</code></li>
<li><code>VK_SHADER_STAGE_ANY_HIT_BIT_KHR</code></li>
<li><code>VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR</code></li>
<li><code>VK_SHADER_STAGE_MISS_BIT_KHR</code></li>
<li><code>VK_SHADER_STAGE_INTERSECTION_BIT_KHR</code></li>
<li><code>VK_SHADER_STAGE_CALLABLE_BIT_KHR</code></li>
</ul>
<p>For a ray tracing pipeline, we have to populate a new <code>VkRayTracingShaderGroupCreateInfoKHR</code> structure:</p>
<pre class="source-code">
shader_group_info.sType =
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER
        _GROUP_CREATE_INFO_KHR;
shader_group_info.type =
    VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;
shader_group_info.generalShader = stage index;
shader_group_info.closestHitShader = VK_SHADER_UNUSED_KHR;
shader_group_info.anyHitShader = VK_SHADER_UNUSED_KHR;
shader_group_info.intersectionShader =
    VK_SHADER_UNUSED_KHR;</pre>
<p>In this example, we are defining<a id="_idIndexMarker663"/> a general shader, which can be a generation, miss, or callable<a id="_idIndexMarker664"/> shader. In our case, we are defining our ray generation shader. As you can see, it’s also possible to define other shaders within the same group entry. We have decided to have individual entries for each shader type as it allows us more flexibility in building our shader binding table.</p>
<p>Other shader types are defined similarly, and we are not going to repeat them here. As a quick example, here is how we define a closest hit shader:</p>
<pre class="source-code">
shader_group_info.type =
    VK_RAY_TRACING_SHADER_GROUP_TYPE
        _TRIANGLES_HIT_GROUP_KHR;
shader_group_info.closestHitShader = stage_index;</pre>
<p>Now that we have our shader groups defined, we can create our pipeline object:</p>
<pre class="source-code">
VkRayTracingPipelineCreateInfoKHR pipeline_info{
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR };
pipeline_info.stageCount = shader_state_data-&gt;
    active_shaders;
pipeline_info.pStages = shader_state_data-&gt;
    shader_stage_info;
pipeline_info.groupCount = shader_state_data-&gt;
    active_shaders;
pipeline_info.pGroups = shader_state_data-&gt;
    shader_group_info;
pipeline_info.maxPipelineRayRecursionDepth = 1;
pipeline_info.layout = pipeline_layout;
vkCreateRayTracingPipelinesKHR( vulkan_device,
    VK_NULL_HANDLE, pipeline_cache, 1, &amp;pipeline_info,
        vulkan_allocation_callbacks, &amp;pipeline-&gt;vk_pipeline );
pipeline-&gt;vk_bind_point =
    VkPipelineBindPoint::VK_PIPELINE
        _BIND_POINT_RAY_TRACING_KHR;</pre>
<p>Notice the <code>maxPipelineRayRecursionDepth</code> field. It determines<a id="_idIndexMarker665"/> the maximum number of call stacks<a id="_idIndexMarker666"/> in case we have a recursive call to the <code>rayTraceEXT</code> function. This is needed by the compiler to determine how much memory could be used by this pipeline at runtime.</p>
<p>We have omitted the <code>pLibraryInfo</code> and <code>pLibraryInterface</code> fields, as we are not using them. Multiple ray tracing pipelines can be combined to create a larger program, similar to how you link multiple objects in C++. This can help reduce compile times for ray tracing pipelines, as individual components need to be compiled only once.</p>
<p>The last step is to create<a id="_idIndexMarker667"/> our shader binding<a id="_idIndexMarker668"/> table. We start by computing the size required for our table:</p>
<pre class="source-code">
u32 group_handle_size =
    ray_tracing_pipeline_properties.shaderGroupHandleSize;
sizet shader_binding_table_size = group_handle_size *
    shader_state_data-&gt;active_shaders;</pre>
<p>We simply multiply the handle size by the number of entries in our table.</p>
<p>Next, we call <code>vkGetRayTracingShaderGroupHandlesKHR</code> to get the handles of the groups in the ray tracing pipeline:</p>
<pre class="source-code">
Array&lt;u8&gt; shader_binding_table_data{ };
shader_binding_table_data.init( allocator,
    shader_binding_table_size, shader_binding_table_size );
vkGetRayTracingShaderGroupHandlesKHR( vulkan_device,
    pipeline-&gt;vk_pipeline, 0, shader_state_data-&gt;
        active_shaders, shader_binding_table_size,
            shader_binding_table_data.data );</pre>
<p>Once we have the shader group handles, we can combine them to create individual tables for each shader type. They are stored in separate buffers:</p>
<pre class="source-code">
BufferCreation shader_binding_table_creation{ };
shader_binding_table_creation.set(
    VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR |
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR,
    ResourceUsageType::Immutable, group_handle_size
    ).set_data( shader_binding_table_data.data
    ).set_name(  "shader_binding_table_raygen" );
pipeline-&gt;shader_binding_table_raygen = create_buffer(
    shader_binding_table_creation );
shader_binding_table_creation.set_data(
    shader_binding_table_data.data + group_handle_size )
        .set_name( "shader_binding_table_hit" );
pipeline-&gt;shader_binding_table_hit = create_buffer(
    shader_binding_table_creation );
shader_binding_table_creation.set_data(
    shader_binding_table_data.data + ( group_handle_size *
        2 ) ).set_name( "shader_binding_table_miss" );
pipeline-&gt;shader_binding_table_miss = create_buffer(
    shader_binding_table_creation );</pre>
<p>We only have one entry<a id="_idIndexMarker669"/> per table, so we simply copy each group handle into its buffer. Notice <a id="_idIndexMarker670"/>that the buffer has to be created with the <code>VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR</code> usage flag.</p>
<p>This completes our ray tracing pipeline creation. All that’s left is to actually use it to generate an image! This is accomplished by the following code:</p>
<pre class="source-code">
u32 shader_group_handle_size = gpu_device-&gt;
    ray_tracing_pipeline_properties.shaderGroupHandleSize;
VkStridedDeviceAddressRegionKHR raygen_table{ };
raygen_table.deviceAddress = gpu_device-&gt;
    get_buffer_device_address( pipeline-&gt;
        shader_binding_table_raygen );
raygen_table.stride = shader_group_handle_size;
raygen_table.size = shader_group_handle_size;
VkStridedDeviceAddressRegionKHR hit_table{ };
hit_table.deviceAddress = gpu_device-&gt;
    get_buffer_device_address( pipeline-&gt;
        shader_binding_table_hit );
VkStridedDeviceAddressRegionKHR miss_table{ };
miss_table.deviceAddress = gpu_device-&gt;
    get_buffer_device_address( pipeline-&gt;
        shader_binding_table_miss );
VkStridedDeviceAddressRegionKHR callable_table{ };
vkCmdTraceRaysKHR( vk_command_buffer, &amp;raygen_table,
    &amp;miss_table, &amp;hit_table, &amp;callable_table, width,
        height, depth );</pre>
<p>We define <code>VkStridedDeviceAddressRegionKHR</code> for each shader binding<a id="_idIndexMarker671"/> table. We use the table buffers<a id="_idIndexMarker672"/> we previously created. Notice that we still need to define a table for callable shaders, even if we are not using them. The <code>width</code>, <code>height</code>, and <code>depth</code> parameters determine the invocation size of our ray tracing shader.</p>
<p>In this section, we have illustrated how to create and use a ray tracing pipeline. We started by defining the organization of our shader binding table. Next, we looked at a basic ray generation and closest hit shader. We then showed how to create a ray tracing pipeline object and how to retrieve shader group handles.</p>
<p>These handles were then<a id="_idIndexMarker673"/> used to populate<a id="_idIndexMarker674"/> the buffers of our shader binding tables. Finally, we demonstrated how to combine all these components to invoke our ray tracing pipeline.</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor211"/>Summary</h1>
<p>In this chapter, we have provided the details on how to use ray tracing in Vulkan. We started by explaining two fundamental concepts:</p>
<ul>
<li><strong class="bold">Acceleration </strong><strong class="bold">Structures</strong>: These are needed to speed up scene traversal. This is essential to achieve real-time results.</li>
<li><strong class="bold">Shader binding tables</strong>: Ray tracing pipelines can invoke multiple shaders, and these tables are used to tell the API which shaders to use for which stage.</li>
</ul>
<p>In the next section, we provided the implementation details to create TLASes and BLASes. We first record the list of geometries that compose our mesh. Next, we use this list to create a BLAS. Each BLAS can then be instanced multiple times within a TLAS, as each BLAS instance defines its own transform. With this data, we can then create our TLAS.</p>
<p>In the third and final section, we explained how to create a ray tracing pipeline. We started with the creation of individual shader types. Next, we demonstrated how to combine these individual shaders into a ray tracing pipeline and how to generate a shader binding table from a given pipeline.</p>
<p>Next, we have shown how to write a simple ray generation shader used in combination with a closest hit shader and a miss shader. Finally, we demonstrate how to combine all these pieces to trace rays in our scene.</p>
<p>In the next chapter, we are going to leverage all the knowledge from this chapter to implement ray-traced shadows!</p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor212"/>Further reading</h1>
<p>As always, we have only provided the most relevant details on how to use the Vulkan API. We recommend you read the Vulkan specification for more details. Here is the list of the most relevant sections:</p>
<ul>
<li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#pipelines-ray-tracing">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#pipelines-ray-tracing</a></li>
<li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#interfaces-raypipeline">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#interfaces-raypipeline</a></li>
<li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#acceleration-structure">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#acceleration-structure</a></li>
<li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#ray-tracing">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#ray-tracing</a></li>
</ul>
<p>This website provides more details on Acceleration Structures: <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-acceleration-structure/introduction">https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-acceleration-structure/introduction</a>.</p>
<p>There are plenty of resources online about real-time ray tracing. It’s still a novel field and subject to ongoing research. A good starting point is provided by these two freely available books:</p>
<ul>
<li><a href="http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml">http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml</a></li>
<li><a href="http://www.realtimerendering.com/raytracinggems/rtg2/index.xhtml">http://www.realtimerendering.com/raytracinggems/rtg2/index.xhtml</a></li>
</ul>
</div>
</div></body></html>