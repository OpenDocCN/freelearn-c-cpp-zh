<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer072">
<h1 class="chapter-number" id="_idParaDest-188"><a id="_idTextAnchor205"/>12</h1>
<h1 id="_idParaDest-189"><a id="_idTextAnchor206"/>Getting Started with Ray Tracing</h1>
<p>In this chapter, we are introducing ray tracing into our rendering pipeline. Thanks to the addition of hardware support for ray tracing in modern GPUs, it’s now possible to integrate ray tracing techniques into <span class="No-Break">real-time rendering.</span></p>
<p>Ray tracing requires a different setup compared to the traditional rendering pipeline, which is why we are dedicating a whole chapter to setting up a ray tracing pipeline. We are going to cover in detail how to set up a shader binding table to tell the API which shaders to invoke when an intersection test for a given ray succeeds <span class="No-Break">or fails.</span></p>
<p>Next, we are going to explain how to create the <strong class="bold">Bottom Level Acceleration Structure</strong> (<strong class="bold">BLAS</strong>) and <strong class="bold">Top Level Acceleration Structure</strong> (<strong class="bold">TLAS</strong>). These <strong class="bold">Acceleration Structures</strong> (<strong class="bold">AS</strong>) are needed to speed up scene ray traversal and ensure that ray tracing can be performed at an <span class="No-Break">interactive rate.</span></p>
<p>In this chapter, we’ll cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>Introduction to ray tracing <span class="No-Break">in Vulkan</span></li>
<li>Building the BLAS <span class="No-Break">and TLAS</span></li>
<li>Defining and creating a ray <span class="No-Break">tracing pipeline</span></li>
</ul>
<h1 id="_idParaDest-190"><a id="_idTextAnchor207"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following <span class="No-Break">URL: </span><a href="https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter12"><span class="No-Break">https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter12</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor208"/>Introduction to ray tracing in Vulkan</h1>
<p>Ray tracing<a id="_idIndexMarker613"/> support in hardware<a id="_idIndexMarker614"/> was first introduced<a id="_idIndexMarker615"/> in 2018 with the NVidia RTX series. Originally, ray tracing support in Vulkan was only available through an NVidia extension, but later, the functionality was ratified through a Khronos extension to allow multiple vendors to support the ray tracing API in Vulkan. We are dedicating a full chapter just to the setup of a ray tracing pipeline, as it requires new constructs that are specific to <span class="No-Break">ray tracing.</span></p>
<p>The first departure<a id="_idIndexMarker616"/> from the traditional rendering<a id="_idIndexMarker617"/> pipeline is the need to organize our scene into Acceleration Structures. These structures are needed to speed up scene traversal, as they allow us to skip entire meshes that the ray has no chance to <span class="No-Break">intersect with.</span></p>
<p>These Acceleration Structures <a id="_idIndexMarker618"/>are usually implemented as a <strong class="bold">Bounded Volume Hierarchy</strong> (<strong class="bold">BVH</strong>). A BVH subdivides the scene and individual<a id="_idIndexMarker619"/> meshes into bounding boxes and then organizes them into a tree. Leaf nodes of this tree are the only nodes containing geometry data, while parent nodes define the position and extent of the volume that encompasses <span class="No-Break">the children.</span></p>
<p>A simple scene and its BVH representation is illustrated by the <span class="No-Break">following image:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<img alt="Figure 12.1 – A scene example on the left and its BVH representation on the right (source: Wikipedia)" height="424" src="image/B18395_12_01.jpg" width="1556"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – A scene example on the left and its BVH representation on the right (source: Wikipedia)</p>
<p>The Vulkan API makes a further distinction between a TLAS and BLAS. A BLAS contains individual mesh definitions. These can then be grouped into a TLAS, where multiple instances of the same mesh can be placed in the scene by defining their <span class="No-Break">transform matrices.</span></p>
<p>This organization is pictured in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<img alt="Figure 12.2 – Each BLAS can be added multiple times to a TLAS with different shading and transform details (source: Vulkan spec)" height="641" src="image/B18395_12_02.jpg" width="706"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Each BLAS can be added multiple times to a TLAS with different shading and transform details (source: Vulkan spec)</p>
<p>Now that we have<a id="_idIndexMarker620"/> defined our Acceleration Structures, we can turn our attention to the ray tracing<a id="_idIndexMarker621"/> pipeline. The major change introduced with ray tracing pipelines is the ability to call other shaders within a shader. This is achieved by defining shader binding tables. Each slot in these tables defines one of the following <span class="No-Break">shader types:</span></p>
<ul>
<li><strong class="bold">Ray generation</strong>: In a traditional ray tracing pipeline, this<a id="_idIndexMarker622"/> is the entry point from which rays are generated. As we will see in later chapters, rays can also be spawned from fragments and <span class="No-Break">compute shaders.</span></li>
<li><strong class="bold">Intersection</strong>: This shader allows the application<a id="_idIndexMarker623"/> to implement custom geometry primitives. In Vulkan, we<a id="_idIndexMarker624"/> can only define triangles and <strong class="bold">Axis-Aligned Bounding </strong><span class="No-Break"><strong class="bold">Boxes</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">AABB</strong></span><span class="No-Break">).</span></li>
<li><strong class="bold">Any-hit</strong>: This is executed after an intersection<a id="_idIndexMarker625"/> shader is triggered. Its main use is to determine whether the hit should be processed further <span class="No-Break">or ignored.</span></li>
<li><strong class="bold">Closest hit</strong>: This shader is triggered the first time<a id="_idIndexMarker626"/> a ray hits <span class="No-Break">a primitive.</span></li>
<li><strong class="bold">Miss</strong>: This shader is triggered<a id="_idIndexMarker627"/> if the ray doesn’t hit <span class="No-Break">any primitive.</span></li>
<li><strong class="bold">Callable</strong>: These are shaders that can be called<a id="_idIndexMarker628"/> from within an <span class="No-Break">existing shader.</span></li>
</ul>
<p>The flow is summarized in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<img alt="Figure 12.3 – The shader flow of a ray tracing pipeline (source: Vulkan spec)" height="284" src="image/B18395_12_03.jpg" width="690"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – The shader flow of a ray tracing pipeline (source: Vulkan spec)</p>
<p>In this section, we have provided<a id="_idIndexMarker629"/> an overview of how<a id="_idIndexMarker630"/> ray tracing is implemented in the Vulkan API. In the next section, we are going to have a better look at how to create <span class="No-Break">Acceleration Structures.</span></p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor209"/>Building the BLAS and TLAS</h1>
<p>As we mentioned in the previous<a id="_idIndexMarker631"/> section, ray tracing pipelines<a id="_idIndexMarker632"/> require geometry to be organized into Acceleration Structures to speed up the ray traversal of the scene. In this section, we are going to explain how to accomplish this <span class="No-Break">in Vulkan.</span></p>
<p>We start by creating<a id="_idIndexMarker633"/> a list of <strong class="source-inline">VkAccelerationStructureGeometryKHR</strong> when parsing<a id="_idIndexMarker634"/> our scene. For each mesh, this data structure is defined <span class="No-Break">as follows:</span></p>
<pre class="source-code">
VkAccelerationStructureGeometryKHR geometry{
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR };
geometry.geometryType = VK_GEOMETRY_TYPE_TRIANGLES_KHR;
geometry.flags =  mesh.is_transparent() ? 0 :
    VK_GEOMETRY_OPAQUE_BIT_KHR;</pre>
<p>Each geometry structure can define three types of entries: triangles, AABBs, and instances. We are going to use triangles here, as that’s how our meshes are defined. We are going to use instances later when defining <span class="No-Break">the TLAS.</span></p>
<p>The following code demonstrates how the <strong class="source-inline">triangles</strong> structure <span class="No-Break">is used:</span></p>
<pre class="source-code">
geometry.geometry.triangles.sType =
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY
        _TRIANGLES_DATA_KHR;
geometry.geometry.triangles.vertexFormat =
    VK_FORMAT_R32G32B32_SFLOAT;
geometry.geometry.triangles.vertexData.deviceAddress =
    renderer-&gt;gpu-&gt;get_buffer_device_address(
        mesh.position_buffer ) + mesh.position_offset;
geometry.geometry.triangles.vertexStride = sizeof( float )
    * 3;
geometry.geometry.triangles.maxVertex = vertex_count;
geometry.geometry.triangles.indexType = mesh.index_type;
geometry.geometry.triangles.indexData.deviceAddress =
    renderer-&gt;gpu-&gt;get_buffer_device_address(
        mesh.index_buffer );</pre>
<p>Geometry data<a id="_idIndexMarker635"/> is defined as it normally would <a id="_idIndexMarker636"/>be for traditional draws: we need to provide a vertex and index buffer, a vertex stride, and a vertex format. The primitive count is defined in the <span class="No-Break">next structure.</span></p>
<p>Finally, we also need to fill a <strong class="source-inline">VkAccelerationStructureBuildRangeInfoKHR</strong> structure to store the primitive definition for <span class="No-Break">our mesh:</span></p>
<pre class="source-code">
VkAccelerationStructureBuildRangeInfoKHR build_range_info{ };
build_range_info.primitiveCount = vertex_count;
build_range_info.primitiveOffset = mesh.index_offset;</pre>
<p>Now that we have the details for our meshes, we can start building the BLAS. This is a two-step process. First, we need to query how much memory our AS requires. We do so by defining a <span class="No-Break"><strong class="source-inline">VkAccelerationStructureBuildGeometryInfoKHR</strong></span><span class="No-Break"> structure:</span></p>
<pre class="source-code">
VkAccelerationStructureBuildGeometryInfoKHR as_info{
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD
        _GEOMETRY_INFO_KHR };
as_info.type =
    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
as_info.mode =
    VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR;
as_info.geometryCount = scene-&gt;geometries.size;
as_info.pGeometries = scene-&gt;geometries.data;</pre>
<p>These flags tell the Vulkan API that this BLAS could be updated or compacted in <span class="No-Break">the future:</span></p>
<pre class="source-code">
as_info.flags =
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR |
        VK_BUILD_ACCELERATION_STRUCTURE_ALLOW
            _COMPACTION_BIT_KHR;</pre>
<p>When querying<a id="_idIndexMarker637"/> the size of the AS, we need to provide<a id="_idIndexMarker638"/> a list with the maximum number of primitives for each <span class="No-Break">geometry entry:</span></p>
<pre class="source-code">
for ( u32 range_index = 0; range_index &lt; scene-&gt;
    geometries.size; range_index++ ) {
        max_primitives_count[ range_index ] = scene-&gt;
           build_range_infos[ range_index ].primitiveCount;
}</pre>
<p>We are now ready to query the size of <span class="No-Break">our AS:</span></p>
<pre class="source-code">
VkAccelerationStructureBuildSizesInfoKHR as_size_info{
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD
        _SIZES_INFO_KHR };
vkGetAccelerationStructureBuildSizesKHR( gpu.vulkan_device,
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
      &amp;as_info, max_primitives_count.data, &amp;as_size_info );</pre>
<p>When building an AS, we need to provide two buffers: one for the actual AS data, and one for a scratch buffer that is used in the building process. The two buffers are created <span class="No-Break">as follows:</span></p>
<pre class="source-code">
as_buffer_creation.set(
    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR,
        ResourceUsageType::Immutable,
            as_size_info.accelerationStructureSize )
                .set_device_only( true )
                    .set_name( "blas_buffer" );
scene-&gt;blas_buffer = gpu.create_buffer(
    as_buffer_creation );
as_buffer_creation.set(
VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR,
        ResourceUsageType::Immutable,
            as_size_info.buildScratchSize )
                .set_device_only( true )
                    .set_name( "blas_scratch_buffer" );
BufferHandle blas_scratch_buffer_handle =
    gpu.create_buffer( as_buffer_creation );</pre>
<p>This is similar to the code<a id="_idIndexMarker639"/> for creating buffers that we<a id="_idIndexMarker640"/> have used many times before, but there are two key differences that we want <span class="No-Break">to highlight:</span></p>
<ul>
<li>The AS buffer needs to be created with the <strong class="source-inline">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR</strong> <span class="No-Break">usage flag</span></li>
<li>The scratch buffer needs to be created with <strong class="source-inline">VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR</strong>. The ray tracing extension also requires the <strong class="source-inline">VK_KHR_buffer_device_address</strong> extension. This allows us to query the GPU virtual address for a given buffer, but it has to be created with this <span class="No-Break">usage flag.</span></li>
</ul>
<p>Now we have everything we need to create our BLAS. First, we retrieve a handle for <span class="No-Break">our AS:</span></p>
<pre class="source-code">
VkAccelerationStructureCreateInfoKHR as_create_info{
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE
        _CREATE_INFO_KHR };
as_create_info.buffer = blas_buffer-&gt;vk_buffer;
as_create_info.offset = 0;
as_create_info.size =
    as_size_info.accelerationStructureSize;
as_create_info.type =
    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
vkCreateAccelerationStructureKHR( gpu.vulkan_device,
    &amp;as_create_info, gpu.vulkan_allocation_callbacks,
        &amp;scene-&gt;blas );</pre>
<p>At this point, <strong class="source-inline">scene-&gt;blas</strong> is only a handle. To build<a id="_idIndexMarker641"/> our acceleration, we populate<a id="_idIndexMarker642"/> the remaining fields of our <span class="No-Break"><strong class="source-inline">VkAccelerationStructureBuildGeometryInfoKHR</strong></span><span class="No-Break"> structure:</span></p>
<pre class="source-code">
as_info.dstAccelerationStructure = scene-&gt;blas;
as_info.scratchData.deviceAddress =
    gpu.get_buffer_device_address(
        blas_scratch_buffer_handle );
VkAccelerationStructureBuildRangeInfoKHR* blas_ranges[] = {
    scene-&gt;build_range_infos.data
};</pre>
<p>Finally, we record the command to build <span class="No-Break">the AS:</span></p>
<pre class="source-code">
vkCmdBuildAccelerationStructuresKHR( gpu_commands-&gt;
    vk_command_buffer, 1, &amp;as_info, blas_ranges );
gpu.submit_immediate( gpu_commands );</pre>
<p>Notice that we submit this command immediately. This is required because it’s not possible to build a BLAS and TLAS on the same submission, as the TLAS depends on a fully <span class="No-Break">constructed BLAS.</span></p>
<p>The next and final step it to build<a id="_idIndexMarker643"/> the TLAS. The process<a id="_idIndexMarker644"/> is similar to the one we just described for the BLAS and we are going to highlight the differences. The TLAS is defined by specifying instances to multiple BLASes, where each BLAS can have its own transform. This is very similar to traditional instancing: we define our geometry once and it can be rendered multiple times by simply changing <span class="No-Break">its transform.</span></p>
<p>We start by defining a <span class="No-Break"><strong class="source-inline">VkAccelerationStructureInstanceKHR</strong></span><span class="No-Break"> structure:</span></p>
<pre class="source-code">
VkAccelerationStructureInstanceKHR tlas_structure{ };
tlas_structure.transform.matrix[ 0 ][ 0 ] = 1.0f;
tlas_structure.transform.matrix[ 1 ][ 1 ] = 1.0f;
tlas_structure.transform.matrix[ 2 ][ 2 ] = 1.0f;
tlas_structure.mask = 0xff;
tlas_structure.flags = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR;
tlas_structure.accelerationStructureReference =
    blas_address;</pre>
<p>As mentioned previously, we provide a BLAS reference and its transform. We then need to create a buffer to hold <span class="No-Break">this data:</span></p>
<pre class="source-code">
as_buffer_creation.reset().set(
    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE
    _BUILD_INPUT_READ_ONLY_BIT_KHR | VK_BUFFER_USAGE_
    SHADER_DEVICE_ADDRESS_BIT,
    ResourceUsageType::Immutable, sizeof(
    VkAccelerationStructureInstanceKHR ) )
    .set_data( &amp;tlas_structure )
    .set_name( "tlas_instance_buffer" );
BufferHandle tlas_instance_buffer_handle =
    gpu.create_buffer( as_buffer_creation );</pre>
<p>Notice the <strong class="source-inline">VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR</strong> usage flag, which<a id="_idIndexMarker645"/> is required for buffers<a id="_idIndexMarker646"/> that are going to be used during the <span class="No-Break">AS build.</span></p>
<p>Next, we define a <span class="No-Break"><strong class="source-inline">VkAccelerationStructureGeometryKHR</strong></span><span class="No-Break"> structure:</span></p>
<pre class="source-code">
VkAccelerationStructureGeometryKHR tlas_geometry{
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR };
tlas_geometry.geometryType =
    VK_GEOMETRY_TYPE_INSTANCES_KHR;
tlas_geometry.geometry.instances.sType =
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE
        _GEOMETRY_INSTANCES_DATA_KHR;
tlas_geometry.geometry.instances.arrayOfPointers = false;
tlas_geometry.geometry.instances.data.deviceAddress =
    gpu.get_buffer_device_address(
        tlas_instance_buffer_handle );</pre>
<p>Now that we have defined the structure of our TLAS, we need to query its size. We won’t repeat the full code, but here are the differences in the <strong class="source-inline">VkAccelerationStructureBuildGeometryInfoKHR</strong> structure compared to when creating <span class="No-Break">a BLAS:</span></p>
<pre class="source-code">
as_info.type =
    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;
as_info.geometryCount = 1;
as_info.pGeometries = &amp;tlas_geometry;</pre>
<p>After creating the data<a id="_idIndexMarker647"/> and scratch buffer for the TLAS, we<a id="_idIndexMarker648"/> are ready to get the <span class="No-Break">TLAS handle:</span></p>
<pre class="source-code">
as_create_info.buffer = tlas_buffer-&gt;vk_buffer;
as_create_info.offset = 0;
as_create_info.size =
    as_size_info.accelerationStructureSize;
as_create_info.type =
    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;
vkCreateAccelerationStructureKHR( gpu.vulkan_device,
                                  &amp;as_create_info, 
                                  gpu.vulkan_allocation_
                                     callbacks,
                                  &amp;scene-&gt;tlas );</pre>
<p>Finally, we can build <span class="No-Break">our TLAS:</span></p>
<pre class="source-code">
as_info.dstAccelerationStructure = scene-&gt;tlas;
as_info.scratchData.deviceAddress =
    gpu.get_buffer_device_address(
        tlas_scratch_buffer_handle );
VkAccelerationStructureBuildRangeInfoKHR tlas_range_info{ };
    tlas_range_info.primitiveCount = 1;
VkAccelerationStructureBuildRangeInfoKHR* tlas_ranges[] = {
    &amp;tlas_range_info
};
vkCmdBuildAccelerationStructuresKHR( gpu_commands-&gt;
    vk_command_buffer, 1, &amp;as_info, tlas_ranges );</pre>
<p>As before, we submit this command immediately so that the TLAS is ready when we start rendering. While it’s not possible to build BLAS and TLAS in the same submission, it is possible to create multiple BLAS and TLAS <span class="No-Break">in parallel.</span></p>
<p>Our Acceleration Structures<a id="_idIndexMarker649"/> are now ready to be used for <span class="No-Break">ray tracing!</span></p>
<p>In this section, we have detailed<a id="_idIndexMarker650"/> the steps required<a id="_idIndexMarker651"/> to create BLASes and TLASes. We started by recording the triangle primitives for our geometry. We then used this data to create a BLAS instance, which was then used as part of <span class="No-Break">a TLAS.</span></p>
<p>In the next section, we are going to define a ray tracing pipeline that makes use of these <span class="No-Break">Acceleration Structures.</span></p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor210"/>Defining and creating a ray tracing pipeline</h1>
<p>Now that we have defined our Acceleration Structures, we can<a id="_idIndexMarker652"/> turn our attention<a id="_idIndexMarker653"/> to ray tracing pipelines. As we mentioned previously, ray tracing shaders work differently compared to traditional graphics and compute shaders. Ray tracing shaders are setup to call other shaders according to the shader binding <span class="No-Break">table setup.</span></p>
<p>If you are familiar with C++, you can think of this setup as a simple form of polymorphism: the interface of a ray tracing pipeline is always the same, but we can dynamically override which shaders (methods) get called at runtime. We don’t have to define all the entry <span class="No-Break">points though.</span></p>
<p>In this example, for instance, we are going to define only a ray generation, the closest hit, and the miss shader. We are ignoring any-hit and intersection shaders for now. </p>
<p>As the name implies, the shader binding table can be represented in table form. This is the binding table we are going to build in <span class="No-Break">our example:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<img alt="" height="240" src="image/B18395_12_Table_01.jpg" width="817"/>
</div>
</div>
<p>The order in the table is important, as that’s the order used by the driver to tell the GPU which shader to invoke according to the stage that has <span class="No-Break">been triggered.</span></p>
<p>Before we start building<a id="_idIndexMarker654"/> our pipeline, let’s have a look at three example shaders<a id="_idIndexMarker655"/> we are going to use. We start with the ray generation shader, which is responsible for spawning the rays to traverse our scene. First, we have to enable the GLSL extension for <span class="No-Break">ray tracing:</span></p>
<pre class="source-code">
#extension GL_EXT_ray_tracing : enable</pre>
<p>Next, we have to define a variable that is going to be populated by <span class="No-Break">other shaders:</span></p>
<pre class="source-code">
layout( location = 0 ) rayPayloadEXT vec4 payload;</pre>
<p>We then define a uniform variable that will contain a reference to <span class="No-Break">our AS:</span></p>
<pre class="source-code">
layout( binding = 1, set = MATERIAL_SET ) uniform
    accelerationStructureEXT as;</pre>
<p>Finally, we define the parameters for our ray <span class="No-Break">generation call:</span></p>
<pre class="source-code">
layout( binding = 2, set = MATERIAL_SET ) uniform rayParams
{
    uint sbt_offset;
    uint sbt_stride;
    uint miss_index;
    uint out_image_index;
};</pre>
<p><strong class="source-inline">sbt_offset</strong> is the offset into our shader binding table, which can be used in case multiple shaders of the same type are defined within a shader binding table. In our case, this will be <strong class="source-inline">0</strong>, as we only have one entry for <span class="No-Break">each shader.</span></p>
<p><strong class="source-inline">sbt_stride</strong> is the size of each entry<a id="_idIndexMarker656"/> in the binding table. This value has to be queried<a id="_idIndexMarker657"/> for each device by passing a <strong class="source-inline">VkPhysicalDeviceRayTracingPipelinePropertiesKHR</strong> structure <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">vkGetPhysicalDeviceProperties2</strong></span><span class="No-Break">.</span></p>
<p><strong class="source-inline">miss_index</strong> is used to compute the index of the miss shader. This can be used if multiple miss shaders are present within a binding table. It will be <strong class="source-inline">0</strong> in our <span class="No-Break">use case.</span></p>
<p>Finally, <strong class="source-inline">out_image_index</strong> is the index of the image in our bindless image array to which we are going <span class="No-Break">to write.</span></p>
<p>Now that we have defined the inputs and outputs of our ray generation shader, we can invoke the function to trace rays into <span class="No-Break">the scene!</span></p>
<pre class="source-code">
traceRayEXT( as, // top level acceleration structure
                gl_RayFlagsOpaqueEXT, // rayFlags
                0xff, // cullMask
                sbt_offset,
                sbt_stride,
                miss_index,
                camera_position.xyz, // origin
                0.0, // Tmin
                compute_ray_dir( gl_LaunchIDEXT,
                gl_LaunchSizeEXT ),
                100.0, // Tmax
                0 // payload
            );</pre>
<p>The first parameter is the TLAS we want to traverse. Since this is a parameter to the <strong class="source-inline">traceRayEXT</strong> function, we could cast rays into multiple Acceleration Structures in the <span class="No-Break">same shader.</span></p>
<p><strong class="source-inline">rayFlags</strong> is a bit mask that determines which geometry is going to trigger a callback to our shaders. In this case, we are only interested in geometry that has the <span class="No-Break">opaque flag.</span></p>
<p><strong class="source-inline">cullMask</strong> is used to match only the entries in the AS that have the same mask value defined. This allows us to define a single AS that can be used for <span class="No-Break">multiple purposes.</span></p>
<p>Finally, the payload<a id="_idIndexMarker658"/> determines the location index of the ray tracing payload<a id="_idIndexMarker659"/> we have defined here. This allows us to invoke <strong class="source-inline">traceRayEXT</strong> multiple times, with each invocation using a different <span class="No-Break">payload variable.</span></p>
<p>The other fields are self-explanatory or have been explained previously. Next, we are going to have a better look at how ray directions <span class="No-Break">are computed:</span></p>
<pre class="source-code">
vec3 compute_ray_dir( uvec3 launchID, uvec3 launchSize) {</pre>
<p>Ray tracing shaders are very similar to compute shaders, and, like compute shaders, each invocation has an ID. For a ray tracing shader this is defined in the <strong class="source-inline">gl_LaunchIDEXT</strong> variable. Likewise, <strong class="source-inline">gl_LaunchSizeEXT</strong> defines the total invocation size. This is akin to the workgroup size for <span class="No-Break">compute shaders.</span></p>
<p>In our case, we have one invocation<a id="_idIndexMarker660"/> per pixel in the image. We compute <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> in <strong class="bold">normalized device coordinates</strong> (<strong class="bold">NDCs</strong>) <span class="No-Break">as follows:</span></p>
<pre class="source-code">
    float x = ( 2 * ( float( launchID.x ) + 0.5 ) / float(
        launchSize.x ) - 1.0 );
    float y = ( 1.0 - 2 * ( float( launchID.y ) + 0.5 ) /
        float( launchSize.y ) );</pre>
<p>Notice that we have to invert <strong class="source-inline">y</strong>, as otherwise, our final image will <span class="No-Break">be upside-down.</span></p>
<p>Finally, we compute our world space direction by multiplying the coordinates by the <span class="No-Break"><strong class="source-inline">inverse_view_projection</strong></span><span class="No-Break"> matrix:</span></p>
<pre class="source-code">
   vec4 dir = inverse_view_projection * vec4( x, y, 1, 1 );
   dir = normalize( dir );
   return dir.xyz;
}</pre>
<p>Once <strong class="source-inline">traceRayEXT</strong> returns, the payload variable<a id="_idIndexMarker661"/> will contain the value computed<a id="_idIndexMarker662"/> through the other shaders. The final step of the ray generation is to save the color for <span class="No-Break">this pixel:</span></p>
<pre class="source-code">
imageStore( global_images_2d[ out_image_index ], ivec2(
    gl_LaunchIDEXT.xy ), payload );</pre>
<p>We are now going to have a look at an example of a closest <span class="No-Break">hit shader:</span></p>
<pre class="source-code">
layout( location = 0 ) rayPayloadInEXT vec4 payload;
void main() {
    payload = vec4( 1.0, 0.0, 0.0, 1.0 );
}</pre>
<p>The main difference from the ray generation shader is that the payload is now defined with the <strong class="source-inline">rayPayloadInEXT</strong> qualifier. It’s also important that the location matches the one defined in the ray <span class="No-Break">generation shader.</span></p>
<p>The miss shader is identical, except we use a different color to distinguish between <span class="No-Break">the two.</span></p>
<p>Now that we have defined our shader code, we can start building our pipeline. Compiling ray tracing shader modules works in the same way as other shaders. The main difference is the shader type. For ray tracing, these enumerations have <span class="No-Break">been added:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">VK_SHADER_STAGE_RAYGEN_BIT_KHR</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">VK_SHADER_STAGE_ANY_HIT_BIT_KHR</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">VK_SHADER_STAGE_MISS_BIT_KHR</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">VK_SHADER_STAGE_INTERSECTION_BIT_KHR</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">VK_SHADER_STAGE_CALLABLE_BIT_KHR</strong></span></li>
</ul>
<p>For a ray tracing pipeline, we have to populate a new <span class="No-Break"><strong class="source-inline">VkRayTracingShaderGroupCreateInfoKHR</strong></span><span class="No-Break"> structure:</span></p>
<pre class="source-code">
shader_group_info.sType =
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER
        _GROUP_CREATE_INFO_KHR;
shader_group_info.type =
    VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;
shader_group_info.generalShader = stage index;
shader_group_info.closestHitShader = VK_SHADER_UNUSED_KHR;
shader_group_info.anyHitShader = VK_SHADER_UNUSED_KHR;
shader_group_info.intersectionShader =
    VK_SHADER_UNUSED_KHR;</pre>
<p>In this example, we are defining<a id="_idIndexMarker663"/> a general shader, which can be a generation, miss, or callable<a id="_idIndexMarker664"/> shader. In our case, we are defining our ray generation shader. As you can see, it’s also possible to define other shaders within the same group entry. We have decided to have individual entries for each shader type as it allows us more flexibility in building our shader <span class="No-Break">binding table.</span></p>
<p>Other shader types are defined similarly, and we are not going to repeat them here. As a quick example, here is how we define a closest <span class="No-Break">hit shader:</span></p>
<pre class="source-code">
shader_group_info.type =
    VK_RAY_TRACING_SHADER_GROUP_TYPE
        _TRIANGLES_HIT_GROUP_KHR;
shader_group_info.closestHitShader = stage_index;</pre>
<p>Now that we have our shader groups defined, we can create our <span class="No-Break">pipeline object:</span></p>
<pre class="source-code">
VkRayTracingPipelineCreateInfoKHR pipeline_info{
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR };
pipeline_info.stageCount = shader_state_data-&gt;
    active_shaders;
pipeline_info.pStages = shader_state_data-&gt;
    shader_stage_info;
pipeline_info.groupCount = shader_state_data-&gt;
    active_shaders;
pipeline_info.pGroups = shader_state_data-&gt;
    shader_group_info;
pipeline_info.maxPipelineRayRecursionDepth = 1;
pipeline_info.layout = pipeline_layout;
vkCreateRayTracingPipelinesKHR( vulkan_device,
    VK_NULL_HANDLE, pipeline_cache, 1, &amp;pipeline_info,
        vulkan_allocation_callbacks, &amp;pipeline-&gt;vk_pipeline );
pipeline-&gt;vk_bind_point =
    VkPipelineBindPoint::VK_PIPELINE
        _BIND_POINT_RAY_TRACING_KHR;</pre>
<p>Notice the <strong class="source-inline">maxPipelineRayRecursionDepth</strong> field. It determines<a id="_idIndexMarker665"/> the maximum number of call stacks<a id="_idIndexMarker666"/> in case we have a recursive call to the <strong class="source-inline">rayTraceEXT</strong> function. This is needed by the compiler to determine how much memory could be used by this pipeline <span class="No-Break">at runtime.</span></p>
<p>We have omitted the <strong class="source-inline">pLibraryInfo</strong> and <strong class="source-inline">pLibraryInterface</strong> fields, as we are not using them. Multiple ray tracing pipelines can be combined to create a larger program, similar to how you link multiple objects in C++. This can help reduce compile times for ray tracing pipelines, as individual components need to be compiled <span class="No-Break">only once.</span></p>
<p>The last step is to create<a id="_idIndexMarker667"/> our shader binding<a id="_idIndexMarker668"/> table. We start by computing the size required for <span class="No-Break">our table:</span></p>
<pre class="source-code">
u32 group_handle_size =
    ray_tracing_pipeline_properties.shaderGroupHandleSize;
sizet shader_binding_table_size = group_handle_size *
    shader_state_data-&gt;active_shaders;</pre>
<p>We simply multiply the handle size by the number of entries in <span class="No-Break">our table.</span></p>
<p>Next, we call <strong class="source-inline">vkGetRayTracingShaderGroupHandlesKHR</strong> to get the handles of the groups in the ray <span class="No-Break">tracing pipeline:</span></p>
<pre class="source-code">
Array&lt;u8&gt; shader_binding_table_data{ };
shader_binding_table_data.init( allocator,
    shader_binding_table_size, shader_binding_table_size );
vkGetRayTracingShaderGroupHandlesKHR( vulkan_device,
    pipeline-&gt;vk_pipeline, 0, shader_state_data-&gt;
        active_shaders, shader_binding_table_size,
            shader_binding_table_data.data );</pre>
<p>Once we have the shader group handles, we can combine them to create individual tables for each shader type. They are stored in <span class="No-Break">separate buffers:</span></p>
<pre class="source-code">
BufferCreation shader_binding_table_creation{ };
shader_binding_table_creation.set(
    VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR |
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR,
    ResourceUsageType::Immutable, group_handle_size
    ).set_data( shader_binding_table_data.data
    ).set_name(  "shader_binding_table_raygen" );
pipeline-&gt;shader_binding_table_raygen = create_buffer(
    shader_binding_table_creation );
shader_binding_table_creation.set_data(
    shader_binding_table_data.data + group_handle_size )
        .set_name( "shader_binding_table_hit" );
pipeline-&gt;shader_binding_table_hit = create_buffer(
    shader_binding_table_creation );
shader_binding_table_creation.set_data(
    shader_binding_table_data.data + ( group_handle_size *
        2 ) ).set_name( "shader_binding_table_miss" );
pipeline-&gt;shader_binding_table_miss = create_buffer(
    shader_binding_table_creation );</pre>
<p>We only have one entry<a id="_idIndexMarker669"/> per table, so we simply copy each group handle into its buffer. Notice <a id="_idIndexMarker670"/>that the buffer has to be created with the <strong class="source-inline">VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR</strong> <span class="No-Break">usage flag.</span></p>
<p>This completes our ray tracing pipeline creation. All that’s left is to actually use it to generate an image! This is accomplished by the <span class="No-Break">following code:</span></p>
<pre class="source-code">
u32 shader_group_handle_size = gpu_device-&gt;
    ray_tracing_pipeline_properties.shaderGroupHandleSize;
VkStridedDeviceAddressRegionKHR raygen_table{ };
raygen_table.deviceAddress = gpu_device-&gt;
    get_buffer_device_address( pipeline-&gt;
        shader_binding_table_raygen );
raygen_table.stride = shader_group_handle_size;
raygen_table.size = shader_group_handle_size;
VkStridedDeviceAddressRegionKHR hit_table{ };
hit_table.deviceAddress = gpu_device-&gt;
    get_buffer_device_address( pipeline-&gt;
        shader_binding_table_hit );
VkStridedDeviceAddressRegionKHR miss_table{ };
miss_table.deviceAddress = gpu_device-&gt;
    get_buffer_device_address( pipeline-&gt;
        shader_binding_table_miss );
VkStridedDeviceAddressRegionKHR callable_table{ };
vkCmdTraceRaysKHR( vk_command_buffer, &amp;raygen_table,
    &amp;miss_table, &amp;hit_table, &amp;callable_table, width,
        height, depth );</pre>
<p>We define <strong class="source-inline">VkStridedDeviceAddressRegionKHR</strong> for each shader binding<a id="_idIndexMarker671"/> table. We use the table buffers<a id="_idIndexMarker672"/> we previously created. Notice that we still need to define a table for callable shaders, even if we are not using them. The <strong class="source-inline">width</strong>, <strong class="source-inline">height</strong>, and <strong class="source-inline">depth</strong> parameters determine the invocation size of our ray <span class="No-Break">tracing shader.</span></p>
<p>In this section, we have illustrated how to create and use a ray tracing pipeline. We started by defining the organization of our shader binding table. Next, we looked at a basic ray generation and closest hit shader. We then showed how to create a ray tracing pipeline object and how to retrieve shader <span class="No-Break">group handles.</span></p>
<p>These handles were then<a id="_idIndexMarker673"/> used to populate<a id="_idIndexMarker674"/> the buffers of our shader binding tables. Finally, we demonstrated how to combine all these components to invoke our ray <span class="No-Break">tracing pipeline.</span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor211"/>Summary</h1>
<p>In this chapter, we have provided the details on how to use ray tracing in Vulkan. We started by explaining two <span class="No-Break">fundamental concepts:</span></p>
<ul>
<li><strong class="bold">Acceleration </strong><strong class="bold">Structures</strong>: These are needed to speed up scene traversal. This is essential to achieve <span class="No-Break">real-time results.</span></li>
<li><strong class="bold">Shader binding tables</strong>: Ray tracing pipelines can invoke multiple shaders, and these tables are used to tell the API which shaders to use for <span class="No-Break">which stage.</span></li>
</ul>
<p>In the next section, we provided the implementation details to create TLASes and BLASes. We first record the list of geometries that compose our mesh. Next, we use this list to create a BLAS. Each BLAS can then be instanced multiple times within a TLAS, as each BLAS instance defines its own transform. With this data, we can then create <span class="No-Break">our TLAS.</span></p>
<p>In the third and final section, we explained how to create a ray tracing pipeline. We started with the creation of individual shader types. Next, we demonstrated how to combine these individual shaders into a ray tracing pipeline and how to generate a shader binding table from a <span class="No-Break">given pipeline.</span></p>
<p>Next, we have shown how to write a simple ray generation shader used in combination with a closest hit shader and a miss shader. Finally, we demonstrate how to combine all these pieces to trace rays in <span class="No-Break">our scene.</span></p>
<p>In the next chapter, we are going to leverage all the knowledge from this chapter to implement <span class="No-Break">ray-traced shadows!</span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor212"/>Further reading</h1>
<p>As always, we have only provided the most relevant details on how to use the Vulkan API. We recommend you read the Vulkan specification for more details. Here is the list of the most <span class="No-Break">relevant sections:</span></p>
<ul>
<li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#pipelines-ray-tracing"><span class="No-Break">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#pipelines-ray-tracing</span></a></li>
<li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#interfaces-raypipeline"><span class="No-Break">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#interfaces-raypipeline</span></a></li>
<li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#acceleration-structure"><span class="No-Break">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#acceleration-structure</span></a></li>
<li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#ray-tracing"><span class="No-Break">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#ray-tracing</span></a></li>
</ul>
<p>This website provides more details on Acceleration <span class="No-Break">Structures: </span><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-acceleration-structure/introduction"><span class="No-Break">https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-acceleration-structure/introduction</span></a><span class="No-Break">.</span></p>
<p>There are plenty of resources online about real-time ray tracing. It’s still a novel field and subject to ongoing research. A good starting point is provided by these two freely <span class="No-Break">available books:</span></p>
<ul>
<li><a href="http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml"><span class="No-Break">http://www.realtimerendering.com/raytracinggems/rtg/index.xhtml</span></a></li>
<li><a href="http://www.realtimerendering.com/raytracinggems/rtg2/index.xhtml"><span class="No-Break">http://www.realtimerendering.com/raytracinggems/rtg2/index.xhtml</span></a></li>
</ul>
</div>
</div></body></html>