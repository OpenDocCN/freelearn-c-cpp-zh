- en: Chapter 2. Give It Some Structure – Building the Game Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 给它一些结构 – 构建游戏框架
- en: 'Working on a project with poor structure is much like building a house with
    no foundation: it''s difficult to maintain, extremely unstable, and will probably
    cause you to abandon it shortly. While the code we worked on in [Chapter 1](ch01.html
    "Chapter 1. It''s Alive! It''s Alive! – Setup and First Program"), *It''s Alive!
    It''s Alive! – Setup and First Program*, is functional and can be managed on a
    very small scale, expanding it without first building a solid framework would
    most likely result in tons of *spaghetti code* (not to be confused with ravioli
    code or lasagna code) being present. Although it sounds delicious, this pejorative
    term describes the pain of a new feature being exponentially more difficult to
    implement within the source code that is unstructured and executes in a "tangled"
    manner, which is something we''ll be focusing on avoiding.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个结构不良的项目上工作就像在没有地基的情况下建造房子：很难维护，极其不稳定，你可能会很快放弃它。虽然我们在[第1章](ch01.html "第1章.
    它活着！它活着！ – 设置和第一个程序")中工作的代码，*它活着！它活着！ – 设置和第一个程序*，在非常小的规模上是功能性的，并且可以管理，但在没有首先构建一个坚实的框架的情况下扩展它很可能会导致大量的*意大利面代码*（不要与意大利面代码或千层面代码混淆）。虽然听起来很美味，但这个贬义词描述了在无结构且以“纠缠”方式执行源代码中实现新特征的指数级困难，这是我们将会着重避免的。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Designing a window class, along with a main game class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计窗口类和主游戏类
- en: Code restructuring and proper architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重构和适当的架构
- en: The importance of proper time management in applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中适当的时间管理的重要性
- en: Using `sf::Clock` and `sf::Time` classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sf::Clock` 和 `sf::Time` 类
- en: Fixed and variable time-steps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定和可变的时间步长
- en: Graduating to ravioli
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 晋升到意大利面
- en: 'Let''s start small. Every game needs to have a window, and as you already know
    from [Chapter 1](ch01.html "Chapter 1. It''s Alive! It''s Alive! – Setup and First
    Program"), *It''s Alive! It''s Alive! – Setup and First Program*, it needs to
    be created, destroyed, and its events need to be processed. It also needs to be
    able to clear the screen and update itself to show anything drawn after the screen
    was cleared. Additionally, keeping track of whether the window is being closed
    and if it''s in full-screen mode, as well as having a method to toggle the latter
    would be quite useful. Lastly, we will, of course, need to draw to the window.
    Knowing all of that, the header of our window class will predictably look something
    like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单开始。每个游戏都需要有一个窗口，正如你从[第1章](ch01.html "第1章. 它活着！它活着！ – 设置和第一个程序")，*它活着！它活着！
    – 设置和第一个程序*中已经知道的，它需要被创建、销毁，并且需要处理其事件。它还需要能够清除屏幕并更新自身以显示在屏幕清除之后绘制的任何内容。此外，跟踪窗口是否正在关闭以及它是否处于全屏模式，以及有一个方法可以切换后者将会非常有用。最后，我们当然需要将内容绘制到窗口中。了解所有这些，我们的窗口类头文件可能会预见到如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because we want to handle setting up our window internally, the setup method
    is made private, as well as the destroy and create methods. Think of these as
    just helper methods that the user of this class doesn't need to know about. It's
    a good idea to keep certain information around after the setup is done, such as
    the window size or the title that's being displayed above it. Lastly, we keep
    around two Boolean variables to keep track of the window being closed and its
    state regarding full screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在内部处理窗口的设置，设置方法被设置为私有，以及销毁和创建方法。将这些视为用户不需要了解的辅助方法。在设置完成后保留某些信息是个好主意，比如窗口大小或显示在其上的标题。最后，我们保留两个布尔变量来跟踪窗口是否关闭以及其全屏状态。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The naming convention that''s being employed in our window class is referred
    to as the **Hungarian notation**. Using it is, of course, not required, but it
    can prove useful when dealing with lots of code, trying to track down bugs, and
    working in larger groups of people. We''ll be utilizing it throughout this book.
    More information about it can be found here: [http://en.wikipedia.org/wiki/Hungarian_notation](http://en.wikipedia.org/wiki/Hungarian_notation)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们窗口类中使用的命名约定被称为**匈牙利符号法**。当然，使用它不是必需的，但在处理大量代码、尝试追踪错误以及在更大的人群中工作时，它可能很有用。我们将在这本书中利用它。更多关于它的信息可以在这里找到：[http://en.wikipedia.org/wiki/Hungarian_notation](http://en.wikipedia.org/wiki/Hungarian_notation)
- en: Implementing the window class
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现窗口类
- en: 'Now that we have our blueprint, let''s begin actually building our window class.
    The entry and exit points seem as good a place as any to start with:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的蓝图，让我们开始实际构建我们的窗口类。入口和出口点似乎是开始的好地方：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Both implementations of the constructor and destructor simply utilize the helper
    methods which we''ll be implementing shortly. There''s also a default constructor
    that takes no arguments and initializes some pre-set default values, which is
    not necessary, but it''s convenient. With that said, let''s take a look at the
    setup method:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和析构函数的实现只是简单地利用我们很快将要实现的辅助方法。还有一个默认构造函数，它不接受任何参数并初始化一些预设的默认值，这不是必需的，但很方便。话虽如此，让我们看看设置方法：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once again, this is quite simple. As mentioned before, it initializes and keeps
    track of some of the window properties that will be passed to the constructor.
    Aside from that, it calls another method named `Create` to break up the code even
    more, which is what we''ll be implementing next in addition to the `Destroy` method:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这很简单。如前所述，它初始化并跟踪一些将要传递给构造函数的窗口属性。除此之外，它还调用另一个名为 `Create` 的方法来进一步分解代码，这是我们将在实现
    `Destroy` 方法之后要实现的内容：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we introduce a new data type that SFML offers: `sf::Uint32`. It gets
    stored inside the `style` local variable, which is automatically deduced to said
    type by using the `auto` keyword. It''s simply an unsigned, fixed size integer
    type. In this particular case, we''re using the *32-bit* integer, although SFML
    offers both signed and unsigned types of *8*, *16*, and *32* bits. We use this
    value to hold the current style for a window using a *ternary operator* and assigning
    it to either the default or full screen styles of the window style enumeration.
    This is the full list of all possible window styles within SFML:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍 SFML 提供的一种新数据类型：`sf::Uint32`。它存储在 `style` 本地变量中，通过使用 `auto` 关键字自动推断为该类型。它是一个无符号的固定大小整数类型。在这种情况下，我们使用的是
    *32 位* 整数，尽管 SFML 提供了 *8 位*、*16 位* 和 *32 位* 的有符号和无符号类型。我们使用这个值来保存窗口的当前样式，使用 *三元运算符*
    并将其分配给窗口样式枚举的默认或全屏样式。这是 SFML 中所有可能的窗口样式的完整列表：
- en: '| Enumerator | Description | Mutually exclusive |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 枚举器 | 描述 | 互斥 |'
- en: '| --- | --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| None | No border or title bar. The most minimalistic style. | Yes |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 没有边框或标题栏。最简约的样式。 | 是 |'
- en: '| Fullscreen | Full screen mode. | Yes |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 全屏 | 全屏模式。 | 是 |'
- en: '| Titlebar | Title bar and a fixed border. | No |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 标题栏 | 标题栏和固定边框。 | 否 |'
- en: '| Close | Title bar and a close button. | No |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 关闭 | 标题栏和关闭按钮。 | 否 |'
- en: '| Resize | Title bar, resizable border and a maximize button. | No |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 调整大小 | 标题栏、可调整大小的边框和最大化按钮。 | 否 |'
- en: '| Default | Title bar, resizable border, maximize and close buttons. | No |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 默认 | 标题栏、可调整大小的边框、最大化和关闭按钮。 | 否 |'
- en: 'The mutually exclusive column simply denotes whether the style in question
    can be used with other styles in tandem. For example, it is possible to have a
    window with a title bar, resizable border, the maximize button, and a close button
    by combining two styles together using the bitwise *or* operator in C++:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥列仅表示所讨论的样式是否可以与其他样式同时使用。例如，通过在 C++ 中使用位或运算符组合两种样式，可以拥有一个带有标题栏、可调整大小的边框、最大化按钮和关闭按钮的窗口：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If, however, a style is mutually exclusive, it cannot be used with any other
    styles in this way.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个样式是互斥的，则不能以这种方式与其他任何样式一起使用。
- en: Once we have our style, we can simply pass it to the `create` method of our
    window, in addition to the `sf::VideoMode` type that gets constructed, using uniform
    initialization. It's that simple.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们的样式，我们只需将其传递给窗口的 `create` 方法，以及构造时得到的 `sf::VideoMode` 类型，使用统一初始化。就这么简单。
- en: The `destroy` method of our `Window` class will simply close the window by invoking
    its `close` method. It's important to note here that the closed window will have
    all of its attached resources destroyed, but you can still call its `create` method
    again to re-create the window. Polling events and calling the `display` method
    will still work if a window is closed. It will just have no effect.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `Window` 类的 `destroy` 方法将简单地通过调用其 `close` 方法来关闭窗口。这里需要注意的是，关闭的窗口将销毁其所有附加的资源，但您仍然可以再次调用其
    `create` 方法来重新创建窗口。如果窗口关闭，轮询事件和调用 `display` 方法仍然有效，但不会有任何效果。
- en: 'Let''s proceed in breaking up our once solid chunk of code by processing the
    events of the window in the appropriate `update` method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在适当的 `update` 方法中处理窗口的事件来继续分解我们之前的一块代码：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s the same drill as before, we''re simply handling events. Instead of closing
    the window right off the bat, however, we simply flip the Boolean flag we keep
    around for checking if the window has been closed or not: `m_isDone`. Since we''re
    also interested in toggling between full screen and normal states of our window,
    we need to keep an eye out for another type of event: `sf::Event::KeyPressed`.
    This event gets dispatched whenever a keyboard key is pressed down and it includes
    information about that key stored in the `event.key` struct. For now, we''re only
    interested in the code of the key being pressed, which we can then check against
    the `sf::Keyboard` enumeration table. Upon receiving an event of an *F5* key being
    pressed, we call the `ToggleFullscreen` method, which is fairly simple to implement
    now that we have broken up the code into manageable sections:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这和之前一样，我们只是在处理事件。然而，我们不是立即关闭窗口，而是简单地翻转我们用来检查窗口是否已关闭的布尔标志`m_isDone`。由于我们还在切换窗口的全屏和正常状态之间切换，我们需要注意另一种类型的事件：`sf::Event::KeyPressed`。每当键盘按键被按下时，都会分发此事件，并且它包含有关该键的信息，存储在`event.key`结构中。目前，我们只对按下的键的代码感兴趣，然后我们可以将其与`sf::Keyboard`枚举表进行比较。在接收到按下*F5*键的事件时，我们调用`ToggleFullscreen`方法，现在由于我们将代码分解成可管理的部分，这个方法实现起来相当简单：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the only thing we do here is invert the value of our *Boolean*
    class member, `m_isFullscreen`, that keeps track of the window state. Afterwards,
    we need to destroy and re-create the window in order to make it honor our changes.
    Let''s take a look at the drawing methods:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在这里做的唯一一件事就是反转我们的布尔类成员`m_isFullscreen`的值，它跟踪窗口状态。之后，我们需要销毁并重新创建窗口，以便使其遵守我们的更改。让我们看看绘图方法：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Nothing new gets introduced here. We''re simply wrapping the functionality
    of clearing and displaying in `BeginDraw` and `EndDraw` methods. All that''s left
    now are the simple helper methods:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有引入任何新内容。我们只是在`BeginDraw`和`EndDraw`方法中封装了清除和显示的功能。现在剩下的只是简单的辅助方法：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These basic methods provide the means for retrieving information about the window
    without giving too much control to anything outside the window class. For now,
    our window class is more than sufficient.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本方法提供了获取窗口信息的方式，同时不会给窗口类外部的东西太多控制。目前，我们的窗口类已经足够。
- en: Building the game class
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游戏类
- en: 'We''ve done a good job at wrapping up the basic functionality of our window
    class, but that''s not the only chunk of code in need of refactoring. In [Chapter
    1](ch01.html "Chapter 1. It''s Alive! It''s Alive! – Setup and First Program"),
    *It''s Alive! It''s Alive! – Setup and First Program*, we''ve discussed the main
    game loop and its contents, mainly processing input, updating the game world and
    the player, and finally, rendering everything on screen. Cramming all of that
    functionality into the game loop alone is generally known to produce spaghetti
    code, and since we want to move away from that, let''s consider a better structure
    that would allow this kind of behavior:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经很好地完成了窗口类的基本功能封装，但这并不是唯一需要重构的代码块。在[第1章](ch01.html "第1章。它活着！它活着！——设置和第一个程序")中，“它活着！它活着！——设置和第一个程序”，我们讨论了主游戏循环及其内容，主要是处理输入、更新游戏世界和玩家，最后，在屏幕上渲染一切。将所有这些功能塞进游戏循环中通常会导致代码混乱，既然我们想要摆脱这种状况，让我们考虑一个更好的结构，这将允许这种行为：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code above represents the *entire* content of our `main.cpp` file and perfectly
    illustrates the use of a properly structured game class, which doesn''t go beyond
    calling the proper methods in the right order in an endless loop until the window
    is closed. Just for the sake of clarity, let''s take a look at a simplified version
    of the game class header:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码代表了我们的`main.cpp`文件的*全部*内容，并完美地说明了正确结构的游戏类的使用，它不会在无限循环中调用适当的顺序直到窗口关闭。为了清晰起见，让我们看看游戏类头文件的简化版本：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the game class holds an instance of our window. It can be done differently,
    but for our current needs this will more than suffice.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，游戏类持有我们的窗口实例。它可以以不同的方式完成，但就我们当前的需求而言，这已经足够了。
- en: Putting our code to work
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的代码投入实际应用
- en: 'We''re now ready to re-implement the bouncing mushroom demo from [Chapter 1](ch01.html
    "Chapter 1. It''s Alive! It''s Alive! – Setup and First Program"), *It''s Alive!
    It''s Alive! – Setup and First Program*. Given how simple it is, we''ll walk you
    through the entire process of adapting our previously written code to our new
    structure. Let''s begin by setting up our window and graphics we''ll be using:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备重新实现来自[第1章](ch01.html "第1章。它活着！它活着！——设置和第一个程序")的弹跳蘑菇演示，“它活着！它活着！——设置和第一个程序”。鉴于它的简单性，我们将向您展示如何将我们之前编写的代码适应到我们的新结构中的整个过程。让我们首先设置我们将要使用的窗口和图形：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because we have nothing to clean up, our game destructor will remain empty
    for now:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有什么要清理的，我们的游戏析构函数现在仍然是空的：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have no need to check for input for this example, so let''s leave that method
    alone for now. What we will be doing, however, is updating the position of our
    sprite each frame:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们没有必要检查输入，所以现在让我们暂时忽略这个方法。然而，我们将要做的是更新我们的精灵在每个帧的位置：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Literally the first thing you''ll probably notice is the update method call
    of our window class. We''ve already covered the importance of *event processing*
    in SFML, but it''s still worthy to note that one more time. The rest of the code
    is pretty much the same, except we now have a separate method that is responsible
    for updating the position of the mushroom sprite. We used two local variables
    to hold the window and texture sizes in order to increase readability, but that''s
    about it. Time to draw our sprite to the screen:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先注意到的是我们窗口类的更新方法调用。我们已经在SFML中讨论了 *事件处理* 的重要性，但仍然值得再次强调。其余的代码基本上是一样的，只是我们现在有一个单独的方法负责更新蘑菇精灵的位置。我们使用了两个局部变量来保存窗口和纹理的大小，以提高可读性，但这基本上就是所有的事情。现在是时候将我们的精灵绘制到屏幕上了：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once again, the code is fairly straight forward. Our window class does all the
    work, and all we have to do is call the `Draw` method and pass in our `sf::Drawable`
    right in between the wrapper methods for clearing the screen and displaying the
    changes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，代码相当直接。我们的窗口类做所有的工作，我们只需要调用 `Draw` 方法，并在清除屏幕和显示更改的包装方法之间传递我们的 `sf::Drawable`。
- en: Putting everything together and running it should produce the exact same bouncing
    mushroom we had back in [Chapter 1](ch01.html "Chapter 1. It's Alive! It's Alive!
    – Setup and First Program"), *It's Alive! It's Alive! – Setup and First Program*.
    However, you may have noticed that the sprite moves differently based on how busy
    your computer is. In this observation lies an important lesson about game development.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将一切组合起来并运行它应该会产生与[第1章](ch01.html "第1章。它活着！它活着！——设置和第一个程序")，“它活着！它活着！——设置和第一个程序”中相同的弹跳蘑菇。然而，你可能已经注意到，精灵的移动方式取决于你的电脑有多忙。在这个观察中，隐藏着一个关于游戏开发的重要教训。
- en: Hardware and execution time
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件和执行时间
- en: 'Let''s travel back in time to May 5, 1992\. Apogee Software begins publishing
    the now known cult classic *Wolfenstein 3D* developed by *id Software*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到1992年5月5日。Apogee软件开始发布由 *id Software* 开发的现在已知的经典之作 *Wolfenstein 3D*：
- en: '![Hardware and execution time](img/4284_02_01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![硬件和执行时间](img/4284_02_01.jpg)'
- en: The man with the vision, *John Carmack*, took massive strides forward and not
    only popularized, but also revolutionized the first person shooter genre on the
    PC. Its massive success cannot be overstated, as even now it's difficult to accurately
    predict how many times it has been downloaded. Having grown up at right around
    that time, one can't help but feel nostalgic sometimes and attempt to play this
    game again. Ever since its original release for the *DOS* operating system on
    the PC, it has been ported to many other operating systems and consoles. While
    it's still possible to play it, we've come a long way since the days of using
    DOS. The environment our software runs in has fundamentally changed, ergo the
    software from the past is no longer compatible, hence the need for emulation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 具有远见卓识的人，*约翰·卡马克*，在个人电脑上的第一人称射击游戏类型中迈出了巨大的步伐，不仅普及了这一类型，而且还彻底改变了它。它的巨大成功不容小觑，因为即使现在也很难准确预测它被下载了多少次。在那个时代长大的人，有时不禁会感到怀旧，并试图再次玩这款游戏。自从它在个人电脑上的
    *DOS* 操作系统上首次发布以来，它已经被移植到许多其他操作系统和游戏机上。虽然现在仍然可以玩它，但我们已经从使用DOS的时代走了很长的路。我们软件运行的环境已经发生了根本性的变化，因此过去的软件不再兼容，这就需要仿真。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An **emulator** is either software, hardware, or the combination of both, that
    simulates the functionality of a certain system, usually referred to as a guest,
    on a primary system, referred to as the host.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟器**是软件、硬件或两者的组合，它模拟了在主系统（称为主机）上运行的一定系统的功能，通常称为客户机。'
- en: Every emulator used for this purpose not only has to imitate the software of
    a system that would be compatible with a title you're attempting to play, but
    also the hardware. Why is that important? Most games in the days of DOS counted
    on the hardware being roughly similar. In the case of Wolfenstein 3D, it assumed
    it was running on a *4.77 MHz* system, which allowed the developers to save some
    clock cycles for the sake of efficiency by not writing internal timing loops.
    A game like Wolfenstein 3D consumed all of the processing power, which was a fine
    strategy for the time, until more powerful and faster processors came about. Today,
    the puny 4.77 MHz speed is dwarfed by comparison, even when looking at all of
    the cheapest consumer-grade processors, so proper emulation of a specific system
    also requires the reduction of CPU clock cycles, otherwise these games will run
    too fast, which is exactly what happens when an emulator is set up in the wrong
    way and doesn't throttle the speed enough.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此目的的每个模拟器不仅需要模仿一个与你要尝试玩的游戏兼容的系统的软件，还需要模仿硬件。为什么这很重要？在DOS时代，大多数游戏都依赖于硬件的大致相似性。在《狼人之三》的例子中，它假设它在一个*4.77
    MHz*的系统上运行，这使得开发者可以通过不编写内部定时循环来节省一些时钟周期以提高效率。像《狼人之三》这样的游戏消耗了所有的处理能力，这在当时是一个很好的策略，直到更强大、更快的处理器出现。如今，即使是所有最便宜的消费级处理器，4.77
    MHz的速度也相形见绌，因此，正确模拟特定系统还需要减少CPU时钟周期，否则这些游戏会运行得太快，这正是当模拟器设置不正确且没有足够限制速度时发生的情况。
- en: 'While this is the most extreme example, speed management is an important component
    of any piece of software today that has to run at a constant speed. Different
    choices of hardware and architecture aside, your software might run faster or
    slower simply based on how busy your system is at the time or the different tasks
    your code needs to accomplish every iteration before the image is rendered. Consider
    the following illustration:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个最极端的例子，但速度管理是任何需要以恒定速度运行的软件的重要组件。抛开硬件和架构的不同选择，你的软件可能仅仅基于系统在那一刻的繁忙程度或代码在渲染图像之前每轮需要完成的任务的不同，运行得更快或更慢。考虑以下说明：
- en: '![Hardware and execution time](img/4284_02_02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![硬件和执行时间](img/4284_02_02.jpg)'
- en: The changes on the left side as well as the right side both take place over
    a 1 second interval. The code is exactly the same in both cases. The only difference
    is the number of iterations the main loop manages to complete during that interval.
    Predictably, the slower hardware will take longer to execute your code and therefore
    will yield fewer iterations, resulting in the sprite being moved fewer times during
    our 1 second time interval and end up looking like the left side. As a game developer,
    it is important to ensure that your product runs the same on all systems within
    the designated specification guidelines. This is where SFML time management comes
    in.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧和右侧的变化都在1秒的时间间隔内发生。在这两种情况下，代码完全相同。唯一的区别是主循环在那个间隔内完成的迭代次数。可以预见，硬件越慢，执行你的代码所需的时间就越长，因此迭代次数会更少，导致在1秒的时间间隔内精灵移动的次数更少，最终看起来像左侧。作为一个游戏开发者，确保你的产品在指定的规范指南内的所有系统上运行相同是很重要的。这就是SFML时间管理发挥作用的地方。
- en: Controlling the frame-rate
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制帧率
- en: 'SFML provides a means of setting a frame-rate cap for your applications. It''s
    a method in the `sf::RenderWindow` class, appropriately called `setFramerateLimit`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SFML提供了一种为你的应用程序设置帧率上限的方法。这是`sf::RenderWindow`类中的一个方法，恰当地命名为`setFramerateLimit`：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Although this feature is not absolutely reliable, it ensures that the application's
    frame-rate is capped at the provided maximum value with reasonable precision,
    as long as the provided cap isn't too high. Keep in mind that capping the frame-rate
    reduces the overall CPU consumption of the program as well, since it doesn't need
    to update and re-draw the same scene as many times anymore. It does, however,
    raise a problem for slower hardware. If the frame-rate is lower than the provided
    value, the simulation will run slower too. Setting the limit solves only half
    of our problem. Let's take a look at something more practical. Enter `sf::Clock`!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个特性并不绝对可靠，但它确保了只要提供的上限不是太高，应用程序的帧率以合理的精度被限制在提供的最大值。记住，限制帧率会降低程序的总体CPU消耗，因为它不再需要多次更新和重新绘制相同的场景。然而，这也会为较慢的硬件带来问题。如果帧率低于提供的值，模拟也会运行得更慢。设置限制只解决了我们问题的一半。让我们看看一些更实际的东西。进入`sf::Clock`！
- en: Using the SFML clock
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SFML时钟
- en: 'The `sf::Clock` class is very simple and lightweight, so it has only two methods:
    `getElapsedTime()` and `restart()`. Its sole purpose is to measure elapsed time
    since the last instance of the clock being restarted, or since its creation, in
    the most precise manner the operating system can provide. When retrieving the
    elapsed time using the `getElapsedTime` method, it returns a type `sf::Time`.
    The main reasoning behind that is an additional layer of abstraction to provide
    flexibility and avoid imposing any fixed data types. The `sf::Time` class is also
    lightweight and provides three useful methods for conversion of elapsed time to
    seconds which returns a *floating point* value, milliseconds, which returns *a
    32-bit integer* value and microseconds, which returns a *64-bit integer* value,
    as represented here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Clock`类非常简单且轻量级，因此它只有两个方法：`getElapsedTime()`和`restart()`。它的唯一目的是以操作系统能提供的最精确的方式测量自上次时钟重启或创建以来的经过时间。当使用`getElapsedTime`方法检索经过时间时，它返回一个类型为`sf::Time`的值。背后的主要原因是增加一层抽象，以提供灵活性和避免强加任何固定数据类型。《sf::Time`类也是轻量级的，并提供三个将经过时间转换为秒的方法，返回一个*浮点*值，毫秒，返回一个*32位整数*值，以及微秒，返回一个*64位整数*值，如下所示：'
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, the `restart` method also returns an `sf::Time` value. This
    is provided in order to avoid calling `getElapsedTime` right before calling the
    `restart` method and having some time pass between those two calls that would
    otherwise be unaccounted for. How is this useful for us? Well, the problem we
    were dealing with was the same code running differently on other platforms because
    we couldn''t account for their speed. We moved our sprite across the screen using
    this line of code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`restart`方法也返回一个`sf::Time`值。这是为了防止在调用`restart`方法之前立即调用`getElapsedTime`，在这两个调用之间会有一些时间流逝，否则将无法计算。这对我们有什么用呢？好吧，我们处理的问题是相同的代码在其他平台上运行不同，因为我们无法计算它们的速度。我们使用以下代码行在屏幕上移动精灵：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `m_increment` vector here is used with an assumption that the time between
    iterations is constant, but that''s obviously not true. Recall the magic triangle
    for the speed, time, and distance formula:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的`m_increment`向量是基于假设迭代之间的时间间隔是恒定的，但显然这不是真的。回想一下速度、时间和距离公式的神奇三角形：
- en: '![Using the SFML clock](img/4284_02_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![使用SFML时钟](img/4284_02_03.jpg)'
- en: 'Finding the distance a sprite should travel in between updates can be done
    by first defining a set speed at which it moves. The time value here is simply
    how long it takes for an entire cycle of the program to finish. In order to accurately
    measure that, we''re going to be adjusting the `Game` class to utilize the `sf::Clock`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到精灵在更新之间应该旅行的距离，首先需要定义一个移动速度。这里的时间值只是整个程序周期完成所需的时间。为了准确测量，我们将调整`Game`类以利用`sf::Clock`：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The two new public methods we''ve added can be implemented like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的两个新公共方法可以这样实现：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once that is done, it''s important to actually utilize this functionality and
    restart the game clock after each iteration. That can be achieved in the main
    game loop by simply calling the `RestartClock` method after all the work is done:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，实际上利用这个功能并在每次迭代后重启游戏时钟是很重要的。这可以通过在主游戏循环中在所有工作完成后简单地调用`RestartClock`方法来实现：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last line in the loop will make sure that the `m_elapsed` member of the
    game class will always have a value of the time passed during the previous iteration,
    so let''s use that time and determine how far our sprite should have moved:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中的最后一行将确保游戏类中的`m_elapsed`成员始终具有上一次迭代期间经过的时间值，所以让我们使用这个时间来确定我们的精灵应该移动多远：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''re now using `m_increment` as a variable of speed, not distance. By looking
    at our previous code in the constructor, we''ve set both *x* and *y* values of
    the `m_increment` vector to a value of `4`. Since we''re expressing our elapsed
    time as seconds, this is essentially like saying that the sprite needs to move
    *4* pixels a second. That''s really slow, so let''s change it to something a little
    bit more stimulating:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用`m_increment`作为速度变量，而不是距离。通过查看我们在构造函数中的前一段代码，我们将`m_increment`向量的*x*和*y*值都设置为`4`。由于我们用秒来表示经过的时间，这实际上意味着精灵需要每秒移动*4*像素。这真的很慢，所以让我们将其改为更有刺激性的值：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Upon compiling and running the project, you should see our sprite happily bouncing
    across the screen. It will now be moved the same distance on every single machine
    it''s executed on, no matter how choppy the frame-rate is. For extra points, try
    it out yourself by artificially slowing down the game loop with the `sf::sleep`
    function that SFML provides, like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目后，你应该看到我们的精灵在屏幕上快乐地弹跳。现在，无论在哪个机器上执行，它都会移动相同的距离，无论帧率有多不稳定。为了加分，你可以通过使用SFML提供的`sf::sleep`函数人工减慢游戏循环来尝试一下，如下所示：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Feel free to adjust the argument passed to the sleep function. You will notice
    that it moves the sprite across exactly the same distance, no matter how long
    each iteration takes to finish.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 随意调整传递给sleep函数的参数。你会发现，无论每次迭代完成需要多长时间，精灵都会移动相同的距离。
- en: Fixed time-step
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定时间步长
- en: 'In some cases, the code for time management that we''ve written doesn''t really
    apply correctly. Let''s say we only want to call certain methods at a fixed rate
    of 60 times per second. It could be a physics system that requires updating only
    a certain amount of times, or it can be useful if the game is grid-based. Whatever
    the case is, when an update rate is really important, a fixed time-step is your
    friend. Unlike the variable time-step, where the next update and draw happens
    as soon as the previous one is done, the fixed time-step approach will ensure
    that certain game logic is only happening at a provided rate. It''s fairly simple
    to implement a fixed time-step. First, we must make sure that instead of overwriting
    the elapsed time value of the previous iteration, we add to it like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们编写的代码对于时间管理并不完全适用。假设我们只想以每秒60次的固定速率调用某些方法。这可能是一个需要仅更新一定次数的物理系统，或者如果游戏是网格基础的，它可能很有用。无论情况如何，当更新速率非常重要时，固定时间步长是你的朋友。与可变时间步长不同，其中下一次更新和绘制会在前一次完成后立即发生，固定时间步长方法将确保某些游戏逻辑仅在提供的速率下发生。实现固定时间步长相当简单。首先，我们必须确保不是覆盖前一次迭代的经过时间值，而是像这样将其添加到：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The basic expression for calculating the amount of time for an individual update
    throughout a 1 second interval is illustrated here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一秒内单个更新的时间的基本表达式在这里展示：
- en: '![Fixed time-step](img/4284_02_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![固定时间步长](img/4284_02_04.jpg)'
- en: 'Let''s say we want our game to update *60* times a second. To find the frame
    time, we would divide *1* by *60* and check if the elapsed time has exceeded that
    value, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想让我们的游戏每秒更新*60*次。为了找到帧时间，我们将*1*除以*60*，并检查经过的时间是否超过了这个值，如下所示：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice the subtraction at the end. This is how we reset the cycle and keep the
    simulation running at a *constant* speed. Depending on your application, you might
    want to put it to *sleep* in between updates in order to relieve the CPU. Aside
    from that detail, these are the bare bones of the fixed time-step. This is the
    exact technique that will be used in the game that we will finish building in
    the next chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后的减法。这是我们重置周期并保持模拟以恒定速度运行的方式。根据你的应用，你可能会想在更新之间将其“休眠”，以减轻CPU的负担。除了这个细节之外，这些都是固定时间步长的基本框架。这正是我们将在下一章中完成构建的游戏所使用的技术。
- en: Common mistakes
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见错误
- en: Often, when using clocks, newbies to SFML tend to stick them in the wrong places
    and restart them at the wrong times. Things like that can result in "funky" behavior
    at best.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当使用时钟时，SFML的新手往往会把它们放在错误的位置，并在错误的时间重新启动它们。这类事情最多只会导致“古怪”的行为。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that every line of code that isn't empty or commented out takes
    time to execute. Depending on how a function that is being called, or a class
    that is being constructed, is implemented, the time value might range from miniscule
    to infinite.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每行非空或非注释的代码都需要时间来执行。根据被调用的函数或正在构造的类的实现方式，时间值可能从微不足道到无限。
- en: Things like updating all of the game entities in the world, performing calculations,
    and rendering are fairly computationally expensive, so make sure to not somehow
    exclude these calls from the span of your time measurement. Always make sure that
    restarting the clock and grabbing the elapsed time is the *last* thing you're
    doing before the main game loop ends.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更新游戏世界中的所有游戏实体、执行计算和渲染等操作，在计算上相当昂贵，所以请确保不要以某种方式排除这些调用在时间测量的范围内。始终确保在主游戏循环结束时重启时钟和获取经过的时间是最后做的事情。
- en: 'Another mistake is having your clock object within the wrong scope. Consider
    this example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个错误是将时钟对象放在了错误的作用域内。考虑以下示例：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Assuming that the intention of this code was to measure anything else other
    than the time since the `sf::Clock` object was initiated, this code will produce
    faulty results. Creating an instance of a clock simply measures the time it has
    been alive within its scope, not anything else. This is the reason why the clock
    in the game class was declared as the class member. Since the clock is *created
    on the stack*, as soon as the method above concludes, the clock will be destroyed
    again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这段代码的目的是测量除 `sf::Clock` 对象启动以来的时间之外的任何东西，这段代码将产生错误的结果。创建时钟实例只是测量它在作用域内存在的时间，而不是其他任何东西。这也是为什么游戏类中的时钟被声明为类成员的原因。由于时钟是在栈上创建的，一旦上述方法结束，时钟就会被再次销毁。
- en: 'Keeping an elapsed time in a `float` data type, or any other data type that
    isn''t `sf::Time` for that matter, is also something that''s generally frowned
    upon. Something like this would not be a great example of proper use of SFML:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将经过的时间保存在 `float` 数据类型中，或者任何其他不是 `sf::Time` 的数据类型，通常也是不被推荐的。以下这样的例子并不是正确使用 SFML
    的好例子：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Although it works, this isn't exactly type-safe. It also requires more type
    conversions along the way, since you have to call one of the three conversion
    methods each time the clock gets restarted. One more nail to seal the coffin would
    be code readability. SFML provides its own time class for a reason and convenience,
    so unless there's a good reason not to use it, do avoid any other data types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它可行，但这并不完全类型安全。由于每次时钟重启时都必须调用三种转换方法之一，因此它还需要进行更多的类型转换。代码的可读性也是一个问题。SFML 提供自己的时间类是为了方便，所以除非有充分的理由不使用它，否则请避免使用其他数据类型。
- en: One last thing that deserves a mention since we're talking about time is the
    console output in C++. While it's just fine to print something out every now and
    then, even for just debugging purposes, constant console spam will slow your application
    down. The console output itself is quite slow and cannot be expected to execute
    at exactly the same speed as the rest of your program. Printing something on every
    iteration of the main game loop, for example, would throttle your application
    speed horribly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们正在讨论时间，所以值得提一下的是 C++ 中的控制台输出。虽然偶尔打印一些内容是可以接受的，甚至只是为了调试目的，但持续的 console
    spam 会减慢你的应用程序速度。控制台输出本身相当慢，并且不能期望它以与程序其他部分相同的速度执行。例如，在主游戏循环的每次迭代中打印内容，将会极大地降低应用程序的速度。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations on finishing the second chapter of this book! As mentioned previously,
    it is imperative that you understand everything covered in this chapter, since
    everything that follows will rely heavily on what we covered here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了这本书的第二章！正如之前提到的，理解本章涵盖的所有内容至关重要，因为接下来的一切都将严重依赖于这里所讨论的内容。
- en: Smooth and consistent results on different platforms and under different conditions
    are just as important as a good structure of an application, which is yet another
    layer of lasagna, if you will. Upon successful completion of this chapter, you
    are left yet again with sufficient knowledge to produce applications that can
    utilize both fixed and variable time-steps in order to create simulations that
    run identically and independently of the underlying architecture.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同平台和不同条件下获得平滑和一致的结果，与一个应用程序的良好结构一样重要，这又是一个“千层面”的层次。完成本章后，你将再次拥有足够的知识来制作能够利用固定和可变时间步长来创建独立于底层架构的模拟应用程序。
- en: Finally, we will leave you with a piece of good advice. The first few chapters
    are something most readers follow relatively closely and literally. While that's
    an acceptable way of doing things, we'd prefer you to use this more like a guide
    instead of a recipe. The most amazing thing about human knowledge is that it isn't
    simply absorbed through endless memorization. Experimentation and gaining actual
    experience is the other half of the key to successfully mastering this, so go
    ahead and write code. Write it good or bad, compile it, or get a bunch of errors,
    run it or crash it, it's good either way. Try out new things and fail miserably
    in order to one day succeed spectacularly. You are well on your way to getting
    your hands dirty, as we will actually begin implementing our first game project
    for this book in the next chapter. See you there!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将给你留下一条宝贵的建议。前几章的内容是大多数读者相对紧密和字面地遵循的部分。虽然这样做是可以接受的，但我们更希望你能将其视为一个指南而不是食谱。人类知识的最大奇妙之处在于它并非仅仅通过无休止的记忆来吸收。实验和获得实际经验是成功掌握这一技能的另一半关键，所以请继续编写代码。无论代码好坏，编译它，或者遇到一大堆错误，运行它或让它崩溃，两种情况都很好。尝试新事物并失败得惨不忍睹，以便有一天能够取得辉煌的成功。你已经走在“动手实践”的道路上了，因为我们将在下一章实际上开始为这本书实现第一个游戏项目。在那里见！
