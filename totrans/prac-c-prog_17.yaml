- en: Embedded Software and IoT
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式软件和物联网
- en: When it comes to doing specific tasks more efficiently and precisely, embedded
    systems are preferred. They work as independent components, and they can be collectively
    combined into larger pieces of equipment. The internet is a vast and endless source
    of information; consequently, the **Internet of Things** (**IoT**) plays a major
    role in making embedded devices smarter so that they can be managed and controlled
    remotely.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到更高效、更精确地执行特定任务时，嵌入式系统更受欢迎。它们作为独立组件工作，并且可以组合成更大的设备。互联网是一个庞大且无穷无尽的信息来源；因此，**物联网（IoT**）在使嵌入式设备更智能、以便远程管理和控制方面发挥着重要作用。
- en: 'In this chapter, we''ll deep dive into the following recipes related to embedded
    software and IoT:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨以下与嵌入式软件和物联网相关的食谱：
- en: Toggling the port of a microcontroller in Embedded C (blinking LED)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在嵌入式C中切换微控制器的端口（闪烁LED）
- en: Incrementing the value of a port in Embedded C
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在嵌入式C中增加端口的值
- en: Toggling the voltage in an output pin using Arduino (blinking LED)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Arduino切换输出引脚的电压（闪烁LED）
- en: Taking input from the serial port using Arduino
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Arduino从串行端口获取输入
- en: Sensing the temperature using Arduino with the LM35 sensor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LM35传感器通过Arduino感知温度
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For embedded programming in C, we will use Keil MDK, which provides a software
    development environment for a wide range of ARM Cortex-M-based microcontroller
    devices. MDK provides the very easy-to-use µVision IDE, an Arm C/C++ compiler,
    and other libraries. You can download Keil MDK from the following URL: [https://www.keil.com/download/](https://www.keil.com/download/).
    Let''s take a look at the following steps:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C语言嵌入式编程，我们将使用Keil MDK，它为广泛的基于ARM Cortex-M的微控制器设备提供了一个软件开发环境。MDK提供了非常易于使用的µVision
    IDE、Arm C/C++编译器和其他库。您可以从以下URL下载Keil MDK：[https://www.keil.com/download/](https://www.keil.com/download/)。让我们看看以下步骤：
- en: 'Download the following three executable files. You may not find the files with
    exactly the same names, but they will be somewhat similar:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载以下三个可执行文件。您可能找不到完全相同的文件名，但它们将大致相似：
- en: '`mdk526.exe`: This provides a development environment for ARM devices.'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdk526.exe`：这为ARM设备提供了一个开发环境。'
- en: '`c251v560.exe`: This provides development tools for all 80251 devices.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c251v560.exe`：这为所有80251设备提供了开发工具。'
- en: '`c51v959.exe`: This provides development tools for all 8051 devices.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c51v959.exe`：这为所有8051设备提供了开发工具。'
- en: Double-click on these executable files one by one and follow the setup dialog
    boxes to install these three Keil products.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个双击这些可执行文件，并按照设置对话框安装这三个Keil产品。
- en: Following the successful installation of these products, you will find an icon
    called Keil uVision5 on the desktop. The icon represents the **Integrated Development
    Environment** (**IDE**) that enables us to write, edit, debug, and compile programs.
    The compiler converts the source code into a HEX file, which, in return, can be
    fused onto the target chip.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装这些产品后，您将在桌面上找到一个名为Keil uVision5的图标。该图标代表**集成开发环境（IDE**），它使我们能够编写、编辑、调试和编译程序。编译器将源代码转换为HEX文件，然后可以将其烧录到目标芯片上。
- en: In order to work with Arduino, you have to buy the Arduino board and download
    the Arduino IDE from [https://www.arduino.cc/en/main/software](https://www.arduino.cc/en/main/software).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Arduino一起工作，您必须购买Arduino板并从[https://www.arduino.cc/en/main/software](https://www.arduino.cc/en/main/software)下载Arduino
    IDE。
- en: At the time of writing this chapter, the latest version of the Arduino IDE that
    is available is 1.8.8\. The downloaded executable file will be `arduino-1.8.8-windows.exe`.
    Connect the Arduino board to your PC and simply double-click on the executable
    file to install the Arduino IDE. When it has successfully installed, you will
    find the Arduino IDE icon on the desktop.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本章时，可用的最新Arduino IDE版本是1.8.8。下载的可执行文件将是`arduino-1.8.8-windows.exe`。将Arduino板连接到您的PC，并简单地双击可执行文件以安装Arduino
    IDE。安装成功后，您将在桌面上找到Arduino IDE图标。
- en: Introduction to embedded systems
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式系统简介
- en: An embedded system is a combination of computer hardware and software designed
    to do specific functions within larger equipment. The heavy equipment used in
    industries, automobiles, medical procedures, household appliances, and mobile
    devices use embedded systems. Most embedded systems use a RISC family microcontroller,
    such as PIC 16F84, Atmel 8051, or Motorola 68HC11\. Several input and output devices
    can be connected to the embedded system's microcontrollers, such as an LCD display,
    keypad, printer, and sensor. These devices can control several other devices such
    as fans, motors, bulbs, washing machines, ovens, AC controllers, cars, printers,
    and so much more.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统是由计算机硬件和软件的组合，旨在在更大的设备中执行特定功能。在工业、汽车、医疗程序、家用电器和移动设备中使用的重型设备都使用了嵌入式系统。大多数嵌入式系统使用
    RISC 家族微控制器，例如 PIC 16F84、Atmel 8051 或 Motorola 68HC11。可以将多个输入和输出设备连接到嵌入式系统的微控制器上，例如液晶显示屏、键盘、打印机、传感器。这些设备可以控制多个其他设备，如风扇、电机、灯泡、洗衣机、烤箱、空调控制器、汽车、打印机等等。
- en: To program a microcontroller to do a specific task, the microcontroller is interfaced
    with a PC by connecting it to a slot. An assembly program, or Embedded C, can
    be used to write and burn the program onto the microcontroller. The programs can
    be stored in the microcontroller's **EPROM **(short for **Erasable Programmable
    Read-Only Memory**). It's an internal, read-only memory that can be programmed
    and erased when exposed to an ultraviolet light source. We will be developing
    applications for embedded systems using Embedded C with software such as Keil.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要编程微控制器以执行特定任务，需要通过连接到插槽将微控制器与 PC 连接。可以使用汇编程序或嵌入式 C 来编写和烧录程序到微控制器上。程序可以存储在微控制器的
    **EPROM**（缩写为 **Erasable Programmable Read-Only Memory**）。它是一种内部、只读内存，当暴露在紫外光源下时可以编程和擦除。我们将使用
    Keil 等软件用嵌入式 C 开发嵌入式系统应用程序。
- en: Introduction to IoT
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网（IoT）简介
- en: IoT is an architecture that comprises hardware and software systems or devices
    that are connected to the internet using various means such as WiFi, Ethernet,
    and more. The web API and other protocols, when combined, provide an environment
    that allows smart embedded devices to be connected to the internet. Consequently,
    it enables us to access data from remote areas and control or trigger certain
    actions on various devices via the internet. In other words, IoT is a system of
    interrelated embedded computing devices that have the ability to transfer data
    over a network and take necessary actions. Arduino is considered to be the best
    starting point for embedded IoT. For Arduino to be able to work as an IoT device,
    Android with an Ethernet shield is required.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网（IoT）是一个由硬件和软件系统或设备组成的架构，这些设备通过 WiFi、以太网等多种方式连接到互联网。当 Web API 和其他协议结合使用时，提供了一个环境，允许智能嵌入式设备连接到互联网。因此，它使我们能够从远程地区访问数据，并通过互联网控制或触发各种设备上的某些操作。换句话说，物联网是一个相互关联的嵌入式计算设备系统，这些设备具有通过网络传输数据并采取必要行动的能力。Arduino
    被认为是嵌入式物联网的最佳起点。为了使 Arduino 能够作为物联网设备工作，需要 Android 和以太网盾。
- en: Let's quickly learn a little more about Arduino.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下 Arduino。
- en: Introduction to Arduino
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arduino 简介
- en: 'Arduino is an architecture that includes the Atmel microcontroller family along
    with standard hardware. The pin diagram of Arduino is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 是一个包括 Atmel 微控制器系列和标准硬件的架构。Arduino 的引脚图如下：
- en: '![](img/a4b83b8f-6db5-46a6-bfe8-717fa7b3738b.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4b83b8f-6db5-46a6-bfe8-717fa7b3738b.png)'
- en: 'Arduino includes 14 digital pins that can operate with 5V:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 包含 14 个数字引脚，可以与 5V 操作：
- en: Pins **0** (**RXD**) and **1** (**TXD**) are the serial pins used to transfer TTL
    serial data.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚 **0**（**RXD**）和 **1**（**TXD**）是用于传输 TTL 串行数据的串行引脚。
- en: Pins **2** and **3** are the external interrupt pins used to activate an interrupt.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚 **2** 和 **3** 是外部中断引脚，用于激活中断。
- en: Pins **3**, **5**, **6**, **9**, **10**, and **11** are used to provide the
    PWM output.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚 **3**、**5**、**6**、**9**、**10** 和 **11** 用于提供 PWM 输出。
- en: Pins **10**, **11**, **12**, and **13** are **SPI** pins (short for the **Serial
    Peripheral Interface**). Named **SS**, **MOSI**, **MISO**, and **SCK**, these
    pins are used for SPI communication.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚 **10**、**11**、**12** 和 **13** 是 **SPI** 引脚（缩写为 **Serial Peripheral Interface**）。命名为
    **SS**、**MOSI**、**MISO** 和 **SCK**，这些引脚用于 SPI 通信。
- en: Pin **13** is an LED pin. A HIGH digital value, when supplied to this pin, will
    make the LED glow.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚 **13** 是 LED 引脚。当向该引脚提供高数字值时，LED 会发光。
- en: Analog pins **4** and **5**—called **SDA** and **SCL**, respectively—are used
    in the communication of **TWI** (short for the **Two-Wire Interface**).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟引脚 **4** 和 **5** 分别称为 **SDA** 和 **SCL**，用于 **TWI**（代表 **Two-Wire Interface**）的通信。
- en: The **AREF** (short for **Analog Reference**) pin is used to connect to some
    reference voltage from an external power supply.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AREF**（代表 **Analog Reference**）引脚用于连接到外部电源的某些参考电压。'
- en: The **RESET** (**RST**) pin is used to reset the microcontroller.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RESET**（或 **RST**）引脚用于重置微控制器。'
- en: As far as software is concerned, Arduino comes with an IDE that we can use to
    write and edit applications and can even upload them to do specific tasks. This
    IDE includes support for the C and C++ programming languages for programming microcontrollers.
    It contains several libraries that make the job of a software developer quite
    easy. Besides this, the IDE provides communication windows in order to enter data
    into the board as well as to get output.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就软件而言，Arduino 随附一个 IDE，我们可以使用它来编写和编辑应用程序，甚至可以将其上传以执行特定任务。此 IDE 包括对 C 和 C++ 编程语言的编程支持，并包含几个库，使软件开发者的工作变得相当容易。此外，IDE
    提供通信窗口，以便将数据输入板以及获取输出。
- en: The Arduino board provides ports to connect LCDs, relays, and much more to its
    output pin and provides input pins to input information from sensors, relays,
    and much more. The Arduino board can be powered either by a USB or by connecting
    a 9V battery.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 板提供端口以连接 LCD、继电器等设备到其输出引脚，并提供输入引脚以从传感器、继电器等设备输入信息。Arduino 板可以通过 USB
    或连接 9V 电池供电。
- en: 'While working with Arduino programming, we will be using the following functions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Arduino 编程时，我们将使用以下函数：
- en: '`Serial.begin()` is used to set the data rate while establishing communication
    between the Arduino board and the PC. In order to communicate with the computer
    through serial data transmission, we need to first set the data rate in bits per
    second (baud). We can use any of the baud rates, such as 300, 600, 1200, 2400,
    4800, 9600, 14400, 19200, 28800, 38400, 57600, or 115200.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Serial.begin()` 用于在建立 Arduino 板与 PC 之间的通信时设置数据速率。为了通过串行数据传输与计算机通信，我们首先需要设置每秒的比特率（波特率）。我们可以使用任何波特率，例如
    300、600、1200、2400、4800、9600、14400、19200、28800、38400、57600 或 115200。'
- en: '`Serial.println()` is used to display a message to the serial port in a human-readable
    format. It displays the message in ASCII text followed by a newline character
    on the serial monitor. You will need to press *Ctrl* + *Shift* + *M* to open the
    serial monitor.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Serial.println()` 用于以人类可读的格式向串行端口显示消息。它在串行监视器上显示消息，后跟换行符。您需要按 *Ctrl* + *Shift*
    + *M* 打开串行监视器。'
- en: '`Serial.available()` checks whether the data, in terms of bytes from the serial
    port, is available for reading. Essentially, the data to be read from the serial
    port is stored in the serial receive buffer and this method checks whether the
    data has arrived in this buffer. This method returns the number of bytes available
    to read:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Serial.available()` 检查从串行端口读取的字节数据是否可用。本质上，要从串行端口读取的数据存储在串行接收缓冲区中，此方法检查数据是否已到达此缓冲区。此方法返回可读取的字节数：'
- en: '`Serial.read()` reads incoming serial data and returns the first byte of incoming
    serial data available. The method returns `-1` if no data is available to read.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Serial.read()` 读取传入的串行数据并返回可用的第一个字节。如果没有可读数据，该方法返回 `-1`。'
- en: '`analogRead()` reads the value from the specified analog pin. The Arduino board
    contains a multichannel, 10-bit analog-to-digital converter. As a result of this,
    it will map input voltages between 0 and the operating voltage (5V or 3.3V) into
    integer values between 0 and 1023.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`analogRead()` 从指定的模拟引脚读取值。Arduino 板包含一个多通道、10 位模数转换器。因此，它将输入电压映射到 0 和工作电压（5V
    或 3.3V）之间的整数值，介于 0 和 1023 之间。'
- en: 'For example, if you''re using a 5V Arduino and a sensor is connected to its
    analog pin, then the following formula is used to convert the 10-bit analog reading
    into a temperature:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您使用的是 5V Arduino，并且传感器连接到其模拟引脚，那么以下公式用于将 10 位模拟读数转换为温度：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This formula converts the number 0-1023 from the ADC into 0-5000 mV.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此公式将 ADC 的 0-1023 数字转换为 0-5000 mV。
- en: 'If you''re using a 3.3V Arduino, then the following formula is used to convert
    the analog reading into a temperature:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 3.3V Arduino，那么以下公式用于将模拟读数转换为温度：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This formula converts the number 0-1023 from the ADC into 0-3300 mV.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此公式将 ADC 的 0-1023 数字转换为 0-3300 mV。
- en: 'To convert the number of millivolts retrieved from the preceding formula into
    a temperature, the following formula is used:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将前一个公式中检索到的毫伏数转换为温度，使用以下公式：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That wraps up our introduction to embedded systems and IoT. We'll now review
    the required technical software and hardware we need to complete the recipes in
    this chapter. After that, we will begin with the first recipe.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对嵌入式系统和物联网的介绍。现在，我们将回顾完成本章菜谱所需的软件和硬件。之后，我们将开始第一个菜谱。
- en: Toggling the port of a microcontroller in Embedded C (blinking LED)
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在嵌入式C中切换微控制器的端口（闪烁LED）
- en: In this recipe, we will learn how to send HIGH and LOW signals to a specific
    port that is connected to an LED, and make the LED blink. The idea behind this
    exercise is to learn how to control a device that is connected to a specific port
    of the microcontroller.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何向连接到LED的特定端口发送高电平和低电平信号，并使LED闪烁。这个练习背后的想法是学习如何控制连接到微控制器特定端口的设备。
- en: How to do it…
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To toggle the port of a microcontroller in Embedded C, perform the following
    steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要在嵌入式C中切换微控制器的端口，请执行以下步骤：
- en: We will carry out this recipe using Keil; double-click on the Keil uVision5
    icon to activate the IDE.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用Keil执行这个菜谱；双击Keil uVision5图标以激活IDE。
- en: Create a new project by clicking on the Project | New uVision Project option.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击“项目 | 新uVision项目”选项创建一个新项目。
- en: When prompted, specify the project name and the folder where you want to create
    the new project.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，指定项目名称以及你想要创建新项目的文件夹。
- en: Give the new project the name `LedBlinkProject` and then click on the Save button.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新项目命名为`LedBlinkProject`，然后点击“保存”按钮。
- en: The device selection window will open and you will be prompted to select a device.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将打开设备选择窗口，并提示你选择一个设备。
- en: From the Device combo box, select the Legacy Device Database [no RTE] option.
    You will get the list of devices in the lower-left pane (refer to the following
    screenshot).
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从设备组合框中选择“Legacy Device Database [no RTE]”选项。你将在左下角的窗格中看到设备列表（参看以下截图）。
- en: Click on the Microchip node to expand it and display the list of devices in
    it.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Microchip节点以展开它并显示其中的设备列表。
- en: 'Because we want to program the Atmel microcontroller, from the Microchip node,
    select the AT89C51 device. The description of the selected device will appear
    in the description pane on the right. Click on OK to move further:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们想要编程Atmel微控制器，从Microchip节点中选择AT89C51设备。所选设备的描述将出现在右侧的描述窗格中。点击“确定”以继续：
- en: '![](img/e086bd76-9554-4d4c-8d26-c961142a3a99.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e086bd76-9554-4d4c-8d26-c961142a3a99.png)'
- en: 'You will be asked whether you want to copy the `STARTUP.A51` file to the project
    folder (refer to the following screenshot). The startup file will be required
    for running the project, so click on the Yes button to add the file and move further:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被询问是否要将`STARTUP.A51`文件复制到项目文件夹中（参看以下截图）。启动文件将用于运行项目，因此点击“是”按钮添加文件并继续：
- en: '![](img/d23d91fa-3ead-45eb-a4ba-ea5fe55903bc.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d23d91fa-3ead-45eb-a4ba-ea5fe55903bc.png)'
- en: 'The IDE will appear as follows. You can see three windows: Project Workspace,
    Editing Window, and Output Window in the IDE. Additionally, you can see the Target1 node
    created under the Project space:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IDE将显示如下。您可以在IDE中看到三个窗口：项目工作区、编辑窗口和输出窗口。此外，您还可以看到在项目空间下创建的Target1节点：
- en: '![](img/4c8417f2-dce2-469e-b0d2-e5fc9330f0c7.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c8417f2-dce2-469e-b0d2-e5fc9330f0c7.png)'
- en: 'Add a C file. Right-click on Source Group1 under the Target1 node and click
    on the Add New item to Group ''Source Group 1'' option. From the list box, select
    the C File (.c) option. Specify the filename as `blinkingLed` (or any other name),
    and then click on the Add button (refer to the following screenshot):'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个C文件。在Target1节点下的Source Group1上右键单击，然后点击“向组‘Source Group 1’添加新项”选项。从列表框中选择“C文件
    (.c)”选项。指定文件名为`blinkingLed`（或任何其他名称），然后点击“添加”按钮（参看以下截图）：
- en: '![](img/aa3a6f00-ca50-475d-a1d3-fa8bf5bbfd87.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa3a6f00-ca50-475d-a1d3-fa8bf5bbfd87.png)'
- en: 'The `blinkingLed.c` file is added to Source Group 1\. Enter the following code
    in the editor window:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`blinkingLed.c`文件已添加到Source Group 1。在编辑窗口中输入以下代码：'
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After entering the code, click on the save icon from the toolbar to save the `blinkingLed.c` file.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入代码后，点击工具栏中的保存图标以保存`blinkingLed.c`文件。
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will define a variable called `LED` of the `sbit` type. The `sbit` type defines
    a bit within a **special function register** (**SFR**). We will set the `LED`
    variable to represent the 0^(th)-bit position of port `P1`. Then, we will define
    a prototype of the `Delay` function, which takes an integer parameter but returns
    nothing. Within the `main` function, we will execute a `while` loop in an infinite
    loop. Within the `while` loop, we will set the `LED` variable to `0`, that is,
    a LOW signal will be sent to the 0th bit of port `P1`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个名为`LED`的`sbit`类型变量。`sbit`类型定义了一个**特殊功能寄存器**（**SFR**）内的位。我们将设置`LED`变量来表示端口`P1`的0位。然后，我们将定义`Delay`函数的原型，该函数接受一个整型参数但不返回任何内容。在`main`函数中，我们将执行一个无限循环中的`while`循环。在`while`循环中，我们将`LED`变量设置为`0`，即向端口`P1`的0位发送低信号。
- en: Thereafter, we will introduce a delay through two nested loops. After the delay,
    we will set the value of the `LED` variable to `1`, that is, a HIGH signal will
    be sent to the 0th bit of port `P1`. If the LED is connected to the 0th bit of
    port `1`, the LED will glow and, after some delay, it will go off. Again, after
    some delay, the LED will glow again; therefore, we get a blinking LED.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们将通过两个嵌套循环引入延迟。延迟后，我们将`LED`变量的值设置为`1`，即向端口`P1`的0位发送高信号。如果LED连接到端口`1`的0位，LED将发光，经过一些延迟后熄灭。再次经过一些延迟后，LED将再次发光；因此，我们得到了一个闪烁的LED。
- en: 'Press *F7* or click on the Build button to start compiling the code. If there
    is no error, you can move on to the next step. You can either generate a HEX file
    to infuse into the desired hardware, or you can use the simulation technique to
    see whether the program is giving the desired output. In order to generate a HEX
    file, right-click on the Target1 node and select Options for Target ''Target 
    1''. We will get a dialog box showing different options. Click on the Output tab,
    and check the Create HEX File box (refer to the following screenshot). Additionally,
    click on the Device tab to confirm that the device selected is AT89C51\. Then,
    click on the OK button:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按*F7*键或点击构建按钮以开始编译代码。如果没有错误，您可以继续下一步。您可以选择生成HEX文件以注入到所需的硬件中，或者可以使用模拟技术来查看程序是否给出了预期的输出。为了生成HEX文件，右键单击“Target1”节点并选择“为‘Target
    1’选项”。我们将得到一个显示不同选项的对话框。点击输出选项卡，并勾选**创建HEX文件**框（参见图表）。此外，点击设备选项卡以确认所选设备是AT89C51。然后，点击确定按钮：
- en: '![](img/14d919f9-c13b-4635-8567-8fba4fd9f389.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14d919f9-c13b-4635-8567-8fba4fd9f389.png)'
- en: Figure 5.5
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5
- en: 'Keil''s built-in Debug option can be used for code simulation. To do this,
    click on Debug | Start/Stop Debug Session; alternatively, you can press *Ctrl*
    + *F5* as the shortcut key, or click on the Start/Stop Debug Session icon (it
    appears in the form of d) in the toolbar. The free version of the Keil tool has
    a condition that the running code size should not be more than 2 KB. You will
    get the following dialog box indicating that the running code has an upper limit
    of 2 KB:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Keil的内置**调试**选项可用于代码模拟。为此，请点击调试|开始/停止调试会话；或者，您可以按*Ctrl* + *F5*作为快捷键，或者点击工具栏中的**开始/停止调试会话**图标（它以d的形式出现）。Keil工具的免费版本有一个条件，即运行代码的大小不应超过2
    KB。您将看到一个对话框，指示运行代码的上限为2 KB：
- en: '![](img/ae978b3a-b3e7-41f8-9e74-e53126b34d46.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae978b3a-b3e7-41f8-9e74-e53126b34d46.png)'
- en: Figure 5.6
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6
- en: 'Click on the OK button to move further. Now the Project workspace window shows
    most of the SFRs as well as the GPRs, r0 to r7, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 点击确定按钮继续。现在，项目工作区窗口显示了大多数SFR以及GPRs，即r0到r7，如下所示：
- en: '![](img/28b08d76-c374-4106-ba99-ca014b9987f8.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28b08d76-c374-4106-ba99-ca014b9987f8.png)'
- en: Figure 5.7
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7
- en: 'Click on the Run icon from the toolbar or press *F5*. To see the output on
    ports go to Peripherals | Select I/O ports | Port 1\. You will get the blinking
    LED on `Port1`, as shown in the following screenshot. You can see that there is
    a LOW signal in `bit0` of the `Port1` and a HIGH signal on the same bit:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从工具栏中点击运行图标或按*F5*键。要查看端口的输出，请转到“外围设备”|“选择I/O端口”|“端口1”。您将在“端口1”上看到闪烁的LED，如下面的截图所示。您可以看到，在“端口1”的`bit0`中有一个低信号，在同一个位上有一个高信号：
- en: '![](img/d38d1f7a-c909-4c46-9f87-d0bc68d091ab.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d38d1f7a-c909-4c46-9f87-d0bc68d091ab.png)'
- en: Figure 5.8
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8
- en: Voilà! We've successfully created a blinking LED using a microcontroller port.
    Now, let's move on to the next recipe!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà！我们已经成功使用微控制器端口创建了一个闪烁的LED。现在，让我们继续下一个菜谱！
- en: Incrementing the value of a port in Embedded C
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在嵌入式C中递增端口的值
- en: In this recipe, we will learn how to display values from 0 to 255 on a specific
    port of a microcontroller and make the value increment like a counter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何在微控制器的特定端口上显示从0到255的值，并使值像计数器一样递增。
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To increment the value of a port in Embedded C, perform the following steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式C中递增端口的值，请执行以下步骤：
- en: Launch the Keil uVision5 IDE.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Keil uVision5 IDE。
- en: Create a new project by clicking on the New Project | New uVision Project option.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击“新建项目 | 新建uVision项目”选项来创建一个新项目。
- en: Specify the project name and folder location when prompted. Let's give the new
    project the name `CounterApp`; click on Save.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，指定项目名称和文件夹位置。让我们将新项目命名为`CounterApp`；点击“保存”。
- en: The device selection window will open and you will be prompted to select a device.
    From the Device combo box, select Legacy Device Database [no RTE].
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将打开设备选择窗口，并提示你选择一个设备。从设备组合框中选择“Legacy Device Database [no RTE]”。
- en: You will get the list of devices in the lower-left pane. Click on the Microchip
    node to expand it and display the list of devices in it.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在左下角的窗格中看到设备列表。点击Microchip节点以展开它并显示其中的设备列表。
- en: From the Microchip node, select the AT89C51 device. The description of the selected
    device will appear in the description pane on the right. Click on OK to move further.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Microchip节点中选择AT89C51设备。所选设备的描述将出现在右侧的描述面板中。点击“确定”以继续操作。
- en: You will be asked whether you want to copy the `STARTUP.A51` file to the project
    folder. Click on Yes to add the file and move further.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统会询问你是否要将`STARTUP.A51`文件复制到项目文件夹中。点击“是”以添加文件并继续操作。
- en: 'The IDE will open showing three windows: The Project Workspace on the left,
    the Editing Window on the right, and the Output Window at the bottom. You will
    see Target1 created under the Project space.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IDE将打开并显示三个窗口：左侧的“项目工作区”，右侧的“编辑窗口”，以及底部的“输出窗口”。你将在项目空间下看到创建的Target1。
- en: Add a C file by right-clicking on Source Group1 under the Target1 node and then
    click on Add New item to Group 'Source Group 1'.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Target1节点下的源组1上右键单击并点击“添加新项到组‘源组1’”来添加一个C文件。
- en: From the list box, select the C File (.c) option. Specify the filename as `showcounter`
    and then click on Add.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表框中选择“C文件 (.c)”选项。指定文件名为`showcounter`，然后点击“添加”。
- en: 'The `showcounter.c` file will be added to Source Group 1\. Enter the following
    code in the editor window:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`showcounter.c`文件将被添加到源组1。在编辑窗口中输入以下代码：'
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After entering the code, click on the SAVE icon in the toolbar to save the `showcounter.c` file.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入代码后，点击工具栏中的保存图标以保存`showcounter.c`文件。
- en: Now, let's go behind the scenes to understand the steps better.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解这些步骤。
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will define a variable, `i`, of the unsigned char type; a variable of the
    unsigned char type can store 256 bits, whereas that of a signed char can store
    only 128 bits. The `i` variable is assigned the HEX value of `0`. We will set
    a `while` loop to execute infinitely. With every iteration of the `while` loop,
    the value of the `i` variable will increment by `1`. Within the `while` loop,
    we will assign the value of the `i` variable, that is, `0`, to port `P3`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个无符号字符类型的变量`i`；无符号字符类型的变量可以存储256位，而有符号字符类型的变量只能存储128位。`i`变量被分配了十六进制值`0`。我们将设置一个无限循环的`while`循环。在`while`循环的每次迭代中，`i`变量的值将递增`1`。在`while`循环内部，我们将`i`变量的值，即`0`，分配给端口`P3`。
- en: We will introduce a delay by using two nested `for` loops. Thereafter, we will
    execute a `while` loop again, incrementing the value of the `i` variable, making
    it `1`. Again, we will assign the value of the `i` variable to port `P3` for display.
    And, we will reintroduce some delay, followed by executing the `while` loop again.
    This process continues infinitely; consequently, port `P3` will display the counter
    from `0` until `255` repeatedly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用两个嵌套的`for`循环来引入延迟。然后，我们再次执行`while`循环，递增`i`变量的值，使其变为`1`。再次，我们将`i`变量的值分配给端口`P3`以进行显示。然后，我们再次引入一些延迟，并再次执行`while`循环。这个过程将无限循环；因此，端口`P3`将重复显示从`0`到`255`的计数器。
- en: Press *F7* or click on the Build button to compile the code. If there is no
    error, you can move ahead to the next step; otherwise, first, debug the code.
    In order to see the output of the code through simulation, we will use Keil's
    built-in Debug option for simulation of the code. To do this, click on Debug |
    Start/Stop Debug Session. Alternatively, you can press *Ctrl* + *F5* as the shortcut
    key, or click on the Start/Stop Debug Session icon (it appears in the form of
    a D) in the toolbar.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按*F7*或点击构建按钮来编译代码。如果没有错误，您可以继续到下一步；否则，首先调试代码。为了通过仿真查看代码的输出，我们将使用Keil的内置仿真调试选项。为此，点击调试
    | 开始/停止调试会话。或者，您可以按*Ctrl* + *F5*作为快捷键，或者点击工具栏中的开始/停止调试会话图标（它以D的形式出现）。
- en: On the free version of Keil, there is a condition that the running code size
    should not be more than 2 KB, so you will get a dialog box indicating that the
    running code has an upper limit of 2 KB. Click on OK to move further. The project
    workspace window shows most of the SFRs as well as the GPRs, from r0 to r7\. Click
    on the  Run icon from the toolbar or press the *F5* key. You can see the output
    of the ports under Peripherals | Select I/O ports| Port 3\. You will see the bits
    of the ports showing the counter from `0` to `255`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Keil的免费版本中，有一个条件是运行代码的大小不应超过2 KB，因此您将得到一个对话框，指示运行代码的上限为2 KB。点击确定继续。项目工作区窗口显示了大多数SFR以及从r0到r7的GPR。从工具栏中点击运行图标或按*F5*键。您可以在外围设备
    | 选择I/O端口 | 端口3下看到端口的输出。您将看到端口的位显示从`0`到`255`的计数器。
- en: 'In the following screenshot, **(a)** shows the bits set to a value of `5`.
    The binary value of 5 is 101, so, accordingly, the first and third bits are set
    to a HIGH signal and the remaining bits are set to a LOW signal. Similarly, **(b)**
    shows the bits displaying the counter value of 10\. The bits of the port will
    be set showing the values from 0 to 255:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图，**(a**)显示了设置为`5`值的位。5的二进制值是101，因此，相应地，第一和第三位被设置为高电平信号，其余位被设置为低电平信号。同样，**(b**)显示了显示计数器值为10的位。端口的位将被设置为从0到255的值：
- en: '![](img/ec502c1f-6fea-4ee3-b7b0-a7be409632d6.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec502c1f-6fea-4ee3-b7b0-a7be409632d6.png)'
- en: Figure 5.9
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9
- en: Voilà! We've successfully created a counter using Embedded C. Now, let's move
    on to the next recipe!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用嵌入式C创建了一个计数器。现在，让我们继续下一个菜谱！
- en: Toggle voltage in output pin using Arduino (blinking LED)
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Arduino在输出引脚上切换电压（闪烁LED）
- en: In this recipe, we will learn how to make an LED that is connected to the output
    pins of the Arduino board blink.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何制作一个连接到Arduino板输出引脚的LED闪烁。
- en: How to do it…
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To make an LED that is connected to the output pins of the Arduino board blink,
    perform the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要使连接到Arduino板输出引脚的LED闪烁，请执行以下步骤：
- en: 'Open the Arduino IDE. Arduino opens up with a file showing the default content,
    as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Arduino IDE。Arduino会打开一个显示默认内容的文件，如下所示：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Connect the Arduino board to the PC.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Arduino板连接到电脑。
- en: From the Tools menu, select Port and confirm whether it shows COM3 (Arduino/Genuino
    Uno) or whatever Arduino board you have attached to your PC. Additionally, confirm
    whether the Board option from the Tools menu indicates the Arduino board that
    is attached to your PC. In my case, the Board option will show Arduino/Genuino
    Uno.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从工具菜单中选择端口，确认是否显示COM3（Arduino/Genuino Uno）或您连接到电脑的Arduino板。此外，确认工具菜单中的板选项是否指示连接到电脑的Arduino板。在我的情况下，板选项将显示Arduino/Genuino
    Uno。
- en: Remember, the LEDs have polarity; hence, they will only glow when they are connected
    properly. The long leg is positive and should connect to a digital pin on the
    Arduino board. I am using the 13^(th) pin of the Arduino board for the output,
    so connect the long leg of the LED to the 13^(th) pin of the Arduino board (refer
    to *Figure 5.10*). Then, connect the short leg of the LED, which is negative,
    to the GND on the Arduino board.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，LED有极性；因此，只有当它们正确连接时才会发光。长腿是正极，应该连接到Arduino板上的数字引脚。我使用Arduino板的第13个引脚作为输出，所以将LED的长腿连接到Arduino板的第13个引脚（参见图5.10）。然后，将LED的短腿（负极）连接到Arduino板的GND。
- en: 'Type the following program in the editor window:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中输入以下程序：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 6\. Save the application by clicking on File | Save As. Specify the application
    name when prompted. Select the desired folder location and specify the application
    name. Let's name the application `ArduinoLedBlink`. A folder will be created with
    the specified application name (`ArduinoLedBlink`), and, within the `ArduinoLedBlink`
    folder, the application will be created with the filename `ArduinoLedBlink.ino`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 通过点击文件 | 另存为保存应用程序。在提示时指定应用程序名称。选择所需的文件夹位置并指定应用程序名称。让我们将应用程序命名为`ArduinoLedBlink`。将创建一个具有指定应用程序名称（`ArduinoLedBlink`）的文件夹，并在`ArduinoLedBlink`文件夹内创建一个名为`ArduinoLedBlink.ino`的应用程序。
- en: 7\. Upload the application to Arduino by clicking on the Upload icon in the
    toolbar.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 通过点击工具栏中的上传图标将应用程序上传到Arduino。
- en: Now, let's go behind the scenes to understand the steps better.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解这些步骤。
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will start by defining a `Led` variable and setting it to represent pin 13
    of the Arduino. By invoking the `pinMode` function, the `Led` variable will be
    indicated as the output pin, that is, it will be connected to an output device
    for display or to do some task.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个`Led`变量并将其设置为表示Arduino的13号引脚。通过调用`pinMode`函数，`Led`变量将被指示为输出引脚，即它将连接到输出设备以进行显示或执行某些任务。
- en: Within the `loop` function, we will invoke the `digitalWrite` method to send
    a HIGH signal to variable `Led`. By doing so, the LED that is connected to output
    pin 13 will be switched on. Thereafter, we will introduce a time delay of 1,000
    milliseconds.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loop`函数中，我们将调用`digitalWrite`方法向变量`Led`发送一个高电平信号。这样做，连接到输出引脚13的LED将打开。之后，我们将引入1,000毫秒的时间延迟。
- en: Once more, we will invoke the `digitalWrite` method and send a LOW signal, this
    time to variable `Led`. As a result, the LED connected to output pin 13 will be
    switched off. Again, we will introduce a delay of 1,000 milliseconds. The commands
    in the `loop` function will execute infinitely making the connected LED to keep
    blinking.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将调用`digitalWrite`方法并发送一个低电平信号，这次发送到变量`Led`。结果，连接到输出引脚13的LED将关闭。同样，我们将引入1,000毫秒的延迟。`loop`函数中的命令将无限执行，使连接的LED保持闪烁。
- en: 'On uploading the program to Arduino, the LED connected to the 13^(th) pin of
    the Arduino will start blinking, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序上传到Arduino后，连接到Arduino 13号引脚的LED将开始闪烁，如下所示：
- en: '![](img/65963531-c8ab-44ae-a5e6-b034cc5f825f.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65963531-c8ab-44ae-a5e6-b034cc5f825f.png)'
- en: Figure 5.10
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10
- en: Voilà! We've successfully toggled the voltage in an output pin on the Arduino
    board to make a blinking LED.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功地在Arduino板上的一个输出引脚上切换电压，使LED闪烁。
- en: Now, let's move on to the next recipe!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Taking input from the serial port using Arduino
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Arduino从串行端口获取输入
- en: In this recipe, we will be attaching an LED to the Arduino board and will prompt
    the user to press either `0` or `1`. The user can input a value using the serial
    port. If the value entered by the user is `0`, it will switch off the LED and
    if the value entered by the user is `1`, it will make the LED glow.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将把一个LED连接到Arduino板，并提示用户按下`0`或`1`。用户可以通过串行端口输入一个值。如果用户输入的值是`0`，它将关闭LED；如果输入的值是`1`，它将使LED发光。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To take input from the serial port using Arduino, perform the following steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Arduino从串行端口获取输入，请执行以下步骤：
- en: 'Invoke the Arduino IDE. Arduino opens up with a file showing its default content,
    as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用Arduino IDE。Arduino将以显示其默认内容的文件打开，如下所示：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Connect the Arduino board to your PC.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Arduino板连接到您的电脑。
- en: From the Tools menu, select Port and confirm whether it shows COM3 (Arduino/Genuino
    Uno) or whatever Arduino board you have attached to your PC. Additionally, confirm
    whether the Board option from the Tools menu indicates the Arduino board that
    is attached to your PC. In my case, the Board option will show Arduino/Genuino
    Uno.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从工具菜单中选择端口，并确认它是否显示COM3（Arduino/Genuino Uno）或您连接到电脑的Arduino板。此外，确认工具菜单中的板选项是否指示连接到电脑的Arduino板。在我的情况下，板选项将显示Arduino/Genuino
    Uno。
- en: We will be attaching the LED to the output pin 13 of Arduino. Because the LEDs
    have polarity and need to be connected properly, we will connect the long leg
    of the LED (also known as the positive pin) to the 13^(th) digital pin on the
    Arduino board. Additionally, we will connect the short leg of the LED (also known
    as the negative pin) to the GND on the Arduino board.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把LED连接到Arduino的输出引脚13。由于LED有极性并且需要正确连接，我们将把LED的长腿（也称为正极引脚）连接到Arduino板上的第13个数字引脚。此外，我们将把LED的短腿（也称为负极引脚）连接到Arduino板上的GND。
- en: 'Type the following program in the editor window:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中输入以下程序：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save the application by clicking on the File | Save As option. Specify the application
    name when prompted. Let's name the application `ArduinoTakinginput`. A folder
    will be created with the specified application name, and, within the `ArduinoLedBlink`
    folder, the application will be created with the filename `ArduinoTakinginput.ino`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击文件 | 另存为选项保存应用程序。在提示时指定应用程序名称。让我们将应用程序命名为`ArduinoTakinginput`。将创建一个具有指定应用程序名称的文件夹，并在`ArduinoLedBlink`文件夹中创建一个名为`ArduinoTakinginput.ino`的应用程序文件。
- en: 'Upload the application to Arduino by clicking on the Upload icon from the toolbar
    (refer to the following screenshot):'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击工具栏中的上传图标将应用程序上传到Arduino（参考以下截图）：
- en: '![](img/c1e6c409-2c23-46a8-bcce-de4cd5110ffc.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c1e6c409-2c23-46a8-bcce-de4cd5110ffc.png)'
- en: Now, let's go behind the scenes to understand the steps better.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解背后的步骤。
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will define a `Led` variable and set it to represent pin 13 of Arduino. By
    invoking the `pinMode` function, the `Led` variable is declared as the output
    pin and, hence, we will use it for connecting to an output device in order to
    perform a desired action. In this application, the output device will be an LED.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个`Led`变量并将其设置为表示Arduino的13号引脚。通过调用`pinMode`函数，`Led`变量被声明为输出引脚，因此我们将使用它来连接到输出设备以执行所需操作。在本应用中，输出设备将是一个LED。
- en: Because we want our PC to communicate with Arduino using serial communication,
    we need to set the data rate in terms of bits per second. So, we will call the
    `Serial.begin` function to set the serial data transmission speed at 9,600 bits
    per second (however, it can be any baud rate). Thereafter, we will display a message
    on the serial port in a human-readable format, informing the user that `0` can
    be pressed to switch off the connected LED and `1` can be pressed to switch on
    the LED.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望我们的PC通过串行通信与Arduino通信，我们需要以每秒比特数来设置数据速率。因此，我们将调用`Serial.begin`函数将串行数据传输速度设置为9,600比特每秒（然而，可以是任何波特率）。之后，我们将在串行端口上以人类可读的格式显示一条消息，通知用户按下`0`可以关闭连接的LED，按下`1`可以打开LED。
- en: Within the `loop` function of Arduino, we will invoke the `Serial.available`
    function to check whether any data is available in the serial port to read from.
    That is, the serial receive buffer will be checked to see whether some data or
    bytes are available there to be read. The data can be available in the serial
    receive buffer only when the user presses any key. It also means that no output
    will appear until the user presses any key. The moment the user presses any key,
    that byte will go into the serial receive buffer and the `Serial.available` function
    will return the Boolean value `true`. As a result of this, the `if` block will
    execute.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino的`loop`函数中，我们将调用`Serial.available`函数来检查串行端口是否有可读数据。也就是说，将检查串行接收缓冲区以查看是否有数据或字节可供读取。只有当用户按下任何键时，数据才会出现在串行接收缓冲区中。这也意味着在用户按下任何键之前不会出现任何输出。当用户按下任何键时，该字节将进入串行接收缓冲区，`Serial.available`函数将返回布尔值`true`。因此，`if`块将执行。
- en: Within the `if` block, we will invoke the `Serial.read` function to read the
    serial data from the serial port. The data or byte that is read from the serial
    port will be assigned to the variable input. The byte read is always in ASCII
    format. The user is supposed to press either `0` or `1`; their corresponding ASCII
    values are 48 and 49, respectively. So, if the user presses `0`, its ASCII value,
    48, will be assigned to the variable input. And if the user presses `1`, its ASCII
    value, 49, will be assigned to the variable input.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块中，我们将调用`Serial.read`函数从串行端口读取串行数据。从串行端口读取的数据或字节将被分配给变量`input`。读取的字节始终是ASCII格式。用户应按下`0`或`1`；它们的ASCII值分别是48和49。因此，如果用户按下`0`，其ASCII值48将被分配给变量`input`。如果用户按下`1`，其ASCII值49将被分配给变量`input`。
- en: To get the actual value of the number entered by the user, the value of 48 is
    subtracted from the variable input. If the user presses `0`, a specified `if`
    block will execute. Within that `if` block, we will invoke the `Serial.println`
    function to display the message *LED is OFF* to inform the user. And we will invoke
    the `digitalWrite` method to send a LOW signal to output pin 13 where the LED
    is connected. Consequently, the LED, if it is glowing, will be switched off.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到用户输入的实际数值，我们从变量输入中减去 48 的值。如果用户按下 `0`，将执行一个指定的 `if` 块。在该 `if` 块内，我们将调用 `Serial.println`
    函数来显示消息 *LED is OFF* 以通知用户。我们还将调用 `digitalWrite` 方法向连接 LED 的输出引脚 13 发送低电平信号。因此，如果
    LED 正在发光，它将被关闭。
- en: If the user presses `1`, then another `if` block will execute; in this case,
    we will invoke the `Serial.println` function to display the message *LED is On.* And
    we will invoke the `digitalWrite` function to send a HIGH signal to output pin
    13 to make the LED glow. If the user has not pressed either `0` or `1`, we will
    display a message asking them to press either `0` or `1` only.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户按下 `1`，则将执行另一个 `if` 块；在这种情况下，我们将调用 `Serial.println` 函数来显示消息 *LED 是开启的*。我们还将调用
    `digitalWrite` 函数向输出引脚 13 发送高电平信号，使 LED 发光。如果用户没有按下 `0` 或 `1`，我们将显示一条消息，要求他们只按下
    `0` 或 `1`。
- en: 'After uploading the program to Arduino, we can press *Ctrl* + *Shift* + *M*
    to open the serial monitor. In the serial monitor, we will get the following message:
    *Enter 0 to switch off LED and 1 to switch it On* (refer to the first dialog box
    in *Figure 5.11*). After pressing `0` in the serial monitor, we will get the message LED
    is OFF and, again, you will be prompted to enter either `0` or `1` (refer to the
    second dialog box in *Figure 5.11*). Besides the message in the serial monitor,
    the LED that is connected to the 13^(th) pin of the Arduino board will also get
    switched off (if it was glowing). On pressing `1`, the message LED is ON will
    be displayed in the serial monitor. Additionally, a message will appear prompting
    us to enter either `0` or `1` (refer to the third dialog box in *Figure 5.11*).
    Also, the LED connected to the Arduino board will glow:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序上传到 Arduino 后，我们可以按 *Ctrl* + *Shift* + *M* 打开串行监视器。在串行监视器中，我们将得到以下消息：*输入
    0 以关闭 LED 并输入 1 以开启它*（参见图 5.11 中的第一个对话框）。在串行监视器中按下 `0` 后，我们将得到消息 LED is OFF，并且，你将再次被提示输入
    `0` 或 `1`（参见图 5.11 中的第二个对话框）。除了串行监视器中的消息外，连接到 Arduino 板 13^(th) 引脚的 LED 也会关闭（如果它之前是发光的）。按下
    `1` 时，串行监视器中将显示消息 LED is ON。此外，将出现一条消息提示我们输入 `0` 或 `1`（参见图 5.11 中的第三个对话框）。此外，连接到
    Arduino 板的 LED 将发光：
- en: '![](img/90223173-1fb1-469f-9ace-27a614a2fc47.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90223173-1fb1-469f-9ace-27a614a2fc47.png)'
- en: Figure 5.11
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11
- en: Voilà! We've successfully made an LED switch on and off on the basis of the
    input made to the serial port using Arduino.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà！我们已经成功使用 Arduino 通过串行端口输入使 LED 开关。
- en: Now, let's move on to the next recipe!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Sensing the temperature using Arduino with the LM35 sensor
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LM35 传感器通过 Arduino 感知温度
- en: In this recipe, we will learn how to sense temperature using the LM35 sensor
    connected to the Arduino board and will display the temperature in Celsius and
    Fahrenheit.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用连接到 Arduino 板的 LM35 传感器来感知温度，并将温度以摄氏度和华氏度显示。
- en: Getting ready...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: 'For this recipe, we will require the following three components: a breadboard, Arduino
    Uno R3, and an LM35 sensor.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要以下三个组件：一个面包板、Arduino Uno R3 和一个 LM35 传感器。
- en: 'The LM35 is a temperature sensor that produces an output voltage that is linearly
    proportional to centigrade temperature. It does not require any external calibration
    or trimming to provide an accurate temperature. It has three terminals, **Vs**,
    **Vout**, and **Ground**, as shown in the following diagram:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: LM35 是一个温度传感器，其输出电压与摄氏温度成线性比例。它不需要任何外部校准或调整即可提供准确的温度。它有三个端子，**Vs**、**Vout**
    和 **Ground**，如下所示：
- en: '![](img/47c2e713-5144-4a84-aa65-2707c8c3ef23.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47c2e713-5144-4a84-aa65-2707c8c3ef23.png)'
- en: Figure 5.12
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12
- en: 'We will connect the LM35 sensor to the Arduino board as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式将 LM35 传感器连接到 Arduino 板：
- en: Connect the +Vs terminal to +5v on your Arduino board.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 +Vs 端口连接到 Arduino 板上的 +5v。
- en: Connect the Vout terminal to Analog0 or A0 on the Arduino board.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Vout 端口连接到 Arduino 板上的 Analog0 或 A0。
- en: Connect the GND terminal with the GND terminal on Arduino.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 GND 端口与 Arduino 上的 GND 端口连接。
- en: 'The following diagram makes this clearer:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表使这一点更清晰：
- en: '![](img/a3e15b71-9f5d-4412-9432-3a23edc8b178.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3e15b71-9f5d-4412-9432-3a23edc8b178.png)'
- en: Figure 5.13
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13
- en: Now that the LM35 sensor is connected to the Arduino board, let's perform the
    steps listed next.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在LM35传感器已连接到Arduino板，让我们执行以下步骤。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To sense temperature using the LM35 sensor connected to the Arduino board,
    perform the following steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用连接到Arduino板的LM35传感器检测温度，请执行以下步骤：
- en: 'Invoke the Arduino IDE. Arduino will open up with a file showing its default
    content, as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用Arduino IDE。Arduino将以显示其默认内容的文件打开，如下所示：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Connect the Arduino board to the PC.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Arduino板连接到PC。
- en: From the Tools menu, select Port and confirm whether it shows COM3 (Arduino/Genuino
    Uno) or whatever Arduino board you have attached to your PC. Additionally, confirm
    whether the Board option from the Tools menu indicates the Arduino board that
    is attached to your PC. In my case, the Board option will show Arduino/Genuino
    Uno.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具菜单中，选择端口并确认是否显示COM3（Arduino/Genuino Uno）或您连接到PC的任何Arduino板。此外，确认工具菜单中的板选项是否指示连接到您的PC的Arduino板。在我的情况下，板选项将显示Arduino/Genuino
    Uno。
- en: 'Type the following program into the editor window:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下程序输入到编辑器窗口中：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the application by clicking on the File | Save As option. Specify the application
    name when prompted. Let's name the application `SensorApp`. A folder will be created
    with the name `SensorApp` and, within that folder, the application will be created
    with the filename `SensorApp.ino`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击File | Save As选项保存应用程序。在提示时指定应用程序名称。让我们将其命名为`SensorApp`。将创建一个名为`SensorApp`的文件夹，在该文件夹中，将创建一个名为`SensorApp.ino`的应用程序文件。
- en: Upload the application to Arduino by clicking on the Upload icon in the toolbar.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击工具栏中的上传图标将应用程序上传到Arduino。
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We define a variable called `voltage`, of the float data type, and a variable
    called `tempPin`, of the integer type; we will set the latter to represent pin
    0 of Arduino. In order to make our PC communicate with Arduino using serial communication,
    we need to set the data rate in terms of bits per second. So, we will call the
    `Serial.begin` function to set the serial data transmission speed to 9,600 bits
    per second (however, it can be any baud rate).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个名为`voltage`的浮点变量和一个名为`tempPin`的整型变量；我们将后者设置为表示Arduino的0号引脚。为了使我们的PC通过串行通信与Arduino通信，我们需要以每秒比特数来设置数据速率。因此，我们将调用`Serial.begin`函数将串行数据传输速度设置为9,600比特每秒（然而，可以是任何波特率）。
- en: Within the `loop` function, we will invoke the `analogRead` function to read
    the value from the specified analog pin, 0\. Recall that the Arduino boards contain
    a multichannel, 10-bit analog to digital converter that maps input voltages between
    0 and the operating voltage (5V or 3.3V) into integer values between 0 and 1023\.
    The value read from the analog pin, 0, is assigned to the `voltage` variable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loop`函数中，我们将调用`analogRead`函数从指定的模拟引脚读取值，0。回想一下，Arduino板包含一个多通道、10位模拟到数字转换器，它将0到工作电压（5V或3.3V）之间的输入电压映射到0到1023之间的整数值。从模拟引脚0读取的值被分配给`voltage`变量。
- en: 'We are using a 5V Arduino and an LM35 sensor is already connected to its analog
    pin. We will use the following formula to convert the 10-bit analog reading into
    a temperature:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用5V Arduino板，并且LM35传感器已经连接到其模拟引脚。我们将使用以下公式将10位模拟读数转换为温度：
- en: '[PRE11]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This formula converts the numbers 0-1023 from the ADC into 0-5000 mV. To convert
    millivolts retrieved from this formula into temperature, we will use another formula:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此公式将ADC中的数字0-1023转换为0-5000 mV。要将此公式检索到的毫伏数转换为温度，我们将使用另一个公式：
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The two previously mentioned formulas can be rewritten as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将前面提到的两个公式重写如下：
- en: '[PRE13]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using this formula, the value read into the voltage variable is converted into
    temperature in Celsius and is assigned to the `tempInCelsius` variable. To convert
    temperature in Celsius (°C) into Fahrenheit (°F), the following formula is used:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此公式，将读取到电压变量的值转换为摄氏度温度，并分配给`tempInCelsius`变量。要将摄氏度（°C）温度转换为华氏度（°F），使用以下公式：
- en: '[PRE14]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using this formula, the temperature in Celsius found in the `tempInCelsius`
    variable is converted into Fahrenheit and assigned to the `tempinFahrenheit` variable.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此公式，将`tempInCelsius`变量中找到的摄氏度温度转换为华氏度，并分配给`tempinFahrenheit`变量。
- en: Temperatures in °C and °F are displayed to the serial port by invoking. The
    temperature reading can be seen by opening the serial monitor. Press *Ctrl* +
    *Shift* + *M* to open the serial monitor and display the temperature. You can
    also press the LM35 sensors in your thumbs to see the rise and fall in temperature.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用，将摄氏度（°C）和华氏度（°F）的温度显示到串行端口。可以通过打开串行监视器来查看温度读数。按*Ctrl* + *Shift* + *M*打开串行监视器并显示温度。您还可以按下您的拇指上的LM35传感器来观察温度的升降。
- en: We will introduce a delay of 1,000 milliseconds between every temperature display
    by invoking the `delay` function. That is, the application will keep displaying
    the temperature in °C and °F infinitely with a delay of 1,000 milliseconds in
    between.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过调用`delay`函数在每次温度显示之间引入1,000毫秒的延迟。也就是说，应用程序将以1,000毫秒的延迟无限期地显示摄氏度和华氏度的温度。
- en: 'After uploading the program to Arduino, we can press *Ctrl* + *Shift* + *M*
    to open the serial monitor. In the serial monitor, we will get the temperature
    in Celsius as well as in Fahrenheit. You will keep getting a temperature reading
    continuously with a delay of 1,000 milliseconds in between:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在将程序上传到Arduino后，我们可以按*Ctrl* + *Shift* + *M*打开串行监视器。在串行监视器中，我们将得到摄氏度和华氏度的温度读数。您将每隔1,000毫秒连续获得温度读数：
- en: '![](img/1da08133-eb6e-40eb-a29c-2b463fe3f741.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1da08133-eb6e-40eb-a29c-2b463fe3f741.png)'
- en: Figure 5.14
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14
- en: 'In the following photograph, you can see the LM35 sensor attached to the Arduino
    board. You can press the LM35 sensor in your thumbs to see the rise in the temperature
    readings:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的照片中，您可以看到LM35传感器连接到Arduino板上。您可以按下您的拇指上的LM35传感器来观察温度读数的上升：
- en: '![](img/057da4bd-05a4-412b-b6b8-db19a90d7bcd.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/057da4bd-05a4-412b-b6b8-db19a90d7bcd.png)'
- en: Figure 5.15
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15
- en: Voilà! We've successfully created a temperature sensor with an LM35 sensor using
    Arduino.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已成功使用Arduino和LM35传感器创建了一个温度传感器。
