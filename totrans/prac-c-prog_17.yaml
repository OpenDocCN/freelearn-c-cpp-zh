- en: Embedded Software and IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to doing specific tasks more efficiently and precisely, embedded
    systems are preferred. They work as independent components, and they can be collectively
    combined into larger pieces of equipment. The internet is a vast and endless source
    of information; consequently, the **Internet of Things** (**IoT**) plays a major
    role in making embedded devices smarter so that they can be managed and controlled
    remotely.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll deep dive into the following recipes related to embedded
    software and IoT:'
  prefs: []
  type: TYPE_NORMAL
- en: Toggling the port of a microcontroller in Embedded C (blinking LED)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incrementing the value of a port in Embedded C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toggling the voltage in an output pin using Arduino (blinking LED)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking input from the serial port using Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensing the temperature using Arduino with the LM35 sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For embedded programming in C, we will use Keil MDK, which provides a software
    development environment for a wide range of ARM Cortex-M-based microcontroller
    devices. MDK provides the very easy-to-use µVision IDE, an Arm C/C++ compiler,
    and other libraries. You can download Keil MDK from the following URL: [https://www.keil.com/download/](https://www.keil.com/download/).
    Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the following three executable files. You may not find the files with
    exactly the same names, but they will be somewhat similar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mdk526.exe`: This provides a development environment for ARM devices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c251v560.exe`: This provides development tools for all 80251 devices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c51v959.exe`: This provides development tools for all 8051 devices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Double-click on these executable files one by one and follow the setup dialog
    boxes to install these three Keil products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following the successful installation of these products, you will find an icon
    called Keil uVision5 on the desktop. The icon represents the **Integrated Development
    Environment** (**IDE**) that enables us to write, edit, debug, and compile programs.
    The compiler converts the source code into a HEX file, which, in return, can be
    fused onto the target chip.
  prefs: []
  type: TYPE_NORMAL
- en: In order to work with Arduino, you have to buy the Arduino board and download
    the Arduino IDE from [https://www.arduino.cc/en/main/software](https://www.arduino.cc/en/main/software).
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this chapter, the latest version of the Arduino IDE that
    is available is 1.8.8\. The downloaded executable file will be `arduino-1.8.8-windows.exe`.
    Connect the Arduino board to your PC and simply double-click on the executable
    file to install the Arduino IDE. When it has successfully installed, you will
    find the Arduino IDE icon on the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to embedded systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An embedded system is a combination of computer hardware and software designed
    to do specific functions within larger equipment. The heavy equipment used in
    industries, automobiles, medical procedures, household appliances, and mobile
    devices use embedded systems. Most embedded systems use a RISC family microcontroller,
    such as PIC 16F84, Atmel 8051, or Motorola 68HC11\. Several input and output devices
    can be connected to the embedded system's microcontrollers, such as an LCD display,
    keypad, printer, and sensor. These devices can control several other devices such
    as fans, motors, bulbs, washing machines, ovens, AC controllers, cars, printers,
    and so much more.
  prefs: []
  type: TYPE_NORMAL
- en: To program a microcontroller to do a specific task, the microcontroller is interfaced
    with a PC by connecting it to a slot. An assembly program, or Embedded C, can
    be used to write and burn the program onto the microcontroller. The programs can
    be stored in the microcontroller's **EPROM **(short for **Erasable Programmable
    Read-Only Memory**). It's an internal, read-only memory that can be programmed
    and erased when exposed to an ultraviolet light source. We will be developing
    applications for embedded systems using Embedded C with software such as Keil.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IoT is an architecture that comprises hardware and software systems or devices
    that are connected to the internet using various means such as WiFi, Ethernet,
    and more. The web API and other protocols, when combined, provide an environment
    that allows smart embedded devices to be connected to the internet. Consequently,
    it enables us to access data from remote areas and control or trigger certain
    actions on various devices via the internet. In other words, IoT is a system of
    interrelated embedded computing devices that have the ability to transfer data
    over a network and take necessary actions. Arduino is considered to be the best
    starting point for embedded IoT. For Arduino to be able to work as an IoT device,
    Android with an Ethernet shield is required.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly learn a little more about Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Arduino
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arduino is an architecture that includes the Atmel microcontroller family along
    with standard hardware. The pin diagram of Arduino is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4b83b8f-6db5-46a6-bfe8-717fa7b3738b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Arduino includes 14 digital pins that can operate with 5V:'
  prefs: []
  type: TYPE_NORMAL
- en: Pins **0** (**RXD**) and **1** (**TXD**) are the serial pins used to transfer TTL
    serial data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pins **2** and **3** are the external interrupt pins used to activate an interrupt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pins **3**, **5**, **6**, **9**, **10**, and **11** are used to provide the
    PWM output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pins **10**, **11**, **12**, and **13** are **SPI** pins (short for the **Serial
    Peripheral Interface**). Named **SS**, **MOSI**, **MISO**, and **SCK**, these
    pins are used for SPI communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin **13** is an LED pin. A HIGH digital value, when supplied to this pin, will
    make the LED glow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analog pins **4** and **5**—called **SDA** and **SCL**, respectively—are used
    in the communication of **TWI** (short for the **Two-Wire Interface**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **AREF** (short for **Analog Reference**) pin is used to connect to some
    reference voltage from an external power supply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **RESET** (**RST**) pin is used to reset the microcontroller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As far as software is concerned, Arduino comes with an IDE that we can use to
    write and edit applications and can even upload them to do specific tasks. This
    IDE includes support for the C and C++ programming languages for programming microcontrollers.
    It contains several libraries that make the job of a software developer quite
    easy. Besides this, the IDE provides communication windows in order to enter data
    into the board as well as to get output.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino board provides ports to connect LCDs, relays, and much more to its
    output pin and provides input pins to input information from sensors, relays,
    and much more. The Arduino board can be powered either by a USB or by connecting
    a 9V battery.
  prefs: []
  type: TYPE_NORMAL
- en: 'While working with Arduino programming, we will be using the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Serial.begin()` is used to set the data rate while establishing communication
    between the Arduino board and the PC. In order to communicate with the computer
    through serial data transmission, we need to first set the data rate in bits per
    second (baud). We can use any of the baud rates, such as 300, 600, 1200, 2400,
    4800, 9600, 14400, 19200, 28800, 38400, 57600, or 115200.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Serial.println()` is used to display a message to the serial port in a human-readable
    format. It displays the message in ASCII text followed by a newline character
    on the serial monitor. You will need to press *Ctrl* + *Shift* + *M* to open the
    serial monitor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Serial.available()` checks whether the data, in terms of bytes from the serial
    port, is available for reading. Essentially, the data to be read from the serial
    port is stored in the serial receive buffer and this method checks whether the
    data has arrived in this buffer. This method returns the number of bytes available
    to read:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Serial.read()` reads incoming serial data and returns the first byte of incoming
    serial data available. The method returns `-1` if no data is available to read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`analogRead()` reads the value from the specified analog pin. The Arduino board
    contains a multichannel, 10-bit analog-to-digital converter. As a result of this,
    it will map input voltages between 0 and the operating voltage (5V or 3.3V) into
    integer values between 0 and 1023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if you''re using a 5V Arduino and a sensor is connected to its
    analog pin, then the following formula is used to convert the 10-bit analog reading
    into a temperature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This formula converts the number 0-1023 from the ADC into 0-5000 mV.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using a 3.3V Arduino, then the following formula is used to convert
    the analog reading into a temperature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This formula converts the number 0-1023 from the ADC into 0-3300 mV.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the number of millivolts retrieved from the preceding formula into
    a temperature, the following formula is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That wraps up our introduction to embedded systems and IoT. We'll now review
    the required technical software and hardware we need to complete the recipes in
    this chapter. After that, we will begin with the first recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling the port of a microcontroller in Embedded C (blinking LED)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to send HIGH and LOW signals to a specific
    port that is connected to an LED, and make the LED blink. The idea behind this
    exercise is to learn how to control a device that is connected to a specific port
    of the microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To toggle the port of a microcontroller in Embedded C, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will carry out this recipe using Keil; double-click on the Keil uVision5
    icon to activate the IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new project by clicking on the Project | New uVision Project option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, specify the project name and the folder where you want to create
    the new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the new project the name `LedBlinkProject` and then click on the Save button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The device selection window will open and you will be prompted to select a device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Device combo box, select the Legacy Device Database [no RTE] option.
    You will get the list of devices in the lower-left pane (refer to the following
    screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Microchip node to expand it and display the list of devices in
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because we want to program the Atmel microcontroller, from the Microchip node,
    select the AT89C51 device. The description of the selected device will appear
    in the description pane on the right. Click on OK to move further:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e086bd76-9554-4d4c-8d26-c961142a3a99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will be asked whether you want to copy the `STARTUP.A51` file to the project
    folder (refer to the following screenshot). The startup file will be required
    for running the project, so click on the Yes button to add the file and move further:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d23d91fa-3ead-45eb-a4ba-ea5fe55903bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The IDE will appear as follows. You can see three windows: Project Workspace,
    Editing Window, and Output Window in the IDE. Additionally, you can see the Target1 node
    created under the Project space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4c8417f2-dce2-469e-b0d2-e5fc9330f0c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a C file. Right-click on Source Group1 under the Target1 node and click
    on the Add New item to Group ''Source Group 1'' option. From the list box, select
    the C File (.c) option. Specify the filename as `blinkingLed` (or any other name),
    and then click on the Add button (refer to the following screenshot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aa3a6f00-ca50-475d-a1d3-fa8bf5bbfd87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `blinkingLed.c` file is added to Source Group 1\. Enter the following code
    in the editor window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After entering the code, click on the save icon from the toolbar to save the `blinkingLed.c` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will define a variable called `LED` of the `sbit` type. The `sbit` type defines
    a bit within a **special function register** (**SFR**). We will set the `LED`
    variable to represent the 0^(th)-bit position of port `P1`. Then, we will define
    a prototype of the `Delay` function, which takes an integer parameter but returns
    nothing. Within the `main` function, we will execute a `while` loop in an infinite
    loop. Within the `while` loop, we will set the `LED` variable to `0`, that is,
    a LOW signal will be sent to the 0th bit of port `P1`.
  prefs: []
  type: TYPE_NORMAL
- en: Thereafter, we will introduce a delay through two nested loops. After the delay,
    we will set the value of the `LED` variable to `1`, that is, a HIGH signal will
    be sent to the 0th bit of port `P1`. If the LED is connected to the 0th bit of
    port `1`, the LED will glow and, after some delay, it will go off. Again, after
    some delay, the LED will glow again; therefore, we get a blinking LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press *F7* or click on the Build button to start compiling the code. If there
    is no error, you can move on to the next step. You can either generate a HEX file
    to infuse into the desired hardware, or you can use the simulation technique to
    see whether the program is giving the desired output. In order to generate a HEX
    file, right-click on the Target1 node and select Options for Target ''Target 
    1''. We will get a dialog box showing different options. Click on the Output tab,
    and check the Create HEX File box (refer to the following screenshot). Additionally,
    click on the Device tab to confirm that the device selected is AT89C51\. Then,
    click on the OK button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14d919f9-c13b-4635-8567-8fba4fd9f389.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5
  prefs: []
  type: TYPE_NORMAL
- en: 'Keil''s built-in Debug option can be used for code simulation. To do this,
    click on Debug | Start/Stop Debug Session; alternatively, you can press *Ctrl*
    + *F5* as the shortcut key, or click on the Start/Stop Debug Session icon (it
    appears in the form of d) in the toolbar. The free version of the Keil tool has
    a condition that the running code size should not be more than 2 KB. You will
    get the following dialog box indicating that the running code has an upper limit
    of 2 KB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae978b3a-b3e7-41f8-9e74-e53126b34d46.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the OK button to move further. Now the Project workspace window shows
    most of the SFRs as well as the GPRs, r0 to r7, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28b08d76-c374-4106-ba99-ca014b9987f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Run icon from the toolbar or press *F5*. To see the output on
    ports go to Peripherals | Select I/O ports | Port 1\. You will get the blinking
    LED on `Port1`, as shown in the following screenshot. You can see that there is
    a LOW signal in `bit0` of the `Port1` and a HIGH signal on the same bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d38d1f7a-c909-4c46-9f87-d0bc68d091ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We've successfully created a blinking LED using a microcontroller port.
    Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Incrementing the value of a port in Embedded C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display values from 0 to 255 on a specific
    port of a microcontroller and make the value increment like a counter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To increment the value of a port in Embedded C, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the Keil uVision5 IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new project by clicking on the New Project | New uVision Project option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the project name and folder location when prompted. Let's give the new
    project the name `CounterApp`; click on Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The device selection window will open and you will be prompted to select a device.
    From the Device combo box, select Legacy Device Database [no RTE].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will get the list of devices in the lower-left pane. Click on the Microchip
    node to expand it and display the list of devices in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Microchip node, select the AT89C51 device. The description of the selected
    device will appear in the description pane on the right. Click on OK to move further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be asked whether you want to copy the `STARTUP.A51` file to the project
    folder. Click on Yes to add the file and move further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The IDE will open showing three windows: The Project Workspace on the left,
    the Editing Window on the right, and the Output Window at the bottom. You will
    see Target1 created under the Project space.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a C file by right-clicking on Source Group1 under the Target1 node and then
    click on Add New item to Group 'Source Group 1'.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the list box, select the C File (.c) option. Specify the filename as `showcounter`
    and then click on Add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `showcounter.c` file will be added to Source Group 1\. Enter the following
    code in the editor window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After entering the code, click on the SAVE icon in the toolbar to save the `showcounter.c` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's go behind the scenes to understand the steps better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will define a variable, `i`, of the unsigned char type; a variable of the
    unsigned char type can store 256 bits, whereas that of a signed char can store
    only 128 bits. The `i` variable is assigned the HEX value of `0`. We will set
    a `while` loop to execute infinitely. With every iteration of the `while` loop,
    the value of the `i` variable will increment by `1`. Within the `while` loop,
    we will assign the value of the `i` variable, that is, `0`, to port `P3`.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce a delay by using two nested `for` loops. Thereafter, we will
    execute a `while` loop again, incrementing the value of the `i` variable, making
    it `1`. Again, we will assign the value of the `i` variable to port `P3` for display.
    And, we will reintroduce some delay, followed by executing the `while` loop again.
    This process continues infinitely; consequently, port `P3` will display the counter
    from `0` until `255` repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: Press *F7* or click on the Build button to compile the code. If there is no
    error, you can move ahead to the next step; otherwise, first, debug the code.
    In order to see the output of the code through simulation, we will use Keil's
    built-in Debug option for simulation of the code. To do this, click on Debug |
    Start/Stop Debug Session. Alternatively, you can press *Ctrl* + *F5* as the shortcut
    key, or click on the Start/Stop Debug Session icon (it appears in the form of
    a D) in the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: On the free version of Keil, there is a condition that the running code size
    should not be more than 2 KB, so you will get a dialog box indicating that the
    running code has an upper limit of 2 KB. Click on OK to move further. The project
    workspace window shows most of the SFRs as well as the GPRs, from r0 to r7\. Click
    on the  Run icon from the toolbar or press the *F5* key. You can see the output
    of the ports under Peripherals | Select I/O ports| Port 3\. You will see the bits
    of the ports showing the counter from `0` to `255`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, **(a)** shows the bits set to a value of `5`.
    The binary value of 5 is 101, so, accordingly, the first and third bits are set
    to a HIGH signal and the remaining bits are set to a LOW signal. Similarly, **(b)**
    shows the bits displaying the counter value of 10\. The bits of the port will
    be set showing the values from 0 to 255:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec502c1f-6fea-4ee3-b7b0-a7be409632d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We've successfully created a counter using Embedded C. Now, let's move
    on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Toggle voltage in output pin using Arduino (blinking LED)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to make an LED that is connected to the output
    pins of the Arduino board blink.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make an LED that is connected to the output pins of the Arduino board blink,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Arduino IDE. Arduino opens up with a file showing the default content,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Connect the Arduino board to the PC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Tools menu, select Port and confirm whether it shows COM3 (Arduino/Genuino
    Uno) or whatever Arduino board you have attached to your PC. Additionally, confirm
    whether the Board option from the Tools menu indicates the Arduino board that
    is attached to your PC. In my case, the Board option will show Arduino/Genuino
    Uno.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember, the LEDs have polarity; hence, they will only glow when they are connected
    properly. The long leg is positive and should connect to a digital pin on the
    Arduino board. I am using the 13^(th) pin of the Arduino board for the output,
    so connect the long leg of the LED to the 13^(th) pin of the Arduino board (refer
    to *Figure 5.10*). Then, connect the short leg of the LED, which is negative,
    to the GND on the Arduino board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following program in the editor window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 6\. Save the application by clicking on File | Save As. Specify the application
    name when prompted. Select the desired folder location and specify the application
    name. Let's name the application `ArduinoLedBlink`. A folder will be created with
    the specified application name (`ArduinoLedBlink`), and, within the `ArduinoLedBlink`
    folder, the application will be created with the filename `ArduinoLedBlink.ino`.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Upload the application to Arduino by clicking on the Upload icon in the
    toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go behind the scenes to understand the steps better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by defining a `Led` variable and setting it to represent pin 13
    of the Arduino. By invoking the `pinMode` function, the `Led` variable will be
    indicated as the output pin, that is, it will be connected to an output device
    for display or to do some task.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `loop` function, we will invoke the `digitalWrite` method to send
    a HIGH signal to variable `Led`. By doing so, the LED that is connected to output
    pin 13 will be switched on. Thereafter, we will introduce a time delay of 1,000
    milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Once more, we will invoke the `digitalWrite` method and send a LOW signal, this
    time to variable `Led`. As a result, the LED connected to output pin 13 will be
    switched off. Again, we will introduce a delay of 1,000 milliseconds. The commands
    in the `loop` function will execute infinitely making the connected LED to keep
    blinking.
  prefs: []
  type: TYPE_NORMAL
- en: 'On uploading the program to Arduino, the LED connected to the 13^(th) pin of
    the Arduino will start blinking, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65963531-c8ab-44ae-a5e6-b034cc5f825f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We've successfully toggled the voltage in an output pin on the Arduino
    board to make a blinking LED.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Taking input from the serial port using Arduino
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be attaching an LED to the Arduino board and will prompt
    the user to press either `0` or `1`. The user can input a value using the serial
    port. If the value entered by the user is `0`, it will switch off the LED and
    if the value entered by the user is `1`, it will make the LED glow.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To take input from the serial port using Arduino, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke the Arduino IDE. Arduino opens up with a file showing its default content,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Connect the Arduino board to your PC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Tools menu, select Port and confirm whether it shows COM3 (Arduino/Genuino
    Uno) or whatever Arduino board you have attached to your PC. Additionally, confirm
    whether the Board option from the Tools menu indicates the Arduino board that
    is attached to your PC. In my case, the Board option will show Arduino/Genuino
    Uno.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be attaching the LED to the output pin 13 of Arduino. Because the LEDs
    have polarity and need to be connected properly, we will connect the long leg
    of the LED (also known as the positive pin) to the 13^(th) digital pin on the
    Arduino board. Additionally, we will connect the short leg of the LED (also known
    as the negative pin) to the GND on the Arduino board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following program in the editor window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Save the application by clicking on the File | Save As option. Specify the application
    name when prompted. Let's name the application `ArduinoTakinginput`. A folder
    will be created with the specified application name, and, within the `ArduinoLedBlink`
    folder, the application will be created with the filename `ArduinoTakinginput.ino`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upload the application to Arduino by clicking on the Upload icon from the toolbar
    (refer to the following screenshot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c1e6c409-2c23-46a8-bcce-de4cd5110ffc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's go behind the scenes to understand the steps better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will define a `Led` variable and set it to represent pin 13 of Arduino. By
    invoking the `pinMode` function, the `Led` variable is declared as the output
    pin and, hence, we will use it for connecting to an output device in order to
    perform a desired action. In this application, the output device will be an LED.
  prefs: []
  type: TYPE_NORMAL
- en: Because we want our PC to communicate with Arduino using serial communication,
    we need to set the data rate in terms of bits per second. So, we will call the
    `Serial.begin` function to set the serial data transmission speed at 9,600 bits
    per second (however, it can be any baud rate). Thereafter, we will display a message
    on the serial port in a human-readable format, informing the user that `0` can
    be pressed to switch off the connected LED and `1` can be pressed to switch on
    the LED.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `loop` function of Arduino, we will invoke the `Serial.available`
    function to check whether any data is available in the serial port to read from.
    That is, the serial receive buffer will be checked to see whether some data or
    bytes are available there to be read. The data can be available in the serial
    receive buffer only when the user presses any key. It also means that no output
    will appear until the user presses any key. The moment the user presses any key,
    that byte will go into the serial receive buffer and the `Serial.available` function
    will return the Boolean value `true`. As a result of this, the `if` block will
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `if` block, we will invoke the `Serial.read` function to read the
    serial data from the serial port. The data or byte that is read from the serial
    port will be assigned to the variable input. The byte read is always in ASCII
    format. The user is supposed to press either `0` or `1`; their corresponding ASCII
    values are 48 and 49, respectively. So, if the user presses `0`, its ASCII value,
    48, will be assigned to the variable input. And if the user presses `1`, its ASCII
    value, 49, will be assigned to the variable input.
  prefs: []
  type: TYPE_NORMAL
- en: To get the actual value of the number entered by the user, the value of 48 is
    subtracted from the variable input. If the user presses `0`, a specified `if`
    block will execute. Within that `if` block, we will invoke the `Serial.println`
    function to display the message *LED is OFF* to inform the user. And we will invoke
    the `digitalWrite` method to send a LOW signal to output pin 13 where the LED
    is connected. Consequently, the LED, if it is glowing, will be switched off.
  prefs: []
  type: TYPE_NORMAL
- en: If the user presses `1`, then another `if` block will execute; in this case,
    we will invoke the `Serial.println` function to display the message *LED is On.* And
    we will invoke the `digitalWrite` function to send a HIGH signal to output pin
    13 to make the LED glow. If the user has not pressed either `0` or `1`, we will
    display a message asking them to press either `0` or `1` only.
  prefs: []
  type: TYPE_NORMAL
- en: 'After uploading the program to Arduino, we can press *Ctrl* + *Shift* + *M*
    to open the serial monitor. In the serial monitor, we will get the following message:
    *Enter 0 to switch off LED and 1 to switch it On* (refer to the first dialog box
    in *Figure 5.11*). After pressing `0` in the serial monitor, we will get the message LED
    is OFF and, again, you will be prompted to enter either `0` or `1` (refer to the
    second dialog box in *Figure 5.11*). Besides the message in the serial monitor,
    the LED that is connected to the 13^(th) pin of the Arduino board will also get
    switched off (if it was glowing). On pressing `1`, the message LED is ON will
    be displayed in the serial monitor. Additionally, a message will appear prompting
    us to enter either `0` or `1` (refer to the third dialog box in *Figure 5.11*).
    Also, the LED connected to the Arduino board will glow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90223173-1fb1-469f-9ace-27a614a2fc47.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We've successfully made an LED switch on and off on the basis of the
    input made to the serial port using Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Sensing the temperature using Arduino with the LM35 sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to sense temperature using the LM35 sensor
    connected to the Arduino board and will display the temperature in Celsius and
    Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will require the following three components: a breadboard, Arduino
    Uno R3, and an LM35 sensor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The LM35 is a temperature sensor that produces an output voltage that is linearly
    proportional to centigrade temperature. It does not require any external calibration
    or trimming to provide an accurate temperature. It has three terminals, **Vs**,
    **Vout**, and **Ground**, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47c2e713-5144-4a84-aa65-2707c8c3ef23.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12
  prefs: []
  type: TYPE_NORMAL
- en: 'We will connect the LM35 sensor to the Arduino board as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the +Vs terminal to +5v on your Arduino board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Vout terminal to Analog0 or A0 on the Arduino board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND terminal with the GND terminal on Arduino.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram makes this clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3e15b71-9f5d-4412-9432-3a23edc8b178.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13
  prefs: []
  type: TYPE_NORMAL
- en: Now that the LM35 sensor is connected to the Arduino board, let's perform the
    steps listed next.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To sense temperature using the LM35 sensor connected to the Arduino board,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke the Arduino IDE. Arduino will open up with a file showing its default
    content, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Connect the Arduino board to the PC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Tools menu, select Port and confirm whether it shows COM3 (Arduino/Genuino
    Uno) or whatever Arduino board you have attached to your PC. Additionally, confirm
    whether the Board option from the Tools menu indicates the Arduino board that
    is attached to your PC. In my case, the Board option will show Arduino/Genuino
    Uno.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following program into the editor window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Save the application by clicking on the File | Save As option. Specify the application
    name when prompted. Let's name the application `SensorApp`. A folder will be created
    with the name `SensorApp` and, within that folder, the application will be created
    with the filename `SensorApp.ino`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the application to Arduino by clicking on the Upload icon in the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We define a variable called `voltage`, of the float data type, and a variable
    called `tempPin`, of the integer type; we will set the latter to represent pin
    0 of Arduino. In order to make our PC communicate with Arduino using serial communication,
    we need to set the data rate in terms of bits per second. So, we will call the
    `Serial.begin` function to set the serial data transmission speed to 9,600 bits
    per second (however, it can be any baud rate).
  prefs: []
  type: TYPE_NORMAL
- en: Within the `loop` function, we will invoke the `analogRead` function to read
    the value from the specified analog pin, 0\. Recall that the Arduino boards contain
    a multichannel, 10-bit analog to digital converter that maps input voltages between
    0 and the operating voltage (5V or 3.3V) into integer values between 0 and 1023\.
    The value read from the analog pin, 0, is assigned to the `voltage` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using a 5V Arduino and an LM35 sensor is already connected to its analog
    pin. We will use the following formula to convert the 10-bit analog reading into
    a temperature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This formula converts the numbers 0-1023 from the ADC into 0-5000 mV. To convert
    millivolts retrieved from this formula into temperature, we will use another formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The two previously mentioned formulas can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this formula, the value read into the voltage variable is converted into
    temperature in Celsius and is assigned to the `tempInCelsius` variable. To convert
    temperature in Celsius (°C) into Fahrenheit (°F), the following formula is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using this formula, the temperature in Celsius found in the `tempInCelsius`
    variable is converted into Fahrenheit and assigned to the `tempinFahrenheit` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Temperatures in °C and °F are displayed to the serial port by invoking. The
    temperature reading can be seen by opening the serial monitor. Press *Ctrl* +
    *Shift* + *M* to open the serial monitor and display the temperature. You can
    also press the LM35 sensors in your thumbs to see the rise and fall in temperature.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce a delay of 1,000 milliseconds between every temperature display
    by invoking the `delay` function. That is, the application will keep displaying
    the temperature in °C and °F infinitely with a delay of 1,000 milliseconds in
    between.
  prefs: []
  type: TYPE_NORMAL
- en: 'After uploading the program to Arduino, we can press *Ctrl* + *Shift* + *M*
    to open the serial monitor. In the serial monitor, we will get the temperature
    in Celsius as well as in Fahrenheit. You will keep getting a temperature reading
    continuously with a delay of 1,000 milliseconds in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1da08133-eb6e-40eb-a29c-2b463fe3f741.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following photograph, you can see the LM35 sensor attached to the Arduino
    board. You can press the LM35 sensor in your thumbs to see the rise in the temperature
    readings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/057da4bd-05a4-412b-b6b8-db19a90d7bcd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We've successfully created a temperature sensor with an LM35 sensor using
    Arduino.
  prefs: []
  type: TYPE_NORMAL
