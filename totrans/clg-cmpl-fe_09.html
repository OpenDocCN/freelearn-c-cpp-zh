<html><head></head><body>
<div id="book-content" class="calibre2">
<div id="sbo-rt-content" class="calibre3"><section id="chapter-7-refactoring-tools" class="level" data-number="2.3">
<h1 data-number="2.3" class="calibre5"><span>7</span></h1>
<h1 id="sigil_toc_id_114" class="calibre5"><a id="x1-1320007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Refactoring Tools</h1>
<p class="hidden">Clang is renowned for its ability to provide suggestions for code fixes. For instance, if you miss a semicolon, Clang will suggest that you insert it. The ability to modify source code goes beyond the compilation process and is widely used in various tools for code modifications, particularly in refactoring tools. The ability to offer fixes is a powerful feature that extends the capabilities of a linter framework, such as Clang-Tidy, which not only detects issues but also provides suggestions for fixing them.</p>
<p class="hidden">In this chapter, we will explore refactoring tools. We will begin by discussing the fundamental classes used for code modification, notably <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Rewriter</code></span>. We will use Rewriter to build a custom refactoring tool that changes method names within a class. Later in the chapter, we will reimplement the tool using Clang-Tidy and delve into <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">FixItHint</code></span>, a component of the Clang Diagnostics subsystem that is employed by both Clang-Tidy and the Clang compiler to modify source code.</p>
<p class="hidden">To conclude the chapter, we will introduce a crucial Clang tool called Clang-Format. This tool is widely employed for code formatting. We will explore the functionality offered by the tool, delve into its design, and understand the rationale behind specific design decisions made during its development.</p>
<p class="hidden">The chapter covers the following topics:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">How to create a custom Clang tool for code refactoring</p></li>
<li class="calibre14"><p class="calibre15">How to integrate code modifications into a Clang-Tidy check</p></li>
<li class="calibre14"><p class="calibre15">An overview of Clang-Format and how it can be integrated with Clang-Tidy</p></li>
</ul>
<p class="hidden"><a id="x1-132001r401" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<section id="technical-requirements-6" class="level" data-number="2.3.1">
<h2 data-number="2.3.1" id="sigil_toc_id_115" class="likechapterhead"><span>7.1 </span> <a id="x1-1330001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Technical requirements</h2>
<p class="hidden">The source code for this chapter is located in the <code class="calibre13">chapter7 </code>folder of the book’s GitHub repository: <a href="https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter7</a>. <a id="x1-133001r403" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="custom-code-modification-tool" class="level" data-number="2.3.2">
<h2 data-number="2.3.2" id="sigil_toc_id_116" class="likechapterhead"><span>7.2 </span> <a id="x1-1340002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Custom code modification tool</h2>
<p class="hidden">We will create a Clang tool that will help us to rename methods for a class that is used for unit testing. We will start <a id="dx1-134001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>with a description for the <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Rewriter</code></span> class – the basic class that is used for code modifications. <a id="x1-134002r392" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<section id="code-modification-support-at-clang" class="level" data-number="2.3.2.1">
<h3 data-number="2.3.2.1" id="sigil_toc_id_117" class="likesectionhead"><span>7.2.1 </span> <a id="x1-1350001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Code modification support at Clang</h3>
<p class="hidden"><span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Rewriter</code></span> is a Clang library class that facilitates source code rewriting operations within a translation unit. It provides <a id="dx1-135001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>methods for inserting, removing, and replacing code within the<strong class="calibre12">Abstract Syntax Tree</strong> <strong class="calibre12">(AST) </strong>of the source code. Developers can use <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Rewriter</code></span> for complex <a id="dx1-135002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>code modifications, such as restructuring or generating new code constructs. It can be applied for both code generation and code refactoring tasks, making it versatile for various code transformation purposes.</p>
<p class="hidden">The class has several methods for text insertion; for instance, <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Rewriter</code></span> <span><code class="calibre13">::</code><code class="calibre13">InsertText</code></span> inserts the text at the specified source location, and <span><code class="calibre13">clang</code></span> <span><code class="calibre13">::</code><code class="calibre13">SourceLocation</code></span> is used to specify the exact location at the buffer, see <a href="B19722_04.xhtml#x1-790001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 4.4.1</em></a><em class="calibre11">,</em> <em class="calibre11">SourceManager and SourceLocation</em>. In addition to the text insertion, you can also remove text with <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Rewriter</code><code class="calibre13">::</code><code class="calibre13">RemoveText</code></span> or replace text with a new one using <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Rewriter</code><code class="calibre13">::</code><code class="calibre13">ReplaceText</code></span>. The last two <a id="dx1-135003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>use source range (<span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">SourceRange</code></span>) to specify the positions at the text to be removed or replaced.</p>
<p class="hidden"><span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Rewriter</code></span> uses <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">SourceManager</code></span>, as explained in <a href="B19722_04.xhtml#x1-790001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 4.4.1</em></a><em class="calibre11">, SourceManager and SourceLocation</em>, to access the source code that needs to be modified. Let’s look at how Rewriter can be used in a real project. <a id="x1-135004r405" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="test-class" class="level" data-number="2.3.2.2">
<h3 data-number="2.3.2.2" id="sigil_toc_id_118" class="likesectionhead"><span>7.2.2 </span> <a id="x1-1360002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Test class</h3>
<p class="hidden">Suppose we have a class that is used for tests. The class name starts with the ”Test” prefix (for instance, <span><code class="calibre13">TestClass</code></span>), but there aren’t any ’test_’ prefixes for public methods of the class. For instance, the class has a <a id="dx1-136001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>public method with the name ’pos’ (<span><code class="calibre13">TestClass</code><code class="calibre13">::</code><code class="calibre13">pos</code></span>) instead of ’test_pos’ (<span><code class="calibre13">TestClass</code><code class="calibre13">::</code><code class="calibre13">test_pos</code><code class="calibre13">()</code></span>). We want to create a tool that will add such a prefix for the class methods.</p>
<div class="tableofcontents">
<pre class="source-code"><span>1 </span>class TestClass { 
 

<span>2 </span>public: 
 

<span>3 </span>  TestClass(){}; 
 

<span>4 </span>  void pos(){}; 
 

<span>5 </span> 
 
<span>6 </span>private: 
 

<span>7 </span>  void private_pos(){}; 
 

<span>8 </span>};</pre>
<p class="hidden"><strong class="calibre12"/>Original code </p>
</div>
<div class="tableofcontents">
<pre class="source-code"><span>1 </span>class TestClass { 
 

<span>2 </span>public: 
 

<span>3 </span>  TestClass(){}; 
 

<span>4 </span>  void test_pos(){}; 
 

<span>5 </span> 
 
<span>6 </span>private: 
 

<span>7 </span>  void private_pos(){}; 
 

<span>8 </span>};</pre>
<p class="hidden"><strong class="calibre12"/>Modified code </p>
</div>
<p class="hidden"><a id="x1-136020r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-136021" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.1</strong>: Code transformations for TestClass </p>
<p class="hidden">Thus, we want the method <span><code class="calibre13">TestClass</code><code class="calibre13">::</code><code class="calibre13">pos</code></span> (see <a href="#x1-136020r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.1</a>) to be replaced with <span><code class="calibre13">TestClass</code><code class="calibre13">::</code><code class="calibre13">test_pos</code></span> at the class declaration.</p>
<p class="hidden">If we have a code where we make a call to the method, the following replacement should be made:</p>
<div class="tableofcontents">
<pre id="listing-52" class="source-code">1      TestClass test; 
 

<span>2 </span>      test.pos();</pre>
<p class="hidden"><strong class="calibre12"/>Original code </p>
</div>
<div class="tableofcontents">
<pre id="listing-53" class="source-code">1      TestClass test; 
 

<span>2 </span>      test.test_pos();</pre>
<p class="hidden"><strong class="calibre12"/>Modified code </p>
</div>
<p class="hidden"><a id="x1-136026r2" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-136027" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.2</strong>: Code transformations for TestClass’s method calls </p>
<p class="hidden">The tool should also ignore all <a id="dx1-136028" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>public methods with the required modifications already applied, either manually or automatically. In other words, if a method already has the required ’test_’ prefix, the tool should not modify it.</p>
<p class="hidden">We are going to create a Clang tool called ’methodrename’, which will perform all the required code modifications. This tool will utilize the recursive AST visitor discussed in <a href="B19722_03.xhtml#x1-620004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 3.4</em></a><em class="calibre11">, Recursive AST visitor</em>. The most crucial aspect is the implementation of the <code class="calibre13">Visitor </code>class. Let’s examine it in detail. <a id="x1-136029r406" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="visitor-class-implementation" class="level" data-number="2.3.2.3">
<h3 data-number="2.3.2.3" id="sigil_toc_id_119" class="likesectionhead"><span>7.2.3 </span> <a id="x1-1370003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Visitor class implementation</h3>
<p class="hidden">Our <code class="calibre13">Visitor </code>class should <a id="dx1-137001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>handle specific processing for the following AST nodes:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">CXXRecordDecl</code></span>: This involves processing C++ class definitions with names starting with the ”Test” prefix. For such classes, all user-defined public methods should be prefixed with ”test_”.</p></li>
<li class="calibre14"><p class="calibre15"><span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">CXXMemberCallExpr</code></span>: Additionally, we need to identify all instances where the modified method is used and make the corresponding changes following the method’s renaming in the class definition.</p></li>
</ul>
<p class="hidden">The processing for <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">CXXRecordDecl</code></span> nodes will be as follows:</p>
<pre class="source-code"><span>10 </span>  bool VisitCXXRecordDecl(clang::CXXRecordDecl *Class) { 
 

<span>11 </span>    if (!Class-&gt;isClass()) 
 
<span>12 </span>      return true; 
 

<span>13 </span>    if (!Class-&gt;isThisDeclarationADefinition()) 
 

<span>14 </span>      return true; 
 
<span>15 </span>    if (!Class-&gt;getName().starts_with("Test")) 
 

<span>16 </span>      return true; 
 
<span>17 </span>    for (const clang::CXXMethodDecl *Method : Class-&gt;methods()) { 
 

<span>18 </span>      clang::SourceLocation StartLoc = Method-&gt;getLocation(); 
 

<span>19 </span>      if (!processMethod(Method, StartLoc, "Renamed method")) 
 

<span>20 </span>        return false; 
 
<span>21 </span>    } 
 
<span>22 </span>    return true; 
 
<span>23 </span>  }</pre>
<p class="hidden"><a id="x1-137017r3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-137018" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.3</strong>: CXXRecordDecl visitor implementation </p>
<p class="hidden"><em class="calibre11">Lines 11-16 </em>in <a href="#x1-137017r3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.3</a> represent the conditions <a id="dx1-137019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>that we require from the examined node. For example, the corresponding class name should start with the ”Test” prefix (see <em class="calibre11">Lines 15-16 </em>in <a href="#x1-137017r3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.3</a>), where we utilize the <span><code class="calibre13">starts_with</code><code class="calibre13">()</code></span> method of the <span><code class="calibre13">llvm</code><code class="calibre13">::</code><code class="calibre13">StringRef</code></span> class.</p>
<p class="hidden">After verifying these conditions, we proceed to examine the methods within the found class.</p>
<p class="hidden">The verification process is implemented in the <span><code class="calibre13">Visitor</code><code class="calibre13">::</code><code class="calibre13">processMethod</code></span> method, and its implementation is presented in the following code fragment:</p>
<pre class="source-code"><span>44 </span>  bool processMethod(const clang::CXXMethodDecl *Method, 
 

<span>45 </span>                     clang::SourceLocation StartLoc, const char *LogMessage) { 
 

<span>46 </span>    if (Method-&gt;getAccess() != clang::AS_public) 
 

<span>47 </span>      return true; 
 
<span>48 </span>    if (llvm::isa&lt;clang::CXXConstructorDecl&gt;(Method)) 
 

<span>49 </span>      return true; 
 
<span>50 </span>    if (!Method-&gt;getIdentifier() || Method-&gt;getName().starts_with("test_")) 
 

<span>51 </span>      return true; 
 
<span>52 </span> 
 
<span>53 </span>    std::string OldMethodName = Method-&gt;getNameAsString(); 
 

<span>54 </span>    std::string NewMethodName = "test_" + OldMethodName; 
 

<span>55 </span>    clang::SourceManager &amp;SM = Context.getSourceManager(); 
 

<span>56 </span>    clang::tooling::Replacement Replace(SM, StartLoc, OldMethodName.length(), 
 

<span>57 </span>                                        NewMethodName); 
 

<span>58 </span>    Replaces.push_back(Replace); 
 

<span>59 </span>    llvm::outs() &lt;&lt; LogMessage &lt;&lt; ": " &lt;&lt; OldMethodName &lt;&lt; " to " 
 

<span>60 </span>                 &lt;&lt; NewMethodName &lt;&lt; "\n"; 
 

<span>61 </span>    return true; 
 
<span>62 </span>  }</pre>
<p class="hidden"><a id="x1-137040r4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-137041" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.4</strong>: Implementation of <span><code class="calibre13">processMethod</code> </span></p>
<p class="hidden"><em class="calibre11">Lines 46-51 </em>in <a href="#x1-137040r4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.4</a> contain the checks <a id="dx1-137042" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>for the required conditions. For instance, in <em class="calibre11">Lines 46-47</em>, we verify that the method is public. <em class="calibre11">Lines 48-49 </em>are used to exclude constructors from processing, and <em class="calibre11">Lines 50-51 </em>serve to exclude methods that already have the required prefix.</p>
<p class="hidden">The main replacement logic is implemented in <em class="calibre11">Lines 53-58</em>. Particularly, in <em class="calibre11">Lines</em> <em class="calibre11">56-57</em>, we create a special <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">tooling</code><code class="calibre13">::</code><code class="calibre13">Replacement</code></span> object, which serves as a wrapper for required code modifications. The object’s parameters are as follows:</p>
<ol class="calibre6">
<li class="calibre7"><div id="x1-137044x1" class="tableofcontents">
<p class="calibre15"><span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">SourceManager</code></span>: We obtain the source manager from <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ASTContext</code></span> at <em class="calibre11">Line 55</em>.</p>
</div></li>
<li class="calibre7"><div id="x1-137046x2" class="tableofcontents">
<p class="calibre15"><span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">SourceLocation</code></span>: The source location specifies the starting position for replacement. The position is passed as the second parameter of our <span><code class="calibre13">processMethod</code></span> method, as seen in <em class="calibre11">Line 45</em>.</p>
</div></li>
<li class="calibre7"><div id="x1-137048x3" class="tableofcontents">
<p class="calibre15"><span><code class="calibre13">unsigned</code></span>: The length of the replaced text.</p>
</div></li>
<li class="calibre7"><div id="x1-137050x4" class="tableofcontents">
<p class="calibre15"><span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">StringRef</code></span>: The replacement text, which we create at <em class="calibre11">Line</em> <em class="calibre11">54</em>.</p>
</div></li>
</ol>
<p class="hidden">We store the replacement in the <span><code class="calibre13">Replaces</code></span> object, a private <a id="dx1-137051" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>member of our Visitor class:</p>
<pre class="source-code"><span>40 </span>private: 
 
<span>41 </span>  clang::ASTContext &amp;Context; 
 

<span>42 </span>  std::vector&lt;clang::tooling::Replacement&gt; Replaces;</pre>
<p class="hidden">There is a special getter to access the object outside the Visitor class:</p>
<pre class="source-code"><span>36 </span>  const std::vector&lt;clang::tooling::Replacement&gt; &amp;getReplacements() { 
 

<span>37 </span>    return Replaces; 
 
<span>38 </span>  }</pre>
<p class="hidden">We log the action at <em class="calibre11">Lines 59-60</em>, using <span><code class="calibre13">LogMessage</code></span> as the prefix for the log message. Different log messages are used for different AST nodes; for instance, we use ”Renamed method” (see <a href="#x1-137017r3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.3</a>, <em class="calibre11">Line 19</em>) for <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">CXXRecordDecl</code></span>.</p>
<p class="hidden">The log message will be different for the method call. The corresponding processing is shown in the following figure.</p>
<pre class="source-code"><span>25 </span>  bool VisitCXXMemberCallExpr(clang::CXXMemberCallExpr *Call) { 
 

<span>26 </span>    if (clang::CXXMethodDecl *Method = Call-&gt;getMethodDecl()) { 
 

<span>27 </span>      clang::CXXRecordDecl *Class = Method-&gt;getParent(); 
 

<span>28 </span>      if (!Class-&gt;getName().starts_with("Test")) 
 

<span>29 </span>        return true; 
 
<span>30 </span>      clang::SourceLocation StartLoc = Call-&gt;getExprLoc(); 
 

<span>31 </span>      return processMethod(Method, StartLoc, "Renamed method call"); 
 

<span>32 </span>    } 
 
<span>33 </span>    return true; 
 
<span>34 </span>  }</pre>
<p class="hidden"><a id="x1-137071r5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-137072" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.5</strong>: CXXMemberCallExpr visitor implementation </p>
<p class="hidden">We verify that the class name, which <a id="dx1-137073" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>holds the test method, starts with the ’Test’ prefix at <em class="calibre11">Lines 27-29</em>. The replacement source location is obtained at <em class="calibre11">Line 30</em>. At <em class="calibre11">Line 31</em>, we call our <span><code class="calibre13">processMethod</code></span> function to process the found method, passing the ”Renamed method call” as the log message to the call.</p>
<p class="hidden">The <span><code class="calibre13">Visitor</code></span> is initialized in the <span><code class="calibre13">Consumer</code></span> class, which will be our next goal. <a id="x1-137074r411" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="consumer-class-implementation" class="level" data-number="2.3.2.4">
<h3 data-number="2.3.2.4" id="sigil_toc_id_120" class="likesectionhead"><span>7.2.4 </span> <a id="x1-1380004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Consumer class implementation</h3>
<p class="hidden">The <code class="calibre13">Consumer </code>class initializes the Visitor <a id="dx1-138001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and starts AST traversal in the <span><code class="calibre13">HandleTranslationUnit</code></span> method. The class can be written as follows:</p>
<pre class="source-code"><span>6 </span>class Consumer : public clang::ASTConsumer { 
 

<span>7 </span>public: 
 
<span>8 </span>  void HandleTranslationUnit(clang::ASTContext &amp;Context) override { 
 

<span>9 </span>    Visitor V(Context); 
 
<span>10 </span>    V.TraverseDecl(Context.getTranslationUnitDecl()); 
 

<span>11 </span> 
 
<span>12 </span>    // Apply the replacements. 
 

<span>13 </span>    clang::Rewriter Rewrite(Context.getSourceManager(), clang::LangOptions()); 
 

<span>14 </span>    auto &amp;Replaces = V.getReplacements(); 
 

<span>15 </span>    for (const auto &amp;Replace : Replaces) { 
 

<span>16 </span>      if (Replace.isApplicable()) { 
 

<span>17 </span>        Replace.apply(Rewrite); 
 
<span>18 </span>      } 
 

<span>19 </span>    } 
 
<span>20 </span> 
 
<span>21 </span>    // Apply the Rewriter changes. 
 

<span>22 </span>    if (Rewrite.overwriteChangedFiles()) { 
 

<span>23 </span>      llvm::errs() &lt;&lt; "Error: Cannot apply changes to the file\n"; 
 

<span>24 </span>    } 
 
<span>25 </span>  } 
 
<span>26 </span>}; 
 
<span>27 </span>} // namespace methodrename</pre>
<p class="hidden"><a id="x1-138025r6" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-138026" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.6</strong>: Consumer class implementation </p>
<p class="hidden">We initialize the Visitor and begin traversal at <em class="calibre11">Lines 9-10 </em>(see <a href="#x1-138025r6" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.6</a>). The Rewriter is created at <em class="calibre11">Line 13</em>, and replacements are applied at <em class="calibre11">Lines 14-19</em>. Finally, the result is stored in the original file at <em class="calibre11">Lines 22-24</em>.</p>
<p class="hidden">The Visitor and Consumer classes are wrapped within the <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">methodrename</code></span> namespace. The Consumer instance is created in the FrontendAction class. This class’s implementation mirrors <a id="dx1-138027" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>that of the <span><code class="calibre13">RecursiveVisitor</code></span> and <span><code class="calibre13">DeclVisitor</code></span>, as detailed in <a href="B19722_03.xhtml#x1-60077r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.8</a>. The only difference is the use of the <span><code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">methodrename</code></span> namespace for the new tool. <a id="x1-138028r420" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="build-configuration-and-main-function" class="level" data-number="2.3.2.5">
<h3 data-number="2.3.2.5" id="sigil_toc_id_121" class="likesectionhead"><span>7.2.5 </span> <a id="x1-1390005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Build configuration and main function</h3>
<p class="hidden">The <span><code class="calibre13">main</code></span> function for our <a id="dx1-139001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>tool is similar to the <a id="dx1-139002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>recursive visitor one defined in <a href="B19722_03.xhtml#x1-62057r21" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.21</a>:</p>
<pre class="source-code"><span>13 </span>int main(int argc, const char **argv) { 
 

<span>14 </span>  llvm::Expected&lt;clang::tooling::CommonOptionsParser&gt; OptionsParser = 
 

<span>15 </span>      clang::tooling::CommonOptionsParser::create(argc, argv, TestCategory); 
 

<span>16 </span>  if (!OptionsParser) { 
 
<span>17 </span>    llvm::errs() &lt;&lt; OptionsParser.takeError(); 
 

<span>18 </span>    return 1; 
 
<span>19 </span>  } 
 
<span>20 </span>  clang::tooling::ClangTool Tool(OptionsParser-&gt;getCompilations(), 
 

<span>21 </span>                                 OptionsParser-&gt;getSourcePathList()); 
 

<span>22 </span>  return Tool.run(clang::tooling::newFrontendActionFactory&lt; 
 

<span>23 </span>                      clangbook::methodrename::FrontendAction&gt;() 
 

<span>24 </span>                      .get()); 
 
<span>25 </span>}</pre>
<p class="hidden"><a id="x1-139017r7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-139018" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.7</strong>: The main function for the ’methodrename’ test tool </p>
<p class="hidden">As you can see, we changed <a id="dx1-139019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>only the namespace name <a id="dx1-139020" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>for our custom frontend action at <em class="calibre11">Line 23</em>.</p>
<p class="hidden">The build configuration is specified as follows:</p>
<pre class="source-code"><span>1 </span>cmake_minimum_required(VERSION 3.16) 
 

<span>2 </span>project("methodrename") 
 
<span>3 </span> 
 
<span>4 </span>if ( NOT DEFINED ENV{LLVM_HOME}) 
 

<span>5 </span>  message(FATAL_ERROR "$LLVM_HOME is not defined") 
 

<span>6 </span>else() 
 
<span>7 </span>  message(STATUS "$LLVM_HOME found: $ENV{LLVM_HOME}") 
 

<span>8 </span>  set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH "Root of LLVM installation") 
 

<span>9 </span>  set(LLVM_LIB ${LLVM_HOME}/lib) 
 

<span>10 </span>  set(LLVM_DIR ${LLVM_LIB}/cmake/llvm) 
 

<span>11 </span>  find_package(LLVM REQUIRED CONFIG) 
 

<span>12 </span>  include_directories(${LLVM_INCLUDE_DIRS}) 
 

<span>13 </span>  link_directories(${LLVM_LIBRARY_DIRS}) 
 

<span>14 </span>  set(SOURCE_FILE MethodRename.cpp) 
 

<span>15 </span>  add_executable(methodrename ${SOURCE_FILE}) 
 

<span>16 </span>  set_target_properties(methodrename PROPERTIES COMPILE_FLAGS "-fno-rtti") 
 

<span>17 </span>  target_link_libraries(methodrename 
 

<span>18 </span>    LLVMSupport 
 
<span>19 </span>    clangAST 
 
<span>20 </span>    clangBasic 
 

<span>21 </span>    clangFrontend 
 
<span>22 </span>    clangSerialization 
 

<span>23 </span>    clangToolingCore 
 
<span>24 </span>    clangRewrite 
 

<span>25 </span>    clangTooling 
 
<span>26 </span>  ) 
 
<span>27 </span>endif()</pre>
<p class="hidden"><a id="x1-139049r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-139050" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.8</strong>: Build configuration for ’methodrename’ test tool </p>
<p class="hidden">The most <a id="dx1-139051" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>notable changes, compared to <a id="dx1-139052" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the code from <a href="B19722_03.xhtml#x1-62028r20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.20</a>, are at <em class="calibre11">Lines</em> <em class="calibre11">23 and 24</em>, where we added two new libraries to support code modifications: <code class="calibre13">clangToolingCore </code>and <code class="calibre13">clangRewrite </code>. Other changes include the new name for the tool (<em class="calibre11">Line 2</em>) and the source file that contains the main function (<em class="calibre11">Line</em> <em class="calibre11">14</em>).</p>
<p class="hidden">As soon as we finish with the code, it’s time to build and run our tool. <a id="x1-139053r423" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="running-the-code-modification-tool" class="level" data-number="2.3.2.6">
<h3 data-number="2.3.2.6" id="sigil_toc_id_122" class="likesectionhead"><span>7.2.6 </span> <a id="x1-1400006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Running the code modification tool</h3>
<p class="hidden">The program can be compiled <a id="dx1-140001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>using the same sequence of commands as we used previously in <a href="B19722_03.xhtml#x1-590003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 3.3</em></a><em class="calibre11">, AST traversal</em>, see <a href="B19722_03.xhtml#x1-60132r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 3.11</a>:</p>
<pre id="verbatim-98" class="console">export LLVM_HOME=&lt;...&gt;/llvm-project/install
mkdir build
cd build
cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug ...
ninja</pre>
<p class="hidden"><a id="x1-140002r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-140003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.9</strong>: Configure and build commands for ’methodrename’ tool </p>
<p class="hidden">We can run the create tool on the following test file (<code class="calibre13">TestClass.cpp </code>):</p>
<pre class="source-code"><span>1 </span>class TestClass { 
 
<span>2 </span>public: 
 
<span>3 </span>  TestClass(){}; 
 

<span>4 </span>  void pos(){}; 
 
<span>5 </span>}; 
 
<span>6 </span> 
 
<span>7 </span>int main() { 
 

<span>8 </span>  TestClass test; 
 
<span>9 </span>  test.pos(); 
 
<span>10 </span>  return 0; 
 
<span>11 </span>}</pre>
<p class="hidden"><a id="x1-140016r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-140017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.10</strong>: Original TestClass.cpp </p>
<p class="hidden">We can run the tool as follows:</p>
<pre id="verbatim-99" class="console">$ ./methodrename TestClass.cpp -- -std=c++17
Renamed method: pos to test_pos
Renamed method call: pos to test_pos</pre>
<p class="hidden"><a id="x1-140018r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-140019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.11</strong>: Running methodrename Clang Tool on TestClass.cpp </p>
<p class="hidden">As we can see, the method <span><code class="calibre13">TestClass</code><code class="calibre13">::</code><code class="calibre13">pos</code></span> was renamed to <span><code class="calibre13">TestClass</code><code class="calibre13">::</code><code class="calibre13">test_pos</code></span>. The method call <a id="dx1-140020" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>was also updated, as shown in the following figure:</p>
<pre class="source-code"><span>1 </span>class TestClass { 
 
<span>2 </span>public: 
 
<span>3 </span>  TestClass(){}; 
 

<span>4 </span>  void test_pos(){}; 
 
<span>5 </span>}; 
 
<span>6 </span> 
 
<span>7 </span>int main() { 
 

<span>8 </span>  TestClass test; 
 
<span>9 </span>  test.test_pos(); 
 
<span>10 </span>  return 0; 
 
<span>11 </span>}</pre>
<p class="hidden"><a id="x1-140033r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-140034" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.12</strong>: Modified TestClass.cpp </p>
<p class="hidden">The provided example demonstrates how Clang can assist in creating refactoring tools. The created Clang Tool uses a recursive visitor to set up the required code transformation. Another possible option is to use Clang-Tidy, which we investigated earlier in <a href="B19722_05.xhtml#x1-990005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Chapter</em><em class="calibre11"> 5</em></a><em class="calibre11">, Clang-Tidy Linter Framework</em>. Let’s examine this option in more detail. <a id="x1-140035r404" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
</section>
<section id="clang-tidy-as-a-code-modification-tool" class="level" data-number="2.3.3">
<h2 data-number="2.3.3" id="sigil_toc_id_123" class="likechapterhead"><span>7.3 </span> <a id="x1-1410003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang-Tidy as a code modification tool</h2>
<p class="hidden">We plan to investigate <span><code class="calibre13">FixItHint</code></span>, which is a <a id="dx1-141001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>part of the Clang Diagnostics subsystem (see <a href="B19722_04.xhtml#x1-800002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 4.4.2</em></a><em class="calibre11">, Diagnostics support</em>). <span><code class="calibre13">FixItHint</code></span> can be integrated with <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Rewriter</code></span> and <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">tooling</code><code class="calibre13">::</code><code class="calibre13">Replacement</code></span> explored previously, providing advanced diagnostics that are used in powerful tools such as Clang-Tidy. <a id="x1-141002r428" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<section id="fixithint" class="level" data-number="2.3.3.1">
<h3 data-number="2.3.3.1" id="sigil_toc_id_124" class="likesectionhead"><span>7.3.1 </span> <a id="x1-1420001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>FixItHint</h3>
<p class="hidden"><span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">FixItHint</code></span> is a class in the Clang compiler that significantly enhances its diagnostic capabilities. Its primary role is to <a id="dx1-142001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>provide automated suggestions for correcting code errors or issues that the compiler detects. These suggestions, known as ”fix-its,” are a part of Clang’s diagnostic messages and are intended to guide developers in resolving identified issues in their code.</p>
<p class="hidden">When Clang encounters a coding error, warning, or stylistic issue, it generates a <span><code class="calibre13">FixItHint</code></span>. This hint contains specific recommendations for changes in the source code. For instance, it may suggest replacing a snippet of text with a corrected version or inserting or removing code at a particular location.</p>
<p class="hidden">For example, consider the following source code:</p>
<pre class="source-code"><span>1 </span>void foo() { 
 
<span>2 </span>  constexpr int a = 0; 
 

<span>3 </span>  constexpr const int *b = &amp;a; 
 
<span>4 </span>}
                                                                     

                                                                     </pre>
<p class="hidden"><a id="x1-142007r13" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-142008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.13</strong>: Test file foo.cpp </p>
<p class="hidden">If we run a compilation for the file, we will get the following error:</p>
<pre id="verbatim-100" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang -cc1 -emit-obj foo.cpp -o /tmp/foo.o
foo.cpp:3:24: error: constexpr variable ’b’ must be initialized by a
constant expression
    3 |   constexpr const int *b = &amp;a;
      |                        ^   ~~
foo.cpp:3:24: note: pointer to ’a’ is not a constant expression
foo.cpp:2:17: note: address of non-static constexpr variable ’a’ may differ
on each invocation of the enclosing function; add ’static’ to give it a
constant address
    2 |   constexpr int a = 0;
      |                 ^
      |   static
<span>1 </span> error generated.</pre>
<p class="hidden"><a id="x1-142009r14" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-142010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.14</strong>: Compilation error generated in foo.cpp </p>
<p class="hidden">As you can see, the compiler suggests adding the <span><code class="calibre13">static</code></span> keyword at <em class="calibre11">Line 2 </em>for the program shown in <a href="#x1-142007r13" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.13</a>.</p>
<p class="hidden">The error is processed by Clang using <a id="dx1-142011" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the FixItHint object, as shown in <a href="#x1-142022r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.15</a>. As seen in <a href="#x1-142022r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.15</a>, when Clang detects an issue in the source code and generates a diagnostic, it can also produce a <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">FixItHint</code></span> that suggests how to fix the issue. The hint is later processed by the Clang diagnostics subsystem and displayed to the user.</p>
<p class="hidden">It’s important to highlight that the hint can also be converted into a <span><code class="calibre13">Replacement</code></span> object, which represents the exact text change needed. For example, Clang-Tidy uses the <code class="calibre13">Replacement </code>object as temporary storage for information from <span><code class="calibre13">FixItHint</code></span> in its <code class="calibre13">DiagnosticConsumer </code>class implementation, allowing the FixItHint to be converted into a <code class="calibre13">Replacement </code>object that represents the exact text change needed.</p>
<pre class="source-code">      if (VarD &amp;&amp; VarD-&gt;isConstexpr()) { 
 

        // Non-static local constexpr variables have unintuitive semantics: 
 

        //   constexpr int a = 1; 
 

        //   constexpr const int *p = &amp;a; 
 

        // ... is invalid because the address of ’a’ is not constant. Suggest 
 

        // adding a ’static’ in this case. 
 

        Info.Note(VarD-&gt;getLocation(), diag::note_constexpr_not_static) 
 

            &lt;&lt; VarD 
 
            &lt;&lt; FixItHint::CreateInsertion(VarD-&gt;getBeginLoc(), "static ");</pre>
<p class="hidden"><a id="x1-142022r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-142023" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.15</strong>: Code fragment from clang/lib/AST/ExprConstant.cpp </p>
<p class="hidden">Overall, <code class="calibre13">clang::FixItHint </code>enhances the user-friendliness and utility of Clang, providing developers with practical tools <a id="dx1-142024" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>for improving code quality and resolving issues efficiently. Its integration into Clang’s diagnostic system exemplifies the compiler’s emphasis on not only pinpointing code issues but also aiding in their resolution. We are going to utilize this feature in a Clang-Tidy check that will rename methods in a test class and convert the code shown in <a href="#x1-140016r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.10</a> to that in <a href="#x1-140033r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.12</a>. <a id="x1-142025r436" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="creating-project-skeleton" class="level" data-number="2.3.3.2">
<h3 data-number="2.3.3.2" id="sigil_toc_id_125" class="likesectionhead"><span>7.3.2 </span> <a id="x1-1430002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Creating project skeleton</h3>
<p class="hidden">Let’s create the project skeleton for our Clang-Tidy check. We will name our check ”methodrename” and it will be a <a id="dx1-143001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>part of ”misc” set of Clang-Tidy checks. We will use the command from <a href="B19722_05.xhtml#x1-1100001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Section 5.4.1</a></p>
<pre id="verbatim-101" class="console">$ ./clang-tools-extra/clang-tidy/add_new_check.py misc methodrename</pre>
<p class="hidden"><a id="x1-143002r16" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-143003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.16</strong>: Creating a skeleton for the misc-methodrename check </p>
<p class="hidden">The command from <a href="#x1-143002r16" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.16</a> should be run from the root of the cloned LLVM project. We specified two parameters for the <code class="calibre13">add</code><code class="calibre13">_new</code><code class="calibre13">_check.py </code>script: <code class="calibre13">misc </code>– the set of checks that will contain our new check, and <code class="calibre13">methodrename </code>– the name of our check.</p>
<p class="hidden">The command will produce the following output:</p>
<pre id="verbatim-102" class="console">Updating ./clang-tools-extra/clang-tidy/misc/CMakeLists.txt...
Creating ./clang-tools-extra/clang-tidy/misc/MethodrenameCheck.h...
Creating ./clang-tools-extra/clang-tidy/misc/MethodrenameCheck.cpp...
Updating ./clang-tools-extra/clang-tidy/misc/MiscTidyModule.cpp...
Updating clang-tools-extra/docs/ReleaseNotes.rst...
Creating clang-tools-extra/test/clang-tidy/checkers/misc/methodrename.cpp...
Creating clang-tools-extra/docs/clang-tidy/checks/misc/methodrename.rst...
Updating clang-tools-extra/docs/clang-tidy/checks/list.rst...
Done. Now it’s your turn!</pre>
<p class="hidden"><a id="x1-143004r17" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-143005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.17</strong>: Artefacts created for misc-methodrename check </p>
<p class="hidden">We have to modify at least <a id="dx1-143006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>two generated files in the <code class="calibre13">./clang-tools-extra/clang-tidy</code> <code class="calibre13">/misc </code>folder:</p>
<ol class="calibre6">
<li class="calibre7"><div id="x1-143008x1" class="tableofcontents">
<p class="calibre15"><code class="calibre13">MethodrenameCheck.h </code>: This is the header file for our check. Here, we want to add an additional private method <span><code class="calibre13">processMethod</code></span> for checking the method’s properties and displaying diagnostics.</p>
</div></li>
<li class="calibre7"><div id="x1-143010x2" class="tableofcontents">
<p class="calibre15"><code class="calibre13">MethodrenameCheck.cpp </code>: This file contains the processing logic, and we need to implement three methods: <span><code class="calibre13">registerMatchers</code></span>, <span><code class="calibre13">check</code></span>, and the newly added private method <span><code class="calibre13">processMethod</code></span>.</p>
</div></li>
</ol>
<p class="hidden"><a id="x1-143011r442" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="check-implementation-1" class="level" data-number="2.3.3.3">
<h3 data-number="2.3.3.3" id="sigil_toc_id_126" class="likesectionhead"><span>7.3.3 </span> <a id="x1-1440003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Check implementation</h3>
<p class="hidden">We will start with modifications to the header file:</p>
<pre class="source-code"><span>27 </span>private: 
 
<span>28 </span>  void processMethod(const clang::CXXMethodDecl *Method, 
 

<span>29 </span>                     clang::SourceLocation StartLoc, const char *LogMessage); 
 

<span>30 </span>};</pre>
<p class="hidden"><a id="x1-144006r18" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-144007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.18</strong>: MethodrenameCheck.h modifications </p>
<p class="hidden">The added private method <span><code class="calibre13">MethodrenameCheck</code><code class="calibre13">::</code><code class="calibre13">processMethod</code></span> has the same parameters as the method introduced <a id="dx1-144008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>earlier in our Clang Tool ’methodrename’, as seen in <a href="#x1-137040r4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.4</a>.</p>
<p class="hidden">We start the implementation with the <span><code class="calibre13">MethodrenameCheck</code><code class="calibre13">::</code><code class="calibre13">registerMatchers</code></span> method of our check as follows:</p>
<pre class="source-code"><span>26 </span>void MethodrenameCheck::registerMatchers(MatchFinder *Finder) { 
 

<span>27 </span>  auto ClassMatcher = hasAncestor(cxxRecordDecl(matchesName("::Test.*$"))); 
 

<span>28 </span>  auto MethodMatcher = cxxMethodDecl(isNotTestMethod(), ClassMatcher); 
 

<span>29 </span>  auto CallMatcher = cxxMemberCallExpr(callee(MethodMatcher)); 
 




<span>30 </span>  Finder-&gt;addMatcher(MethodMatcher.bind("method"), this); 
 

<span>31 </span>  Finder-&gt;addMatcher(CallMatcher.bind("call"), this); 
 

<span>32 </span>}</pre>
<p class="hidden"><a id="x1-144017r19" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-144018" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.19</strong>: Implementation of registerMatchers </p>
<p class="hidden"><em class="calibre11">Lines 30 and 31 </em>register two matchers. The first one is for method declarations (bound to the ”method” identifier), and the second one is for method calls (bound to the ”call” identifier).</p>
<p class="hidden">Here, we use a <strong class="calibre12">Domain Specific Language (DSL) </strong>defined in <a href="B19722_03.xhtml#x1-630005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 3.5</em></a><em class="calibre11">,</em> <em class="calibre11">AST matchers</em>. The <span><code class="calibre13">ClassMatcher</code></span> specifies that <a id="dx1-144019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>our method declaration has to be declared within a class with a name starting with the ”Test” prefix.</p>
<p class="hidden">The method declaration matcher (<span><code class="calibre13">MethodMatcher</code></span>) is defined at <em class="calibre11">Line 28</em>. It must be declared within the class specified by <span><code class="calibre13">ClassMatcher</code></span> and should be a test method (details about the <span><code class="calibre13">isNotTestMethod</code></span> matcher will be described below).</p>
<p class="hidden">The last matcher, <span><code class="calibre13">CallMatcher</code></span>, is defined at <em class="calibre11">Line 29 </em>and specifies that it must be a call to a method that satisfies the conditions of <span><code class="calibre13">MethodMatcher</code></span>.</p>
<p class="hidden">The <span><code class="calibre13">isNotTestMethod</code></span> matcher is an ad-hoc matcher that is used to check our specific conditions. We can define our <a id="dx1-144020" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>own matchers using <span><code class="calibre13">AST_MATCHER</code></span> and related macros. The implementation for it can be found here:</p>
<pre class="source-code">                                                                     

                                                                     
<span>18 </span>AST_MATCHER(CXXMethodDecl, isNotTestMethod) { 
 

<span>19 </span>  if (Node.getAccess() != clang::AS_public) return false; 
 

<span>20 </span>  if (llvm::isa&lt;clang::CXXConstructorDecl&gt;(&amp;Node)) return false; 
 

<span>21 </span>  if (!Node.getIdentifier() || Node.getName().startswith("test_")) return false; 
 

<span>22 </span> 
 
<span>23 </span>  return true; 
 
<span>24 </span>}</pre>
<p class="hidden"><a id="x1-144029r20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-144030" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.20</strong>: isNotTestMethod matcher implementation </p>
<p class="hidden">The macro has two parameters. The first one specifies the AST node we want to check, which is <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">CXXMethodDecl</code></span> in our case. The second parameter is the matcher name that we want to use for the user-defined matcher, which is <span><code class="calibre13">isNotTestMethod</code></span> in our case.</p>
<p class="hidden">The AST node can be accessed as a <span><code class="calibre13">Node</code></span> variable at the macro body. The macro should return <span><code class="calibre13">true</code></span> if the Node matches the required conditions. We use the same conditions we used for our ’methodrename’ Clang Tool in <a href="#x1-137040r4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.4</a> (<em class="calibre11">Lines</em> <em class="calibre11">46-51</em>).</p>
<p class="hidden">The <span><code class="calibre13">MethodrenameCheck</code><code class="calibre13">::</code><code class="calibre13">check</code></span> is the main <a id="dx1-144031" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>method for our check and can be implemented as follows:</p>
<pre class="source-code"><span>34 </span>void MethodrenameCheck::check(const MatchFinder::MatchResult &amp;Result) { 
 

<span>35 </span>  if (const auto *Method = Result.Nodes.getNodeAs&lt;CXXMethodDecl&gt;("method")) { 
 

<span>36 </span>    processMethod(Method, Method-&gt;getLocation(), "Method"); 
 

<span>37 </span>  } 
 
<span>38 </span> 
 
<span>39 </span>  if (const auto *Call = Result.Nodes.getNodeAs&lt;CXXMemberCallExpr&gt;("call")) { 
 

<span>40 </span>    if (CXXMethodDecl *Method = Call-&gt;getMethodDecl()) { 
 

<span>41 </span>      processMethod(Method, Call-&gt;getExprLoc(), "Method call"); 
 

<span>42 </span>    } 
 
<span>43 </span>  } 
 
<span>44 </span>}</pre>
<p class="hidden"><a id="x1-144044r21" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-144045" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.21</strong>: check implementation </p>
<p class="hidden">The code has two blocks. The first one (<em class="calibre11">Lines 35-37</em>) processes method declarations, and the last one (<em class="calibre11">Lines 39-42</em>) processes method calls. Both call <span><code class="calibre13">MethodrenameCheck</code></span> <span><code class="calibre13">::</code><code class="calibre13">processMethod</code></span> to display diagnostics and create the required code modifications.</p>
<p class="hidden">Let’s examine how it’s implemented and how <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">FixItHint</code></span> is used.</p>
<pre class="source-code"><span>46 </span>void MethodrenameCheck::processMethod(const clang::CXXMethodDecl *Method, 
 

<span>47 </span>                                      clang::SourceLocation StartLoc, 
 

<span>48 </span>                                      const char *LogMessage) { 
 

<span>49 </span>  diag(StartLoc, "%0 %1 does not have ’test_’ prefix") &lt;&lt; LogMessage &lt;&lt; Method; 
 

<span>50 </span>  diag(StartLoc, "insert ’test_’", DiagnosticIDs::Note) 
 

<span>51 </span>      &lt;&lt; FixItHint::CreateInsertion(StartLoc, "test_"); 
 

<span>52 </span>}</pre>
<p class="hidden"><a id="x1-144054r22" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-144055" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.22</strong>: processMethod implementation </p>
<p class="hidden">We print diagnostics about the <a id="dx1-144056" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>detected issue at <em class="calibre11">Line 49</em>. <em class="calibre11">Lines 50-51 </em>print an informational message about the suggested code modifications and create the corresponding code replacement at <em class="calibre11">Line 51</em>. To insert text, we use <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">FixItHint</code><code class="calibre13">::</code><code class="calibre13">CreateInsertion</code></span>. We also display the insertion as a note for our primary warning.</p>
<p class="hidden">As soon as all the required changes are applied to the generated skeleton, it’s time to build and run our check on a test file. <a id="x1-144057r445" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="build-and-run-the-check" class="level" data-number="2.3.3.4">
<h3 data-number="2.3.3.4" id="sigil_toc_id_127" class="likesectionhead"><span>7.3.4 </span> <a id="x1-1450004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Build and run the check</h3>
<p class="hidden">We assume that build configuration from <a href="B19722_01.xhtml#x1-30003r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.12</a> was used. Thus, we have to run the following <a id="dx1-145001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>command to build our check:</p>
<pre id="verbatim-103" class="console">$ ninja clang-tidy</pre>
<p class="hidden">We can <a id="dx1-145002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>install it to the <code class="calibre13">install </code>folder with:</p>
<pre id="verbatim-104" class="console">$ ninja install</pre>
<p class="hidden">We can run our check as follows on the <span><code class="calibre13">TestClass</code></span> from <a href="#x1-140016r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.10</a>:</p>
<pre id="verbatim-105" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang-tidy \
             -checks=’-*,misc-methodrename’ \
             ./TestClass.cpp              \
             -- -std=c++17</pre>
<p class="hidden"><a id="x1-145003r23" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-145004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.23</strong>: Clang-Tidy misc-methodrename check run on the test file TestClass.cpp </p>
<p class="hidden">The command <a id="dx1-145005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>will produce the <a id="dx1-145006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>following output:</p>
<pre id="verbatim-106" class="console">TestClass.cpp:4:8: warning: Method ’pos’ does not have ’test_’ prefix
[misc-methodrename]
  void pos(){};
       ^
TestClass.cpp:4:8: note: insert ’test_’
  void pos(){};
       ^
       test_
TestClass.cpp:9:8: warning: Method call ’pos’ does not have ’test_’ prefix
[misc-methodrename]
  test.pos();
       ^
TestClass.cpp:9:8: note: insert ’test_’
  test.pos();
       ^
       test_</pre>
<p class="hidden"><a id="x1-145007r24" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-145008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.24</strong>: Warning generated for TestClass.cpp by misc-methodrename check </p>
<p class="hidden">As we can see, the check correctly detected two places where the method name has to be changed and created replacements. The command from <a href="#x1-145003r23" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.23</a> does not modify the original source file. We <a id="dx1-145009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>have to specify an additional argument <code class="calibre13">-fix-notes </code>to apply the insertions specified as notes to <a id="dx1-145010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the original warnings. The required command will look like this:</p>
<pre id="verbatim-107" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang-tidy \
             -fix-notes                   \
             -checks=’-*,misc-methodrename’ \
             ./TestClass.cpp              \
             -- -std=c++17</pre>
<p class="hidden"><a id="x1-145011r25" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-145012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.25</strong>: Clang-Tidy with -fix-notes option </p>
<p class="hidden">The command output is as follows:</p>
<pre id="verbatim-108" class="console">2 warnings generated.
TestClass.cpp:4:8: warning: Method ’pos’ does not have ’test_’ prefix
[misc-methodrename]
  void pos(){};
       ^
TestClassSmall.cpp:4:8: note: FIX-IT applied suggested code changes
TestClass.cpp:4:8: note: insert ’test_’
  void pos(){};
       ^
       test_
TestClass.cpp:9:8: warning: Method call ’pos’ does not have ’test_’ prefix
[misc-methodrename]
  test.pos();
       ^
TestClass.cpp:9:8: note: FIX-IT applied suggested code changes
TestClass.cpp:9:8: note: insert ’test_’</pre>
<pre id="verbatim-109" class="console">  test.pos();
       ^
       test_
clang-tidy applied 2 of 2 suggested fixes.</pre>
<p class="hidden"><a id="x1-145013r26" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-145014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.26</strong>: Clang-Tidy fixes applied to the TestClass.cpp </p>
<p class="hidden">As we can see, the required <a id="dx1-145015" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>insertions were applied here. Clang-Tidy has powerful tools to control the applied fixes and can be considered a <a id="dx1-145016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>significant resource for code modification. Another popular tool used for code modification is Clang-Format. As the name suggests, this tool specializes in code formatting. Let’s explore it in detail. <a id="x1-145017r435" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
</section>
<section id="code-modification-and-clang-format" class="level" data-number="2.3.4">
<h2 data-number="2.3.4" id="sigil_toc_id_128" class="likechapterhead"><span>7.4 </span> <a id="x1-1460004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Code modification and Clang-Format</h2>
<p class="hidden">Clang-Format is an essential tool in the Clang/LLVM project, designed for formatting C, C++, Java, JavaScript, Objective-C, or Protobuf code. It plays a crucial role in the Clang tooling ecosystem, offering <a id="dx1-146001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>capabilities for parsing, analyzing, and manipulating source code.</p>
<p class="hidden">Clang-Format is a part of Clang and has to be installed if we have built and installed the Clang compiler. Let’s look at how it can be used. <a id="x1-146002r456" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<section id="clang-format-configuration-and-usage-examples" class="level" data-number="2.3.4.1">
<h3 data-number="2.3.4.1" id="sigil_toc_id_129" class="likesectionhead"><span>7.4.1 </span> <a id="x1-1470001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang-Format configuration and usage examples</h3>
<p class="hidden">Clang-Format uses <code class="calibre13">.clang-format </code>configuration files. The utility will use the closest configuration file; i.e., if the file is located at the folder with the source files we want to format, then the configuration <a id="dx1-147001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>from the folder will be used. The format for configuration files is YAML, which is the same format <a id="dx1-147002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>used for Clang-Tidy configuration files, as shown in <a href="B19722_05.xhtml#x1-1080002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Figure</em><em class="calibre11"> 5.12</em></a><em class="calibre11">,</em> <em class="calibre11">Clang-Tidy configuration</em>. Let’s create the following simple configuration file:</p>
<pre class="source-code"><span>1 </span>BasedOnStyle: LLVM</pre>
<p class="hidden"><a id="x1-147005r27" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-147006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.27</strong>: Simple .clang-format configuration file </p>
<p class="hidden">The configuration file says that we will use the code style defined by LLVM, see <a href="https://llvm.org/docs/CodingStandards.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://llvm.org/docs/CodingStandards.html</a>.</p>
<p class="hidden">Suppose we have a non-formatted file <code class="calibre13">main.cpp </code>, then the following command will format it:</p>
<pre id="verbatim-110" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang-format -i main.cpp</pre>
<p class="hidden">The <a id="dx1-147007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>result of the formatting is <a id="dx1-147008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>shown here:</p>
<div class="tableofcontents">
<pre class="source-code"><span>1 </span>namespace clang { 
 

<span>2 </span>class TestClang { 
 

<span>3 </span>public: 
 

<span>4 </span>void testClang(){}; 
 

<span>5 </span>}; 
 
<span>6 </span>}int main() { 
 

<span>7 </span>TestClang test; 
 

<span>8 </span>test.testClang(); 
 

<span>9 </span>return 0; 
 
<span>10 </span>}</pre>
<p class="hidden"><strong class="calibre12"/>Original code </p>
</div>
<div class="tableofcontents">
<pre class="source-code"><span>1 </span>namespace clang { 
 

<span>2 </span>class TestClang { 
 

<span>3 </span>public: 
 

<span>4 </span>  void testClang(){}; 
 

<span>5 </span>}; 
 

<span>6 </span>} // namespace clang 
 

<span>7 </span>int main() { 
 

<span>8 </span>  TestClang test; 
 

<span>9 </span>  test.testClang(); 
 

<span>10 </span>  return 0; 
 
<span>11 </span>}</pre>
<p class="hidden"><strong class="calibre12"/>Formatted code </p>
</div>
<p class="hidden"><a id="x1-147032r28" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-147033" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.28</strong>: Formatting for main.cpp </p>
<p class="hidden">In the example provided in <a href="#x1-147032r28" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.28</a>, we can see that the indentation defined by the LLVM code style was applied. We can also observe that Clang-Format broke <em class="calibre11">Line 6 </em>in the original source code and made the main function definition start on a separate line. Additionally, we can see that Clang-Format added a comment to the namespace closing bracket in the formatted code at <em class="calibre11">Line</em> <em class="calibre11">6</em>.</p>
<p class="hidden">After considering the usage example, it’s time to look at the internal design of Clang-Format. <a id="x1-147034r462" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="design-considerations" class="level" data-number="2.3.4.2">
<h3 data-number="2.3.4.2" id="sigil_toc_id_130" class="likesectionhead"><span>7.4.2 </span> <a id="x1-1480002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Design considerations</h3>
<p class="hidden">At the core of Clang-Format is the Clang Lexer (see <a href="B19722_02.xhtml#x1-380002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Figure</em><em class="calibre11"> 2.5</em></a><em class="calibre11">, Lexer</em>), which tokenizes the input source code, breaking it <a id="dx1-148001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>down into individual tokens like keywords, identifiers, and literals. These tokens serve as the basis for formatting decisions.</p>
<p class="hidden">The initial Clang-Format design document considered the Parser and AST as basic components for formatting. Despite the advantages provided by advanced data structures such as the AST, this approach has some disadvantages:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">The Parser requires a full build process and, therefore, build configuration.</p></li>
<li class="calibre14"><p class="calibre15">The Parser has limited capabilities to process a part of the source text, which is a typical task for formatting, such as formatting a single function or a source range of the source file.</p></li>
<li class="calibre14"><p class="calibre15">Formatting macros is a challenging task when using the AST as the basic structure for formatting. For instance, the processed macro may not be called in the compiled code and, as a result, may be missed in the AST.</p></li>
<li class="calibre14"><p class="calibre15">The Parser is much slower than the Lexer.</p></li>
</ul>
<p class="hidden">Clang-Format leverages <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">tooling</code><code class="calibre13">::</code><code class="calibre13">Replacement</code></span> to represent code formatting changes and utilizes <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Rewriter</code></span> to apply these changes to the source code.</p>
<p class="hidden">Configuration plays a pivotal role in Clang-Format’s operation. Users define their preferred formatting style by configuring rules in a <code class="calibre13">.clang-format </code>file. This configuration specifies details such as indentation width, brace placement, line breaks, and more.</p>
<p class="hidden">Clang-Format supports various predefined and customizable formatting styles, such as ”LLVM,” ”Google,” and ”Chromium.” Users can select a style that aligns with their project’s coding standards.</p>
<p class="hidden">Once tokenized, Clang-Format processes the token stream, taking into account the current context, indentation level, and configured style rules. It then adjusts whitespace and line breaks accordingly to adhere to the chosen style.</p>
<p class="hidden">One notable feature of Clang-Format is its ability to handle macros effectively, preserving the original formatting within macros and complex macros.</p>
<p class="hidden">Customization is a key aspect of Clang-Format. Users can extend or customize its behavior by defining custom rules and formatting options in the configuration file. This flexibility allows teams to enforce specific coding standards or adapt Clang-Format to project-specific needs.</p>
<p class="hidden">It offers a user-friendly command-line interface, enabling manual code formatting or integration into scripts and automation.</p>
<p class="hidden">Clang-Format utilizes Clang’s Format <a id="dx1-148002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>library to generate formatted code accurately. This library ensures that the code consistently follows the desired formatting style. The design follows the main paradigm of LLVM: ”everything is a library,” as discussed in <a href="B19722_01.xhtml#x1-200001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 1.2.1</em></a><em class="calibre11">, Short LLVM history</em>. Thus, we can effectively use the formatting functionality in other Clang Tools. For instance, formatting can be used with Clang-Tidy to format code with fixes applied by Clang-Tidy. Let’s consider an example of how this functionality can be used. <a id="x1-148003r468" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="clang-tidy-and-clang-format" class="level" data-number="2.3.4.3">
<h3 data-number="2.3.4.3" id="sigil_toc_id_131" class="likesectionhead"><span>7.4.3 </span> <a id="x1-1490003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang-Tidy and Clang-Format</h3>
<p class="hidden">The applied Clang-Tidy fixes can break formatting. Clang-Tidy suggests using the <code class="calibre13">-format-style </code>option to <a id="dx1-149001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>address the problem. This option will apply formatting using the functionality provided by the clangFormat library. The formatting is applied to the modified lines of code. Consider an example when our TestClass has broken formatting.</p>
<p class="hidden">If we run Clang-Tidy as we did before (see <a href="#x1-145011r25" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.25</a>), then the formatting will remain unchanged and broken:</p>
<div class="tableofcontents">
<pre class="source-code"><span>1 </span>class TestClass { 
 

<span>2 </span>public: 
 

<span>3 </span>  TestClass(){}; 
 

<span>4 </span>void pos(){}; 
 
<span>5 </span>}; 
 
<span>6 </span> 
 

<span>7 </span>int main() { 
 

<span>8 </span>  TestClass test; 
 

<span>9 </span>test.pos(); 
 

<span>10 </span>  return 0; 
 
<span>11 </span>}</pre>
<p class="hidden"><strong class="calibre12"/>Original code </p>
</div>
<div class="tableofcontents">
<pre class="source-code"><span>1 </span>class TestClass { 
 

<span>2 </span>public: 
 

<span>3 </span>  TestClass(){}; 
 

<span>4 </span>void test_pos(){}; 
 
<span>5 </span>}; 
 

<span>6 </span> 
 
<span>7 </span>int main() { 
 

<span>8 </span>  TestClass test; 
 

<span>9 </span>test.test_pos(); 
 

<span>10 </span>  return 0; 
 
<span>11 </span>}</pre>
<p class="hidden"><strong class="calibre12"/>Applied fixes </p>
</div>
<p class="hidden"><a id="x1-149026r29" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-149027" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.29</strong>: Applying Clang-Tidy fixes without formatting on TestClassNotFormated.cpp </p>
<p class="hidden">We used the <a id="dx1-149028" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>following command for <a href="#x1-149026r29" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 7.29</a></p>
<pre id="verbatim-111" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang-tidy\
  -fix-notes                               \
  -checks=’-*,misc-methodrename’           \
  ./TestClassNotFormated.cpp               \
  -- -std=c++17</pre>
<p class="hidden">The result will be different if we run Clang-Tidy with <code class="calibre13">-format-style </code>option, for example:</p>
<pre id="verbatim-112" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang-tidy\
  -format-style ’llvm’                     \
  -fix-notes                               \
  -checks=’-*,misc-methodrename’           \
  ./TestClassNotFormated.cpp               \
  -- -std=c++17</pre>
<p class="hidden">As we can see the ’llvm’ formatting style was chosen for the example. The result is shown in the following figure:</p>
<div class="tableofcontents">
<pre class="source-code"><span>1 </span>class TestClass { 
 

<span>2 </span>public: 
 

<span>3 </span>  TestClass(){}; 
 

<span>4 </span>void pos(){}; 
 
<span>5 </span>}; 
 
<span>6 </span> 
 

<span>7 </span>int main() { 
 

<span>8 </span>  TestClass test; 
 

<span>9 </span>test.pos(); 
 

<span>10 </span>  return 0; 
 
<span>11 </span>}</pre>
<p class="hidden"><strong class="calibre12"/>Original code </p>
</div>
<div class="tableofcontents">
<pre class="source-code"><span>1 </span>class TestClass { 
 

<span>2 </span>public: 
 

<span>3 </span>  TestClass(){}; 
 

<span>4 </span>  void test_pos(){}; 
 

<span>5 </span>}; 
 
<span>6 </span> 
 
<span>7 </span>int main() { 
 

<span>8 </span>  TestClass test; 
 

<span>9 </span>  test.test_pos(); 
 

<span>10 </span>  return 0; 
 
<span>11 </span>}</pre>
<p class="hidden"><strong class="calibre12"/>Applied fixes with formatting </p>
</div>
<p class="hidden"><a id="x1-149053r30" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-149054" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 7.30</strong>: Applying Clang-Tidy fixes with formatting on TestClassNotFormated.cpp </p>
<p class="hidden">The relationship between Clang-Tidy <a id="dx1-149055" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and Clang-Format, as we just demonstrated, can be visualized as presented in the following figure:</p>
<div class="tableofcontents">
<div class="tableofcontents">
<img src="../media/Figure7.31_B19722.png" alt="Figure 7.31: Clang-Tidy and Clang-Format integration " class="calibre42"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 7.31</strong>: Clang-Tidy and Clang-Format integration </p>
</div>
<p class="hidden">In the figure, both Clang-Tidy and Clang-Format use the <code class="calibre13">clangFormat </code>library to format the code.</p>
<p class="hidden">The provided example demonstrates <a id="dx1-149058" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the integration of various Clang Tools. Modularity, an essential design decision in LLVM/Clang, is a key component for such integration. This example is not unique, and we will explore the further integration of different Clang Tools to enhance <a id="dx1-149059" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the development experience in <strong class="calibre12">Integrated Development Environments </strong>(<strong class="calibre12">IDEs</strong>) like <strong class="calibre12">Visual Studio Code </strong>(<strong class="calibre12">VS Code</strong>). This <a id="dx1-149060" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>will be the topic of our next chapter. <a id="x1-149061r461" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
</section>
<section id="summary-6" class="level" data-number="2.3.5">
<h2 data-number="2.3.5" id="sigil_toc_id_132" class="likechapterhead"><span>7.5 </span> <a id="x1-1500005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Summary</h2>
<p class="hidden">In this chapter, we investigated the different options provided by Clang for code modifications. We created a specialized Clang Tool that renames a method in a test class. We also rewrote the tool using Clang-Tidy and explored how custom AST matchers can be created. Furthermore, we delved into a variety of different classes provided by Clang for code modifications. One of these classes, <span><code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">FixItHint</code></span>, is integrated with the Clang diagnostics subsystem and provides a powerful tool for code modification within Clang, as well as in different tools created with Clang. We concluded with Clang-Format, the only tool in the book that does not use the AST but instead utilizes the Clang Lexer to perform code formatting. The next chapter will focus on the integration of different Clang Tools within IDEs. <a id="x1-150001r477" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
<section id="further-reading-5" class="level" data-number="2.3.6">
<h2 data-number="2.3.6" id="sigil_toc_id_133" class="likechapterhead"><span>7.6 </span> <a id="x1-1510006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Further reading</h2>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Clang-Format Style Options: <a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://clang.llvm.org/docs/ClangFormatStyleOptions.html</a></p></li>
<li class="calibre14"><p class="calibre15">Peter Goldsborough, Emitting Diagnostics in Clang [<a href="B19722_Bib.xhtml#Xmisc_peter_goldsborough" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">23</a>]</p></li>
<li class="calibre14"><p class="calibre15">AST Matcher Reference: <a href="https://clang.llvm.org/docs/LibASTMatchersReference.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://clang.llvm.org/docs/LibASTMatchersReference.html</a></p></li>
</ul>
<p class="hidden"><a id="x1-151001r402" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
</section>
</section>
</div>
</div>
</body></html>