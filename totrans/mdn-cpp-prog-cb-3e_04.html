<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer072">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 class="chapterTitle" id="_idParaDest-227"><span class="koboSpan" id="kobo.2.1">Preprocessing and Compilation</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In C++, compilation is </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.4.1">the process by which source code is transformed into machine code and organized into object files that are then linked together to produce an executable. </span><span class="koboSpan" id="kobo.4.2">The compiler actually works on a single file (called a translation unit) at a time, produced by the preprocessor (the part of the compiler that handles preprocessing directives) from a single source file and all the header files that it includes. </span><span class="koboSpan" id="kobo.4.3">This is, however, an oversimplification of what happens when we compile the code. </span><span class="koboSpan" id="kobo.4.4">This chapter addresses topics related to preprocessing and compilation, with a focus on various methods to perform conditional compilation, but also touches on other modern topics such as using attributes to provide implementation-defined language extensions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">The recipes included in this chapter are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">Conditionally compiling your source code</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Using the indirection pattern for preprocessor stringification and concatenation</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Performing compile-time assertion checks with </span><code class="inlineCode"><span class="koboSpan" id="kobo.9.1">static_assert</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Conditionally compiling classes and functions with </span><code class="inlineCode"><span class="koboSpan" id="kobo.11.1">enable_if</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Selecting branches at compile time with </span><em class="italic"><span class="koboSpan" id="kobo.13.1">constexpr if</span></em></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Providing metadata to the compiler with attributes</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.15.1">The recipe that we will start this chapter with addresses a very common problem faced by developers, which is compiling only parts of a code base depending on various conditions.</span></p>
<h1 class="heading-1" id="_idParaDest-228"><span class="koboSpan" id="kobo.16.1">Conditionally compiling your source code</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.17.1">Conditional compilation</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.18.1"> is a simple mechanism that enables developers to maintain a single code base, but only consider some parts of the code for compilation to produce different executables, usually in order to run on different platforms or hardware, or depend on different libraries or library versions. </span><span class="koboSpan" id="kobo.18.2">Common examples include using or ignoring code based on the compiler, platform (x86, x64, ARM, and so on), configuration (debug or release), or any user-defined specific conditions. </span><span class="koboSpan" id="kobo.18.3">In this recipe, we’ll take a look at how conditional compilation works.</span></p>
<h2 class="heading-2" id="_idParaDest-229"><span class="koboSpan" id="kobo.19.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.20.1">Conditional compilation</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.21.1"> is a technique used extensively</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.22.1"> for many purposes. </span><span class="koboSpan" id="kobo.22.2">In this recipe, we will look at several examples and explain how they work. </span><span class="koboSpan" id="kobo.22.3">This technique is not in any way limited to these examples. </span><span class="koboSpan" id="kobo.22.4">For the scope of this recipe, we will only consider the three major compilers: GCC, Clang, and VC++.</span></p>
<h2 class="heading-2" id="_idParaDest-230"><span class="koboSpan" id="kobo.23.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.24.1">To conditionally</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.25.1"> compile portions of code, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.26.1">#if</span></code><span class="koboSpan" id="kobo.27.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.28.1">#ifdef</span></code><span class="koboSpan" id="kobo.29.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.30.1">#ifndef</span></code><span class="koboSpan" id="kobo.31.1"> directives (with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.32.1">#elif</span></code><span class="koboSpan" id="kobo.33.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.34.1">#else</span></code><span class="koboSpan" id="kobo.35.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.36.1">#endif</span></code><span class="koboSpan" id="kobo.37.1"> directives). </span><span class="koboSpan" id="kobo.37.2">The general form for conditional compilation is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.38.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.39.1">if</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.40.1"> condition1</span></span><span class="koboSpan" id="kobo.41.1">
  text1
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.42.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.43.1">elif</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.44.1"> condition2</span></span><span class="koboSpan" id="kobo.45.1">
  text2
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.46.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.47.1">elif</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.48.1"> condition3</span></span><span class="koboSpan" id="kobo.49.1">
  text3
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.50.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.51.1">else</span></span><span class="koboSpan" id="kobo.52.1">
  text4
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.53.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.54.1">endif</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.55.1">Because the conditions here usually imply checking whether a macro is defined or not using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.56.1">defined identifier</span></code><span class="koboSpan" id="kobo.57.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.58.1">defined (identifier)</span></code><span class="koboSpan" id="kobo.59.1"> syntax, it’s also possible to use the following forms:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.60.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.61.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.62.1"> identifier1</span></span><span class="koboSpan" id="kobo.63.1">
  text1
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.64.1">#elifdef identifier2</span></span><span class="koboSpan" id="kobo.65.1">
  text2
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.66.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.67.1">endif</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.68.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.69.1">ifndef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.70.1"> identifier1</span></span><span class="koboSpan" id="kobo.71.1">
  text1
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.72.1">#elifndef identifier2</span></span><span class="koboSpan" id="kobo.73.1">
  text2
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.74.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.75.1">endif</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.76.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.77.1">#elifdef</span></code><span class="koboSpan" id="kobo.78.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.79.1">#elifndef</span></code><span class="koboSpan" id="kobo.80.1"> directives were introduced in C++23.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.81.1">To</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.82.1"> define macros for conditional compilation, you can use </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.83.1">either of the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.84.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.85.1">#define</span></code><span class="koboSpan" id="kobo.86.1"> directive in your source code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.87.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.88.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.89.1"> VERBOSE_PRINTS</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.90.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.91.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.92.1"> VERBOSITY_LEVEL 5</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.93.1">Compiler command-line options that are specific to each compiler. </span><span class="koboSpan" id="kobo.93.2">Examples for the most widely used compilers are as follows:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.94.1">For Visual C++, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.95.1">/Dname</span></code><span class="koboSpan" id="kobo.96.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.97.1">/Dname=value</span></code><span class="koboSpan" id="kobo.98.1"> (where </span><code class="inlineCode"><span class="koboSpan" id="kobo.99.1">/Dname</span></code><span class="koboSpan" id="kobo.100.1"> is equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.101.1">/Dname=1</span></code><span class="koboSpan" id="kobo.102.1">), for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">cl /DVERBOSITY_LEVEL=5</span></code><span class="koboSpan" id="kobo.104.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.105.1">For GCC and Clang, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.106.1">-D name</span></code><span class="koboSpan" id="kobo.107.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.108.1">-D name=value</span></code><span class="koboSpan" id="kobo.109.1"> (where </span><code class="inlineCode"><span class="koboSpan" id="kobo.110.1">-D name</span></code><span class="koboSpan" id="kobo.111.1"> is equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.112.1">-D name=1</span></code><span class="koboSpan" id="kobo.113.1">), for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.114.1">gcc -D VERBOSITY_LEVEL=5</span></code><span class="koboSpan" id="kobo.115.1">.</span></li>
</ul>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.116.1">The following are typical</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.117.1"> examples of conditional compilation:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.118.1">Header guards to avoid duplicate definitions (due to multiple inclusions of the same header in the same translation unit):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.119.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.120.1">ifndef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.121.1"> UNIQUE_NAME</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.122.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.123.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.124.1"> UNIQUE_NAME</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.125.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.126.1">widget</span></span><span class="koboSpan" id="kobo.127.1"> { };
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.128.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.129.1">endif</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.130.1">Compiler-specific code for cross-platform applications. </span><span class="koboSpan" id="kobo.130.2">The following is an example of printing a message to the console with the name of the compiler:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.131.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.132.1">show_compiler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.133.1">()</span></span><span class="koboSpan" id="kobo.134.1">
{
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.135.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.136.1">if</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.137.1"> defined _MSC_VER</span></span><span class="koboSpan" id="kobo.138.1">
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.139.1">"Visual C++\n"</span></span><span class="koboSpan" id="kobo.140.1">;
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.141.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.142.1">elif</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.143.1"> defined __clang__</span></span><span class="koboSpan" id="kobo.144.1">
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.145.1">"Clang\n"</span></span><span class="koboSpan" id="kobo.146.1">;
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.147.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.148.1">elif</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.149.1"> defined __GNUG__</span></span><span class="koboSpan" id="kobo.150.1">
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.151.1">"GCC\n"</span></span><span class="koboSpan" id="kobo.152.1">;
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.153.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.154.1">else</span></span><span class="koboSpan" id="kobo.155.1">
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.156.1">"Unknown compiler\n"</span></span><span class="koboSpan" id="kobo.157.1">;
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.158.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.159.1">endif</span></span><span class="koboSpan" id="kobo.160.1">
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.161.1">Target-specific </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.162.1">code for multiple architectures, for example, for conditionally compiling code for multiple compilers </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.163.1">and architectures:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.164.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.165.1">show_architecture</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.166.1">()</span></span><span class="koboSpan" id="kobo.167.1">
{
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.168.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.169.1">if</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.170.1"> defined _MSC_VER</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.171.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.172.1">if</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.173.1"> defined _M_X64</span></span><span class="koboSpan" id="kobo.174.1">
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.175.1">"AMD64\n"</span></span><span class="koboSpan" id="kobo.176.1">;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.177.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.178.1">elif</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.179.1"> defined _M_IX86</span></span><span class="koboSpan" id="kobo.180.1">
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.181.1">"INTEL x86\n"</span></span><span class="koboSpan" id="kobo.182.1">;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.183.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.184.1">elif</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.185.1"> defined _M_ARM</span></span><span class="koboSpan" id="kobo.186.1">
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.187.1">"ARM\n"</span></span><span class="koboSpan" id="kobo.188.1">;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.189.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.190.1">else</span></span><span class="koboSpan" id="kobo.191.1">
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.192.1">"unknown\n"</span></span><span class="koboSpan" id="kobo.193.1">;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.194.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.195.1">endif</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.196.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.197.1">elif</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.198.1"> defined __clang__ || __GNUG__</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.199.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.200.1">if</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.201.1"> defined __amd64__</span></span><span class="koboSpan" id="kobo.202.1">
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.203.1">"AMD64\n"</span></span><span class="koboSpan" id="kobo.204.1">;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.205.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.206.1">elif</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.207.1"> defined __i386__</span></span><span class="koboSpan" id="kobo.208.1">
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.209.1">"INTEL x86\n"</span></span><span class="koboSpan" id="kobo.210.1">;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.211.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.212.1">elif</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.213.1"> defined __arm__</span></span><span class="koboSpan" id="kobo.214.1">
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.215.1">"ARM\n"</span></span><span class="koboSpan" id="kobo.216.1">;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.217.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.218.1">else</span></span><span class="koboSpan" id="kobo.219.1">
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.220.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.221.1">unknown\n"</span></span><span class="koboSpan" id="kobo.222.1">;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.223.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.224.1">endif</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.225.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.226.1">else</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.227.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.228.1">error</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.229.1"> Unknown compiler</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.230.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.231.1">endif</span></span><span class="koboSpan" id="kobo.232.1">
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.233.1">Configuration-specific code, for example, for conditionally compiling code for debug and release builds:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.234.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.235.1">show_configuration</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.236.1">()</span></span><span class="koboSpan" id="kobo.237.1">
{
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.238.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.239.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.240.1"> _DEBUG</span></span><span class="koboSpan" id="kobo.241.1">
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.242.1">"debug\n"</span></span><span class="koboSpan" id="kobo.243.1">;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.244.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.245.1">else</span></span><span class="koboSpan" id="kobo.246.1">
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.247.1">"release\n"</span></span><span class="koboSpan" id="kobo.248.1">;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.249.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.250.1">endif</span></span><span class="koboSpan" id="kobo.251.1">
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.252.1">To </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.253.1">check whether a language or library </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.254.1">feature is available, use the predefined macros </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">__cpp_xxx</span></code><span class="koboSpan" id="kobo.256.1"> for language features (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">__cpp_constexpr</span></code><span class="koboSpan" id="kobo.258.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.259.1">__cpp_constinit</span></code><span class="koboSpan" id="kobo.260.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.261.1">__cpp_modules</span></code><span class="koboSpan" id="kobo.262.1">) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">__cpp_lib_xxx</span></code><span class="koboSpan" id="kobo.264.1"> for library features (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">__cpp_lib_concepts</span></code><span class="koboSpan" id="kobo.266.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">__cpp_lib_expected</span></code><span class="koboSpan" id="kobo.268.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.269.1">__cpp_lib_jthread</span></code><span class="koboSpan" id="kobo.270.1">). </span><span class="koboSpan" id="kobo.270.2">The library feature macros were introduced in C++20 and are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">&lt;version&gt;</span></code><span class="koboSpan" id="kobo.272.1"> header:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.273.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.274.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.275.1"> __cpp_consteval</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.276.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.277.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.278.1"> CONSTEVAL consteval</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.279.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.280.1">else</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.281.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.282.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.283.1"> CONSTEVAL constexpr</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.284.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.285.1">endif</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.286.1">CONSTEVAL </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.287.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.288.1">twice</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.289.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.290.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.291.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.292.1"> n)</span></span><span class="koboSpan" id="kobo.293.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.294.1">return</span></span><span class="koboSpan" id="kobo.295.1"> n + n;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.296.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.297.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.298.1">()</span></span><span class="koboSpan" id="kobo.299.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.300.1">twice</span></span><span class="koboSpan" id="kobo.301.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.302.1">42</span></span><span class="koboSpan" id="kobo.303.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.304.1">To check whether a header or source file is available for inclusion, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.305.1">__has_include</span></code><span class="koboSpan" id="kobo.306.1"> directive, which is available in C++17. </span><span class="koboSpan" id="kobo.306.2">The following example checks whether the </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">&lt;optional&gt;</span></code><span class="koboSpan" id="kobo.308.1"> header exists:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.309.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.310.1">if</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.311.1"> __has_include(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.312.1">&lt;optional&gt;</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.313.1">)</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.314.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.315.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.316.1">&lt;optional&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.317.1">template</span></span><span class="koboSpan" id="kobo.318.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.319.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.320.1">T</span></span><span class="koboSpan" id="kobo.321.1">&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.322.1">using</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.323.1">optional_t</span></span><span class="koboSpan" id="kobo.324.1"> = std::optional&lt;T&gt;;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.325.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.326.1">elif</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.327.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.328.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.329.1">"myoptional.h"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.330.1">template</span></span><span class="koboSpan" id="kobo.331.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.332.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.333.1">T</span></span><span class="koboSpan" id="kobo.334.1">&gt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.335.1">using</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.336.1">optional_t</span></span><span class="koboSpan" id="kobo.337.1"> = my::optional&lt;T&gt;;
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.338.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.339.1">endif</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.340.1">To </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.341.1">check whether an attribute is supported (as well as from what version), use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">__has_cpp_attribute</span></code><span class="koboSpan" id="kobo.343.1"> directive, which </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.344.1">is available in C++20:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.345.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.346.1">if</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.347.1"> defined(__has_cpp_attribute) </span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.348.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.349.1">if</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.350.1"> __has_cpp_attribute(deprecated)</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.351.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.352.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.353.1"> DEPRECATED(msg) [[deprecated(msg)]]</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.354.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.355.1">endif</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.356.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.357.1">endif</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.358.1">DEPRECATED</span></span><span class="koboSpan" id="kobo.359.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.360.1">"This function is deprecated."</span></span><span class="koboSpan" id="kobo.361.1">)
</span><span class="hljs-type"><span class="koboSpan" id="kobo.362.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.363.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.364.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.365.1">{}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-231"><span class="koboSpan" id="kobo.366.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.367.1">Before discussing </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.368.1">compilation, we should first clarify a term that we will encounter often: </span><strong class="keyWord"><span class="koboSpan" id="kobo.369.1">translation unit</span></strong><span class="koboSpan" id="kobo.370.1">. </span><span class="koboSpan" id="kobo.370.2">In C++, this is the basic unit of compilation. </span><span class="koboSpan" id="kobo.370.3">It is the result of putting together the content of a source file (a </span><code class="inlineCode"><span class="koboSpan" id="kobo.371.1">.cpp</span></code><span class="koboSpan" id="kobo.372.1"> file) and the entire graph of all the header files included directly or indirectly but without the text excluded with conditional preprocessing statements, as described in this recipe.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.373.1">When you use the preprocessing directives </span><code class="inlineCode"><span class="koboSpan" id="kobo.374.1">#if</span></code><span class="koboSpan" id="kobo.375.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.376.1">#ifndef</span></code><span class="koboSpan" id="kobo.377.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.378.1">#ifdef</span></code><span class="koboSpan" id="kobo.379.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">#elif</span></code><span class="koboSpan" id="kobo.381.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">#else</span></code><span class="koboSpan" id="kobo.383.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">#endif</span></code><span class="koboSpan" id="kobo.385.1">, the compiler will select, at most, one branch whose body will be included in the translation unit for compilation. </span><span class="koboSpan" id="kobo.385.2">The body of these directives can be any text, including other preprocessing directives. </span><span class="koboSpan" id="kobo.385.3">The following rules apply:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.386.1">#if</span></code><span class="koboSpan" id="kobo.387.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.388.1">#ifdef</span></code><span class="koboSpan" id="kobo.389.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">#ifndef</span></code><span class="koboSpan" id="kobo.391.1"> must be matched by an </span><code class="inlineCode"><span class="koboSpan" id="kobo.392.1">#endif</span></code><span class="koboSpan" id="kobo.393.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.394.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">#if</span></code><span class="koboSpan" id="kobo.396.1"> directive may have multiple </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">#elif</span></code><span class="koboSpan" id="kobo.398.1"> directives, but only one </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">#else</span></code><span class="koboSpan" id="kobo.400.1">, which must also be the last one before </span><code class="inlineCode"><span class="koboSpan" id="kobo.401.1">#endif</span></code><span class="koboSpan" id="kobo.402.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.403.1">#if</span></code><span class="koboSpan" id="kobo.404.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.405.1">#ifdef</span></code><span class="koboSpan" id="kobo.406.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.407.1">#ifndef</span></code><span class="koboSpan" id="kobo.408.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.409.1">#elif</span></code><span class="koboSpan" id="kobo.410.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.411.1">#else</span></code><span class="koboSpan" id="kobo.412.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.413.1">#endif</span></code><span class="koboSpan" id="kobo.414.1"> can be nested.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.415.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">#if</span></code><span class="koboSpan" id="kobo.417.1"> directive requires a constant expression, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.418.1">#ifdef</span></code><span class="koboSpan" id="kobo.419.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.420.1">#ifndef</span></code><span class="koboSpan" id="kobo.421.1"> require an identifier.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.422.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.423.1">defined</span></code><span class="koboSpan" id="kobo.424.1"> operator can be used for preprocessor constant expressions, but only in </span><code class="inlineCode"><span class="koboSpan" id="kobo.425.1">#if</span></code><span class="koboSpan" id="kobo.426.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.427.1">#elif</span></code><span class="koboSpan" id="kobo.428.1"> directives.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.429.1">defined(identifier)</span></code><span class="koboSpan" id="kobo.430.1"> is considered </span><code class="inlineCode"><span class="koboSpan" id="kobo.431.1">true</span></code><span class="koboSpan" id="kobo.432.1"> if </span><code class="inlineCode"><span class="koboSpan" id="kobo.433.1">identifier</span></code><span class="koboSpan" id="kobo.434.1"> is defined; otherwise, it is considered </span><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">false</span></code><span class="koboSpan" id="kobo.436.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.437.1">An identifier defined as an empty text is considered defined.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.438.1">#ifdef identifier</span></code><span class="koboSpan" id="kobo.439.1"> is equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.440.1">#if defined(identifier)</span></code><span class="koboSpan" id="kobo.441.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.442.1">#ifndef identifier</span></code><span class="koboSpan" id="kobo.443.1"> is equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.444.1">#if !defined(identifier)</span></code><span class="koboSpan" id="kobo.445.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.446.1">defined(identifier)</span></code><span class="koboSpan" id="kobo.447.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.448.1">defined identifier</span></code><span class="koboSpan" id="kobo.449.1"> are equivalent.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.450.1">Header </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.451.1">guards are one of the most common forms of conditional compilation. </span><span class="koboSpan" id="kobo.451.2">This technique is used to prevent the content of a header file from being included several times in the same translation unit (although the header is still scanned every time in order to detect what should be included). </span><span class="koboSpan" id="kobo.451.3">Therefore, the code in headers is guarded against multiple inclusions in the manner shown in the example given in the previous section. </span><span class="koboSpan" id="kobo.451.4">The way this works, considering the given example, is that if the </span><code class="inlineCode"><span class="koboSpan" id="kobo.452.1">UNIQUE_NAME</span></code><span class="koboSpan" id="kobo.453.1"> macro (this is a generic name from the previous section) is not defined, then the code after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.454.1">#if</span></code><span class="koboSpan" id="kobo.455.1"> directive, until </span><code class="inlineCode"><span class="koboSpan" id="kobo.456.1">#endif</span></code><span class="koboSpan" id="kobo.457.1">, is included in the translation unit and compiled. </span><span class="koboSpan" id="kobo.457.2">When that happens, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.458.1">UNIQUE_NAME</span></code><span class="koboSpan" id="kobo.459.1"> macro is defined with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.460.1">#define</span></code><span class="koboSpan" id="kobo.461.1"> directive. </span><span class="koboSpan" id="kobo.461.2">The next time the header is included in the (same) translation unit, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">UNIQUE_NAME</span></code><span class="koboSpan" id="kobo.463.1"> macro is defined and the code in the body of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">#if</span></code><span class="koboSpan" id="kobo.465.1"> directive is not included in the translation unit, therefore, it avoids duplicates.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.466.1">Note that the name of the macro must be unique throughout the application; otherwise, only the code from the first header where the macro is used will be compiled. </span><span class="koboSpan" id="kobo.466.2">Code from other headers using the same name will be ignored. </span><span class="koboSpan" id="kobo.466.3">Typically, the name of the macro is based on the name of the header file where it is defined.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.467.1">Another important example of conditional compilation is cross-platform code, which needs to account for different compilers and architectures, usually one of Intel x86, AMD64, or ARM. </span><span class="koboSpan" id="kobo.467.2">However, the compiler defines its own macros for the possible platforms. </span><span class="koboSpan" id="kobo.467.3">The samples from the </span><em class="italic"><span class="koboSpan" id="kobo.468.1">How to do it...</span></em><span class="koboSpan" id="kobo.469.1"> section show how to conditionally compile code for multiple compilers and architectures.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.470.1">Note that in the aforementioned example, we only consider a few architectures. </span><span class="koboSpan" id="kobo.470.2">In practice, there are multiple macros that can be used to identify the same architecture. </span><span class="koboSpan" id="kobo.470.3">Ensure that you read the documentation of each compiler before using these types of macros in your code.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.471.1">Configuration-specific code is also handled with macros and conditional compilation. </span><span class="koboSpan" id="kobo.471.2">Compilers such as GCC and Clang do not define any special macros for debug configurations (when the </span><code class="inlineCode"><span class="koboSpan" id="kobo.472.1">-g</span></code><span class="koboSpan" id="kobo.473.1"> flag is used). </span><span class="koboSpan" id="kobo.473.2">Visual C++ does define </span><code class="inlineCode"><span class="koboSpan" id="kobo.474.1">_DEBUG</span></code><span class="koboSpan" id="kobo.475.1"> for a debug configuration, which was shown in the last example in the </span><em class="italic"><span class="koboSpan" id="kobo.476.1">How to do it...</span></em><span class="koboSpan" id="kobo.477.1"> section. </span><span class="koboSpan" id="kobo.477.2">For the other compilers, you would have to explicitly define a macro to identify such a debug configuration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.478.1">Feature testing </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.479.1">is an important conditional-compilation use case, especially in libraries that provide support for multiple platforms (Windows, Linux, etc.) and compiler versions (C++11, C++14, C++17, etc.). </span><span class="koboSpan" id="kobo.479.2">Library implementers often need to check whether a particular language feature or language attribute is available. </span><span class="koboSpan" id="kobo.479.3">This is possible with a set of predefined macros that includes the following:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.480.1">__cplusplus</span></code><span class="koboSpan" id="kobo.481.1">: Indicates the version of the C++ standard that is being used. </span><span class="koboSpan" id="kobo.481.2">It expands to one of the following values: </span><code class="inlineCode"><span class="koboSpan" id="kobo.482.1">199711L</span></code><span class="koboSpan" id="kobo.483.1"> for versions before C++11, </span><code class="inlineCode"><span class="koboSpan" id="kobo.484.1">201103L</span></code><span class="koboSpan" id="kobo.485.1"> for C++11, </span><code class="inlineCode"><span class="koboSpan" id="kobo.486.1">201402L</span></code><span class="koboSpan" id="kobo.487.1"> for C++14, </span><code class="inlineCode"><span class="koboSpan" id="kobo.488.1">201703L</span></code><span class="koboSpan" id="kobo.489.1"> for C++17, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">202002L</span></code><span class="koboSpan" id="kobo.491.1"> for C++20. </span><span class="koboSpan" id="kobo.491.2">At the time of writing the book, the value for C++23 has not been defined.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.492.1">__cpp_xxx</span></code><span class="koboSpan" id="kobo.493.1"> macros, for determining whether a language feature is supported. </span><span class="koboSpan" id="kobo.493.2">Examples include </span><code class="inlineCode"><span class="koboSpan" id="kobo.494.1">__cpp_concepts</span></code><span class="koboSpan" id="kobo.495.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.496.1">__cpp_consteval</span></code><span class="koboSpan" id="kobo.497.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.498.1">__cpp_modules</span></code><span class="koboSpan" id="kobo.499.1">, etc.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">__cpp_lib_xxx</span></code><span class="koboSpan" id="kobo.501.1"> macros, for determining whether a library feature is supported. </span><span class="koboSpan" id="kobo.501.2">Examples include </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">__cpp_lib_any</span></code><span class="koboSpan" id="kobo.503.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">__cpp_lib_optional</span></code><span class="koboSpan" id="kobo.505.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.506.1">__cpp_lib_constexpr_string</span></code><span class="koboSpan" id="kobo.507.1">, etc. </span><span class="koboSpan" id="kobo.507.2">These macros are defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">&lt;version&gt;</span></code><span class="koboSpan" id="kobo.509.1"> header that was introduced in C++20.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.510.1">The set of </span><code class="inlineCode"><span class="koboSpan" id="kobo.511.1">__cpp_xxx</span></code><span class="koboSpan" id="kobo.512.1"> language feature macros and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">__cpp_lib_xxx</span></code><span class="koboSpan" id="kobo.514.1"> library feature macros are being expanded with new macros as new features are added. </span><span class="koboSpan" id="kobo.514.2">The entire list of macros is too long to be presented here but can be consulted at </span><a href="https://en.cppreference.com/w/cpp/feature_test"><span class="url"><span class="koboSpan" id="kobo.515.1">https://en.cppreference.com/w/cpp/feature_test</span></span></a><span class="koboSpan" id="kobo.516.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.517.1">Apart from these macros, there are two directives, </span><code class="inlineCode"><span class="koboSpan" id="kobo.518.1">__has_include</span></code><span class="koboSpan" id="kobo.519.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.520.1">__has_cpp_attribute</span></code><span class="koboSpan" id="kobo.521.1">, that can be used in </span><code class="inlineCode"><span class="koboSpan" id="kobo.522.1">#if</span></code><span class="koboSpan" id="kobo.523.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.524.1">#elif</span></code><span class="koboSpan" id="kobo.525.1"> expressions to determine whether a header or source file exists or whether an attribute is supported by the compiler. </span><span class="koboSpan" id="kobo.525.2">Together, all these macros and directives are useful tools in determining whether a particular feature is present. </span><span class="koboSpan" id="kobo.525.3">They enable us to write code that is portable across platforms and compiler versions.</span></p>
<h2 class="heading-2" id="_idParaDest-232"><span class="koboSpan" id="kobo.526.1">There’s more…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.527.1">Sometimes, when</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.528.1"> performing conditional compilation, you will want to either display a warning or stop the compilation entirely. </span><span class="koboSpan" id="kobo.528.2">This is possible with the help of two diagnostics macros:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">#error</span></code><span class="koboSpan" id="kobo.530.1"> displays a message to the console and stops the compilation of the program.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">#warning</span></code><span class="koboSpan" id="kobo.532.1">, available since C++23, displays a message to the console without stopping the compilation of the program.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.533.1">The following snippet shows an example of using these directives:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.534.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.535.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.536.1"> _WIN64</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.537.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.538.1">error</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.539.1">"64-bit not supported"</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.540.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.541.1">endif</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.542.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.543.1">if</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.544.1"> __cplusplus &lt; 201703L</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.545.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.546.1">warning</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.547.1">"Consider upgrading to a C++17 compiler"</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.548.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.549.1">endif</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.550.1">Although </span><code class="inlineCode"><span class="koboSpan" id="kobo.551.1">#warning</span></code><span class="koboSpan" id="kobo.552.1"> is only available since C++23, many compilers offer support for this directive as an extension.</span></p>
<h2 class="heading-2" id="_idParaDest-233"><span class="koboSpan" id="kobo.553.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.554.1">Using the indirection pattern for preprocessor stringification and concatenation</span></em><span class="koboSpan" id="kobo.555.1">, to learn how to transform identifiers into strings and concatenate identifiers together during preprocessing</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-234"><span class="koboSpan" id="kobo.556.1">Using the indirection pattern for preprocessor stringification and concatenation</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.557.1">The</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.558.1"> C++ preprocessor provides two operators for transforming identifiers into strings and concatenating identifiers together. </span><span class="koboSpan" id="kobo.558.2">The first one, operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.559.1">#</span></code><span class="koboSpan" id="kobo.560.1">, is called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.561.1">stringizing operator</span></strong><span class="koboSpan" id="kobo.562.1">, while </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.563.1">the second </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.564.1">one, operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.565.1">##</span></code><span class="koboSpan" id="kobo.566.1">, is called </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.567.1">the </span><strong class="keyWord"><span class="koboSpan" id="kobo.568.1">token-pasting</span></strong><span class="koboSpan" id="kobo.569.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.570.1">merging</span></strong><span class="koboSpan" id="kobo.571.1">, or </span><strong class="keyWord"><span class="koboSpan" id="kobo.572.1">concatenating operator</span></strong><span class="koboSpan" id="kobo.573.1">. </span><span class="koboSpan" id="kobo.573.2">Although their use is limited to some particular cases, it is</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.574.1"> important to understand how they work. </span></p>
<h2 class="heading-2" id="_idParaDest-235"><span class="koboSpan" id="kobo.575.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.576.1">For this recipe, you need to know how to define macros using the preprocessing directive </span><code class="inlineCode"><span class="koboSpan" id="kobo.577.1">#define</span></code><span class="koboSpan" id="kobo.578.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-236"><span class="koboSpan" id="kobo.579.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.580.1">To </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.581.1">create a </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.582.1">string from an identifier using the preprocessing operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.583.1">#</span></code><span class="koboSpan" id="kobo.584.1">, use the following pattern:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.585.1">Define a helper macro taking one argument that expands to </span><code class="inlineCode"><span class="koboSpan" id="kobo.586.1">#</span></code><span class="koboSpan" id="kobo.587.1">, followed by the argument:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.588.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.589.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.590.1"> MAKE_STR2(x) #x</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.591.1">Define the macro you want to use, taking one argument that expands to the helper macro:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.592.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.593.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.594.1"> MAKE_STR(x) MAKE_STR2(x)</span></span>
</code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.595.1">To </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.596.1">concatenate identifiers together using the preprocessing operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">##</span></code><span class="koboSpan" id="kobo.598.1">, use the following pattern:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.599.1">Define a helper macro with one or more arguments that use the token-pasting operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.600.1">##</span></code><span class="koboSpan" id="kobo.601.1"> to concatenate arguments:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.602.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.603.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.604.1"> MERGE2(x, y)    x##y</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.605.1">Define the macro you want to use by using the helper macro:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.606.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.607.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.608.1"> MERGE(x, y)     MERGE2(x, y)</span></span>
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-237"><span class="koboSpan" id="kobo.609.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.610.1">To </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.611.1">understand how these work, let’s consider the </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">MAKE_STR</span></code><span class="koboSpan" id="kobo.613.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">MAKE_STR2</span></code><span class="koboSpan" id="kobo.615.1"> macros defined earlier. </span><span class="koboSpan" id="kobo.615.2">When used with any text, they will produce a string containing that text. </span><span class="koboSpan" id="kobo.615.3">The following example shows how both these macros can be used to define strings containing the text </span><code class="inlineCode"><span class="koboSpan" id="kobo.616.1">"sample"</span></code><span class="koboSpan" id="kobo.617.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.618.1">std::string s1 { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.619.1">MAKE_STR</span></span><span class="koboSpan" id="kobo.620.1">(sample) };  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.621.1">// s1 = "sample"</span></span><span class="koboSpan" id="kobo.622.1">
std::string s2 { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.623.1">MAKE_STR2</span></span><span class="koboSpan" id="kobo.624.1">(sample) }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.625.1">// s2 = "sample"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.626.1">On the </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.627.1">other hand, when a macro is passed as an argument, the results are different. </span><span class="koboSpan" id="kobo.627.2">In the following example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.628.1">NUMBER</span></code><span class="koboSpan" id="kobo.629.1"> is a macro that expands to an integer, </span><code class="inlineCode"><span class="koboSpan" id="kobo.630.1">42</span></code><span class="koboSpan" id="kobo.631.1">. </span><span class="koboSpan" id="kobo.631.2">When used as an </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.632.1">argument to </span><code class="inlineCode"><span class="koboSpan" id="kobo.633.1">MAKE_STR</span></code><span class="koboSpan" id="kobo.634.1">, it indeed produces the string </span><code class="inlineCode"><span class="koboSpan" id="kobo.635.1">"42"</span></code><span class="koboSpan" id="kobo.636.1">; however, when used as an argument to </span><code class="inlineCode"><span class="koboSpan" id="kobo.637.1">MAKE_STR2</span></code><span class="koboSpan" id="kobo.638.1">, it produces the string </span><code class="inlineCode"><span class="koboSpan" id="kobo.639.1">"NUMBER"</span></code><span class="koboSpan" id="kobo.640.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.641.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.642.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.643.1"> NUMBER 42</span></span><span class="koboSpan" id="kobo.644.1">
std::string s3 { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.645.1">MAKE_STR</span></span><span class="koboSpan" id="kobo.646.1">(NUMBER) };    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.647.1">// s3 = "42"</span></span><span class="koboSpan" id="kobo.648.1">
std::string s4 { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.649.1">MAKE_STR2</span></span><span class="koboSpan" id="kobo.650.1">(NUMBER) };   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.651.1">// s4 = "NUMBER"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.652.1">The C++ standard defines the following rules for argument substitution in function-like macros (paragraph 15.6.2 from the C++ Standard document number N4917):</span></p>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.653.1">After the arguments for the invocation of a function-like macro have been identified, argument substitution takes place. </span><span class="koboSpan" id="kobo.653.2">A parameter in the replacement list, unless preceded by a # or ## preprocessing token or followed by a ## preprocessing token (see below), is replaced by the corresponding argument after all the macros contained therein have been expanded. </span><span class="koboSpan" id="kobo.653.3">Before being substituted, each argument’s preprocessing tokens are completely macro replaced as if they formed the rest of the preprocessing file; no other preprocessing tokens are available.</span></p>
</blockquote>
<p class="normal"><span class="koboSpan" id="kobo.654.1">What this says is that macro arguments are expanded before they are substituted into the macro body, except for the case when the operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.655.1">#</span></code><span class="koboSpan" id="kobo.656.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.657.1">##</span></code><span class="koboSpan" id="kobo.658.1"> is preceding or following a parameter in the macro body. </span><span class="koboSpan" id="kobo.658.2">As a result, the following happens:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.659.1">For </span><code class="inlineCode"><span class="koboSpan" id="kobo.660.1">MAKE_STR2(NUMBER)</span></code><span class="koboSpan" id="kobo.661.1">, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.662.1">NUMBER</span></code><span class="koboSpan" id="kobo.663.1"> parameter in the replacement list is preceded by </span><code class="inlineCode"><span class="koboSpan" id="kobo.664.1">#</span></code><span class="koboSpan" id="kobo.665.1"> and, therefore, it is not expanded before substituting the argument in the macro body; therefore, after the substitution, we have </span><code class="inlineCode"><span class="koboSpan" id="kobo.666.1">#NUMBER</span></code><span class="koboSpan" id="kobo.667.1">, which becomes </span><code class="inlineCode"><span class="koboSpan" id="kobo.668.1">"NUMBER"</span></code><span class="koboSpan" id="kobo.669.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.670.1">For </span><code class="inlineCode"><span class="koboSpan" id="kobo.671.1">MAKE_STR(NUMBER)</span></code><span class="koboSpan" id="kobo.672.1">, the replacement list is </span><code class="inlineCode"><span class="koboSpan" id="kobo.673.1">MAKE_STR2(NUMBER)</span></code><span class="koboSpan" id="kobo.674.1">, which has no </span><code class="inlineCode"><span class="koboSpan" id="kobo.675.1">#</span></code><span class="koboSpan" id="kobo.676.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.677.1">##</span></code><span class="koboSpan" id="kobo.678.1">; therefore, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.679.1">NUMBER</span></code><span class="koboSpan" id="kobo.680.1"> parameter is replaced with its corresponding argument, </span><code class="inlineCode"><span class="koboSpan" id="kobo.681.1">42</span></code><span class="koboSpan" id="kobo.682.1">, before being substituted. </span><span class="koboSpan" id="kobo.682.2">The result is </span><code class="inlineCode"><span class="koboSpan" id="kobo.683.1">MAKE_STR2(42)</span></code><span class="koboSpan" id="kobo.684.1">, which is then scanned again, and, after expansion, it becomes </span><code class="inlineCode"><span class="koboSpan" id="kobo.685.1">"42"</span></code><span class="koboSpan" id="kobo.686.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.687.1">The</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.688.1"> same processing rules apply to macros using the token-pasting operator. </span><span class="koboSpan" id="kobo.688.2">Therefore, in order to make sure that your stringification and concatenation macros work for all cases, always apply the indirection pattern described in this recipe.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.689.1">The</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.690.1"> token-pasting operator </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.691.1">is typically used in macros</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.692.1"> that factor in repetitive code to avoid writing the same thing explicitly over and over again. </span><span class="koboSpan" id="kobo.692.2">The following simple example shows a practical use of the token-pasting operator; given a set of classes, we want to provide factory methods that create an instance of each class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.693.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.694.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.695.1"> DECL_MAKE(x)    DECL_MAKE2(x)</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.696.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.697.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.698.1"> DECL_MAKE2(x)   x* make##_##x() { return new x(); }</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.699.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.700.1">bar</span></span><span class="koboSpan" id="kobo.701.1"> {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.702.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.703.1">foo</span></span><span class="koboSpan" id="kobo.704.1"> {};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.705.1">DECL_MAKE</span></span><span class="koboSpan" id="kobo.706.1">(foo)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.707.1">DECL_MAKE</span></span><span class="koboSpan" id="kobo.708.1">(bar)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.709.1">auto</span></span><span class="koboSpan" id="kobo.710.1"> f = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.711.1">make_foo</span></span><span class="koboSpan" id="kobo.712.1">(); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.713.1">// f is a foo*</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.714.1">auto</span></span><span class="koboSpan" id="kobo.715.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.716.1">make_bar</span></span><span class="koboSpan" id="kobo.717.1">(); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.718.1">// b is a bar*</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.719.1">Those familiar with the Windows platform have probably used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">_T</span></code><span class="koboSpan" id="kobo.721.1"> (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">_TEXT</span></code><span class="koboSpan" id="kobo.723.1">) macro for declaring string literals that are either translated to Unicode or ANSI strings (both single- and multi-type character strings):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.724.1">auto</span></span><span class="koboSpan" id="kobo.725.1"> text{ _T(</span><span class="hljs-string"><span class="koboSpan" id="kobo.726.1">"sample"</span></span><span class="koboSpan" id="kobo.727.1">) }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.728.1">// text is either "sample" or L"sample"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.729.1">The Windows SDK defines the </span><code class="inlineCode"><span class="koboSpan" id="kobo.730.1">_T</span></code><span class="koboSpan" id="kobo.731.1"> macro as follows. </span><span class="koboSpan" id="kobo.731.2">Note that when </span><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">_UNICODE</span></code><span class="koboSpan" id="kobo.733.1"> is defined, the token-pasting operator is defined to concatenate together the </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">L</span></code><span class="koboSpan" id="kobo.735.1"> prefix and the actual string being passed to the macro:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.736.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.737.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.738.1"> _UNICODE</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.739.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.740.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.741.1"> __T(x)   L ## x</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.742.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.743.1">else</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.744.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.745.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.746.1"> __T(x)   x</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.747.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.748.1">endif</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.749.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.750.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.751.1"> _T(x)    __T(x)</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.752.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.753.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.754.1"> _TEXT(x) __T(x)</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.755.1">At first </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.756.1">glance, it seems unnecessary to have one macro calling another macro, but this</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.757.1"> level of indirection is key for </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.758.1">making the </span><code class="inlineCode"><span class="koboSpan" id="kobo.759.1">#</span></code><span class="koboSpan" id="kobo.760.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.761.1">##</span></code><span class="koboSpan" id="kobo.762.1"> operators work with other macros, as we have seen in this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-238"><span class="koboSpan" id="kobo.763.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.764.1">Conditionally compiling your source code</span></em><span class="koboSpan" id="kobo.765.1">, to learn how to compile only parts of your code, depending on various conditions</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-239"><span class="koboSpan" id="kobo.766.1">Performing compile-time assertion checks with static_assert</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.767.1">In C++, it is </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.768.1">possible to perform both runtime and compile-time assertion checks to ensure that specific conditions in your code are true. </span><span class="koboSpan" id="kobo.768.2">Runtime assertions have the disadvantage that they are verified late </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.769.1">when the program is running, and only if the control flow reaches them. </span><span class="koboSpan" id="kobo.769.2">There is no alternative when the condition depends on runtime data; however, when that is not the case, compile-time assertion checks are to be preferred. </span><span class="koboSpan" id="kobo.769.3">With compile-time assertions, the compiler is able to notify you early in the development stage with an error that a particular condition has not been met. </span><span class="koboSpan" id="kobo.769.4">These, however, can only be used when the condition can be evaluated at compile time. </span><span class="koboSpan" id="kobo.769.5">In C++11, compile-time assertions are performed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">static_assert</span></code><span class="koboSpan" id="kobo.771.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-240"><span class="koboSpan" id="kobo.772.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.773.1">The most common use of static assertion checks is with template metaprogramming, where they </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.774.1">can be used for validating that preconditions on template types are met (examples can include whether a </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.775.1">type is a POD type, copy-constructible, a reference type, and so on). </span><span class="koboSpan" id="kobo.775.2">Another typical example is to ensure that types (or objects) have an expected size.</span></p>
<h2 class="heading-2" id="_idParaDest-241"><span class="koboSpan" id="kobo.776.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.777.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.778.1">static_assert</span></code><span class="koboSpan" id="kobo.779.1"> declarations to ensure that conditions in different scopes are met:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.780.1">Namespace</span></strong><span class="koboSpan" id="kobo.781.1">: In this example, we validate that the size of the class </span><code class="inlineCode"><span class="koboSpan" id="kobo.782.1">item</span></code><span class="koboSpan" id="kobo.783.1"> is always 16:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.784.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.785.1">alignas</span></span><span class="koboSpan" id="kobo.786.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.787.1">8</span></span><span class="koboSpan" id="kobo.788.1">) item
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.789.1">int</span></span><span class="koboSpan" id="kobo.790.1">      id;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.791.1">bool</span></span><span class="koboSpan" id="kobo.792.1">     active;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.793.1">double</span></span><span class="koboSpan" id="kobo.794.1">   value;
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.795.1">static_assert</span></span><span class="koboSpan" id="kobo.796.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.797.1">sizeof</span></span><span class="koboSpan" id="kobo.798.1">(item) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.799.1">16</span></span><span class="koboSpan" id="kobo.800.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.801.1">"size of item must be 16 bytes"</span></span><span class="koboSpan" id="kobo.802.1">);
</span></code></pre>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.803.1">Class</span></strong><span class="koboSpan" id="kobo.804.1">: In this example, we validate that </span><code class="inlineCode"><span class="koboSpan" id="kobo.805.1">pod_wrapper</span></code><span class="koboSpan" id="kobo.806.1"> can only be used with POD types:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.807.1">template</span></span><span class="koboSpan" id="kobo.808.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.809.1">typename</span></span><span class="koboSpan" id="kobo.810.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.811.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.812.1">pod_wrapper</span></span><span class="koboSpan" id="kobo.813.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.814.1">static_assert</span></span><span class="koboSpan" id="kobo.815.1">(std::is_standard_layout_v&lt;T&gt;, </span><span class="hljs-string"><span class="koboSpan" id="kobo.816.1">"POD type expected!"</span></span><span class="koboSpan" id="kobo.817.1">);
  T value;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.818.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.819.1">point</span></span><span class="koboSpan" id="kobo.820.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.821.1">int</span></span><span class="koboSpan" id="kobo.822.1"> x;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.823.1">int</span></span><span class="koboSpan" id="kobo.824.1"> y;
};
pod_wrapper&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.825.1">int</span></span><span class="koboSpan" id="kobo.826.1">&gt;         w1; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.827.1">// OK</span></span><span class="koboSpan" id="kobo.828.1">
pod_wrapper&lt;point&gt;       w2; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.829.1">// OK</span></span><span class="koboSpan" id="kobo.830.1">
pod_wrapper&lt;std::string&gt; w3; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.831.1">// error: POD type expected</span></span>
</code></pre>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.832.1">Block (function)</span></strong><span class="koboSpan" id="kobo.833.1">: In this</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.834.1"> example, we validate that a function template has only arguments of an integral type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.835.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.836.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.837.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.838.1"> T&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.839.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.840.1">mul</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.841.1">(T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.842.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.843.1"> a, T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.844.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.845.1"> b)</span></span><span class="koboSpan" id="kobo.846.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.847.1">static_assert</span></span><span class="koboSpan" id="kobo.848.1">(std::is_integral_v&lt;T&gt;, </span><span class="hljs-string"><span class="koboSpan" id="kobo.849.1">"Integral type expected"</span></span><span class="koboSpan" id="kobo.850.1">);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.851.1">return</span></span><span class="koboSpan" id="kobo.852.1"> a * b;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.853.1">auto</span></span><span class="koboSpan" id="kobo.854.1"> v1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.855.1">mul</span></span><span class="koboSpan" id="kobo.856.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.857.1">1</span></span><span class="koboSpan" id="kobo.858.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.859.1">2</span></span><span class="koboSpan" id="kobo.860.1">);       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.861.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.862.1">auto</span></span><span class="koboSpan" id="kobo.863.1"> v2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.864.1">mul</span></span><span class="koboSpan" id="kobo.865.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.866.1">12.0</span></span><span class="koboSpan" id="kobo.867.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.868.1">42.5</span></span><span class="koboSpan" id="kobo.869.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.870.1">// error: Integral type expected</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-242"><span class="koboSpan" id="kobo.871.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.872.1">static_assert</span></code><span class="koboSpan" id="kobo.873.1"> is basically a declaration, but it does not introduce a new name. </span><span class="koboSpan" id="kobo.873.2">These declarations have the following form:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.874.1">static_assert</span></span><span class="koboSpan" id="kobo.875.1">(condition, message);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.876.1">The</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.877.1"> condition must be convertible to a Boolean value at compile time, and the message must be a string literal. </span><span class="koboSpan" id="kobo.877.2">As of C++17, the message is optional.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.878.1">When the condition in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.879.1">static_assert</span></code><span class="koboSpan" id="kobo.880.1"> declaration evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.881.1">true</span></code><span class="koboSpan" id="kobo.882.1">, nothing happens. </span><span class="koboSpan" id="kobo.882.2">When the condition evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.883.1">false</span></code><span class="koboSpan" id="kobo.884.1">, the compiler generates an error that contains the specified message, if any.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.885.1">The message argument must be a string literal. </span><span class="koboSpan" id="kobo.885.2">However, that changes as of C++26, so that it could be an arbitrary constant expression that produces a sequence of characters. </span><span class="koboSpan" id="kobo.885.3">This helps provide better diagnostic messages for users. </span><span class="koboSpan" id="kobo.885.4">For instance, assuming there would be a </span><code class="inlineCode"><span class="koboSpan" id="kobo.886.1">constexpr</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.887.1">std::format()</span></code><span class="koboSpan" id="kobo.888.1"> function, one could write the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.889.1">static_assert</span></span><span class="koboSpan" id="kobo.890.1">(
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.891.1">   sizeof</span></span><span class="koboSpan" id="kobo.892.1">(item) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.893.1">16</span></span><span class="koboSpan" id="kobo.894.1">,
   std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.895.1">"size of item must be 16 bytes but got {}", sizeof(item))</span></span><span class="koboSpan" id="kobo.896.1">);
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-243"><span class="koboSpan" id="kobo.897.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.898.1">Conditionally compiling classes and functions with enable_if</span></em><span class="koboSpan" id="kobo.899.1">, to learn about SFINAE and how to use it to specify type constraints for templates</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.900.1">Chapter 12</span></em><span class="koboSpan" id="kobo.901.1">, </span><em class="italic"><span class="koboSpan" id="kobo.902.1">Specifying requirements on template arguments with concepts</span></em><span class="koboSpan" id="kobo.903.1">, to learn the fundamentals of C++20 concepts and how to use them to specify constraints for template types</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.904.1">Selecting branches at compile time with constexpr if</span></em><span class="koboSpan" id="kobo.905.1">, to learn how to compile only parts of your code with </span><em class="italic"><span class="koboSpan" id="kobo.906.1">constexpr if</span></em><span class="koboSpan" id="kobo.907.1"> statements</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-244"><span class="koboSpan" id="kobo.908.1">Conditionally compiling classes and functions with enable_if</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.909.1">Template </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.910.1">metaprogramming is a powerful feature of C++ that enables us to write generic classes and functions that work with any type. </span><span class="koboSpan" id="kobo.910.2">This is a problem sometimes because the language </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.911.1">does not define any mechanism for specifying constraints on the types that can be substituted for the template </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.912.1">parameters. </span><span class="koboSpan" id="kobo.912.2">However, we can still achieve this using metaprogramming tricks and by leveraging a rule called </span><strong class="keyWord"><span class="koboSpan" id="kobo.913.1">substitution failure is not an error</span></strong><span class="koboSpan" id="kobo.914.1">, also</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.915.1"> known as </span><strong class="keyWord"><span class="koboSpan" id="kobo.916.1">SFINAE</span></strong><span class="koboSpan" id="kobo.917.1">. </span><span class="koboSpan" id="kobo.917.2">This rule determines whether the compiler discards, from the overloaded set, a specialization when substituting the explicitly specified or deduced type for the template parameter when it fails, instead of generating an error. </span><span class="koboSpan" id="kobo.917.3">This recipe will focus on implementing type constraints for templates.</span></p>
<h2 class="heading-2" id="_idParaDest-245"><span class="koboSpan" id="kobo.918.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.919.1">Developers have used a class template usually called </span><code class="inlineCode"><span class="koboSpan" id="kobo.920.1">enable_if</span></code><span class="koboSpan" id="kobo.921.1"> for many years in conjunction with SFINAE to implement constraints on template types. </span><span class="koboSpan" id="kobo.921.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.922.1">enable_if</span></code><span class="koboSpan" id="kobo.923.1"> family of templates has become part of the C++11 standard and is implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.924.1">template</span></span><span class="koboSpan" id="kobo.925.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.926.1">bool</span></span><span class="koboSpan" id="kobo.927.1"> Test, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.928.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.929.1">T</span></span><span class="koboSpan" id="kobo.930.1"> = </span><span class="hljs-type"><span class="koboSpan" id="kobo.931.1">void</span></span><span class="koboSpan" id="kobo.932.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.933.1">struct</span></span><span class="koboSpan" id="kobo.934.1"> enable_if
{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.935.1">template</span></span><span class="koboSpan" id="kobo.936.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.937.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.938.1">T</span></span><span class="koboSpan" id="kobo.939.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.940.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.941.1">enable_if</span></span><span class="koboSpan" id="kobo.942.1">&lt;</span><span class="hljs-literal"><span class="koboSpan" id="kobo.943.1">true</span></span><span class="koboSpan" id="kobo.944.1">, T&gt;
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.945.1">typedef</span></span><span class="koboSpan" id="kobo.946.1"> T type;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.947.1">To be able to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.948.1">std::enable_if</span></code><span class="koboSpan" id="kobo.949.1">, you must include the </span><code class="inlineCode"><span class="koboSpan" id="kobo.950.1">&lt;type_traits&gt;</span></code><span class="koboSpan" id="kobo.951.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-246"><span class="koboSpan" id="kobo.952.1">How to do it...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">std::enable_if</span></code><span class="koboSpan" id="kobo.954.1"> can be used in multiple scopes to achieve different purposes; consider the </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.955.1">following</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.956.1"> examples:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.957.1">On a</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.958.1"> class template parameter to enable a class template only for types that meet a specified condition:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.959.1">template</span></span><span class="koboSpan" id="kobo.960.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.961.1">typename</span></span><span class="koboSpan" id="kobo.962.1"> T,
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.963.1">typename</span></span><span class="koboSpan" id="kobo.964.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.965.1">typename</span></span><span class="koboSpan" id="kobo.966.1">
          std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.967.1">enable_if_t</span></span><span class="koboSpan" id="kobo.968.1">&lt;std::is_standard_layout_v&lt;T&gt;, T&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.969.1">class</span></span><span class="koboSpan" id="kobo.970.1"> pod_wrapper
{
  T value;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.971.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.972.1">point</span></span><span class="koboSpan" id="kobo.973.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.974.1">int</span></span><span class="koboSpan" id="kobo.975.1"> x;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.976.1">int</span></span><span class="koboSpan" id="kobo.977.1"> y;
};
struct foo
{
   virtual int f() const
   {
      return 42;
   }
};
pod_wrapper&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.978.1">int</span></span><span class="koboSpan" id="kobo.979.1">&gt;         w1; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.980.1">// OK</span></span><span class="koboSpan" id="kobo.981.1">
pod_wrapper&lt;point&gt;       w2; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.982.1">// OK</span></span><span class="koboSpan" id="kobo.983.1">
pod_wrapper&lt;std::string&gt; w3; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.984.1">// OK with Clang and GCC</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.985.1">                             // error with MSVC</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.986.1">                             // too few template arguments</span></span><span class="koboSpan" id="kobo.987.1">
pod_wrapper&lt;foo&gt;         w4; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.988.1">// error</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.989.1">On a </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.990.1">function template </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.991.1">parameter, function parameter, or function return type to enable a function template only for types that meet a specified condition:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.992.1">template</span></span><span class="koboSpan" id="kobo.993.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.994.1">typename</span></span><span class="koboSpan" id="kobo.995.1"> T,
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.996.1">typename</span></span><span class="koboSpan" id="kobo.997.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.998.1">typename</span></span><span class="koboSpan" id="kobo.999.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1000.1">enable_if_t</span></span><span class="koboSpan" id="kobo.1001.1">&lt;std::is_integral_v&lt;T&gt;, T&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1002.1">auto</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1003.1">mul</span></span><span class="koboSpan" id="kobo.1004.1">(T </span><span class="hljs-type"><span class="koboSpan" id="kobo.1005.1">const</span></span><span class="koboSpan" id="kobo.1006.1"> a, T </span><span class="hljs-type"><span class="koboSpan" id="kobo.1007.1">const</span></span><span class="koboSpan" id="kobo.1008.1"> b)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1009.1">return</span></span><span class="koboSpan" id="kobo.1010.1"> a * b;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1011.1">auto</span></span><span class="koboSpan" id="kobo.1012.1"> v1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1013.1">mul</span></span><span class="koboSpan" id="kobo.1014.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1015.1">1</span></span><span class="koboSpan" id="kobo.1016.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1017.1">2</span></span><span class="koboSpan" id="kobo.1018.1">);     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1019.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1020.1">auto</span></span><span class="koboSpan" id="kobo.1021.1"> v2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1022.1">mul</span></span><span class="koboSpan" id="kobo.1023.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1024.1">1.0</span></span><span class="koboSpan" id="kobo.1025.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1026.1">2.0</span></span><span class="koboSpan" id="kobo.1027.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1028.1">// error: no matching overloaded function found</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1029.1">To </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.1030.1">simplify the cluttered code that we end up writing when we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1031.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1032.1">, we can leverage alias templates and define two aliases, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1033.1">EnableIf</span></code><span class="koboSpan" id="kobo.1034.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1035.1">DisableIf</span></code><span class="koboSpan" id="kobo.1036.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1037.1">template</span></span><span class="koboSpan" id="kobo.1038.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1039.1">typename</span></span><span class="koboSpan" id="kobo.1040.1"> Test, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1041.1">typename</span></span><span class="koboSpan" id="kobo.1042.1"> T = </span><span class="hljs-type"><span class="koboSpan" id="kobo.1043.1">void</span></span><span class="koboSpan" id="kobo.1044.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1045.1">using</span></span><span class="koboSpan" id="kobo.1046.1"> EnableIf = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1047.1">typename</span></span><span class="koboSpan" id="kobo.1048.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1049.1">enable_if_t</span></span><span class="koboSpan" id="kobo.1050.1">&lt;Test::value, T&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1051.1">template</span></span><span class="koboSpan" id="kobo.1052.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1053.1">typename</span></span><span class="koboSpan" id="kobo.1054.1"> Test, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1055.1">typename</span></span><span class="koboSpan" id="kobo.1056.1"> T = </span><span class="hljs-type"><span class="koboSpan" id="kobo.1057.1">void</span></span><span class="koboSpan" id="kobo.1058.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1059.1">using</span></span><span class="koboSpan" id="kobo.1060.1"> DisableIf = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1061.1">typename</span></span><span class="koboSpan" id="kobo.1062.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1063.1">enable_if_t</span></span><span class="koboSpan" id="kobo.1064.1">&lt;!Test::value, T&gt;;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1065.1">Based on these alias templates, the following definitions are equivalent to the preceding ones:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1066.1">template</span></span><span class="koboSpan" id="kobo.1067.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1068.1">typename</span></span><span class="koboSpan" id="kobo.1069.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1070.1">typename</span></span><span class="koboSpan" id="kobo.1071.1"> = EnableIf&lt;std::is_standard_layout&lt;T&gt;&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1072.1">class</span></span><span class="koboSpan" id="kobo.1073.1"> pod_wrapper
{
  T value;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1074.1">template</span></span><span class="koboSpan" id="kobo.1075.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1076.1">typename</span></span><span class="koboSpan" id="kobo.1077.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1078.1">typename</span></span><span class="koboSpan" id="kobo.1079.1"> = EnableIf&lt;std::is_integral&lt;T&gt;&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1080.1">auto</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1081.1">mul</span></span><span class="koboSpan" id="kobo.1082.1">(T </span><span class="hljs-type"><span class="koboSpan" id="kobo.1083.1">const</span></span><span class="koboSpan" id="kobo.1084.1"> a, T </span><span class="hljs-type"><span class="koboSpan" id="kobo.1085.1">const</span></span><span class="koboSpan" id="kobo.1086.1"> b)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1087.1">return</span></span><span class="koboSpan" id="kobo.1088.1"> a * b;
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-247"><span class="koboSpan" id="kobo.1089.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1090.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1091.1"> works because the compiler applies the SFINAE rule when performing overload resolution. </span><span class="koboSpan" id="kobo.1091.2">Before we can explain how </span><code class="inlineCode"><span class="koboSpan" id="kobo.1092.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1093.1"> works, we should have a quick look at what SFINAE is.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1094.1">When the </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.1095.1">compiler </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.1096.1">encounters a function call, it needs to build a set of possible overloads and select the best match for the call based on the </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.1097.1">arguments for the function call. </span><span class="koboSpan" id="kobo.1097.2">When building this overload set, the compiler evaluates function templates too, and has to perform a substitution for the specified or deduced types in the template arguments. </span><span class="koboSpan" id="kobo.1097.3">According to SFINAE, when the substitution fails, instead of yielding an error, the compiler should just remove the function template from the overload set and continue.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.1098.1">The standard specifies a list of type and expression errors that are also SFINAE errors. </span><span class="koboSpan" id="kobo.1098.2">These include an attempt to create an array of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1099.1">void</span></code><span class="koboSpan" id="kobo.1100.1"> or an array of size zero, an attempt to create a reference to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1101.1">void</span></code><span class="koboSpan" id="kobo.1102.1">, an attempt to create a function type with a parameter of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1103.1">void</span></code><span class="koboSpan" id="kobo.1104.1">, and an attempt to perform an invalid conversion in a template argument expression or in an expression used in a function declaration. </span><span class="koboSpan" id="kobo.1104.2">For the complete list of exceptions, consult the C++ standard or other resources.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1105.1">Let’s consider the following two overloads of a function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1106.1">func()</span></code><span class="koboSpan" id="kobo.1107.1">. </span><span class="koboSpan" id="kobo.1107.2">The first overload is a function template that has a single argument of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1108.1">T::value_type</span></code><span class="koboSpan" id="kobo.1109.1">; this means it can only be instantiated with types that have an inner type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1110.1">value_type</span></code><span class="koboSpan" id="kobo.1111.1">. </span><span class="koboSpan" id="kobo.1111.2">The second overload is a function that has a single argument of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1112.1">int</span></code><span class="koboSpan" id="kobo.1113.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1114.1">template</span></span><span class="koboSpan" id="kobo.1115.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1116.1">typename</span></span><span class="koboSpan" id="kobo.1117.1"> T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1118.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1119.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1120.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1121.1">typename</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1122.1"> T::value_type </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1123.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1124.1"> a)</span></span><span class="koboSpan" id="kobo.1125.1">
{ std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1126.1">"func&lt;&gt;"</span></span><span class="koboSpan" id="kobo.1127.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1128.1">'\n'</span></span><span class="koboSpan" id="kobo.1129.1">; }
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1130.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1131.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1132.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1133.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1134.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1135.1"> a)</span></span><span class="koboSpan" id="kobo.1136.1">
{ std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1137.1">"func"</span></span><span class="koboSpan" id="kobo.1138.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1139.1">'\n'</span></span><span class="koboSpan" id="kobo.1140.1">; }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1141.1">template</span></span><span class="koboSpan" id="kobo.1142.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1143.1">typename</span></span><span class="koboSpan" id="kobo.1144.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1145.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1146.1">some_type</span></span><span class="koboSpan" id="kobo.1147.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1148.1">using</span></span><span class="koboSpan" id="kobo.1149.1"> value_type = T;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1150.1">If the </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.1151.1">compiler encounters a call such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1152.1">func(42)</span></code><span class="koboSpan" id="kobo.1153.1">, then it must find an overload that can take an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1154.1">int</span></code><span class="koboSpan" id="kobo.1155.1"> argument. </span><span class="koboSpan" id="kobo.1155.2">When it builds the overload set and substitutes the template parameter with the provided template </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.1156.1">argument, the result, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1157.1">void func(int::value_type const)</span></code><span class="koboSpan" id="kobo.1158.1">, is invalid, because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1159.1">int</span></code><span class="koboSpan" id="kobo.1160.1"> does not have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1161.1">value_type</span></code><span class="koboSpan" id="kobo.1162.1"> member. </span><span class="koboSpan" id="kobo.1162.2">Due to SFINAE, the compiler will not emit an error and stop but will simply ignore the overload and continue. </span><span class="koboSpan" id="kobo.1162.3">It then finds </span><code class="inlineCode"><span class="koboSpan" id="kobo.1163.1">void func(int const)</span></code><span class="koboSpan" id="kobo.1164.1">, and that will be the best (and only) match that it will call.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1165.1">If the </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.1166.1">compiler encounters a call such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1167.1">func&lt;some_type&lt;int&gt;&gt;(42)</span></code><span class="koboSpan" id="kobo.1168.1">, then it builds an overload set containing </span><code class="inlineCode"><span class="koboSpan" id="kobo.1169.1">void func(some_type&lt;int&gt;::value_type const&gt;</span></code><span class="koboSpan" id="kobo.1170.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1171.1">void func(int const)</span></code><span class="koboSpan" id="kobo.1172.1">, and the best match, in this case, is the first overload; no SFINAE is involved this time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1173.1">On the other hand, if the compiler encounters a call such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1174.1">func("string"s)</span></code><span class="koboSpan" id="kobo.1175.1">, then it again relies on SFINAE to ignore the function template, because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1176.1">std::basic_string</span></code><span class="koboSpan" id="kobo.1177.1"> does not have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1178.1">value_type</span></code><span class="koboSpan" id="kobo.1179.1"> member either. </span><span class="koboSpan" id="kobo.1179.2">This time, however, the overload set does not contain any match for the string argument; therefore, the program is ill-formed and the compiler emits an error and stops.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1180.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1181.1">enable_if&lt;bool, T&gt;</span></code><span class="koboSpan" id="kobo.1182.1"> class template does not have any members, but its partial specialization, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1183.1">enable_if&lt;true, T</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1184.1">&gt;</span></code><span class="koboSpan" id="kobo.1185.1">, does have an inner type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1186.1">type</span></code><span class="koboSpan" id="kobo.1187.1">, which is a synonym for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1188.1">T</span></code><span class="koboSpan" id="kobo.1189.1">. </span><span class="koboSpan" id="kobo.1189.2">When the compile-time expression supplied as the first argument to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1190.1">enable_if</span></code><span class="koboSpan" id="kobo.1191.1"> evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1192.1">true</span></code><span class="koboSpan" id="kobo.1193.1">, the inner member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1194.1">type</span></code><span class="koboSpan" id="kobo.1195.1"> is available; otherwise, it is not.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1196.1">Considering the last definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1197.1">mul()</span></code><span class="koboSpan" id="kobo.1198.1"> function from the </span><em class="italic"><span class="koboSpan" id="kobo.1199.1">How to do it...</span></em><span class="koboSpan" id="kobo.1200.1"> section, when the compiler encounters a call such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1201.1">mul(1, 2)</span></code><span class="koboSpan" id="kobo.1202.1">, it tries to substitute </span><code class="inlineCode"><span class="koboSpan" id="kobo.1203.1">int</span></code><span class="koboSpan" id="kobo.1204.1"> for the template parameter, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1205.1">T</span></code><span class="koboSpan" id="kobo.1206.1">; since </span><code class="inlineCode"><span class="koboSpan" id="kobo.1207.1">int</span></code><span class="koboSpan" id="kobo.1208.1"> is an integral type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1209.1">std::is_integral&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1210.1"> evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1211.1">true</span></code><span class="koboSpan" id="kobo.1212.1"> and, therefore, a specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1213.1">enable_if</span></code><span class="koboSpan" id="kobo.1214.1"> that defines an inner type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1215.1">type</span></code><span class="koboSpan" id="kobo.1216.1"> is instantiated. </span><span class="koboSpan" id="kobo.1216.2">As a result, the alias template </span><code class="inlineCode"><span class="koboSpan" id="kobo.1217.1">EnableIf</span></code><span class="koboSpan" id="kobo.1218.1"> becomes a synonym for this type, which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1219.1">void</span></code><span class="koboSpan" id="kobo.1220.1"> (from the expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.1221.1">typename T = void</span></code><span class="koboSpan" id="kobo.1222.1">). </span><span class="koboSpan" id="kobo.1222.2">The result is a function template, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1223.1">int mul&lt;int, void&gt;(int a, int b)</span></code><span class="koboSpan" id="kobo.1224.1">, that can be called with the supplied arguments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1225.1">On the other hand, when the compiler encounters a call such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1226.1">mul(1.0, 2.0)</span></code><span class="koboSpan" id="kobo.1227.1">, it tries to substitute </span><code class="inlineCode"><span class="koboSpan" id="kobo.1228.1">double</span></code><span class="koboSpan" id="kobo.1229.1"> for the template parameter, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1230.1">T</span></code><span class="koboSpan" id="kobo.1231.1">. </span><span class="koboSpan" id="kobo.1231.2">However, this is not an integral type; as a result, the condition in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1232.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1233.1"> evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1234.1">false</span></code><span class="koboSpan" id="kobo.1235.1"> and the class template does not define an inner member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1236.1">type</span></code><span class="koboSpan" id="kobo.1237.1">. </span><span class="koboSpan" id="kobo.1237.2">This results in a substitution error, but according to </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.1238.1">SFINAE, the compiler will not emit</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.1239.1"> an error but move on. </span><span class="koboSpan" id="kobo.1239.2">However, since no other overload is found, there will be no </span><code class="inlineCode"><span class="koboSpan" id="kobo.1240.1">mul()</span></code><span class="koboSpan" id="kobo.1241.1"> function that can be called. </span><span class="koboSpan" id="kobo.1241.2">Therefore, the program is considered ill-formed and the compiler stops with an error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1242.1">A similar situation is encountered with the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.1243.1">pod_wrapper</span></code><span class="koboSpan" id="kobo.1244.1">. </span><span class="koboSpan" id="kobo.1244.2">It has two template </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.1245.1">type parameters: the first is the actual POD type that is being wrapped, while the second is the result of the substitution of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1246.1">enable_if</span></code><span class="koboSpan" id="kobo.1247.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1248.1">is_standard_layout</span></code><span class="koboSpan" id="kobo.1249.1">. </span><span class="koboSpan" id="kobo.1249.2">If the type is a POD type (as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1250.1">pod_wrapper&lt;int&gt;</span></code><span class="koboSpan" id="kobo.1251.1">), then the inner member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1252.1">type</span></code><span class="koboSpan" id="kobo.1253.1"> from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1254.1">enable_if</span></code><span class="koboSpan" id="kobo.1255.1"> exists and it substitutes the second template type parameter. </span><span class="koboSpan" id="kobo.1255.2">However, if the inner member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1256.1">type</span></code><span class="koboSpan" id="kobo.1257.1"> is not a POD type (as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1258.1">pod_wrapper&lt;std::string&gt;</span></code><span class="koboSpan" id="kobo.1259.1">), then the inner member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1260.1">type</span></code><span class="koboSpan" id="kobo.1261.1"> is not defined, and the substitution fails, producing an error such as </span><em class="italic"><span class="koboSpan" id="kobo.1262.1">too few template arguments</span></em><span class="koboSpan" id="kobo.1263.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-248"><span class="koboSpan" id="kobo.1264.1">There’s more...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1265.1">static_assert</span></code><span class="koboSpan" id="kobo.1266.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1267.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1268.1"> can be used to achieve the same goals. </span><span class="koboSpan" id="kobo.1268.2">In fact, in the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.1269.1">Performing compile-time assertion checks with static_assert</span></em><span class="koboSpan" id="kobo.1270.1">, we defined the same class template, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1271.1">pod_wrapper</span></code><span class="koboSpan" id="kobo.1272.1">, and function template, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1273.1">mul()</span></code><span class="koboSpan" id="kobo.1274.1">. </span><span class="koboSpan" id="kobo.1274.2">For these examples, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1275.1">static_assert</span></code><span class="koboSpan" id="kobo.1276.1"> seems like a better solution because the compiler emits better error messages (provided that you specify relevant messages in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1277.1">static_assert</span></code><span class="koboSpan" id="kobo.1278.1"> declaration). </span><span class="koboSpan" id="kobo.1278.2">These two, however, work quite differently and are not intended as alternatives.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1279.1">static_assert</span></code><span class="koboSpan" id="kobo.1280.1"> does not rely on SFINAE and is applied after overload resolution is performed. </span><span class="koboSpan" id="kobo.1280.2">The result of a failed assert is a compiler error. </span><span class="koboSpan" id="kobo.1280.3">On the other hand, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1281.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1282.1"> is used to remove candidates from the overload set and does not trigger compiler errors (given that the exceptions the standard specifies for SFINAE do not occur). </span><span class="koboSpan" id="kobo.1282.2">The actual error that can occur after SFINAE is an empty overload set that makes a program ill-formed. </span><span class="koboSpan" id="kobo.1282.3">This is because a particular function call cannot be performed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1283.1">To understand the difference between </span><code class="inlineCode"><span class="koboSpan" id="kobo.1284.1">static_assert</span></code><span class="koboSpan" id="kobo.1285.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1286.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1287.1"> with SFINAE, let’s consider a case where we want to have two function overloads: one that should be called for arguments of integral types and one for arguments of any type other than integral types. </span><span class="koboSpan" id="kobo.1287.2">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.1288.1">static_assert</span></code><span class="koboSpan" id="kobo.1289.1">, we can write the following (note that the </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.1290.1">dummy </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.1291.1">second type parameter on the second overload is necessary to define two different overloads; otherwise, we would just have two definitions of the same function):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1292.1">template</span></span><span class="koboSpan" id="kobo.1293.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1294.1">typename</span></span><span class="koboSpan" id="kobo.1295.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1296.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1297.1">compute</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1298.1">(T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1299.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1300.1"> a, T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1301.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1302.1"> b)</span></span><span class="koboSpan" id="kobo.1303.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1304.1">static_assert</span></span><span class="koboSpan" id="kobo.1305.1">(std::is_integral_v&lt;T&gt;, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1306.1">"An integral type expected"</span></span><span class="koboSpan" id="kobo.1307.1">);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1308.1">return</span></span><span class="koboSpan" id="kobo.1309.1"> a + b;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1310.1">template</span></span><span class="koboSpan" id="kobo.1311.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1312.1">typename</span></span><span class="koboSpan" id="kobo.1313.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1314.1">typename</span></span><span class="koboSpan" id="kobo.1315.1"> = </span><span class="hljs-type"><span class="koboSpan" id="kobo.1316.1">void</span></span><span class="koboSpan" id="kobo.1317.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1318.1">auto</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1319.1">compute</span></span><span class="koboSpan" id="kobo.1320.1">(T </span><span class="hljs-type"><span class="koboSpan" id="kobo.1321.1">const</span></span><span class="koboSpan" id="kobo.1322.1"> a, T </span><span class="hljs-type"><span class="koboSpan" id="kobo.1323.1">const</span></span><span class="koboSpan" id="kobo.1324.1"> b)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1325.1">static_assert</span></span><span class="koboSpan" id="kobo.1326.1">(!std::is_integral_v&lt;T&gt;, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1327.1">"A non-integral type expected"</span></span><span class="koboSpan" id="kobo.1328.1">);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1329.1">return</span></span><span class="koboSpan" id="kobo.1330.1"> a * b;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1331.1">auto</span></span><span class="koboSpan" id="kobo.1332.1"> v1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1333.1">compute</span></span><span class="koboSpan" id="kobo.1334.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1335.1">1</span></span><span class="koboSpan" id="kobo.1336.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1337.1">2</span></span><span class="koboSpan" id="kobo.1338.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1339.1">// error: ambiguous call to overloaded function</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1340.1">auto</span></span><span class="koboSpan" id="kobo.1341.1"> v2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1342.1">compute</span></span><span class="koboSpan" id="kobo.1343.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1344.1">1.0</span></span><span class="koboSpan" id="kobo.1345.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1346.1">2.0</span></span><span class="koboSpan" id="kobo.1347.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1348.1">// error: ambiguous call to overloaded function</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1349.1">Regardless </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.1350.1">of how we try to call this function, we end up with an error, because the compiler finds two overloads that it could potentially call. </span><span class="koboSpan" id="kobo.1350.2">This is because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1351.1">static_assert</span></code><span class="koboSpan" id="kobo.1352.1"> is only considered after the overload resolution has been resolved, which, in this case, builds a set of two possible candidates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1353.1">The solution to this problem is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1354.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1355.1"> and SFINAE. </span><span class="koboSpan" id="kobo.1355.2">We use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1356.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1357.1"> via the alias templates </span><code class="inlineCode"><span class="koboSpan" id="kobo.1358.1">EnableIf</span></code><span class="koboSpan" id="kobo.1359.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1360.1">DisableIf</span></code><span class="koboSpan" id="kobo.1361.1"> defined previously on a template parameter (although we still use the dummy template parameter on the second overload to introduce two different definitions). </span><span class="koboSpan" id="kobo.1361.2">The following example shows the two overloads rewritten. </span><span class="koboSpan" id="kobo.1361.3">The first overload is enabled only for integral types, while the second is disabled for integral types:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1362.1">template</span></span><span class="koboSpan" id="kobo.1363.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1364.1">typename</span></span><span class="koboSpan" id="kobo.1365.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1366.1">typename</span></span><span class="koboSpan" id="kobo.1367.1"> = EnableIf&lt;std::is_integral&lt;T&gt;&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1368.1">auto</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1369.1">compute</span></span><span class="koboSpan" id="kobo.1370.1">(T </span><span class="hljs-type"><span class="koboSpan" id="kobo.1371.1">const</span></span><span class="koboSpan" id="kobo.1372.1"> a, T </span><span class="hljs-type"><span class="koboSpan" id="kobo.1373.1">const</span></span><span class="koboSpan" id="kobo.1374.1"> b)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1375.1">return</span></span><span class="koboSpan" id="kobo.1376.1"> a * b;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1377.1">template</span></span><span class="koboSpan" id="kobo.1378.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1379.1">typename</span></span><span class="koboSpan" id="kobo.1380.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1381.1">typename</span></span><span class="koboSpan" id="kobo.1382.1"> = DisableIf&lt;std::is_integral&lt;T&gt;&gt;,
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1383.1">typename</span></span><span class="koboSpan" id="kobo.1384.1"> = </span><span class="hljs-type"><span class="koboSpan" id="kobo.1385.1">void</span></span><span class="koboSpan" id="kobo.1386.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1387.1">auto</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1388.1">compute</span></span><span class="koboSpan" id="kobo.1389.1">(T </span><span class="hljs-type"><span class="koboSpan" id="kobo.1390.1">const</span></span><span class="koboSpan" id="kobo.1391.1"> a, T </span><span class="hljs-type"><span class="koboSpan" id="kobo.1392.1">const</span></span><span class="koboSpan" id="kobo.1393.1"> b)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1394.1">return</span></span><span class="koboSpan" id="kobo.1395.1"> a + b;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1396.1">auto</span></span><span class="koboSpan" id="kobo.1397.1"> v1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1398.1">compute</span></span><span class="koboSpan" id="kobo.1399.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1400.1">1</span></span><span class="koboSpan" id="kobo.1401.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1402.1">2</span></span><span class="koboSpan" id="kobo.1403.1">);     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1404.1">// OK; v1 = 2</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1405.1">auto</span></span><span class="koboSpan" id="kobo.1406.1"> v2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1407.1">compute</span></span><span class="koboSpan" id="kobo.1408.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1409.1">1.0</span></span><span class="koboSpan" id="kobo.1410.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1411.1">2.0</span></span><span class="koboSpan" id="kobo.1412.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1413.1">// OK; v2 = 3.0</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1414.1">With </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.1415.1">SFINAE at work, when </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.1416.1">the</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.1417.1"> compiler builds the overload set for either </span><code class="inlineCode"><span class="koboSpan" id="kobo.1418.1">compute(1, 2)</span></code><span class="koboSpan" id="kobo.1419.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1420.1">compute(1.0, 2.0);</span></code><span class="koboSpan" id="kobo.1421.1">, it will simply discard the overload that produces a substitution failure and move on, where in each case we’ll end up with an overload set containing a single candidate.</span></p>
<h2 class="heading-2" id="_idParaDest-249"><span class="koboSpan" id="kobo.1422.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1423.1">Performing compile-time assertion checks with static_assert</span></em><span class="koboSpan" id="kobo.1424.1">, to learn how to define assertions that are verified at compile time</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.1425.1">Chapter 1</span></em><span class="koboSpan" id="kobo.1426.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1427.1">Creating type aliases and alias templates</span></em><span class="koboSpan" id="kobo.1428.1">, to learn about aliases for types</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-250"><span class="koboSpan" id="kobo.1429.1">Selecting branches at compile time with constexpr if</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1430.1">In the</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.1431.1"> previous recipes, we saw how we</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.1432.1"> can impose restrictions on types and functions using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1433.1">static_assert</span></code><span class="koboSpan" id="kobo.1434.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1435.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1436.1"> and how these two are different. </span><span class="koboSpan" id="kobo.1436.2">Template metaprogramming can become complicated and cluttered when we use SFINAE and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1437.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1438.1"> to define function overloads or when we write variadic function templates. </span><span class="koboSpan" id="kobo.1438.2">A new feature of C++17 is intended to simplify such code; it is called </span><em class="italic"><span class="koboSpan" id="kobo.1439.1">constexpr if</span></em><span class="koboSpan" id="kobo.1440.1">, and it defines an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1441.1">if</span></code><span class="koboSpan" id="kobo.1442.1"> statement with a condition that is evaluated at compile time, resulting in the compiler selecting the body of a branch or another in the translation unit. </span><span class="koboSpan" id="kobo.1442.2">Typical usage of </span><em class="italic"><span class="koboSpan" id="kobo.1443.1">constexpr if</span></em><span class="koboSpan" id="kobo.1444.1"> is for simplification of variadic templates and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1445.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1446.1">-based code.</span></p>
<h2 class="heading-2" id="_idParaDest-251"><span class="koboSpan" id="kobo.1447.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1448.1">In this</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.1449.1"> recipe, we will refer to and simplify </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.1450.1">the code written in two previous recipes. </span><span class="koboSpan" id="kobo.1450.2">Before continuing with this recipe, you should take a moment to go back and review the code we have written in the previous recipes, as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1451.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1452.1">compute()</span></code><span class="koboSpan" id="kobo.1453.1"> overloads for integral and non-integral types from the </span><em class="italic"><span class="koboSpan" id="kobo.1454.1">Conditionally compiling classes and functions with enable_if</span></em><span class="koboSpan" id="kobo.1455.1"> recipe.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1456.1">User-defined 8-bit, 16-bit, and 32-bit binary literals from the </span><em class="italic"><span class="koboSpan" id="kobo.1457.1">Creating raw user-defined literals</span></em><span class="koboSpan" id="kobo.1458.1"> recipe of </span><em class="chapterRef"><span class="koboSpan" id="kobo.1459.1">Chapter 2</span></em><span class="koboSpan" id="kobo.1460.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1461.1">Working with Numbers and Strings</span></em><span class="koboSpan" id="kobo.1462.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1463.1">These implementations have several issues:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1464.1">They are hard to read. </span><span class="koboSpan" id="kobo.1464.2">There is a lot of focus on the template declaration, yet the body of the functions is very simple, for instance. </span><span class="koboSpan" id="kobo.1464.3">The biggest problem, though, is that it requires greater attention from developers because it is cluttered with complicated declarations, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1465.1">typename = std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type</span></code><span class="koboSpan" id="kobo.1466.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1467.1">There is too much code. </span><span class="koboSpan" id="kobo.1467.2">The end purpose of the first example is to have a generic function that behaves differently for different types, yet we had to write two overloads for the function; moreover, to differentiate the two, we had to use an extra, unused, template parameter. </span><span class="koboSpan" id="kobo.1467.3">In the second example, the purpose was to build an integer value out of characters </span><code class="inlineCode"><span class="koboSpan" id="kobo.1468.1">'0'</span></code><span class="koboSpan" id="kobo.1469.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1470.1">'1'</span></code><span class="koboSpan" id="kobo.1471.1">, yet we had to write one class template and three specializations to make it happen.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1472.1">It requires advanced template metaprogramming skills, which shouldn’t be necessary for doing something this simple.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1473.1">The syntax for </span><em class="italic"><span class="koboSpan" id="kobo.1474.1">constexpr if</span></em><span class="koboSpan" id="kobo.1475.1"> is very similar to regular </span><code class="inlineCode"><span class="koboSpan" id="kobo.1476.1">if</span></code><span class="koboSpan" id="kobo.1477.1"> statements and requires the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1478.1">constexpr</span></code><span class="koboSpan" id="kobo.1479.1"> keyword before the condition. </span><span class="koboSpan" id="kobo.1479.2">The general form is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1480.1">if</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1481.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.1482.1">(init-statement condition)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1483.1"> statement-</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1484.1">true</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1485.1">else</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1486.1"> statement-</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.1487.1">false</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1488.1">Notice that in this form, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1489.1">init-statement</span></code><span class="koboSpan" id="kobo.1490.1"> is optional.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1491.1">In the following section, we’ll explore several use cases for conditional compilation with </span><em class="italic"><span class="koboSpan" id="kobo.1492.1">constexpr if</span></em><span class="koboSpan" id="kobo.1493.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-252"><span class="koboSpan" id="kobo.1494.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1495.1">Use </span><em class="italic"><span class="koboSpan" id="kobo.1496.1">constexpr if</span></em><span class="koboSpan" id="kobo.1497.1"> statements</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.1498.1"> to do the</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.1499.1"> following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1500.1">To avoid using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1501.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1502.1"> and relying on SFINAE to impose restrictions on function template types and conditionally compile code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1503.1">template</span></span><span class="koboSpan" id="kobo.1504.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1505.1">typename</span></span><span class="koboSpan" id="kobo.1506.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1507.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1508.1">value_of</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1509.1">(T value)</span></span><span class="koboSpan" id="kobo.1510.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1511.1">if</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1512.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.1513.1">(std::is_pointer_v&lt;T&gt;)</span></span>
<span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1514.1">return</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1515.1"> *value</span></span><span class="koboSpan" id="kobo.1516.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1517.1">else</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1518.1">return</span></span><span class="koboSpan" id="kobo.1519.1"> value;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1520.1">To simplify writing variadic templates and implement metaprogramming compile-time recursion:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1521.1">namespace</span></span><span class="koboSpan" id="kobo.1522.1"> binary
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1523.1">using</span></span><span class="koboSpan" id="kobo.1524.1"> byte8 = </span><span class="hljs-type"><span class="koboSpan" id="kobo.1525.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1526.1">char</span></span><span class="koboSpan" id="kobo.1527.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1528.1">namespace</span></span><span class="koboSpan" id="kobo.1529.1"> binary_literals
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1530.1">namespace</span></span><span class="koboSpan" id="kobo.1531.1"> binary_literals_internals
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1532.1">template</span></span><span class="koboSpan" id="kobo.1533.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1534.1">typename</span></span><span class="koboSpan" id="kobo.1535.1"> CharT, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1536.1">char</span></span><span class="koboSpan" id="kobo.1537.1"> d, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1538.1">char</span></span><span class="koboSpan" id="kobo.1539.1">... </span><span class="koboSpan" id="kobo.1539.2">bits&gt;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1540.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1541.1"> CharT </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1542.1">binary_eval</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1543.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1544.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1545.1">if</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1546.1">constexpr</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1547.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1548.1">sizeof</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1549.1">...(bits) == </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1550.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1551.1">)</span></span>
<span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1552.1">return</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1553.1">static_cast</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1554.1">&lt;CharT&gt;</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1555.1">(d-</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1556.1">'0'</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1557.1">)</span></span><span class="koboSpan" id="kobo.1558.1">;
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1559.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1560.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1561.1">constexpr</span></span><span class="koboSpan" id="kobo.1562.1">(d == </span><span class="hljs-string"><span class="koboSpan" id="kobo.1563.1">'0'</span></span><span class="koboSpan" id="kobo.1564.1">)
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1565.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1566.1">binary_eval</span></span><span class="koboSpan" id="kobo.1567.1">&lt;CharT, bits...&gt;();
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1568.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1569.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1570.1">constexpr</span></span><span class="koboSpan" id="kobo.1571.1">(d == </span><span class="hljs-string"><span class="koboSpan" id="kobo.1572.1">'1'</span></span><span class="koboSpan" id="kobo.1573.1">)
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1574.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1575.1">static_cast</span></span><span class="koboSpan" id="kobo.1576.1">&lt;CharT&gt;(
            (</span><span class="hljs-number"><span class="koboSpan" id="kobo.1577.1">1</span></span><span class="koboSpan" id="kobo.1578.1"> &lt;&lt; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1579.1">sizeof</span></span><span class="koboSpan" id="kobo.1580.1">...(bits)) |
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1581.1">binary_eval</span></span><span class="koboSpan" id="kobo.1582.1">&lt;CharT, bits...&gt;());
      }
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1583.1">template</span></span><span class="koboSpan" id="kobo.1584.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1585.1">char</span></span><span class="koboSpan" id="kobo.1586.1">... </span><span class="koboSpan" id="kobo.1586.2">bits&gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1587.1">constexpr</span></span><span class="koboSpan" id="kobo.1588.1"> byte8 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1589.1">operator</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1590.1">""</span></span><span class="koboSpan" id="kobo.1591.1">_b8()
    {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1592.1">static_assert</span></span><span class="koboSpan" id="kobo.1593.1">(
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1594.1">sizeof</span></span><span class="koboSpan" id="kobo.1595.1">...(bits) &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1596.1">8</span></span><span class="koboSpan" id="kobo.1597.1">,
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.1598.1">"binary literal b8 must be up to 8 digits long"</span></span><span class="koboSpan" id="kobo.1599.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1600.1">return</span></span><span class="koboSpan" id="kobo.1601.1"> binary_literals_internals::
                 </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1602.1">binary_eval</span></span><span class="koboSpan" id="kobo.1603.1">&lt;byte8, bits...&gt;();
    }
  }
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-253"><span class="koboSpan" id="kobo.1604.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1605.1">The </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.1606.1">way </span><em class="italic"><span class="koboSpan" id="kobo.1607.1">constexpr if</span></em><span class="koboSpan" id="kobo.1608.1"> works is relatively simple: the condition in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1609.1">if</span></code><span class="koboSpan" id="kobo.1610.1"> statement must be a compile-time expression </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.1611.1">that evaluates or is convertible to a Boolean. </span><span class="koboSpan" id="kobo.1611.2">If the condition is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1612.1">true</span></code><span class="koboSpan" id="kobo.1613.1">, the body of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1614.1">if</span></code><span class="koboSpan" id="kobo.1615.1"> statement is selected, which means it ends up in the translation unit for compilation. </span><span class="koboSpan" id="kobo.1615.2">If the condition is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1616.1">false</span></code><span class="koboSpan" id="kobo.1617.1">, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1618.1">else</span></code><span class="koboSpan" id="kobo.1619.1"> branch, if one is defined, is evaluated. </span><span class="koboSpan" id="kobo.1619.2">Return statements in discarded </span><em class="italic"><span class="koboSpan" id="kobo.1620.1">constexpr if</span></em><span class="koboSpan" id="kobo.1621.1"> branches do not contribute to the function return type deduction.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1622.1">In the first example from the </span><em class="italic"><span class="koboSpan" id="kobo.1623.1">How to do it...</span></em><span class="koboSpan" id="kobo.1624.1"> section, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1625.1">value_of()</span></code><span class="koboSpan" id="kobo.1626.1"> function template has a clean signature. </span><span class="koboSpan" id="kobo.1626.2">The body is also very simple; if the type that is substituted for the template parameter is a pointer type, the compiler will select the first branch (that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1627.1">return *value;</span></code><span class="koboSpan" id="kobo.1628.1">) for code generation and discard the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1629.1">else</span></code><span class="koboSpan" id="kobo.1630.1"> branch. </span><span class="koboSpan" id="kobo.1630.2">For non-pointer types, because the condition evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1631.1">false</span></code><span class="koboSpan" id="kobo.1632.1">, the compiler will select the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1633.1">else</span></code><span class="koboSpan" id="kobo.1634.1"> branch (that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1635.1">return value;</span></code><span class="koboSpan" id="kobo.1636.1">) for code generation and discard the rest. </span><span class="koboSpan" id="kobo.1636.2">This function can be used as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1637.1">auto</span></span><span class="koboSpan" id="kobo.1638.1"> v1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1639.1">value_of</span></span><span class="koboSpan" id="kobo.1640.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1641.1">42</span></span><span class="koboSpan" id="kobo.1642.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1643.1">auto</span></span><span class="koboSpan" id="kobo.1644.1"> p = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1645.1">make_unique</span></span><span class="koboSpan" id="kobo.1646.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1647.1">int</span></span><span class="koboSpan" id="kobo.1648.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1649.1">42</span></span><span class="koboSpan" id="kobo.1650.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1651.1">auto</span></span><span class="koboSpan" id="kobo.1652.1"> v2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1653.1">value_of</span></span><span class="koboSpan" id="kobo.1654.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1655.1">get</span></span><span class="koboSpan" id="kobo.1656.1">());
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1657.1">However, without the help of </span><em class="italic"><span class="koboSpan" id="kobo.1658.1">constexpr if</span></em><span class="koboSpan" id="kobo.1659.1">, we could only implement this using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1660.1">std::enable_if</span></code><span class="koboSpan" id="kobo.1661.1">. </span><span class="koboSpan" id="kobo.1661.2">The following implementation is a more cluttered alternative:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1662.1">template</span></span><span class="koboSpan" id="kobo.1663.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1664.1">typename</span></span><span class="koboSpan" id="kobo.1665.1"> T,
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1666.1">typename</span></span><span class="koboSpan" id="kobo.1667.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1668.1">typename</span></span><span class="koboSpan" id="kobo.1669.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1670.1">enable_if_t</span></span><span class="koboSpan" id="kobo.1671.1">&lt;std::is_pointer_v&lt;T&gt;, T&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1672.1">auto</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1673.1">value_of</span></span><span class="koboSpan" id="kobo.1674.1">(T value)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1675.1">return</span></span><span class="koboSpan" id="kobo.1676.1"> *value;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1677.1">template</span></span><span class="koboSpan" id="kobo.1678.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1679.1">typename</span></span><span class="koboSpan" id="kobo.1680.1"> T,
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1681.1">typename</span></span><span class="koboSpan" id="kobo.1682.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1683.1">typename</span></span><span class="koboSpan" id="kobo.1684.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1685.1">enable_if_t</span></span><span class="koboSpan" id="kobo.1686.1">&lt;!std::is_pointer_v&lt;T&gt;, T&gt;&gt;
T </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1687.1">value_of</span></span><span class="koboSpan" id="kobo.1688.1">(T value)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1689.1">return</span></span><span class="koboSpan" id="kobo.1690.1"> value;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1691.1">As you can see, the </span><em class="italic"><span class="koboSpan" id="kobo.1692.1">constexpr if</span></em><span class="koboSpan" id="kobo.1693.1"> variant is not only shorter but more expressive and easier to read and understand.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1694.1">In the </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.1695.1">second example from the </span><em class="italic"><span class="koboSpan" id="kobo.1696.1">How to do it...</span></em><span class="koboSpan" id="kobo.1697.1"> section, the internal </span><code class="inlineCode"><span class="koboSpan" id="kobo.1698.1">binary_eval()</span></code><span class="koboSpan" id="kobo.1699.1"> helper function is a variadic template function without any parameters; it only has template parameters. </span><span class="koboSpan" id="kobo.1699.2">The function</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.1700.1"> evaluates the first argument and then does something with the rest of the arguments in a recursive manner (but remember this is not a runtime recursion). </span><span class="koboSpan" id="kobo.1700.2">When there is a single character left and the size of the remaining pack is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1701.1">0</span></code><span class="koboSpan" id="kobo.1702.1">, we return the decimal value represented by the character (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1703.1">0</span></code><span class="koboSpan" id="kobo.1704.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1705.1">'0'</span></code><span class="koboSpan" id="kobo.1706.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1707.1">1</span></code><span class="koboSpan" id="kobo.1708.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1709.1">'</span></code><code class="inlineCode"><span class="koboSpan" id="kobo.1710.1">1'</span></code><span class="koboSpan" id="kobo.1711.1">). </span><span class="koboSpan" id="kobo.1711.2">If the current first element is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1712.1">'0'</span></code><span class="koboSpan" id="kobo.1713.1">, we return the value determined by evaluating the rest of the arguments pack, which involves a recursive call. </span><span class="koboSpan" id="kobo.1713.2">If the current first element is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1714.1">'1'</span></code><span class="koboSpan" id="kobo.1715.1">, we return the value by shifting a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1716.1">1</span></code><span class="koboSpan" id="kobo.1717.1"> to the left a number of positions given by the size of the remaining pack bit or the value determined. </span><span class="koboSpan" id="kobo.1717.2">We do this by evaluating the rest of the arguments pack, which again involves a recursive call.</span></p>
<h2 class="heading-2" id="_idParaDest-254"><span class="koboSpan" id="kobo.1718.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1719.1">Conditionally compiling classes and functions with enable_if</span></em><span class="koboSpan" id="kobo.1720.1">, to learn about SFINAE and how to use it to specify type constraints for templates</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-255"><span class="koboSpan" id="kobo.1721.1">Providing metadata to the compiler with attributes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1722.1">C++ has been </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.1723.1">very deficient when it comes to features that enable reflection or introspection on types of data or standard mechanisms to define language extensions. </span><span class="koboSpan" id="kobo.1723.2">Because of that, compilers have defined their own specific extensions for this purpose. </span><span class="koboSpan" id="kobo.1723.3">Examples include the VC++ </span><code class="inlineCode"><span class="koboSpan" id="kobo.1724.1">__declspec()</span></code><span class="koboSpan" id="kobo.1725.1"> specifier and the GCC </span><code class="inlineCode"><span class="koboSpan" id="kobo.1726.1">__attribute__((...))</span></code><span class="koboSpan" id="kobo.1727.1">. </span><span class="koboSpan" id="kobo.1727.2">C++11, however, introduced the </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.1728.1">concept of attributes, which enable compilers to implement extensions in a standard way or even embedded domain-specific languages. </span><span class="koboSpan" id="kobo.1728.2">The newer C++ standards define several attributes all compilers should implement, and that will be the topic of this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-256"><span class="koboSpan" id="kobo.1729.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1730.1">Use standard attributes to provide hints for the compiler about various design goals such as in the scenarios listed here, but not only these:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1731.1">To ensure that the return value from a function cannot be ignored, declare the function with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1732.1">[[nodiscard]]</span></code><span class="koboSpan" id="kobo.1733.1"> attribute. </span><span class="koboSpan" id="kobo.1733.2">In C++20, you can specify a string literal, of the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.1734.1">[[nodiscard(text)]]</span></code><span class="koboSpan" id="kobo.1735.1">, to explain why the result should not be discarded:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1736.1">[[nodiscard]] </span><span class="hljs-type"><span class="koboSpan" id="kobo.1737.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1738.1">get_value1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1739.1">()</span></span><span class="koboSpan" id="kobo.1740.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1741.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1742.1">42</span></span><span class="koboSpan" id="kobo.1743.1">;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1744.1">get_value1</span></span><span class="koboSpan" id="kobo.1745.1">();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1746.1">// warning: ignoring return value of function</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1747.1">//          declared with 'nodiscard' attribute get_value1();</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1748.1">Alternatively, you can declare enumerations and classes used as the return type of a function with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1749.1">[[nodiscard]]</span></code><span class="koboSpan" id="kobo.1750.1"> attribute; in this case, the return value of any function returning such a type cannot be ignored:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1751.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1752.1">class</span></span><span class="koboSpan" id="kobo.1753.1">[[nodiscard]] ReturnCodes{ OK, NoData, Error };
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1754.1">ReturnCodes </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1755.1">get_value2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1756.1">()</span></span><span class="koboSpan" id="kobo.1757.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1758.1">return</span></span><span class="koboSpan" id="kobo.1759.1"> ReturnCodes::OK;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1760.1">struct</span></span><span class="koboSpan" id="kobo.1761.1">[[nodiscard]] Item{};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1762.1">Item </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1763.1">get_value3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1764.1">()</span></span><span class="koboSpan" id="kobo.1765.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1766.1">return</span></span><span class="koboSpan" id="kobo.1767.1"> Item{};
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1768.1">// warning: ignoring return value of function</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1769.1">//          declared with 'nodiscard' attribute</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1770.1">get_value2</span></span><span class="koboSpan" id="kobo.1771.1">();
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1772.1">get_value3</span></span><span class="koboSpan" id="kobo.1773.1">();
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1774.1">To</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.1775.1"> ensure that the usage of functions or types that are considered deprecated is flagged by the compiler</span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.1776.1"> with a warning, declare them with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1777.1">[[deprecated]]</span></code><span class="koboSpan" id="kobo.1778.1"> attribute:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1779.1">[[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1780.1">deprecated</span></span><span class="koboSpan" id="kobo.1781.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1782.1">"Use func2()"</span></span><span class="koboSpan" id="kobo.1783.1">)]] </span><span class="hljs-type"><span class="koboSpan" id="kobo.1784.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1785.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1786.1">()</span></span><span class="koboSpan" id="kobo.1787.1">
{
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1788.1">// warning: 'func' is deprecated : Use func2()</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1789.1">func</span></span><span class="koboSpan" id="kobo.1790.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1791.1">class</span></span><span class="koboSpan" id="kobo.1792.1"> [[deprecated]] foo
{
};
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1793.1">// warning: 'foo' is deprecated</span></span><span class="koboSpan" id="kobo.1794.1">
foo f;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1795.1">To ensure that the compiler does not emit a warning for unused variables, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1796.1">[[maybe_unused]]</span></code><span class="koboSpan" id="kobo.1797.1"> attribute:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1798.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1799.1">run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1800.1">([[maybe_unused]] </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1801.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1802.1"> a, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1803.1">double</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1804.1"> b)</span></span><span class="koboSpan" id="kobo.1805.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1806.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1807.1">2</span></span><span class="koboSpan" id="kobo.1808.1"> * b;
}
[[maybe_unused]] </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1809.1">auto</span></span><span class="koboSpan" id="kobo.1810.1"> i = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1811.1">get_value1</span></span><span class="koboSpan" id="kobo.1812.1">();
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1813.1">To ensure that intentional fall-through case labels in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1814.1">switch</span></code><span class="koboSpan" id="kobo.1815.1"> statement are not flagged by the compiler with a warning, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1816.1">[[fallthrough]]</span></code><span class="koboSpan" id="kobo.1817.1"> attribute:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1818.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1819.1">option1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1820.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1821.1">{}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1822.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1823.1">option2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1824.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1825.1">{}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1826.1">int</span></span><span class="koboSpan" id="kobo.1827.1"> alternative = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1828.1">get_value1</span></span><span class="koboSpan" id="kobo.1829.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1830.1">switch</span></span><span class="koboSpan" id="kobo.1831.1"> (alternative)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1832.1">case</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1833.1">1</span></span><span class="koboSpan" id="kobo.1834.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1835.1">option1</span></span><span class="koboSpan" id="kobo.1836.1">();
    [[fallthrough]]; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1837.1">// this is intentional</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1838.1">case</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1839.1">2</span></span><span class="koboSpan" id="kobo.1840.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1841.1">option2</span></span><span class="koboSpan" id="kobo.1842.1">();
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1843.1">To </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.1844.1">help the compiler optimize</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.1845.1"> paths of execution that are more or less likely to execute, use the C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.1846.1">[[likely]]</span></code><span class="koboSpan" id="kobo.1847.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1848.1">[[unlikely]]</span></code><span class="koboSpan" id="kobo.1849.1"> attributes:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1850.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1851.1">execute_command</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1852.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1853.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1854.1"> cmd)</span></span><span class="koboSpan" id="kobo.1855.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1856.1">switch</span></span><span class="koboSpan" id="kobo.1857.1">(cmd)
  {
    [[likely]]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1858.1">case</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1859.1">'a'</span></span><span class="koboSpan" id="kobo.1860.1">: </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1861.1">/* add */</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1862.1">break</span></span><span class="koboSpan" id="kobo.1863.1">;
    [[unlikely]]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1864.1">case</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1865.1">'d'</span></span><span class="koboSpan" id="kobo.1866.1">: </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1867.1">/* delete */</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1868.1">break</span></span><span class="koboSpan" id="kobo.1869.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1870.1">case</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1871.1">'p'</span></span><span class="koboSpan" id="kobo.1872.1">: </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1873.1">/* print */</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1874.1">break</span></span><span class="koboSpan" id="kobo.1875.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1876.1">default</span></span><span class="koboSpan" id="kobo.1877.1">:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1878.1">/* do something else */</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1879.1">break</span></span><span class="koboSpan" id="kobo.1880.1">;
  }
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1881.1">To help the compiler optimize code based on the user-given assumptions, use the C++23 </span><code class="inlineCode"><span class="koboSpan" id="kobo.1882.1">[[assume]]</span></code><span class="koboSpan" id="kobo.1883.1"> attribute:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1884.1">void</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1885.1">process</span></span><span class="koboSpan" id="kobo.1886.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1887.1">int</span></span><span class="koboSpan" id="kobo.1888.1">* data, size_t len)
{
   [[assume(len &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1889.1">0</span></span><span class="koboSpan" id="kobo.1890.1">)]];
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1891.1">for</span></span><span class="koboSpan" id="kobo.1892.1">(size_t i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1893.1">0</span></span><span class="koboSpan" id="kobo.1894.1">; i &lt; len; ++i)
   {
     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1895.1">// do something with data[i]</span></span><span class="koboSpan" id="kobo.1896.1">
   }
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-257"><span class="koboSpan" id="kobo.1897.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1898.1">Attributes </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.1899.1">are a very flexible feature of C++; they can be used almost everywhere, but the actual usage is specifically defined for each particular attribute. </span><span class="koboSpan" id="kobo.1899.2">They can be used on types, functions, variables, names, code blocks, or entire translation units.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1900.1">Attributes are </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.1901.1">specified between double square brackets (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1902.1">[[attr1]]</span></code><span class="koboSpan" id="kobo.1903.1">), and more than one attribute can be specified in a declaration (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1904.1">[[attr1, attr2, attr3]]</span></code><span class="koboSpan" id="kobo.1905.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1906.1">Attributes can have arguments, for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1907.1">[[mode(greedy)]]</span></code><span class="koboSpan" id="kobo.1908.1">, and can be fully qualified, for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1909.1">[[sys::hidden]]</span></code><span class="koboSpan" id="kobo.1910.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1911.1">[[using sys: visibility(hidden), debug]]</span></code><span class="koboSpan" id="kobo.1912.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1913.1">Attributes can appear either before or after the name of the entity on which they are applied, or both, in which case they are combined. </span><span class="koboSpan" id="kobo.1913.2">The following are several examples that exemplify this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1914.1">// attr1 applies to a, attr2 applies to b</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1915.1">int</span></span><span class="koboSpan" id="kobo.1916.1"> a [[attr1]], b [[attr2]];
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1917.1">// attr1 applies to a and b</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1918.1">int</span></span><span class="koboSpan" id="kobo.1919.1"> [[attr1]] a, b;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1920.1">// attr1 applies to a and b, attr2 applies to a</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1921.1">int</span></span><span class="koboSpan" id="kobo.1922.1"> [[attr1]] a [[attr2]], b;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1923.1">Attributes cannot appear in a namespace declaration, but they can appear as a single-line declaration anywhere in a namespace. </span><span class="koboSpan" id="kobo.1923.2">In this case, it is specific to each attribute whether it applies to the following declaration, to the namespace, or to the translation unit:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1924.1">namespace</span></span><span class="koboSpan" id="kobo.1925.1"> test
{
  [[debug]];
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1926.1">The standard does define several attributes all compilers must implement, and using them can help you write better code. </span><span class="koboSpan" id="kobo.1926.2">We have seen some of them in the examples given in the </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.1927.1">previous section. </span><span class="koboSpan" id="kobo.1927.2">These attributes have </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.1928.1">been defined in different versions of the standard:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1929.1">In C++11:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1930.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1931.1">[[noreturn]]</span></code><span class="koboSpan" id="kobo.1932.1"> attribute indicates that a function does not return.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1933.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1934.1">[[carries_dependency]]</span></code><span class="koboSpan" id="kobo.1935.1"> attribute indicates that the dependency chain in release-consume </span><code class="inlineCode"><span class="koboSpan" id="kobo.1936.1">std::memory_order</span></code><span class="koboSpan" id="kobo.1937.1"> propagates in and out of the function, which allows the compiler to skip unnecessary memory fence instructions.</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1938.1">In C++14:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1939.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1940.1">[[deprecated]]</span></code><span class="koboSpan" id="kobo.1941.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1942.1">[[deprecated("reason")]]</span></code><span class="koboSpan" id="kobo.1943.1"> attributes indicate that the entity declared with these attributes is considered deprecated and should not be used. </span><span class="koboSpan" id="kobo.1943.2">These attributes can be used with classes, non-static data members, typedefs, functions, enumerations, and template specializations. </span><span class="koboSpan" id="kobo.1943.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1944.1">"reason"</span></code><span class="koboSpan" id="kobo.1945.1"> string is an optional parameter.</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1946.1">In C++17:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1947.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1948.1">[[fallthrough]]</span></code><span class="koboSpan" id="kobo.1949.1"> attribute indicates that the fall-through between labels in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1950.1">switch</span></code><span class="koboSpan" id="kobo.1951.1"> statement is intentional. </span><span class="koboSpan" id="kobo.1951.2">The attribute must appear on a line of its own immediately before a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1952.1">case</span></code><span class="koboSpan" id="kobo.1953.1"> label.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1954.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1955.1">[[nodiscard]]</span></code><span class="koboSpan" id="kobo.1956.1"> attribute indicates that a return value from a function cannot be ignored.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1957.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1958.1">[[maybe_unused]]</span></code><span class="koboSpan" id="kobo.1959.1"> attribute indicates that an entity may be unused, but the compiler should not emit a warning about that. </span><span class="koboSpan" id="kobo.1959.2">This attribute can be applied to variables, classes, non-static data members, enumerations, enumerators, and typedefs.</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1960.1">In C++20:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1961.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1962.1">[[nodiscard(text)]]</span></code><span class="koboSpan" id="kobo.1963.1"> attribute is an extension of the C++17 </span><code class="inlineCode"><span class="koboSpan" id="kobo.1964.1">[[nodiscard]]</span></code><span class="koboSpan" id="kobo.1965.1"> attribute and provides text that describes the reason a result should not be discarded.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1966.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1967.1">[[likely]]</span></code><span class="koboSpan" id="kobo.1968.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1969.1">[[unlikely]]</span></code><span class="koboSpan" id="kobo.1970.1"> attributes provide hints for the compiler that a path of execution is more or less likely to execute, therefore allowing it to optimize accordingly. </span><span class="koboSpan" id="kobo.1970.2">They can be applied to statements (but not declarations) and labels, but only one of them, as they are mutually exclusive.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1971.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1972.1">[[no_unique_address]]</span></code><span class="koboSpan" id="kobo.1973.1"> attribute can be applied to non-static data members, excluding bitfields, and tells the compiler that the member does not have to have a unique address. </span><span class="koboSpan" id="kobo.1973.2">When applied to a member that has an empty type, the compiler can optimize it to occupy no space, as in the case of it being an empty base. </span><span class="koboSpan" id="kobo.1973.3">On the other hand, if the member’s type is not empty, the compiler may reuse any ensuing padding to store other data members.</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1974.1">In C++23:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1975.1">[[assume(expr)]]</span></code><span class="koboSpan" id="kobo.1976.1"> indicates that an expression will always evaluate to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1977.1">true</span></code><span class="koboSpan" id="kobo.1978.1">. </span><span class="koboSpan" id="kobo.1978.2">Its purpose is to enable the compiler to perform code optimizations and not to document the preconditions of a function. </span><span class="koboSpan" id="kobo.1978.3">However, the expression is never evaluated. </span><span class="koboSpan" id="kobo.1978.4">An expression that has undefined behavior or throws an exception is evaluated to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1979.1">false</span></code><span class="koboSpan" id="kobo.1980.1">. </span><span class="koboSpan" id="kobo.1980.2">An assumption that does not hold causes undefined behavior; therefore, assumptions should be used judiciously. </span><span class="koboSpan" id="kobo.1980.3">On the other hand, compilers may not use an assumption at all.</span></li>
</ul>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1981.1">Attributes </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.1982.1">are often ignored or briefly </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.1983.1">mentioned in books and tutorials on modern C++ programming, and the reason for that is probably the fact that developers cannot actually write attributes, as this language feature is intended for compiler implementations. </span><span class="koboSpan" id="kobo.1983.2">For some compilers, though, it may be possible to define user-provided attributes; one such compiler is GCC, which supports plugins that add extra features to the compiler, and they can be used for defining new attributes too.</span></p>
<h2 class="heading-2" id="_idParaDest-258"><span class="koboSpan" id="kobo.1984.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.1985.1">Chapter 9</span></em><span class="koboSpan" id="kobo.1986.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1987.1">Using noexcept for functions that do not throw</span></em><span class="koboSpan" id="kobo.1988.1">, to learn how to inform the compiler that a function should not throw exceptions</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1989.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1990.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_04.xhtml"><span class="url"><span class="koboSpan" id="kobo.1991.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1992.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>