<html><head></head><body>
<div><h1 class="chapterNumber">4</h1>
<h1 class="chapterTitle" id="_idParaDest-227">Preprocessing and Compilation</h1>
<p class="normal">In C++, compilation is <a id="_idIndexMarker484"/>the process by which source code is transformed into machine code and organized into object files that are then linked together to produce an executable. The compiler actually works on a single file (called a translation unit) at a time, produced by the preprocessor (the part of the compiler that handles preprocessing directives) from a single source file and all the header files that it includes. This is, however, an oversimplification of what happens when we compile the code. This chapter addresses topics related to preprocessing and compilation, with a focus on various methods to perform conditional compilation, but also touches on other modern topics such as using attributes to provide implementation-defined language extensions.</p>
<p class="normal">The recipes included in this chapter are as follows:</p>
<ul>
<li class="bulletList">Conditionally compiling your source code</li>
<li class="bulletList">Using the indirection pattern for preprocessor stringification and concatenation</li>
<li class="bulletList">Performing compile-time assertion checks with <code class="inlineCode">static_assert</code></li>
<li class="bulletList">Conditionally compiling classes and functions with <code class="inlineCode">enable_if</code></li>
<li class="bulletList">Selecting branches at compile time with <em class="italic">constexpr if</em></li>
<li class="bulletList">Providing metadata to the compiler with attributes</li>
</ul>
<p class="normal">The recipe that we will start this chapter with addresses a very common problem faced by developers, which is compiling only parts of a code base depending on various conditions.</p>
<h1 class="heading-1" id="_idParaDest-228">Conditionally compiling your source code</h1>
<p class="normal">Conditional compilation<a id="_idIndexMarker485"/> is a simple mechanism that enables developers to maintain a single code base, but only consider some parts of the code for compilation to produce different executables, usually in order to run on different platforms or hardware, or depend on different libraries or library versions. Common examples include using or ignoring code based on the compiler, platform (x86, x64, ARM, and so on), configuration (debug or release), or any user-defined specific conditions. In this recipe, we’ll take a look at how conditional compilation works.</p>
<h2 class="heading-2" id="_idParaDest-229">Getting ready</h2>
<p class="normal">Conditional compilation<a id="_idIndexMarker486"/> is a technique used extensively<a id="_idIndexMarker487"/> for many purposes. In this recipe, we will look at several examples and explain how they work. This technique is not in any way limited to these examples. For the scope of this recipe, we will only consider the three major compilers: GCC, Clang, and VC++.</p>
<h2 class="heading-2" id="_idParaDest-230">How to do it...</h2>
<p class="normal">To conditionally<a id="_idIndexMarker488"/> compile portions of code, use the <code class="inlineCode">#if</code>, <code class="inlineCode">#ifdef</code>, and <code class="inlineCode">#ifndef</code> directives (with the <code class="inlineCode">#elif</code>, <code class="inlineCode">#else</code>, and <code class="inlineCode">#endif</code> directives). The general form for conditional compilation is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">#if condition1
  text1
#elif condition2
  text2
#elif condition3
  text3
#else
  text4
#endif
</code></pre>
<p class="normal">Because the conditions here usually imply checking whether a macro is defined or not using the <code class="inlineCode">defined identifier</code> or <code class="inlineCode">defined (identifier)</code> syntax, it’s also possible to use the following forms:</p>
<pre class="programlisting code"><code class="hljs-code">#ifdef identifier1
  text1
#elifdef identifier2
  text2
#endif
#ifndef identifier1
  text1
#elifndef identifier2
  text2
#endif
</code></pre>
<p class="normal">The <code class="inlineCode">#elifdef</code> and <code class="inlineCode">#elifndef</code> directives were introduced in C++23.</p>
<p class="normal">To<a id="_idIndexMarker489"/> define macros for conditional compilation, you can use <a id="_idIndexMarker490"/>either of the following:</p>
<ul>
<li class="bulletList">A <code class="inlineCode">#define</code> directive in your source code:
        <pre class="programlisting code"><code class="hljs-code">#define VERBOSE_PRINTS
#define VERBOSITY_LEVEL 5
</code></pre>
</li>
<li class="bulletList">Compiler command-line options that are specific to each compiler. Examples for the most widely used compilers are as follows:<ul>
<li class="bulletList">For Visual C++, use <code class="inlineCode">/Dname</code> or <code class="inlineCode">/Dname=value</code> (where <code class="inlineCode">/Dname</code> is equivalent to <code class="inlineCode">/Dname=1</code>), for example, <code class="inlineCode">cl /DVERBOSITY_LEVEL=5</code>.</li>
<li class="bulletList">For GCC and Clang, use <code class="inlineCode">-D name</code> or <code class="inlineCode">-D name=value</code> (where <code class="inlineCode">-D name</code> is equivalent to <code class="inlineCode">-D name=1</code>), for example, <code class="inlineCode">gcc -D VERBOSITY_LEVEL=5</code>.</li>
</ul>
</li>
</ul>
<p class="normal">The following are typical<a id="_idIndexMarker491"/> examples of conditional compilation:</p>
<ul>
<li class="bulletList">Header guards to avoid duplicate definitions (due to multiple inclusions of the same header in the same translation unit):
        <pre class="programlisting code"><code class="hljs-code">#ifndef UNIQUE_NAME
#define UNIQUE_NAME
class widget { };
#endif
</code></pre>
</li>
<li class="bulletList">Compiler-specific code for cross-platform applications. The following is an example of printing a message to the console with the name of the compiler:
        <pre class="programlisting code"><code class="hljs-code">void show_compiler()
{
  #if defined _MSC_VER
    std::cout &lt;&lt; "Visual C++\n";
  #elif defined __clang__
    std::cout &lt;&lt; "Clang\n";
  #elif defined __GNUG__
    std::cout &lt;&lt; "GCC\n";
  #else
    std::cout &lt;&lt; "Unknown compiler\n";
  #endif
}
</code></pre>
</li>
<li class="bulletList">Target-specific <a id="_idIndexMarker492"/>code for multiple architectures, for example, for conditionally compiling code for multiple compilers <a id="_idIndexMarker493"/>and architectures:
        <pre class="programlisting code"><code class="hljs-code">void show_architecture()
{
#if defined _MSC_VER
#if defined _M_X64
  std::cout &lt;&lt; "AMD64\n";
#elif defined _M_IX86
  std::cout &lt;&lt; "INTEL x86\n";
#elif defined _M_ARM
  std::cout &lt;&lt; "ARM\n";
#else
  std::cout &lt;&lt; "unknown\n";
#endif
#elif defined __clang__ || __GNUG__
#if defined __amd64__
  std::cout &lt;&lt; "AMD64\n";
#elif defined __i386__
  std::cout &lt;&lt; "INTEL x86\n";
#elif defined __arm__
  std::cout &lt;&lt; "ARM\n";
#else
  std::cout &lt;&lt; "unknown\n";
#endif
#else
#error Unknown compiler
#endif
}
</code></pre>
</li>
<li class="bulletList">Configuration-specific code, for example, for conditionally compiling code for debug and release builds:
        <pre class="programlisting code"><code class="hljs-code">void show_configuration()
{
#ifdef _DEBUG
  std::cout &lt;&lt; "debug\n";
#else
  std::cout &lt;&lt; "release\n";
#endif
}
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker494"/>check whether a language or library <a id="_idIndexMarker495"/>feature is available, use the predefined macros <code class="inlineCode">__cpp_xxx</code> for language features (such as <code class="inlineCode">__cpp_constexpr</code>, <code class="inlineCode">__cpp_constinit</code>, or <code class="inlineCode">__cpp_modules</code>) and <code class="inlineCode">__cpp_lib_xxx</code> for library features (such as <code class="inlineCode">__cpp_lib_concepts</code>, <code class="inlineCode">__cpp_lib_expected</code>, or <code class="inlineCode">__cpp_lib_jthread</code>). The library feature macros were introduced in C++20 and are available in the <code class="inlineCode">&lt;version&gt;</code> header:
        <pre class="programlisting code"><code class="hljs-code">#ifdef __cpp_consteval
#define CONSTEVAL consteval
#else
#define CONSTEVAL constexpr
#endif
CONSTEVAL int twice(int const n)
{
    return n + n;
}
int main()
{
  twice(42);
}
</code></pre>
</li>
<li class="bulletList">To check whether a header or source file is available for inclusion, use the <code class="inlineCode">__has_include</code> directive, which is available in C++17. The following example checks whether the <code class="inlineCode">&lt;optional&gt;</code> header exists:
        <pre class="programlisting code"><code class="hljs-code">#if __has_include(&lt;optional&gt;)
#include &lt;optional&gt;
template&lt;class T&gt; using optional_t = std::optional&lt;T&gt;;
#elif
#include "myoptional.h"
template&lt;class T&gt; using optional_t = my::optional&lt;T&gt;;
#endif
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker496"/>check whether an attribute is supported (as well as from what version), use the <code class="inlineCode">__has_cpp_attribute</code> directive, which <a id="_idIndexMarker497"/>is available in C++20:
        <pre class="programlisting code"><code class="hljs-code">#if defined(__has_cpp_attribute) 
#if __has_cpp_attribute(deprecated)
#define DEPRECATED(msg) [[deprecated(msg)]]
#endif
#endif
DEPRECATED("This function is deprecated.")
void func() {}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-231">How it works...</h2>
<p class="normal">Before discussing <a id="_idIndexMarker498"/>compilation, we should first clarify a term that we will encounter often: <strong class="keyWord">translation unit</strong>. In C++, this is the basic unit of compilation. It is the result of putting together the content of a source file (a <code class="inlineCode">.cpp</code> file) and the entire graph of all the header files included directly or indirectly but without the text excluded with conditional preprocessing statements, as described in this recipe.</p>
<p class="normal">When you use the preprocessing directives <code class="inlineCode">#if</code>, <code class="inlineCode">#ifndef</code>, <code class="inlineCode">#ifdef</code>, <code class="inlineCode">#elif</code>, <code class="inlineCode">#else</code>, and <code class="inlineCode">#endif</code>, the compiler will select, at most, one branch whose body will be included in the translation unit for compilation. The body of these directives can be any text, including other preprocessing directives. The following rules apply:</p>
<ul>
<li class="bulletList"><code class="inlineCode">#if</code>, <code class="inlineCode">#ifdef</code>, and <code class="inlineCode">#ifndef</code> must be matched by an <code class="inlineCode">#endif</code>.</li>
<li class="bulletList">The <code class="inlineCode">#if</code> directive may have multiple <code class="inlineCode">#elif</code> directives, but only one <code class="inlineCode">#else</code>, which must also be the last one before <code class="inlineCode">#endif</code>.</li>
<li class="bulletList"><code class="inlineCode">#if</code>, <code class="inlineCode">#ifdef</code>, <code class="inlineCode">#ifndef</code>, <code class="inlineCode">#elif</code>, <code class="inlineCode">#else</code>, and <code class="inlineCode">#endif</code> can be nested.</li>
<li class="bulletList">The <code class="inlineCode">#if</code> directive requires a constant expression, whereas <code class="inlineCode">#ifdef</code> and <code class="inlineCode">#ifndef</code> require an identifier.</li>
<li class="bulletList">The <code class="inlineCode">defined</code> operator can be used for preprocessor constant expressions, but only in <code class="inlineCode">#if</code> and <code class="inlineCode">#elif</code> directives.</li>
<li class="bulletList"><code class="inlineCode">defined(identifier)</code> is considered <code class="inlineCode">true</code> if <code class="inlineCode">identifier</code> is defined; otherwise, it is considered <code class="inlineCode">false</code>.</li>
<li class="bulletList">An identifier defined as an empty text is considered defined.</li>
<li class="bulletList"><code class="inlineCode">#ifdef identifier</code> is equivalent to <code class="inlineCode">#if defined(identifier)</code>.</li>
<li class="bulletList"><code class="inlineCode">#ifndef identifier</code> is equivalent to <code class="inlineCode">#if !defined(identifier)</code>.</li>
<li class="bulletList"><code class="inlineCode">defined(identifier)</code> and <code class="inlineCode">defined identifier</code> are equivalent.</li>
</ul>
<p class="normal">Header <a id="_idIndexMarker499"/>guards are one of the most common forms of conditional compilation. This technique is used to prevent the content of a header file from being included several times in the same translation unit (although the header is still scanned every time in order to detect what should be included). Therefore, the code in headers is guarded against multiple inclusions in the manner shown in the example given in the previous section. The way this works, considering the given example, is that if the <code class="inlineCode">UNIQUE_NAME</code> macro (this is a generic name from the previous section) is not defined, then the code after the <code class="inlineCode">#if</code> directive, until <code class="inlineCode">#endif</code>, is included in the translation unit and compiled. When that happens, the <code class="inlineCode">UNIQUE_NAME</code> macro is defined with the <code class="inlineCode">#define</code> directive. The next time the header is included in the (same) translation unit, the <code class="inlineCode">UNIQUE_NAME</code> macro is defined and the code in the body of the <code class="inlineCode">#if</code> directive is not included in the translation unit, therefore, it avoids duplicates.</p>
<div><p class="normal">Note that the name of the macro must be unique throughout the application; otherwise, only the code from the first header where the macro is used will be compiled. Code from other headers using the same name will be ignored. Typically, the name of the macro is based on the name of the header file where it is defined.</p>
</div>
<p class="normal">Another important example of conditional compilation is cross-platform code, which needs to account for different compilers and architectures, usually one of Intel x86, AMD64, or ARM. However, the compiler defines its own macros for the possible platforms. The samples from the <em class="italic">How to do it...</em> section show how to conditionally compile code for multiple compilers and architectures.</p>
<div><p class="normal">Note that in the aforementioned example, we only consider a few architectures. In practice, there are multiple macros that can be used to identify the same architecture. Ensure that you read the documentation of each compiler before using these types of macros in your code.</p>
</div>
<p class="normal">Configuration-specific code is also handled with macros and conditional compilation. Compilers such as GCC and Clang do not define any special macros for debug configurations (when the <code class="inlineCode">-g</code> flag is used). Visual C++ does define <code class="inlineCode">_DEBUG</code> for a debug configuration, which was shown in the last example in the <em class="italic">How to do it...</em> section. For the other compilers, you would have to explicitly define a macro to identify such a debug configuration.</p>
<p class="normal">Feature testing <a id="_idIndexMarker500"/>is an important conditional-compilation use case, especially in libraries that provide support for multiple platforms (Windows, Linux, etc.) and compiler versions (C++11, C++14, C++17, etc.). Library implementers often need to check whether a particular language feature or language attribute is available. This is possible with a set of predefined macros that includes the following:</p>
<ul>
<li class="bulletList"><code class="inlineCode">__cplusplus</code>: Indicates the version of the C++ standard that is being used. It expands to one of the following values: <code class="inlineCode">199711L</code> for versions before C++11, <code class="inlineCode">201103L</code> for C++11, <code class="inlineCode">201402L</code> for C++14, <code class="inlineCode">201703L</code> for C++17, and <code class="inlineCode">202002L</code> for C++20. At the time of writing the book, the value for C++23 has not been defined.</li>
<li class="bulletList"><code class="inlineCode">__cpp_xxx</code> macros, for determining whether a language feature is supported. Examples include <code class="inlineCode">__cpp_concepts</code>, <code class="inlineCode">__cpp_consteval</code>, <code class="inlineCode">__cpp_modules</code>, etc.</li>
<li class="bulletList"><code class="inlineCode">__cpp_lib_xxx</code> macros, for determining whether a library feature is supported. Examples include <code class="inlineCode">__cpp_lib_any</code>, <code class="inlineCode">__cpp_lib_optional</code>, <code class="inlineCode">__cpp_lib_constexpr_string</code>, etc. These macros are defined in the <code class="inlineCode">&lt;version&gt;</code> header that was introduced in C++20.</li>
</ul>
<p class="normal">The set of <code class="inlineCode">__cpp_xxx</code> language feature macros and the <code class="inlineCode">__cpp_lib_xxx</code> library feature macros are being expanded with new macros as new features are added. The entire list of macros is too long to be presented here but can be consulted at <a href="https://en.cppreference.com/w/cpp/feature_test">https://en.cppreference.com/w/cpp/feature_test</a>.</p>
<p class="normal">Apart from these macros, there are two directives, <code class="inlineCode">__has_include</code> and <code class="inlineCode">__has_cpp_attribute</code>, that can be used in <code class="inlineCode">#if</code>/<code class="inlineCode">#elif</code> expressions to determine whether a header or source file exists or whether an attribute is supported by the compiler. Together, all these macros and directives are useful tools in determining whether a particular feature is present. They enable us to write code that is portable across platforms and compiler versions.</p>
<h2 class="heading-2" id="_idParaDest-232">There’s more…</h2>
<p class="normal">Sometimes, when<a id="_idIndexMarker501"/> performing conditional compilation, you will want to either display a warning or stop the compilation entirely. This is possible with the help of two diagnostics macros:</p>
<ul>
<li class="bulletList"><code class="inlineCode">#error</code> displays a message to the console and stops the compilation of the program.</li>
<li class="bulletList"><code class="inlineCode">#warning</code>, available since C++23, displays a message to the console without stopping the compilation of the program.</li>
</ul>
<p class="normal">The following snippet shows an example of using these directives:</p>
<pre class="programlisting code"><code class="hljs-code">#ifdef _WIN64
#error "64-bit not supported"
#endif
#if __cplusplus &lt; 201703L
#warning "Consider upgrading to a C++17 compiler"
#endif
</code></pre>
<p class="normal">Although <code class="inlineCode">#warning</code> is only available since C++23, many compilers offer support for this directive as an extension.</p>
<h2 class="heading-2" id="_idParaDest-233">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using the indirection pattern for preprocessor stringification and concatenation</em>, to learn how to transform identifiers into strings and concatenate identifiers together during preprocessing</li>
</ul>
<h1 class="heading-1" id="_idParaDest-234">Using the indirection pattern for preprocessor stringification and concatenation</h1>
<p class="normal">The<a id="_idIndexMarker502"/> C++ preprocessor provides two operators for transforming identifiers into strings and concatenating identifiers together. The first one, operator <code class="inlineCode">#</code>, is called the <strong class="keyWord">stringizing operator</strong>, while <a id="_idIndexMarker503"/>the second <a id="_idIndexMarker504"/>one, operator <code class="inlineCode">##</code>, is called <a id="_idIndexMarker505"/>the <strong class="keyWord">token-pasting</strong>, <strong class="keyWord">merging</strong>, or <strong class="keyWord">concatenating operator</strong>. Although their use is limited to some particular cases, it is<a id="_idIndexMarker506"/> important to understand how they work. </p>
<h2 class="heading-2" id="_idParaDest-235">Getting ready</h2>
<p class="normal">For this recipe, you need to know how to define macros using the preprocessing directive <code class="inlineCode">#define</code>.</p>
<h2 class="heading-2" id="_idParaDest-236">How to do it...</h2>
<p class="normal">To <a id="_idIndexMarker507"/>create a <a id="_idIndexMarker508"/>string from an identifier using the preprocessing operator <code class="inlineCode">#</code>, use the following pattern:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Define a helper macro taking one argument that expands to <code class="inlineCode">#</code>, followed by the argument:
        <pre class="programlisting code"><code class="hljs-code">#define MAKE_STR2(x) #x
</code></pre>
</li>
<li class="numberedList">Define the macro you want to use, taking one argument that expands to the helper macro:
        <pre class="programlisting code"><code class="hljs-code">#define MAKE_STR(x) MAKE_STR2(x)
</code></pre>
</li>
</ol>
<p class="normal">To <a id="_idIndexMarker509"/>concatenate identifiers together using the preprocessing operator <code class="inlineCode">##</code>, use the following pattern:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Define a helper macro with one or more arguments that use the token-pasting operator <code class="inlineCode">##</code> to concatenate arguments:
        <pre class="programlisting code"><code class="hljs-code">#define MERGE2(x, y)    x##y
</code></pre>
</li>
<li class="numberedList">Define the macro you want to use by using the helper macro:
        <pre class="programlisting code"><code class="hljs-code">#define MERGE(x, y)     MERGE2(x, y)
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-237">How it works...</h2>
<p class="normal">To <a id="_idIndexMarker510"/>understand how these work, let’s consider the <code class="inlineCode">MAKE_STR</code> and <code class="inlineCode">MAKE_STR2</code> macros defined earlier. When used with any text, they will produce a string containing that text. The following example shows how both these macros can be used to define strings containing the text <code class="inlineCode">"sample"</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::string s1 { MAKE_STR(sample) };  // s1 = "sample"
std::string s2 { MAKE_STR2(sample) }; // s2 = "sample"
</code></pre>
<p class="normal">On the <a id="_idIndexMarker511"/>other hand, when a macro is passed as an argument, the results are different. In the following example, <code class="inlineCode">NUMBER</code> is a macro that expands to an integer, <code class="inlineCode">42</code>. When used as an <a id="_idIndexMarker512"/>argument to <code class="inlineCode">MAKE_STR</code>, it indeed produces the string <code class="inlineCode">"42"</code>; however, when used as an argument to <code class="inlineCode">MAKE_STR2</code>, it produces the string <code class="inlineCode">"NUMBER"</code>:</p>
<pre class="programlisting code"><code class="hljs-code">#define NUMBER 42
std::string s3 { MAKE_STR(NUMBER) };    // s3 = "42"
std::string s4 { MAKE_STR2(NUMBER) };   // s4 = "NUMBER"
</code></pre>
<p class="normal">The C++ standard defines the following rules for argument substitution in function-like macros (paragraph 15.6.2 from the C++ Standard document number N4917):</p>
<blockquote class="packt_quote">
<p class="quote">After the arguments for the invocation of a function-like macro have been identified, argument substitution takes place. A parameter in the replacement list, unless preceded by a # or ## preprocessing token or followed by a ## preprocessing token (see below), is replaced by the corresponding argument after all the macros contained therein have been expanded. Before being substituted, each argument’s preprocessing tokens are completely macro replaced as if they formed the rest of the preprocessing file; no other preprocessing tokens are available.</p>
</blockquote>
<p class="normal">What this says is that macro arguments are expanded before they are substituted into the macro body, except for the case when the operator <code class="inlineCode">#</code> or <code class="inlineCode">##</code> is preceding or following a parameter in the macro body. As a result, the following happens:</p>
<ul>
<li class="bulletList">For <code class="inlineCode">MAKE_STR2(NUMBER)</code>, the <code class="inlineCode">NUMBER</code> parameter in the replacement list is preceded by <code class="inlineCode">#</code> and, therefore, it is not expanded before substituting the argument in the macro body; therefore, after the substitution, we have <code class="inlineCode">#NUMBER</code>, which becomes <code class="inlineCode">"NUMBER"</code>.</li>
<li class="bulletList">For <code class="inlineCode">MAKE_STR(NUMBER)</code>, the replacement list is <code class="inlineCode">MAKE_STR2(NUMBER)</code>, which has no <code class="inlineCode">#</code> or <code class="inlineCode">##</code>; therefore, the <code class="inlineCode">NUMBER</code> parameter is replaced with its corresponding argument, <code class="inlineCode">42</code>, before being substituted. The result is <code class="inlineCode">MAKE_STR2(42)</code>, which is then scanned again, and, after expansion, it becomes <code class="inlineCode">"42"</code>.</li>
</ul>
<p class="normal">The<a id="_idIndexMarker513"/> same processing rules apply to macros using the token-pasting operator. Therefore, in order to make sure that your stringification and concatenation macros work for all cases, always apply the indirection pattern described in this recipe.</p>
<p class="normal">The<a id="_idIndexMarker514"/> token-pasting operator <a id="_idIndexMarker515"/>is typically used in macros<a id="_idIndexMarker516"/> that factor in repetitive code to avoid writing the same thing explicitly over and over again. The following simple example shows a practical use of the token-pasting operator; given a set of classes, we want to provide factory methods that create an instance of each class:</p>
<pre class="programlisting code"><code class="hljs-code">#define DECL_MAKE(x)    DECL_MAKE2(x)
#define DECL_MAKE2(x)   x* make##_##x() { return new x(); }
struct bar {};
struct foo {};
DECL_MAKE(foo)
DECL_MAKE(bar)
auto f = make_foo(); // f is a foo*
auto b = make_bar(); // b is a bar*
</code></pre>
<p class="normal">Those familiar with the Windows platform have probably used the <code class="inlineCode">_T</code> (or <code class="inlineCode">_TEXT</code>) macro for declaring string literals that are either translated to Unicode or ANSI strings (both single- and multi-type character strings):</p>
<pre class="programlisting code"><code class="hljs-code">auto text{ _T("sample") }; // text is either "sample" or L"sample"
</code></pre>
<p class="normal">The Windows SDK defines the <code class="inlineCode">_T</code> macro as follows. Note that when <code class="inlineCode">_UNICODE</code> is defined, the token-pasting operator is defined to concatenate together the <code class="inlineCode">L</code> prefix and the actual string being passed to the macro:</p>
<pre class="programlisting code"><code class="hljs-code">#ifdef _UNICODE
#define __T(x)   L ## x
#else
#define __T(x)   x
#endif
#define _T(x)    __T(x)
#define _TEXT(x) __T(x)
</code></pre>
<p class="normal">At first <a id="_idIndexMarker517"/>glance, it seems unnecessary to have one macro calling another macro, but this<a id="_idIndexMarker518"/> level of indirection is key for <a id="_idIndexMarker519"/>making the <code class="inlineCode">#</code> and <code class="inlineCode">##</code> operators work with other macros, as we have seen in this recipe.</p>
<h2 class="heading-2" id="_idParaDest-238">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Conditionally compiling your source code</em>, to learn how to compile only parts of your code, depending on various conditions</li>
</ul>
<h1 class="heading-1" id="_idParaDest-239">Performing compile-time assertion checks with static_assert</h1>
<p class="normal">In C++, it is <a id="_idIndexMarker520"/>possible to perform both runtime and compile-time assertion checks to ensure that specific conditions in your code are true. Runtime assertions have the disadvantage that they are verified late <a id="_idIndexMarker521"/>when the program is running, and only if the control flow reaches them. There is no alternative when the condition depends on runtime data; however, when that is not the case, compile-time assertion checks are to be preferred. With compile-time assertions, the compiler is able to notify you early in the development stage with an error that a particular condition has not been met. These, however, can only be used when the condition can be evaluated at compile time. In C++11, compile-time assertions are performed with <code class="inlineCode">static_assert</code>.</p>
<h2 class="heading-2" id="_idParaDest-240">Getting ready</h2>
<p class="normal">The most common use of static assertion checks is with template metaprogramming, where they <a id="_idIndexMarker522"/>can be used for validating that preconditions on template types are met (examples can include whether a <a id="_idIndexMarker523"/>type is a POD type, copy-constructible, a reference type, and so on). Another typical example is to ensure that types (or objects) have an expected size.</p>
<h2 class="heading-2" id="_idParaDest-241">How to do it...</h2>
<p class="normal">Use <code class="inlineCode">static_assert</code> declarations to ensure that conditions in different scopes are met:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Namespace</strong>: In this example, we validate that the size of the class <code class="inlineCode">item</code> is always 16:
        <pre class="programlisting code"><code class="hljs-code">struct alignas(8) item
{
  int      id;
  bool     active;
  double   value;
};
static_assert(sizeof(item) == 16, "size of item must be 16 bytes");
</code></pre>
</li>
<li class="bulletList"><strong class="keyWord">Class</strong>: In this example, we validate that <code class="inlineCode">pod_wrapper</code> can only be used with POD types:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
class pod_wrapper
{
  static_assert(std::is_standard_layout_v&lt;T&gt;, "POD type expected!");
  T value;
};
struct point
{
  int x;
  int y;
};
pod_wrapper&lt;int&gt;         w1; // OK
pod_wrapper&lt;point&gt;       w2; // OK
pod_wrapper&lt;std::string&gt; w3; // error: POD type expected
</code></pre>
</li>
<li class="bulletList"><strong class="keyWord">Block (function)</strong>: In this<a id="_idIndexMarker524"/> example, we validate that a function template has only arguments of an integral type:
        <pre class="programlisting code"><code class="hljs-code">template&lt;typename T&gt;
auto mul(T const a, T const b)
{
  static_assert(std::is_integral_v&lt;T&gt;, "Integral type expected");
  return a * b;
}
auto v1 = mul(1, 2);       // OK
auto v2 = mul(12.0, 42.5); // error: Integral type expected
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-242">How it works...</h2>
<p class="normal"><code class="inlineCode">static_assert</code> is basically a declaration, but it does not introduce a new name. These declarations have the following form:</p>
<pre class="programlisting code"><code class="hljs-code">static_assert(condition, message);
</code></pre>
<p class="normal">The<a id="_idIndexMarker525"/> condition must be convertible to a Boolean value at compile time, and the message must be a string literal. As of C++17, the message is optional.</p>
<p class="normal">When the condition in a <code class="inlineCode">static_assert</code> declaration evaluates to <code class="inlineCode">true</code>, nothing happens. When the condition evaluates to <code class="inlineCode">false</code>, the compiler generates an error that contains the specified message, if any.</p>
<p class="normal">The message argument must be a string literal. However, that changes as of C++26, so that it could be an arbitrary constant expression that produces a sequence of characters. This helps provide better diagnostic messages for users. For instance, assuming there would be a <code class="inlineCode">constexpr</code> <code class="inlineCode">std::format()</code> function, one could write the following:</p>
<pre class="programlisting code"><code class="hljs-code">static_assert(
   sizeof(item) == 16,
   std::format("size of item must be 16 bytes but got {}", sizeof(item)));
</code></pre>
<h2 class="heading-2" id="_idParaDest-243">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Conditionally compiling classes and functions with enable_if</em>, to learn about SFINAE and how to use it to specify type constraints for templates</li>
<li class="bulletList"><em class="chapterRef">Chapter 12</em>, <em class="italic">Specifying requirements on template arguments with concepts</em>, to learn the fundamentals of C++20 concepts and how to use them to specify constraints for template types</li>
<li class="bulletList"><em class="italic">Selecting branches at compile time with constexpr if</em>, to learn how to compile only parts of your code with <em class="italic">constexpr if</em> statements</li>
</ul>
<h1 class="heading-1" id="_idParaDest-244">Conditionally compiling classes and functions with enable_if</h1>
<p class="normal">Template <a id="_idIndexMarker526"/>metaprogramming is a powerful feature of C++ that enables us to write generic classes and functions that work with any type. This is a problem sometimes because the language <a id="_idIndexMarker527"/>does not define any mechanism for specifying constraints on the types that can be substituted for the template <a id="_idIndexMarker528"/>parameters. However, we can still achieve this using metaprogramming tricks and by leveraging a rule called <strong class="keyWord">substitution failure is not an error</strong>, also<a id="_idIndexMarker529"/> known as <strong class="keyWord">SFINAE</strong>. This rule determines whether the compiler discards, from the overloaded set, a specialization when substituting the explicitly specified or deduced type for the template parameter when it fails, instead of generating an error. This recipe will focus on implementing type constraints for templates.</p>
<h2 class="heading-2" id="_idParaDest-245">Getting ready</h2>
<p class="normal">Developers have used a class template usually called <code class="inlineCode">enable_if</code> for many years in conjunction with SFINAE to implement constraints on template types. The <code class="inlineCode">enable_if</code> family of templates has become part of the C++11 standard and is implemented as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;bool Test, class T = void&gt;
struct enable_if
{};
template&lt;class T&gt;
struct enable_if&lt;true, T&gt;
{
  typedef T type;
};
</code></pre>
<p class="normal">To be able to use <code class="inlineCode">std::enable_if</code>, you must include the <code class="inlineCode">&lt;type_traits&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-246">How to do it...</h2>
<p class="normal"><code class="inlineCode">std::enable_if</code> can be used in multiple scopes to achieve different purposes; consider the <a id="_idIndexMarker530"/>following<a id="_idIndexMarker531"/> examples:</p>
<ul>
<li class="bulletList">On a<a id="_idIndexMarker532"/> class template parameter to enable a class template only for types that meet a specified condition:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T,
          typename = typename
          std::enable_if_t&lt;std::is_standard_layout_v&lt;T&gt;, T&gt;&gt;
class pod_wrapper
{
  T value;
};
struct point
{
  int x;
  int y;
};
struct foo
{
   virtual int f() const
   {
      return 42;
   }
};
pod_wrapper&lt;int&gt;         w1; // OK
pod_wrapper&lt;point&gt;       w2; // OK
pod_wrapper&lt;std::string&gt; w3; // OK with Clang and GCC
                             // error with MSVC
                             // too few template arguments
pod_wrapper&lt;foo&gt;         w4; // error
</code></pre>
</li>
<li class="bulletList">On a <a id="_idIndexMarker533"/>function template <a id="_idIndexMarker534"/>parameter, function parameter, or function return type to enable a function template only for types that meet a specified condition:
        <pre class="programlisting code"><code class="hljs-code">template&lt;typename T,
         typename = typename std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, T&gt;&gt;
auto mul(T const a, T const b)
{
  return a * b;
}
auto v1 = mul(1, 2);     // OK
auto v2 = mul(1.0, 2.0); // error: no matching overloaded function found
</code></pre>
</li>
</ul>
<p class="normal">To <a id="_idIndexMarker535"/>simplify the cluttered code that we end up writing when we use <code class="inlineCode">std::enable_if</code>, we can leverage alias templates and define two aliases, called <code class="inlineCode">EnableIf</code> and <code class="inlineCode">DisableIf</code>:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename Test, typename T = void&gt;
using EnableIf = typename std::enable_if_t&lt;Test::value, T&gt;;
template &lt;typename Test, typename T = void&gt;
using DisableIf = typename std::enable_if_t&lt;!Test::value, T&gt;;
</code></pre>
<p class="normal">Based on these alias templates, the following definitions are equivalent to the preceding ones:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, typename = EnableIf&lt;std::is_standard_layout&lt;T&gt;&gt;&gt;
class pod_wrapper
{
  T value;
};
template&lt;typename T, typename = EnableIf&lt;std::is_integral&lt;T&gt;&gt;&gt;
auto mul(T const a, T const b)
{
  return a * b;
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-247">How it works...</h2>
<p class="normal"><code class="inlineCode">std::enable_if</code> works because the compiler applies the SFINAE rule when performing overload resolution. Before we can explain how <code class="inlineCode">std::enable_if</code> works, we should have a quick look at what SFINAE is.</p>
<p class="normal">When the <a id="_idIndexMarker536"/>compiler <a id="_idIndexMarker537"/>encounters a function call, it needs to build a set of possible overloads and select the best match for the call based on the <a id="_idIndexMarker538"/>arguments for the function call. When building this overload set, the compiler evaluates function templates too, and has to perform a substitution for the specified or deduced types in the template arguments. According to SFINAE, when the substitution fails, instead of yielding an error, the compiler should just remove the function template from the overload set and continue.</p>
<div><p class="normal">The standard specifies a list of type and expression errors that are also SFINAE errors. These include an attempt to create an array of <code class="inlineCode">void</code> or an array of size zero, an attempt to create a reference to <code class="inlineCode">void</code>, an attempt to create a function type with a parameter of type <code class="inlineCode">void</code>, and an attempt to perform an invalid conversion in a template argument expression or in an expression used in a function declaration. For the complete list of exceptions, consult the C++ standard or other resources.</p>
</div>
<p class="normal">Let’s consider the following two overloads of a function called <code class="inlineCode">func()</code>. The first overload is a function template that has a single argument of type <code class="inlineCode">T::value_type</code>; this means it can only be instantiated with types that have an inner type called <code class="inlineCode">value_type</code>. The second overload is a function that has a single argument of type <code class="inlineCode">int</code>:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
void func(typename T::value_type const a)
{ std::cout &lt;&lt; "func&lt;&gt;" &lt;&lt; '\n'; }
void func(int const a)
{ std::cout &lt;&lt; "func" &lt;&lt; '\n'; }
template &lt;typename T&gt;
struct some_type
{
  using value_type = T;
};
</code></pre>
<p class="normal">If the <a id="_idIndexMarker539"/>compiler encounters a call such as <code class="inlineCode">func(42)</code>, then it must find an overload that can take an <code class="inlineCode">int</code> argument. When it builds the overload set and substitutes the template parameter with the provided template <a id="_idIndexMarker540"/>argument, the result, <code class="inlineCode">void func(int::value_type const)</code>, is invalid, because <code class="inlineCode">int</code> does not have a <code class="inlineCode">value_type</code> member. Due to SFINAE, the compiler will not emit an error and stop but will simply ignore the overload and continue. It then finds <code class="inlineCode">void func(int const)</code>, and that will be the best (and only) match that it will call.</p>
<p class="normal">If the <a id="_idIndexMarker541"/>compiler encounters a call such as <code class="inlineCode">func&lt;some_type&lt;int&gt;&gt;(42)</code>, then it builds an overload set containing <code class="inlineCode">void func(some_type&lt;int&gt;::value_type const&gt;</code> and <code class="inlineCode">void func(int const)</code>, and the best match, in this case, is the first overload; no SFINAE is involved this time.</p>
<p class="normal">On the other hand, if the compiler encounters a call such as <code class="inlineCode">func("string"s)</code>, then it again relies on SFINAE to ignore the function template, because <code class="inlineCode">std::basic_string</code> does not have a <code class="inlineCode">value_type</code> member either. This time, however, the overload set does not contain any match for the string argument; therefore, the program is ill-formed and the compiler emits an error and stops.</p>
<p class="normal">The <code class="inlineCode">enable_if&lt;bool, T&gt;</code> class template does not have any members, but its partial specialization, <code class="inlineCode">enable_if&lt;true, T</code> <code class="inlineCode">&gt;</code>, does have an inner type called <code class="inlineCode">type</code>, which is a synonym for <code class="inlineCode">T</code>. When the compile-time expression supplied as the first argument to <code class="inlineCode">enable_if</code> evaluates to <code class="inlineCode">true</code>, the inner member <code class="inlineCode">type</code> is available; otherwise, it is not.</p>
<p class="normal">Considering the last definition of the <code class="inlineCode">mul()</code> function from the <em class="italic">How to do it...</em> section, when the compiler encounters a call such as <code class="inlineCode">mul(1, 2)</code>, it tries to substitute <code class="inlineCode">int</code> for the template parameter, <code class="inlineCode">T</code>; since <code class="inlineCode">int</code> is an integral type, <code class="inlineCode">std::is_integral&lt;T&gt;</code> evaluates to <code class="inlineCode">true</code> and, therefore, a specialization of <code class="inlineCode">enable_if</code> that defines an inner type called <code class="inlineCode">type</code> is instantiated. As a result, the alias template <code class="inlineCode">EnableIf</code> becomes a synonym for this type, which is <code class="inlineCode">void</code> (from the expression <code class="inlineCode">typename T = void</code>). The result is a function template, <code class="inlineCode">int mul&lt;int, void&gt;(int a, int b)</code>, that can be called with the supplied arguments.</p>
<p class="normal">On the other hand, when the compiler encounters a call such as <code class="inlineCode">mul(1.0, 2.0)</code>, it tries to substitute <code class="inlineCode">double</code> for the template parameter, <code class="inlineCode">T</code>. However, this is not an integral type; as a result, the condition in <code class="inlineCode">std::enable_if</code> evaluates to <code class="inlineCode">false</code> and the class template does not define an inner member <code class="inlineCode">type</code>. This results in a substitution error, but according to <a id="_idIndexMarker542"/>SFINAE, the compiler will not emit<a id="_idIndexMarker543"/> an error but move on. However, since no other overload is found, there will be no <code class="inlineCode">mul()</code> function that can be called. Therefore, the program is considered ill-formed and the compiler stops with an error.</p>
<p class="normal">A similar situation is encountered with the class template <code class="inlineCode">pod_wrapper</code>. It has two template <a id="_idIndexMarker544"/>type parameters: the first is the actual POD type that is being wrapped, while the second is the result of the substitution of <code class="inlineCode">enable_if</code> and <code class="inlineCode">is_standard_layout</code>. If the type is a POD type (as in <code class="inlineCode">pod_wrapper&lt;int&gt;</code>), then the inner member <code class="inlineCode">type</code> from <code class="inlineCode">enable_if</code> exists and it substitutes the second template type parameter. However, if the inner member <code class="inlineCode">type</code> is not a POD type (as in <code class="inlineCode">pod_wrapper&lt;std::string&gt;</code>), then the inner member <code class="inlineCode">type</code> is not defined, and the substitution fails, producing an error such as <em class="italic">too few template arguments</em>.</p>
<h2 class="heading-2" id="_idParaDest-248">There’s more...</h2>
<p class="normal"><code class="inlineCode">static_assert</code> and <code class="inlineCode">std::enable_if</code> can be used to achieve the same goals. In fact, in the previous recipe, <em class="italic">Performing compile-time assertion checks with static_assert</em>, we defined the same class template, <code class="inlineCode">pod_wrapper</code>, and function template, <code class="inlineCode">mul()</code>. For these examples, <code class="inlineCode">static_assert</code> seems like a better solution because the compiler emits better error messages (provided that you specify relevant messages in the <code class="inlineCode">static_assert</code> declaration). These two, however, work quite differently and are not intended as alternatives.</p>
<p class="normal"><code class="inlineCode">static_assert</code> does not rely on SFINAE and is applied after overload resolution is performed. The result of a failed assert is a compiler error. On the other hand, <code class="inlineCode">std::enable_if</code> is used to remove candidates from the overload set and does not trigger compiler errors (given that the exceptions the standard specifies for SFINAE do not occur). The actual error that can occur after SFINAE is an empty overload set that makes a program ill-formed. This is because a particular function call cannot be performed.</p>
<p class="normal">To understand the difference between <code class="inlineCode">static_assert</code> and <code class="inlineCode">std::enable_if</code> with SFINAE, let’s consider a case where we want to have two function overloads: one that should be called for arguments of integral types and one for arguments of any type other than integral types. With <code class="inlineCode">static_assert</code>, we can write the following (note that the <a id="_idIndexMarker545"/>dummy <a id="_idIndexMarker546"/>second type parameter on the second overload is necessary to define two different overloads; otherwise, we would just have two definitions of the same function):</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
auto compute(T const a, T const b)
{
  static_assert(std::is_integral_v&lt;T&gt;, "An integral type expected");
  return a + b;
}
template &lt;typename T, typename = void&gt;
auto compute(T const a, T const b)
{
  static_assert(!std::is_integral_v&lt;T&gt;, "A non-integral type expected");
  return a * b;
}
auto v1 = compute(1, 2);
// error: ambiguous call to overloaded function
auto v2 = compute(1.0, 2.0);
// error: ambiguous call to overloaded function
</code></pre>
<p class="normal">Regardless <a id="_idIndexMarker547"/>of how we try to call this function, we end up with an error, because the compiler finds two overloads that it could potentially call. This is because <code class="inlineCode">static_assert</code> is only considered after the overload resolution has been resolved, which, in this case, builds a set of two possible candidates.</p>
<p class="normal">The solution to this problem is <code class="inlineCode">std::enable_if</code> and SFINAE. We use <code class="inlineCode">std::enable_if</code> via the alias templates <code class="inlineCode">EnableIf</code> and <code class="inlineCode">DisableIf</code> defined previously on a template parameter (although we still use the dummy template parameter on the second overload to introduce two different definitions). The following example shows the two overloads rewritten. The first overload is enabled only for integral types, while the second is disabled for integral types:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, typename = EnableIf&lt;std::is_integral&lt;T&gt;&gt;&gt;
auto compute(T const a, T const b)
{
  return a * b;
}
template &lt;typename T, typename = DisableIf&lt;std::is_integral&lt;T&gt;&gt;,
          typename = void&gt;
auto compute(T const a, T const b)
{
  return a + b;
}
auto v1 = compute(1, 2);     // OK; v1 = 2
auto v2 = compute(1.0, 2.0); // OK; v2 = 3.0
</code></pre>
<p class="normal">With <a id="_idIndexMarker548"/>SFINAE at work, when <a id="_idIndexMarker549"/>the<a id="_idIndexMarker550"/> compiler builds the overload set for either <code class="inlineCode">compute(1, 2)</code> or <code class="inlineCode">compute(1.0, 2.0);</code>, it will simply discard the overload that produces a substitution failure and move on, where in each case we’ll end up with an overload set containing a single candidate.</p>
<h2 class="heading-2" id="_idParaDest-249">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Performing compile-time assertion checks with static_assert</em>, to learn how to define assertions that are verified at compile time</li>
<li class="bulletList"><em class="chapterRef">Chapter 1</em>, <em class="italic">Creating type aliases and alias templates</em>, to learn about aliases for types</li>
</ul>
<h1 class="heading-1" id="_idParaDest-250">Selecting branches at compile time with constexpr if</h1>
<p class="normal">In the<a id="_idIndexMarker551"/> previous recipes, we saw how we<a id="_idIndexMarker552"/> can impose restrictions on types and functions using <code class="inlineCode">static_assert</code> and <code class="inlineCode">std::enable_if</code> and how these two are different. Template metaprogramming can become complicated and cluttered when we use SFINAE and <code class="inlineCode">std::enable_if</code> to define function overloads or when we write variadic function templates. A new feature of C++17 is intended to simplify such code; it is called <em class="italic">constexpr if</em>, and it defines an <code class="inlineCode">if</code> statement with a condition that is evaluated at compile time, resulting in the compiler selecting the body of a branch or another in the translation unit. Typical usage of <em class="italic">constexpr if</em> is for simplification of variadic templates and <code class="inlineCode">std::enable_if</code>-based code.</p>
<h2 class="heading-2" id="_idParaDest-251">Getting ready</h2>
<p class="normal">In this<a id="_idIndexMarker553"/> recipe, we will refer to and simplify <a id="_idIndexMarker554"/>the code written in two previous recipes. Before continuing with this recipe, you should take a moment to go back and review the code we have written in the previous recipes, as follows:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">compute()</code> overloads for integral and non-integral types from the <em class="italic">Conditionally compiling classes and functions with enable_if</em> recipe.</li>
<li class="bulletList">User-defined 8-bit, 16-bit, and 32-bit binary literals from the <em class="italic">Creating raw user-defined literals</em> recipe of <em class="chapterRef">Chapter 2</em>, <em class="italic">Working with Numbers and Strings</em>.</li>
</ul>
<p class="normal">These implementations have several issues:</p>
<ul>
<li class="bulletList">They are hard to read. There is a lot of focus on the template declaration, yet the body of the functions is very simple, for instance. The biggest problem, though, is that it requires greater attention from developers because it is cluttered with complicated declarations, such as <code class="inlineCode">typename = std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type</code>.</li>
<li class="bulletList">There is too much code. The end purpose of the first example is to have a generic function that behaves differently for different types, yet we had to write two overloads for the function; moreover, to differentiate the two, we had to use an extra, unused, template parameter. In the second example, the purpose was to build an integer value out of characters <code class="inlineCode">'0'</code> and <code class="inlineCode">'1'</code>, yet we had to write one class template and three specializations to make it happen.</li>
<li class="bulletList">It requires advanced template metaprogramming skills, which shouldn’t be necessary for doing something this simple.</li>
</ul>
<p class="normal">The syntax for <em class="italic">constexpr if</em> is very similar to regular <code class="inlineCode">if</code> statements and requires the <code class="inlineCode">constexpr</code> keyword before the condition. The general form is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">if constexpr (init-statement condition) statement-true
else statement-false
</code></pre>
<p class="normal">Notice that in this form, the <code class="inlineCode">init-statement</code> is optional.</p>
<p class="normal">In the following section, we’ll explore several use cases for conditional compilation with <em class="italic">constexpr if</em>.</p>
<h2 class="heading-2" id="_idParaDest-252">How to do it...</h2>
<p class="normal">Use <em class="italic">constexpr if</em> statements<a id="_idIndexMarker555"/> to do the<a id="_idIndexMarker556"/> following:</p>
<ul>
<li class="bulletList">To avoid using <code class="inlineCode">std::enable_if</code> and relying on SFINAE to impose restrictions on function template types and conditionally compile code:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
auto value_of(T value)
{
  if constexpr (std::is_pointer_v&lt;T&gt;)
 return *value;
  else
return value;
}
</code></pre>
</li>
<li class="bulletList">To simplify writing variadic templates and implement metaprogramming compile-time recursion:
        <pre class="programlisting code"><code class="hljs-code">namespace binary
{
  using byte8 = unsigned char;
  namespace binary_literals
  {
    namespace binary_literals_internals
    {
      template &lt;typename CharT, char d, char... bits&gt;
      constexpr CharT binary_eval()
 {
        if constexpr(sizeof...(bits) == 0)
 return static_cast&lt;CharT&gt;(d-'0');
        else if constexpr(d == '0')
          return binary_eval&lt;CharT, bits...&gt;();
        else if constexpr(d == '1')
          return static_cast&lt;CharT&gt;(
            (1 &lt;&lt; sizeof...(bits)) |
            binary_eval&lt;CharT, bits...&gt;());
      }
    }
    template&lt;char... bits&gt;
    constexpr byte8 operator""_b8()
    {
      static_assert(
        sizeof...(bits) &lt;= 8,
        "binary literal b8 must be up to 8 digits long");
      return binary_literals_internals::
                 binary_eval&lt;byte8, bits...&gt;();
    }
  }
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-253">How it works...</h2>
<p class="normal">The <a id="_idIndexMarker557"/>way <em class="italic">constexpr if</em> works is relatively simple: the condition in the <code class="inlineCode">if</code> statement must be a compile-time expression <a id="_idIndexMarker558"/>that evaluates or is convertible to a Boolean. If the condition is <code class="inlineCode">true</code>, the body of the <code class="inlineCode">if</code> statement is selected, which means it ends up in the translation unit for compilation. If the condition is <code class="inlineCode">false</code>, the <code class="inlineCode">else</code> branch, if one is defined, is evaluated. Return statements in discarded <em class="italic">constexpr if</em> branches do not contribute to the function return type deduction.</p>
<p class="normal">In the first example from the <em class="italic">How to do it...</em> section, the <code class="inlineCode">value_of()</code> function template has a clean signature. The body is also very simple; if the type that is substituted for the template parameter is a pointer type, the compiler will select the first branch (that is, <code class="inlineCode">return *value;</code>) for code generation and discard the <code class="inlineCode">else</code> branch. For non-pointer types, because the condition evaluates to <code class="inlineCode">false</code>, the compiler will select the <code class="inlineCode">else</code> branch (that is, <code class="inlineCode">return value;</code>) for code generation and discard the rest. This function can be used as follows:</p>
<pre class="programlisting code"><code class="hljs-code">auto v1 = value_of(42);
auto p = std::make_unique&lt;int&gt;(42);
auto v2 = value_of(p.get());
</code></pre>
<p class="normal">However, without the help of <em class="italic">constexpr if</em>, we could only implement this using <code class="inlineCode">std::enable_if</code>. The following implementation is a more cluttered alternative:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T,
          typename = typename std::enable_if_t&lt;std::is_pointer_v&lt;T&gt;, T&gt;&gt;
auto value_of(T value)
{
  return *value;
}
template &lt;typename T,
          typename = typename std::enable_if_t&lt;!std::is_pointer_v&lt;T&gt;, T&gt;&gt;
T value_of(T value)
{
  return value;
}
</code></pre>
<p class="normal">As you can see, the <em class="italic">constexpr if</em> variant is not only shorter but more expressive and easier to read and understand.</p>
<p class="normal">In the <a id="_idIndexMarker559"/>second example from the <em class="italic">How to do it...</em> section, the internal <code class="inlineCode">binary_eval()</code> helper function is a variadic template function without any parameters; it only has template parameters. The function<a id="_idIndexMarker560"/> evaluates the first argument and then does something with the rest of the arguments in a recursive manner (but remember this is not a runtime recursion). When there is a single character left and the size of the remaining pack is <code class="inlineCode">0</code>, we return the decimal value represented by the character (<code class="inlineCode">0</code> for <code class="inlineCode">'0'</code> and <code class="inlineCode">1</code> for <code class="inlineCode">'</code><code class="inlineCode">1'</code>). If the current first element is a <code class="inlineCode">'0'</code>, we return the value determined by evaluating the rest of the arguments pack, which involves a recursive call. If the current first element is a <code class="inlineCode">'1'</code>, we return the value by shifting a <code class="inlineCode">1</code> to the left a number of positions given by the size of the remaining pack bit or the value determined. We do this by evaluating the rest of the arguments pack, which again involves a recursive call.</p>
<h2 class="heading-2" id="_idParaDest-254">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Conditionally compiling classes and functions with enable_if</em>, to learn about SFINAE and how to use it to specify type constraints for templates</li>
</ul>
<h1 class="heading-1" id="_idParaDest-255">Providing metadata to the compiler with attributes</h1>
<p class="normal">C++ has been <a id="_idIndexMarker561"/>very deficient when it comes to features that enable reflection or introspection on types of data or standard mechanisms to define language extensions. Because of that, compilers have defined their own specific extensions for this purpose. Examples include the VC++ <code class="inlineCode">__declspec()</code> specifier and the GCC <code class="inlineCode">__attribute__((...))</code>. C++11, however, introduced the <a id="_idIndexMarker562"/>concept of attributes, which enable compilers to implement extensions in a standard way or even embedded domain-specific languages. The newer C++ standards define several attributes all compilers should implement, and that will be the topic of this recipe.</p>
<h2 class="heading-2" id="_idParaDest-256">How to do it...</h2>
<p class="normal">Use standard attributes to provide hints for the compiler about various design goals such as in the scenarios listed here, but not only these:</p>
<ul>
<li class="bulletList">To ensure that the return value from a function cannot be ignored, declare the function with the <code class="inlineCode">[[nodiscard]]</code> attribute. In C++20, you can specify a string literal, of the form <code class="inlineCode">[[nodiscard(text)]]</code>, to explain why the result should not be discarded:
        <pre class="programlisting code"><code class="hljs-code">[[nodiscard]] int get_value1()
{
  return 42;
}
get_value1();
// warning: ignoring return value of function
//          declared with 'nodiscard' attribute get_value1();
</code></pre>
</li>
<li class="bulletList">Alternatively, you can declare enumerations and classes used as the return type of a function with the <code class="inlineCode">[[nodiscard]]</code> attribute; in this case, the return value of any function returning such a type cannot be ignored:
        <pre class="programlisting code"><code class="hljs-code">enum class[[nodiscard]] ReturnCodes{ OK, NoData, Error };
ReturnCodes get_value2()
{
  return ReturnCodes::OK;
}
struct[[nodiscard]] Item{};
Item get_value3()
{
  return Item{};
}
// warning: ignoring return value of function
//          declared with 'nodiscard' attribute
get_value2();
get_value3();
</code></pre>
</li>
<li class="bulletList">To<a id="_idIndexMarker563"/> ensure that the usage of functions or types that are considered deprecated is flagged by the compiler<a id="_idIndexMarker564"/> with a warning, declare them with the <code class="inlineCode">[[deprecated]]</code> attribute:
        <pre class="programlisting code"><code class="hljs-code">[[deprecated("Use func2()")]] void func()
{
}
// warning: 'func' is deprecated : Use func2()
func();
class [[deprecated]] foo
{
};
// warning: 'foo' is deprecated
foo f;
</code></pre>
</li>
<li class="bulletList">To ensure that the compiler does not emit a warning for unused variables, use the <code class="inlineCode">[[maybe_unused]]</code> attribute:
        <pre class="programlisting code"><code class="hljs-code">double run([[maybe_unused]] int a, double b)
{
  return 2 * b;
}
[[maybe_unused]] auto i = get_value1();
</code></pre>
</li>
<li class="bulletList">To ensure that intentional fall-through case labels in a <code class="inlineCode">switch</code> statement are not flagged by the compiler with a warning, use the <code class="inlineCode">[[fallthrough]]</code> attribute:
        <pre class="programlisting code"><code class="hljs-code">void option1() {}
void option2() {}
int alternative = get_value1();
switch (alternative)
{
  case 1:
    option1();
    [[fallthrough]]; // this is intentional
case 2:
    option2();
}
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker565"/>help the compiler optimize<a id="_idIndexMarker566"/> paths of execution that are more or less likely to execute, use the C++20 <code class="inlineCode">[[likely]]</code> and <code class="inlineCode">[[unlikely]]</code> attributes:
        <pre class="programlisting code"><code class="hljs-code">void execute_command(char cmd)
{
  switch(cmd)
  {
    [[likely]]
    case 'a': /* add */ break;
    [[unlikely]]
    case 'd': /* delete */ break;
    case 'p': /* print */ break;
    default:  /* do something else */ break;
  }
}
</code></pre>
</li>
<li class="bulletList">To help the compiler optimize code based on the user-given assumptions, use the C++23 <code class="inlineCode">[[assume]]</code> attribute:
        <pre class="programlisting code"><code class="hljs-code">void process(int* data, size_t len)
{
   [[assume(len &gt; 0)]];
   for(size_t i = 0; i &lt; len; ++i)
   {
     // do something with data[i]
   }
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-257">How it works...</h2>
<p class="normal">Attributes <a id="_idIndexMarker567"/>are a very flexible feature of C++; they can be used almost everywhere, but the actual usage is specifically defined for each particular attribute. They can be used on types, functions, variables, names, code blocks, or entire translation units.</p>
<p class="normal">Attributes are <a id="_idIndexMarker568"/>specified between double square brackets (for example, <code class="inlineCode">[[attr1]]</code>), and more than one attribute can be specified in a declaration (for example, <code class="inlineCode">[[attr1, attr2, attr3]]</code>).</p>
<p class="normal">Attributes can have arguments, for example, <code class="inlineCode">[[mode(greedy)]]</code>, and can be fully qualified, for example, <code class="inlineCode">[[sys::hidden]]</code> or <code class="inlineCode">[[using sys: visibility(hidden), debug]]</code>.</p>
<p class="normal">Attributes can appear either before or after the name of the entity on which they are applied, or both, in which case they are combined. The following are several examples that exemplify this:</p>
<pre class="programlisting code"><code class="hljs-code">// attr1 applies to a, attr2 applies to b
int a [[attr1]], b [[attr2]];
// attr1 applies to a and b
int [[attr1]] a, b;
// attr1 applies to a and b, attr2 applies to a
int [[attr1]] a [[attr2]], b;
</code></pre>
<p class="normal">Attributes cannot appear in a namespace declaration, but they can appear as a single-line declaration anywhere in a namespace. In this case, it is specific to each attribute whether it applies to the following declaration, to the namespace, or to the translation unit:</p>
<pre class="programlisting code"><code class="hljs-code">namespace test
{
  [[debug]];
}
</code></pre>
<p class="normal">The standard does define several attributes all compilers must implement, and using them can help you write better code. We have seen some of them in the examples given in the <a id="_idIndexMarker569"/>previous section. These attributes have <a id="_idIndexMarker570"/>been defined in different versions of the standard:</p>
<ul>
<li class="bulletList">In C++11:<ul>
<li class="bulletList">The <code class="inlineCode">[[noreturn]]</code> attribute indicates that a function does not return.</li>
<li class="bulletList">The <code class="inlineCode">[[carries_dependency]]</code> attribute indicates that the dependency chain in release-consume <code class="inlineCode">std::memory_order</code> propagates in and out of the function, which allows the compiler to skip unnecessary memory fence instructions.</li>
</ul>
</li>
<li class="bulletList">In C++14:<ul>
<li class="bulletList">The <code class="inlineCode">[[deprecated]]</code> and <code class="inlineCode">[[deprecated("reason")]]</code> attributes indicate that the entity declared with these attributes is considered deprecated and should not be used. These attributes can be used with classes, non-static data members, typedefs, functions, enumerations, and template specializations. The <code class="inlineCode">"reason"</code> string is an optional parameter.</li>
</ul>
</li>
<li class="bulletList">In C++17:<ul>
<li class="bulletList">The <code class="inlineCode">[[fallthrough]]</code> attribute indicates that the fall-through between labels in a <code class="inlineCode">switch</code> statement is intentional. The attribute must appear on a line of its own immediately before a <code class="inlineCode">case</code> label.</li>
<li class="bulletList">The <code class="inlineCode">[[nodiscard]]</code> attribute indicates that a return value from a function cannot be ignored.</li>
<li class="bulletList">The <code class="inlineCode">[[maybe_unused]]</code> attribute indicates that an entity may be unused, but the compiler should not emit a warning about that. This attribute can be applied to variables, classes, non-static data members, enumerations, enumerators, and typedefs.</li>
</ul>
</li>
<li class="bulletList">In C++20:<ul>
<li class="bulletList">The <code class="inlineCode">[[nodiscard(text)]]</code> attribute is an extension of the C++17 <code class="inlineCode">[[nodiscard]]</code> attribute and provides text that describes the reason a result should not be discarded.</li>
<li class="bulletList">The <code class="inlineCode">[[likely]]</code> and <code class="inlineCode">[[unlikely]]</code> attributes provide hints for the compiler that a path of execution is more or less likely to execute, therefore allowing it to optimize accordingly. They can be applied to statements (but not declarations) and labels, but only one of them, as they are mutually exclusive.</li>
<li class="bulletList">The <code class="inlineCode">[[no_unique_address]]</code> attribute can be applied to non-static data members, excluding bitfields, and tells the compiler that the member does not have to have a unique address. When applied to a member that has an empty type, the compiler can optimize it to occupy no space, as in the case of it being an empty base. On the other hand, if the member’s type is not empty, the compiler may reuse any ensuing padding to store other data members.</li>
</ul>
</li>
<li class="bulletList">In C++23:<ul>
<li class="bulletList"><code class="inlineCode">[[assume(expr)]]</code> indicates that an expression will always evaluate to <code class="inlineCode">true</code>. Its purpose is to enable the compiler to perform code optimizations and not to document the preconditions of a function. However, the expression is never evaluated. An expression that has undefined behavior or throws an exception is evaluated to <code class="inlineCode">false</code>. An assumption that does not hold causes undefined behavior; therefore, assumptions should be used judiciously. On the other hand, compilers may not use an assumption at all.</li>
</ul>
</li>
</ul>
<p class="normal">Attributes <a id="_idIndexMarker571"/>are often ignored or briefly <a id="_idIndexMarker572"/>mentioned in books and tutorials on modern C++ programming, and the reason for that is probably the fact that developers cannot actually write attributes, as this language feature is intended for compiler implementations. For some compilers, though, it may be possible to define user-provided attributes; one such compiler is GCC, which supports plugins that add extra features to the compiler, and they can be used for defining new attributes too.</p>
<h2 class="heading-2" id="_idParaDest-258">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 9</em>, <em class="italic">Using noexcept for functions that do not throw</em>, to learn how to inform the compiler that a function should not throw exceptions</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_04.xhtml">https://discord.gg/7xRaTCeEhx</a></p>
<p class="normal"><img alt="" src="img/QR_Code2659294082093549796.png"/></p>
</div>
</body></html>