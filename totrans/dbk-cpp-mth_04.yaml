- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: The Main() Function is the Entry Point to Your Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main()`函数是应用程序的入口点'
- en: '*What happens before main stays* *in main*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*在main之前发生的事情都留在main中*'
- en: For programmers working with C++ on various operating systems, the entry point
    of an application is a concept that requires a deep understanding of the underlying
    architecture. In this chapter, we’ll analyze how an application starts, focusing
    on the initialization code that’s executed before we reach the user-defined **main()**
    function.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在各个操作系统上使用C++的程序员来说，应用程序的入口点是一个需要深入了解底层架构的概念。在本章中，我们将分析应用程序的启动方式，重点关注在我们达到用户定义的`main()`函数之前执行的初始化代码。
- en: While exploring this process under Linux, we’ll analyze the **Executable and
    Linkable Format** ( **ELF** ), detailing how the **execve()** system call loads
    and executes a **_start()** function, which prepares the runtime environment before
    calling **main()** . We’ll also explore some compiler-specific extensions that
    we can use to manipulate this process. Then, we’ll shift our focus to Windows
    by offering a detailed examination of the **Portable Executable** ( **PE** ) file
    sections on Windows.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux下探索这个过程时，我们将分析**可执行和链接格式**（**ELF**），详细说明`execve()`系统调用如何加载和执行`_start()`函数，该函数在调用`main()`之前准备运行时环境。我们还将探讨一些编译器特定的扩展，我们可以使用这些扩展来操纵这个过程。然后，我们将把注意力转向Windows，详细检查Windows上的**可移植可执行文件**（**PE**）文件部分。
- en: We’ll also use a tool called **Ghidra** to dissect and analyze the executables
    under both platforms since this is one of the tools that provides practical insights
    into the low-level operations that underpin application startup.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一个名为**Ghidra**的工具来分析两个平台下的可执行文件，因为这是提供关于支撑应用程序启动的低级操作实用见解的工具之一。
- en: 'After completing this chapter, you’ll have a deeper understanding of the following
    aspects:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将更深入地理解以下方面：
- en: The format of executable files and starting processes under Linux and Windows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件格式以及Linux和Windows下的进程启动
- en: How to tinker with the startup process of applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何篡改应用程序的启动过程
- en: What is Ghidra?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Ghidra？
- en: '**Ghidra** is an open source software reverse engineering suite developed by
    the NSA for analyzing compiled code across various formats and platforms. It offers
    tools for decompiling, disassembling, and debugging binary files, making it easier
    for users to understand and analyze machine code.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ghidra**是由NSA开发的开源软件逆向工程套件，用于分析各种格式和平台上的编译代码。它提供了反编译、反汇编和调试二进制文件的工具，使用户更容易理解和分析机器代码。'
- en: The main() function
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main()`函数'
- en: 'When we took up C++ in school, or maybe at university, on our first C++ course,
    we were told by our teacher: “Dear fellows, here’s the main function: **void main(void)**
    . That’s where your program will start.” That’s it.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在学校或可能在大学的第一门C++课程中学习C++时，我们的老师告诉我们：“亲爱的同学们，这是main函数：`void main(void)`。你的程序将从这里开始。”就这样。
- en: Chapter done – turn the pages and see you in the next one.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 章节完成——翻到下一页，我们下一章见。
- en: However, this statement isn’t true. I wrote **void main(void)** just to wake
    your curiosity and put you in a state of alertness. At this point in their career,
    all C++ programmers should know that **void main(void)** is as far as standard
    C++ as Point Nemo is from the closest piece of dry land.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个说法并不正确。我写下`void main(void)`只是为了激发你的好奇心，让你保持警觉。在这个职业阶段，所有C++程序员都应该知道`void
    main(void)`与标准C++的距离，就像Nemo点与最近的陆地一样遥远。
- en: Oh – you’re still here! This means that you must have read the fine print. Excellent
    – we programmers should always pay attention to the finer details, such as how
    our application is loaded and executed in memory by the underlying operating system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 哦——你还在这里！这意味着你一定读过了细则。太好了——我们程序员应该始终关注细节，比如我们的应用程序是如何被底层操作系统加载和执行在内存中的。
- en: Since we live in a free world, we have the option to choose from several operating
    systems at our discretion, so we’ve opted to present how this application loading
    happens under Linux and Windows.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们生活在一个自由的世界，我们可以根据自己的意愿选择使用几个操作系统，因此我们选择展示这个应用程序在Linux和Windows下是如何加载的。
- en: There’s a significant difference between these two operating systems concerning
    the way they load and execute the compiled binaries, and while in one of them
    (it’s not that hard to guess which one) we can track all the code paths of this
    peculiar process down the deepest layers of the underlying kernel, for the other
    one, we must rely on existing documentation, books, and various sources of information
    that are to be gathered by the enthusiast low-level scholar.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个操作系统之间，关于它们加载和执行编译后的二进制文件的方式存在显著差异。在其中一个（不难猜出是哪一个）中，我们可以追踪到这个特殊过程的代码路径，直到底层内核的最深层次，而对于另一个，我们必须依赖现有的文档、书籍和各种信息来源，这些信息将由热衷于底层研究的学者收集。
- en: Since the way Linux deals with this operation is very similar to how the operating
    systems from the BSD family (FreeBSD, NetBSD, and so on) approach the same problem,
    we’ll refrain from actively mentioning these while we debate the problem in the
    upcoming paragraphs. Since we want to keep you entertained while in the pursuit
    of knowledge, we still want to offer information that’s up to date, so we’ve decided
    not to offer this information for peculiar operating systems, such as MS-DOS,
    that are no longer used in active production environments as of 2024 (except if
    you happen to work at Deutsche Bahn [1](B22235_04.xhtml#footnote-016) ).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Linux处理这种操作的方式与BSD家族（FreeBSD、NetBSD等）的操作系统处理相同问题的方法非常相似，因此在我们接下来的段落中讨论问题时，我们将避免主动提及这些操作系统。由于我们希望在追求知识的同时让您保持兴趣，我们仍然想提供最新的信息，因此我们决定不为MS-DOS等特殊操作系统提供信息，这些操作系统自2024年起不再在活跃的生产环境中使用（除非您恰好在大德意志铁路公司工作[1](B22235_04.xhtml#footnote-016)）。
- en: '[1](B22235_04.xhtml#footnote-016-backlink) [https://www.theregister.com/2024/01/30/windows_311_trundles_on/](https://www.theregister.com/2024/01/30/windows_311_trundles_on/)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](B22235_04.xhtml#footnote-016-backlink) [https://www.theregister.com/2024/01/30/windows_311_trundles_on/](https://www.theregister.com/2024/01/30/windows_311_trundles_on/)'
- en: 'But before we dig deeper, we’ll present the test application that we’ll be
    using in this chapter to exemplify the aforementioned functionality:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入探讨之前，我们将展示本章将使用的测试应用程序，以展示上述功能：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When compiled and run on a standard compliant system, the preceding application
    produces the following output, as expected by a standard compliant programmer:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当在符合标准规范的系统上编译并运行上述应用程序时，它会产生以下预期的输出，这对于遵循标准规范的程序员来说是显而易见的：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Yes, we’ve intentionally used no **cout** and other stream operations as we
    want to keep this simple. We don’t want to pollute the generated code since we
    plan to dig deep into the compiled executables.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们故意没有使用**cout**和其他流操作，因为我们希望保持代码的简洁。我们不希望污染生成的代码，因为我们计划深入研究编译后的可执行文件。
- en: 'Also, please note that this is synthetic code that’s been written specifically
    for this chapter to exemplify the features we want to present. The authors are
    totally aware of the potential memory overflow error induced by strcpy, so the
    readers are advised to do what the author tells them to do, not what the author
    does: “ *Don’t* *use strcpy.* ”'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，这段代码是专门为本章编写的合成代码，用以展示我们想要展示的特性。作者完全清楚strcpy可能引起的潜在内存溢出错误，因此建议读者按照作者的建议去做，而不是模仿作者的做法：“**不要**使用strcpy。”
- en: 'Going back to our initial goal, let’s present how operating systems load and
    execute applications. In case, dear reader, you feel that the discussion below
    is of a too low level, please bear in mind: C++ programs compile to native code
    while running at the highest possible speed allocated by the underlying operating
    system.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的初始目标，让我们展示操作系统如何加载和执行应用程序。如果，亲爱的读者，您觉得下面的讨论过于底层，请记住：C++程序在运行时编译成本地代码，以尽可能高的速度执行，这是底层操作系统分配的速度。
- en: With this in mind, we consider that it’s in the interest of any C++ programmer
    to know how the operating system is handling their code, and what happens after
    the compiler has digested their source files and spat out an executable. We will
    try to keep out the lowest level details and present only what is really necessary,
    in order to fully grasp the seriousness of the situation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们认为任何C++程序员都有必要了解操作系统是如何处理他们的代码的，以及编译器消化了他们的源文件并输出可执行文件后会发生什么。我们将尽量排除最低级细节，只展示真正必要的内容，以便全面理解这一情况的严重性。
- en: The penguin farm
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企鹅农场
- en: When Linux loads and executes an application (say we want to execute an application,
    not a shell script or something else), usually a **fork()** / **execve()** pair
    of system calls are initiated to start the execution of the application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Linux 加载和执行应用程序（例如，我们想要执行一个应用程序，而不是 shell 脚本或其他东西）时，通常通过一个 **fork()** / **execve()**
    系统调用对来启动应用程序的执行。
- en: These system calls are responsible for duplicating the current process ( **fork()**
    ) and replacing the current process image with a new process image (the application
    to be executed – that is, **execve()** ).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统调用负责复制当前进程（**fork()**）并用新的进程映像（要执行的应用程序，即**execve()**）替换当前进程映像。
- en: These API calls are presented in great detail in *Advanced Linux Programming*
    , by Mark Mitchell, Jeffrey Oldham, and Alex Samuel, but there are countless online
    resources dedicated to this subject. So, if you’re interested in this subject,
    you might find good sources of information there.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 API 调用在 Mark Mitchell、Jeffrey Oldham 和 Alex Samuel 所著的《高级 Linux 编程》中有详细的介绍，但还有无数在线资源专门介绍这个主题。所以，如果你对这个主题感兴趣，你可能会在那里找到很好的信息来源。
- en: But let’s continue loading the executable. The **execve()** system call, after
    several iterations where it leaves the confines of userspace, will end up in the
    Linux kernel and create a **linux_binprm** structure [2](B22235_04.xhtml#footnote-015)
    .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们继续加载可执行文件。在经过几次迭代并离开用户空间限制后，**execve()** 系统调用最终会进入 Linux 内核并创建一个 **linux_binprm**
    结构 [2](B22235_04.xhtml#footnote-015)。
- en: '[2](B22235_04.xhtml#footnote-015-backlink) [https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h](https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](B22235_04.xhtml#footnote-015-backlink) [https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h](https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h)'
- en: According to the documentation, this structure is used upon loading binaries
    and contains all the major details that are needed upon loading and executing
    a binary file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，这个结构在加载二进制文件时使用，并包含在加载和执行二进制文件时所需的所有主要详细信息。
- en: If you have lots of free time, are armed with a large cup of tea, and have deep
    knowledge of the intricacies of the C language, you can easily read through the
    lengthy implementation of the **do_execveat_common** function to learn more about
    the behind-the-scenes of this function in the current Linux kernel source tree
    [3](B22235_04.xhtml#footnote-014) .
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多空闲时间，手里拿着一大杯茶，并且对 C 语言的复杂性有深入的了解，你可以轻松地阅读 **do_execveat_common** 函数的冗长实现，以了解更多关于当前
    Linux 内核源树中此函数幕后情况的信息 [3](B22235_04.xhtml#footnote-014)。
- en: '[3](B22235_04.xhtml#footnote-014-backlink) https://github.com/torvalds/linux/blob/master/fs/exec.c'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](B22235_04.xhtml#footnote-014-backlink) https://github.com/torvalds/linux/blob/master/fs/exec.c'
- en: The kernel, in turn, determines the format of the executable file. On Linux
    systems, the most common executable format is ELF.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 内核随后确定可执行文件的格式。在 Linux 系统中，最常用的可执行文件格式是 ELF。
- en: 'All fields are described in the official standard document, [4](B22235_04.xhtml#footnote-013)
    but a quick summary of the fields that are relevant to our use case are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字段都在官方标准文档 [4](B22235_04.xhtml#footnote-013) 中进行了描述，但与我们用例相关的字段的快速总结如下：
- en: '[4](B22235_04.xhtml#footnote-013-backlink) https://refspecs.linuxfoundation.org/elf/elf.pdf'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](B22235_04.xhtml#footnote-013-backlink) https://refspecs.linuxfoundation.org/elf/elf.pdf'
- en: '| **Field Name** | **Offset** | **Description** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **字段名称** | **偏移量** | **描述** |'
- en: '| **MAGIC** | 0x00 | A magic number indicating that the file is an ELF file
    (“ELF” in ASCII and 0x7F) |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **MAGIC** | 0x00 | 一个表示文件是 ELF 文件的魔数（ASCII 中的“ELF”和 0x7F）|'
- en: '| **CLASS** | 0x04 | Specifies the class (32-bit or 64-bit) of the ELF file
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **CLASS** | 0x04 | 指定 ELF 文件的类（32 位或 64 位）|'
- en: '| **e_type** | 0x10 | Identifies the object file type (for example, executable,
    shared object, and so on) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **e_type** | 0x10 | 识别对象文件类型（例如，可执行文件、共享对象等）|'
- en: '| **e_machine** | 0x12 | Specifies the architecture for which the file was
    compiled |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **e_machine** | 0x12 | 指定文件编译的架构 |'
- en: '| **e_entry** | 0x18 | The virtual address to which the system transfers control
    first, starting the process |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **e_entry** | 0x18 | 系统首先将控制权转移到该虚拟地址，以启动进程 |'
- en: 'Please remember this table as we’ll be referring to it shortly. But for now,
    let’s continue loading a program. It’s time for the kernel to read the ELF header
    to understand the structure of the executable. The following operations happen
    at this stage:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住这个表格，因为我们很快就会参考它。但现在，让我们继续加载程序。现在是内核读取 ELF 头以了解可执行文件结构的时候了。在这个阶段发生以下操作：
- en: '**Memory allocation** : The kernel allocates memory for the new process. This
    includes setting up the process’s address space, which consists of different segments
    such as text (code), data, the heap, and the stack.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**内存分配**：内核为新进程分配内存。这包括设置进程的地址空间，它由不同的段组成，如文本（代码）、数据、堆和栈。'
- en: '**Section mapping** : The kernel maps sections of the executable file into
    the process’s address space. For example, the text segment (containing executable
    code) is mapped as read-only, while the data segment (containing global variables)
    is mapped as read-write.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**段映射**：内核将可执行文件的段映射到进程的地址空间中。例如，文本段（包含可执行代码）被映射为只读，而数据段（包含全局变量）被映射为读写。'
- en: '**Dynamic linking** : If the executable depends on shared libraries, the dynamic
    linker/loader ( **ld.so** ) is invoked to load the necessary shared libraries
    and resolve symbol references. The dynamic linker also maps these libraries into
    the process’s address space.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动态链接**：如果可执行文件依赖于共享库，则调用动态链接器/加载器（**ld.so**）来加载必要的共享库并解析符号引用。动态链接器还将这些库映射到进程的地址空间中。'
- en: These operations all happen deep inside the Linux kernel, but if you’re interested
    in this domain, we encourage you to go and read the source – perhaps you can spot
    something teasing there.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作都在 Linux 内核深处进行，但如果你对这个领域感兴趣，我们鼓励你阅读源代码——也许你能在其中发现一些有趣的东西。
- en: 'Once all these interesting and very low-level operations have been performed
    successfully, the kernel sets up the initial environment stack for the process.
    This stack contains the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些有趣且非常底层的操作都成功执行，内核就会为进程设置初始环境栈。这个栈包含以下内容：
- en: '**Argument vectors** ( **argv** ): An array of command-line arguments'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数向量**（**argv**）：命令行参数数组。'
- en: '**Environment variables** ( **envp** ): An array of environment variables'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量**（**envp**）：环境变量数组。'
- en: '**Auxiliary vectors** ( **auxv** ): Additional information needed by the program,
    such as system page size, entry point of the program, and so on'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**辅助向量**（**auxv**）：程序需要的附加信息，例如系统页面大小、程序入口点等。'
- en: 'All this happens in the same kernel source file mentioned previously ( **binfmt_elf.c**
    ), in the following function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在之前提到的相同内核源文件（**binfmt_elf.c**）中发生，在以下函数中：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After creating the runtime environment, the kernel sets up the **instruction
    pointer** ( **IP** ) to point to the entry point of the program (as specified
    in the ELF header). The CPU registers are also initialized as required. Finally,
    the kernel switches the CPU back to user mode and transfers control to the entry
    point of the program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建运行时环境后，内核设置 **指令指针**（**IP**）指向程序的入口点（如 ELF 头部中指定）。CPU 寄存器也被初始化为所需的值。最后，内核将
    CPU 返回到用户模式并将控制权转移到程序的入口点。
- en: In Linux, transfer of control i occurs primarily in the **start_thread()** function,
    which is architecture-specific. At the time of writing, for x86, this function
    is defined in **arch/x86/include/asm/processor.h** and is implemented in **arch/x86/kernel/process_64.c**
    . The program starts executing from this point. Now comes the interesting part
    – at least from a C++ developer’s point of view.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，控制权转移主要发生在 **start_thread()** 函数中，该函数是架构特定的。在撰写本文时，对于 x86，该函数在 **arch/x86/include/asm/processor.h**
    中定义，并在 **arch/x86/kernel/process_64.c** 中实现。程序从这个点开始执行。现在来到有趣的部分——至少从 C++ 开发者的角度来看。
- en: First, the program’s initialization code (often part of the C runtime library)
    is executed – typically the **_start()** function, not **main()** . The **e_entry**
    field of the ELF header lists the offset in the file where the program starts
    executing. Usually, it’s the offset of the **_start()** method, or at least if
    the executable was compiled with the standard GNU toolchain. This code is responsible
    for setting up any runtime environment variables and calling the **main()** function
    of the program. From this point, the program runs as per the instructions written.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，执行程序的初始化代码（通常是 C 运行时库的一部分）——通常是 **_start()** 函数，而不是 **main()**。ELF 头部的 **e_entry**
    字段列出了程序开始执行的位置在文件中的偏移量。通常，它是 **_start()** 方法的偏移量，或者至少如果可执行文件是用标准 GNU 工具链编译的。这段代码负责设置任何运行时环境变量并调用程序的
    **main()** 函数。从这一点开始，程序按照编写的指令运行。
- en: 'So, let’s examine what exactly is the initialization code. We’ll use our handy
    tool, **Ghidra** , which allows us to dissect Linux executables and examine their
    inner workings. This tool provides the following summary of our almost empty application:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来检查一下初始化代码究竟是什么。我们将使用我们手头的工具**Ghidra**，它允许我们剖析 Linux 可执行文件并检查它们的内部工作原理。此工具为我们几乎空白的程序提供了以下摘要：
- en: '![Figure 4.1 – The structure of our synthetic application](img/B22235_04_01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 我们合成应用的架构](img/B22235_04_01.jpg)'
- en: Figure 4.1 – The structure of our synthetic application
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 我们合成应用的架构
- en: 'When looking at the **ELF Source File** section, we can see our initial **main.cpp**
    file; however, there are a few other items that we’re not familiar with yet –
    for example, **crtstuff.c** . This file is part of **libgcc** and can be found
    in the **libgcc** repository [5](B22235_04.xhtml#footnote-012) , with the following
    comment written at the top:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看**ELF源文件**部分时，我们可以看到我们的初始**main.cpp**文件；然而，还有一些我们还不熟悉的其他项目 – 例如，**crtstuff.c**。此文件是**libgcc**的一部分，可以在**libgcc**仓库[5](B22235_04.xhtml#footnote-012)中找到，其顶部有如下注释：
- en: '[5](B22235_04.xhtml#footnote-012-backlink) [https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c](https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[5](B22235_04.xhtml#footnote-012-backlink) [https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c](https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c)'
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With that, one of the mysteries has been resolved and the comment is self-explanatory.
    However, another remains: **Scrt1.o** . To understand this, we need to know about
    the difference between **fixed-address executables** and **position-independent**
    **executables** ( **PIEs** ).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，一个谜团已经解开，注释也就不言自明了。然而，另一个谜团仍然存在：**Scrt1.o**。要理解这一点，我们需要了解**固定地址可执行文件**和**位置无关可执行文件**（**PIEs**）之间的区别。
- en: Fixed-address executables are compiled to be loaded at specific, predetermined
    memory addresses, making them simpler but less secure and flexible since their
    addresses are predictable and vulnerable to attacks. This is the preferred manner
    of loading executables on embedded devices and some older platforms (such as MS-DOS,
    which also had this “feature” of requiring **.com** applications to be loaded
    at a specific offset).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 固定地址可执行文件被编译为在特定的、预定的内存地址上加载，这使得它们更简单但安全性较低且灵活性较差，因为它们的地址是可预测的且容易受到攻击。这是在嵌入式设备和一些较老的平台（如也具有此“特性”要求**.com**应用程序在特定偏移量加载的MS-DOS）上加载可执行文件的首选方式。
- en: On the other hand, **Position Independent Executable** ( **PIE** ) executables
    are compiled and linked to be position-independent, allowing them to be loaded
    at any address in memory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**位置无关可执行文件**（**PIE**）可执行文件在编译和链接时被设计为位置无关，允许它们在任何内存地址上加载。
- en: 'When you compile a program, you can use various flags to control how the compiler
    generates the code. The **-fPIE** , **-pie** , and **-fPIC** flags are related
    to how the code is positioned and handled in memory. Here’s a quick breakdown
    of what each flag does:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译一个程序时，你可以使用各种标志来控制编译器如何生成代码。**-fPIE**、**-pie**和**-fPIC**标志与代码在内存中的定位和处理方式有关。以下是每个标志的快速概述：
- en: '**-fPIE** ( **position-independent executable** ): The **-fPIE** flag tells
    the compiler to generate position-independent code for executables. This is useful
    for creating executables that support **Address Space Layout Randomization** (
    **ASLR** ), a security feature that randomizes the memory address where the executable
    is loaded to make it harder for attackers to predict the location of specific
    code.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-fPIE**（**位置无关可执行文件**）：**-fPIE**标志告诉编译器为可执行文件生成位置无关代码。这对于创建支持**地址空间布局随机化**（**ASLR**）的可执行文件很有用，这是一个安全特性，它随机化可执行文件加载到的内存地址，使得攻击者更难预测特定代码的位置。'
- en: '**-pie** ( **position-independent executable linker flag** ): The **-pie**
    flag is used during the linking stage. It instructs the linker to produce a position-independent
    executable. This means that the final output file (the executable) will be able
    to be loaded at any address in memory supporting ASLR. It complements the **-fPIE**
    flag, which is used during compilation, ensuring that all the code in the executable
    is position-independent.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-pie**（**位置无关可执行文件链接器标志**）：**-pie**标志在链接阶段使用。它指示链接器生成位置无关的可执行文件。这意味着最终输出文件（可执行文件）将能够在支持ASLR的任何内存地址上加载。它与在编译阶段使用的**-fPIE**标志相辅相成，确保可执行文件中的所有代码都是位置无关的。'
- en: '**-fPIC** ( **position-independent code** ): The **-fPIC** flag tells the compiler
    to generate position-independent code for shared libraries. Position-independent
    code for shared libraries means that the library can be loaded at any address
    in memory. This is essential for shared libraries because they may be loaded into
    different memory locations in different programs.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-fPIC**（**位置无关代码**）：**-fPIC**标志告诉编译器为共享库生成位置无关代码。共享库的位置无关代码意味着库可以加载到内存中的任何地址。这对于共享库是必要的，因为它们可能被加载到不同程序的不同内存位置。'
- en: 'Now that we know about these important notions, let’s get back to where we
    left off and cover the one remaining mystery in our binary: **Scrt1.o** . Do you
    remember the **_start()** function? Since you didn’t write it yourself, it must
    come from somewhere. For us, it comes from this magic **Scrt1.o** . There are
    several variations of **crtX.o** , some with a leading S, some without, but for
    us, the presence of **Scrt1.o** tells us that our application is a PIE executable.
    Several other files can be linked to our application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些重要概念，让我们回到我们之前中断的地方，并讨论我们二进制文件中剩下的一个谜团：**Scrt1.o**。你还记得**_start()**函数吗？由于你没有自己编写它，它必须来自某个地方。对于我们来说，它来自这个神奇的**Scrt1.o**。**crtX.o**有几个变体，一些以S开头，一些没有，但对我们来说，**Scrt1.o**的存在告诉我们我们的应用程序是一个PIE可执行文件。还可以将几个其他文件链接到我们的应用程序：
- en: '**crt0.o** , **crt1.o** , and so on: These files contain the **_start** symbol,
    which is crucial for bootstrapping program execution. Their specific naming conventions
    may vary between **libc** implementations.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**crt0.o**、**crt1.o** 等等：这些文件包含**_start**符号，这对于引导程序执行至关重要。它们的具体命名约定可能因**libc**实现而异。'
- en: '**crti.o** : This defines function prologues for **.init** and **.fini** sections,
    triggering linker-generated dynamic tags ( **DT_INIT and DT_FINI** ), to support
    We’ll discuss these notions here, so don’t worry about the unknown terminology
    yet.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**crti.o**：这为**.init**和**.fini**部分定义函数前缀，触发链接器生成的动态标签（**DT_INIT和DT_FINI**），以支持我们将在这里讨论这些概念，所以不要担心未知术语。'
- en: '**crtn.o** : This provides function epilogues for **.init** and **.fini** sections,
    complementing **crti.o** .'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**crtn.o**：这为**.init**和**.fini**部分提供函数结尾，补充**crti.o**。'
- en: '**Scrt1.o** , **gcrt1.o** , and **Mcrt1.o** : These are variants of **crt1.o**
    that are used under different circumstances, such as generating PIEs or including
    profiling information.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scrt1.o**、**gcrt1.o**和**Mcrt1.o**：这些是**crt1.o**的变体，在不同情况下使用，例如生成PIEs或包含性能信息。'
- en: '**crtbegin.o** , **crtbeginS.o** , and **crtbeginT.o** : These are used by
    GCC to locate constructors and their variations ( **crtbeginS.o** for shared objects/PIEs
    and **crtbeginT.o** for static executables).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**crtbegin.o**、**crtbeginS.o**和**crtbeginT.o**：这些由GCC用于定位构造函数及其变体（**crtbeginS.o**用于共享对象/PIEs和**crtbeginT.o**用于静态可执行文件）。'
- en: '**crtend.o** and **crtendS.o** : Similar to **crtbegin.o** , these are used
    by GCC to locate destructors ( **crtendS.o** for shared objects/PIEs).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**crtend.o**和**crtendS.o**：与**crtbegin.o**类似，这些由GCC用于定位析构函数（**crtendS.o**用于共享对象/PIEs）。'
- en: 'Now that we’ve demystified the content of our executable, we need to understand
    something else: the **.init_array** section in an ELF file is used to store an
    array of function pointers that are automatically executed by the operating system’s
    runtime loader during program startup.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经揭开了可执行文件内容的神秘面纱，我们需要了解另一件事：ELF文件中的**.init_array**部分用于存储一个函数指针数组，操作系统运行时加载器在程序启动时自动执行这些函数。
- en: 'These functions are typically referred to as “init functions” or “initialization
    functions.” They’re called before **main()** and are responsible for initializing
    global data. For our synthetic application, this is how this section looks once
    it’s been analyzed by **Ghidra** :'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数通常被称为“初始化函数”或“初始化函数”。它们在**main()**之前被调用，并负责初始化全局数据。对于我们的合成应用程序，这是经过**Ghidra**分析后该部分的外观：
- en: '![Figure 4.2 – The .init_array section for global variables](img/B22235_04_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 全局变量的.init_array部分](img/B22235_04_02.jpg)'
- en: Figure 4.2 – The .init_array section for global variables
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 全局变量的.init_array部分
- en: 'As we can see, there are two functions here – a dummy one and something called
    **_GLOBAL__sub_I_my_string** . Interesting choice of name, so let’s use the assembly
    to C-like code feature of the tool and see what it does:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这里有两个函数——一个是哑函数，另一个叫做**_GLOBAL__sub_I_my_string**。名字选择很有趣，所以让我们使用工具的汇编到C-like代码功能来看看它做了什么：
- en: '![Figure 4.3 – How global objects are created according to Ghidra](img/B22235_04_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 根据Ghidra创建全局对象的方式](img/B22235_04_03.jpg)'
- en: Figure 4.3 – How global objects are created according to Ghidra
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 根据Ghidra创建全局对象的方式
- en: Intriguing, isn’t it? This is just what you would expect to happen in the global
    namespace.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣，不是吗？这正是你期望在全局命名空间中发生的事情。
- en: Here, the **my_a** and **my_other_a** objects are being created, their constructor
    is called, and the destructor of class **A** is being invoked for **__cxa_atexit**
    . It is quite an intriguing observation though, how the constructor calls behind
    the scenes work.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，正在创建 **my_a** 和 **my_other_a** 对象，调用它们的构造函数，并为 **__cxa_atexit** 调用类 **A**
    的析构函数。尽管这是一个相当有趣的观察，但幕后构造函数的调用是如何工作的。
- en: 'From this queasy disassembly, you may feel that the constructor gets an invisible
    parameter for the object it’s constructing. This is true: this is the **this**
    variable, and it’s implicitly added to all the methods of a class without being
    explicitly required. This is how we gain access to the object itself.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从这种令人不安的反汇编中，你可能觉得构造函数为它正在构建的对象获得了一个不可见的参数。这是真的：这是 **this** 变量，并且它被隐式地添加到类的所有方法中，而不需要显式要求。这就是我们如何访问对象本身的方式。
- en: As its name suggests, the **__cxa_atexit** function is just like **atexit**
    . However, you don’t have to worry about it because it isn’t a function that should
    be dealt with outside of the library it resides in.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，**__cxa_atexit** 函数就像 **atexit** 一样。然而，你不必担心它，因为它不是应该在它所在的库之外处理的函数。
- en: 'Now that we understand what happens here, it’s time to pick up another thread
    we mentioned previously: the infamous **_start()** function.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这里发生的事情，是时候捡起我们之前提到的一个线程：臭名昭著的 **_start()** 函数。
- en: 'As mentioned previously, this function should do some housekeeping and start
    our **main** function. According to Ghidra, it can be indeed found in the ELF
    header. According to the ELF specification, it occupies the **e_entry** field
    in the long list of ELF entries: :'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个函数应该做一些清理工作并启动我们的 **main** 函数。根据 Ghidra，它确实可以在 ELF 头中找到。根据 ELF 规范，它占据了
    ELF 条目列表中的 **e_entry** 字段：：
- en: '![Figure 4.4 – The ELF header according to Ghidra](img/B22235_04_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 根据Ghidra的ELF头](img/B22235_04_04.jpg)'
- en: Figure 4.4 – The ELF header according to Ghidra
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 根据Ghidra的ELF头
- en: 'Now, after applying some disassembly magic, courtesy of **Ghidra** , it looks
    like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，经过一些反汇编魔法的应用，得益于 **Ghidra**，它看起来是这样的：
- en: '![Figure 4.5 – The _start routine function, disassembled and converted into
    C pseudocode](img/B22235_04_05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – _start例程函数，反汇编并转换为C伪代码](img/B22235_04_05.jpg)'
- en: Figure 4.5 – The _start routine function, disassembled and converted into C
    pseudocode
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – _start例程函数，反汇编并转换为C伪代码
- en: The scary-looking **__libc_start_main** function isn’t as scary as it seems
    and is responsible for loading our **main()** function alongside the parameters
    provided by the operating system. This function is part of **glibc** and can be
    obtained free of charge [6](B22235_04.xhtml#footnote-011) , just like every other
    free piece of software with good behavior, so that we can study its internals.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来可怕的 **__libc_start_main** 函数并没有它看起来那么可怕，它负责加载我们的 **main()** 函数以及操作系统提供的参数。这个函数是
    **glibc** 的一部分，可以免费获得 [6](B22235_04.xhtml#footnote-011) ，就像其他所有行为良好的免费软件一样，这样我们就可以研究其内部结构。
- en: '[6](B22235_04.xhtml#footnote-011-backlink) git clone git://sourceware.org/git/glibc.git'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[6](B22235_04.xhtml#footnote-011-backlink) git clone git://sourceware.org/git/glibc.git'
- en: At this stage, with the outcome of **__libc_start_main** , we’ve reached the
    actual main function. This is where we would expect our program to reside.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，随着 **__libc_start_main** 的结果，我们已经到达了实际的 main 函数。这是我们期望程序驻留的地方。
- en: These details offer deeper insights into program execution, optimization opportunities,
    and debugging capabilities. Mastery of the ELF file format enables you to optimize
    performance by leveraging specific linker options and understanding dynamic linking
    intricacies. Moreover, it facilitates effective debugging by tracing initialization
    sequences and identifying startup-related issues.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细节提供了对程序执行、优化机会和调试能力的更深入见解。掌握 ELF 文件格式可以使你通过利用特定的链接器选项和理解动态链接的复杂性来优化性能。此外，它通过跟踪初始化序列和识别启动相关的问题，有助于有效的调试。
- en: Oh no, there’s more!
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哦，还有更多！
- en: Now that we’re here, typing on our favorite Linux machine, let’s not waste any
    more time and dive a bit deeper into the internals of some of the compilers that
    come with this great operating system. For example, let’s dig into the **.init_array**
    section of the ELF file. As mentioned previously, it’s responsible for starting
    different functions before the main one.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在这里，在我们最喜欢的Linux机器上打字，让我们不要浪费时间，更深入地了解一下这个伟大操作系统中一些编译器的内部机制。例如，让我们深入研究ELF文件的**.init_array**部分。如前所述，它负责在主函数之前启动不同的函数。
- en: 'But before we continue our journey through these swampy fields, a warning must
    be mentioned: what we’re going to discuss isn’t for faint-hearted C++ programmers,
    to the extent that it isn’t even standard C++. Please read [*Chapter 2*](B22235_02.xhtml#_idTextAnchor026)
    concerning C++ standardness. If you can live with the unholy scripture of compiler
    extensions, then please read on.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们继续穿越这些沼泽地之前，必须提到一个警告：我们接下来要讨论的内容并不适合胆小的C++程序员，甚至它都不是标准的C++。请阅读[*第2章*](B22235_02.xhtml#_idTextAnchor026)有关C++标准性的内容。如果你能忍受编译器扩展的邪恶教条，那么请继续阅读。
- en: 'GCC (as well as Clang) has a very handy extension for executing functions before
    **main()** . These functions are called constructor functions and they need to
    be spawned with a specific attribute:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: GCC（以及Clang）有一个非常方便的扩展，可以在**main()**之前执行函数。这些函数被称为构造函数，并且需要使用特定的属性来生成：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we add this specific piece of code to our synthetic application, we can
    expect the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这段特定的代码添加到我们的合成应用程序中，我们可以期待以下输出：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, the constructor function is being executed before the global
    initialization code. If we dig into the executable with our favorite nine-headed
    spades, we’ll see the following content in the **.** **init_array** section:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，构造函数在全局初始化代码之前执行。如果我们用我们最喜欢的九头铲深入可执行文件，我们将在**.** **init_array**部分看到以下内容：
- en: '![Figure 4.6 – The .init_array section with a constructor function](img/B22235_04_06.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 带有构造函数的 .init_array 部分](img/B22235_04_06.jpg)'
- en: Figure 4.6 – The .init_array section with a constructor function
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 带有构造函数的 .init_array 部分
- en: 'With this knowledge, we now possess two methods of writing code that will be
    executed before the **main()** function in a C++ application: constructor functions
    and global variables.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些知识，我们现在拥有了两种在C++应用程序中**main()**函数之前执行代码的方法：构造函数和全局变量。
- en: 'At this point, we’re in a place where we’ve started scratching the surface
    of something dangerous: the **static initialization order fiasco** . This is a
    subject that’s been debated several times, in various places. These debates summarize
    that this issue arises from the undefined order of initialization of static or
    global variables across different translation units. There are various techniques
    for resolving these issues, but our recommendation is to just **avoid them** .'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经开始触及一些危险的东西：**静态初始化顺序灾难**。这是一个多次在各种地方讨论过的话题。这些讨论总结说，这个问题源于不同翻译单元中静态或全局变量初始化的未定义顺序。有各种技术可以解决这些问题，但我们的建议是**避免它们**。
- en: 'The following example illustrates why this can conjure up dangerous situations.
    Here, we’ve created several short files, again with synthetic content, trying
    to emulate a real-life situation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了为什么这可能会引发危险的情况。在这里，我们创建了几个简短的文件，再次使用合成内容，试图模拟现实生活中的情况：
- en: a.h
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: a.h
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: b.h
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: b.h
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: C.h
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: C.h
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: a.cpp
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: a.cpp
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: b.cpp
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: b.cpp
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: main.cpp
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: main.cpp
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This isn’t extraordinarily complicated code – it’s just a diagnostic **C** class
    that’s used to print out some debugging information and some separate C++ files
    creating objects of the aforementioned diagnostic class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不特别复杂——它只是一个用于打印一些调试信息和创建上述诊断类对象的单独C++文件的诊断**C**类。
- en: 'Normally, these files are compiled with **gcc** , so let’s compile them and
    execute the resulting file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些文件是用**gcc**编译的，所以让我们编译它们并执行生成的文件：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There’s nothing special here – we compiled and created an executable that performed
    what it’s supposed to: print out when a specific object was created and destroyed.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处——我们编译并创建了一个可执行文件，它执行了它应该执行的操作：在创建和销毁特定对象时打印出来。
- en: But what happens if we specify the files in a different order?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们以不同的顺序指定文件会发生什么呢？
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What a surprise. Now, the **b_c** object from **b.cpp** is created before the
    **a_c** object from **a.cpp** . Now, imagine the disastrous situation where our
    program is made up of global objects that depend on the pre-existence of some
    other global objects to be initialized correctly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 真是令人惊讶。现在，**b.cpp** 中的 **b_c** 对象在 **a.cpp** 中的 **a_c** 对象之前创建。现在，想象一下我们的程序由依赖于某些其他全局对象正确初始化的全球对象组成的灾难性情况。
- en: Thankfully, the compiler ecosystem under Linux provides us with the necessary
    tools to achieve a sane state of our applications concerning this matter, with
    the help of a very handy extension. This extension is used to specify the initialization
    order for global members and it manifests itself using the **__attribute__((init_priority(XXX)))**
    syntax.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Linux下的编译器生态系统为我们提供了必要的工具，帮助我们实现应用程序在这个问题上的合理状态，借助一个非常方便的扩展。这个扩展用于指定全局成员的初始化顺序，并使用
    **__attribute__((init_priority(XXX)))** 语法体现出来。
- en: Both **gcc** and **clang** provide this way to control the initialization order
    of **namespacescope** objects across translation units using the **init_priority**
    attribute. This attribute allows users to assign a relative priority to the initialization,
    with priority values ranging from **101** to **65535** inclusive. Lower numbers
    correspond to higher priority, meaning objects with lower i **nit_priority** values
    will be initialized earlier.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**gcc** 和 **clang** 都提供了这种方式来控制跨翻译单元的 **namespacescope** 对象的初始化顺序，使用 **init_priority**
    属性。这个属性允许用户为初始化分配一个相对优先级，优先级值从 **101** 到 **65535**（包含）不等。数字越小，优先级越高，这意味着具有较低 **init_priority**
    值的对象将更早初始化。'
- en: 'Armed with this knowledge, let’s modify our synthetic example files so that
    they use this extension:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，让我们修改我们的合成示例文件，以便它们使用这个扩展：
- en: a.cpp
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: a.cpp
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: b.cpp
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: b.cpp
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, regardless of the order in which **a.cpp** and **b.cpp** are introduced
    to the compiler, the result will be the same:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论 **a.cpp** 和 **b.cpp** 的引入顺序如何，结果都将相同：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s return to our first synthetic application – the one that tried to
    create global objects but in the same translation unit. And also introduced the
    notion of “constructor” functions. Let’s see what happens if we specify initialization
    priority for one of the global objects, and what the order will be in that case:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的第一个合成应用程序——那个尝试在同一个翻译单元中创建全局对象的应用程序。同时也引入了“构造函数”的概念。让我们看看如果我们为其中一个全局对象指定初始化优先级会发生什么，以及在这种情况下顺序会是什么：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Surprisingly, the output will be as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，输出结果如下：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In order to grasp a deeper understanding of the mechanics behind the scenes,
    and to understand why this scenario happened we run our beloved tool on the compiled
    binary. The result confirms our finding as per the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入理解幕后机制，并了解为什么会出现这种场景，我们运行了我们钟爱的工具在编译后的二进制文件上。结果证实了我们的发现，如下截图所示：
- en: '![Figure 4.7 – The .init_array section according to gcc with the specified
    init priority](img/B22235_04_07.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 根据gcc指定的初始化优先级显示的 .init_array 部分](img/B22235_04_07.jpg)'
- en: Figure 4.7 – The .init_array section according to gcc with the specified init
    priority
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 根据gcc指定的初始化优先级显示的 .init_array 部分
- en: The output happens to be as it is because the **.init_array** section has gained
    a new member that’s to be executed before the constructor and the standard global
    initialization code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 输出之所以如此，是因为 **.init_array** 部分增加了一个新成员，它需要在构造函数和标准全局初始化代码之前执行。
- en: 'It isn’t hard to guess that the name of the new function contains the initialization
    priority. What however still baffles the author is why **gcc** decided to continuously
    use **my_string** as a postfix for the variable names. This must be a **gcc**
    specificity because the same executable compiled with **clang** produces the following
    **.** **init_array** section:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 并不难猜测新函数的名称包含初始化优先级。然而，让作者感到困惑的是，为什么 **gcc** 决定持续使用 **my_string** 作为变量名称的后缀。这必须是
    **gcc** 的特性，因为用 **clang** 编译的相同可执行文件产生了以下 **.** **init_array** 部分：
- en: '![Figure 4.8 – Clang’s different .init_array section for the same init priority](img/B22235_04_08.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – Clang对于相同初始化优先级的不同的 .init_array 部分](img/B22235_04_08.jpg)'
- en: Figure 4.8 – Clang’s different .init_array section for the same init priority
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – Clang对于相同初始化优先级的不同的 .init_array 部分
- en: The author has found it interesting why there’s such a difference between how
    **gcc** and **clang** handle this critical section of the object file. However,
    without analyzing the source files of these compilers further, this will remain
    a mystery.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作者发现，为什么**gcc**和**clang**在处理对象文件的这个关键部分时存在如此大的差异，这很有趣。然而，在没有进一步分析这些编译器的源文件的情况下，这仍将是一个谜。
- en: A library is the delivery room for the birth of ideas unexpected behavior
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库是意外行为和思想诞生的分娩室
- en: So far, we’ve been the happy parents of a single application. Now, the time
    has come for our lovechild to mature and marry a … meaning, in order to adhere
    to some common sense and more advanced programming practices, we want to factor
    out some very useful functionality of our synthetic code into a synthetic library
    and call it **synth** . Pardon – I mean **libsinth** .
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是单一应用程序的快乐的父母。现在，我们的爱情结晶成熟并准备结婚……意味着，为了遵循一些常识和更高级的编程实践，我们希望将合成代码中的一些非常有用的功能提取到一个合成库中，并将其命名为**synth**。抱歉——我的意思是**libsinth**。
- en: And since the main focus of this chapter is still the dissection of code execution
    before **main()** ( *1* ), and since we are happily advocating for gcc (and clang)
    extensions (2), let’s see what happens if we hitch all these together in an unholy
    matrimony of code and data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的主要焦点仍然是**main()**之前的代码执行分析（*1*），并且我们愉快地提倡gcc（和clang）的扩展（2），让我们看看如果我们将所有这些组合在一起会发生什么，这是一种代码和数据的不神圣的婚姻。
- en: As a side note, we’ll use our second synthetic example, where **a.cpp** and
    **b.cpp** remained unchanged from their last stage, which includes the required
    initialization order. We’ll create a new **main.cpp** file to utilize the library
    itself, and we’ll also introduce the library’s source code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我们将使用我们的第二个合成示例，其中**a.cpp**和**b.cpp**在其最后阶段保持未变，这包括所需的初始化顺序。我们将创建一个新的**main.cpp**文件来利用库本身，并且我们还将引入库的源代码。
- en: 'Our library will be constructed from the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的库将由以下代码构建：
- en: synth.cpp
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: synth.cpp
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: synth.h
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: synth.h
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Besides defining the global object **synth_c** of type **C** (as defined in
    the **C.h** header) and has an initialization priority of **2000** , we also define
    a function called **welcome_library** marked with **__attribute__((constructor))**
    , ensuring it runs before **main()** and prints “welcome to the library.”
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义全局对象**synth_c**，其类型为**C**（如**C.h**头文件中定义的）并且具有**2000**的初始化优先级之外，我们还定义了一个名为**welcome_library**的函数，带有**__attribute__((constructor))**标记，确保它在**main()**之前运行并打印“欢迎来到库。”
- en: Additionally, the **print_synth** function prints a message that states the
    value that was obtained from **synth_c.get()** . The **C.h** header is the one
    from a few pages prior – it defines the class **C** , along with all the required
    methods and constructors to create objects properly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**print_synth**函数打印一条消息，说明从**synth_c.get()**获得的值。**C.h**头文件是几页前的那个——它定义了类**C**，以及创建对象所需的所有方法和构造函数。
- en: To use this library, we’ll need to create the corresponding underlying infrastructure
    for it. This consists of the two aforementioned files and an application that
    uses the features exposed by it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个库，我们需要为其创建相应的底层基础设施。这包括上述两个文件和一个使用其公开特性的应用程序。
- en: To keep on track, we’ll need to modify our main file so that it uses the library’s
    features. However, we also want to keep the test source files we created for this
    scenario.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持进度，我们需要修改我们的主文件，使其使用库的功能。然而，我们还想保留为这种场景创建的测试源文件。
- en: 'So, our application will contain the aforementioned **a.cpp** and **b.cpp**
    files, as well as our new **main.cpp** file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的应用程序将包含上述**a.cpp**和**b.cpp**文件，以及我们的新**main.cpp**文件：
- en: main.cpp
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: main.cpp
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To make everything work properly, we need to link these items and turn them
    into a working application:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一切正常工作，我们需要将这些项目链接起来，并将它们转换成一个可工作的应用程序：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, at this stage, we’ve created a **static** library, **libsynth.a**
    , and linked our main application to it to incorporate all the code in the library
    properly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这个阶段，我们已经创建了一个**静态**库，**libsynth.a**，并将我们的主应用程序链接到它，以正确地包含库中的所有代码。
- en: Please note that there is no *c.cpp* file because, to be as compact as possible,
    we’ve provided all the implementation of the class in the header file. For bigger
    projects, this isn’t best practice because a small change in the implementation
    of any functions of the class will require all the files that include the header
    to be recompiled. However, for this very peculiar situation, we can live with
    it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有*c.cpp*文件，因为为了尽可能紧凑，我们在头文件中提供了类的所有实现。对于更大的项目，这并不是最佳实践，因为对类中任何函数实现的任何小更改都要求重新编译包含头文件的所有文件。然而，对于这种情况，我们可以接受。
- en: 'Since we’re interested in the order of execution of the various constructs
    we’ve created, after running the resulting application, we get the following output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对我们所创建的各种构造的执行顺序感兴趣，在运行结果应用程序后，我们得到以下输出：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To dig a bit deeper into the innards of the freshly compiled executable file,
    we’ll open it with our beloved tool, **Ghidra** , and locate the section we’re
    most interested in: the **.** **init_array** section.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解新编译的可执行文件内部结构，我们将使用我们喜爱的工具**Ghidra**打开它，并定位我们最感兴趣的章节：**.** **init_array**章节。
- en: 'After a quick inspection, we can see that the order of the printouts corresponds
    to the order of the functions in the **.** **init_array** section:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 经过快速检查，我们可以看到打印顺序与**.** **init_array**章节中函数的顺序相对应：
- en: '![Figure 4.9 – The .init_array section for different init priorities in different
    files](img/B22235_04_09.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9——不同文件中不同初始化优先级的.init_array章节](img/B22235_04_09.jpg)'
- en: Figure 4.9 – The .init_array section for different init priorities in different
    files
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9——不同文件中不同初始化优先级的.init_array章节
- en: Here, **_GLOBAL__sub_I_welcome_main** is the function creating the global object
    in **main.cpp** – that is, **C main_c("main") ;** . Interesting! At this point,
    we’re convinced that the order of initialization for global objects works even
    after libraries – at least static ones.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**_GLOBAL__sub_I_welcome_main**是创建**main.cpp**中全局对象的函数——即**C main_c("main")
    ;**。有趣！在这个时候，我们确信全局对象的初始化顺序即使在库之后——至少是静态库——也是有效的。
- en: 'But we’re still not done. Let’s see what happens if we create a shared library.
    That isn’t that complicated. After removing the generated files – that is, **synth.o**
    , **libsynth.a** , and **main** – so that we have a clean plate, we need to run
    the following command to create a shared library:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有完成。让我们看看如果我们创建一个共享库会发生什么。这并不复杂。在移除生成的文件——即**synth.o**、**libsynth.a**和**main**——以便我们有一个干净的起点后，我们需要运行以下命令来创建一个共享库：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, we can see how easily those magic switches fall into place from the beginning
    of this chapter, where we created a shared library and application that uses it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到从本章开始创建共享库和应用程序的整个过程是如何轻松地实现那些神奇开关的。
- en: 'With all these pieces in place, we can see an interesting change in how Ghidra
    presents the application overview:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些部分就绪后，我们可以看到Ghidra如何展示应用程序概述的一个有趣的变化：
- en: '![Figure 4.10 – The synth library as a dependency, as shown in Ghidra](img/B22235_04_10.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10——Ghidra中显示的作为依赖项的synth库](img/B22235_04_10.jpg)'
- en: Figure 4.10 – The synth library as a dependency, as shown in Ghidra
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10——Ghidra中显示的作为依赖项的synth库
- en: 'Here, we can see a dependency on the **libsynth.so** library we just created.
    Now, we can examine the part that interests us most regarding the executable –
    **.** **init_array** :'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到对刚刚创建的**libsynth.so**库的依赖。现在，我们可以检查关于可执行文件最感兴趣的部分——**.** **init_array**：
- en: '![Figure 4.11 – No reference to libsynth in the .init_array section](img/B22235_04_11.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11——.init_array章节中没有对libsynth的引用](img/B22235_04_11.jpg)'
- en: Figure 4.11 – No reference to libsynth in the .init_array section
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11——.init_array章节中没有对libsynth的引用
- en: 'There’s no reference at all to the objects and functions in our synth library…
    No wonder – it’s a library. But at least we can still see that our application
    links to the library properly:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的synth库中的对象和函数完全没有引用……难怪——它是一个库。但至少我们可以看到我们的应用程序正确地链接到库：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Please observe that we have to specify **LD_LIBRARY_PATH=.** explicitly to find
    the library (note that we’ve also truncated unnecessary output lines to keep things
    clear).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须明确指定**LD_LIBRARY_PATH=.**以找到库（注意，我们已截断不必要的输出行以保持内容清晰）。
- en: 'At this point, we’re curious about what happens when we execute the application:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们很好奇当执行应用程序时会发生什么：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, according to the expectations set by the single application test, the
    object(s) with the specified priority(ies) is(are) created in the library. Then,
    the constructor function from the library is called. If there were any other non-prioritized
    global objects in the library, they would have been created after these, before
    the prioritized objects from the main application were created and the constructor
    from the main application was called. All these operations were performed before
    the **main()** function even had the chance to say *hush* .
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，根据单应用程序测试设定的预期，具有指定优先级（优先级）的对象在库中创建。然后，调用库中的构造函数。如果库中还有其他非优先级的全局对象，它们将在这些对象之后创建，在主应用程序的优先级对象创建之前，以及主应用程序的构造函数被调用之前。所有这些操作都是在
    **main()** 函数甚至有机会说“安静”之前完成的。
- en: Almost as we expected it to happen. There’s just one dark corner of these function
    constructor extensions that I’ve been unable to find a cure for at the moment
    – what if **a.cpp** and **b.cpp** contain the following lines?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎就像我们预期的那样发生。只是这些函数构造扩展的一个阴暗角落，我目前还没有找到解决办法——如果 **a.cpp** 和 **b.cpp** 包含以下行？
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This unholy scribbling of spooky code adds two more constructor functions to
    our executable. Now, we have three. If you want to have a predictable order of
    execution for these constructor functions too, you need to specify their priority
    using **__attribute__((constructor(205))) void welcome_b()** . This will guarantee
    that these functions will also be executed in a specific order and that you’re
    not facing the global constructor invoking order fiasco.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这不神圣的神秘代码添加了两个更多的构造函数到我们的可执行文件中。现在，我们有三个了。如果你也想为这些构造函数指定一个可预测的执行顺序，你需要使用 **__attribute__((constructor(205)))
    void welcome_b()** 来指定它们的优先级。这将保证这些函数也将按照特定的顺序执行，并且你不会遇到全局构造函数调用顺序的混乱。
- en: The behavior in case the library was dynamically loaded ( **dlopen** / **dlclose**
    ) is the one that one would expect, i.e. it follows the execution flow of the
    main application, and at the point where the library is loaded, it will jump and
    execute the various constructors and object initializations from the library.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当库被动态加载（**dlopen** / **dlclose**）时的行为是人们预期的，即它遵循主应用程序的执行流程，在库被加载的点，它将跳转并执行库中的各种构造函数和对象初始化。
- en: Famous last words
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后的话
- en: This chapter dealt with code that is executed before the main function. However
    the same attention would require the topic covering the code that is executed
    after the main function, but that debate will go in a different chapter, in a
    different book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了在主函数之前执行的代码。然而，对于在主函数之后执行的代码也需要同样的关注，但这个讨论将在另一章、另一本书中进行。
- en: 'But just to spoil you, here’s a small hint: the same way as there are constructor
    functions, there are also destructor functions. They’re not like C++ destructors
    – more like **__attribute__((destructor))** .'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了给你一些提示，这里有一个小提示：就像有构造函数一样，也有析构函数。它们不像 C++ 的析构函数——更像是 **__attribute__((destructor))**。
- en: Spicing those up with the standard application exit routines, we have twice
    as much fun as the startup because we have to consider a myriad of other alternatives,
    such as functions registered for **std::atexit** (or even **std::quick_exit**
    ), or abnormal program termination. For example, let’s say an exception is thrown
    in a destructor or we use **std::terminate** or **std::abort** .
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 用标准的程序退出例程来增加这些，我们比启动时更有乐趣，因为我们必须考虑无数的其他替代方案，例如注册给 **std::atexit**（甚至 **std::quick_exit**）的函数，或者程序的非正常终止。例如，假设在析构函数中抛出一个异常，或者我们使用
    **std::terminate** 或 **std::abort**。
- en: The documentation on **gcc** and **clang** offers a nice escapade from the standard
    world, and any good book on C++ will offer a great overview of the standard termination
    routines, so please head over to them for a good lecture. A combination of these
    two will provide the best overview of how applications start and exit.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**gcc** 和 **clang** 的文档提供了一个从标准世界中的美好逃避，任何关于 C++ 的好书都会提供一个关于标准终止例程的全面概述，所以请前往它们那里听一场精彩的讲座。这两个的结合将提供关于应用程序如何启动和退出的最佳概述。'
- en: For now, we’ll shift our attention toward other platforms before we get a good
    wigging from the folks at Packt – instead of the agreed-upon 16 pages for this
    chapter, we’re already at 22 and covered only half of the promised subject.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从 Packt 的人那里得到满意的反馈之前，我们将把注意力转向其他平台——而不是本章节约定的 16 页，我们目前已经达到了 22 页，但只覆盖了承诺主题的一半。
- en: Let’s open the Windows (unless you’re on ISS)
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们打开 Windows（除非你在 ISS 上）
- en: Before we delve deep into the internals of how an application is executed under
    Windows and the steps we must take to reach our main function, please note that
    from C++’s point of view, there should be no real difference from Linux or any
    other operating system. The C++-only standard functionality is (should be) identical
    to the functionality presented in the previous pages, so we won’t repeat the same
    information here.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨 Windows 下应用程序执行的内幕以及我们必须采取的步骤以到达主函数之前，请注意，从 C++ 的角度来看，与 Linux 或任何其他操作系统之间不应有真正的区别。仅
    C++ 的标准功能（应该是）与前面页面中展示的功能相同，因此我们在这里不会重复相同的信息。
- en: We will, however, present how and why the application starts under Windows the
    way it does and present some techniques that can directly influence this behavior,
    just like we did under Linux. We’ll also be using a Visual Studio compiler since
    **gcc** and **clang** for Windows behave identically, so there’s no sense in presenting
    them again.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将展示应用程序在 Windows 下如何以及为什么以这种方式启动，并介绍一些可以直接影响这种行为的技巧，就像我们在 Linux 下做的那样。我们还将使用
    Visual Studio 编译器，因为 Windows 下的 **gcc** 和 **clang** 行为相同，所以没有必要再次展示它们。
- en: 'Due to its closed nature, to understand process creation under Windows, we
    need to resort to the few available resources that deal with this kind of information.
    One of these resources is the best book I’ve managed to find in this domain: *Windows
    Internals, 7th edition (Part 1)* , [7](B22235_04.xhtml#footnote-010) by Pavel
    Yosifovich, Alex Ionescu, Mark E. Russinovich, and David A. Solomon.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其封闭性，要理解 Windows 下的进程创建，我们需要求助于处理这类信息的少数可用资源。其中之一是我在这个领域找到的最好的书：*《Windows
    内部机制，第 7 版（第一部分）》，[7](B22235_04.xhtml#footnote-010) ，由 Pavel Yosifovich、Alex Ionescu、Mark
    E. Russinovich 和 David A. Solomon 撰写。
- en: '[7](B22235_04.xhtml#footnote-010-backlink) [https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals](https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[7](B22235_04.xhtml#footnote-010-backlink) [https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals](https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals)'
- en: 'The information gathered from that book is complemented by various scraps gathered
    from the world wide internet, and filtered in order to offer our readers a light
    introduction to the Windows side of process creation. We will reference back however
    some of the notions encountered in the Linux subsection of this chapter, so reading
    it would be beneficial. Also, a small observation: security, thread handling,
    and user management are much more fine-tuned in Windows than in Linux, and all
    this is reflected in the way processes are treated. If you’re interested in understanding
    this domain, there are several resources available, such as the excellent *Windows
    Security Internals: A Deep Dive into Windows Authentication, Authorization, and
    Auditing* , by James Forshaw. We recommend reading through it if you’re interested
    in the domain.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从那本书中获得的信息得到了从全球互联网收集的各种零散信息的补充，并经过筛选，以便为读者提供对 Windows 进程创建方面的轻量级介绍。然而，我们将回溯参考本章
    Linux 小节中遇到的一些概念，因此阅读它会有所帮助。此外，一个小观察：与 Linux 相比，Windows 在安全性、线程处理和用户管理方面更加精细，所有这些都反映在处理进程的方式上。如果你对这个领域感兴趣，有几种资源可用，例如
    James Forshaw 的优秀作品 *《Windows 安全内部机制：深入 Windows 认证、授权和审计》*。如果你对这个领域感兴趣，我们建议你阅读它。
- en: 'Let’s get back to the processes. The process creation mechanism in Windows
    involves several stages that are executed by different components of the operating
    system: the Windows client-side library, **kernel32.dll** , the Windows executive,
    and the Windows subsystem process ( **csrss.exe** ). Due to the simple fact that
    we don’t have access to the sources of these Windows components, our presentation
    on this matter will be a very high-level one.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到进程上来。Windows 中的进程创建机制涉及几个阶段，这些阶段由操作系统的不同组件执行：Windows 客户端库、**kernel32.dll**、Windows
    执行器和 Windows 子系统进程（**csrss.exe**）。由于我们没有访问这些 Windows 组件源代码的权限，我们对这个问题的介绍将非常高级。
- en: Processes in Windows are created by a function of the CreateProcess family,
    which comes with several relatives and uncles ( **create process** as a different
    user, create process with various security clearances, etc…) but all members of
    the extended family routines after several iterations end up in the CreateProcessInternalW
    function in **kernel32.dll** , which first validates and converts some of the
    parameters and flags to an internal representation (to which sadly we have no
    access).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Windows中的进程是通过CreateProcess家族的函数创建的，该家族有几个亲戚和叔叔（**以不同用户创建进程**、**以各种安全许可创建进程**等……）但经过几次迭代后，扩展家族例程的所有成员最终都会进入**kernel32.dll**中的CreateProcessInternalW函数，该函数首先验证并转换一些参数和标志为内部表示（遗憾的是我们无法访问）。
- en: 'The priority class for the new process is determined by the **CreationFlags**
    parameter. In Windows, there are six priority classes: Idle, Below Normal, Normal,
    Above Normal, High, and Real-time. If no priority class is specified, the priority
    class defaults to Normal. If Real-time is requested but the caller lacks the necessary
    privileges, the priority is downgraded to High.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 新进程的优先级类别由**CreationFlags**参数确定。在Windows中，有六个优先级类别：空闲、低于正常、正常、高于正常、高和实时。如果没有指定优先级类别，则默认优先级类别为正常。如果请求实时优先级但调用者缺乏必要的权限，则优先级将降级为高。
- en: Next, **kernel32.dll** initiates a connection to the native debugging interface
    if the process is to be debugged and sets the default hard error mode if specified.
    The user-specified attribute list is converted into its native format, and any
    additional internal attributes are added. The security attributes for the process
    and initial thread are also converted into internal representations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果进程需要调试，**kernel32.dll**将启动与本地调试接口的连接，并设置默认的硬错误模式（如果指定）。用户指定的属性列表被转换为它的本地格式，并添加任何额外的内部属性。进程和初始线程的安全属性也被转换为内部表示。
- en: The next step is to open the executable image to be run. This task is handled
    within the **NtCreateUserProcess** system call. First, the function validates
    the arguments again to ensure they haven’t been tampered with. Then, it attempts
    to find and open the appropriate Windows image and create a section object, which
    will be mapped into the new process’s address space at a later date.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是打开要运行的可执行映像。这个任务由**NtCreateUserProcess**系统调用处理。首先，该函数再次验证参数以确保它们没有被篡改。然后，它尝试找到并打开适当的Windows映像并创建一个将在稍后日期映射到新进程地址空间的部分对象。
- en: If the image isn’t a valid Windows executable, the function searches for a support
    image to run it. For instance, if the executable is an MS-DOS or Win16 application,
    it uses **ntvdm.exe** (for 32-bit Windows) to run it. This ensures that older
    DOS or Win16 applications can be executed correctly within the Windows environment.
    However, this feature has been slowly deprecated on modern Windows systems, so
    you need to enable it so that it can function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果映像不是一个有效的Windows可执行文件，该函数将搜索一个支持映像来运行它。例如，如果可执行文件是一个MS-DOS或Win16应用程序，它将使用**ntvdm.exe**（用于32位Windows）来运行它。这确保了较老的DOS或Win16应用程序可以在Windows环境中正确执行。然而，这一特性在现代Windows系统中已被逐渐弃用，因此您需要启用它才能使其正常工作。
- en: Once the executable image has been opened, the next stage is to create the Windows
    executive process object. This involves setting up the process’s virtual address
    space and other critical structures. The executive process object serves as a
    container for all the resources needed by the process, including memory, handles,
    and threads.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行映像一旦被打开，下一个阶段就是创建Windows执行进程对象。这涉及到设置进程的虚拟地址空间和其他关键结构。执行进程对象作为所有进程所需资源的容器，包括内存、句柄和线程。
- en: With the process object in place, the initial thread is created. This step involves
    setting up the thread’s stack, context, and executive thread object. The thread
    is responsible for executing the program’s entry point and managing the process’s
    execution flow.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置进程对象之后，创建初始线程。这一步包括设置线程的堆栈、上下文和执行线程对象。线程负责执行程序的入口点并管理进程的执行流程。
- en: After the initial thread is created, Windows performs subsystem-specific initialization
    tasks. These tasks are essential for integrating the new process into the Windows
    subsystem, which provides the environment and resources necessary for the process
    to run correctly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建初始线程之后，Windows执行子系统特定的初始化任务。这些任务对于将新进程集成到Windows子系统至关重要，该子系统为进程正确运行提供环境和资源。
- en: The initial thread is then started, unless the **CREATE_SUSPENDED** flag is
    specified, in which case the thread remains suspended until it’s explicitly resumed.
    Starting the thread involves switching to user mode and executing the process’s
    entry point.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后启动初始线程，除非指定了**CREATE_SUSPENDED**标志，在这种情况下，线程将保持挂起状态，直到显式恢复。启动线程涉及切换到用户模式并执行进程的入口点。
- en: Finally, in the context of the new process and thread, the address space is
    initialized. This includes loading any required DLLs and performing any other
    necessary setup tasks. Once these steps are complete, the process begins executing
    its code, and process creation is considered complete.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在新的进程和线程的上下文中，地址空间被初始化。这包括加载所需的DLL以及执行任何其他必要的设置任务。一旦这些步骤完成，进程开始执行其代码，进程创建被认为是完成的。
- en: To PE or not to PE
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是PE还是非PE
- en: Like every other file with a specific meaning, the bytes that conjure up Windows-based
    executables also have a special meaning.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他具有特定意义的文件一样，构成基于Windows的可执行文件的字节也有特殊含义。
- en: The Windows **Portable Executable** ( **PE** ) format is a file format for executables,
    object code, DLLs, and other system files that are used in Windows operating systems.
    It’s the standard file format for executables in DOS (as well as FreeDOS), Windows,
    and ReactOS and encompasses both the **executable** ( **EXE** ) and **Dynamic
    Link Library** ( **DLL** ) file types.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Windows **可移植可执行文件**（**PE**）格式是用于在Windows操作系统中的可执行文件、对象代码、DLL和其他系统文件的文件格式。它是DOS（以及FreeDOS）、Windows和ReactOS中可执行文件的标准文件格式，并包括**可执行文件**（**EXE**）和**动态链接库**（**DLL**）文件类型。
- en: The PE format is designed to be extensible and capable of supporting modern
    operating system features. If you’re interested in this domain, there are excellent
    learning opportunities online, so we encourage you to study this subject since
    this book can’t encompass all the required information due to lack of space.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: PE格式被设计为可扩展的，并且能够支持现代操作系统功能。如果您对这个领域感兴趣，网上有很好的学习机会，所以我们鼓励您学习这个主题，因为这本书由于空间有限无法涵盖所有必需的信息。
- en: 'Here’s a filtered explanation of its structure and components, mostly the ones
    relevant to this chapter:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对其结构和组件的过滤解释，主要与本章相关的内容：
- en: '**DOS** **header (IMAGE_DOS_HEADER)** :'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DOS** **头（IMAGE_DOS_HEADER）**：'
- en: The file begins with **MZ** , the initials of Mark Zbikowski, the engineer who
    created this format while working at Microsoft. This is followed by a DOS header,
    which is a relic from the MS-DOS days. This header includes a small DOS stub program
    that displays a message (“This program can’t be run in DOS mode”) if the executable
    is run in a DOS environment. The last section of the DOS header contains a pointer
    to the PE header’s location.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件以**MZ**开头，这是创建此格式的工程师Mark Zbikowski的缩写，当时他在微软工作。接着是一个DOS头，这是MS-DOS时代的遗物。此头包括一个小的DOS存根程序，如果可执行文件在DOS环境中运行，则会显示消息（“此程序不能在DOS模式下运行”）。DOS头的最后部分包含指向PE头位置的指针。
- en: '**PE** **header (IMAGE_NT_HEADERS)** :'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PE** **头（IMAGE_NT_HEADERS）**：'
- en: '**Signature** : This identifies the file as a PE file. The signature is a 4-byte
    value – that is, **PE\0\0** .'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**：这标识了文件是一个PE文件。签名是一个4字节值——也就是说，**PE\0\0**。'
- en: '**File header** ( **IMAGE_FILE_HEADER** ): This contains basic information
    about the file, such as the target machine type, the number of sections, the time
    and date the file was created, and the size of the optional header.'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件头**（**IMAGE_FILE_HEADER**）：这包含有关文件的基本信息，例如目标机器类型、节的数量、文件的创建时间和日期以及可选头的大小。'
- en: '**Optional header** ( **IMAGE_OPTIONAL_HEADER** ): This provides essential
    information for loading and running the program. Despite its name, this header
    is required for executable files and includes the following aspects:'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选头**（**IMAGE_OPTIONAL_HEADER**）：这提供了加载和运行程序所需的基本信息。尽管其名称如此，但此头对于可执行文件是必需的，并包括以下方面：'
- en: '**Magic number** : Identifies the format (for example, PE32 for 32-bit and
    PE32+ for 64-bit)'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**魔数**：标识格式（例如，PE32用于32位和PE32+用于64位）'
- en: '**AddressOfEntryPoint** : The address where execution starts'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AddressOfEntryPoint**：执行开始的地址'
- en: '**ImageBase** : The preferred base address for the executable in memory'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ImageBase**：可执行文件在内存中的首选基本地址'
- en: '**SectionAlignment** : Alignment of sections in memory.'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SectionAlignment**：内存中节的对齐方式。'
- en: '**SizeOfImage** : The total size of the image in memory'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SizeOfImage**：图像在内存中的总大小'
- en: '**Subsystem** : Identifies the required subsystem (Windows GUI or CUI)'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子系统**：标识所需的子系统（Windows GUI或CUI）'
- en: '**Section** **headers (IMAGE_SECTION_HEADER)** :'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节** **标题 (IMAGE_SECTION_HEADER)** :'
- en: 'Following the PE header, there are one or more section headers, each describing
    a section of the file. These sections contain the actual data and code of the
    program. The following are some common sections:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 PE 头部之后，有一个或多个节标题，每个标题描述文件的一个部分。这些部分包含程序的实际上传数据和代码。以下是一些常见的部分：
- en: '**.text** : Contains executable code.'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.text** : 包含可执行代码。'
- en: '**.data** : Contains initialized global and static variables.'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.data** : 包含初始化的全局和静态变量。'
- en: '**.bss** : Contains uninitialized data.'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.bss** : 包含未初始化的数据。'
- en: '**.rdata** : Read-only data (such as string literals and constants).'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.rdata** : 只读数据（例如字符串字面量和常量）。'
- en: '**.idata** : Import table, listing the functions and DLLs that the executable
    depends on.'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.idata** : 导入表，列出可执行文件所依赖的函数和 DLL。'
- en: '**.edata** : Export table, listing functions and data that the executable exposes
    to other modules.'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.edata** : 导出表，列出可执行文件暴露给其他模块的函数和数据。'
- en: '**Data directories** :'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据目录** :'
- en: 'Part of the optional header, these directories provide information about the
    location and size of various tables and data structures within the executable
    file, including:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选头部分的一部分，这些目录提供了关于可执行文件内部各种表和数据结构的位置和大小信息，包括：
- en: '**Import table** : Lists the DLLs and functions imported by the executable.'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入表** : 列出可执行文件导入的 DLL 和函数。'
- en: '**Export table** : Lists the functions and data exported by the executable.'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导出表** : 列出可执行文件导出的函数和数据。'
- en: '**Resource table** : Contains resources that are built into the application,
    such as icons, menus, and dialogs. These resources are stored in a resource tree,
    depending on their type. There’s also support for variations in multiple languages
    for the same resource.'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源表** : 包含嵌入到应用程序中的资源，如图标、菜单和对话框。这些资源根据其类型存储在资源树中。同时，也支持同一资源的多语言变体。'
- en: '**Exception table** : Contains information for exception handling.'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常表** : 包含异常处理的信息。'
- en: '**Relocation table** : Used for address fixups.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重定位表** : 用于地址修正。'
- en: '**Sections** :'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节** :'
- en: The actual sections follow the headers and contain the executable code, initialized
    data, and other components that the program needs to run.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际的节跟在标题后面，包含可执行代码、初始化数据和程序运行所需的其他组件。
- en: Each section is aligned based on the **SectionAlignment** value specified in
    the optional header.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个节都是根据可选头部中指定的 **SectionAlignment** 值对齐的。
- en: For us, the most important and interesting part of this list of sections and
    subsections is the **AddressOfEntryPoint** field.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，这个节和子节列表中最重要的和有趣的部分是 **AddressOfEntryPoint** 字段。
- en: Getting our hands dirty
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入实践
- en: Our initial approach will be a very clean application to work on, a classical
    “Hello World!”
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的方案将是一个非常干净的应用程序，一个经典的“Hello World！”
- en: '[PRE28]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will allow us to understand how a very simple application is loaded and
    executed under Windows. However, before taking things further, a small remark:
    under Windows, there are different kinds of applications, as indicated by the
    **OptionalHeader** / **Subsystem** field in the PE header.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够理解一个非常简单的应用程序在 Windows 下的加载和执行过程。然而，在进一步探讨之前，有一个小注解：在 Windows 下，有不同类型的应用程序，如
    PE 头部中的 **OptionalHeader** / **Subsystem** 字段所示。
- en: For our purpose, which is to dissect an application to examine how it starts,
    we’ll create a Console Application. There are other types of applications we could
    look at, but they’re overly complex. For example, if they have a GUI, then we
    must implement complicated message loops and dependencies, so we’ll stick with
    something simple.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，即剖析应用程序以检查其启动过程，我们将创建一个控制台应用程序。我们还可以查看其他类型的应用程序，但它们过于复杂。例如，如果它们有 GUI，那么我们必须实现复杂的信息循环和依赖关系，所以我们将坚持使用简单的东西。
- en: 'Assuming that we’ve successfully compiled our synthetic console application,
    we can fire up Ghidra and see that a large section of the file resembles the standard
    PE header shown previously:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经成功编译了我们的合成控制台应用程序，我们可以启动 Ghidra 并看到文件的一个大节与之前显示的标准 PE 头部相似：
- en: '![Figure 4.12 – The contents of the PE header](img/B22235_04_12.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – PE 头部的内容](img/B22235_04_12.jpg)'
- en: Figure 4.12 – The contents of the PE header
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – PE 头部的内容
- en: 'This is a lot of information to digest, but what’s interesting for us is the
    **AddressOfEntryPoint** field. At the moment, it points to a method called **entry**
    . This is where our application will start executing, so let’s examine this function
    in a bit more detail. If we dig deeper and see what the entry is, we’ll reach
    the following function:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要消化的信息量，但对我们来说，有趣的是 **AddressOfEntryPoint** 字段。目前，它指向一个名为 **entry** 的方法。这就是我们的应用程序将开始执行的地方，所以让我们更详细地检查这个函数。如果我们进一步挖掘并查看入口是什么，我们会到达以下函数：
- en: '[PRE29]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This in itself is an interesting discovery as it seems to be the entry point
    of console-based Windows applications. Let’s explore this further. The next function
    that’s run is as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身就是一个有趣的发现，因为它似乎是基于控制台的 Windows 应用程序的入口点。让我们进一步探索。接下来运行的函数如下：
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Microsoft’s page [8](B22235_04.xhtml#footnote-009) contains a detailed description
    of the **__security_init_cookie()** function. However, the other function is a
    different kind of beast. It does a large amount of initialization, such as setting
    up the terminal and handling initialization errors. At some point, the following
    piece of code is executed:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的页面 [8](B22235_04.xhtml#footnote-009) 包含了 **__security_init_cookie()** 函数的详细描述。然而，另一个函数则是一种不同的生物。它执行大量的初始化，例如设置终端和处理初始化错误。在某个时刻，以下代码片段被执行：
- en: '[8](B22235_04.xhtml#footnote-009-backlink) [https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[8](B22235_04.xhtml#footnote-009-backlink) [https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170)'
- en: '![Figure 4.13 – The invocation of main()](img/B22235_04_13.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – main() 的调用](img/B22235_04_13.jpg)'
- en: Figure 4.13 – The invocation of main()
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – main() 的调用
- en: 'As you may have guessed, **invoke_main** is responsible for invoking **main()**
    :'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，**invoke_main** 负责调用 **main()**：
- en: '[PRE31]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At this point, we’ve reached the stage where our **main()** function is called.
    Even for a simple “Hello World!” application, there’s a large amount of boilerplate
    code that needs to be executed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经到达了调用我们的 **main()** 函数的阶段。即使是简单的“Hello World！”应用程序，也需要执行大量的样板代码。
- en: Now, it’s time to go one step further and take our synthetic application on
    a ride through Ghidra (for brevity’s sake, we’ll omit that we must create a project,
    compile it, and link the application; let’s just assume the application summons
    itself by magic).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更进一步，并让我们的合成应用程序在 Ghidra 中运行一次（为了简洁起见，我们将省略创建项目、编译和链接应用程序的步骤；让我们假设应用程序通过魔法自行启动）。
- en: 'Since we’re mostly interested in determining the order of function calls before
    **main()** , and we know that we initialize the **my_a** and **my_other_a** variables
    globally, we need to look through the binary. At some point, we’ll spot the following
    interesting data:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们主要感兴趣的是确定在 **main()** 之前的函数调用顺序，并且我们知道我们全局初始化了 **my_a** 和 **my_other_a**
    变量，因此我们需要检查二进制文件。在某个时刻，我们会发现以下有趣的数据：
- en: '![Figure 4.14 – The .CRT$XCU section according to Ghidra](img/B22235_04_14.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 根据 Ghidra 的 .CRT$XCU 部分](img/B22235_04_14.jpg)'
- en: Figure 4.14 – The .CRT$XCU section according to Ghidra
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 根据 Ghidra 的 .CRT$XCU 部分
- en: 'Well, this looks interesting, especially that cryptic **.CRT$XCU** text. This
    takes us back to a few paragraphs prior, where the sections of a PE file were
    discussed: sections are distinct areas within the executable file that hold different
    types of data and code.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这看起来很有趣，特别是那个神秘的 **.CRT$XCU** 文本。这让我们回到了几段之前的讨论，即 PE 文件的各个部分：部分是可执行文件中的不同数据类型和代码的独立区域。
- en: Each section serves a specific purpose and has attributes that define its behavior
    and how it should be handled by the operating system. There’s excellent documentation
    [9](B22235_04.xhtml#footnote-008) on Microsoft’s site that discusses the sections
    responsible for initializing CRT, a quick summary of it follows.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都服务于特定的目的，并具有定义其行为以及操作系统如何处理它的属性。在微软网站上有一份出色的文档 [9](B22235_04.xhtml#footnote-008)，讨论了负责初始化
    CRT 的部分，以下是对其的简要总结。
- en: '[9](B22235_04.xhtml#footnote-008-backlink) [https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170](https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[9](B22235_04.xhtml#footnote-008-backlink) [https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170](https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170)'
- en: According to the documentation, by default, the CRT library is included via
    the linker, which ensures that the CRT is initialized properly, global initializers
    are called, and, subsequently, the user-defined **main()** function is executed.
    When the compiler encounters a global initializer, it creates a dynamic initializer
    and places it in the **.** **CRT$XCU** section.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，默认情况下，CRT库通过链接器包含，这确保了CRT被正确初始化，全局初始化器被调用，随后执行用户定义的**main()**函数。当编译器遇到全局初始化器时，它创建一个动态初始化器并将其放置在**.CRT$XCU**部分。
- en: The CRT uses specific pointers such as **__xc_a** and **__xc_z** in the **.CRT$XCA**
    and **.CRT$XCZ** initialization sections to define the start and end of the list
    of initializers, ensuring they’re called in the correct order. The **__scrt_common_main_seh()**
    function, which we discussed previously, is responsible for setting these up correctly.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: CRT在**.CRT$XCA**和**.CRT$XCZ**初始化部分使用特定的指针，如**__xc_a**和**__xc_z**，来定义初始化器列表的开始和结束，确保它们按正确的顺序调用。我们之前讨论过的**__scrt_common_main_seh()**函数负责正确设置这些。
- en: These names are predefined by the CRT, and the linker arranges these sections
    alphabetically. This ordering ensures that user-defined initializers in **.CRT$XCU**
    are executed between the standard sections.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称是由CRT预定义的，链接器将这些部分按字母顺序排列。这种排序确保用户定义的初始化器在**.CRT$XCU**标准部分之间执行。
- en: To manipulate the initialization order, developers can place their initializers
    in unused reserved sections such as **.CRT$XCT** (before compiler-generated initializers)
    and **.CRT$XCV** (after compiler-generated initializers) using specific pragmas,
    as detailed in the CRT startup documentation mentioned a few paragraphs prior,
    but before jumping on that technique, please read below because things are a bit
    more complicated than they seem.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操纵初始化顺序，开发者可以使用特定的编译器指令将初始化器放置在未使用的保留部分，如**.CRT$XCT**（在编译器生成的初始化器之前）和**.CRT$XCV**（在编译器生成的初始化器之后），具体细节请参阅前面提到的CRT启动文档，但在采用这种技术之前，请阅读以下内容，因为事情比看起来要复杂得多。
- en: 'According to Microsoft, that subject is so platform and compiler-specific that
    we don’t wish to explore those fields, especially considering the warning that
    comes from the official site:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 根据微软的说法，这个主题非常依赖于平台和编译器，我们不希望探索这些领域，特别是考虑到官方网站发出的警告：
- en: “The names .CRT$XCT and .CRT$XCV aren’t used by either the compiler or the CRT
    library right now, but there’s no guarantee that they’ll remain unused in the
    future. And, your variables could still be optimized away by the compiler. Consider
    the potential engineering, maintenance, and portability issues before adopting
    this technique.”
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: “目前，编译器和CRT库都没有使用**.CRT$XCT**和**.CRT$XCV**这两个名称，但无法保证它们将来不会被使用。此外，你的变量可能仍然会被编译器优化掉。在采用这项技术之前，请考虑潜在的工程、维护和可移植性问题。”
- en: 'So, once again, we’ll just repeat what the official warning said: unless you
    have to do this kind of hackery, please refrain from using these halfheartedly
    documented “features” of the language and compiler since (again, as mentioned
    in the official warning) there’s no guarantee that if it works today, it will
    work tomorrow, or even after the next system update.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们再次重复官方警告的内容：除非你真的需要进行这种黑客行为，否则请避免使用这些半文档化的“特性”和编译器的语言，因为（正如官方警告中提到的）没有保证如果今天它能工作，明天或下一次系统更新后它仍然能工作。
- en: 'Instead, let’s turn our attention toward the functions that we “discovered”
    in the **.CRT$XCU** section and see what kind of sorcery lies behind this very
    explicit name, which undoubtedly isn’t standard C ( nor C++):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们将注意力转向我们在**.CRT$XCU**部分“发现”的函数，看看这个非常明确的名字背后隐藏着什么样的魔法，毫无疑问这不是标准的C（也不是C++）：
- en: '[PRE32]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After performing some maintenance tasks (such as initializing the stack with
    the **0xcccccccc** value), we can see the function call to the constructor of
    **A** , with stylishly the first parameter being the **this** object, and registering
    an **atexit** function for the destructor of the class for the specific object,
    again.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行一些维护任务（例如使用**0xcccccccc**值初始化堆栈）之后，我们可以看到对类**A**构造函数的函数调用，其中第一个参数是**this**对象，并且为特定对象的类析构函数注册了一个**atexit**函数，再次。
- en: This **0xcccccccc** pattern is the typical way the Visual C++ compiler marks
    uninitialized stack memory, making it easier to detect the use of uninitialized
    memory in debugging sessions. Interestingly, the loop doesn’t seem to execute.
    However, if we were to dig deeper into the debug builds of functions that have
    larger C-style arrays, we’d see this stack protection scheme in action, together
    with some nicely set-up stack canaries.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这种**0xcccccccc**模式是Visual C++编译器标记未初始化堆栈内存的典型方式，这使得在调试会话中更容易检测到未初始化内存的使用。有趣的是，循环似乎并没有执行。然而，如果我们深入挖掘具有较大C风格数组的函数的调试构建，我们会看到这个堆栈保护方案的实际应用，以及一些设置得很好的堆栈看门狗。
- en: Stack canaries are a security mechanism designed to detect and prevent stack-based
    buffer overflow attacks by placing a special value (called the canary) between
    a function's local variables and its control data on the stack (such as the return
    address and the saved frame pointer).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈看门狗是一种安全机制，通过在函数的局部变量和其堆栈上的控制数据（如返回地址和保存的帧指针）之间放置一个特殊值（称为看门狗），旨在检测和防止基于堆栈的缓冲区溢出攻击。
- en: If a buffer overflow occurs, the canary value is altered, signaling that some
    mischief has taken place. This allows the program to take corrective actions,
    such as terminating execution to prevent exploitation.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生缓冲区溢出，看门狗值会改变，这表明发生了某种破坏行为。这允许程序采取纠正措施，例如终止执行以防止利用。
- en: The origin of this term is a bit obscure, and it goes back to the historical
    use of canaries in coal mines. Miners would bring canaries into the mines to detect
    toxic gases such as carbon monoxide. Since canaries are more sensitive to these
    gases than humans, if the bird became ill or died (that is, it stopped singing),
    it served as an early warning signal for miners to evacuate. This isn’t quite
    of mythological proportions, but it’s pragmatic – especially if you’re the miner,
    not the canary.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个术语的起源有些晦涩，它追溯到历史上在煤矿中使用看门狗的情况。矿工会把金丝雀带入矿井以检测一氧化碳等有毒气体。由于金丝雀对这些气体比人类更敏感，如果鸟儿生病或死亡（即停止唱歌），它就会作为矿工撤离的早期预警信号。这并不完全是神话般的比例，但它是实用的——尤其是如果你是矿工，而不是金丝雀。
- en: With these notions set in place, we have an overview of how the application
    loads under Windows, but only from the console. But let’s not forget that Windows
    is a GUI environment. It creates windows and dialogs, has a message loop, and
    deals with a plethora of events.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些概念确立之后，我们对应用程序在Windows下的加载过程有一个概述，但仅限于控制台。但不要忘记，Windows是一个GUI环境。它创建窗口和对话框，有一个消息循环，并处理大量的事件。
- en: However, the startup process of a Windows GUI application isn’t that dissimilar
    to a console-based application. The main difference is that the **invoke_main**
    function invokes two different functions before invoking a GUI-specific **WinMain**
    function, dealing with the show state of the window and the command line options.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Windows GUI应用程序的启动过程与基于控制台的应用程序并没有太大的不同。主要区别在于，在调用GUI特定的**WinMain**函数之前，**invoke_main**函数会调用两个不同的函数，处理窗口的显示状态和命令行选项。
- en: The first function allows us to show the window of the application in different
    ways.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数允许我们以不同的方式显示应用程序的窗口。
- en: The second function is the command line of the application, in a wide string
    format.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数是应用程序的命令行，以宽字符串格式。
- en: The rest is just calling the **WinMain** and from there, we are in familiar
    territory, at least programmers who have experience in this domain.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的只是调用**WinMain**，从那里，我们进入了熟悉的领域，至少对于在这个领域有经验的程序员来说是这样。
- en: In closing this chapter, there’s nothing else but encourage our readers to experiment
    while hacking around binaries – that’s the only way to truly understand how a
    specific functionality will behave on your system.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章时，除了鼓励读者在破解二进制文件时进行实验之外，别无他法——这是真正理解特定功能如何在您的系统上运行的唯一方法。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, the author tried to provide a not-so-comprehensive overview
    of the application startup processes on both Linux and Windows. The insights that
    were provided into the initial stages of execution, including the critical steps
    before reaching the **main()** function, weren’t as complete as the platforms
    themselves require, but then this book would have been called something else since
    this is a huge and very niche topic that doesn’t attract a broad range of programmers.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，作者试图提供一个并非全面概述的Linux和Windows上的应用启动过程。对于执行初始阶段，包括到达**main()**函数之前的临界步骤，所提供的见解并不像平台本身所要求的那样完整，但既然这是一个巨大且非常狭窄的话题，它不会吸引广泛的程序员，所以这本书的名称也就不会是别的了。
- en: By exploring ELF on Linux, understanding the **execve()** system call, and examining
    the **_start()** function, you gained valuable knowledge about the underlying
    architecture and initialization routines. Similarly, the discussion on Windows
    highlighted the startup sequence for both console-based and GUI applications,
    emphasizing the role of the various sections and how they come together to start
    that pesky program of yours, especially if it’s not working.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Linux上探索ELF，理解**execve()**系统调用，并检查**_start()**函数，您获得了关于底层架构和初始化例程的宝贵知识。同样，关于Windows的讨论突出了基于控制台和GUI应用程序的启动序列，强调了各个部分的作用以及它们如何组合起来启动您那令人烦恼的程序，尤其是如果它不起作用的话。
- en: By leaving a window of opportunity open to further deepen the understanding
    of this topic, we recommended that you engage in hands-on experimentation by creating
    and analyzing binaries, modifying startup routines, and observing the effects
    on different operating systems. You even can manually change various addresses
    in the headers of executables to see what happens and how they crash.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步深化对这个主题的理解，我们建议您通过创建和分析二进制文件、修改启动程序以及观察不同操作系统上的效果来进行实际操作实验。您甚至可以手动更改可执行文件头部的各种地址，看看会发生什么以及它们是如何崩溃的。
- en: This practical approach will not only reinforce the concepts that were covered
    in this chapter but also provide you with a more profound and practical grasp
    of application startup processes. By actively exploring and experimenting, you’ll
    enhance your ability to troubleshoot, optimize, and innovate within the realm
    of software development while learning useful and fun facts about the software
    and the environment it runs in.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实用方法不仅将加强本章所涵盖的概念，还将为您提供对应用启动过程的更深入和实用的理解。通过积极探索和实验，您将提高在软件开发领域进行故障排除、优化和创新的能力，同时了解有关软件及其运行环境的有趣和有用的事实。
- en: In our next chapter, the correct order of declaration of class members, cover
    will we. Through the adventures of one programmer who on quest bug-free code to
    write was, bugs we will see. Keep on reading please, you shall.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下一章中，我们将讨论类成员声明的正确顺序。通过一位程序员追求编写无bug代码的冒险经历，我们将看到bug。请继续阅读，您将会的。
