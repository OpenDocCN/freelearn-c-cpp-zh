- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Main() Function is the Entry Point to Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*What happens before main stays* *in main*'
  prefs: []
  type: TYPE_NORMAL
- en: For programmers working with C++ on various operating systems, the entry point
    of an application is a concept that requires a deep understanding of the underlying
    architecture. In this chapter, we’ll analyze how an application starts, focusing
    on the initialization code that’s executed before we reach the user-defined **main()**
    function.
  prefs: []
  type: TYPE_NORMAL
- en: While exploring this process under Linux, we’ll analyze the **Executable and
    Linkable Format** ( **ELF** ), detailing how the **execve()** system call loads
    and executes a **_start()** function, which prepares the runtime environment before
    calling **main()** . We’ll also explore some compiler-specific extensions that
    we can use to manipulate this process. Then, we’ll shift our focus to Windows
    by offering a detailed examination of the **Portable Executable** ( **PE** ) file
    sections on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use a tool called **Ghidra** to dissect and analyze the executables
    under both platforms since this is one of the tools that provides practical insights
    into the low-level operations that underpin application startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing this chapter, you’ll have a deeper understanding of the following
    aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: The format of executable files and starting processes under Linux and Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to tinker with the startup process of applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Ghidra?
  prefs: []
  type: TYPE_NORMAL
- en: '**Ghidra** is an open source software reverse engineering suite developed by
    the NSA for analyzing compiled code across various formats and platforms. It offers
    tools for decompiling, disassembling, and debugging binary files, making it easier
    for users to understand and analyze machine code.'
  prefs: []
  type: TYPE_NORMAL
- en: The main() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we took up C++ in school, or maybe at university, on our first C++ course,
    we were told by our teacher: “Dear fellows, here’s the main function: **void main(void)**
    . That’s where your program will start.” That’s it.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter done – turn the pages and see you in the next one.
  prefs: []
  type: TYPE_NORMAL
- en: However, this statement isn’t true. I wrote **void main(void)** just to wake
    your curiosity and put you in a state of alertness. At this point in their career,
    all C++ programmers should know that **void main(void)** is as far as standard
    C++ as Point Nemo is from the closest piece of dry land.
  prefs: []
  type: TYPE_NORMAL
- en: Oh – you’re still here! This means that you must have read the fine print. Excellent
    – we programmers should always pay attention to the finer details, such as how
    our application is loaded and executed in memory by the underlying operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Since we live in a free world, we have the option to choose from several operating
    systems at our discretion, so we’ve opted to present how this application loading
    happens under Linux and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a significant difference between these two operating systems concerning
    the way they load and execute the compiled binaries, and while in one of them
    (it’s not that hard to guess which one) we can track all the code paths of this
    peculiar process down the deepest layers of the underlying kernel, for the other
    one, we must rely on existing documentation, books, and various sources of information
    that are to be gathered by the enthusiast low-level scholar.
  prefs: []
  type: TYPE_NORMAL
- en: Since the way Linux deals with this operation is very similar to how the operating
    systems from the BSD family (FreeBSD, NetBSD, and so on) approach the same problem,
    we’ll refrain from actively mentioning these while we debate the problem in the
    upcoming paragraphs. Since we want to keep you entertained while in the pursuit
    of knowledge, we still want to offer information that’s up to date, so we’ve decided
    not to offer this information for peculiar operating systems, such as MS-DOS,
    that are no longer used in active production environments as of 2024 (except if
    you happen to work at Deutsche Bahn [1](B22235_04.xhtml#footnote-016) ).
  prefs: []
  type: TYPE_NORMAL
- en: '[1](B22235_04.xhtml#footnote-016-backlink) [https://www.theregister.com/2024/01/30/windows_311_trundles_on/](https://www.theregister.com/2024/01/30/windows_311_trundles_on/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we dig deeper, we’ll present the test application that we’ll be
    using in this chapter to exemplify the aforementioned functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When compiled and run on a standard compliant system, the preceding application
    produces the following output, as expected by a standard compliant programmer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Yes, we’ve intentionally used no **cout** and other stream operations as we
    want to keep this simple. We don’t want to pollute the generated code since we
    plan to dig deep into the compiled executables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, please note that this is synthetic code that’s been written specifically
    for this chapter to exemplify the features we want to present. The authors are
    totally aware of the potential memory overflow error induced by strcpy, so the
    readers are advised to do what the author tells them to do, not what the author
    does: “ *Don’t* *use strcpy.* ”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our initial goal, let’s present how operating systems load and
    execute applications. In case, dear reader, you feel that the discussion below
    is of a too low level, please bear in mind: C++ programs compile to native code
    while running at the highest possible speed allocated by the underlying operating
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we consider that it’s in the interest of any C++ programmer
    to know how the operating system is handling their code, and what happens after
    the compiler has digested their source files and spat out an executable. We will
    try to keep out the lowest level details and present only what is really necessary,
    in order to fully grasp the seriousness of the situation.
  prefs: []
  type: TYPE_NORMAL
- en: The penguin farm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Linux loads and executes an application (say we want to execute an application,
    not a shell script or something else), usually a **fork()** / **execve()** pair
    of system calls are initiated to start the execution of the application.
  prefs: []
  type: TYPE_NORMAL
- en: These system calls are responsible for duplicating the current process ( **fork()**
    ) and replacing the current process image with a new process image (the application
    to be executed – that is, **execve()** ).
  prefs: []
  type: TYPE_NORMAL
- en: These API calls are presented in great detail in *Advanced Linux Programming*
    , by Mark Mitchell, Jeffrey Oldham, and Alex Samuel, but there are countless online
    resources dedicated to this subject. So, if you’re interested in this subject,
    you might find good sources of information there.
  prefs: []
  type: TYPE_NORMAL
- en: But let’s continue loading the executable. The **execve()** system call, after
    several iterations where it leaves the confines of userspace, will end up in the
    Linux kernel and create a **linux_binprm** structure [2](B22235_04.xhtml#footnote-015)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[2](B22235_04.xhtml#footnote-015-backlink) [https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h](https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h)'
  prefs: []
  type: TYPE_NORMAL
- en: According to the documentation, this structure is used upon loading binaries
    and contains all the major details that are needed upon loading and executing
    a binary file.
  prefs: []
  type: TYPE_NORMAL
- en: If you have lots of free time, are armed with a large cup of tea, and have deep
    knowledge of the intricacies of the C language, you can easily read through the
    lengthy implementation of the **do_execveat_common** function to learn more about
    the behind-the-scenes of this function in the current Linux kernel source tree
    [3](B22235_04.xhtml#footnote-014) .
  prefs: []
  type: TYPE_NORMAL
- en: '[3](B22235_04.xhtml#footnote-014-backlink) https://github.com/torvalds/linux/blob/master/fs/exec.c'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel, in turn, determines the format of the executable file. On Linux
    systems, the most common executable format is ELF.
  prefs: []
  type: TYPE_NORMAL
- en: 'All fields are described in the official standard document, [4](B22235_04.xhtml#footnote-013)
    but a quick summary of the fields that are relevant to our use case are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[4](B22235_04.xhtml#footnote-013-backlink) https://refspecs.linuxfoundation.org/elf/elf.pdf'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field Name** | **Offset** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **MAGIC** | 0x00 | A magic number indicating that the file is an ELF file
    (“ELF” in ASCII and 0x7F) |'
  prefs: []
  type: TYPE_TB
- en: '| **CLASS** | 0x04 | Specifies the class (32-bit or 64-bit) of the ELF file
    |'
  prefs: []
  type: TYPE_TB
- en: '| **e_type** | 0x10 | Identifies the object file type (for example, executable,
    shared object, and so on) |'
  prefs: []
  type: TYPE_TB
- en: '| **e_machine** | 0x12 | Specifies the architecture for which the file was
    compiled |'
  prefs: []
  type: TYPE_TB
- en: '| **e_entry** | 0x18 | The virtual address to which the system transfers control
    first, starting the process |'
  prefs: []
  type: TYPE_TB
- en: 'Please remember this table as we’ll be referring to it shortly. But for now,
    let’s continue loading a program. It’s time for the kernel to read the ELF header
    to understand the structure of the executable. The following operations happen
    at this stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory allocation** : The kernel allocates memory for the new process. This
    includes setting up the process’s address space, which consists of different segments
    such as text (code), data, the heap, and the stack.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Section mapping** : The kernel maps sections of the executable file into
    the process’s address space. For example, the text segment (containing executable
    code) is mapped as read-only, while the data segment (containing global variables)
    is mapped as read-write.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dynamic linking** : If the executable depends on shared libraries, the dynamic
    linker/loader ( **ld.so** ) is invoked to load the necessary shared libraries
    and resolve symbol references. The dynamic linker also maps these libraries into
    the process’s address space.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These operations all happen deep inside the Linux kernel, but if you’re interested
    in this domain, we encourage you to go and read the source – perhaps you can spot
    something teasing there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all these interesting and very low-level operations have been performed
    successfully, the kernel sets up the initial environment stack for the process.
    This stack contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument vectors** ( **argv** ): An array of command-line arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment variables** ( **envp** ): An array of environment variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auxiliary vectors** ( **auxv** ): Additional information needed by the program,
    such as system page size, entry point of the program, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All this happens in the same kernel source file mentioned previously ( **binfmt_elf.c**
    ), in the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After creating the runtime environment, the kernel sets up the **instruction
    pointer** ( **IP** ) to point to the entry point of the program (as specified
    in the ELF header). The CPU registers are also initialized as required. Finally,
    the kernel switches the CPU back to user mode and transfers control to the entry
    point of the program.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, transfer of control i occurs primarily in the **start_thread()** function,
    which is architecture-specific. At the time of writing, for x86, this function
    is defined in **arch/x86/include/asm/processor.h** and is implemented in **arch/x86/kernel/process_64.c**
    . The program starts executing from this point. Now comes the interesting part
    – at least from a C++ developer’s point of view.
  prefs: []
  type: TYPE_NORMAL
- en: First, the program’s initialization code (often part of the C runtime library)
    is executed – typically the **_start()** function, not **main()** . The **e_entry**
    field of the ELF header lists the offset in the file where the program starts
    executing. Usually, it’s the offset of the **_start()** method, or at least if
    the executable was compiled with the standard GNU toolchain. This code is responsible
    for setting up any runtime environment variables and calling the **main()** function
    of the program. From this point, the program runs as per the instructions written.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s examine what exactly is the initialization code. We’ll use our handy
    tool, **Ghidra** , which allows us to dissect Linux executables and examine their
    inner workings. This tool provides the following summary of our almost empty application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The structure of our synthetic application](img/B22235_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The structure of our synthetic application
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking at the **ELF Source File** section, we can see our initial **main.cpp**
    file; however, there are a few other items that we’re not familiar with yet –
    for example, **crtstuff.c** . This file is part of **libgcc** and can be found
    in the **libgcc** repository [5](B22235_04.xhtml#footnote-012) , with the following
    comment written at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[5](B22235_04.xhtml#footnote-012-backlink) [https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c](https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, one of the mysteries has been resolved and the comment is self-explanatory.
    However, another remains: **Scrt1.o** . To understand this, we need to know about
    the difference between **fixed-address executables** and **position-independent**
    **executables** ( **PIEs** ).'
  prefs: []
  type: TYPE_NORMAL
- en: Fixed-address executables are compiled to be loaded at specific, predetermined
    memory addresses, making them simpler but less secure and flexible since their
    addresses are predictable and vulnerable to attacks. This is the preferred manner
    of loading executables on embedded devices and some older platforms (such as MS-DOS,
    which also had this “feature” of requiring **.com** applications to be loaded
    at a specific offset).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, **Position Independent Executable** ( **PIE** ) executables
    are compiled and linked to be position-independent, allowing them to be loaded
    at any address in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you compile a program, you can use various flags to control how the compiler
    generates the code. The **-fPIE** , **-pie** , and **-fPIC** flags are related
    to how the code is positioned and handled in memory. Here’s a quick breakdown
    of what each flag does:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-fPIE** ( **position-independent executable** ): The **-fPIE** flag tells
    the compiler to generate position-independent code for executables. This is useful
    for creating executables that support **Address Space Layout Randomization** (
    **ASLR** ), a security feature that randomizes the memory address where the executable
    is loaded to make it harder for attackers to predict the location of specific
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-pie** ( **position-independent executable linker flag** ): The **-pie**
    flag is used during the linking stage. It instructs the linker to produce a position-independent
    executable. This means that the final output file (the executable) will be able
    to be loaded at any address in memory supporting ASLR. It complements the **-fPIE**
    flag, which is used during compilation, ensuring that all the code in the executable
    is position-independent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-fPIC** ( **position-independent code** ): The **-fPIC** flag tells the compiler
    to generate position-independent code for shared libraries. Position-independent
    code for shared libraries means that the library can be loaded at any address
    in memory. This is essential for shared libraries because they may be loaded into
    different memory locations in different programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know about these important notions, let’s get back to where we
    left off and cover the one remaining mystery in our binary: **Scrt1.o** . Do you
    remember the **_start()** function? Since you didn’t write it yourself, it must
    come from somewhere. For us, it comes from this magic **Scrt1.o** . There are
    several variations of **crtX.o** , some with a leading S, some without, but for
    us, the presence of **Scrt1.o** tells us that our application is a PIE executable.
    Several other files can be linked to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**crt0.o** , **crt1.o** , and so on: These files contain the **_start** symbol,
    which is crucial for bootstrapping program execution. Their specific naming conventions
    may vary between **libc** implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**crti.o** : This defines function prologues for **.init** and **.fini** sections,
    triggering linker-generated dynamic tags ( **DT_INIT and DT_FINI** ), to support
    We’ll discuss these notions here, so don’t worry about the unknown terminology
    yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**crtn.o** : This provides function epilogues for **.init** and **.fini** sections,
    complementing **crti.o** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scrt1.o** , **gcrt1.o** , and **Mcrt1.o** : These are variants of **crt1.o**
    that are used under different circumstances, such as generating PIEs or including
    profiling information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**crtbegin.o** , **crtbeginS.o** , and **crtbeginT.o** : These are used by
    GCC to locate constructors and their variations ( **crtbeginS.o** for shared objects/PIEs
    and **crtbeginT.o** for static executables).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**crtend.o** and **crtendS.o** : Similar to **crtbegin.o** , these are used
    by GCC to locate destructors ( **crtendS.o** for shared objects/PIEs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we’ve demystified the content of our executable, we need to understand
    something else: the **.init_array** section in an ELF file is used to store an
    array of function pointers that are automatically executed by the operating system’s
    runtime loader during program startup.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions are typically referred to as “init functions” or “initialization
    functions.” They’re called before **main()** and are responsible for initializing
    global data. For our synthetic application, this is how this section looks once
    it’s been analyzed by **Ghidra** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The .init_array section for global variables](img/B22235_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The .init_array section for global variables
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, there are two functions here – a dummy one and something called
    **_GLOBAL__sub_I_my_string** . Interesting choice of name, so let’s use the assembly
    to C-like code feature of the tool and see what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – How global objects are created according to Ghidra](img/B22235_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – How global objects are created according to Ghidra
  prefs: []
  type: TYPE_NORMAL
- en: Intriguing, isn’t it? This is just what you would expect to happen in the global
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the **my_a** and **my_other_a** objects are being created, their constructor
    is called, and the destructor of class **A** is being invoked for **__cxa_atexit**
    . It is quite an intriguing observation though, how the constructor calls behind
    the scenes work.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this queasy disassembly, you may feel that the constructor gets an invisible
    parameter for the object it’s constructing. This is true: this is the **this**
    variable, and it’s implicitly added to all the methods of a class without being
    explicitly required. This is how we gain access to the object itself.'
  prefs: []
  type: TYPE_NORMAL
- en: As its name suggests, the **__cxa_atexit** function is just like **atexit**
    . However, you don’t have to worry about it because it isn’t a function that should
    be dealt with outside of the library it resides in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand what happens here, it’s time to pick up another thread
    we mentioned previously: the infamous **_start()** function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, this function should do some housekeeping and start
    our **main** function. According to Ghidra, it can be indeed found in the ELF
    header. According to the ELF specification, it occupies the **e_entry** field
    in the long list of ELF entries: :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The ELF header according to Ghidra](img/B22235_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The ELF header according to Ghidra
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after applying some disassembly magic, courtesy of **Ghidra** , it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The _start routine function, disassembled and converted into
    C pseudocode](img/B22235_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – The _start routine function, disassembled and converted into C
    pseudocode
  prefs: []
  type: TYPE_NORMAL
- en: The scary-looking **__libc_start_main** function isn’t as scary as it seems
    and is responsible for loading our **main()** function alongside the parameters
    provided by the operating system. This function is part of **glibc** and can be
    obtained free of charge [6](B22235_04.xhtml#footnote-011) , just like every other
    free piece of software with good behavior, so that we can study its internals.
  prefs: []
  type: TYPE_NORMAL
- en: '[6](B22235_04.xhtml#footnote-011-backlink) git clone git://sourceware.org/git/glibc.git'
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, with the outcome of **__libc_start_main** , we’ve reached the
    actual main function. This is where we would expect our program to reside.
  prefs: []
  type: TYPE_NORMAL
- en: These details offer deeper insights into program execution, optimization opportunities,
    and debugging capabilities. Mastery of the ELF file format enables you to optimize
    performance by leveraging specific linker options and understanding dynamic linking
    intricacies. Moreover, it facilitates effective debugging by tracing initialization
    sequences and identifying startup-related issues.
  prefs: []
  type: TYPE_NORMAL
- en: Oh no, there’s more!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’re here, typing on our favorite Linux machine, let’s not waste any
    more time and dive a bit deeper into the internals of some of the compilers that
    come with this great operating system. For example, let’s dig into the **.init_array**
    section of the ELF file. As mentioned previously, it’s responsible for starting
    different functions before the main one.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we continue our journey through these swampy fields, a warning must
    be mentioned: what we’re going to discuss isn’t for faint-hearted C++ programmers,
    to the extent that it isn’t even standard C++. Please read [*Chapter 2*](B22235_02.xhtml#_idTextAnchor026)
    concerning C++ standardness. If you can live with the unholy scripture of compiler
    extensions, then please read on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'GCC (as well as Clang) has a very handy extension for executing functions before
    **main()** . These functions are called constructor functions and they need to
    be spawned with a specific attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add this specific piece of code to our synthetic application, we can
    expect the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the constructor function is being executed before the global
    initialization code. If we dig into the executable with our favorite nine-headed
    spades, we’ll see the following content in the **.** **init_array** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The .init_array section with a constructor function](img/B22235_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The .init_array section with a constructor function
  prefs: []
  type: TYPE_NORMAL
- en: 'With this knowledge, we now possess two methods of writing code that will be
    executed before the **main()** function in a C++ application: constructor functions
    and global variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re in a place where we’ve started scratching the surface
    of something dangerous: the **static initialization order fiasco** . This is a
    subject that’s been debated several times, in various places. These debates summarize
    that this issue arises from the undefined order of initialization of static or
    global variables across different translation units. There are various techniques
    for resolving these issues, but our recommendation is to just **avoid them** .'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates why this can conjure up dangerous situations.
    Here, we’ve created several short files, again with synthetic content, trying
    to emulate a real-life situation:'
  prefs: []
  type: TYPE_NORMAL
- en: a.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: b.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: C.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: a.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: b.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: main.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t extraordinarily complicated code – it’s just a diagnostic **C** class
    that’s used to print out some debugging information and some separate C++ files
    creating objects of the aforementioned diagnostic class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, these files are compiled with **gcc** , so let’s compile them and
    execute the resulting file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s nothing special here – we compiled and created an executable that performed
    what it’s supposed to: print out when a specific object was created and destroyed.'
  prefs: []
  type: TYPE_NORMAL
- en: But what happens if we specify the files in a different order?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What a surprise. Now, the **b_c** object from **b.cpp** is created before the
    **a_c** object from **a.cpp** . Now, imagine the disastrous situation where our
    program is made up of global objects that depend on the pre-existence of some
    other global objects to be initialized correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, the compiler ecosystem under Linux provides us with the necessary
    tools to achieve a sane state of our applications concerning this matter, with
    the help of a very handy extension. This extension is used to specify the initialization
    order for global members and it manifests itself using the **__attribute__((init_priority(XXX)))**
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Both **gcc** and **clang** provide this way to control the initialization order
    of **namespacescope** objects across translation units using the **init_priority**
    attribute. This attribute allows users to assign a relative priority to the initialization,
    with priority values ranging from **101** to **65535** inclusive. Lower numbers
    correspond to higher priority, meaning objects with lower i **nit_priority** values
    will be initialized earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with this knowledge, let’s modify our synthetic example files so that
    they use this extension:'
  prefs: []
  type: TYPE_NORMAL
- en: a.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: b.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, regardless of the order in which **a.cpp** and **b.cpp** are introduced
    to the compiler, the result will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s return to our first synthetic application – the one that tried to
    create global objects but in the same translation unit. And also introduced the
    notion of “constructor” functions. Let’s see what happens if we specify initialization
    priority for one of the global objects, and what the order will be in that case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Surprisingly, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to grasp a deeper understanding of the mechanics behind the scenes,
    and to understand why this scenario happened we run our beloved tool on the compiled
    binary. The result confirms our finding as per the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The .init_array section according to gcc with the specified
    init priority](img/B22235_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The .init_array section according to gcc with the specified init
    priority
  prefs: []
  type: TYPE_NORMAL
- en: The output happens to be as it is because the **.init_array** section has gained
    a new member that’s to be executed before the constructor and the standard global
    initialization code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It isn’t hard to guess that the name of the new function contains the initialization
    priority. What however still baffles the author is why **gcc** decided to continuously
    use **my_string** as a postfix for the variable names. This must be a **gcc**
    specificity because the same executable compiled with **clang** produces the following
    **.** **init_array** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Clang’s different .init_array section for the same init priority](img/B22235_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Clang’s different .init_array section for the same init priority
  prefs: []
  type: TYPE_NORMAL
- en: The author has found it interesting why there’s such a difference between how
    **gcc** and **clang** handle this critical section of the object file. However,
    without analyzing the source files of these compilers further, this will remain
    a mystery.
  prefs: []
  type: TYPE_NORMAL
- en: A library is the delivery room for the birth of ideas unexpected behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve been the happy parents of a single application. Now, the time
    has come for our lovechild to mature and marry a … meaning, in order to adhere
    to some common sense and more advanced programming practices, we want to factor
    out some very useful functionality of our synthetic code into a synthetic library
    and call it **synth** . Pardon – I mean **libsinth** .
  prefs: []
  type: TYPE_NORMAL
- en: And since the main focus of this chapter is still the dissection of code execution
    before **main()** ( *1* ), and since we are happily advocating for gcc (and clang)
    extensions (2), let’s see what happens if we hitch all these together in an unholy
    matrimony of code and data.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, we’ll use our second synthetic example, where **a.cpp** and
    **b.cpp** remained unchanged from their last stage, which includes the required
    initialization order. We’ll create a new **main.cpp** file to utilize the library
    itself, and we’ll also introduce the library’s source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our library will be constructed from the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: synth.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: synth.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Besides defining the global object **synth_c** of type **C** (as defined in
    the **C.h** header) and has an initialization priority of **2000** , we also define
    a function called **welcome_library** marked with **__attribute__((constructor))**
    , ensuring it runs before **main()** and prints “welcome to the library.”
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the **print_synth** function prints a message that states the
    value that was obtained from **synth_c.get()** . The **C.h** header is the one
    from a few pages prior – it defines the class **C** , along with all the required
    methods and constructors to create objects properly.
  prefs: []
  type: TYPE_NORMAL
- en: To use this library, we’ll need to create the corresponding underlying infrastructure
    for it. This consists of the two aforementioned files and an application that
    uses the features exposed by it.
  prefs: []
  type: TYPE_NORMAL
- en: To keep on track, we’ll need to modify our main file so that it uses the library’s
    features. However, we also want to keep the test source files we created for this
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our application will contain the aforementioned **a.cpp** and **b.cpp**
    files, as well as our new **main.cpp** file:'
  prefs: []
  type: TYPE_NORMAL
- en: main.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To make everything work properly, we need to link these items and turn them
    into a working application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, at this stage, we’ve created a **static** library, **libsynth.a**
    , and linked our main application to it to incorporate all the code in the library
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that there is no *c.cpp* file because, to be as compact as possible,
    we’ve provided all the implementation of the class in the header file. For bigger
    projects, this isn’t best practice because a small change in the implementation
    of any functions of the class will require all the files that include the header
    to be recompiled. However, for this very peculiar situation, we can live with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’re interested in the order of execution of the various constructs
    we’ve created, after running the resulting application, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To dig a bit deeper into the innards of the freshly compiled executable file,
    we’ll open it with our beloved tool, **Ghidra** , and locate the section we’re
    most interested in: the **.** **init_array** section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After a quick inspection, we can see that the order of the printouts corresponds
    to the order of the functions in the **.** **init_array** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – The .init_array section for different init priorities in different
    files](img/B22235_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – The .init_array section for different init priorities in different
    files
  prefs: []
  type: TYPE_NORMAL
- en: Here, **_GLOBAL__sub_I_welcome_main** is the function creating the global object
    in **main.cpp** – that is, **C main_c("main") ;** . Interesting! At this point,
    we’re convinced that the order of initialization for global objects works even
    after libraries – at least static ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we’re still not done. Let’s see what happens if we create a shared library.
    That isn’t that complicated. After removing the generated files – that is, **synth.o**
    , **libsynth.a** , and **main** – so that we have a clean plate, we need to run
    the following command to create a shared library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see how easily those magic switches fall into place from the beginning
    of this chapter, where we created a shared library and application that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all these pieces in place, we can see an interesting change in how Ghidra
    presents the application overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – The synth library as a dependency, as shown in Ghidra](img/B22235_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – The synth library as a dependency, as shown in Ghidra
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see a dependency on the **libsynth.so** library we just created.
    Now, we can examine the part that interests us most regarding the executable –
    **.** **init_array** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – No reference to libsynth in the .init_array section](img/B22235_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – No reference to libsynth in the .init_array section
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s no reference at all to the objects and functions in our synth library…
    No wonder – it’s a library. But at least we can still see that our application
    links to the library properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Please observe that we have to specify **LD_LIBRARY_PATH=.** explicitly to find
    the library (note that we’ve also truncated unnecessary output lines to keep things
    clear).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re curious about what happens when we execute the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, according to the expectations set by the single application test, the
    object(s) with the specified priority(ies) is(are) created in the library. Then,
    the constructor function from the library is called. If there were any other non-prioritized
    global objects in the library, they would have been created after these, before
    the prioritized objects from the main application were created and the constructor
    from the main application was called. All these operations were performed before
    the **main()** function even had the chance to say *hush* .
  prefs: []
  type: TYPE_NORMAL
- en: Almost as we expected it to happen. There’s just one dark corner of these function
    constructor extensions that I’ve been unable to find a cure for at the moment
    – what if **a.cpp** and **b.cpp** contain the following lines?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This unholy scribbling of spooky code adds two more constructor functions to
    our executable. Now, we have three. If you want to have a predictable order of
    execution for these constructor functions too, you need to specify their priority
    using **__attribute__((constructor(205))) void welcome_b()** . This will guarantee
    that these functions will also be executed in a specific order and that you’re
    not facing the global constructor invoking order fiasco.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior in case the library was dynamically loaded ( **dlopen** / **dlclose**
    ) is the one that one would expect, i.e. it follows the execution flow of the
    main application, and at the point where the library is loaded, it will jump and
    execute the various constructors and object initializations from the library.
  prefs: []
  type: TYPE_NORMAL
- en: Famous last words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter dealt with code that is executed before the main function. However
    the same attention would require the topic covering the code that is executed
    after the main function, but that debate will go in a different chapter, in a
    different book.
  prefs: []
  type: TYPE_NORMAL
- en: 'But just to spoil you, here’s a small hint: the same way as there are constructor
    functions, there are also destructor functions. They’re not like C++ destructors
    – more like **__attribute__((destructor))** .'
  prefs: []
  type: TYPE_NORMAL
- en: Spicing those up with the standard application exit routines, we have twice
    as much fun as the startup because we have to consider a myriad of other alternatives,
    such as functions registered for **std::atexit** (or even **std::quick_exit**
    ), or abnormal program termination. For example, let’s say an exception is thrown
    in a destructor or we use **std::terminate** or **std::abort** .
  prefs: []
  type: TYPE_NORMAL
- en: The documentation on **gcc** and **clang** offers a nice escapade from the standard
    world, and any good book on C++ will offer a great overview of the standard termination
    routines, so please head over to them for a good lecture. A combination of these
    two will provide the best overview of how applications start and exit.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we’ll shift our attention toward other platforms before we get a good
    wigging from the folks at Packt – instead of the agreed-upon 16 pages for this
    chapter, we’re already at 22 and covered only half of the promised subject.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s open the Windows (unless you’re on ISS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we delve deep into the internals of how an application is executed under
    Windows and the steps we must take to reach our main function, please note that
    from C++’s point of view, there should be no real difference from Linux or any
    other operating system. The C++-only standard functionality is (should be) identical
    to the functionality presented in the previous pages, so we won’t repeat the same
    information here.
  prefs: []
  type: TYPE_NORMAL
- en: We will, however, present how and why the application starts under Windows the
    way it does and present some techniques that can directly influence this behavior,
    just like we did under Linux. We’ll also be using a Visual Studio compiler since
    **gcc** and **clang** for Windows behave identically, so there’s no sense in presenting
    them again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to its closed nature, to understand process creation under Windows, we
    need to resort to the few available resources that deal with this kind of information.
    One of these resources is the best book I’ve managed to find in this domain: *Windows
    Internals, 7th edition (Part 1)* , [7](B22235_04.xhtml#footnote-010) by Pavel
    Yosifovich, Alex Ionescu, Mark E. Russinovich, and David A. Solomon.'
  prefs: []
  type: TYPE_NORMAL
- en: '[7](B22235_04.xhtml#footnote-010-backlink) [https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals](https://learn.microsoft.com/en-us/sysinternals/resources/windows-internals)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The information gathered from that book is complemented by various scraps gathered
    from the world wide internet, and filtered in order to offer our readers a light
    introduction to the Windows side of process creation. We will reference back however
    some of the notions encountered in the Linux subsection of this chapter, so reading
    it would be beneficial. Also, a small observation: security, thread handling,
    and user management are much more fine-tuned in Windows than in Linux, and all
    this is reflected in the way processes are treated. If you’re interested in understanding
    this domain, there are several resources available, such as the excellent *Windows
    Security Internals: A Deep Dive into Windows Authentication, Authorization, and
    Auditing* , by James Forshaw. We recommend reading through it if you’re interested
    in the domain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get back to the processes. The process creation mechanism in Windows
    involves several stages that are executed by different components of the operating
    system: the Windows client-side library, **kernel32.dll** , the Windows executive,
    and the Windows subsystem process ( **csrss.exe** ). Due to the simple fact that
    we don’t have access to the sources of these Windows components, our presentation
    on this matter will be a very high-level one.'
  prefs: []
  type: TYPE_NORMAL
- en: Processes in Windows are created by a function of the CreateProcess family,
    which comes with several relatives and uncles ( **create process** as a different
    user, create process with various security clearances, etc…) but all members of
    the extended family routines after several iterations end up in the CreateProcessInternalW
    function in **kernel32.dll** , which first validates and converts some of the
    parameters and flags to an internal representation (to which sadly we have no
    access).
  prefs: []
  type: TYPE_NORMAL
- en: 'The priority class for the new process is determined by the **CreationFlags**
    parameter. In Windows, there are six priority classes: Idle, Below Normal, Normal,
    Above Normal, High, and Real-time. If no priority class is specified, the priority
    class defaults to Normal. If Real-time is requested but the caller lacks the necessary
    privileges, the priority is downgraded to High.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, **kernel32.dll** initiates a connection to the native debugging interface
    if the process is to be debugged and sets the default hard error mode if specified.
    The user-specified attribute list is converted into its native format, and any
    additional internal attributes are added. The security attributes for the process
    and initial thread are also converted into internal representations.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to open the executable image to be run. This task is handled
    within the **NtCreateUserProcess** system call. First, the function validates
    the arguments again to ensure they haven’t been tampered with. Then, it attempts
    to find and open the appropriate Windows image and create a section object, which
    will be mapped into the new process’s address space at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: If the image isn’t a valid Windows executable, the function searches for a support
    image to run it. For instance, if the executable is an MS-DOS or Win16 application,
    it uses **ntvdm.exe** (for 32-bit Windows) to run it. This ensures that older
    DOS or Win16 applications can be executed correctly within the Windows environment.
    However, this feature has been slowly deprecated on modern Windows systems, so
    you need to enable it so that it can function.
  prefs: []
  type: TYPE_NORMAL
- en: Once the executable image has been opened, the next stage is to create the Windows
    executive process object. This involves setting up the process’s virtual address
    space and other critical structures. The executive process object serves as a
    container for all the resources needed by the process, including memory, handles,
    and threads.
  prefs: []
  type: TYPE_NORMAL
- en: With the process object in place, the initial thread is created. This step involves
    setting up the thread’s stack, context, and executive thread object. The thread
    is responsible for executing the program’s entry point and managing the process’s
    execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: After the initial thread is created, Windows performs subsystem-specific initialization
    tasks. These tasks are essential for integrating the new process into the Windows
    subsystem, which provides the environment and resources necessary for the process
    to run correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The initial thread is then started, unless the **CREATE_SUSPENDED** flag is
    specified, in which case the thread remains suspended until it’s explicitly resumed.
    Starting the thread involves switching to user mode and executing the process’s
    entry point.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the context of the new process and thread, the address space is
    initialized. This includes loading any required DLLs and performing any other
    necessary setup tasks. Once these steps are complete, the process begins executing
    its code, and process creation is considered complete.
  prefs: []
  type: TYPE_NORMAL
- en: To PE or not to PE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like every other file with a specific meaning, the bytes that conjure up Windows-based
    executables also have a special meaning.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows **Portable Executable** ( **PE** ) format is a file format for executables,
    object code, DLLs, and other system files that are used in Windows operating systems.
    It’s the standard file format for executables in DOS (as well as FreeDOS), Windows,
    and ReactOS and encompasses both the **executable** ( **EXE** ) and **Dynamic
    Link Library** ( **DLL** ) file types.
  prefs: []
  type: TYPE_NORMAL
- en: The PE format is designed to be extensible and capable of supporting modern
    operating system features. If you’re interested in this domain, there are excellent
    learning opportunities online, so we encourage you to study this subject since
    this book can’t encompass all the required information due to lack of space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a filtered explanation of its structure and components, mostly the ones
    relevant to this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DOS** **header (IMAGE_DOS_HEADER)** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file begins with **MZ** , the initials of Mark Zbikowski, the engineer who
    created this format while working at Microsoft. This is followed by a DOS header,
    which is a relic from the MS-DOS days. This header includes a small DOS stub program
    that displays a message (“This program can’t be run in DOS mode”) if the executable
    is run in a DOS environment. The last section of the DOS header contains a pointer
    to the PE header’s location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**PE** **header (IMAGE_NT_HEADERS)** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature** : This identifies the file as a PE file. The signature is a 4-byte
    value – that is, **PE\0\0** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File header** ( **IMAGE_FILE_HEADER** ): This contains basic information
    about the file, such as the target machine type, the number of sections, the time
    and date the file was created, and the size of the optional header.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optional header** ( **IMAGE_OPTIONAL_HEADER** ): This provides essential
    information for loading and running the program. Despite its name, this header
    is required for executable files and includes the following aspects:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Magic number** : Identifies the format (for example, PE32 for 32-bit and
    PE32+ for 64-bit)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AddressOfEntryPoint** : The address where execution starts'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ImageBase** : The preferred base address for the executable in memory'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SectionAlignment** : Alignment of sections in memory.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SizeOfImage** : The total size of the image in memory'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subsystem** : Identifies the required subsystem (Windows GUI or CUI)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Section** **headers (IMAGE_SECTION_HEADER)** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following the PE header, there are one or more section headers, each describing
    a section of the file. These sections contain the actual data and code of the
    program. The following are some common sections:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**.text** : Contains executable code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.data** : Contains initialized global and static variables.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.bss** : Contains uninitialized data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.rdata** : Read-only data (such as string literals and constants).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.idata** : Import table, listing the functions and DLLs that the executable
    depends on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.edata** : Export table, listing functions and data that the executable exposes
    to other modules.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data directories** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part of the optional header, these directories provide information about the
    location and size of various tables and data structures within the executable
    file, including:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Import table** : Lists the DLLs and functions imported by the executable.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Export table** : Lists the functions and data exported by the executable.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource table** : Contains resources that are built into the application,
    such as icons, menus, and dialogs. These resources are stored in a resource tree,
    depending on their type. There’s also support for variations in multiple languages
    for the same resource.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception table** : Contains information for exception handling.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relocation table** : Used for address fixups.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sections** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual sections follow the headers and contain the executable code, initialized
    data, and other components that the program needs to run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each section is aligned based on the **SectionAlignment** value specified in
    the optional header.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For us, the most important and interesting part of this list of sections and
    subsections is the **AddressOfEntryPoint** field.
  prefs: []
  type: TYPE_NORMAL
- en: Getting our hands dirty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our initial approach will be a very clean application to work on, a classical
    “Hello World!”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow us to understand how a very simple application is loaded and
    executed under Windows. However, before taking things further, a small remark:
    under Windows, there are different kinds of applications, as indicated by the
    **OptionalHeader** / **Subsystem** field in the PE header.'
  prefs: []
  type: TYPE_NORMAL
- en: For our purpose, which is to dissect an application to examine how it starts,
    we’ll create a Console Application. There are other types of applications we could
    look at, but they’re overly complex. For example, if they have a GUI, then we
    must implement complicated message loops and dependencies, so we’ll stick with
    something simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we’ve successfully compiled our synthetic console application,
    we can fire up Ghidra and see that a large section of the file resembles the standard
    PE header shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – The contents of the PE header](img/B22235_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – The contents of the PE header
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a lot of information to digest, but what’s interesting for us is the
    **AddressOfEntryPoint** field. At the moment, it points to a method called **entry**
    . This is where our application will start executing, so let’s examine this function
    in a bit more detail. If we dig deeper and see what the entry is, we’ll reach
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This in itself is an interesting discovery as it seems to be the entry point
    of console-based Windows applications. Let’s explore this further. The next function
    that’s run is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Microsoft’s page [8](B22235_04.xhtml#footnote-009) contains a detailed description
    of the **__security_init_cookie()** function. However, the other function is a
    different kind of beast. It does a large amount of initialization, such as setting
    up the terminal and handling initialization errors. At some point, the following
    piece of code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[8](B22235_04.xhtml#footnote-009-backlink) [https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/security-init-cookie?view=msvc-170)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – The invocation of main()](img/B22235_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – The invocation of main()
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have guessed, **invoke_main** is responsible for invoking **main()**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we’ve reached the stage where our **main()** function is called.
    Even for a simple “Hello World!” application, there’s a large amount of boilerplate
    code that needs to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to go one step further and take our synthetic application on
    a ride through Ghidra (for brevity’s sake, we’ll omit that we must create a project,
    compile it, and link the application; let’s just assume the application summons
    itself by magic).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’re mostly interested in determining the order of function calls before
    **main()** , and we know that we initialize the **my_a** and **my_other_a** variables
    globally, we need to look through the binary. At some point, we’ll spot the following
    interesting data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – The .CRT$XCU section according to Ghidra](img/B22235_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – The .CRT$XCU section according to Ghidra
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this looks interesting, especially that cryptic **.CRT$XCU** text. This
    takes us back to a few paragraphs prior, where the sections of a PE file were
    discussed: sections are distinct areas within the executable file that hold different
    types of data and code.'
  prefs: []
  type: TYPE_NORMAL
- en: Each section serves a specific purpose and has attributes that define its behavior
    and how it should be handled by the operating system. There’s excellent documentation
    [9](B22235_04.xhtml#footnote-008) on Microsoft’s site that discusses the sections
    responsible for initializing CRT, a quick summary of it follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[9](B22235_04.xhtml#footnote-008-backlink) [https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170](https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170)'
  prefs: []
  type: TYPE_NORMAL
- en: According to the documentation, by default, the CRT library is included via
    the linker, which ensures that the CRT is initialized properly, global initializers
    are called, and, subsequently, the user-defined **main()** function is executed.
    When the compiler encounters a global initializer, it creates a dynamic initializer
    and places it in the **.** **CRT$XCU** section.
  prefs: []
  type: TYPE_NORMAL
- en: The CRT uses specific pointers such as **__xc_a** and **__xc_z** in the **.CRT$XCA**
    and **.CRT$XCZ** initialization sections to define the start and end of the list
    of initializers, ensuring they’re called in the correct order. The **__scrt_common_main_seh()**
    function, which we discussed previously, is responsible for setting these up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: These names are predefined by the CRT, and the linker arranges these sections
    alphabetically. This ordering ensures that user-defined initializers in **.CRT$XCU**
    are executed between the standard sections.
  prefs: []
  type: TYPE_NORMAL
- en: To manipulate the initialization order, developers can place their initializers
    in unused reserved sections such as **.CRT$XCT** (before compiler-generated initializers)
    and **.CRT$XCV** (after compiler-generated initializers) using specific pragmas,
    as detailed in the CRT startup documentation mentioned a few paragraphs prior,
    but before jumping on that technique, please read below because things are a bit
    more complicated than they seem.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Microsoft, that subject is so platform and compiler-specific that
    we don’t wish to explore those fields, especially considering the warning that
    comes from the official site:'
  prefs: []
  type: TYPE_NORMAL
- en: “The names .CRT$XCT and .CRT$XCV aren’t used by either the compiler or the CRT
    library right now, but there’s no guarantee that they’ll remain unused in the
    future. And, your variables could still be optimized away by the compiler. Consider
    the potential engineering, maintenance, and portability issues before adopting
    this technique.”
  prefs: []
  type: TYPE_NORMAL
- en: 'So, once again, we’ll just repeat what the official warning said: unless you
    have to do this kind of hackery, please refrain from using these halfheartedly
    documented “features” of the language and compiler since (again, as mentioned
    in the official warning) there’s no guarantee that if it works today, it will
    work tomorrow, or even after the next system update.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let’s turn our attention toward the functions that we “discovered”
    in the **.CRT$XCU** section and see what kind of sorcery lies behind this very
    explicit name, which undoubtedly isn’t standard C ( nor C++):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After performing some maintenance tasks (such as initializing the stack with
    the **0xcccccccc** value), we can see the function call to the constructor of
    **A** , with stylishly the first parameter being the **this** object, and registering
    an **atexit** function for the destructor of the class for the specific object,
    again.
  prefs: []
  type: TYPE_NORMAL
- en: This **0xcccccccc** pattern is the typical way the Visual C++ compiler marks
    uninitialized stack memory, making it easier to detect the use of uninitialized
    memory in debugging sessions. Interestingly, the loop doesn’t seem to execute.
    However, if we were to dig deeper into the debug builds of functions that have
    larger C-style arrays, we’d see this stack protection scheme in action, together
    with some nicely set-up stack canaries.
  prefs: []
  type: TYPE_NORMAL
- en: Stack canaries are a security mechanism designed to detect and prevent stack-based
    buffer overflow attacks by placing a special value (called the canary) between
    a function's local variables and its control data on the stack (such as the return
    address and the saved frame pointer).
  prefs: []
  type: TYPE_NORMAL
- en: If a buffer overflow occurs, the canary value is altered, signaling that some
    mischief has taken place. This allows the program to take corrective actions,
    such as terminating execution to prevent exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: The origin of this term is a bit obscure, and it goes back to the historical
    use of canaries in coal mines. Miners would bring canaries into the mines to detect
    toxic gases such as carbon monoxide. Since canaries are more sensitive to these
    gases than humans, if the bird became ill or died (that is, it stopped singing),
    it served as an early warning signal for miners to evacuate. This isn’t quite
    of mythological proportions, but it’s pragmatic – especially if you’re the miner,
    not the canary.
  prefs: []
  type: TYPE_NORMAL
- en: With these notions set in place, we have an overview of how the application
    loads under Windows, but only from the console. But let’s not forget that Windows
    is a GUI environment. It creates windows and dialogs, has a message loop, and
    deals with a plethora of events.
  prefs: []
  type: TYPE_NORMAL
- en: However, the startup process of a Windows GUI application isn’t that dissimilar
    to a console-based application. The main difference is that the **invoke_main**
    function invokes two different functions before invoking a GUI-specific **WinMain**
    function, dealing with the show state of the window and the command line options.
  prefs: []
  type: TYPE_NORMAL
- en: The first function allows us to show the window of the application in different
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: The second function is the command line of the application, in a wide string
    format.
  prefs: []
  type: TYPE_NORMAL
- en: The rest is just calling the **WinMain** and from there, we are in familiar
    territory, at least programmers who have experience in this domain.
  prefs: []
  type: TYPE_NORMAL
- en: In closing this chapter, there’s nothing else but encourage our readers to experiment
    while hacking around binaries – that’s the only way to truly understand how a
    specific functionality will behave on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the author tried to provide a not-so-comprehensive overview
    of the application startup processes on both Linux and Windows. The insights that
    were provided into the initial stages of execution, including the critical steps
    before reaching the **main()** function, weren’t as complete as the platforms
    themselves require, but then this book would have been called something else since
    this is a huge and very niche topic that doesn’t attract a broad range of programmers.
  prefs: []
  type: TYPE_NORMAL
- en: By exploring ELF on Linux, understanding the **execve()** system call, and examining
    the **_start()** function, you gained valuable knowledge about the underlying
    architecture and initialization routines. Similarly, the discussion on Windows
    highlighted the startup sequence for both console-based and GUI applications,
    emphasizing the role of the various sections and how they come together to start
    that pesky program of yours, especially if it’s not working.
  prefs: []
  type: TYPE_NORMAL
- en: By leaving a window of opportunity open to further deepen the understanding
    of this topic, we recommended that you engage in hands-on experimentation by creating
    and analyzing binaries, modifying startup routines, and observing the effects
    on different operating systems. You even can manually change various addresses
    in the headers of executables to see what happens and how they crash.
  prefs: []
  type: TYPE_NORMAL
- en: This practical approach will not only reinforce the concepts that were covered
    in this chapter but also provide you with a more profound and practical grasp
    of application startup processes. By actively exploring and experimenting, you’ll
    enhance your ability to troubleshoot, optimize, and innovate within the realm
    of software development while learning useful and fun facts about the software
    and the environment it runs in.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, the correct order of declaration of class members, cover
    will we. Through the adventures of one programmer who on quest bug-free code to
    write was, bugs we will see. Keep on reading please, you shall.
  prefs: []
  type: TYPE_NORMAL
