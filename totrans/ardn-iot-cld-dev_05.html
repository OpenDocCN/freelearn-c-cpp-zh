<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-101"><a id="_idTextAnchor101"/>5</h1>
<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Project #2 – Creating a Portable Thing Tracker Using MKR GSM 1400</h1>
<p>This chapter is dedicated to <strong class="bold">smart transportation</strong> and <strong class="bold">smart remote monitoring</strong>. It shows how cellular communication-enabled devices can be integrated with the <strong class="bold">Arduino IoT Cloud</strong> platform, and it also offers an example of using a <strong class="bold">global IoT SIM card</strong> for communication.</p>
<p>Here, we will practically explore <strong class="bold">Long-Term Evolution</strong> (<strong class="bold">LTE</strong>) technologies, which are very useful in remote monitoring and control, whether they involve asset tracking or remote operation monitoring. This project uses the <strong class="bold">Arduino MKR GSM 1400</strong> development board, which is equipped with the latest communication bands and was specially designed for <strong class="bold">Industrial Internet of Things</strong> (<strong class="bold">IIoT</strong>) and <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) use cases. This project practically explains how you can develop a tracking solution based on cellular communications for different use cases. This chapter will help you to understand cellular communication technology, global IoT SIM cards, and the integration of Arduino IoT Cloud using cellular technology. By the end of this chapter, you will be able to develop solutions for remote areas using cellular technology.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Enhancing operations with IoT asset tracking and remote control</li>
<li>Exploring the advantages of GSM/LTE/NB-IoT communication technologies</li>
<li>Seamless global connectivity with IoT SIM cards</li>
<li>Building blocks – sensors and development boards for IoT</li>
<li>Designing the project architecture</li>
<li>Activating SIM cards for IoT deployment</li>
<li>Configuring the Thing, network credentials, cloud variables, and code</li>
<li>Creating comprehensive web and mobile dashboards</li>
</ul>
<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Technical requirements</h1>
<p>The following are the hardware components required to complete this chapter:</p>
<ul>
<li>MKR GSM 1400/MKR NB 1500</li>
<li>A Hologram global IoT SIM card</li>
<li>A NEO-6M GPS module</li>
<li>A breadboard</li>
<li>Jumper cables</li>
</ul>
<p>For coding, we will use the <strong class="bold">Arduino Web Editor</strong>, which includes a large collection of development boards and sensor libraries, as well as Arduino IoT Cloud for Thing and dashboard setup. To develop hardware and sensor designs, we need the <strong class="bold">Fritzing </strong>desktop software, and we need <strong class="bold">Arduino IDE</strong> for GPS module testing.</p>
<p>In this chapter, we will use the <strong class="bold">Arduino IoT SIM card</strong> for communication instead of local SIM providers. Arduino provides a wide variety of data plans for global IoT sim cards that can be chosen according to requirements. The code for this chapter is available at the book’s official GitHub repository at this link: https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/>Enhancing operations with IoT asset tracking and remote control</h1>
<p><strong class="bold">IoT</strong> technology can be very useful for asset tracking and remote controlling and monitoring operations. By installing sensors on assets and connecting them to a central network, you can track the location and status of your assets in real time. Here are some ways in which IoT can<a id="_idIndexMarker419"/> be used for asset tracking and remote controlling<a id="_idIndexMarker420"/> and monitoring operations:</p>
<ul>
<li><strong class="bold">Asset tracking</strong>: By installing GPS trackers or RFID tags on your assets, you can track their location and movements in real time. This can be very useful for logistics and supply chain management, as well as fleet management.</li>
<li><strong class="bold">Condition monitoring</strong>: By <a id="_idIndexMarker421"/>installing sensors on your assets, you can monitor their condition and performance in real time. This can help you identify potential problems before they become serious and take corrective action to prevent downtime and reduce maintenance costs.</li>
<li><strong class="bold">Predictive maintenance</strong>: By analyzing data from your sensors, you can use machine<a id="_idIndexMarker422"/> learning algorithms to predict when maintenance is needed on your assets. This can help you schedule maintenance at the most convenient time and avoid unplanned downtime.</li>
<li><strong class="bold">Remote control</strong>: By<a id="_idIndexMarker423"/> connecting your assets to a central network, you can control them remotely from a central location. This can be very useful for operations that are located in remote areas or difficult to access.</li>
<li><strong class="bold">Remote monitoring</strong>: By<a id="_idIndexMarker424"/> installing cameras and other sensors on your assets, you can monitor their operations remotely in real time. This can help you identify potential problems and take corrective action quickly.</li>
</ul>
<p>Overall, IoT technology can be very useful for asset tracking and remote controlling and monitoring operations. By leveraging the power of sensors, data analytics, and machine learning, you can improve the efficiency and reliability of your operations while reducing costs and downtime. In this section, we have discussed IoT for asset tracking and remote monitoring using cellular technology. Next, we will cover different communication technologies that are available now and coming to market in the future.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor105"/>Exploring the advantages of GSM/LTE/NB-IoT communication technologies</h1>
<p><strong class="bold">Global System for Mobile communication</strong> (<strong class="bold">GSM</strong>), LTE, and <strong class="bold">NarrowBand-Internet of Things</strong> (<strong class="bold">NB-IoT</strong>) are all wireless communication technologies that are widely<a id="_idIndexMarker425"/> used for mobile communications and IoT devices. Each technology has its own pros and cons, and the choice of which technology to use depends on the specific requirements and solution design.</p>
<p>Here are some<a id="_idIndexMarker426"/> of the reasons why GSM, LTE, or NB-IoT are often chosen over other communication technologies:</p>
<ul>
<li><strong class="bold">Wide coverage</strong>: GSM and LTE networks have extensive coverage and are available in most parts of the world, making them ideal for global connectivity. NB-IoT, on the other hand, has been designed specifically for IoT devices and offers greater coverage in hard-to-reach areas.</li>
<li><strong class="bold">High data rates</strong>: LTE offers high data rates, making it suitable for applications that require fast and reliable data transfer. NB-IoT, although slower, still offers better data rates than<a id="_idIndexMarker427"/> other <strong class="bold">Low-Power Wide-Area Network</strong> (<strong class="bold">LPWAN</strong>) technologies.</li>
<li><strong class="bold">Security</strong>: GSM and LTE networks offer high levels of security, with features such as encryption and authentication to protect against eavesdropping and other forms of cyberattacks. NB-IoT also provides end-to-end encryption for data security.</li>
<li><strong class="bold">Compatibility</strong>: GSM and LTE networks are backward compatible with previous generations of technology, allowing for seamless integration with existing infrastructure. NB-IoT is also designed to be compatible with LTE networks, making it easy to add IoT capabilities to existing LTE networks.</li>
<li><strong class="bold">Battery life</strong>: NB-IoT and other LPWAN technologies are designed to consume minimal power, resulting in longer battery life for connected devices.</li>
</ul>
<p>Overall, GSM, LTE, and NB-IoT are widely used communication technologies that offer reliable connectivity, high data rates, security, and compatibility with existing infrastructure. Here, we have discussed the benefits of GSM/LTE/NB-IoT communication technologies over other wireless communication technologies. In the next section, we are going to cover global IoT SIM cards, which is the main pillar of this chapter.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor106"/>Seamless global connectivity with IoT SIM cards</h1>
<p>Global IoT SIM cards <a id="_idIndexMarker428"/>are specifically designed for IoT devices that require cellular connectivity to communicate with the internet or other connected devices. These SIM cards provide access to multiple networks, allowing devices to roam across different countries and regions without the need to switch between SIM cards.</p>
<p>Global IoT SIM cards typically <a id="_idIndexMarker429"/>offer features such as the following:</p>
<ul>
<li><strong class="bold">Multi-network coverage</strong>: These SIM cards can connect to multiple cellular networks, including GSM, LTE, and other emerging technologies, such as NB-IoT and <strong class="bold">Cat-M</strong>, to <a id="_idIndexMarker430"/>provide reliable coverage in different locations.</li>
<li><strong class="bold">Over-the-air</strong> (<strong class="bold">OTA</strong>) <strong class="bold">updates</strong>: Many global IoT SIM card providers offer OTA updates, enabling devices to receive firmware and software updates without the need for physical intervention, improving efficiency and reducing maintenance costs.</li>
<li><strong class="bold">Data plans</strong>: Global IoT SIM card providers offer flexible data plans that can be customized to suit the specific needs of a device or application. This includes data allowances, data speed, and the ability to add more data as needed.</li>
<li><strong class="bold">Security</strong>: Global IoT SIM cards typically come with security features such as encryption and authentication to protect data and prevent unauthorized access.</li>
<li><strong class="bold">Management tools</strong>: Many global IoT SIM card providers offer web-based portals or mobile apps that allow users to monitor and manage their SIM cards, including data usage, network performance, and billing information.</li>
</ul>
<p>Global IoT SIM cards provide a cost-effective and flexible solution for companies, allowing them to deploy IoT devices worldwide. They allow seamless connectivity, ensuring that devices are always connected to the best available network, regardless of location.</p>
<p>There are many <a id="_idIndexMarker431"/>IoT global SIM service providers. Here is a list of some of them:</p>
<ul>
<li>Hologram</li>
<li>Soracom</li>
<li>Arduino SIM</li>
<li>Twilio</li>
<li>Emnify</li>
<li>Aeris</li>
<li>KORE Wireless</li>
<li>Sierra Wireless</li>
<li>Teleena</li>
<li>Thales Group</li>
<li>Truphone</li>
<li>UROS</li>
<li>1oT</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">Before buying an IoT global SIM card from any service provider, please verify whether it works in your region or not and, if so, what type of services it offers, such as GSM, <strong class="bold">3G</strong>/<strong class="bold">4G</strong>, or NB-IoT, as there are many regions where, for example, NB-IoT services are still not available.</p>
<p class="callout">Please note<a id="_idIndexMarker432"/> that this is not a complete list, and there are many other IoT SIM providers available in the market. It’s important to research and compare different providers based on your specific requirements and needs before making a decision.</p>
<p>Here, we have discussed global IoT SIM cards in detail and listed all the top global IoT SIM card service providers. Next, we are going to cover what types of hardware and sensors are required to complete the chapter’s project.</p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/>Building blocks – sensors and development boards for IoT</h1>
<p>The Arduino series has a wide collection of development boards that vary in size, pins, and communication <a id="_idIndexMarker433"/>technologies. In this chapter, I will use an Arduino MKR GSM 1400 development board, as it’s compact, battery-enabled, and <a id="_idIndexMarker434"/>provides the support of GSM/3G/4G. <em class="italic">Figure 5</em><em class="italic">.1</em> shows the pinout diagram for the MKR GSM 1400.</p>
<div><div><img alt="Figure 5.1 – Arduino MKR GSM 1400" src="img/B19752_05_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Arduino MKR GSM 1400</p>
<p>Arduino MKR GSM 1400<a id="_idIndexMarker435"/> provides 7 analog pins and 14 digital input/output pins, with built-in battery charging and a LiPo battery connector for standby power, which helps developers build prototypes and solutions for remote monitoring/operations without worrying about power backups. For further details, please visit the official website at <a href="https://store-usa.arduino.cc/products/arduino-mkr-gsm-1400">https://store-usa.arduino.cc/products/arduino-mkr-gsm-1400</a>.</p>
<p>Arduino’s latest development board, MKR NB 1500, only supports NB-IoT, <strong class="bold">LTE-M</strong>, and <strong class="bold">Enhanced GPRS</strong> (<strong class="bold">EGPRS</strong>) for <a id="_idIndexMarker436"/>SMS. NB-IoT and LTE-M are specially designed for IoT devices, and their popularity is spreading very rapidly across different regions. For complete details and specifications, visit <a href="https://store-usa.arduino.cc/products/arduino-mkr-nb-1500">https://store-usa.arduino.cc/products/arduino-mkr-nb-1500</a>. For a list of updated regions where NB-IoT and LTE-M are deployed, visit <a href="https://www.gsma.com/iot/deployment-map/">https://www.gsma.com/iot/deployment-map/</a>.</p>
<p>In this chapter, we will track the assets based on GPS location. To get the GPS coordinates, we will use<a id="_idIndexMarker437"/> the <strong class="bold">GY-GPS6MV2 GPS module</strong>, which is based <a id="_idIndexMarker438"/>on the <strong class="bold">NEO-6M u-blox</strong> chip. The GPS module <a id="_idIndexMarker439"/>communicates on both software serial and hardware serial ports, but MKR GSM 1400 provides a built-in hardware serial, so we will use <em class="italic">Pins 13</em> and <em class="italic">14</em> to communicate with the GPS module.</p>
<p>The GPS module <a id="_idIndexMarker440"/>provides latitude, longitude, satellite count, altitude feet, and speed per mile data. We will display these properties on the dashboard for proper asset tracking. This module was developed in China and is available on the market at affordable prices, but <a id="_idIndexMarker441"/>there are many other organizations that develop GPS modules based on the NEO-6M u-blox chip, such<a id="_idIndexMarker442"/> as <strong class="bold">SparkFun</strong>, <strong class="bold">Seeed Studio</strong>, and <strong class="bold">Adafruit</strong>. <em class="italic">Figure 5</em><em class="italic">.2</em> shows<a id="_idIndexMarker443"/> the NEO-6M u-blox GPS module and its pinout diagram:</p>
<div><div><img alt="Figure 5.2 – The NEO-6M u-blox GY-GPS6MV2 GPS module and a pinout diagram" src="img/B19752_05_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The NEO-6M u-blox GY-GPS6MV2 GPS module and a pinout diagram</p>
<p>The <a id="_idIndexMarker444"/>preceding figure<a id="_idIndexMarker445"/> illustrates the pinout layout of the GPS module. <em class="italic">Pin #1</em> is a <strong class="bold">ground</strong> (<strong class="bold">GND</strong>) pin that connects with the onboard GND, while <em class="italic">Pin #2</em> and <em class="italic">Pin #3</em> are <strong class="bold">transmit</strong> (<strong class="bold">TX</strong>) and <strong class="bold">receive</strong> (<strong class="bold">RX</strong>) pins, respectively, and connect to <em class="italic">Pin #13</em> and <em class="italic">Pin #14</em> of MKR GSM 1400, respectively. <em class="italic">Pin #4</em> – the <strong class="bold">voltage common collector</strong> (<strong class="bold">VCC</strong>) – works with both onboard <a id="_idIndexMarker446"/>VCC and 5V pins. You can solder the male headers with the GPS module or directly solder the cables without any header pins.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The GPS module works optimally in an outdoor environment. Make sure there is no rooftop during testing and deployment to receive a proper signal from satellites.</p>
<p class="callout">If you are using the module in a lab, then there will be a chance that the GPS module will not work properly. Remember that there is a built-in light in the GPS module that blinks when you start receiving signals from satellites.</p>
<p>In this section, we discussed the MKR GSM 1400 development board, which is a SIM-enabled board, and the NEO-6M u-blox GPS module, which will provide the GPS coordinates to the development board. We also discussed their pin layouts. Next, we will discuss how to connect the GPS module with the MKR GSM 1400 development board.</p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Designing the project architecture</h1>
<p>In the <a id="_idIndexMarker447"/>preceding sections, we discussed the module and development board in detail. Now, it’s time to cook the recipe. In hardware development, before starting to work with sensors and development boards, we need to develop the design concepts to get a better understanding of how things will connect. There is a lot of software that is available to design and develop design concepts for an electronics project, but in this case, we will use Fritzing.</p>
<p>In the following two subsections, we will talk about schematics and designing a project, while explaining how to connect pins with a development board and soldering. Then, we will do some tests to fetch GPS coordinates, which is very important before sending data to the cloud.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/>Schematic design and assembly</h2>
<p>The purpose of your<a id="_idIndexMarker448"/> schematic design is to get a clear understanding of how sensors will connect with a development board. Schematic diagram helps you to develop a prototype on a <a id="_idIndexMarker449"/>breadboard or a <strong class="bold">Veroboard,</strong> which is shown in <em class="italic">Figure 5</em><em class="italic">.3</em>. Another major benefit of designing is that Fritzing builds hardware schematics and PCB design in the background according to your design, which can <a id="_idIndexMarker450"/>be adjusted according to system requirements. <em class="italic">Figure 5</em><em class="italic">.3</em> shows the schematic diagram of how to connect MKR GSM 1400 with the NEO-6M u-blox GPS module:</p>
<div><div><img alt="Figure 5.3 – MKR GSM 1400 and the GPS module schematic" src="img/B19752_05_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – MKR GSM 1400 and the GPS module schematic</p>
<p><em class="italic">Figure 5</em><em class="italic">.3</em> is schematic <a id="_idIndexMarker451"/>diagram of project, but for ease I also <a id="_idIndexMarker452"/>created <em class="italic">Table 5.1,</em> which demonstrates MKR GSM 1400 to GPS Module pin numbers and names.</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">MKR GSM </strong><strong class="bold">1400 Board</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">GPS Module</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>5V</p>
</td>
<td class="No-Table-Style">
<p>VCC</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>GND</p>
</td>
<td class="No-Table-Style">
<p>GND</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>14 TX</p>
</td>
<td class="No-Table-Style">
<p>RX</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>13 RX</p>
</td>
<td class="No-Table-Style">
<p>TX</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1 – MKR GSM 1400 and the GPS module pin connections list</p>
<p>The preceding <a id="_idIndexMarker453"/>design provides a full overview of how you <a id="_idIndexMarker454"/>can connect a module to a development board. According to our design, we have 5V and GND from the development board to the GPS module. The GPS module TX is connected to the RX (<em class="italic">Pin #13</em>) and the GPS module RX pin is connected to the TX (<em class="italic">Pin #14</em>) of the development board. <em class="italic">Table 5.1</em> shows the pin information. Finally, we have built our prototype by using a breadboard, which is shown in <em class="italic">Figure 5</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 5.4 – The final prototype" src="img/B19752_05_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The final prototype</p>
<p>After soldering the male headers to the GPS module, connect the pins according to the schematic diagram. There is only one sensor, so there is no requirement for the Veroboard. Next, we are going to test the GPS module using a serial monitor to verify that our GPS module is working properly and getting the values from GPS.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor110"/>Testing GPS module data</h2>
<p>For <a id="_idIndexMarker455"/>module testing, we need a <code>tinygps</code> into the search bar.</p>
<div><div><img alt="Figure 5.5 – The TinyGPSPlus library" src="img/B19752_05_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The TinyGPSPlus library</p>
<p>After searching, <strong class="bold">Library Manager</strong> shows a lot of libraries. Select the <strong class="bold">TinyGPSPlus</strong> library and install its latest version. The library comes with a lot of examples, but all are based on software serial. However, <strong class="bold">Arduino SAMD</strong> boards <a id="_idIndexMarker457"/>provide hardware serial, so I modified the code that uses hardware serial to communicate with the GPS module.</p>
<p>Download the code from the book’s official GitHub repository in the chapter folder, open the <code>MKR-1400-NEO-6M-GPS-Module</code> code, and upload it to the development board:</p>
<pre class="source-code">
while(Serial1.available()&gt;0)//While there are characters to come from the GPS
  {
    gps.encode(Serial1.read());//This feeds the serial NMEA data into the library one char at a time
  }
  if(gps.location.isUpdated())//This will pretty much be fired all the time anyway but will at least reduce it to only after a package of NMEA data comes in
  {
    //Get the latest info from the gps object which it derived from the data sent by the GPS unit
    Serial.println("Satellite Count:");
    Serial.println(gps.satellites.value());
    Serial.println("Latitude:");
    Serial.println(gps.location.lat(), 6);
    Serial.println("Longitude:");
    Serial.println(gps.location.lng(), 6);
    Serial.println("Speed MPH:");
    Serial.println(gps.speed.mph());
    Serial.println("Altitude Feet:");
    Serial.println(gps.altitude.feet());
    Serial.println("");
  }</pre> <p>In the <a id="_idIndexMarker458"/>setup, we have initialized <code>Serial</code> and <code>Serial1</code>. <code>Serial</code> is used to display the content on the serial monitor, while <code>Serial1</code> is the hardware serial that is used to communicate with the GPS module. The preceding code belongs to the <code>loop()</code> method.</p>
<p>First, the <a id="_idIndexMarker459"/>GPS module will read the data from satellites using the <code>Serial1.read()</code> method and encode the data via the <code>gps.encode()</code> method. <code>Serial1</code> only reads one character at a time, so it will take a little bit of time to update the values. Next, we will verify whether there is any update in location by using the <code>gps.location.isUpdated()</code> method. If there is a change, then data will be printed on the serial monitor.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Make sure that your GPS module is placed in an open environment where you have a clear sky without any obstructions, such as a roof or anything similar, to properly receive signals from satellites.</p>
<p class="callout">The GPS module has an onboard built-in LED that starts blinking when it receives data from GPS.</p>
<p class="callout">The same code will work with MKR NB 1500 without any modification.</p>
<p><em class="italic">Figure 5</em><em class="italic">.6</em> shows the serial monitor with values from the GPS, which includes latitude and longitude, along with other parameters:</p>
<div><div><img alt="Figure 5.6 – GPS module data on the serial monitor" src="img/B19752_05_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – GPS module data on the serial monitor</p>
<p>The<a id="_idIndexMarker460"/> preceding figure shows the data that is received by the GPS module from GPS satellites and printed on the serial monitor. The data includes the satellite count, the latitude and longitude that represent the location coordinates, the speed in <strong class="bold">miles per hour</strong> (<strong class="bold">MPH</strong>) based on current and previous GPS coordinates, and the altitude in feet.</p>
<p>In this section, we tested the NEO-6M u-blox GPS module in the Arduino IDE. First, we installed the TinyGPSPlus library for the module and then we used the preceding code for the development board, which shows the readings on the serial monitor. In the next section, we are going to start with the global IoT SIM card activation.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Activating SIM cards for IoT deployment</h1>
<p>After<a id="_idIndexMarker461"/> assembling the GPS module with MKR GSM 1400 and testing it, it’s time to activate the Hologram global IoT SIM card, which will act as a bridge between the device and the Arduino IoT Cloud. You can purchase the IoT SIM card from <a href="https://store.hologram.io/store/">https://store.hologram.io/store/</a>. It provides different types of SIM cards for industries, such as<a id="_idIndexMarker462"/> the <strong class="bold">Hyper EUICC IoT SIM card</strong>, which is an industrial-grade and simple SIM card for learning projects, and these are available in different sizes according to the SIM slots in the development boards. You can order<a id="_idIndexMarker463"/> its <strong class="bold">pilot SIM card</strong> for free, but you need to pay for its shipment.</p>
<p>After receiving the SIM card, create an account at <a href="http://hologram.io">hologram.io</a>, where you will be able to activate and manage all your SIM cards. The Hologram dashboard provides full details regarding the data utilization of devices, packages, billing, and routes. By setting up routes, you can forward your device data to a different IoT cloud if you directly send it to the Hologram cloud. However, in our case, we will just use the Hologram SIM card as a carrier to <a id="_idIndexMarker464"/>transfer data from a device directly to the Arduino IoT Cloud, so there will be no requirements to set up a route. Just activate the SIM card and insert it into the MKR GSM 1400 development board.</p>
<p>In this section, we discussed how we can proceed with Hologram global IoT SIM card activation as well as the different types of SIM cards available at <a href="http://hologram.io">hologram.io</a> for researchers as well as industry. In the next section, we are going to set up the Thing in the Arduino IoT Cloud, which will include cloud variables creation, device association, network configuration, and code.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>Configuring the Thing, network credentials, cloud variables, and code</h1>
<p>After setting<a id="_idIndexMarker465"/> up the hardware, it’s time to set up the Thing in the Arduino IoT Cloud. For this project, we need four cloud variables to fetch different properties from the device. The network settings will be different as we are using a GSM series board instead of Wi-Fi. <em class="italic">Figure 5</em><em class="italic">.7</em> shows the complete overview of the Thing:</p>
<div><div><img alt="Figure 5.7 – A portable Thing tracker using the MKR GSM 1400 Thing setup" src="img/B19752_05_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – A portable Thing tracker using the MKR GSM 1400 Thing setup</p>
<p>Set up a new Thing<a id="_idIndexMarker466"/> with the name <code>A portable thing tracker using MKR GSM1400</code>. Then, follow these steps to create cloud variables, an associate device, a network configuration, and finally, the code:</p>
<ol>
<li>Firstly, we need to set up four cloud variables for location, altitude feet, satellite count, and speed. The complete details regarding these cloud variables are available in the following section.</li>
<li>Then, we need to associate the device with the Thing. In the current project, we will use the MKR GSM 1400, so the wizard will be the same one used for the Arduino boards. The complete details are available in the <em class="italic">Associating a </em><em class="italic">device</em> section.</li>
<li>Finally, we need to set up a network configuration for the device, but this time, we need to provide<a id="_idIndexMarker467"/> different settings for the GSM board, which will be covered in the <em class="italic">Network</em> subsection.</li>
</ol>
<p>Here, we have discussed what steps will be involved in the Thing creation. In the following subsections, we will create cloud variables, associate a device to the Thing, and network settings in separate subsections step by step.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>Cloud variables</h2>
<p>The following table <a id="_idIndexMarker468"/>explains all the properties that we need to use during cloud variable creation. For <code>Location</code>, we need two different variables to store latitude and longitude, but thanks to the Arduino IoT Cloud extended group of variables, we have a <code>Location</code> type variable. Next, make sure each variable matches the declaration in the table; otherwise, you need to modify the example code according to your naming.</p>
<p>In <em class="italic">Table 5.2</em>, during the cloud variables creation, I made the permission <em class="italic">read-only</em>. Although we have the read/write option, in this project, we only want to receive data from the device instead of modifying it on the dashboard. That’s why read-only mode is used – to prevent issues with data consistency. <strong class="bold">Update Policy</strong> is set to <strong class="bold">On change</strong>, as the device will send the data when the GPS module receives new data from satellites.</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">#</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Declaration</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Permission</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Update policy</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>1</p>
</td>
<td class="No-Table-Style">
<p><code>AltitudeFeet</code></p>
</td>
<td class="No-Table-Style">
<p><code>Float</code></p>
</td>
<td class="No-Table-Style">
<p><code>altitudeFeet</code></p>
</td>
<td class="No-Table-Style">
<p>Read-only</p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>2</p>
</td>
<td class="No-Table-Style">
<p><code>Location</code></p>
</td>
<td class="No-Table-Style">
<p><code>CloudLocation</code></p>
</td>
<td class="No-Table-Style">
<p><code>location</code></p>
</td>
<td class="No-Table-Style">
<p>Read-only</p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>3</p>
</td>
<td class="No-Table-Style">
<p><code>SatelliteCount</code></p>
</td>
<td class="No-Table-Style">
<p><code>Int</code></p>
</td>
<td class="No-Table-Style">
<p><code>satelliteCount</code></p>
</td>
<td class="No-Table-Style">
<p>Read-only</p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>4</p>
</td>
<td class="No-Table-Style">
<p><code>Speed</code></p>
</td>
<td class="No-Table-Style">
<p><code>Float</code></p>
</td>
<td class="No-Table-Style">
<p><code>speed</code></p>
</td>
<td class="No-Table-Style">
<p>Read-only</p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.2 – Cloud variables list for the Thing</p>
<p>In this section, we<a id="_idIndexMarker469"/> have discussed what type of cloud variables are required for this project. Here, we have listed four cloud variables of different types but in read-only mode, as we only want to take the values from the device. In the next subsection, we are going to associate the MKR GSM 1400 with the Thing.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>Associating a device</h2>
<p>After creating <a id="_idIndexMarker470"/>the variables, it’s time to add the device and associate it with the Thing. Before adding the device, connect the development board to the computer and open the <strong class="bold">Arduino Create Agent</strong> application. <em class="italic">Figure 5</em><em class="italic">.8</em> shows a popup in which we have options to either select the existing device for association or set up a new device that is not available in the list:</p>
<div><div><img alt="Figure 5.8 – Associate device" src="img/B19752_05_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Associate device</p>
<p>In our case, we <a id="_idIndexMarker471"/>already have different devices in the portal, but we want to add a new MKR GSM 1400 device, so just click on <strong class="bold">SET UP NEW DEVICE</strong> to configure the new device in the account.</p>
<p>Then, you will see two options in the popup (<em class="italic">Figure 5</em><em class="italic">.9</em>). The first option is to set up an Arduino board, and the second option is to set up a third party device. Here, you will see a note under both <a id="_idIndexMarker472"/>options, <strong class="bold">Compatible devices</strong> (<img alt="" role="presentation" src="img/Icon.png"/>), which means you can only use certain types of Arduino devices as well as third-party devices in the Arduino IoT Cloud.</p>
<div><div><img alt="Figure 5.9 – Choosing a development device" src="img/B19752_05_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Choosing a development device</p>
<p>We can select any one option from the popup, according to the available device. However, in this case, click on the option to set up an Arduino device, as, in this chapter, we will use the MKR GSM 1400 board. Before adding the device, make sure that Arduino Create Agent<a id="_idIndexMarker473"/> runs on your machine.</p>
<p>In this subsection, we have associated the MKR GSM 1400 development board with the Thing. Next, we will configure the network settings in the <strong class="bold">Thing</strong> tab.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/>Network</h2>
<p>After<a id="_idIndexMarker474"/> associating the device with the Thing, it is time to configure the network settings for device communication. These network settings are different from the Wi-Fi network settings. Both the MKR GSM 1400 and MKR NB 1500 development boards use SIM technology for communication. For that reason, their network configurations are different and will vary according to the IoT SIM card service provider. The following figure (<em class="italic">Figure 5</em><em class="italic">.10</em>) shows the <strong class="bold">Configure network</strong> popup for the MKR GSM 1400, which is totally different to the Wi-Fi configuration due to cellular communication:</p>
<div><div><img alt="Figure 5.10 – The network configuration for the MKR GSM 1400" src="img/B19752_05_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – The network configuration for the MKR GSM 1400</p>
<p>Currently, we are<a id="_idIndexMarker475"/> using the Hologram global IoT SIM card, and only need to mention <code>hologram</code> under <code>prepay.pelion</code>, <code>0000</code>, and <code>arduino</code>. Before using any other global IoT SIM card, first, take its APN information to set up the network properly.</p>
<p>Here, we have<a id="_idIndexMarker476"/> discussed the network configuration for the Arduino MKR GSM 1400, which includes the APN, PIN, username, and password. In the next section, we will cover the code for the development board.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Coding</h2>
<p>The chapter’s code is<a id="_idIndexMarker477"/> available at the book’s official GitHub repository. Download <code>A_portable_thing_tracker_using_MKR_GSM1400_apr07a.zip</code> and import it into the Arduino Web Editor.</p>
<p>You can download the code and put it into your Thing by navigating to the <code>setup()</code> method; remember to never try to use the <code>delay</code> method, as it will block the <code>ArduinoCloud.update()</code> method:</p>
<pre class="source-code">
TinyGPSPlus gps;
unsigned long previousMillis = 0;
const long interval = 30000; //milliseconds</pre> <p>In the preceding code snippet, we declare the <code>gps</code> instance and two variables, which will be used to wait for 30,000 milliseconds (30 seconds) before taking the next readings without blocking the code.</p>
<p>Next, we will move toward the <code>loop</code> method. Here, we call the <code>FetchGPS()</code> method after every 30 minutes, which is carried out by comparing <code>currentMillis</code> and <code>previousMillis</code> without the use of delay:</p>
<pre class="source-code">
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis &gt;= interval) {
    //speed=currentMillis;
    FetchGPS();
    previousMillis = currentMillis;
  }</pre> <p>In the following snippet, I have just picked a small part of the code from the <code>FetchGPS()</code> method. Here, I assign the latest values from the GPS module to the Arduino cloud <a id="_idIndexMarker478"/>variables, which will be used to send data to the cloud as well as print it on the serial monitor:</p>
<pre class="source-code">
if (gps.location.isUpdated())
  {
    altitudeFeet = gps.altitude.feet();
    satelliteCount = gps.satellites.value();
    speed = gps.speed.mph();
    location = Location(gps.location.lat(), gps.location.lng());
    Location cordinates = location.getValue();
 .
 .
 .
}</pre> <p>Upload the code to the device and open up the Arduino Web Editor serial monitor to verify the values. After successfully uploading the data to the cloud, it’s time to set up a beautiful dashboard for web and mobile for end users.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If you used different names in the variable declaration, then update the code according to your naming scheme. However, it’s better to first follow all the steps according to the book and later change the cloud variable names, modifying your code respectively.</p>
<p class="callout">Never try to use the <code>delay</code> method, which will create a block for the <code>ArduinoCloud.update()</code> method.</p>
<p class="callout">The Arduino IoT Cloud only updates a value on the dashboard whenever a variable value is changed. For example, if the GPS location of the device is the same after an interval of time, then it means the device is not moving. Then, the Arduino IoT Cloud will not record the value, so don’t get confused if values are not changing on the map. Another benefit of this feature is that you will not get duplicate data when you export the content.</p>
<p class="callout">The same code will work with MKR NB 1500 without any modification. However, here, you need to associate the MKR NB 1500 device with the Thing instead of the MKR GSM 1400.</p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/>Creating comprehensive web and mobile dashboards</h1>
<p>After <a id="_idIndexMarker479"/>uploading the code to the device, it’s time to set up a dashboard for web and mobile to visualize the data with different widgets. The following figure demonstrates the visualization of readings with different widgets:</p>
<div><div><img alt="Figure 5.11 – The Thing dashboard" src="img/B19752_05_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – The Thing dashboard</p>
<p>We have four readings from the GPS module to visualize; here, I have used three widgets, <code>location</code> variable. Currently, the Map widget is only capable of displaying the location of the asset device based on coordinates; if you have multiple assets to track, then you need to set up multiple Map widgets according to the number of tracking devices.</p>
<p>Well, this was the last section of our chapter. Here, we have created a stunning dashboard for GPS tracking that shows the location using the Map widget on the dashboard, the speed per mile, and some other parameters.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor118"/>What next?</h1>
<p>We still have a lot of options available to explore, but now it’s your time to use different sensors and development boards to do some more experiments and learn from them. In the current chapter, we only used one GPS module, which gave us only four parameters but, on the market, there are a lot of GPS modules that provide a wide variety of functionalities; they work under the roof as well as under clear sky, and have several accuracy features.</p>
<p>While monitoring an asset’s location, there are some other parameters that are very important to monitor in different industries, such as temperature and humidity, which are very important in food and medical products. CO2 and LPG gases are very important to monitor during fuel transportation. Try different sensors with a GPS module to set up different tracking prototypes for different industries.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/>Summary</h1>
<p>In this chapter, we explored how to develop a GPS-based tracking system using a global IoT SIM card and GPS module. We set up the Thing, which included cloud variable creation, device association, GSM network configuration, and coding a development board. Later, we created a dashboard to visualize the Thing readings with different types of widgets to display current readings, with the most important widget of the chapter being the Map widget. It is a very interesting and important widget to display the location of IoT devices using GPS coordinates.</p>
<p>GPS tracking is a very important aspect that we covered in this chapter, and it helps us to develop a device for our asset tracking, which will help us in asset tracking and monitoring. This chapter demonstrated how we can display the location of a device on the dashboard, which gives you the confidence to build more solutions regarding asset tracking. In the next chapter, we will explore another long-range communication technology, called <strong class="bold">LoRaWAN</strong>. We will use this technology to build a solution for remote monitoring distant areas as well as compare this technology with GSM/4G/LTE and NB-IoT technology for proper guidance.</p>
</div>
</body></html>