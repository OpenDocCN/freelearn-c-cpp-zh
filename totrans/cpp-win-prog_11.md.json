["```cpp\nnamespace SmallWindows { \n  extern const Size USLetterPortrait, LineSize; \n\n```", "```cpp\n  enum KeyboardMode {InsertKeyboard, OverwriteKeyboard}; \n\n```", "```cpp\n  class Document : public Window { \n    public: \n      Document(CoordinateSystem system, Size pageSize, \n               Window* parentPtr = nullptr, \n               WindowStyle style=OverlappedWindow, \n               WindowShow windowShow = Normal, \n               bool acceptDropFiles = true, \n               Size lineSize = LineSize); \n\n    protected: \n      Document(String className, CoordinateSystem system, \n               Size pageSize, Window* parentPtr = nullptr, \n               WindowStyle style = OverlappedWindow, \n               WindowShow windowShow = Normal, \n               bool acceptDropFiles = true, \n               Size lineSize = LineSize); \n\n```", "```cpp\n    public: \n      ~Document(); \n\n      String GetName() const; \n      void SetName(String name); \n      void SetZoom(double zoom); \n      bool IsDirty() const; \n      void SetDirty(bool dirty); \n\n    private: \n      void GenerateHeader();  \n\n```", "```cpp\n    public: \n      virtual void OnSize(Size clientSize); \n\n```", "```cpp\n      virtual void OnMouseWheel(WheelDirection direction, \n                          bool shiftPressed, bool controlPressed); \n\n```", "```cpp\n      void OnGainFocus(); \n      void OnLoseFocus(); \n      void SetCaret(Rect caretLogicalRect); \n      void ClearCaret(); \n\n```", "```cpp\n      virtual void UpdateCaret() {/* Empty. */} \n\n```", "```cpp\n      void SetMenuBar(Menu& menuBar); \n      void OnCommand(WORD commandId); \n      void OnCommandInit(); \n\n```", "```cpp\n      virtual void OnDropFile(vector<String> pathList) \n                             {/* Empty. */} \n\n```", "```cpp\n      KeyboardMode GetKeyboardMode() const {return keyboardMode;} \n      void SetKeyboardMode(KeyboardMode mode) \n                          {keyboardMode = mode;} \n      virtual void OnKeyboardMode(KeyboardMode mode) \n                                 {/* Empty. */} \n\n```", "```cpp\n      virtual void OnHorizontalScroll(WORD flags,WORD thumbPos=0); \n      virtual void OnVerticalScroll(WORD flags, WORD thumbPos =0); \n\n```", "```cpp\n      virtual bool KeyToScroll(WORD key, bool shiftPressed, \n                               bool controlPressed); \n\n```", "```cpp\n      void SetHorizontalScrollPosition(int scrollPos); \n      int GetHorizontalScrollPosition() const; \n      void SetVerticalScrollPosition(int scrollPos); \n      int GetVerticalScrollPosition() const; \n\n      void SetHorizontalScrollLineWidth(int lineWidth); \n      int GetHorizontalScrollLineHeight() const; \n      void SetVerticalScrollLineHeight(int lineHeight); \n      int GetVerticalScrollLineHeight() const; \n\n      void SetHorizontalScrollPageWidth(int pageWidth); \n      int GetHorizontalScrollPageWidth() const; \n      void SetVerticalScrollPageHeight(int pageHeight); \n      int GetVerticalScrollPageHeight() const; \n\n      void SetHorizontalScrollTotalWidth(int scrollWidth); \n      int GetHorizontalScrollTotalWidth() const; \n      void SetVerticalScrollTotalHeight(int scrollHeight); \n      int GetVerticalScrollTotalHeight() const; \n\n```", "```cpp\n    public: \n      map<WORD,Command>& CommandMap() {return commandMap;} \n\n```", "```cpp\n      list<ACCEL>& AcceleratorSet() {return acceleratorSet;} \n\n    private: \n      map<WORD, Command> commandMap; \n      list<ACCEL> acceleratorSet; \n\n```", "```cpp\n      String name; \n      bool caretPresent = false; \n\n```", "```cpp\n      Size lineSize; \n\n```", "```cpp\n      bool dirtyFlag = false; \n\n```", "```cpp\n      HMENU menuBarHandle; \n\n```", "```cpp\n      KeyboardMode keyboardMode = InsertKeyboard; \n  }; \n\n```", "```cpp\n  LRESULT CALLBACK DocumentProc(HWND windowHandle, UINT message, \n                           WPARAM wordParam,LPARAM longParam); \n\n```", "```cpp\n  vector<String> ExtractPathList(WORD wordParam); \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n  const Size USLetterPortrait(21590, 27940), LineSize(500, 500); \n\n```", "```cpp\n  Document::Document(CoordinateSystem system, Size pageSize, \n                     Window* parentPtr /* = nullptr */, \n                     WindowStyle style /* = OverlappedWindow */, \n                     WindowShow windowShow /* = Normal */, \n                     bool acceptDropFiles /* = true */, \n                     Size lineSize /* = LineSize */) \n   :Document::Document(TEXT(\"document\"), system, pageSize, \n                       parentPtr, style, windowShow, \n                       acceptDropFiles, lineSize) { \n    // Empty. \n  } \n\n```", "```cpp\n  Document::Document(String className, CoordinateSystem system, \n                     Size pageSize, Window* parentPtr/*=nullptr*/, \n                     WindowStyle style /* = OverlappedWindow */, \n                     WindowShow windowShow /* = Normal */, \n                     bool acceptDropFiles /* = true */, \n                     Size lineSize /* = LineSize */) \n   :Window(className, system, pageSize, parentPtr, \n           style, NoStyle, windowShow), \n\n```", "```cpp\n    lineSize(lineSize) { \n\n```", "```cpp\n    GenerateHeader(); \n\n```", "```cpp\n    SetHorizontalScrollPosition(0); \n    SetVerticalScrollPosition(0); \n\n```", "```cpp\n    SetHorizontalScrollTotalWidth(pageSize.Width()); \n    SetVerticalScrollTotalHeight(pageSize.Height()); \n\n```", "```cpp\n    Size clientSize = GetClientSize(); \n    SetHorizontalScrollPageWidth(clientSize.Width()); \n    SetVerticalScrollPageHeight(clientSize.Height()); \n\n```", "```cpp\n    ::DragAcceptFiles(windowHandle, \n                      acceptDropFiles ? TRUE : FALSE); \n  } \n\n```", "```cpp\n  Document::~Document() { \n    if (caretPresent) { \n      ::DestroyCaret(); \n    } \n  } \n\n```", "```cpp\n  String Document::GetName() const { \n    return name; \n  }  \n\n  void Document::SetName(String name) { \n    this->name = name; \n    GenerateHeader(); \n  }  \n\n  void Document::SetZoom(double zoom) { \n    Window::SetZoom(zoom); \n    GenerateHeader(); \n  } \n\n  bool Document::IsDirty() const { \n    return dirtyFlag; \n  }  \n\n  void Document::SetDirty(bool dirty) { \n    dirtyFlag = dirty; \n    GenerateHeader(); \n  } \n\n```", "```cpp\n  void Document::GenerateHeader() { \n    String headerName = name.empty() ? TEXT(\"[No Name]\") : name, \n           dirtyText = dirtyFlag ? TEXT(\"*\") : TEXT(\"\"); \n    int zoomPerCent = (int) (100 * GetZoom()); \n\n    if (zoomPerCent!= 100) { \n      String zoomText = \n        TEXT(\" \") + to_String(zoomPerCent) + TEXT(\"%\"); \n      SetHeader(headerName + dirtyText + zoomText); \n    } \n    else { \n      SetHeader(headerName + dirtyText); \n    } \n  } \n\n```", "```cpp\n  void Document::OnSize(Size clientSize) { \n    SetHorizontalScrollPageWidth(clientSize.Width()); \n    SetVerticalScrollPageHeight(clientSize.Height()); \n  } \n\n```", "```cpp\n  void Document::OnGainFocus() { \n    if (caretPresent) { \n      ::ShowCaret(windowHandle); \n    } \n  } \n\n  void Document::OnLoseFocus() { \n    if (caretPresent) { \n      ::HideCaret(windowHandle); \n    } \n  } \n\n```", "```cpp\n  void Document::SetCaret(Rect caretLogicalRect) { \n    if (caretPresent) { \n      ::DestroyCaret(); \n    } \n\n```", "```cpp\n    Rect deviceCaretRect = LogicalToDevice(caretLogicalRect); \n    if (deviceCaretRect.Width() == 0) {       \n      deviceCaretRect.Right() = deviceCaretRect.Left() + 1; \n    } \n\n```", "```cpp\n    ::CreateCaret(windowHandle, nullptr, deviceCaretRect.Width(), \n                  deviceCaretRect.Height()); \n    ::SetCaretPos(deviceCaretRect.Left(), deviceCaretRect.Top()); \n    ::ShowCaret(windowHandle); \n\n    caretPresent = true; \n  } \n\n```", "```cpp\n  void Document::ClearCaret() { \n    if (caretPresent) { \n      ::DestroyCaret(); \n    }  \n    caretPresent = false; \n  } \n\n```", "```cpp\n  void Document::OnMouseWheel(WheelDirection wheelDirection, \n                        bool shiftPressed, bool controlPressed){ \n    if (controlPressed) { \n      switch (wheelDirection) { \n        case WheelUp: \n          OnVerticalScroll(SB_LINEUP); \n          break; \n\n        case WheelDown: \n          OnVerticalScroll(SB_LINEDOWN); \n          break; \n      } \n    } \n\n```", "```cpp\n    else { \n      switch (wheelDirection) { \n        case WheelUp: \n          SetZoom(min(10.0, 1.11 * GetZoom())); \n          break; \n\n        case WheelDown: \n          SetZoom(max(0.1, 0.9 * GetZoom())); \n          break; \n      } \n    } \n\n```", "```cpp\n    Invalidate(); \n    UpdateWindow(); \n    UpdateCaret(); \n  } \n\n```", "```cpp\n  void Document::SetMenuBar(Menu& menuBar) { \n    menuBarHandle = menuBar.menuHandle; \n    ::SetMenu(windowHandle, menuBarHandle); \n  } \n\n```", "```cpp\n  void Document::OnCommand(WORD commandId) { \n    Command command = commandMap[commandId]; \n    command.Selection()(this); \n  } \n\n```", "```cpp\n  void Document::OnCommandInit() { \n    for (pair<WORD,Command> pair : commandMap) { \n      WORD commandId = pair.first; \n      Command command = pair.second; \n\n```", "```cpp\n      if (command.Enable() != nullptr) { \n        UINT enableFlag = command.Enable()(this) ? \n                          MF_ENABLED : MF_GRAYED; \n        ::EnableMenuItem(menuBarHandle, commandId, \n                         MF_BYCOMMAND | enableFlag); \n      } \n\n```", "```cpp\n      { bool checkFlag = false; \n        if (command.Check() != nullptr) { \n          BoolListener checkListener = command.Check(); \n          checkFlag = checkListener(this); \n        } \n\n        bool radioFlag = false; \n        if (command.Radio() != nullptr) { \n          BoolListener radioListener = command.Radio(); \n          radioFlag = radioListener(this); \n        } \n\n```", "```cpp\n        UINT checkFlags = (checkFlag | radioFlag) ? \n                          MF_CHECKED : MF_UNCHECKED; \n        ::CheckMenuItem(menuBarHandle, commandId, \n                        MF_BYCOMMAND | checkFlags); \n      } \n    } \n  } \n\n```", "```cpp\n  void Document::OnHorizontalScroll(WORD flags, \n                                    WORD thumbPos /*= 0 */) { \n    int scrollPos = GetHorizontalScrollPosition(), \n        scrollLine = GetHorizontalScrollLineHeight(), \n        scrollPage = GetHorizontalScrollPageWidth(), \n        scrollSize = GetHorizontalScrollTotalWidth(); \n\n    switch (flags) { \n      case SB_LEFT: \n        SetHorizontalScrollPosition(0); \n        break; \n\n```", "```cpp\n      case SB_LINELEFT: \n        SetHorizontalScrollPosition(max(0, scrollPos - \n                                           scrollLine)); \n        break; \n\n      case SB_PAGELEFT: \n        SetHorizontalScrollPosition(max(0, scrollPos - \n                                           scrollPage)); \n        break; \n\n```", "```cpp\n      case SB_LINERIGHT: \n        SetHorizontalScrollPosition(min(scrollPos + scrollLine, \n                                        scrollSize - scrollLine)); \n        break; \n\n      case SB_PAGERIGHT: \n        SetHorizontalScrollPosition(min(scrollPos + scrollLine, \n                                        scrollSize - scrollPage)); \n        break; \n\n      case SB_RIGHT: \n        SetHorizontalScrollPosition(scrollSize - scrollPage); \n        break; \n\n```", "```cpp\n      case SB_THUMBTRACK: \n      case SB_THUMBPOSITION: \n        SetHorizontalScrollPosition(thumbPos); \n        break; \n    } \n  } \n\n```", "```cpp\n  void Document::OnVerticalScroll(WORD flags, \n                                  WORD thumbPos /* = 0 */) { \n    int scrollPos = GetVerticalScrollPosition(), \n        scrollLine = GetVerticalScrollLineHeight(), \n        scrollPage = GetVerticalScrollPageHeight(), \n        scrollSize = GetVerticalScrollTotalHeight(); \n\n    switch (flags) { \n      case SB_TOP: \n        SetVerticalScrollPosition(0); \n        break; \n\n      case SB_LINEUP: \n        SetVerticalScrollPosition(max(0, scrollPos - scrollLine)); \n        break; \n\n      case SB_PAGEUP: \n        SetVerticalScrollPosition(max(0, scrollPos - scrollPage)); \n        break; \n\n      case SB_LINEDOWN: \n        SetVerticalScrollPosition(min(scrollPos + scrollLine, \n                                      scrollSize - scrollLine)); \n        break; \n\n      case SB_PAGEDOWN: \n        SetVerticalScrollPosition(min(scrollPos + scrollLine, \n                                      scrollSize - scrollPage)); \n        break; \n\n      case SB_BOTTOM: \n        SetVerticalScrollPosition(scrollSize - scrollPage); \n        break; \n\n      case SB_THUMBTRACK: \n      case SB_THUMBPOSITION: \n        SetVerticalScrollPosition(thumbPos); \n        break; \n    } \n  } \n\n```", "```cpp\n  bool Document::KeyToScroll(WORD key, bool shiftPressed, \n                             bool controlPressed) { \n    switch (key) { \n      case KeyUp: \n        OnVerticalScroll(SB_LINEUP); \n        return true; \n\n      case KeyDown: \n        OnVerticalScroll(SB_LINEDOWN); \n        return true; \n\n      case KeyPageUp: \n        OnVerticalScroll(SB_PAGEUP); \n        return true; \n\n      case KeyPageDown: \n        OnVerticalScroll(SB_PAGEDOWN); \n        return true; \n\n      case KeyLeft: \n        OnHorizontalScroll(SB_LINELEFT); \n        return true; \n\n      case KeyRight: \n        OnHorizontalScroll(SB_LINERIGHT); \n        return true; \n\n      case KeyHome: \n        OnHorizontalScroll(SB_LEFT); \n        if (controlPressed) { \n          OnVerticalScroll(SB_TOP); \n        } \n        return true; \n\n      case KeyEnd: \n        OnHorizontalScroll(SB_RIGHT); \n        if (controlPressed) { \n          OnVerticalScroll(SB_BOTTOM); \n        } \n        return true; \n    } \n\n    return false; \n  } \n\n```", "```cpp\n  void Document::SetHorizontalScrollPosition(int scrollPos) { \n    if (scrollPos != GetHorizontalScrollPosition()) { \n      ::SetScrollPos(windowHandle, SB_HORZ, scrollPos, TRUE); \n      Invalidate(); \n      UpdateWindow(); \n      UpdateCaret(); \n    } \n  } \n\n```", "```cpp\n  int Document::GetHorizontalScrollPosition() const { \n    return ::GetScrollPos(windowHandle, SB_HORZ); \n  } \n\n```", "```cpp\n  void Document::SetVerticalScrollPosition(int scrollPos) { \n    if (scrollPos != GetVerticalScrollPosition()) { \n      ::SetScrollPos(windowHandle, SB_VERT, scrollPos, TRUE); \n      Invalidate(); \n      UpdateWindow(); \n      UpdateCaret(); \n    } \n  }  \n\n  int Document::GetVerticalScrollPosition() const { \n    return ::GetScrollPos(windowHandle, SB_VERT); \n  } \n\n```", "```cpp\n  void Document::SetHorizontalScrollLineWidth(int lineWidth) { \n    lineSize.Width() = lineWidth; \n  } \n\n  int Document::GetHorizontalScrollLineHeight() const { \n    return lineSize.Width(); \n  } \n\n  void Document::SetVerticalScrollLineHeight(int lineHeight) { \n    lineSize.Height() = lineHeight; \n  } \n\n  int Document::GetVerticalScrollLineHeight() const { \n    return lineSize.Height(); \n  } \n\n```", "```cpp\n  void Document::SetHorizontalScrollPageWidth(int pageWidth) { \n    SCROLLINFO scrollInfo = {sizeof(SCROLLINFO), SIF_PAGE}; \n    scrollInfo.nPage = pageWidth; \n\n    ::SetScrollInfo(windowHandle, SB_HORZ, &scrollInfo, TRUE); \n  } \n\n  int Document::GetHorizontalScrollPageWidth() const { \n    SCROLLINFO scrollInfo = {sizeof(SCROLLINFO), SIF_PAGE}; \n    ::GetScrollInfo(windowHandle, SB_HORZ, &scrollInfo); \n    return scrollInfo.nPage; \n  } \n\n  void Document::SetVerticalScrollPageHeight(int pageHeight) { \n    SCROLLINFO scrollInfo = {sizeof(SCROLLINFO), SIF_PAGE}; \n    scrollInfo.nPage = pageHeight; \n    ::SetScrollInfo(windowHandle, SB_VERT, &scrollInfo, TRUE); \n  } \n\n  int Document::GetVerticalScrollPageHeight() const { \n    SCROLLINFO scrollInfo = {sizeof(SCROLLINFO), SIF_PAGE}; \n    ::GetScrollInfo(windowHandle, SB_VERT, &scrollInfo); \n    return scrollInfo.nPage; \n  } \n\n```", "```cpp\n  void Document::SetHorizontalScrollTotalWidth(int scrollWidth) { \n    ::SetScrollRange(windowHandle, SB_HORZ, 0, scrollWidth, TRUE); \n  } \n\n  int Document::GetHorizontalScrollTotalWidth() const { \n    int minRange, maxRange; \n    ::GetScrollRange(windowHandle, SB_HORZ, &minRange, &maxRange); \n    return maxRange; \n  } \n\n  void Document::SetVerticalScrollTotalHeight(int scrollHeight) { \n    ::SetScrollRange(windowHandle, SB_VERT, 0, scrollHeight,TRUE); \n  } \n\n  int Document::GetVerticalScrollTotalHeight() const { \n    int minRange, maxRange; \n    ::GetScrollRange(windowHandle, SB_VERT, &minRange, &maxRange); \n    return maxRange; \n  } \n\n```", "```cpp\nLRESULT CALLBACK DocumentProc(HWND windowHandle, UINT message, \n                              WPARAM wordParam, LPARAM longParam){ \n\n```", "```cpp\n    if ((windowHandle != nullptr) &&\n        (WindowMap.count(windowHandle) == 1)) {\n      Document* documentPtr = \n        dynamic_cast<Document*>(WindowMap[windowHandle]); \n\n      if (documentPtr != nullptr) { \n        switch (message) { \n\n```", "```cpp\n          case WM_MOUSEWHEEL: { \n              bool down = (HIWORD(wordParam) & 0x0100) != 0; \n              WheelDirection wheelDirection = \n                down ? WheelDown : WheelUp; \n              bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n              bool controlPressed = (::GetKeyState(VK_CONTROL)<0); \n              documentPtr->OnMouseWheel(wheelDirection, \n                             shiftPressed, controlPressed); \n            } \n            return 0; \n\n```", "```cpp\n          case WM_KEYDOWN: { \n              WORD key = wordParam; \n\n```", "```cpp\n              if (key == KeyInsert) { \n                switch (documentPtr->GetKeyboardMode()) { \n\n                  case InsertKeyboard: \n                    documentPtr-> \n                      SetKeyboardMode(OverwriteKeyboard); \n                    documentPtr-> \n                      OnKeyboardMode(OverwriteKeyboard); \n                    break; \n\n                  case OverwriteKeyboard: \n                    documentPtr->SetKeyboardMode(InsertKeyboard); \n                    documentPtr->OnKeyboardMode(InsertKeyboard); \n                    break; \n                } \n\n                return 0; \n              } \n\n```", "```cpp\n              else { \n                bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n                bool controlPressed=(::GetKeyState(VK_CONTROL)<0); \n\n                if (documentPtr->OnKeyDown(wordParam,shiftPressed, \n                                           controlPressed) || \n                    documentPtr->KeyToScroll(key, shiftPressed, \n                                           controlPressed)) { \n                return 0; \n                } \n              } \n            } \n            break; \n\n```", "```cpp\n          case WM_COMMAND: \n            documentPtr->OnCommand(LOWORD(wordParam)); \n            return 0; \n\n          case WM_INITMENUPOPUP: \n            documentPtr->OnCommandInit(); \n            return 0; \n\n```", "```cpp\n          case WM_DROPFILES: { \n              vector<String> pathList = \n                ExtractPathList(wordParam); \n              documentPtr->OnDropFile(pathList); \n            } \n            return 0; \n\n```", "```cpp\n          case WM_HSCROLL: { \n              WORD flags = LOWORD(wordParam), \n                   thumbPos = HIWORD(wordParam); \n              documentPtr->OnHorizontalScroll(flags, thumbPos); \n            } \n            return 0; \n\n          case WM_VSCROLL: { \n              WORD flags = LOWORD(wordParam), \n                   thumbPos = HIWORD(wordParam); \n              documentPtr->OnVerticalScroll(flags, thumbPos); \n            } \n            return 0; \n        } \n      } \n    } \n\n```", "```cpp\n    return WindowProc(windowHandle, message, \n                      wordParam, longParam); \n  } \n\n```", "```cpp\n  vector<String> ExtractPathList(WORD wordParam) { \n    vector<String> pathList; \n    HDROP dropHandle = (HDROP) wordParam; \n\n```", "```cpp\n    int size = \n      ::DragQueryFile(dropHandle, 0xFFFFFFFF, nullptr, 0);  \n    for (int index = 0; index < size; ++index) { \n\n```", "```cpp\n      int bufferSize =  \n        ::DragQueryFile(dropHandle, index, nullptr, 0) + 1; \n      TCHAR* path = new TCHAR[bufferSize]; \n      assert(path!= nullptr); \n\n```", "```cpp\n      assert(::DragQueryFile(dropHandle, index, \n                             path, bufferSize) != 0); \n      pathList.push_back(String(path)); \n      delete [] path; \n    } \n\n    return pathList; \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  typedef void (*VoidListener)(void* sourcePtr); \n  typedef bool (*BoolListener)(void* sourcePtr);  \n\n  class Command { \n    public: \n      Command(); \n      Command(VoidListener selection, BoolListener enable, \n              BoolListener check, BoolListener radio); \n\n      VoidListener Selection() const {return selection;} \n      BoolListener Enable() const {return enable;} \n      BoolListener Check() const {return check;} \n      BoolListener Radio() const {return radio;} \n\n    private: \n      VoidListener selection; \n      BoolListener enable, check, radio; \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\"\n\nnamespace SmallWindows { \n  Command::Command() \n   :selection(nullptr), \n    enable(nullptr), \n    check(nullptr), \n    radio(nullptr) { \n    // Empty. \n  } \n\n  Command::Command(VoidListener selection, BoolListener enable, \n                   BoolListener check, BoolListener radio) \n   :selection(selection), \n    enable(enable), \n    check(check), \n    radio(radio) { \n    // Empty. \n  } \n}; \n\n```", "```cpp\n#define DEFINE_BOOL_LISTENER(SubClass, Listener)  \\ \n  virtual bool Listener() const;                  \\ \n  static bool SubClass::Listener(void* voidPtr) { \\ \n    return ((SubClass*) voidPtr)->Listener();     \\ \n  } \n\n#define DEFINE_VOID_LISTENER(SubClass, Listener)  \\ \n  virtual void Listener();                        \\ \n  static void SubClass::Listener(void* voidPtr) { \\ \n    ((SubClass*) voidPtr)->Listener();            \\ \n  } \n\nnamespace SmallWindows { \n  class Document; \n\n  class Menu { \n    public: \n      Menu(Document* documentPtr, String text = TEXT(\"\")); \n      Menu(const Menu& menu); \n\n      void AddMenu(Menu& menu); \n      void AddSeparator(); \n      void AddItem(String text, VoidListener selection, \n                   BoolListener enable = nullptr, \n                   BoolListener check = nullptr, \n                   BoolListener radio = nullptr); \n\n```", "```cpp\n    private: \n      Document* documentPtr; \n      String text; \n      HMENU menuHandle; \n\n      friend class Document; \n      friend class StandardDocument; \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\n```", "```cpp\nnamespace SmallWindows { \n  Menu::Menu(Document* documentPtr, String text /* = TEXT(\"\") */) \n   :documentPtr(documentPtr), \n    text(text), \n    menuHandle(::CreateMenu()) { \n    // Empty. \n  } \n\n```", "```cpp\n  Menu::Menu(const Menu& menu) \n   :documentPtr(menu.documentPtr), \n    text(menu.text), \n    menuHandle(menu.menuHandle) { \n    // Empty. \n  } \n\n```", "```cpp\n  void Menu::AddMenu(Menu& menu) { \n    ::AppendMenu(menuHandle, MF_STRING | MF_POPUP, \n                 (UINT) menu.menuHandle, menu.text.c_str()); \n  } \n\n  void Menu::AddSeparator() { \n    ::AppendMenu(menuHandle, MF_SEPARATOR, 0, nullptr); \n  } \n\n```", "```cpp\n  void Menu::AddItem(String text, VoidListener selection, \n                     BoolListener enable /* = nullptr */, \n                     BoolListener check /* = nullptr */, \n                     BoolListener radio /* = nullptr */) { \n\n```", "```cpp\n    assert((selection != nullptr) && \n           ((check == nullptr) || (radio == nullptr))); \n\n```", "```cpp\n    map<WORD,Command>& commandMap = documentPtr->CommandMap(); \n    int itemId = commandMap.size(); \n\n```", "```cpp\n    commandMap[itemId] = Command(listener, enable, check, radio); \n    ::AppendMenu(menuHandle, MF_STRING, \n                 (UINT) itemId, text.c_str()); \n\n```", "```cpp\n    if (radio != nullptr) { \n      MENUITEMINFO menuItemInfo; \n      menuItemInfo.cbSize = sizeof menuItemInfo; \n      menuItemInfo.fMask = MIIM_FTYPE; \n      menuItemInfo.fType = MFT_RADIOCHECK; \n      ::SetMenuItemInfo(menuHandle, (UINT) itemId, \n                        FALSE, &menuItemInfo); \n    } \n\n```", "```cpp\n    Accelerator::TextToAccelerator(text, itemId, \n                                   documentPtr->AcceleratorSet()); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n\n```", "```cpp\n  enum Keys {KeyF1 = VK_F1, KeyF2 = VK_F2, KeyF3 = VK_F3, \n             KeyF4 = VK_F4, KeyF5 = VK_F5, KeyF6 = VK_F6, \n             KeyF7 = VK_F7, KeyF8 = VK_F8, KeyF9 = VK_F9, \n             KeyF10 = VK_F10, KeyF11 = VK_F11, KeyF12 = VK_F12, \n             KeyInsert = VK_INSERT, KeyDelete = VK_DELETE, \n             KeyBackspace = VK_BACK, KeyTabulator = VK_TAB, \n             KeyHome = VK_HOME, KeyEnd = VK_END, \n             KeyPageUp = VK_PRIOR, KeyPageDown = VK_NEXT, \n             KeyLeft = VK_LEFT, KeyRight = VK_RIGHT, \n             KeyUp = VK_UP, KeyDown = VK_DOWN, \n             KeySpace = VK_SPACE, KeyEscape = VK_ESCAPE, \n             KeyReturn = VK_RETURN}; \n\n```", "```cpp\n  class Accelerator { \n    public: \n      static void TextToAccelerator(String& text, int idemId, \n                                    list<ACCEL>& acceleratorSet); \n  }; \n}; \n\n```", "```cpp\n    #include \"SmallWindows.h\"\n\n```", "```cpp\nnamespace SmallWindows { \n  WORD TextToVirtualKey(String& text) { \n    static const struct { \n      TCHAR* textPtr; \n      WORD key; \n    } keyTable[] = { \n      {TEXT(\"F1\"), KeyF1}, {TEXT(\"F2\"), KeyF2}, \n      {TEXT(\"F3\"), KeyF3}, {TEXT(\"F4\"), KeyF4}, \n      {TEXT(\"F5\"), KeyF5}, {TEXT(\"F6\"), KeyF6}, \n      {TEXT(\"F7\"), KeyF7}, {TEXT(\"F8\"), KeyF8}, \n      {TEXT(\"F9\"), KeyF9}, {TEXT(\"F10\"), KeyF10}, \n      {TEXT(\"F11\"), KeyF11}, {TEXT(\"F12\"), KeyF12}, \n      {TEXT(\"Insert\"), KeyInsert}, {TEXT(\"Delete\"), KeyDelete}, \n      {TEXT(\"Back\"), KeyBackspace}, {TEXT(\"Tab\"), KeyTabulator}, \n      {TEXT(\"Home\"), KeyHome}, {TEXT(\"End\"), KeyEnd}, \n      {TEXT(\"Page Up\"), KeyPageUp}, \n      {TEXT(\"Page Down\"), KeyPageDown}, \n      {TEXT(\"Left\"), KeyLeft}, {TEXT(\"Right\"), KeyRight}, \n      {TEXT(\"Up\"), KeyUp}, {TEXT(\"Down\"), KeyDown}, \n      {TEXT(\"Space\"), KeySpace},  {TEXT(\"Escape\"), KeyEscape}, \n      {TEXT(\"Return\"), KeyReturn}, {nullptr, 0}}; \n\n```", "```cpp\n    for (int index = 0; keyTable[index].textPtr != nullptr; \n         ++index) { \n      if (text == keyTable[index].textPtr) { \n        return keyTable[index].key; \n      } \n    } \n\n```", "```cpp\n    assert(false); \n    return 0; \n  } \n\n```", "```cpp\n  void Accelerator::TextToAccelerator(String& text, int itemId, \n                                      list<ACCEL>&acceleratorSet){ \n\n```", "```cpp\n    int tabulatorIndex = text.find(TEXT(\"\\t\")); \n    if (tabulatorIndex != -1) { \n      ACCEL accelerator; \n      accelerator.fVirt = 0; \n      accelerator.cmd = itemId; \n      String acceleratorText = text.substr(tabulatorIndex + 1); \n\n```", "```cpp\n      { String controlText = TEXT(\"Ctrl+\"); \n        int controlIndex = acceleratorText.find(controlText); \n\n        if (controlIndex != -1) { \n          accelerator.fVirt |= FCONTROL; \n          acceleratorText.erase(controlIndex, \n                                controlText.length()); \n        } \n      } \n\n      { String altText = TEXT(\"Alt+\"); \n        int altIndex = acceleratorText.find(altText); \n\n        if (altIndex != -1) { \n          accelerator.fVirt |= FALT; \n          acceleratorText.erase(altIndex, altText.length()); \n        } \n      } \n\n      { String shiftText = TEXT(\"Shift+\"); \n        int shiftIndex = acceleratorText.find(shiftText); \n\n        if (shiftIndex != -1) { \n          accelerator.fVirt |= FSHIFT; \n          acceleratorText.erase(shiftIndex, shiftText.length()); \n        } \n      } \n\n```", "```cpp\n      if (acceleratorText.length() == 1) { \n        accelerator.key = \n          (WORD) ((tolower(acceleratorText[0]) - ''a'') + 1); \n      } \n\n```", "```cpp\n      else { \n        accelerator.fVirt |= FVIRTKEY; \n        accelerator.key = TextToVirtualKey(acceleratorText); \n      } \n\n```", "```cpp\n      assert(accelerator.fVirt != 0); \n\n```", "```cpp\n      acceleratorSet.push_back(accelerator); \n    } \n\n```", "```cpp\n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class StandardDocument : public Document { \n    public: \n\n```", "```cpp\n      StandardDocument(CoordinateSystem system, Size pageSize, \n                       String fileDescriptionsText, \n                       Window* parentPtr=nullptr, \n                       WindowStyle style = OverlappedWindow, \n                       WindowShow windowShow = Normal, \n                       initializer_list<unsigned int> \n                         copyFormatList = {}, \n                       initializer_list<unsigned int> \n                         pasteFormatList = {}, \n                       bool acceptDropFiles = true, \n                       Size lineSize = LineSize); \n\n    private: \n      void InitializeFileFilter(String fileDescription); \n\n```", "```cpp\n    protected: \n      Menu StandardFileMenu(bool print); \n      Menu StandardEditMenu(); \n      Menu StandardHelpMenu(); \n\n```", "```cpp\n    private: \n      DEFINE_VOID_LISTENER(StandardDocument, OnNew); \n      DEFINE_VOID_LISTENER(StandardDocument, OnOpen); \n      DEFINE_BOOL_LISTENER(StandardDocument, SaveEnable); \n      DEFINE_VOID_LISTENER(StandardDocument, OnSave); \n      DEFINE_VOID_LISTENER(StandardDocument, OnSaveAs); \n\n```", "```cpp\n   private: \n      void SaveFileWithName(String name); \n      void SaveFileWithoutName(); \n\n```", "```cpp\n    protected: \n      void ClearPageSetupInfo(); \n      bool ReadPageSetupInfoFromStream(istream &inStream); \n      bool WritePageSetupInfoToStream(ostream &outStream) const; \n\n      virtual void ClearDocument() {/* Empty. */} \n      virtual bool WriteDocumentToStream(String name, \n                        ostream& outStream) const {return true;} \n      virtual bool ReadDocumentFromStream(String name, \n                       istream& inStream) {return true;} \n\n```", "```cpp\n      DEFINE_VOID_LISTENER(StandardDocument, OnCut); \n      DEFINE_VOID_LISTENER(StandardDocument, OnCopy); \n      DEFINE_VOID_LISTENER(StandardDocument, OnPaste); \n      DEFINE_VOID_LISTENER(StandardDocument, OnDelete); \n\n```", "```cpp\n      DEFINE_BOOL_LISTENER(StandardDocument, CutEnable); \n      DEFINE_BOOL_LISTENER(StandardDocument, CopyEnable); \n      DEFINE_BOOL_LISTENER(StandardDocument, PasteEnable); \n      DEFINE_BOOL_LISTENER(StandardDocument, DeleteEnable); \n\n```", "```cpp\n      virtual bool IsCopyAsciiReady() const {return false;} \n      virtual bool IsCopyUnicodeReady() const {return false;} \n      virtual bool IsCopyGenericReady(int format) \n                                      const {return false;} \n\n```", "```cpp\n      virtual void CopyAscii(vector<String>& textList) const \n                            {/* Empty. */} \n      virtual void CopyUnicode(vector<String>& textList) const \n                              {/* Empty. */} \n      virtual void CopyGeneric(int format, InfoList& infoList) \n                               const {/* Empty. */} \n\n```", "```cpp\n      virtual bool IsPasteAsciiReady \n              (const vector<String>&textList) const {return true;} \n      virtual bool IsPasteUnicodeReady \n              (const vector<String>&textList) const {return true;} \n      virtual bool IsPasteGenericReady(int format, \n                        InfoList& infoList) const {return true;} \n\n```", "```cpp\n      virtual void PasteAscii(const vector<String>& textList) \n                             {/* Empty. */} \n      virtual void PasteUnicode(const vector<String>& textList) \n                               {/* Empty. */} \n      virtual void PasteGeneric(int format, InfoList& infoList) \n                               {/* Empty. */} \n\n```", "```cpp\n      void OnDropFile(vector<String> pathList); \n\n```", "```cpp\n    private: \n      Size PageOuterSize() const; \n      Size PageInnerSize() const; \n\n    protected: \n      int PageInnerWidth() const{return PageInnerSize().Width();} \n      int PageInnerHeight()const{return PageInnerSize().Height();} \n\n```", "```cpp\n    public: \n      DEFINE_VOID_LISTENER(StandardDocument, OnPageSetup); \n      DEFINE_VOID_LISTENER(StandardDocument, OnPrintPreview); \n      DEFINE_VOID_LISTENER(StandardDocument, OnPrintItem); \n\n```", "```cpp\n      bool PrintPage(Graphics* graphicsPtr, int page, \n                     int copy, int totalPages); \n\n```", "```cpp\n      virtual void OnPageSetup(PageSetupInfo info) {/* Empty. */} \n\n```", "```cpp\n      virtual int GetTotalPages() const {return 1;} \n\n```", "```cpp\n      virtual void OnPrint(Graphics& graphics, int page, \n                           int copy, int totalPages) const; \n\n```", "```cpp\n      DEFINE_VOID_LISTENER(StandardDocument, OnExit); \n      virtual bool TryClose(); \n\n```", "```cpp\n      DEFINE_VOID_LISTENER(StandardDocument, OnAbout); \n\n```", "```cpp\n    private: \n      TCHAR fileFilter[MAX_PATH]; \n      vector<String> fileSuffixList; \n\n```", "```cpp\n      PageSetupInfo pageSetupInfo; \n\n```", "```cpp\n      list<unsigned int> copyFormatList, pasteFormatList; \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\"\n\n```", "```cpp\nnamespace SmallWindows { \n  StandardDocument::StandardDocument(CoordinateSystem system, \n                        Size pageSize, \n                        String fileDescriptionsText, \n                        Window* parentPtr /* = nullptr */, \n                        WindowStyle style/* = OverlappedWindow */, \n                        WindowShow windowShow /* = Normal */, \n                        initializer_list<unsigned int> \n                          copyFormatList /* = {} */, \n                        initializer_list<unsigned int> \n                          pasteFormatList /* = {}*/, \n                        bool acceptDropFiles /* = true */, \n                        Size lineSize /* = LineSize */) \n   :Document(TEXT(\"standarddocument\"), system, pageSize, \n             parentPtr, style, windowShow, \n             acceptDropFiles, lineSize), \n    copyFormatList(copyFormatList), \n    pasteFormatList(pasteFormatList) { \n    InitializeFileFilter(fileDescriptionsText); \n\n```", "```cpp\n    SetHorizontalScrollTotalWidth(PageInnerWidth()); \n    SetVerticalScrollTotalHeight(PageInnerHeight()); \n  } \n\n```", "```cpp\n  void StandardDocument::InitializeFileFilter(String fileListText) \n  { OStringStream filterStream; \n    vector<String> fileList = Split(fileListText, TEXT('';'')); \n    assert(fileList.size() > 0); \n\n    for (String fileText : fileList) { \n      vector<String> partList = Split(fileText, TEXT('','')); \n      assert(partList.size() == 2); \n      String description = Trim(partList[0]), \n             suffix = Trim(partList[1]); \n      fileSuffixList.push_back(suffix); \n      filterStream << description << TEXT(\" (*.\") << suffix \n                   << TEXT(\")\\n\") << TEXT(\"*.\") << suffix \n                   << TEXT(\"\\n\"); \n    } \n\n    filterStream << TEXT(\"\\n\"); \n\n    int index = 0; \n    for (TCHAR c : filterStream.str()) { \n      fileFilter[index++] = (c == TEXT(''\\n'')) ? TEXT(''\\0'') : c; \n    } \n  } \n\n```", "```cpp\n  Menu StandardDocument::StandardFileMenu(bool print) { \n    Menu fileMenu(this, TEXT(\"&File\")); \n    fileMenu.AddItem(TEXT(\"&New\\tCtrl+N\"), OnNew); \n    fileMenu.AddItem(TEXT(\"&Open\\tCtrl+O\"), OnOpen); \n    fileMenu.AddItem(TEXT(\"&Save\\tCtrl+S\"), OnSave, SaveEnable); \n    fileMenu.AddItem(TEXT(\"Save &As\\tCtrl+Shift+S\"), OnSaveAs); \n\n    if (print) { \n      fileMenu.AddSeparator(); \n      fileMenu.AddItem(TEXT(\"Page Set&up\"), OnPageSetup); \n      fileMenu.AddItem(TEXT(\"Print Pre&view\"), OnPrintPreview); \n      fileMenu.AddItem(TEXT(\"&Print\\tCtrl+P\"), OnPrintItem); \n    } \n\n    fileMenu.AddSeparator(); \n    fileMenu.AddItem(TEXT(\"E&xit\\tAlt+X\"), OnExit); \n    return fileMenu; \n  } \n\n```", "```cpp\n  Menu StandardDocument::StandardEditMenu() { \n    Menu editMenu(this, TEXT(\"&Edit\")); \n    editMenu.AddItem(TEXT(\"C&ut\\tCtrl+X\"), OnCut, CutEnable); \n    editMenu.AddItem(TEXT(\"&Copy\\tCtrl+C\"), OnCopy, CopyEnable); \n    editMenu.AddItem(TEXT(\"&Paste\\tCtrl+V\"), OnPaste,PasteEnable); \n    editMenu.AddSeparator(); \n    editMenu.AddItem(TEXT(\"&Delete\\tDelete\"), \n                     OnDelete, DeleteEnable); \n    return editMenu; \n  } \n\n```", "```cpp\n  Menu StandardDocument::StandardHelpMenu() { \n    Menu helpMenu(this, TEXT(\"&Help\")); \n    helpMenu.AddItem(TEXT(\"About \") + \n                     Application::ApplicationName() + \n                     TEXT(\" ...\"), OnAbout); \n    return helpMenu; \n  } \n\n```", "```cpp\n  bool StandardDocument::TryClose() { \n    if (IsDirty()) { \n      switch (MessageBox(TEXT(\"Do you want to save?\"), \n                         TEXT(\"Unsaved Document\"), YesNoCancel)) { \n        case Yes: \n          OnSave(); \n          return !IsDirty(); \n\n        case No: \n          return true; \n\n        case Cancel: \n          return false; \n      } \n    } \n\n    return true; \n  } \n\n```", "```cpp\n  void StandardDocument::OnExit() { \n    if (TryClose()) { \n      delete Application::MainWindowPtr(); \n    } \n  } \n\n```", "```cpp\n  void StandardDocument::OnNew() { \n    if (TryClose()) { \n      ClearDocument(); \n      ClearPageSetupInfo(); \n      SetZoom(1.0); \n      SetDirty(false); \n      SetName(TEXT(\"\")); \n      Invalidate(); \n      UpdateWindow(); \n      UpdateCaret(); \n    } \n  } \n\n```", "```cpp\n  void StandardDocument::OnOpen() { \n    if (TryClose()) { \n      String name = GetName(); \n\n      if (StandardDialog::OpenDialog(this, name, fileFilter, \n                                     fileSuffixList)) { \n        ClearDocument(); \n        Invalidate(); \n        UpdateWindow(); \n        ifstream inStream(name.c_str()); \n\n        if (inStream && ReadDocumentFromStream(name, inStream)) { \n          SetName(name); \n        } \n\n        else { \n          MessageBox(TEXT(\"Could not open \") + \n                     name + TEXT(\".\")); \n        } \n      } \n    } \n\n    SetDirty(false); \n    SetZoom(1.0); \n    Invalidate(); \n    UpdateWindow(); \n    UpdateCaret(); \n  } \n\n```", "```cpp\n  bool StandardDocument::SaveEnable() const { \n    return IsDirty(); \n  } \n\n```", "```cpp\n  void StandardDocument::OnSave() { \n    String name = GetName(); \n\n    if (!name.empty()) { \n      SaveFileWithName(name); \n    } \n    else { \n      SaveFileWithoutName(); \n    } \n  } \n\n```", "```cpp\n  void StandardDocument::OnSaveAs() { \n    SaveFileWithoutName(); \n  } \n\n```", "```cpp\n  void StandardDocument::SaveFileWithoutName() { \n    String name = GetName(); \n\n    if (StandardDialog::SaveDialog(this, name, fileFilter, \n                                   fileSuffixList)) { \n      SaveFileWithName(name); \n    } \n  } \n\n```", "```cpp\n  void StandardDocument::SaveFileWithName(String name) { \n    ofstream outStream(name.c_str()); \n\n    if (outStream && WriteDocumentToStream(name, outStream)) { \n      SetName(name); \n      SetDirty(false); \n      SetZoom(1.0); \n    } \n  } \n\n  void StandardDocument::ClearPageSetupInfo() { \n    pageSetupInfo.ClearPageSetupInfo(); \n  } \n\n  bool StandardDocument::ReadPageSetupInfoFromStream \n                         (istream &inStream) { \n    pageSetupInfo.ReadPageSetupInfoFromStream(inStream); \n    return ((bool) inStream); \n  } \n\n  bool StandardDocument::WritePageSetupInfoToStream \n                         (ostream &outStream) const { \n    pageSetupInfo.WritePageSetupInfoToStream(outStream); \n    return ((bool) outStream); \n  } \n\n```", "```cpp\n  void StandardDocument::OnAbout() { \n    String applicationName = Application::ApplicationName(); \n    MessageBox(applicationName + TEXT(\", version 1.0\"), \n               applicationName, Ok, Information); \n  } \n\n```", "```cpp\n  bool StandardDocument::CutEnable() const { \n    return CopyEnable(); \n  } \n\n  bool StandardDocument::DeleteEnable() const { \n    return CopyEnable(); \n  } \n\n```", "```cpp\n  void StandardDocument::OnCut() { \n    OnCopy(); \n    OnDelete(); \n  } \n\n```", "```cpp\n  void StandardDocument::OnDelete() { \n    // Empty. \n  } \n\n```", "```cpp\n  bool StandardDocument::CopyEnable() const { \n    for (unsigned int format : pasteFormatList) { \n      switch (format) { \n        case AsciiFormat: \n          if (IsCopyAsciiReady()) { \n            return true; \n          } \n          break; \n\n        case UnicodeFormat: \n          if (IsCopyUnicodeReady()) { \n            return true; \n          } \n          break; \n\n        default: \n          if (IsCopyGenericReady(format)) { \n            return true; \n          } \n          break; \n      } \n    }  \n    return false; \n  } \n\n```", "```cpp\n  void StandardDocument::OnCopy() { \n    if (Clipboard::Open(this)) { \n      Clipboard::Clear();  \n      for (unsigned int format : copyFormatList) { \n        switch (format) { \n\n```", "```cpp\n          case AsciiFormat:  \n            if (IsCopyAsciiReady()) { \n              vector<String> asciiList; \n              CopyAscii(asciiList); \n              Clipboard::WriteText<AsciiFormat,char>(asciiList); \n            } \n            break; \n\n```", "```cpp\n          case UnicodeFormat: \n            if (IsCopyUnicodeReady()) { \n              vector<String> unicodeList; \n              CopyUnicode(unicodeList); \n              Clipboard::WriteText<UnicodeFormat,wchar_t> \n                                  (unicodeList); \n            } \n            break; \n\n```", "```cpp\n          default: \n            if (IsCopyGenericReady(format)) { \n              InfoList infoList; \n              CopyGeneric(format, infoList); \n              Clipboard::WriteGeneric(format, infoList); \n            } \n            break; \n        } \n      }  \n      Clipboard::Close(); \n    } \n  } \n\n```", "```cpp\n  bool StandardDocument::PasteEnable() const { \n    if (Clipboard::Open(this)) { \n      for (unsigned int format : pasteFormatList) { \n        if (Clipboard::Available(format)) { \n          switch (format) { \n            case AsciiFormat: { \n                vector<String> asciiList; \n                if (Clipboard::ReadText<AsciiFormat,char> \n                                       (asciiList) && \n                    IsPasteAsciiReady(asciiList)) { \n                  Clipboard::Close(); \n                  return true; \n                } \n              } \n              break;  \n            case UnicodeFormat: { \n                vector<String> unicodeList; \n                if (Clipboard::ReadText<UnicodeFormat,wchar_t> \n                                       (unicodeList) && \n                    IsPasteUnicodeReady(unicodeList)) { \n                  Clipboard::Close(); \n                  return true; \n                } \n              } \n              break;  \n            default: { \n                InfoList infoList; \n                if (Clipboard::ReadGeneric(format, infoList) && \n                    IsPasteGenericReady(format, infoList)) { \n                  Clipboard::Close(); \n                  return true; \n                } \n              } \n          } \n        } \n      } \n\n      Clipboard::Close(); \n    } \n\n    return false; \n  } \n\n```", "```cpp\n  void StandardDocument::OnPaste() { \n    if (Clipboard::Open(this)) { \n      for (unsigned int format : pasteFormatList) { \n        bool quit = false;  \n        if (Clipboard::Available(format)) { \n          switch (format) { \n\n```", "```cpp\n            case AsciiFormat: { \n                vector<String> asciiList; \n                if (Clipboard::ReadText<AsciiFormat,char> \n                               (asciiList) && \n                    IsPasteAsciiReady(asciiList)) { \n                  PasteAscii(asciiList); \n                  quit = true; \n                } \n              } \n              break; \n\n```", "```cpp\n            case UnicodeFormat: { \n                vector<String> unicodeList; \n                if (Clipboard::ReadText<UnicodeFormat,wchar_t> \n                                     (unicodeList) && \n                    IsPasteUnicodeReady(unicodeList)) { \n                  PasteUnicode(unicodeList); \n                  quit = true; \n                } \n              } \n              break; \n\n```", "```cpp\n            default: { \n                InfoList infoList; \n                if (Clipboard::ReadGeneric(format, infoList) && \n                    IsPasteGenericReady(format, infoList)) { \n                  PasteGeneric(format, infoList); \n                  quit = true; \n                } \n              } \n              break; \n          }  \n          if (quit) { \n            break; \n          } \n        } \n      }  \n      Clipboard::Close(); \n    } \n  } \n\n```", "```cpp\n  void StandardDocument::OnDropFile(vector<String> pathList) { \n    set<String> pathSet; \n\n```", "```cpp\n    for (String path : pathList) { \n      for (String suffix : fileSuffixList) { \n        if (EndsWith(path, TEXT(\".\") + suffix)) { \n          pathSet.insert(path); \n          break; \n        } \n      } \n    } \n\n```", "```cpp\n    if (pathSet.empty()) { \n      MessageBox(TEXT(\"No suitable dropped file.\"), \n                 TEXT(\"Drop File\"), Ok, Stop); \n    } \n\n```", "```cpp\n    else if (pathSet.size() > 1) { \n      MessageBox(TEXT(\"To many suitable dropped files.\"), \n                 TEXT(\"Drop File\"), Ok, Stop); \n    } \n\n```", "```cpp\n    else { \n      String path = *pathSet.begin(); \n\n      if (TryClose()) { \n        ClearDocument(); \n        ReadDocumentFromStream(path, ifstream(path)); \n        SetName(path); \n        SetDirty(false); \n        SetZoom(1.0); \n        Invalidate(); \n        UpdateWindow(); \n        UpdateCaret(); \n      } \n    } \n  } \n\n```", "```cpp\n  Size StandardDocument::PageOuterSize() const { \n    if (pageSetupInfo.GetOrientation() == Landscape) { \n      return Size(pageSize.Height(), pageSize.Width()); \n    } \n\n    return pageSize; \n  } \n\n```", "```cpp\n  Size StandardDocument::PageInnerSize() const { \n    Size outerSize = PageOuterSize(); \n\n    int innerWidth = outerSize.Width() - \n                     (100 * (pageSetupInfo.LeftMargin() + \n                     pageSetupInfo.RightMargin())), \n        innerHeight = outerSize.Height() - \n                      (100 * (pageSetupInfo.TopMargin() + \n                      pageSetupInfo.BottomMargin())); \n\n    return Size(innerWidth, innerHeight); \n  } \n\n```", "```cpp\n  int StandardDocument::PageInnerWidth() const { \n    return PageOuterSize().Width() - \n           (100 * (pageSetupInfo.LeftMargin() + \n                   pageSetupInfo.RightMargin())); \n  } \n\n  int StandardDocument::PageInnerHeight() const { \n    return PageOuterSize().Height() - \n           (100 * (pageSetupInfo.TopMargin() + \n                   pageSetupInfo.BottomMargin())); \n  } \n\n```", "```cpp\n  void StandardDocument::OnPageSetup() { \n    PageSetupDialog pageSetupDialog(this, &pageSetupInfo); \n\n    if (pageSetupDialog.DoModal()) { \n      OnPageSetup(pageSetupInfo); \n    } \n  } \n\n```", "```cpp\n  void StandardDocument::OnPrintPreview() { \n    new PrintPreviewDocument(this, GetTotalPages()); \n  } \n\n```", "```cpp\nvoid StandardDocument::OnPrintItem() { \n    int totalPages = GetTotalPages(), firstPage, lastPage, copies; \n    bool sorted; \n\n```", "```cpp\n    Graphics* graphicsPtr = \n      StandardDialog::PrintDialog(this, totalPages, firstPage, \n                                  lastPage, copies, sorted); \n\n```", "```cpp\n    if (graphicsPtr != nullptr) { \n      static DOCINFO docInfo; \n      docInfo.cbSize = sizeof docInfo; \n      docInfo.lpszDocName = GetName().c_str(); \n\n      if (::StartDoc(graphicsPtr->GetDeviceContextHandle(), \n                     &docInfo) > 0) { \n        PrepareDeviceContext \n          (graphicsPtr->GetDeviceContextHandle()); \n        EnableWindow(false); \n\n```", "```cpp\n        if (sorted) { \n          bool printOk = true; \n          for (int copy = 1; (copy <= copies) && printOk; ++copy){ \n            for (int page = firstPage; \n                 (page <= lastPage) && printOk; ++page){ \n              printOk = PrintPage(graphicsPtr, page, \n                                  copy, totalPages); \n            } \n          } \n        } \n        else { \n          bool printOk = true; \n          for (int page = firstPage; \n               (page <= lastPage) && printOk; ++page) { \n            for (int copy = 1; (copy <= copies) && printOk; \n                 ++copy) { \n              printOk = PrintPage(graphicsPtr, page, \n                                  copy, totalPages); \n            } \n          } \n        } \n\n```", "```cpp\n        ::EndDoc(graphicsPtr->GetDeviceContextHandle()); \n      } \n    } \n  } \n\n```", "```cpp\n  bool StandardDocument::PrintPage(Graphics* graphicsPtr, \n                              int page, int copy, int totalPages){ \n    if (::StartPage(graphicsPtr->GetDeviceContextHandle()) > 0) { \n      OnPrint(*graphicsPtr, page, copy, totalPages); \n      return (::EndPage(graphicsPtr->GetDeviceContextHandle())>0); \n    } \n\n    return false; \n  } \n\n```", "```cpp\n  void StandardDocument::OnPrint(Graphics& graphics, int page, \n                                 int copy, int totalPages) const { \n\n```", "```cpp\n    graphics.FillRectangle(Rect(0, 0, PageOuterSize().Width(), \n                      PageOuterSize().Height()), White, White); \n\n    int left = 100 * pageSetupInfo.LeftMargin(), \n        top = 100 * pageSetupInfo.TopMargin(); \n    int right = left + PageInnerWidth(), \n                bottom = top + PageInnerHeight(); \n\n```", "```cpp\n    if (!pageSetupInfo.HeaderText().empty() && \n        !((page == 1) && (!pageSetupInfo.HeaderFirst()))) { \n      Rect headerRect(left, 0, right, top); \n      String headerText = \n        Template(this, pageSetupInfo.HeaderText(), \n                 copy, page, totalPages); \n      Color textColor = pageSetupInfo.HeaderFont().FontColor(); \n      Color backColor = textColor.Inverse(); \n      graphics.DrawText(headerRect, headerText, \n               pageSetupInfo.HeaderFont(), textColor, backColor); \n    } \n\n```", "```cpp\n    if (!pageSetupInfo.FooterText().empty() && \n        !((page == 1) && (!pageSetupInfo.HeaderFirst()))) { \n      Rect footerRect(left, bottom, right, \n                      PageOuterSize().Height()); \n      String footerText = \n        Template(this, pageSetupInfo.FooterText(), \n                 copy, page, totalPages); \n      Color textColor = pageSetupInfo.FooterFont().FontColor(); \n      Color backColor = textColor.Inverse(); \n      graphics.DrawText(footerRect, footerText, \n               pageSetupInfo.FooterFont(), textColor, backColor); \n    } \n\n```", "```cpp\n    int save = graphics.Save(); \n    Point centerPoint(-left, \n                      ((page - 1) * PageInnerHeight()) - top); \n    graphics.SetOrigin(centerPoint); \n    Rect clipRect(0, (page - 1) * PageInnerHeight(), \n                  PageInnerWidth(), page * PageInnerHeight()); \n    graphics.IntersectClip(clipRect); \n    OnDraw(graphics, Print); \n    graphics.Restore(save); \n\n```", "```cpp\n    if (pageSetupInfo.Frame()) { \n      graphics.DrawRectangle(Rect(left, top, right, bottom), \n                             Black); \n    } \n  } \n}; \n\n```"]