- en: Remotely Controlling the Arduino
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I was a kid, my parents used to use both myself and my sister as the remote
    control for the television sets because back then, television sets did not come
    with remote controls. Fortunately, Eugene Polley, an engineer at *Zenith,* came
    up with the idea to control television with remote controls, saving millions of
    kids from having to change the channels for their parents. The remote control
    greatly enhanced how we interacted with the television set and can do the same
    for your Arduino project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to connect a radio frequency remote control to an Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to determine what button is pressed on a radio frequency remote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to connect an infrared remote control to an Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to determine what button is pressed on an infrared remote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at a couple of ways that we can control our Arduino
    project remotely. For the first project, we will use the Keyestudio IR (infrared)
    receiver, which uses the **HX1838 infrared control module**. The HX1838 infrared
    control module is used in numerous IR receivers that can be used by the Arduino.
    Therefore, you do not need to specifically get the Keyestudio one that we use
    here.
  prefs: []
  type: TYPE_NORMAL
- en: An infrared transmitter has an LED that emits infrared radiation, which is picked
    up by the infrared receiver. When a button is pressed on the remote control, the
    LED on the transmitter will blink very quickly for a fraction of a second and
    the receiver will read the pattern of blinks and interpret it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Keyestudio IR receiver that we will be using in this chapter looks like
    the following photograph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec2f13b3-b1b8-4766-841a-5726474390ca.png)'
  prefs: []
  type: TYPE_IMG
- en: The pin marked with the **S** is the signal pin and should be connected to one
    of the digital pins on the Arduino. The pin marked with the **+** sign should
    be connected to 5V and the pin with the **-** sign should be connected to ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the really nice things about using an IR receiver as the remote control
    for your project is you can use pretty much any IR remote controller as the transmitter.
    For example, I can use this remote that came with one of my IR receivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e25082b0-b686-4861-b5aa-30475d73eb5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Or I could use any of my spare TV remotes that use infrared such as the one
    shown in the following photograph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/594144fe-8f46-45d1-adad-cfe298a65fb3.png)'
  prefs: []
  type: TYPE_IMG
- en: Some remotes, however, do not use infrared technologies such as the Apple TV
    remote, which uses Bluetooth 4.0\. Therefore, they cannot be used with the infrared
    receiver.
  prefs: []
  type: TYPE_NORMAL
- en: Infrared remotes do have a couple drawbacks, the biggest being that they must
    have a line of sight to communicate with the receiver. What this means is the
    transmitter must be pointed directly at the receiver; otherwise, the receiver
    will not be able to read the transmission. Another drawback with infrared remotes
    is they are only really useful up to 30 feet (10 meters).
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than using an infrared transmitter/receiver we could use a **radio frequency**
    (**RF**) transmitter and receiver. In this chapter, we will look at how to use
    a basic four-button keyfob RF transmitter and a receiver like the ones shown in
    the following photograph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bb52204-6b5c-4759-b54f-60dd9094c3dd.png)'
  prefs: []
  type: TYPE_IMG
- en: The two biggest advantages of using an RF transmitter and receiver is that the
    RF signal can travel further, and they can go through normal walls, which means
    it does not need line of sight. Unlike the infrared receiver, which can work with
    almost any infrared transmitter, if the RF transmitter and receiver are not designed
    to work together, and are set to the same frequencies, they will not be able to
    communicate. RF transmitters such as the one shown in the preceding photograph,
    also have far fewer buttons than infrared remotes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the parts we will need for these projects.
  prefs: []
  type: TYPE_NORMAL
- en: Components needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For these projects, you will need the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: One Arduino Uno or compatible board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One infrared receiver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more infrared transmitter(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One RF transmitter and receiver pair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows how we connect the infrared receiver to the Arduino:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b08245c-4b46-46a2-a3d7-21401cbe397a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The 5V in and the ground pins on the IR receiver are connected to the appropriate
    rails on the breadboard. The signal pin is connected to the digital 2 pin on the
    Arduino. Now let''s look at how we would connect the radio frequency receiver
    to the Arduino:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51ede3ee-b019-421a-aa23-02a6f7b7c01c.png)'
  prefs: []
  type: TYPE_IMG
- en: The 5V in and the ground pins on the RF receiver are connected to the appropriate
    rails on the breadboard. The four output pins on the receiver are connected to
    the 8, 9, 10 and 11 digital pins on the Arduino. When a button is pressed on the
    transmitter, the corresponding output pin on the receiver goes to HIGH.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the code for our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start writing the code that will read the input from the infrared
    receiver, we will need to load the **IRremote library** by shirriff. The following
    screenshot shows the library and version that we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17076f8f-2192-4001-b420-e0fd5d161352.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the library is loaded, we will need to start by importing the header file
    for the IRremote library and creating the global variables and directives. The
    following code shows how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we start off by including the `IRremote.h` header file
    into our project. We then define that the infrared receiver is connected to pin
    2 on the Arduino. Next, we create an instance of the `IRrecv` type, which is used
    to read the input from the IR receiver. Finally, we create an instance of the
    `decode_results` type, which is used to store the values from the IR receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will need to add the initialization code to the `setup()` function.
    The following codes shows the `setup()` function for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we start off by initializing the serial monitor so we can print
    out the results. We then call the `enableIRIn()` function from the `IRrecv` type
    instance, which will prepare the Arduino to read the input from the IR receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `loop()` function, we look for input from the IR receiver and print
    out the codes for the buttons pressed on the remote. The following code shows
    what the `loop()` function will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the `loop()` function, we use the `decode()` function, passing in the instance
    of the `decode_results` type, to read the code of the button that was pressed.
    Once a code has been received, the `Serial.println()` function is used to print
    out the code to the serial console. We delay the execution of the application
    for 100 milliseconds to give the user a chance to release the button before a
    repeat code is sent. Finally, the `resume()` function is called to begin listening
    for results again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of the code should look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da5fca3d-1494-43a2-ab59-57edb885a5a8.png)'
  prefs: []
  type: TYPE_IMG
- en: The Car mp3 remote, shown earlier in this chapter, was used to get the results
    shown in the preceding screenshot.  `FF30CF` is the code for button number 1,
    the `FF18E7` code is the number 2 button, and the `ff7A85` code is the number
    3 button. The `FFFFFFFF` results mean that the button is being held down; therefore,
    the last valid code should be used again.
  prefs: []
  type: TYPE_NORMAL
- en: You will probably want to save this project somewhere because it is very useful
    for getting valid codes for buttons on your remotes. Once you have the codes,
    you can then use the IRremote library in your other projects and perform whatever
    activities are needed depending on the codes returned from the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: The RF receiver is a little easier to read because we do not need an external
    library to read it because there is one pin per button on the transmitter. When
    a user presses the button, the corresponding pin on the receiver will be pulled
    HIGH.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start the RF code by defining what pins on the Arduino are connected
    to the pins on the RF receiver. If you connected the RF receiver as shown in the
    Fritzing diagram, the buttons would be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to set up these pins for input within the `setup()` function and
    also initialize the serial monitor. The following code shows the `setup()` function
    for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `loop()` function, we need to read each of the pins, check whether it
    is HIGH, and if so, perform what function is needed within your project. For this
    project, we simply print out that the pin was pressed. The following shows the
    `loop()` function for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When this code is run, you will be able to see which buttons were pressed within
    the serial monitor. Adding a remote control to your project may seem like simply
    a *nice to have;* however, it can really enhance the usability of your project
    and also save you from constantly getting up to interact with it. Now let's look
    at our challenge for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw two types of remote control devices. The first was the
    IR control, which needs a line of sight to the project and can have a lot of different
    buttons. The radio frequency remote is good when the remote needs to work over
    greater distances from the device or even in a different room.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous other ways to create remote controls using wireless signals, such
    as **Zigbee** radios or even Wi-Fi; however, for this challenge, we want you to
    think outside the box and to begin to expand your own horizons. The challenge
    for this chapter is to think of ways to remotely control your device without using
    a wireless signal.
  prefs: []
  type: TYPE_NORMAL
- en: You may be shaking your head right now wondering what we mean by remotely controlling
    a project without using a wireless signal. One example of this would be the clapper.
    The clapper is a sound-activated electrical switch. You clap once, and the switch
    will turn on, you clap again, and the switch will turn off. Another example is
    a motion sensor that controls your outside lights. If the motion sensor detects
    motion, it will turn on the light. Now try to think outside the box and come up
    with other ways that you can control your device without using a wireless signal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to use an IR remote and an RF remote with an Arduino.
    You were also challenged to think outside of the box and think of other ways that
    you could remotely control your project without using a wireless signal. The reason
    this challenge was in this last project chapter was to get you to start thinking
    outside of the box when designing your projects because thinking outside of the
    box and creating new and improved ways to do something is what gets people excited
    about these types of projects. It can also make you a lot of money if you are
    able to monopolize your project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about how you can use the knowledge you gained
    from previous project chapters to create a simple robot. We will not be writing
    the code or designing the circuits for you. Instead we will show you how to put
    the pieces you have learned in the book together, so you can design your own robot
    or create other projects.
  prefs: []
  type: TYPE_NORMAL
