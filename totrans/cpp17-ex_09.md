# 领域特定语言

在前面的章节中，我们使用Qt库开发了Othello和井字棋游戏。在本章中，我们将开始开发一个**领域特定语言（DSL**），这是一种针对特定领域的语言。更具体地说，我们将开发一种用于在Qt小部件中编写图形对象的语言。该语言允许我们绘制线条、矩形、椭圆，并写入文本。此外，它还允许我们为图形对象选择颜色以及笔和画笔样式。它还允许我们为文本选择字体和对齐方式。

本章我们将涵盖的主题包括：

+   首先，我们将通过查看一个示例来非正式地研究我们的领域特定语言（DSL）的源代码。我们将绘制图形对象并设置它们的颜色、样式和字体。

+   我们将使用语法正式定义我们的语言。

+   当我们定义了语法后，我们编写扫描器。扫描器读取源代码并识别有意义的字符序列，称为**标记**。

+   当我们编写了扫描器后，我们编写解析器。解析器可以被认为是我们的领域特定语言（DSL）的核心。当需要时，它会从扫描器请求新的标记。它检查源代码是否符合语法，并生成一系列动作。每个动作都包含一个指令，例如设置颜色或绘制线条。

+   最后，我们编写一个查看器，该查看器读取解析器生成的动作序列，并在Qt小部件中显示图形对象。

# 介绍源语言——一个简单的例子

我们的领域特定语言（DSL）的源语言由一系列指令组成。有用于绘制图形对象的指令，如线条、矩形、椭圆和文本。我们还有设置对象颜色和样式以及文本字体和对齐方式的指令。最后，还有为名称分配值的指令。

让我们来看一个例子。以下代码绘制了一个矩形并写入了文本。请注意，该语言不区分大小写，也就是说，我们代码中使用小写或大写字母无关紧要。我们首先定义矩形的左上角：

[PRE0]

我们使用坐标运算符来提取左上点的*x*和*y*坐标，并定义右下角：

[PRE1]

我们使用预定义的值`DashLine`和`CrossPatterns`来设置笔和画笔的样式：

[PRE2]

我们使用预定义的颜色`Black`作为笔的颜色，并为画笔创建自己的颜色`Purple`。我们可以使用三个值来创建一个新颜色，这三个值分别对应它们的红色、绿色和蓝色分量。每个分量可以持有介于0到255之间的值，包括：

[PRE3]

我们继续添加文本，包括字体和对齐方式。我们选择`12`点的`Times New Roman`字体，左对齐水平方向和顶对齐垂直方向：

[PRE4]

此示例中的指令将由扫描器分成有意义的部分；解析器将检查指令是否符合语法，并生成一系列由观众读取的动作，并显示以下 Qt 小部件：

![](img/30203c62-df0f-49a5-9e2a-e676d1dafdbf.png)

# 源语言的语法

我们需要精确地定义我们的领域特定语言（DSL）的源语言。我们通过定义语言的语法来实现这一点。语法由规则（以 *斜体* 风格呈现）、关键字（以 **粗体* 风格呈现）、分隔符和标点符号组成。

`program` 规则是起始规则。箭头 (`->`) 表示程序由指令列表组成。箭头可以读作：

[PRE5]

在语法中，星号 (`*`) 表示 **零个或多个**。因此，指令列表由零个或多个指令组成：

[PRE6]

赋值指令包含一个名称后跟赋值运算符 (`=`)，一个表达式和一个分号。设置笔和画笔颜色和样式的指令以及字体和对齐的设置都只需要一个表达式。绘制线条、矩形和文本的指令需要两个表达式。请注意，每个指令都以分号 (`;`) 结尾。

竖线 (`|`) 可以读作 **或**。指令是一个赋值或设置笔色、设置画笔色等：

[PRE7]

下一步要定义的是表达式。首先，我们查看表达式的运算符。我们还需要考虑运算符的优先级。例如，乘法和除法的优先级高于加法和减法。语法中的运算符具有以下优先级：

| **表达式** | **运算符** | **优先级** |
| --- | --- | --- |
| 加减 | `+ -` | 最低 |
| 乘除 | `* /` |  |
| 基本表达式 | `point` `xCoordinate` `yCoordinate` `color` `font` `(expression)` `name` `value` | 最高 |

我们为加法和减法、乘法和除法各自定义了两条规则。我们首先从优先级最低的开始，即加法和减法。在 `expression` 规则中，我们调用 `mulDivExpression` 规则来处理乘除表达式，并调用 `expressionRest` 规则来检查表达式的其余部分：

[PRE8]

在 `expressionRest` 规则中，我们查看下一个标记。如果它是加号或减号，我们有一个加法或减法表达式。我们调用 `mulDivExpression` 来处理优先级更高的表达式。最后，如果还有另一个加号或减号，我们再次调用 `expressionRest` 规则。然而，如果第一个标记既不是加号也不是减号，我们就不做任何事情：

[PRE9]

`mulDivExpression` 和 `mulDivExpressionRest` 的工作方式与之前展示的 `expression` 和 `expressionRest` 相同：

[PRE10]

基本表达式是一个点，一个 *x* 或 *y* 坐标，一个颜色，一个字体，一个名字或一个值。一个点由两个表达式组成，分别持有点的 *x* 和 *y* 坐标。一个坐标接受一个包含点的表达式，并给它一个 *x* 或 *y* 坐标：

[PRE11]

颜色表达式由其红色、绿色和蓝色分量组成，而字体表达式由字体名称和大小组成：

[PRE12]

表达式可以用括号括起来以改变表达式的优先级。例如，在表达式 2 + 3 x 4 中，乘法比加法有更高的优先级，但在表达式 (2 + 3) x 4 中，加法比乘法有更高的优先级：

[PRE13]

最后，一个表达式可以是一个之前与值关联的名字，或者简单地是一个值：

[PRE14]

# 目标语言

目标语言由一系列动作定义。非正式地说，动作对应于语法的指令。我们有设置画笔或刷子的颜色或样式的动作，以及设置文本的水平或垂直对齐，以及实际绘制线条、矩形、椭圆和绘图文本的动作。在本章的后面，我们将编写一个生成一系列动作的解析器，以及一个读取动作并在 Qt 小部件中显示图形对象的查看器。

一个 `Action` 对象持有动作的标识符（由 `Token` 类中的 `TokenId` 枚举定义，如下所示）以及最多两个值。

**Action.h:** 

[PRE15]

`Action.cpp` 文件包含了 `Action` 类的方法定义。

**Action.cpp:** 

[PRE16]

构造函数接受动作标识符和最多两个值：

[PRE17]

# 颜色

当设置画笔或刷子的颜色时，我们需要提交带有指令的颜色。我们可以使用前面语法中的颜色规则来创建自己的颜色。然而，Qt 类 `QColor` 有一个预定义的颜色集。以下扫描器定义了一个预定义的 `QColor` 对象集（`Aqua`、`Black`、...）并将它们映射到它们的名称。例如，用户可以在源代码中编写以下指令：

[PRE18]

在那种情况下，由于名字 `Aqua` 与 `QColor` 对象 `Aqua` 相关联，画笔颜色被设置为 `Aqua`。

**Colors.h:** 

[PRE19]

`Colors.cpp` 文件包含了 `Colors.h` 文件中颜色的定义。

**Colors.cpp:** 

[PRE20]

每个颜色由其红色、绿色和蓝色分量定义。每个分量持有从 0 到 255 的值，包括 255。例如，`Blue` 颜色持有蓝色分量的最大值和其它分量的零值，而 `Yellow` 是红色和绿色的混合：

[PRE21]

# 错误处理

存在一些用于错误处理的函数：`check` 检查一个条件是否为真，如果不为真则报告错误。`syntaxError` 和 `semanticError` 函数报告语法和语义错误，而 `error` 抛出一个异常，该异常被 `main` 函数捕获并报告。

**Error.h:** 

[PRE22]

`Error.cpp` 文件包含了 `Error.h` 文件的定义。

**Error.cpp:** 

[PRE23]

我们使用C++的`stringstream`标准类来组合错误信息：

[PRE24]

`str`方法返回C++ `string`标准类的一个对象，而`c_str`返回一个字符指针，在`error`调用中转换为`QString`对象：

[PRE25]

当扫描器发现不构成标记的字符序列，或者当解析器检测到标记序列不符合语法时，会发生语法错误。我们将在不久的将来介绍这个主题；现在，只需记住扫描器也可以报告错误：

[PRE26]

当发现未知名称，或者当表达式的类型不匹配时，会发生语义错误：

[PRE27]

`check`方法与`assert`宏有类似的效果。它检查条件是否为真。如果不为真，则调用`semanticError`，最终抛出错误异常：

[PRE28]

# 值

语言中有几种类型的值，用于设置画笔或画刷的颜色或样式，或设置线的端点，或设置字体名称，或文本的对齐方式：数值（`double`）、字符串（`QString`）、颜色（`QColor`）、字体（`QFont`）、点（`QPoint`）、画笔样式（`Qt::PenStyle`）、画刷样式（`Qt`::`BrushStyle`）以及水平或垂直对齐（`Qt`::`AlignmentFlag`）。

**Value.h**：

[PRE29]

`Value.cpp`文件包含了`Value`类的定义方法。

**Value.cpp**：

[PRE30]

非默认构造函数使用适当的值初始化`Value`对象：

[PRE31]

# 扫描器

**扫描器**是应用程序的一部分，它接受源代码并生成一系列标记。**标记**是源代码中最小的有意义的部分。例如，字符**f**、**o**、**n**和**t**组成了关键字**font**，而字符**1**、**2**和**3**构成了数值**123**。

然而，首先我们需要`Token`类来跟踪标记。`m_tokenId`字段被设置为枚举`TokenId`的值。在名称的情况下，`m_name`字段包含名称，而在值的情况下，`m_value`字段包含值。

**Token.h**：

[PRE32]

`TokenId`枚举包含了扫描器的所有标记。它们被分为关键字、运算符、标点符号和分隔符，以及名称和值。为了避免在不同枚举之间进行转换，扫描器、解析器和查看器都使用`TokenId`枚举。`TokenId`枚举由扫描器在类型检查和评估表达式时区分不同的标记，由`Action`类区分不同的操作。

第一部分（从`ColorId`到`YCoordinateId`）是语言的关键字：

[PRE33]

第二部分（从`AddId`到`DivideId`）是运算符：

[PRE34]

下一个部分是括号、赋值（`=`）、逗号和分号：

[PRE35]

最后，最后一部分是名称、值和文件结束标记：

[PRE36]

每个标记都可以用名称或值进行标注：

[PRE37]

`Token.cpp` 文件包含 `Token` 类的方法定义。

**Token.cpp:**

[PRE38]

默认标记使用文件结束标记初始化：

[PRE39]

大多数标记只包含 `TokenId` 枚举的值：

[PRE40]

标记也可以包含名称或值：

[PRE41]

`Scanner` 类接收源代码并将其划分为标记。标记也可以通过名称或值关联。

**Scanner.h:**

[PRE42]

`init` 方法初始化关键字和操作符的名称：

[PRE43]

`nextToken` 方法扫描缓冲区并返回下一个标记。如果没有可识别的标记，则会抛出一个错误异常，该异常随后被 `main` 函数捕获：

[PRE44]

`m_buffer` 字段包含源代码；`m_bufferIndex` 包含要检查的缓冲区中下一个字符的索引（索引初始化为零）；`m_keywordMap` 包含关键字的名称；`m_valueMap` 包含颜色、对齐、笔和画笔样式值的映射，`m_operatorList` 包含操作符列表：

[PRE45]

在前面的章节中，我们使用了 C++ 标准类 `map`、`set`、`list`、`vector` 和 `stack`。在本章中，我们将使用 Qt 类 `QMap`、`QSet`、`QList`、`QVector` 和 `QStack` 代替。它们的工作方式大致相同：

[PRE46]

`Scanner.cpp` 文件包含 `Scanner` 类的方法定义。

**Scanner.cpp:**

[PRE47]

`g_lineNo` 全局字段跟踪源代码中的当前行，以便错误消息可以显示行号：

[PRE48]

`ADD_TO_OPERATOR_LIST` 宏将标记添加到操作符列表中。例如，`ADD_TO_OPERATOR_LIST("+", AddId)` 将 `"+"` 和 `AddId` 对添加到列表中：

[PRE49]

`ADD_TO_KEYWORD_MAP` 宏将关键字添加到关键字映射中。例如，`ADD_TO_KEYWORD_MAP(ColorId)` 将 `Color` 和 `ColorId` 对添加到映射中。请注意，关键字的部分（最后两个字符）的文本被移除：

[PRE50]

`ADD_TO_VALUE_MAP` 宏将值添加到值映射中。例如，`ADD_TO_VALUE_MAP(Aqua)` 将 aqua 和 `QColor` 对象 Aqua 对添加到映射中。请注意，文本被转换为小写。另外请注意，只包括最后一个可能的对冒号 (`::`) 的最后一个部分：

[PRE51]

`ADD_TO_VALUE_MAP(Qt::AlignLeft)` 将对齐左和 `Qt::PenStyle` 值对添加到映射中。再次注意，只有值名称的最后一个部分被存储为文本：

[PRE52]

在构造函数中，我们将缓冲区加载到 `m_buffer` 字段中。我们还添加了空字符 (`''`)，以便更容易地找到缓冲区的末尾：

[PRE53]

`nextToken` 方法扫描缓冲区并返回找到的标记。首先，我们迭代，直到找到新行、空白或行注释。如果遇到新行，则增加行数：

[PRE54]

空白是常规空格、水平或垂直制表符、回车符或新行。我们使用 `isSpace` 方法检查字符是否为空白：

[PRE55]

如果我们遇到行注释的开始（`//`），我们继续直到找到行尾（`'n'`）或缓冲区结束（`''`）：

[PRE56]

如果我们没有找到新行、空白或行注释，我们中断迭代并继续寻找下一个标记：

[PRE57]

当我们扫描过潜在的空白和注释后，我们开始寻找真正的标记。我们首先检查缓冲区中的下一个字符是否是空字符（`''`）。如果是空字符，我们就找到了源代码的结尾并返回文件结束。记住，我们在构造函数中添加了一个空字符到缓冲区末尾，只是为了能够识别文件结束：

[PRE58]

如果下一个标记不是文件结束，我们检查它是否是一个运算符。我们遍历运算符列表，并检查缓冲区是否以任何运算符的文本开头。例如，加法运算符包含文本 `+`：

[PRE59]

当我们找到运算符时，我们增加缓冲区索引，并返回标记：

[PRE60]

如果缓冲区不以运算符开头，我们寻找代表关键字、值或简单名称的名称。我们首先检查缓冲区是否以字母或下划线字符（`'_'`）开头，因为名称可以以字母或下划线开头。然而，除了字母和下划线之外，剩余的字符可以是数字：

[PRE61]

我们遍历直到找到一个不是字母、数字或下划线的字符：

[PRE62]

我们提取文本并增加缓冲区索引：

[PRE63]

文本可以包含一个关键字、一个值或一个名称。首先，我们检查文本是否存在于关键字映射中。如果存在，我们只需返回与关键字文本关联的标记：

[PRE64]

然后我们检查文本是否存在于值映射中。如果存在，我们返回一个带有值注释的值标记。值可以在稍后由解析器获取：

[PRE65]

如果文本既不是关键字也不是值，我们假设它是一个名称，并返回一个带有名称注释的名称标记。名称可以在稍后由解析器获取：

[PRE66]

当我们没有找到名称时，我们开始寻找字符串。字符串是由双引号（`'"'`）包围的文本。如果缓冲区中的下一个字符是双引号，那么它是文本的开始。我们从缓冲区中移除双引号，并遍历直到找到文本的结束引号：

[PRE67]

如果我们在文本结束之前找到空字符，由于我们在文本中找到了文件结束，所以报告语法错误：

[PRE68]

当我们找到结束引号时，我们增加缓冲区索引，并返回一个带有文本作为其注释值的值标记。文本可以在稍后由解析器获取：

[PRE69]

如果缓冲区中的下一个字符是数字，我们就找到了一个数值，可能带有小数点。首先，我们遍历缓冲区，直到找到数字：

[PRE70]

当我们不再找到任何数字时，我们检查缓冲区中的下一个字符是否是点（`'.'`）。如果是点，只要我们找到数字，我们就继续迭代：

[PRE71]

当我们不再找到任何数字时，我们增加缓冲区索引，并返回一个带有注释值的值标记。该值可以稍后被解析器获取：

[PRE72]

最后，如果前面的任何情况都不适用，源代码在语法上是错误的，我们报告一个语法错误：

[PRE73]

我们返回一个文件结束标记，仅仅是因为我们必须返回一个值。然而，我们永远不会到达代码的这个点，因为`syntaxError`调用抛出了一个异常：

[PRE74]

现在我们已经了解了扫描器，我们将在下一节继续了解解析器。

# 构建解析器

现在我们已经了解了扫描器，是时候转向解析器了。解析器检查源代码是否符合语法。它还执行类型检查并生成动作列表，该列表稍后由查看器显示，如下所示。`Parser` 类以这种方式反映了语法，即它为每个语法规则持有一个方法。

**Parser.h:** 

[PRE75]

构造函数接受一个语法对象和动作列表，动作列表最初为空。解析器每次需要新标记时都会调用扫描器：

[PRE76]

`match` 方法检查给定的标记是否等于扫描器获取的下一个标记。如果不相等，则报告语法错误：

[PRE77]

`Parser`类的其余方法分为语法中的指令和表达式的方法，以及类型检查和表达式评估的方法：

[PRE78]

我们还为语法中的每个表达式规则添加了一个解析器方法：

[PRE79]

在评估表达式的值时，我们需要检查值的类型。例如，当添加两个值时，两个操作数都应该是数值：

[PRE80]

`m_lookAhead`字段持有扫描器获取的下一个标记，`m_scanner`持有扫描器本身。`m_actionList`字段持有构造函数中给出的动作列表的引用。最后，`m_assignMap`持有由赋值规则分配给值的映射：

[PRE81]

`Parser.cpp`文件包含`Parser`类的定义方法。

**Parser.cpp:** 

[PRE82]

构造函数初始化对扫描器和动作列表的引用，并将`m_lookAHead`字段设置为扫描器获取的第一个标记。然后通过调用`instructionList`开始解析过程。当指令列表被解析后，唯一剩下的标记应该是文件结束标记：

[PRE83]

`g_lineNo`字段跟踪源代码的当前行，以便可以报告带有正确行号的语法错误：

[PRE84]

`instructionList`方法会一直迭代，直到遇到文件结束标记：

[PRE85]

`match`方法比较扫描器获取的下一个标记与给定的标记。如果不一致，则报告语法错误。如果一致，则通过扫描器获取下一个标记：

[PRE86]

# 解析语言的指令

`instruction` 方法包含一系列的 switch 案例序列，每个案例对应于指令的一个类别。我们将查看扫描器获得的下一个标记：

[PRE87]

在名称的情况下，我们解析名称、赋值运算符（`=`）、后面的表达式和分号：

[PRE88]

如果名称已经与一个值相关联，则会报告语义错误：

[PRE89]

笔和刷的颜色和样式设置，以及字体和对齐方式，稍微复杂一些。我们调用 `expression` 来解析和评估表达式的值。检查表达式的类型，并将 `Action` 对象添加到动作列表中：

[PRE90]

绘制线条、矩形、椭圆和文本需要两种表达式，其值将被评估和类型检查：

[PRE91]

如果前面的任何标记都不适用，则报告语法错误：

[PRE92]

# 解析语言的表达式

在最低优先级上，一个表达式由两个乘法或除法表达式组成。首先，我们调用 `mulDivExpression`，这是按优先级顺序的下一个表达式，以获得可能的加法或减法表达式的左值，然后调用 `expressionRest`，以检查实际上是否存在这样的表达式：

[PRE93]

`expressionRest` 方法检查下一个标记是否为加号或减号。在这种情况下，我们有一个加法或减法表达式，匹配标记，检查左右值的类型，然后评估并返回结果表达式：

[PRE94]

`mulDivExpression` 方法的工作方式与之前展示的 `expression` 类似。它调用 `primaryExpression` 和 `mulDivExpressionRest`，寻找乘法和除法。乘法和除法的优先级高于加法和减法。正如之前在 *源语言语法* 部分所述，我们需要在语法中添加一对新规则，在解析器中有两对方法用于加法/减法和乘法/除法表达式：

[PRE95]

最后，主表达式由一个点、坐标、颜色或字体表达式组成。它也可以由括号内的表达式、一个名称（在这种情况下我们查找其值）或一个值组成：

[PRE96]

坐标表达式接受一个点并返回其 x 或 y 坐标。我们匹配关键字和括号，并调用括号之间的表达式。然后我们检查表达式的值是否为点，最后调用 `evaluate` 以提取 *x* 或 *y* 坐标：

[PRE97]

点表达式由关键字 `point` 和两个数值表达式组成：*x* 和 *y* 坐标：

[PRE98]

颜色表达式由关键字 `color` 和三个数值表达式组成：红色、绿色和蓝色成分：

[PRE99]

字体表达式由关键字 `font` 和两个表达式组成：字体的名称（字符串）和其大小（数值）：

[PRE100]

表达式可以被括号包围。在这种情况下，我们匹配括号，并在其中调用 `expression` 以获得表达式的值：

[PRE101]

在名称的情况下，我们在赋值映射中查找其值并返回该值。如果没有值，则报告语义错误：

[PRE102]

在值的情况下，我们直接返回该值：

[PRE103]

在任何其他情况下，都会报告语法错误：

[PRE104]

# 表达式类型检查

第一个 `checkType` 方法检查具有一个值的表达式的类型。当设置笔或画刷样式时，类型必须是笔或画刷样式：

[PRE105]

当设置颜色或字体时，值必须是颜色或字体：

[PRE106]

当设置对齐方式时，值必须是对齐方式：

[PRE107]

当从一个点中提取 *x* 或 *y* 坐标时，值必须是一个点：

[PRE108]

第二个 `checkType` 方法接受两个值。绘图指令必须接受两个点：

[PRE109]

文本绘图指令必须接受一个点和字符串：

[PRE110]

# 评估表达式的值

第一个 `evaluate` 方法返回具有一个值的表达式的值。*x* 和 *y* 坐标运算符返回点的 *x* 或 *y* 坐标：

[PRE111]

断言仅用于调试目的，我们返回 false 仅因为该方法必须返回一个值：

[PRE112]

最后，第二个 `evaluate` 方法评估具有两个值的表达式的值。首先，我们提取数值并评估算术表达式：

[PRE113]

在除以零的情况下，报告语义错误：

[PRE114]

最后，在点表达式中，我们返回一个包含其 *x* 和 *y* 坐标两个数值的点值：

[PRE115]

如前所述的第一个评估情况，断言仅用于调试目的，我们返回 false 仅因为该方法必须返回一个值：

[PRE116]

# 查看器

最后，是时候编写查看器，我们 DSL 的最后一部分。查看器遍历动作并显示图形对象。`ViewerWidget` 类继承自 Qt 类 `QWidget`，它在屏幕上显示小部件。

**ViewerWidget.h:** 

[PRE117]

构造函数调用基类 `QWidget` 的构造函数，并存储动作列表的引用：

[PRE118]

类的主要部分是 `paintEvent` 方法。每当窗口需要重绘时，它都会被调用，并遍历动作列表：

[PRE119]

调用 `QFont` 的默认构造函数，将字体初始化为合适的系统字体。水平和垂直对齐都是居中的。最后，`m_actionList` 持有由解析器生成的动作列表的引用：

[PRE120]

`ViewerWidget.cpp` 文件包含 `ViewerWidget` 类的方法定义。

**ViewerWidget.cpp:** 

[PRE121]

构造函数调用基类 `QWidget` 的构造函数，并传入父窗口小部件，初始化 `m_actionList` 引用，设置窗口标题，并设置一个合适的尺寸：

[PRE122]

每次小部件需要重新绘制时，都会调用 `paintEvent` 方法。首先定义 `QPainter` 对象 `painter`，然后遍历动作列表：

[PRE123]

`SetPenColor` 动作创建了一个带有新颜色和当前样式的笔，并将其添加到 `painter` 中。同样，`SetPenStyle` 动作创建了一个带有新样式和当前颜色的笔：

[PRE124]

我们以与之前设置笔颜色和样式相同的方式设置画刷的颜色和样式。唯一的区别是我们创建了一个画刷而不是笔：

[PRE125]

在字体的情况下，我们在 `painter` 上调用 `setFont`。之后，字体与 `painter` 关联，并在写入文本时使用：

[PRE126]

水平和垂直对齐方式存储在 `m_horizontalAlignment` 和 `m_verticalAlignment` 中，这些值在写入文本时会被使用：

[PRE127]

现在，是时候实际绘制一些图形对象了。一条线简单地画在两个点之间，而矩形或椭圆有上左和下右角，这些角被放置在一个矩形中，该矩形用作 `drawRect` 和 `drawEllipse` 调用的参数：

[PRE128]

最后，我们写入文本。我们首先提取点以围绕文本中心进行绘制，然后使用 Qt 的 `QFontMetrics` 类获取文本的大小（以像素为单位）：

[PRE129]

在左对齐的情况下，文本的左侧是点的 *x* 坐标。在居中对齐的情况下，文本的左侧会向左移动半个文本宽度，而在右对齐的情况下，文本的左侧会向左移动整个文本宽度：

[PRE130]

同样：在顶部垂直对齐的情况下，文本的顶部是点的 *y* 坐标。在居中对齐的情况下，文本的顶部向上移动半个文本高度，而在底部对齐的情况下，文本的顶部向上移动整个文本高度：

[PRE131]

# 主函数

最后，主函数调用扫描器的 `init` 静态方法以初始化其标记、关键字和值。创建了一个 `QApplication` 对象，读取并解析源代码，并创建了查看器小部件。它执行动作列表并显示图形对象。应用程序会一直执行，直到用户按下右上角的关闭按钮。

**Main.cpp:**

[PRE132]

在出现语法或语义错误的情况下，其消息会在消息框中显示：

[PRE133]

# 摘要

在本章中，我们开始开发一个 DSL，该 DSL 生成一系列创建图形对象的动作，这些对象在窗口小部件中查看。我们的 DSL 支持绘制图形对象（如线条、矩形、椭圆和文本）的指令，以及设置对象的颜色、样式和对齐方式。它还支持带有算术运算符的表达式。

我们领域特定语言（DSL）的语法由语法规则定义，并由一个扫描器组成，该扫描器扫描文本以查找有意义的部分，解析器检查源代码是否符合语法，并生成一系列动作，这些动作由查看器读取并执行。

在下一章中，我们将继续开发我们的DSL。本章的DSL仅支持按顺序执行的代码。然而，在下一章中，我们将添加函数调用以及选择和迭代（`if`和`while`指令）。
