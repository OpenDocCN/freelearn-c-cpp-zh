# Domain-Specific Language

In the previous chapters, we developed the games Othello and Noughts and Crosses with the Qt library. In this chapter, we will start to develop a **Domain-Specific Language** (**DSL**), which is a language intended for a specific domain. More specifically, we will develop a language for writing graphical objects in a Qt widget. The language allows us to draw lines, rectangles, ellipses, and to write text. Moreover, it does allow us to choose color as well as pen and brush style for the graphical objects. It also allows us to choose font and alignment for the text.

Topics we will cover in this chapter include:

*   First, we will informally look into the source code of our DSL by looking at an example. We will draw graphical objects and set their color, style, and font.
*   We will formally define our language with grammar.
*   When we have defined the grammar, we write the scanner. The scanner reads the source code and recognizes meaningful sequences of characters, called **tokens**.
*   When we have written the scanner, we write the parser. The parser can be considered the heart of our DSL. It requests new tokens from the scanner, when needed. It checks that the source code complies with the grammar, and it generates a sequence of actions. Each action holds an instruction, such as setting the color or drawing a line.
*   Finally, we write a viewer that reads the action sequence generated by the parser and displays the graphical objects in a Qt widget.

# Introducing the source language – a simple example

The source language of our DSL is made up by a sequence of instructions. There are instructions for drawing graphical objects such as lines, rectangles, ellipses, and text. We also have instructions for setting the color and style of the objects as well as font and alignment of the text. Finally, there is instruction for assigning values to a name.

Let us look at an example. The following code draws a rectangle and writes text. Note that the language is not case-sensitive, that is, it does not matter whether we use small or capital letters in our code. We start by defining the top-left corner of a rectangle:

```cpp
  topLeft = point(100, 100); 
```

We use the coordinate operators to extract the *x* and *y* coordinates of the top-left point and define the bottom-right corner:

```cpp
  left = xCoordinate(topleft); 
  top = yCoordinate(topLeft); 
  bottomRight = point(left + 100, top + 100); 
```

We use the predefined values `DashLine` and `CrossPatterns` to set the style of the pen and brush:

```cpp
  SetPenStyle(DashLine); 
  SetBrushStyle(CrossPattern); 
```

We use the predefined color `Black` for the pen and create our own color `Purple` for the brush. We can create a new color with three values corresponding to their red, green, and blue components. Each component can hold a value between 0 and 255, inclusive:

```cpp
  SetPenColor(Black); 
  PurpleColor = color(128, 0, 128); 
  SetBrushColor(PurpleColor); 
  DrawRectangle(topLeft, bottomRight); 
```

We continue to add a text, with font and alignment. We choose `12` point `Times New Roman` with left horizontal alignment and top vertical alignment:

```cpp
  SetFont(font("Times New Roman", 12)); 
  SetHorizontalAlignment(AlignLeft); 
  SetVerticalAlignment(AlignTop); 
  DrawText(point(300, 150), "Hello, DSL!");
```

The instructions of this example will be divided into meaningful parts by the scanner; the parser will check that the instructions comply with the grammar and generate a sequence of actions read by the viewer and display the following Qt widget:

![](img/30203c62-df0f-49a5-9e2a-e676d1dafdbf.png)

# The grammar of the source language

The source language of our DSL needs to be exactly defined. We do that by defining grammarfor the language. Grammar is made up by rules (in *italic* style), keywords (in **bold** style), separations, and punctuations.

The `program` rule is the start rule. The arrow (`->`) means that a program is made up by an instructions list. The arrow can be read as:

```cpp
program -> instructionList 
```

In the grammar, an asterisk (`*`) means **zero** or **more**. Hence, an instruction list is made up by zero or more instructions:

```cpp
instructionList -> instruction* 
```

The assignment instruction takes a name followed by the assignment operator (`=`), an expression, and a semicolon. The instructions for setting the pen and brush color and style take one expression, so do the settings of the font and alignment. The instructions for drawing lines, rectangles, and text take two expressions. Note that every instruction is terminated by a semicolon (`;`).

The vertical bar (`|`) can be read as **or**. An instruction is an assignment orthe setting of the pen color orthe setting of the brush color, and so on:

```cpp
instruction -> name = expression; 
             | SetPenColor(expression); 
             | SetPenStyle(expression); 
             | SetBrushColor(expression); 
             | SetBrushStyle(expression); 
             | SetFont(expression); 
             | SetHorizontalAlignment(expression); 
             | SetVerticalAlignment(expression); 
             | DrawLine(expression, expression); 
             | DrawRectangle(expression, expression); 
             | DrawEllipse(expression, expression); 
             | DrawText(expression, expression); 
```

The next part of the parser to define is the expressions. First, we look at the operators of the expressions. We also have to look into the priority of the operators. For instance, multiplication and division have higher priority than addition and subtraction. The operators of the grammar have the following priorities:

| **Expression** | **Operator** | **Priority** |
| Addition Subtraction | `+ -` | Lowest |
| Multiplication Division | `* /` |  |
| Primary | `point``xCoordinate``yCoordinate``color``font``(expression)``name``value` | Highest |

We define two rules each for addition and subtraction, as well as for multiplication and division. We start with the lowest priority level, which is addition and subtraction. In the `expression` rule we call the `mulDivExpression` rule, which handles multiplication and division expressions, and we call the `expressionRest` rule to examine the rest of the expression:

```cpp
expression -> mulDivExpression expressionRest 
```

In the `expressionRest` rule we look into the next token. If it is a plus or a minus, we have an addition or subtraction expression. We call `mulDivExpression` to handle expressions of higher priority. Finally, we call the `expressionRest` rule again in case of another plus or minus. However, if the first token is neither a plus nor a minus,  we do nothing:

```cpp
expressionRest -> + mulDivExpression expressionRest 
                | - mulDivExpression expressionRest 
                | /* empty */ 
```

`mulDivExpression` and `mulDivExpressionRest` work in the same way as `expression` and `expressionRest` shown previously:

```cpp
mulDivExpression -> primaryExpression mulDivExpressionRest 
mulDivExpressionRest -> * primaryExpression mulDivExpressionRest 
                      | / primaryExpression mulDivExpressionRest 
                      | /* empty */ 
```

The primary expression is a point, an *x* or *y* coordinate, a color, a font, a name, or a value. A point is made up by two expressions holding the *x* and *y* coordinate of the point. A coordinate takes an expression holding a point and gives it an *x* or *y* coordinate:

```cpp
primaryExpression -> point(expression, expression) 
                   | xCoordinate(expression) 
                   | yCoordinate(expression) 
```

A color expression is made up by its red, green, and blue components, while a font expression is made up by the name and size of the font:

```cpp
                   | color(expression, expression, expression) 
                   | font(expression, expression) 
```

An expression can be enclosed in parentheses in order to change the priority of the expression. For instance, in the expression 2 + 3 x 4, multiplication takes precedence over addition, but in the expression (2 + 3) x 4, addition takes precedence over multiplication:

```cpp
                   | (expression) 
```

Finally, an expression can be a name earlier associated with a value, or simply a value:

```cpp
                   | name 
                   | value
```

# The target language

The target language is defined by a sequence of actions. Informally, the actions correspond to the instructions of the grammar. We have actions for setting the color or style of a pen or a brush, and for setting the horizontal or vertical alignment of the text, as well as actually drawing the lines, rectangles, ellipses, and text of the drawing. Later in this chapter, we will write a parser that generates a sequence of actions, and a viewer that reads the actions and displays graphical objects in a Qt widget.

An `Action` object holds the identity of the action (which is defined by the `TokenId` enumeration in the `Token` class, as follows) together with, at most, two values.

**Action.h:**

```cpp
#ifndef ACTION_H 
#define ACTION_H 

#include "Token.h" 
#include "Value.h" 

class Action { 
  public: 
    Action(TokenId actionId, const Value& value1 = Value(), 
           const Value& value2 = Value()); 

    Action(const Action& action); 
    Action operator=(const Action& action); 

    TokenId id() const {return m_actionId;} 
    const Value& value1() const {return m_value1;} 
    const Value& value2() const {return m_value2;} 

  private: 
    TokenId m_actionId; 
    Value m_value1, m_value2; 
}; 

#endif // ACTION_H 
```

The `Action.cpp` file holds the definitions of the methods of the `Action` class.

**Action.cpp:**

```cpp
#include "Action.h"
```

The constructor takes the action identity and at most two values:

```cpp
Action::Action(TokenId actionId, 
               const Value& value1 /*= Value()*/, 
               const Value& value2 /*= Value()*/ ) 
  :m_actionId(actionId), 
   m_value1(value1), 
   m_value2(value2) { 
  // Empty. 
}  
```

# The colors

When setting the color of the pen or brush, we need to submit the color with the instruction. We can use the color rule in the preceding grammar to create our own color. However, there is a set of predefined colors of the Qt class `QColor`. The following scanner defines a set of predefined `QColor` objects (`Aqua`, `Black`, ...) and maps them to their names. For instance, the user can write the following instruction in the source code:

```cpp
SetPenColor(Aqua); 
```

In that case, since the name `Aqua` is associated with the `QColor` object `Aqua`, the pen color is set to `Aqua`.

**Colors.h:**

```cpp
#ifndef COLOR_H 
#define COLOR_H 

#include <QWidget> 

extern QColor 
  Aqua, Black, Blue, Brown, Cyan, Gray, Green, Lime, Magenta, 
  Navyblue, Orange, Orchid, Pink, Purple, Red, Silver, Snow, 
  SteelBlue, SystemColor, Turquoise, Violet, White, Yellow; 

#endif // COLOR_H 
```

The `Colors.cpp` file holds the definitions of the colors in the `Colors.h` file.

**Colors.cpp:**

```cpp
#include "Colors.h"
```

Each color is defined by its red, green, and blue component. Each component holds a value from 0 to 255, inclusive. For instance, the `Blue` color holds the full value of the blue component and zero of the other components, while `Yellow` is a blend of red and green:

```cpp
QColor 
  Aqua(0, 255, 255), Black(0, 0, 0), Blue(0, 0, 255), 
  Brown(165, 42, 42), Cyan(0, 255, 255), Gray(127, 127, 127), 
  Green(0, 128, 0), Lime(0, 255, 0), Magenta(255, 0, 255), 
  Navyblue(159, 175, 223), Orange(255, 165, 0), 
  Orchid(218, 112, 214), Pink(255, 192, 203), 
  Purple(128, 0, 128), Red(255, 0, 0), Silver(192, 192, 192), 
  Snow(255, 250, 250),  SteelBlue(70, 130, 180), 
  SystemColor(0, 0, 0), Turquoise(64, 224, 208), 
  Violet(238, 130, 238), White(255, 255, 255), 
  Yellow(255, 255, 0); 
```

# Error handling

There are some functions for error handling: `check` checks whether a condition is true and reports an error if it is not. The `syntaxError` and `semanticError` functions report a syntactic and semantic error, while `error` throws an exception that is caught and reported by the `main` function.

**Error.h:**

```cpp
#ifndef ERROR_H 
#define ERROR_H 

#include <QString> 

void error(const QString& message); 
void syntaxError(); 
void syntaxError(const QString& message); 
void semanticError(const QString& message); 
void check(bool condition, const QString& message); 

#endif // ERROR_H 
```

The `Error.cpp` file holds the definitions of the `Error.h` file.

**Error.cpp:**

```cpp
#include <SStream> 
#include <Exception> 
using namespace std; 

#include "Error.h" 

extern int g_lineNo = 1; 

void error(const QString& message) { 
  throw exception(message.toStdString().c_str()); 
} 
```

We use the C++ `stringstream` standard class to compound the error message:

```cpp
void syntaxError() { 
  stringstream stringStream; 
  stringStream << "Syntax error at line " << g_lineNo << "."; 
```

The `str` method returns an object of the C++ `string` standard class, and `c_str` returns a character pointer that is converted to a `QString` object in the `error` call:

```cpp
  error(stringStream.str().c_str()); 
} 
```

A syntax error occurs when the scanner finds a character sequence that does not constitute a token, or when the parser detects that the token sequence does not comply with the grammar. We will cover the topic soon; for now, just remember that a scanner can report errors too:

```cpp
void syntaxError(const QString& message) { 
  stringstream stringStream; 
  stringStream << "Syntax error at line " << g_lineNo 
               << ": " << message.toStdString() << "."; 
  error(stringStream.str().c_str()); 
} 
```

A semantic error occurs when an unknown name is found, or when the types of an expression do not comply:

```cpp
void semanticError(const QString& message) { 
  stringstream stringStream; 
  stringStream << "Sematic error: " 
               << message.toStdString() << "."; 
  error(stringStream.str().c_str()); 
}
```

The `check` method has a similar effect to the `assert` macro. It checks whether the condition is true. If it is not true, `semanticError` is called, which eventually throws an error exception:

```cpp
void check(bool condition, const QString& message) { 
  if (!condition) { 
    semanticError(message); 
  } 
} 
```

# The value

There are several kinds of values in the language, which are used to set the color or style of the pen or brush, or to set the end-points of a line, or to set the name of the font, or the alignment of the text: numerical (`double`), string (`QString`), color (`QColor`), font (`QFont`), point (`QPoint`), pen style (`Qt::PenStyle`), brush style (`Qt`::`BrushStyle`), and horizontal or vertical alignment (`Qt`::`AlignmentFlag`).

**Value.h:**

```cpp
#ifndef VALUE_H 
#define VALUE_H 

#include <IOStream> 
using namespace std; 

#include <QtWidgets> 

enum TypeId {NumericalTypeId, StringTypeId, ColorTypeId, 
             PenStyleTypeId, BrushStyleId, AlignmentTypeId, 
             FontTypeId, PointTypeId}; 

class Value { 
  public: 
    Value(); 
    Value(double numericalValue); 
    Value(const QString& stringValue); 
    Value(const QPoint& pointValue); 
    Value(const QColor& colorValue); 
    Value(const QFont& fontValue); 
    Value(const Qt::PenStyle& penStyleValue); 
    Value(const Qt::BrushStyle& brushStyleValue); 
    Value(const Qt::AlignmentFlag& alignment); 

    Value(const Value& value); 
    Value& operator=(const Value& value); 

    bool isNumerical() const {return (m_typeId==NumericalTypeId);} 
    bool isString() const { return (m_typeId == StringTypeId); } 
    bool isColor() const { return (m_typeId == ColorTypeId); } 
    bool isFont() const { return (m_typeId == FontTypeId); } 
    bool isPoint() const { return (m_typeId == PointTypeId); } 
    bool isPenStyle() const {return (m_typeId == PenStyleTypeId);} 
    bool isBrushStyle() const {return (m_typeId == BrushStyleId);} 
    bool isAlignment() const {return (m_typeId==AlignmentTypeId);} 

    double numericalValue() const { return m_numericalValue; } 
    const QString& stringValue() const { return m_stringValue; } 
    const QColor& colorValue() const { return m_colorValue; } 
    const QFont& fontValue() const { return m_fontValue; } 
    const QPoint& pointValue() const { return m_pointValue; } 
    const Qt::PenStyle& penStyleValue() const 
                        { return m_penStyleValue; } 
    const Qt::BrushStyle& brushStyleValue() const 
                          { return m_brushStyleValue; } 
    const Qt::AlignmentFlag& alignmentValue() const 
                             { return m_alignmentValue; } 

  private: 
    TypeId m_typeId; 
    double m_numericalValue; 
    QString m_stringValue; 
    QPoint m_pointValue; 
    QColor m_colorValue; 
    QFont m_fontValue; 
    Qt::PenStyle m_penStyleValue; 
    Qt::BrushStyle m_brushStyleValue; 
    Qt::AlignmentFlag m_alignmentValue; 
}; 

#endif // VALUE_H 
```

The `Value.cpp` file holds the definitions of the methods of the `Value` class.

**Value.cpp:**

```cpp
#include <CAssert> 
using namespace std; 

#include "Value.h" 

Value::Value() { 
  // Empty. 
} 
```

The non-default constructors initialize the `Value` object with appropriate values:

```cpp
Value::Value(double numericalValue) 
 :m_typeId(NumericalTypeId), 
  m_numericalValue(numericalValue) { 
  // Empty. 
} 

Value::Value(const QPoint& pointValue) 
 :m_typeId(PointTypeId), 
  m_pointValue(pointValue) { 
  // Empty. 
} 
```

# The scanner

The **scanner** is a part of the application that accepts the source code and generates a sequence of tokens. A **token** is the smallest meaningful part of the source code. For instance, the characters **f**, **o**, **n**, and **t** make up the keyword **font**, and the characters **1**, **2**, and **3** constitute the numerical value **123**.

However, first we need the `Token` class to keep track of the tokens. The `m_tokenId` field is set to a value of the enumeration `TokenId`. In the case of a name, the `m_name` field holds the name, and in the case of a value, the `m_value` field holds the value.

**Token.h:**

```cpp
#ifndef TOKEN_H 
#define TOKEN_H 

#include <QWidget> 
#include "Value.h" 
```

The `TokenId` enumeration holds all the tokens of the scanner. They are divided into keywords, operators, punctuation, and separators, as well as names and values. In order to avoid converting between different enumerations, the `TokenId` enumeration is used by the scanner, parser, and viewer. The `TokenId` enumeration is used by the scanner to distinguish between the different tokens by the parser when type checking and evaluating expressions, and by the `Action` class to distinguish between different actions.

The first part (`ColorId` to `YCoordinateId`) is keywords of the language:

```cpp
enum TokenId {ColorId, DrawEllipseId, DrawLineId, 
              DrawRectangleId, DrawTextId, FontId,  
              PointId, SetBrushColorId, SetBrushStyleId, 
              SetFontId, SetHorizontalAlignmentId, 
              SetPenColorId, SetPenStyleId, 
              SetVerticalAlignmentId, 
              XCoordinateId, YCoordinateId, 
```

The second part (`AddId` to `DivideId`) is operators:

```cpp
              AddId, SubtractId, MultiplyId, DivideId, 
```

The next part is parentheses, assignment (`=`), comma, and semicolon:

```cpp
              LeftParenthesisId, RightParenthesisId, 
              AssignId, CommaId, SemicolonId, 
```

Finally, the last part is the name, value, and end-of-file marking:

```cpp
              NameId, ValueId, EndOfFileId}; 

class Token{ 
  public: 
    Token(); 
    Token(TokenId tokenId); 
    Token(TokenId tokenId, const QString& name); 
    Token(TokenId tokenId, const Value& value); 
```

Each token can be annotated with a name or a value:

```cpp
    TokenId id() const {return m_tokenId;} 
    const QString& name() const { return m_name; } 
    const Value& value() const { return m_value; } 

  private: 
    TokenId m_tokenId; 
    QString m_name; 
    Value m_value; 
}; 

#endif // TOKEN_H
```

The `Token.cpp` file holds the definitions of the methods of the `Token` class.

**Token.cpp:**

```cpp
#include "Token.h" 
```

The default token is initialized with an end-of-file token:

```cpp
Token::Token() 
 :m_tokenId(EndOfFileId) { 
  // Empty. 
} 
```

Most tokens hold only a value of the `TokenId` enumeration:

```cpp
Token::Token(TokenId tokenId) 
 :m_tokenId(tokenId) { 
  // Empty. 
} 
```

Tokens can also hold a name or a value:

```cpp
Token::Token(TokenId tokenId, const QString& name) 
 :m_tokenId(tokenId), 
  m_name(name) { 
  // Empty. 
} 

Token::Token(TokenId tokenId, const Value& value) 
 :m_tokenId(tokenId), 
  m_value(value) { 
  // Empty. 
} 
```

The `Scanner` class takes the source code and divides it into tokens. A token can also be associated by a name or a value.

**Scanner.h:**

```cpp
#ifndef SCANNER_H 
#define SCANNER_H 

#include "Token.h" 
#include "Colors.h"
```

The `init` method initializes the names of the keywords and operators:

```cpp
class Scanner { 
  public: 
    static void init(); 
    Scanner(QString& buffer); 
```

The `nextToken` method scans the buffer and returns the next token. If there is no recognizable token, an error exception is thrown that is later caught by the `main` function:

```cpp
  public: 
    Token nextToken(); 
```

The `m_buffer` field holds the source code; `m_bufferIndex` holds the index of the next character in the buffer to be examined (the index is initialized to zero); `m_keywordMap` holds the names of the keywords; `m_valueMap` holds a map of color, alignment, and pen and brush style values, and `m_operatorList` hold a list of operators:

```cpp
  private: 
    QString m_buffer; 
    int m_bufferIndex = 0; 
```

In previous chapters, we have used the C++ standard classes `map`, `set`, `list`, `vector`, and `stack`. In this chapter, we will use the Qt classes `QMap`, `QSet`, `QList`, `QVector`, and `QStack` instead. They work approximately in the same way:

```cpp
    static QMap<QString,TokenId> m_keywordMap; 
    static QMap<QString,Value> m_valueMap; 
    static QList<pair<QString,TokenId>> m_operatorList; 
}; 

#endif // SCANNER_H 
```

The `Scanner.cpp` file holds the definitions of the methods of the `Scanner` class.

**Scanner.cpp:**

```cpp
#include <SStream> 
#include <IOStream> 
#include <Exception> 
using namespace std; 

#include "Error.h" 
#include "Scanner.h" 

QMap<QString,Value> Scanner::m_valueMap; 
QMap<QString,TokenId> Scanner::m_keywordMap; 
QList<pair<QString, TokenId>> Scanner::m_operatorList; 
```

The `g_lineNo` global field keeps track of the current line in the source code, in order for the error messages to state the line number:

```cpp
extern int g_lineNo; 
```

The `ADD_TO_OPERATOR_LIST` macro adds a token to the operator list. For instance, `ADD_TO_OPERATOR_LIST("+", AddId)` adds the pair of `"+"` and `AddId` to the list:

```cpp
#define ADD_TO_OPERATOR_LIST(text, token)                      
  m_operatorList.push_back(pair<QString,TokenId>(text, token)); 

void Scanner::init() { 
  ADD_TO_OPERATOR_LIST("+", AddId) 
  ADD_TO_OPERATOR_LIST("-", SubtractId) 
  ADD_TO_OPERATOR_LIST("*", MultiplyId) 
  ADD_TO_OPERATOR_LIST("/", DivideId) 
  ADD_TO_OPERATOR_LIST("(", LeftParenthesisId) 
  ADD_TO_OPERATOR_LIST(")", RightParenthesisId) 
  ADD_TO_OPERATOR_LIST("=", AssignId) 
  ADD_TO_OPERATOR_LIST(",", CommaId) 
  ADD_TO_OPERATOR_LIST(";", SemicolonId) 
```

The `ADD_TO_KEYWORD_MAP` macro adds a keyword to the keyword map. For instance, `ADD_TO_KEYWORD_MAP(ColorId)` adds the pair of `Color` and `ColorId` to the map. Note that the `Id` part of the keyword (the last two characters) text is removed:

```cpp
#define ADD_TO_KEYWORD_MAP(x) {                        
  QString s(#x);                                       
  m_keywordMap[s.toLower().left(s.length() - 2)] = x; } 

  ADD_TO_KEYWORD_MAP(ColorId) 
  ADD_TO_KEYWORD_MAP(DrawEllipseId) 
  ADD_TO_KEYWORD_MAP(DrawLineId) 
  ADD_TO_KEYWORD_MAP(DrawRectangleId) 
  ADD_TO_KEYWORD_MAP(DrawTextId) 
  ADD_TO_KEYWORD_MAP(FontId) 
  ADD_TO_KEYWORD_MAP(PointId) 
  ADD_TO_KEYWORD_MAP(SetBrushColorId) 
  ADD_TO_KEYWORD_MAP(SetBrushStyleId) 
  ADD_TO_KEYWORD_MAP(SetFontId) 
  ADD_TO_KEYWORD_MAP(SetHorizontalAlignmentId) 
  ADD_TO_KEYWORD_MAP(SetPenColorId) 
  ADD_TO_KEYWORD_MAP(SetPenStyleId) 
  ADD_TO_KEYWORD_MAP(SetVerticalAlignmentId) 
  ADD_TO_KEYWORD_MAP(XCoordinateId) 
  ADD_TO_KEYWORD_MAP(YCoordinateId) 
```

The `ADD_TO_VALUE_MAP` macro adds a value to the value map. For instance, `ADD_TO_VALUE_MAP(Aqua)` adds the pair of aqua and the `QColor` object Aqua to the map. Note that the text is converted to lower case. Also note that only the last part after the last potential pair of colons (`::`) is included:

```cpp
#define ADD_TO_VALUE_MAP(x) {                           
  QString s(#x);                                        
  QString t = s.toLower();                              
  int i = t.lastIndexOf("::");                          
  m_valueMap[(i == -1) ? t : t.mid(i + 2)] = Value(x); } 
```

`ADD_TO_VALUE_MAP(Qt::AlignLeft)` adds the pair of align left and the `Qt::PenStyle` value to the map. Again, note that only the last segment of the value's name is stored as text:

```cpp
  ADD_TO_VALUE_MAP(Qt::AlignLeft) 
  ADD_TO_VALUE_MAP(Qt::AlignTop) 

  ADD_TO_VALUE_MAP(Qt::PenStyle::NoPen) 
  ADD_TO_VALUE_MAP(Qt::PenStyle::SolidLine) 

  ADD_TO_VALUE_MAP(Qt::BrushStyle::NoBrush) 
  ADD_TO_VALUE_MAP(Qt::BrushStyle::SolidPattern) 

  ADD_TO_VALUE_MAP(Aqua) 
  ADD_TO_VALUE_MAP(Black) 
} 
```

In the constructor, we load the buffer into the `m_buffer` field. We also add the null-character (`''`) in order to find the end of the buffer in an easier way:

```cpp
Scanner::Scanner(QString& buffer) 
 :m_buffer(buffer) { 
  m_buffer.append(''); 
} 
```

The `nextToken` method scans the buffer and returns the token found. First, we iterate as long as we find new-line, white-space, or line comment. In case of a new line, we increase the line count:

```cpp
Token Scanner::nextToken() { 
  while (true) { 
    if (m_buffer[m_bufferIndex] == 'n') { 
      ++g_lineNo; 
      ++m_bufferIndex; 
    } 
```

A white-space is regular space, a horizontal or vertical tabulator, a return character, or new line. We use the `isSpace` method to check whether the character is a white-space:

```cpp
    else if (m_buffer[m_bufferIndex].isSpace()) { 
      ++m_bufferIndex; 
    } 
```

If we encounter the beginning of a line comment (`//`), we continue until we find the end of the line (`'n'`) or the end of the buffer (`''`):

```cpp
    else if (m_buffer.indexOf("//", m_bufferIndex) == 
             m_bufferIndex) { 
      while ((m_buffer[m_bufferIndex] != QChar('n')) && 
             (m_buffer[m_bufferIndex] != QChar(''))) { 
        ++m_bufferIndex; 
      } 
    } 
```

If we do not find a new line, white-space, or line comment, we break the iteration and continue looking for the next token:

```cpp
    else { 
      break; 
    } 
  } 
```

When we have scanned through the potential white-spaces and comments, we start looking for the real tokens. We start by checking if the next character in the buffer is a null character (`''`). If it is a null character, we have found the end of the source code and return end-of-file. Remember that we added a null character at the end of the buffer in the constructor, just to be able to recognize the end of the file:

```cpp
  if (m_buffer[m_bufferIndex] == QChar('')) { 
    return Token(EndOfFileId); 
  } 
```

If the next token is not end-of-file, we check if it is an operator. We iterate through the operator list and check if the buffer begins with any of the operator's text. For instance, the add operator holds the text `+`:

```cpp
  for (const pair<QString,TokenId>& pair : m_operatorList) { 
    const QString& operatorText = pair.first; 
    TokenId tokenId = pair.second;
```

When we have found the operator, we increment the buffer index, and return the token:

```cpp
    if (m_buffer.indexOf(operatorText, m_bufferIndex) == 
        m_bufferIndex) { 
      m_bufferIndex += operatorText.length(); 
      return Token(tokenId); 
    } 
  } 
```

If the buffer does not begin with an operator, we look after a name representing a keyword, a value, or simply a name. We start by checking if the buffer begins with a letter or the underscore character (`'_'`), since a name is allowed to start with a letter or an underscore. However, the remaining characters can be digits besides the letters and underscores:

```cpp
  if (m_buffer[m_bufferIndex].isLetter() || 
      (m_buffer[m_bufferIndex] == '_')) { 
    int index = m_bufferIndex; 
```

We iterate until we find a character that is not a letter, digit, or underscore:

```cpp
    while (m_buffer[index].isLetterOrNumber() || 
           (m_buffer[index] == '_')) { 
      ++index; 
    } 
```

We extract the text and increase the buffer index:

```cpp
    int size = index - m_bufferIndex; 
    QString text = m_buffer.mid(m_bufferIndex, size).toLower(); 
    m_bufferIndex += size; 
```

The text can hold a keyword, a value, or a name. First, we check whether the text is present in the keyword map. If it is present, we just return the token associated with the keyword text:

```cpp
    if (m_keywordMap.contains(text)) { 
      return Token(m_keywordMap[text]); 
    } 
```

We then check whether the text is present in the value map. If it is present, we return a value token with the value annotated to the token. The value can later be obtained by the parser:

```cpp
    else if (m_valueMap.contains(text)) { 
      return Token(ValueId, m_valueMap[text]); 
    }
```

If the text is neither a keyword nor a value, we assume that it is a name and return a name token with the name annotated to the token. The name can later be obtained by the parser:

```cpp
    else { 
      return Token(NameId, text); 
    } 
  } 
```

When we have looked for a name without finding it, we start looking for a string instead. A string is a text enclosed by double quotes (`'"'`). If the next character in the buffer is a double quote, it is the beginning of a text. We remove the double quote from the buffer and iterate until we find the end quote of the text:

```cpp
  if (m_buffer[m_bufferIndex] == '"') { 
    int index = m_bufferIndex + 1; 

    while (m_buffer[index] != '"') { 
```

If we find a null character before the end of the text, a syntax error is reported since we have found the end of the file inside the text:

```cpp
      if (m_buffer[index] == QChar('')) { 
        syntaxError("unfinished string"); 
      } 

      ++index; 
    } 
```

When we have found the end quote, we increase the buffer index and return a value token with the text as its annotated value. The text can later be obtained by the parser:

```cpp
    int size = index - m_bufferIndex + 1; 
    QString text = m_buffer.mid(m_bufferIndex, size); 
    m_bufferIndex += size; 
    return Token(ValueId, Value(text)); 
  } 
```

If the next character in the buffer is a digit, we have found a numerical value, with or without decimals. First, we iterate as long as we find digits in the buffer:

```cpp
  if (m_buffer[m_bufferIndex].isDigit()) { 
    int index = m_bufferIndex; 

    while (m_buffer[index].isDigit()) { 
      ++index; 
    }
```

When we no longer find any digits, we check whether the next character in the buffer is a dot (`'.'`). If it is a dot, we continue to iterate as long as we find digits:

```cpp
    if (m_buffer[index] == '.') { 
      ++index; 

      while (m_buffer[index].isDigit()) { 
        ++index; 
      } 
    } 
```

When we no longer find any digits, we increase the buffer index and return a value token with the annotated value. The value can later be obtained by the parser:

```cpp
    int size = index - m_bufferIndex; 
    QString text = m_buffer.mid(m_bufferIndex, size); 
    m_bufferIndex += size; 
    return Token(ValueId, Value(text.toDouble())); 
  } 
```

Finally, if none of the preceding cases apply, the source code is syntactically incorrect, and we report a syntax error:

```cpp
  syntaxError(); 
```

We return an end-of-file token, simply because we have to return a value. However, we will never reach this point of the code since the `syntaxError` call caused an exception to be thrown:

```cpp
  return Token(EndOfFileId); 
} 
```

Now that we have looked at the scanner, we will continue to look at the parser in the next section.

# Building the parser

Now that we have looked into the scanner, it is time to move on to the parser. The parser checks that the source code complies with the grammar. It also performs type checking and generates the action list, which is later displayed by the viewer, as follows. The `Parser` class mirrors the grammar in that way the it holds one method for each grammar rule.

**Parser.h:**

```cpp
#ifndef PARSER_H 
#define PARSER_H 

#include "Action.h" 
#include "Scanner.h" 
```

The constructor takes a grammar object and the action list, which is empty at the beginning. The parser calls the scanner each time it needs a new token:

```cpp
class Parser { 
  public: 
    Parser(Scanner& m_scanner, QList<Action>& actionList); 
```

The `match` method checks whether the given token equals the next token obtained by the scanner. If it does not, a syntax error is reported:

```cpp
  private: 
    void match(TokenId tokenId); 
```

The remaining methods of the `Parser` class are divided into methods for instructions and expressions in the grammar, as well as methods for type checking and evaluation of expressions:

```cpp
    void instructionList(); 
    void instruction(); 
```

We also add a method to the parser for each expression rule in the grammar:

```cpp
    Value expression(); 
    Value expressionRest(Value leftValue); 
    Value mulDivExpression(); 
    Value mulDivExpressionRest(Value leftValue); 
    Value primaryExpression(); 
    Value primaryExpression(); 
```

When evaluating the values of expressions, we need to check the types of the values. For instance, when adding two values, both of the operands shall have numerical values:

```cpp
    void checkType(TokenId operatorId, const Value& value); 
    void checkType(TokenId operatorId, const Value& leftValue, 
                   const Value& rightValue); 
    Value evaluate(TokenId operatorId, const Value& value); 
    Value evaluate(TokenId operatorId, const Value& leftValue, 
                   const Value& rightValue);
```

The `m_lookAhead` field holds the next token obtained by the scanner, and `m_scanner` holds the scanner itself. The `m_actionList` field holds a reference to the action list given in the constructor. Finally, `m_assignMap` holds a map for the names assigned to values by the assignment rule:

```cpp
  private: 
    Token m_lookAHead; 
    Scanner& m_scanner; 
    QList<Action>& m_actionList; 
    QMap<QString,Value> m_assignMap;                                                                                                                                                                                                            }; 

#endif // PARSER_H 
```

The `Parser.cpp` file holds the definitions of the methods of the `Parser` class.

**Parser.cpp:**

```cpp
#include <CAssert> 
using namespace std; 

#include "Value.h" 
#include "Token.h" 
#include "Scanner.h" 
#include "Parser.h" 
#include "Error.h" 
```

The constructor initializes the references to the scanner and the action list, and sets the `m_lookAHead` field to the first token obtained by the scanner. Then the parsing process begins by calling `instructionList`. When the instruction list has been parsed, the only remaining token shall be the end-of-file token:

```cpp
Parser::Parser(Scanner& m_scanner, QList<Action>& actionList) 
 :m_scanner(m_scanner), 
  m_actionList(actionList) { 
  m_lookAHead = m_scanner.nextToken(); 
  instructionList(); 
  match(EndOfFileId); 
} 
```

The `g_lineNo` field keeps track of the current line of the source code so that a syntax error can be reported with the correct line number:

```cpp
extern int g_lineNo;
```

The `instructionList` method keeps iterating until it encounters the end-of-file token:

```cpp
void Parser::instructionList() { 
  while (m_lookAHead.id() != EndOfFileId) { 
    instruction(); 
  } 
} 
```

The `match` method compares the next token obtained by the scanner with the given token. If they do not comply, a syntax error is reported. If they do comply, the next token is obtained by the scanner:

```cpp
void Parser::match(TokenId tokenId) { 
  if (m_lookAHead.id() != tokenId) { 
    syntaxError(); 
  } 

  m_lookAHead = m_scanner.nextToken(); 
} 
```

# Parsing the instructions of the language

The `instruction` method holds a sequence of switch cases, one case for each category of instructions. We will look into the next token obtained by the scanner:

```cpp
void Parser::instruction() { 
  TokenId tokenId = m_lookAHead.id(); 
```

In the case of a name, we parse the name, assignment (`=`), the following expression, and a semicolon:

```cpp
  switch (tokenId) { 
    case NameId: { 
        QString assignName = m_lookAHead.name(); 
        match(NameId); 
        match(AssignId); 
        Value assignValue = expression(); 
        match(SemicolonId); 
```

If the name is already associated with a value, a semantic error is reported:

```cpp
        check(!m_assignMap.contains(assignName), 
              "the name "" + assignName + "" defined twiced"); 
        m_assignMap[assignName] = assignValue; 
      } 
      break;
```

The settings of pen and brush colors and styles, as well as fonts and alignments, are a little bit more complicated. We call `expression` to parse and evaluate the value of an expression. The type of the expression is checked, and an `Action` object is added to the action list:

```cpp
    case SetPenColorId: 
    case SetPenStyleId: 
    case SetBrushColorId: 
    case SetBrushStyleId: 
    case SetFontId: 
    case SetHorizontalAlignmentId: 
    case SetVerticalAlignmentId: { 
        match(tokenId); 
        match(LeftParenthesisId); 
        Value value = expression(); 
        match(RightParenthesisId); 
        match(SemicolonId); 
        checkType(tokenId, value); 
        m_actionList.push_back(Action(tokenId, value)); 
      } 
      break; 
```

The drawing of lines, rectangles, ellipses, and text takes two expressions, whose values are evaluated and type checked:

```cpp
    case DrawLineId: 
    case DrawRectangleId: 
    case DrawEllipseId: 
    case DrawTextId: { 
        match(tokenId); 
        match(LeftParenthesisId); 
        Value firstValue = expression(); 
        match(CommaId); 
        Value secondValue = expression(); 
        match(RightParenthesisId); 
        match(SemicolonId); 
        checkType(tokenId, firstValue, secondValue); 
        m_actionList.push_back(Action(tokenId, firstValue, 
                                      secondValue)); 
      } 
      break; 
```

If none of the preceding tokens apply, a syntax error is reported:

```cpp
    default: 
      syntaxError(); 
  } 
} 
```

# Parsing the expressions of the language

An expression, at its lowest priority level, is made up by two multiplication or division expressions. First, we call `mulDivExpression`, which is the next expression in increasing priority order, to obtain the left value of a possible addition or subtraction expression, and then `expressionRest`, which checks if there actually is such an expression:

```cpp
Value Parser::expression() { 
  Value leftValue = mulDivExpression (); 
  return expressionRest(leftValue); 
} 
```

The `expressionRest` method checks whether the next token is a plus or a minus. In that case, we have an addition or subtraction expression, the token is matched, the left and right values are type checked, and the resulting expression is evaluated and returned:

```cpp
Value Parser::expressionRest(Value leftValue) { 
  TokenId tokenId = m_lookAHead.id(); 

  switch (tokenId) { 
    case AddId: 
    case SubtractId: { 
        match(tokenId); 
        Value rightValue = mulDivExpression(); 
        check(leftValue.isNumerical() && rightValue.isNumerical(), 
              "non-numerical values in arithmetic expression"); 
        Value resultValue = 
          evaluate(tokenId, leftValue, rightValue); 
        return expressionRest(resultValue); 
      } 

    default: 
      return leftValue; 
  } 
}
```

The `mulDivExpression` method works in a way similar to `expression` shown previously. It calls `primaryExpression` and `mulDivExpressionRest`, which look for multiplication and division. Multiplication and division have higher priority than addition and subtraction. As stated in *The grammar of source language* section previously, we need a new pair of rules in the grammar, with two pairs of methods in the parser for the addition/subtraction and multiplication/division expressions:

```cpp
Value Parser::mulDivExpression() { 
  Value leftValue = primaryExpression(); 
  return mulDivExpressionRest(leftValue); 
} 

Value Parser::mulDivExpressionRest(Value leftValue) { 
  TokenId tokenId = m_lookAHead.id(); 

  switch (tokenId) { 
    case MultiplyId: 
    case DivideId: { 
        match(tokenId); 
        Value rightValue = primaryExpression(); 
        check(leftValue.isNumerical() && rightValue.isNumerical(), 
              "non-numerical values in arithmetic expression"); 
        Value resultValue = 
          evaluate(tokenId, leftValue, rightValue); 
        return mulDivExpressionRest (resultValue); 
      } 

    default: 
      return leftValue; 
  } 
} 
```

Finally, the primary expression is made up by a point, coordinate, color, or font expression. It can also be made up by an expression enclosed in parentheses, a name (in which case we look up its value), or a value:

```cpp
Value Parser::primaryExpression() { 
  TokenId tokenId = m_lookAHead.id(); 
```

The coordinate expression takes a point and returns its x or y coordinate. We match the keyword and the parentheses and call expressions in between. We then check that the value of the expression is a point, and finally call `evaluate` to extract the *x* or *y* coordinate:

```cpp
  switch (tokenId) { 
    case XCoordinateId: 
    case YCoordinateId: { 
        match(tokenId); 
        match(LeftParenthesisId); 
        Value value = expression(); 
        match(RightParenthesisId); 
        check(value.isPoint(), 
              "not a point in coordinate expression"); 
        checkType(tokenId, value); 
        return evaluate(tokenId, value); 
      } 
      break; 
```

A point expression is made up by the keyword `point` and two numerical expressions: the *x* and *y* coordinate:

```cpp
    case PointId: { 
        match(PointId); 
        match(LeftParenthesisId); 
        Value xValue = expression(); 
        match(CommaId); 
        Value yValue = expression(); 
        match(RightParenthesisId); 
        check(xValue.isNumerical() && yValue.isNumerical(), 
              "non-numerical values in point expression"); 
        return Value(QPoint(xValue.numericalValue(), 
                            yValue.numericalValue())); 
    } 
```

A color expression is made up by the keyword `color` and three numerical expressions: the red, green, and blue components:

```cpp
    case ColorId: { 
        match(ColorId); 
        match(LeftParenthesisId); 
        Value redValue = expression(); 
        match(CommaId); 
        Value greenValue = expression(); 
        match(CommaId); 
        Value blueValue = expression(); 
        match(RightParenthesisId); 
        check(redValue.isNumerical() && greenValue.isNumerical() 
              && blueValue.isNumerical(), 
              "non-numerical values in color expression"); 
        return Value(QColor(redValue.numericalValue(), 
                            greenValue.numericalValue(), 
                            blueValue.numericalValue())); 
      } 
```

A font expression is made up by the keyword `font` and two expressions: the name of the font (string) and its size (numerical):

```cpp
    case FontId: { 
        match(FontId); 
        match(LeftParenthesisId); 
        Value nameValue = expression(); 
        match(CommaId); 
        Value sizeValue = expression(); 
        match(RightParenthesisId); 
        check(nameValue.isString() && sizeValue.isNumerical(), 
              "invalid types in font expression"); 
        return Value(QFont(nameValue.stringValue(), 
                           sizeValue.numericalValue())); 
      } 
```

An expression can be enclosed by parentheses. In that case, we match the parentheses and call `expression` in between to obtain the value of the expression:

```cpp
    case LeftParenthesisId: { 
        match(LeftParenthesisId); 
        Value value = expression(); 
        match(RightParenthesisId); 
        return value; 
      } 
```

In case of a name, we look up its value in the assignment map and return the value. If there is no value, a semantic error is reported:

```cpp
    case NameId: { 
        QString lookupName = m_lookAHead.name(); 
        match(NameId); 
        check(m_assignMap.contains(lookupName ), 
              "unknown name: "" + lookupName + ""."); 
        return m_assignMap[lookupName ]; 
      } 
```

In the case of a value, we simply return the value:

```cpp
    case ValueId: { 
        Value value = m_lookAHead.value(); 
        match(ValueId); 
        return value; 
      } 
```

In any other case, a syntax error is reported:

```cpp
    default: 
      syntaxError(); 
      return Value(); 
  } 
} 
```

# Type checking the expression

The first `checkType` method checks the type of an expression with one value. When setting a pen or brush style, the type must be a pen or brush style, respectively:

```cpp
void Parser::checkType(TokenId codeId, const Value& value) { 
  switch (codeId) { 
    case SetPenStyleId: 
      check(value.isPenStyle(), "not a pen-style value"); 
      break; 

    case SetBrushStyleId: 
      check(value.isBrushStyle(), "not a brush-style value"); 
      break; 
```

When setting a color or a font, the value must be a color or a font, respectively:

```cpp
    case SetPenColorId: 
    case SetBrushColorId: 
      check(value.isColor(), "not a color value"); 
      break; 

    case SetFontId: 
      check(value.isFont(), "not a font value"); 
      break; 
```

When setting an alignment, the value must be an alignment:

```cpp
    case SetHorizontalAlignmentId: 
    case SetVerticalAlignmentId: 
      check(value.isAlignment(), "not an alignment value"); 
      break; 
```

When extracting the *x* or *y* coordinate from a point, the value must be a point:

```cpp
    case XCoordinateId: 
    case YCoordinateId: 
      check(value.isPoint(), "not a point value"); 
      break; 
  } 
} 
```

The second `checkType` method takes two values. The drawing instructions must take two points:

```cpp
void Parser::checkType(TokenId codeId, const Value& leftValue, 
                       const Value& rightValue) { 
  switch (codeId) { 
    case DrawLineId: 
    case DrawRectangleId: 
    case DrawEllipseId: 
      check(leftValue.isPoint() && rightValue.isPoint(), 
            "non-point values in draw expression"); 
      break; 
```

The drawing of text instructions must take a point and a string:

```cpp
    case DrawTextId: 
      check(leftValue.isPoint() && rightValue.isString(), 
            "invalid values in text-drawing expression"); 
      break; 
  } 
} 
```

# Evaluating the values of the expressions

The first `evaluate` method returns the value of an expression with one value. The *x* and *y* coordinate operators return the *x* or *y* coordinate of the point:

```cpp
Value Parser::evaluate(TokenId codeId, const Value& value) { 
  switch (codeId) { 
    case XCoordinateId: 
      return Value((double) value.pointValue().x()); 

    case YCoordinateId: 
      return Value((double) value.pointValue().y()); 
```

The assertion is for debugging purposes only, and we return false simply because the method has to return a value:

```cpp
    default: 
      assert(false); 
      return false; 
  } 
} 
```

Finally, the second `evaluate` method evaluates the value of expressions with two values. First, we extract numerical values and evaluate the arithmetic expressions:

```cpp
Value Parser::evaluate(TokenId codeId, const Value& leftValue, 
                          const Value& rightValue) { 
  double leftNumericalValue = leftValue.numericalValue(), 
         rightNumericalValue = rightValue.numericalValue(); 

  switch (codeId) { 
    case AddId: 
      return Value(leftNumericalValue + rightNumericalValue); 

    case SubtractId: 
      return Value(leftNumericalValue - rightNumericalValue); 

    case MultiplyId: 
      return Value(leftNumericalValue * rightNumericalValue); 
```

In case of division by zero, a semantic error is reported:

```cpp
    case DivideId: 
      if (rightNumericalValue == 0) { 
        semanticError("division by zero"); 
      } 

      return Value(leftNumericalValue / rightNumericalValue); 
```

Finally, in the point expression, we return a point value holding the two numerical values holding its *x* and *y* coordinates:

```cpp
    case PointId: 
      return Value(QPoint(leftNumericalValue, 
                          rightNumericalValue)); 
```

As in the first evaluate case previously, the assertion is for debugging purposes only, and we return false simply because the method has to return a value:

```cpp
    default: 
      assert(false); 
      return Value(); 
  } 
} 
```

# The viewer

Finally, it is time to write the viewer, the last part of our DSL. The viewer iterates through the actions and displays the graphical objects. The `ViewerWidget` class inherits the Qt class `QWidget`, which displays a widget on the screen.

**ViewerWidget.h:**

```cpp
#ifndef MAINWIDGET_H 
#define MAINWIDGET_H 

#include <QWidget> 
#include <QtWidgets> 
#include "Value.h" 
#include "Colors.h" 
#include "Action.h" 

class ViewerWidget : public QWidget { 
  Q_OBJECT 
```

The constructor calls the constructor of the base class `QWidget` and stores a reference to the action list:

```cpp
  public: 
    ViewerWidget(const QList<Action>& actionList, 
                 QWidget *parentWidget = nullptr); 
```

The main part of the class is the `paintEvent` method. It gets called every time the widget needs to be repainted and iterates through the actions list:

```cpp
    void paintEvent(QPaintEvent *eventPtr); 
```

The default constructor of `QFont` is called, which initializes the font to an appropriate system font. Both the horizontal and vertical alignment is centered. Finally, `m_actionList` holds a reference to the action list generated by the parser:

```cpp
  private: 
    Qt::Alignment m_horizontalAlignment = Qt::AlignHCenter, 
                  m_verticalAlignment = Qt::AlignVCenter; 
    const QList<Action>& m_actionList; 
}; 

#endif // MAINWIDGET_H 
```

The `ViewerWidget.cpp` file holds the definitions of the methods of the `ViewerWidget` class.

**ViewerWidget.cpp:**

```cpp
#include <QtWidgets> 
#include "ViewerWidget.h" 
```

The constructor calls the constructor of the base class `QWidget` with the parent widget, initializes the `m_actionList` reference, sets the title of the widget, and sets an appropriate size:

```cpp
ViewerWidget::ViewerWidget(const QList<Action>& actionList, 
                           QWidget *parentWidget) 
 :QWidget(parentWidget), 
  m_actionList(actionList) { 
  setWindowTitle(tr("Domain Specific Language")); 
  resize(500, 300); 
} 
```

The `paintEvent` method is called every time the widget needs to be repainted. First, the `QPainter` object `painter` is defined, we then iterate through the action list:

```cpp
void ViewerWidget::paintEvent(QPaintEvent* /*event*/) { 
  QPainter painter(this); 

  for (const Action& action : m_actionList) { 
    switch (action.id()) { 
```

The `SetPenColor` action creates a new pen with the new color and current style, which is added to `painter`. In the same way, the `SetPenStyle` action creates a pen with the new style and the current color:

```cpp
      case SetPenColorId: { 
          QColor penColor = action.value1().colorValue(); 
          QPen pen(penColor); 
          pen.setStyle(painter.pen().style()); 
          painter.setPen(pen); 
        } 
        break; 

      case SetPenStyleId: { 
          Qt::PenStyle penStyle = action.value1().penStyleValue(); 
          QPen pen(penStyle); 
          pen.setColor(painter.pen().color()); 
          painter.setPen(pen); 
        } 
        break; 
```

We set the color and style of the brush in the same way as we set the pen previously. The only difference is that we create a brush instead of a pen:

```cpp
      case SetBrushColorId: { 
          QColor brushColor = action.value1().colorValue(); 
          QBrush brush(brushColor); 
          brush.setStyle(painter.brush().style()); 
          painter.setBrush(brush); 
        } 
        break; 

      case SetBrushStyleId: { 
          Qt::BrushStyle brushStyle = 
            action.value1().brushStyleValue(); 
          QBrush brush(brushStyle); 
          brush.setColor(painter.brush().color()); 
          painter.setBrush(brush); 
        } 
        break; 
```

In the case of the font, we call `setFont` on `painter`. Thereafter, the font is associated to `painter`, and will be used when writing text:

```cpp
      case SetFontId: { 
          QFont font = action.value1().fontValue(); 
          painter.setFont(font); 
        } 
        break; 
```

The horizontal and vertical alignment are stored in `m_horizontalAlignment` and `m_verticalAlignment`, which are values that are later used when writing text:

```cpp
      case SetHorizontalAlignmentId: 
        m_horizontalAlignment = action.value1().alignmentValue(); 
        break; 

      case SetVerticalAlignmentId: 
        m_verticalAlignment = action.value1().alignmentValue(); 
        break; 
```

Now, it is time to actually draw some graphical objects. A line is simply drawn between two points, while a rectangle or ellipse has top-left and bottom-right corners, which are placed in a rectangle that is used as a parameter to the calls to `drawRect` and `drawEllipse`:

```cpp
      case DrawLineId: 
        painter.drawLine(action.value1().pointValue(), 
                         action.value2().pointValue()); 
        break; 

      case DrawRectangleId: { 
          QRect rect(action.value1().pointValue(), 
                     action.value2().pointValue()); 

          painter.drawRect(rect); 
        } 
        break; 

      case DrawEllipseId: { 
          QRect rect(action.value1().pointValue(), 
                     action.value2().pointValue()); 

          painter.drawEllipse(rect); 
        } 
        break; 
```

Finally, we write text. We start by extracting the point to center the text around and the text to draw. We then obtain the size of the text (in pixels) with the Qt `QFontMetrics` class:

```cpp
      case DrawTextId:  { 
          QPoint point = action.value1().pointValue(); 
          const QString& text = action.value2().stringValue(); 
          QFontMetrics metrics(painter.font()); 
          QSize size = metrics.size(0, text); 
```

In the case of left horizontal alignment, the left side of the text is the *x* coordinate of the point. In the case of center alignment, the left side of the text is moved to the left with half the text width, and in the case of right alignment, the left side is moved to the left with the whole text width:

```cpp
          switch (m_horizontalAlignment) { 
            case Qt::AlignHCenter: 
              point.rx() -= size.width() / 2; 
              break; 

            case Qt::AlignRight: 
              point.rx() -= size.width(); 
              break; 
          } 
```

In the same way: in the case of top vertical alignment, the top side of the text is the *y* coordinate of the point. In the case of center alignment, the top side of the text is moved upwards with half of the text height, and in the case of bottom alignment, the top side is moved upwards with the whole text height:

```cpp
          switch (m_verticalAlignment) { 
            case Qt::AlignVCenter: 
              point.ry() -= size.height() / 2; 
              break; 

            case Qt::AlignBottom: 
              point.ry() -= size.height(); 
              break; 
          } 

          painter.drawText(point, text); 
        } 
        break; 
    } 
  } 
} 
```

# The main function

Finally, the main function calls the `init` static method on the scanner in order to initialize its tokens, keywords, and values. A `QApplication` object is created, the source code is read and parsed, and the viewer widget is created. It executes the action list and displays the graphical objects. The application executes until the user presses the close button in the top-right corner.

**Main.cpp:**

```cpp
#include <QApplication> 
#include <QMessageBox> 

#include "Action.h" 
#include "Error.h" 
#include "Scanner.h" 
#include "Parser.h" 
#include "ViewerWidget.h" 

int main(int argc, char *argv[]) { 
  Scanner::init(); 
  QApplication application(argc, argv); 

  try { 
    QString path = "C:\Input.dsl"; 
    QFile file(path); 
    if (!file.open(QIODevice::ReadOnly)) { 
      error("Cannot open file "" + path + "" for reading."); 
    } 

    QString buffer(file.readAll()); 
    Scanner scanner(buffer); 

    QList<Action> actionList; 
    Parser(scanner, actionList); 

    ViewerWidget mainWidget(actionList); 
    mainWidget.show(); 
    return application.exec(); 
  } 
```

In the case of a syntactic or semantic error, its message is displayed in a message box:

```cpp
  catch (exception e) { 
    QMessageBox messageBox(QMessageBox::Information, 
                           QString("Error"), QString(e.what())); 
    messageBox.exec(); 
  } 
} 
```

# Summary

In this chapter, we started to develop a DSL that generates a sequence of actions creating graphical objects, which are viewed in a widget. Our DSL supports instructions for drawing graphical objects such as lines, rectangles, ellipses, and text, and for setting the color, style, and alignment of the objects. It also supports expressions with arithmetic operators.

The language of our DSL is defined by grammar and is made up by a scanner that scans the text for meaningful parts, the parser checks that the source code complies with the grammar and generates a sequence of actions, which is read and executed by the viewer.

In the next chapter, we will continue to develop our DSL. The DSL of this chapter only supports code executed in straight sequence. However, in the next chapter, we will add function calls as well as selection and iteration (the `if` and `while` instructions).