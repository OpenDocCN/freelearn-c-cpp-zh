["```cpp\ntypedef enum\n{\n  ALL_OFF = 0,\n  RED_ON = 1,\n  RED_OFF = 2,\n  BLUE_ON = 3,\n  BLUE_OFF= 4,\n  GREEN_ON = 5,\n  GREEN_OFF = 6,\n  ALL_ON = 7\n\n}LED_CMDS;\n```", "```cpp\nstatic QueueHandle_t ledCmdQueue = NULL;\n```", "```cpp\nQueueHandle_t xQueueCreate( UBaseType_t uxQueueLength,\n                             UBaseType_t uxItemSize );\n```", "```cpp\nledCmdQueue = xQueueCreate(2, sizeof(uint8_t));\nassert_param(ledCmdQueue != NULL);\n```", "```cpp\nvoid recvTask( void* NotUsed )\n{\n  uint8_t nextCmd = 0;\n\n  while(1)\n  {\n    if(xQueueReceive(ledCmdQueue, &nextCmd, portMAX_DELAY) == pdTRUE)\n    {\n      switch(nextCmd)\n      {\n        case ALL_OFF:\n          RedLed.Off();\n          GreenLed.Off();\n          BlueLed.Off();\n        break;\n        case GREEN_ON:\n          GreenLed.On();\n        break;\n```", "```cpp\nvoid sendingTask( void* NotUsed )\n{\n  while(1)\n  {\n    for(int i = 0; i < 8; i++)\n    {\n      uint8_t ledCmd = (LED_CMDS) i;\n xQueueSend(ledCmdQueue, &ledCmd, portMAX_DELAY);\n      vTaskDelay(200/portTICK_PERIOD_MS);\n    }\n  }\n}\n```", "```cpp\ntypedef struct\n{\n  uint8_t redLEDState : 1; //specify this variable as 1 bit wide \n  uint8_t blueLEDState : 1; //specify this variable as 1 bit wide \n  uint8_t greenLEDState : 1; //specify this variable as 1 bit wide \n  uint32_t msDelayTime; //min number of mS to remain in this state\n}LedStates_t;\n```", "```cpp\nif(xQueueReceive(ledCmdQueue, &nextCmd, portMAX_DELAY) == pdTRUE)\n{\n    if(nextCmd.redLEDState == 1)\n        RedLed.On();\n    else\n        RedLed.Off();\n    if(nextCmd.blueLEDState == 1)\n        BlueLed.On();\n    else\n        BlueLed.Off();\n    if(nextCmd.greenLEDState == 1)\n        GreenLed.On();\n    else\n        GreenLed.Off();\n}\nvTaskDelay(nextCmd.msDelayTime/portTICK_PERIOD_MS);\n```", "```cpp\nwhile(1)\n  {\n    nextStates.redLEDState = 1;\n    nextStates.greenLEDState = 1;\n    nextStates.blueLEDState = 1;\n    nextStates.msDelayTime = 100;\n\n    xQueueSend(ledCmdQueue, &nextStates, portMAX_DELAY);\n\n    nextStates.blueLEDState = 0; //turn off just the blue LED\n    nextStates.msDelayTime = 1500;\n    xQueueSend(ledCmdQueue, &nextStates, portMAX_DELAY);\n\n    nextStates.greenLEDState = 0;//turn off just the green LED\n    nextStates.msDelayTime = 200;\n    xQueueSend(ledCmdQueue, &nextStates, portMAX_DELAY);\n\n    nextStates.redLEDState = 0;\n    xQueueSend(ledCmdQueue, &nextStates, portMAX_DELAY);\n  }\n```", "```cpp\nxTaskCreate(recvTask, \"recvTask\", STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, \n            NULL);\nxTaskCreate(sendingTask, \"sendingTask\", STACK_SIZE, NULL, \n            configMAX_PRIORITIES â€“ 1, NULL);\n\n```", "```cpp\n#define MAX_MSG_LEN 256\ntypedef struct\n{\n  uint32_t redLEDState : 1;\n  uint32_t blueLEDState : 1;\n  uint32_t greenLEDState : 1;\n  uint32_t msDelayTime; //min number of mS to remain in this state\n  //an array for storing strings of up to 256 char\n  char message[MAX_MSG_LEN];\n}LedStates_t;\n```", "```cpp\nstatic LedStates_t ledState1 = {1, 0, 0, 1000, \n  \"The quick brown fox jumped over the lazy dog.\n  The Red LED is on.\"};\nstatic LedStates_t ledState2 = {0, 1, 0, 1000,\n  \"Another string. The Blue LED is on\"};\n```", "```cpp\nvoid sendingTask( void* NotUsed )\n{\n  LedStates_t* state1Ptr = &ledState1;\n  LedStates_t* state2Ptr = &ledState2;\n\n  while(1)\n  {\n    xQueueSend(ledCmdQueue, &state1Ptr, portMAX_DELAY);\n    xQueueSend(ledCmdQueue, &state2Ptr, portMAX_DELAY);\n  }\n}\n```", "```cpp\nvoid recvTask( void* NotUsed )\n{\n    LedStates_t* nextCmd;\n\n    while(1)\n    {\n        if(xQueueReceive(ledCmdQueue, &nextCmd, portMAX_DELAY) == \n                                                           pdTRUE)\n        {\n            if(nextCmd->redLEDState == 1)\n            RedLed.On();\n```", "```cpp\nvoid func( void ) \n{\n    static struct MyBigStruct myVar;\n```", "```cpp\n#define RED_LED_MASK 0x0001\n#define BLUE_LED_MASK 0x0002\n#define GREEN_LED_MASK 0x0004\nstatic xTaskHandle recvTaskHandle = NULL; \n```", "```cpp\nretVal = xTaskCreate(recvTask, \"recvTask\", STACK_SIZE, NULL, \n                     tskIDLE_PRIORITY + 2, &recvTaskHandle);\nassert_param( retVal == pdPASS);\nassert_param(recvTaskHandle != NULL);\n```", "```cpp\nvoid recvTask( void* NotUsed )\n{\n    while(1)\n    {\n        uint32_t notificationvalue = ulTaskNotifyTake( pdTRUE, \n                                              portMAX_DELAY );\n        if((notificationvalue & RED_LED_MASK) != 0)\n            RedLed.On();\n        else\n            RedLed.Off();\n```", "```cpp\nvoid sendingTask( void* NotUsed )\n{\n    while(1)\n    {\n xTaskNotify( recvTaskHandle, RED_LED_MASK,\n eSetValueWithOverwrite);\n        vTaskDelay(200);\n```", "```cpp\neNoAction = 0, /* Notify the task without updating its notify value. */\n eSetBits, /* Set bits in the task's notification value. */\n eIncrement, /* Increment the task's notification value. */\n eSetValueWithOverwrite, /* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */\n eSetValueWithoutOverwrite /* Set the task's notification value if the previous value has been read by the task. */\n```"]