<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Optimizing Code with Metaprogramming</h1>
                </header>
            
            <article>
                
<p>We discussed the optimizing techniques using lazy evaluation in the previous chapter, and used the delaying process, caching technique, and memoization to make our code run fast. In this chapter, we will optimize the code using <strong>metaprogramming</strong>, where we will create a code that will create more code. The topics we will discuss in this chapter are as follows:</p>
<ul>
<li><span>Introduction to metaprogramming</span></li>
<li>The part that builds the template metaprogramming</li>
<li>Refactoring flow control into template metaprogramming</li>
<li>Running the code in the compile-time execution</li>
<li>The advantages and disadvantages of template metaprogramming</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to metaprogramming</h1>
                </header>
            
            <article>
                
<p>The simplest way to say this is that metaprogramming is a technique that creates a code by using a code. Implementing metaprogramming, we write a computer program that manipulates the other programs and treats them as its data. In addition, templates are a compile-time mechanism in C++ that is <strong>Turing-complete</strong>, which means any computation expressible by a computer program can be computed, in some form, by a template metaprogram before runtime. It also uses recursion a lot and has immutable variables. So, in metaprogramming, we create code that will run when the code is compiled.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preprocessing the code using a macro</h1>
                </header>
            
            <article>
                
<p>To start our discussion on metaprogramming, let's go back to the era when the ANSI C programming language was a popular language. For simplicity, we used the C preprocessor by creating a macro. The C parameterized macro is also known as <strong>metafunctions</strong>, and is one of the examples of metaprogramming. Consider the following parameterized macro:</p>
<pre>
    #define MAX(a,b) (((a) &gt; (b)) ? (a) : (b))
</pre>
<p>Since the C++ programming language has a drawback compatibility to the C language, we can compile the preceding macro using our C++ compiler. Let's create the code to consume the preceding macro, which will be as follows:</p>
<pre class="mce-root">
    /* macro.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Defining macro<br/>    #define MAX(a,b) (((a) &gt; (b)) ? (a) : (b))<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[macro.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing two int variables<br/>      int x = 10;<br/>      int y = 20;<br/><br/>      // Consuming the MAX macro<br/>      // and assign the result to z variable<br/>      int z = MAX(x,y);<br/><br/>      // Displaying the result<br/>      cout &lt;&lt; "Max number of " &lt;&lt; x &lt;&lt; " and " &lt;&lt; y;<br/>      cout &lt;&lt; " is " &lt;&lt; z &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding <kbd>macro.cpp</kbd> code, we pass two arguments to the <kbd>MAX</kbd> macro since it is a parameterized macro, which means the parameter can be obtained from the users. If we run the preceding code, we should see the following output on the console:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/c3415c09-ba2c-4b3c-9377-afd18f2d9d30.png"/></div>
<p>As we discussed at the beginning of this chapter, metaprogramming is a code that will run in compile time. By using a macro in the preceding code, we can demonstrate there's a new code generated from the <kbd>MAX</kbd> macro. The preprocessor will parse the macro in compile time and bring the new code. In compile time, the compiler modifies the code as follows:</p>
<pre>
    auto main() -&gt; int<br/>    {<br/>      // same code<br/>      // ...<br/>    <br/>      int z = (((a) &gt; (b)) ? (a) : (b)); // &lt;-- Notice this section<br/> <br/>      // same code<br/>      // ...<br/><br/>      return 0;<br/>    }
</pre>
<p>Besides a one line macro preprocessor, we can also generate a multiline macro metafunction. To achieve this, we can use the backslash character at the end of the line. Let's suppose we need to swap the two values. We can create a parameterized macro named <kbd>SWAP</kbd> and consume it like the following code:</p>
<pre class="mce-root">
    /* macroswap.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Defining multi line macro<br/>    #define SWAP(a,b) { \<br/>      (a) ^= (b); \<br/>      (b) ^= (a); \<br/>      (a) ^= (b); \<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[macroswap.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing two int variables<br/>      int x = 10;<br/>      int y = 20;<br/><br/>      // Displaying original variable value<br/>      cout &lt;&lt; "before swapping" &lt;&lt; endl;<br/>      cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y ;<br/>      cout &lt;&lt; endl &lt;&lt; endl;<br/><br/>      // Consuming the SWAP macro<br/>      SWAP(x,y);<br/><br/>      // Displaying swapped variable value<br/>      cout &lt;&lt; "after swapping" &lt;&lt; endl;<br/>      cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y;<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we will create a multiline preprocessor macro and use backslash characters at the end of each line. Each time we invoke the <kbd>SWAP</kbd> parameterized macro, it will then be replaced with the implementation of the macro. We will see the following output on the console if we run the preceding code:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/502d5c3f-23b1-4998-b4c8-04ea9ef089bf.png"/></div>
<p>Now we have a basic understanding of the metaprogramming, especially in metafunction, we can move further in the next topics.</p>
<div class="packt_tip">We use parenthesis for each variable in every implementation of the macro preprocessor because the preprocessor is simply replacing our code with the implementation of the macro. Let's suppose we have the following macro:<br/>
<kbd>MULTIPLY(a,b) (a * b)<br/></kbd>It won't be a problem if we pass the number as the parameters. However, if we pass an operation as the argument, a problem will occur. For instance, if we use the <kbd>MULTIPLY</kbd> macro as follows:<br/>
<kbd>MULTIPLY(x+2,y+5);</kbd><br/>
<span>Then the compiler will replace it as <kbd>(x+2*y+5)</kbd>. This happens because the macro just replaces the <kbd>a</kbd> variable with the <kbd>x + 2</kbd> expression and the <kbd>b</kbd> variable with the <kbd>y + 5</kbd> expression, with any additional parentheses.</span> <span>And because the order of multiplication is higher than addition, we will have got the result as follows:</span><br/>
<kbd>(x+2y+5)</kbd><br/>
And that is not what we expect. As a result, the best approach is to use parenthesis in each variable of the parameter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dissecting template metaprogramming in the Standard Library</h1>
                </header>
            
            <article>
                
<p>We discussed the Standard Library in <a href="58c8c3cc-432a-4664-be4d-a78917b16f15.xhtml" target="_blank">Chapter 1</a>, <em>Diving into Modern C++</em>, and dealt with it in the previous chapter too. The Standard Library provided in the C++ language is mostly a template that contains an incomplete function. However, it will be used to generate complete functions. The template metaprogramming is the C++ template to generate C++ types and code in compile time.</p>
<p>Let's pick up one of the classes in the Standard Library--the <kbd>Array</kbd> class. In the <kbd>Array</kbd> class, we can define a data type for it. When we instance the array, the compiler actually <span>generates the code for an array of the data type we define. Now, let's try to build a simple</span> <kbd>Array</kbd> <span>template implementation as follows:<br/></span></p>
<pre class="lang:default decode:true notranslate">
    template&lt;typename T&gt;<br/><span class="code-keyword">    class</span> Array<br/>    {<br/>      T element;<br/>    };
</pre>
<p>Then, we instance the <kbd>char</kbd> and <kbd>int</kbd> arrays as follows:</p>
<pre class="lang:default decode:true notranslate">
    Array&lt;char&gt; arrChar;<br/>    Array&lt;int&gt; arrInt;
</pre>
<p>What the compiler does is it creates these two implementations of the template based on the data type we define. Although we won't see this in the code, the compiler actually creates the following code:</p>
<pre class="lang:default decode:true notranslate">
<span class="code-keyword">    class</span> ArrayChar<br/>    {<br/>      char element;<br/>    };<br/><br/><span class="code-keyword">    class</span> ArrayInt<br/>    {<br/>      int element;<br/>    };<br/><br/>    ArrayChar arrChar;<br/>    ArrayInt arrInt;
</pre>
<p>As we can see in the preceding code snippet, the template metaprogramming is a code that creates another code in compile time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the template metaprogramming</h1>
                </header>
            
            <article>
                
<p>Before we go further in the template metaprogramming discussion, it's better if we discuss the skeleton that builds the template metaprogramming. There are four factors that form the template metaprogramming--<strong>type</strong>, <strong>value</strong>, <strong>branch</strong>, and <strong>recursion</strong>. In this topic, we will dig into the factors that form the template.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a value to the variable in the template</h1>
                </header>
            
            <article>
                
<p><span>At the beginning of this chapter, we discussed the concept of metafunction when we talked about the macro preprocessor. In the macro preprocessor, we explicitly manipulate the source code; in this case, the macro (metafunction) manipulates the source code. In contrast, we work with types in C++ template metaprogramming. This means the metafunction is a function that works with types. So, the better approach to use template metaprogramming is working with type parameters only when possible. When we are talking about the variables in template metaprogramming, it's actually not a variable since the value on it cannot be modified. What we need from the variable is its name so we can access it. Because we will code with types, the named values are</span> <kbd>typedef</kbd>, <span>as we can see in the following code snippet:<br/></span></p>
<pre>
<span class="k">    struct</span> <span class="n">ValueDataType<br/>    {</span><br/><span class="k">      typedef</span> <span class="kt">int</span> <span class="n">valueDataType</span><span class="p">;</span><br/><span class="p">    };</span>
</pre>
<p><span>By using the preceding code, we store the <kbd>int</kbd> type to the <kbd>valueDataType</kbd> alias name so we can access the data type using the <kbd>valueDataType</kbd> variable. If we need to store a value instead of the data type to the variable, we can use <kbd>enum</kbd> so it will be the data member of the <kbd>enum</kbd> itself. Let's take a look at the following code snippet if we want to store the value:<br/></span></p>
<pre>
<span class="k">    struct</span> <span class="n">ValuePlaceHolder<br/>    {</span><br/>      enum <br/>       { <br/><span class="kt">        value = 1</span><span class="n"> <br/>       }</span><span class="p">;</span><br/><span class="p">    };</span>
</pre>
<p><span>Based on the preceding code snippet, we can now access the <kbd>value</kbd> variable to fetch its value.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapping a function to the input parameters</h1>
                </header>
            
            <article>
                
<p><span>We can add the variable to the template metaprogramming. Now, what we have to do next is retrieve the user parameters and map them to a function. Let's suppose we want to develop a <kbd>Multiplexer</kbd> function that will multiply two values and we have to use the template metaprogramming. The following code snippet can be used to solve this problem:<br/></span></p>
<pre>
<span class="k">    template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">B</span><span class="o">&gt;</span><br/><span class="k">    struct</span> <strong><span class="n">Multiplexer</span></strong><br/><span class="p">    {</span><br/><span class="k">      enum</span> <br/><span class="p">      {</span><br/><span class="n">        result</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span> <br/><span class="p">      };</span><br/><span class="p">    };</span>
</pre>
<p><span>As we can see in the preceding code snippet, the template requires two arguments, <kbd>A</kbd> and <kbd>B</kbd>, from the user, and it will use them to get the value of <kbd>result</kbd> variable by multiplying these two parameters. We can access the result variable using the following code:<br/></span></p>
<pre>
<span class="p">    int i = Multiplex<span>er&lt;2, 3&gt;::result;</span></span>
</pre>
<p><span>If we run the preceding code snippet, the <kbd>i</kbd> variable will store <kbd>6</kbd> since it will calculate <kbd>2</kbd> times <kbd>3</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing the correct process based on the condition</h1>
                </header>
            
            <article>
                
<p><span>When we have more than one function, we have to choose one over the others based on certain conditions. We can construct the conditional branch by providing two alternative specializations of the <kbd>template</kbd> class, as shown here:<br/></span></p>
<pre>
<span class="k">    template</span><span class="o">&lt;</span><span class="k">typename</span> A<span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="o">&gt;</span><br/><span class="k">    struct</span> Checking<span class="n">Type</span><br/><span class="p">    {</span><br/><span class="k">      enum</span> <br/><span class="p">      {</span> <br/><span class="n">        result</span> <span class="o">=</span> <span class="mi">0</span> <br/><span class="p">      };</span><br/><span class="p">    };</span><br/><br/><span class="k">    template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span><br/><span class="k">    struct</span> Checking<span class="n">Type</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="o">&gt;</span><br/><span class="p">    {</span><br/><span class="k">      enum</span> <br/><span class="p">      {</span> <br/><span class="n">        result</span> <span class="o">=</span> <span class="mi">1</span> <br/><span class="p">      };</span><br/><span class="p">    };</span>
</pre>
<p><span>As we can see in the preceding <kbd>template</kbd> code, we have two templates that have <kbd>X</kbd> and <kbd>A</kbd>/<kbd>B</kbd> as their type. When the template has only a single type, that is, <kbd>typename X</kbd>, it means that the two types (<kbd>CheckingType &lt;X, X&gt;</kbd>) we compare are exactly the same. Otherwise, these two data types are different. The following code snippet can be used to consume the two preceding templates:<br/></span></p>
<pre>
<span class="k">    if</span> <span class="p">(Checking</span><span class="n">Type</span><span class="o">&lt;<strong>Unknown</strong></span><strong><span class="n">Type</span></strong><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">result</span><span class="p">)</span><br/><span class="p">    {</span><br/><span class="c1">      // run the function if the </span><span class="o">Unknown</span><span class="n">Type is int<br/></span><span class="p">    }</span> <br/><span class="k">    else</span> <br/><span class="p">    {</span> <br/><span class="c1">      // otherwise run any function</span> <br/><span class="p">    }</span>
</pre>
<p>As we can see in the preceding code snippet, we try to compare the <kbd><span><span>UnknownType</span></span></kbd> <span class="n">data type with the <kbd>int</kbd> type. The <kbd><span class="o">Unknown</span>Type</kbd></span> data type <span class="n">might be coming from the other process. Then, we can decide the next process we want to run by comparing these two types using templates.</span></p>
<div class="packt_infobox">Up to here, you might wonder how template multiprogramming will help us make code optimization. Soon we will use the template metaprogramming to optimize code. However, we need to discuss other things that will solidify our knowledge in template multiprogramming. For now, please be patient and keep reading.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Repeating the process recursively</h1>
                </header>
            
            <article>
                
<p><span>We have successfully added value and data type to the template, then created a branch to decide the next process based on the current condition. Another thing we have to consider in the basic template is repeating the process. However, since the variable in the template is immutable, we cannot iterate the sequence. Instead, we have to recur the process as we discussed in <a href="7c3fb034-5951-4003-905f-48dd745a1c6f.xhtml" target="_blank">Chapter 4</a>,</span> <em>Repeating Method Invocation Using Recursive Algorithm</em><span>.<br/>
Let's suppose we are developing a template to calculate the factorial value. The first thing we have to do is develop a general template that passes the <kbd>I</kbd> value to the function as follows:<br/></span></p>
<pre>
<span class="k">    template</span> <span class="o">&lt;</span><span class="kt">int I</span><span class="o">&gt;</span><br/><span class="k">    struct</span> F<span class="n">actorial</span><br/><span class="p">    {</span><br/><span class="k">      enum</span> <br/><span class="p">      {</span> <br/><span class="n">        value</span> <span class="o">=</span> <span class="n">I</span> <span class="o">*</span> F<span class="n">actorial</span><span class="o">&lt;</span><span class="n">I</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span> <br/><span class="p">      };</span><br/><span class="p">    };</span>
</pre>
<p><span>As we can see in the preceding code, we can obtain the value of the factorial by running the following code:<br/></span></p>
<pre>
    F<span class="n">actorial&lt;I&gt;::value;</span>
</pre>
<p><span>In the preceding code, <kbd>I</kbd> is an integer number.<br/>
Next, we have to develop a template to ensure that it doesn't end up with an infinite loop. We can create the following template that passes zero (<kbd>0</kbd>) as a parameter to it:<br/></span></p>
<pre>
<span class="k">    template</span> <span class="o">&lt;&gt;</span><br/><span class="k">    struct</span> F<span class="n">actorial</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><br/><span class="p">    {</span><br/><span class="k">      enum</span> <br/><span class="p">      {</span> <br/><span class="n">        value</span> <span class="o">=</span> <span class="mi">1</span> <br/><span class="p">      };</span><br/><span class="p">    };</span>
</pre>
<p><span>Now we have a pair of templates that will generate the value of the factorial in compile time. The following is a sample code to get the value of <kbd>Factorial(10)</kbd> in compile time:<br/></span></p>
<pre>
<span class="kt">    int</span> <span class="nf">main</span><span class="p">()<br/></span><span class="p">    {</span><br/><span class="kt">      int</span> <span class="n">fact10 = F</span><span class="n">actorial</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span><br/><span class="p">    }</span>
</pre>
<p><span>If we run the preceding code, we will get <kbd>3628800</kbd> as a result of the factorial of <kbd>10</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting a type in compile-time</h1>
                </header>
            
            <article>
                
<p>As we discussed in the preceding topic, <kbd>type</kbd> is a basic part of a template. However, we can select a certain type based on the input from the user. Let's create a template that can decide what type should be used in the variable. The following <kbd>types.cpp</kbd> code will show the implementation of the template:</p>
<pre class="lang:default decode:true notranslate">
    /* types.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/><strong>    // Defining a data type</strong><br/><strong>    // in template</strong><br/><strong>    template&lt;typename T&gt;</strong><br/><strong>    struct datatype</strong><br/><strong>    {</strong><br/><strong>      using type = T;</strong><br/><strong>    };</strong><br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[types.cpp]" &lt;&lt; endl;<br/><br/>      // Selecting a data type in compile time<br/>      using t = typename datatype&lt;int&gt;::type;<br/><br/>      // Using the selected data type<br/>      t myVar = 123;<br/> <br/>      // Displaying the selected data type<br/>      cout &lt;&lt; "myVar = " &lt;&lt; myVar;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we have a template named <kbd>datatype</kbd>. This template can be used to select the <kbd>type</kbd> we pass to it. We can use the <kbd>using</kbd> keyword to assign a variable to a <kbd>type</kbd>. From the preceding <kbd>types.cpp</kbd> code, we will assign a <kbd>t</kbd> variable to <kbd>type</kbd> from the <kbd>datatype</kbd> template. The <kbd>t</kbd> variable now will be <kbd>int</kbd> since we passed the <kbd>int</kbd> data type to the template.<br/>
We can also create a code to select the correct data type based on the current condition. We will have an <kbd>IfElseDataType</kbd> template that takes three arguments which are <kbd>predicate</kbd>, the data type when the <kbd>predicate</kbd> parameter is true, and the data type when the <kbd>predicate</kbd> parameter is false. The code will look as follows:</p>
<pre class="lang:default decode:true notranslate">
    /* selectingtype.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Defining IfElseDataType template<br/>    template&lt;<br/>      bool predicate,<br/>      typename TrueType,<br/>      typename FalseType&gt;<br/>      struct IfElseDataType<br/>      {<br/>      };<br/><br/>    // Defining template for TRUE condition<br/>    // passed to 'predicate' parameter<br/>    template&lt;<br/>      typename TrueType,<br/>      typename FalseType&gt;<br/>      struct IfElseDataType&lt;<br/>       true,<br/>       TrueType,<br/>       FalseType&gt;<br/>       {<br/>         typedef TrueType type;<br/>       };<br/><br/>    // Defining template for FALSE condition<br/>    // passed to 'predicate' parameter<br/>    template&lt;<br/>      typename TrueType,<br/>      typename FalseType&gt;<br/>      struct IfElseDataType&lt;<br/>      false,<br/>      TrueType,<br/>      FalseType&gt;<br/>      {<br/>         typedef FalseType type;<br/>      };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[types.cpp]" &lt;&lt; endl;<br/><br/>      // Consuming template and passing<br/>      // 'SHRT_MAX == 2147483647'<br/>      // It will be FALSE<br/>      // since the maximum value of short<br/>      // is 32767<br/>      // so the data type for myVar<br/>      // will be 'int'<br/>      IfElseDataType&lt;<br/>        SHRT_MAX == 2147483647,<br/>        short,<br/>        int&gt;::type myVar;<br/><br/>      // Assigning myVar to maximum value<br/>      // of 'short' type<br/>      myVar = 2147483647;<br/><br/>      // Displaying the data type of myVar<br/>      cout &lt;&lt; "myVar has type ";<br/>      cout &lt;&lt; typeid(myVar).name() &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>Now, by having the <kbd>IfElseDataType</kbd> <span>template, we can select the correct type to the variable based on the condition we have. Let's suppose we want to assign</span> <kbd>2147483647</kbd> to a variable so we can check if it's a short number. If so, <kbd>myVar</kbd> will be of type <kbd>short</kbd>, otherwise, it will be <kbd>int</kbd>. Moreover, since the maximum value of <kbd>short</kbd> type is <kbd>32767</kbd>, by giving the predicate as <kbd>SHRT_MAX == 2147483647</kbd> will be resulting <kbd>FALSE</kbd>. Therefore, the type of <kbd>myVar</kbd> will be an <kbd>int</kbd> type, as we can see in the following output that will appear on the console:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/c9f65a57-9612-429f-82b7-55741f74cc50.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Flow control with template metaprogramming</h1>
                </header>
            
            <article>
                
<p>Code flow is an important aspect in coding a program. In many programming languages, they have an <kbd>if-else</kbd>, <kbd>switch</kbd>, and <kbd>do-while</kbd> statement to arrange the flow of the code. Now, let's refactor the usual flow of code to become a template-based flow. We will start by using the <kbd>if-else</kbd> statement, followed by the <kbd>switch</kbd> statement, and finally ending with the <kbd>do-while</kbd> statement, all in templates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deciding the next process by the current condition</h1>
                </header>
            
            <article>
                
<p>Now it's time to use the template as we discussed previously. Let's suppose we have two functions that we have to choose by a certain condition. What we usually do is use the <kbd>if-else</kbd> statement as follows:</p>
<pre class="lang:default decode:true notranslate">
    /* condition.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Function that will run<br/>    // if the condition is TRUE<br/>    void TrueStatement()<br/>    {<br/>      cout &lt;&lt; "True Statement is run." &lt;&lt; endl;<br/>    }<br/><br/>    // Function that will run<br/>    // if the condition is FALSE<br/>    void FalseStatement()<br/>    {<br/>      cout &lt;&lt; "False Statement is run." &lt;&lt; endl;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[condition.cpp]" &lt;&lt; endl;<br/><br/>      // Choosing the function<br/>      // based on the condition<br/>      if (2 + 3 == 5)<br/>        TrueStatement();<br/>      else<br/>        FalseStatement();<br/><br/>      return 0;<br/>    }
</pre>
<p><span>As we can see in the preceding code, we have two functions--<kbd>TrueStatement()</kbd> and <kbd>FalseStatement()</kbd>. We also have a condition in the code--</span><kbd>2 + 3 == 5</kbd>. And since the condition is <kbd>TRUE</kbd>, then the <kbd>TrueStatement()</kbd> <span>function will be run as we can see in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/9e5c6760-bbad-42e6-9208-48d2213aca67.png"/></div>
<p><span>Now, let's refactor the preceding <kbd>condition.cpp</kbd> code. We will create three templates here. First, the template initialization that inputs the condition as follows:<br/></span></p>
<pre class="lang:default decode:true notranslate">
    template&lt;bool predicate&gt; class IfElse
</pre>
<p><span>Then, we create two templates for each condition--<kbd>TRUE</kbd> or <kbd>FALSE</kbd>. The name will be as follows:<br/></span></p>
<pre class="lang:default decode:true notranslate">
    template&lt;&gt; class IfElse&lt;true&gt;<br/>    template&lt;&gt; class IfElse&lt;false&gt; 
</pre>
<p><span>Each template in the preceding code snippet will run the functions we have created before--the <kbd>TrueStatement()</kbd> and <kbd>FalseStatement()</kbd> functions. And we will get the complete code as the following</span> <kbd>conditionmeta.cpp</kbd> code:</p>
<pre class="lang:default decode:true notranslate">
    /* conditionmeta.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Function that will run<br/>    // if the condition is TRUE<br/>    void TrueStatement()<br/>    {<br/>      cout &lt;&lt; "True Statement is run." &lt;&lt; endl;<br/>    }<br/><br/>    // Function that will run<br/>    // if the condition is FALSE<br/>    void FalseStatement()<br/>    {<br/>      cout &lt;&lt; "False Statement is run." &lt;&lt; endl;<br/>    }<br/><br/>    // Defining IfElse template<br/>    template&lt;bool predicate&gt;<br/>    class IfElse<br/>    {<br/>    };<br/><br/>    // Defining template for TRUE condition<br/>    // passed to 'predicate' parameter<br/>    template&lt;&gt;<br/>    class IfElse&lt;true&gt;<br/>    {<br/>      public:<br/>        static inline void func()<br/>        {<br/>          TrueStatement();<br/>        }<br/>    };<br/><br/>    // Defining template for FALSE condition<br/>    // passed to 'predicate' parameter<br/>    template&lt;&gt;<br/>    class IfElse&lt;false&gt;<br/>    {<br/>      public:<br/>        static inline void func()<br/>        {<br/>          FalseStatement();<br/>        }<br/>    };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[conditionmeta.cpp]" &lt;&lt; endl;<br/><br/>      // Consuming IfElse template<br/>      <strong>IfElse&lt;(2 + 3 == 5)&gt;::func();</strong><br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see, we put the condition on the bracket of the <kbd>IfElse</kbd> template, then call the <kbd>func()</kbd> method inside the template. If we run the <kbd>conditionmeta.cpp</kbd> <span>code</span>, we will get the exact same output such as the <kbd>condition.cpp</kbd> <span>code, as shown here:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/52dfab6d-8e80-4036-9e19-95f40d013725.png"/></div>
<p><span>We now have the <kbd>if-else</kbd> statement to flow our code in the template metaprogramming.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting the correct statement</h1>
                </header>
            
            <article>
                
<p>In C++ programming, and other programming languages as well, we use the <kbd>switch</kbd> statement to select a certain process based on the value we give to the <kbd>switch</kbd> statement. If the value matches with the one of the switch case, it will run the process under that case. Let's take a look at the following <kbd>switch.cpp</kbd> code that implements the <kbd>switch</kbd> statement:</p>
<pre class="lang:default decode:true notranslate">
    /* switch.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Function to find out<br/>    // the square of an int<br/>    int Square(int a)<br/>    {<br/>      return a * a;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[switch.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing two int variables<br/>      int input = 2;<br/>      int output = 0;<br/><br/>      // Passing the correct argument<br/>      // to the function<br/>      switch (input)<br/>      {<br/>        case 1:<br/>            output = Square(1);<br/>            break;<br/>        case 2:<br/>            output = Square(2);<br/>            break;<br/>        default:<br/>            output = Square(0);<br/>            break;<br/>      }<br/><br/>      // Displaying the result<br/>      cout &lt;&lt; "The result is " &lt;&lt; output &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we have a function named <kbd>Square()</kbd> that takes an argument. The argument we pass to it is based on the value that we give to the switch statement. Since the value we pass to switch is <kbd>2</kbd>, the <kbd>Square(2)</kbd> method will be run. The following screenshot is what we will see on the console screen:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/bb934a6e-293e-47b9-b771-cb7d9da4832f.png"/></div>
<p><span>To refactor the <kbd>switch.cpp</kbd> code to template metaprogramming, we have to create three templates that consist of the function we plan to run. First, we will create the initialization template to retrieve the value from the user, as follows:<br/></span></p>
<pre class="lang:default decode:true notranslate">
    template&lt;int val&gt; class SwitchTemplate 
</pre>
<p><span>The preceding initialization template will also be used for the default value. Next, we will add two templates for each possible value as follows:<br/></span></p>
<pre class="lang:default decode:true notranslate">
    template&lt;&gt; class SwitchTemplate&lt;1&gt;<br/>    template&lt;&gt; class SwitchTemplate&lt;2&gt; 
</pre>
<p><span>Each preceding template will run the <kbd>Square()</kbd> function and pass the argument based on the value of the template. The complete code is written as follows:</span></p>
<pre class="lang:default decode:true notranslate">
    /* switchmeta.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Function to find out<br/>    // the square of an int<br/>    int Square(int a)<br/>    {<br/>      return a * a;<br/>    }<br/><br/>    // Defining template for<br/>    // default output<br/>    // for any input value<br/>    template&lt;int val&gt;<br/>    class SwitchTemplate<br/>    {<br/>      public:<br/>        static inline int func()<br/>        {<br/>          return Square(0);<br/>        }<br/>    };<br/><br/>    // Defining template for<br/>    // specific input value<br/>    // 'val' = 1<br/>    template&lt;&gt;<br/>    class SwitchTemplate&lt;1&gt;<br/>    {<br/>       public:<br/>         static inline int func()<br/>         {<br/>           return Square(1);<br/>         }<br/>    };<br/><br/>    // Defining template for<br/>    // specific input value<br/>    // 'val' = 2<br/>    template&lt;&gt;<br/>    class SwitchTemplate&lt;2&gt;<br/>    {<br/>       public:<br/>         static inline int func()<br/>         {<br/>            return Square(2);<br/>         }<br/>    };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[switchmeta.cpp]" &lt;&lt; endl;<br/><br/>      // Defining a constant variable<br/>      const int i = 2;<br/><br/>      // Consuming the SwitchTemplate template<br/>      int output = SwitchTemplate&lt;i&gt;::func();<br/><br/>      // Displaying the result<br/>      cout &lt;&lt; "The result is " &lt;&lt; output &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see, we do the same as <kbd>conditionmeta.cpp</kbd>--we call the <kbd>func()</kbd> method inside the template to run the selected function. The value for this <kbd>switch-case</kbd> condition is the template we put in the angle bracket. If we run the preceding <kbd>switchmeta.cpp</kbd> code, we will see the following output on the console:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/eeb896aa-2598-4995-b3b0-bbb61386f762.png"/></div>
<p><span>As we can see in the preceding screenshot, we've got the exact same output for <kbd>switchmeta.cpp</kbd> code as compared to the <kbd>switch.cpp</kbd> code. Thus, we have successfully refactored the <kbd>switch.cpp</kbd> code into the template metaprogramming.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Looping the process</h1>
                </header>
            
            <article>
                
<p>We usually use the <kbd>do-while</kbd> loop when we iterate something. Let's suppose we need to print certain numbers until it reaches zero (<kbd>0</kbd>). The code is as follows:</p>
<pre class="lang:default decode:true notranslate">
    /* loop.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Function for printing<br/>    // given number<br/>    void PrintNumber(int i)<br/>    {<br/>      cout &lt;&lt; i &lt;&lt; "\t";<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[loop.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing an int variable<br/>      // marking as maximum number<br/>      int i = 100;<br/><br/>      // Looping to print out<br/>      // the numbers below i variable<br/>      cout &lt;&lt; "List of numbers between 100 and 1";<br/>      cout &lt;&lt; endl;<br/>      do<br/>      {<br/>        PrintNumber(i);<br/>      }<br/>      while (--i &gt; 0);<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we will print the number <kbd>100</kbd>, decrease its value, and print again. It will always run until the number reaches zero (<kbd>0</kbd>). The output on the console should be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="218" src="assets/1a84c23b-dd08-4dfc-99a6-273c36918e06.png" width="583"/></div>
<p><span>Now, let's refactor it to the template metaprogramming. Here, we need only two templates to achieve the <kbd>do-while</kbd></span> loop <span>in template metaprogramming. First, we will create the following template:</span></p>
<pre class="lang:default decode:true notranslate">
    template&lt;int limit&gt; class DoWhile
</pre>
<p><span>The limit in the preceding code is the value that is passed to the <kbd>do-while</kbd> loop. And, to not make the loop become an infinite loop, we have to design the <kbd>DoWhile</kbd> template when it has reached zero (<kbd>0</kbd>), as shown here:<br/></span></p>
<pre class="lang:default decode:true notranslate">
    template&lt;&gt; class DoWhile&lt;0&gt;
</pre>
<p><span>The preceding template will do nothing since it's used only to break the loop. The complete refactoring of the <kbd>do-while</kbd> loop is like the following <kbd>loopmeta.cpp</kbd> code:</span></p>
<pre class="lang:default decode:true notranslate">
    /* loopmeta.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Function for printing<br/>    // given number<br/>    void PrintNumber(int i)<br/>    {<br/>      cout &lt;&lt; i &lt;&lt; "\t";<br/>    }<br/><br/>    // Defining template for printing number<br/>    // passing to its 'limit' parameter<br/>    // It's only run<br/>    // if the 'limit' has not been reached<br/>    template&lt;int limit&gt;<br/>    class DoWhile<br/>    {<br/>       private:<br/>         enum<br/>         {<br/>           run = (limit-1) != 0<br/>         };<br/><br/>       public:<br/>         static inline void func()<br/>         {<br/>           PrintNumber(limit);<br/>           DoWhile&lt;run == true ? (limit-1) : 0&gt;<br/>            ::func();<br/>         }<br/>    };<br/><br/>    // Defining template for doing nothing<br/>    // when the 'limit' reaches 0<br/>    template&lt;&gt;<br/>    class DoWhile&lt;0&gt;<br/>    {<br/>      public:<br/>        static inline void func()<br/>        {<br/>        }<br/>    };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[loopmeta.cpp]" &lt;&lt; endl;<br/><br/>      // Defining a constant variable<br/>      const int i = 100;<br/><br/>      // Looping to print out<br/>      // the numbers below i variable<br/>      // by consuming the DoWhile<br/>      cout &lt;&lt; "List of numbers between 100 and 1";<br/>      cout &lt;&lt; endl;<br/>      DoWhile&lt;i&gt;::func();<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>We then call the <kbd>func()</kbd> method inside the template to run our desired function. And, if we run the code, we will see the following output on the screen:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="194" src="assets/b5fd496c-ddac-483e-b0db-523307b3c91e.png" width="520"/></div>
<p><span>Again, we have successfully refactored the <kbd>loop.cpp</kbd> code into <kbd>loopmeta.cpp</kbd> code since both have the exact same output.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing the code in compile-time</h1>
                </header>
            
            <article>
                
<p>As we discussed earlier, template metaprogramming will run the code in compile-time by creating a new code. Now, let's see how we can get the compile-time constant and generate a compile-time class in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting a compile-time constant</h1>
                </header>
            
            <article>
                
<p>To retrieve a compile-time constant, let's create a code that has the template for a Fibonacci algorithm in it. We will consume the template so the compiler will provide the value in compile time. The code should be as follows:</p>
<pre class="lang:default decode:true notranslate">
    /* fibonaccimeta.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Defining Fibonacci template<br/>    // to calculate the Fibonacci sequence<br/>    template &lt;int number&gt;<br/>    struct Fibonacci<br/>    {<br/>      enum<br/>      {<br/>        value =<br/>            Fibonacci&lt;number - 1&gt;::value +<br/>            Fibonacci&lt;number - 2&gt;::value<br/>      };<br/>    };<br/><br/>    // Defining template for<br/>    // specific input value<br/>    // 'number' = 1<br/>    template &lt;&gt;<br/>    struct Fibonacci&lt;1&gt;<br/>    {<br/>      enum<br/>      {<br/>        value = 1<br/>      };<br/>    };<br/><br/>    // Defining template for<br/>    // specific input value<br/>    // 'number' = 0<br/>    template &lt;&gt;<br/>    struct Fibonacci&lt;0&gt;<br/>    {<br/>      enum<br/>      {<br/>        value = 0<br/>      };<br/>    };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[fibonaccimeta.cpp]" &lt;&lt; endl;<br/><br/>      // Displaying the compile-time constant<br/>      cout &lt;&lt; "Getting compile-time constant:";<br/>      cout &lt;&lt; endl;<br/>      cout &lt;&lt; "Fibonacci(25) = ";<br/>      cout &lt;&lt; <strong>Fibonacci&lt;25&gt;::value</strong>;<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, the value variable in the Fibonacci template will provide a compile-time constant. And if we run the preceding code, we will see the following output on the console screen:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/015e83df-4905-4a3c-aa49-c8f233a2282c.png"/></div>
<p>Now, we have <kbd>75025</kbd> that is generated by the compiler as a compile-time constant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating the class using a compile-time class generation</h1>
                </header>
            
            <article>
                
<p>Besides the generation of a compile-time constant, we will also generate the class in compile time. Let's suppose we have a template to find out the prime number in the range <kbd>0</kbd> to <kbd>X</kbd>. The following <kbd>isprimemeta.cpp</kbd> code will explain the implementation of the template metaprogramming to find the prime number:</p>
<pre class="lang:default decode:true notranslate">
    /* isprimemeta.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Defining template that decide<br/>    // whether or not the passed argument<br/>    // is a prime number<br/>    template &lt;<br/>      int lastNumber,<br/>      int secondLastNumber&gt;<br/>    class IsPrime<br/>    {<br/>      public:<br/>        enum<br/>        {<br/>          primeNumber = (<br/>            (lastNumber % secondLastNumber) &amp;&amp;<br/>            IsPrime&lt;lastNumber, secondLastNumber - 1&gt;<br/>                ::primeNumber)<br/>        };<br/>     };<br/><br/>    // Defining template for checking<br/>    // the number passed to the 'number' parameter<br/>    // is a prime number<br/>    template &lt;int number&gt;<br/>    class IsPrime&lt;number, 1&gt;<br/>    {<br/>      public:<br/>        enum<br/>        {<br/>          primeNumber = 1<br/>        };<br/>    };<br/><br/>    // Defining template to print out<br/>    // the passed argument is it's a prime number<br/>    template &lt;int number&gt;<br/>    class PrimeNumberPrinter<br/>    {<br/>      public:<br/>        PrimeNumberPrinter&lt;number - 1&gt; printer;<br/><br/>      enum<br/>      {<br/>        primeNumber = IsPrime&lt;number, number - 1&gt;<br/>            ::primeNumber<br/>      };<br/><br/>      void func()<br/>      {<br/>        printer.func();<br/><br/>        if (primeNumber)<br/>        {<br/>            cout &lt;&lt; number &lt;&lt; "\t";<br/>        }<br/>      }<br/>    };<br/><br/>    // Defining template to just ignoring the number<br/>    // we pass 1 as argument to the parameter<br/>    // since 1 is not prime number<br/>    template&lt;&gt;<br/>    class PrimeNumberPrinter&lt;1&gt;<br/>    {<br/>      public:<br/>        enum<br/>        {<br/>          primeNumber = 0<br/>        };<br/><br/>        void func()<br/>        {<br/>        }<br/>    };<br/><br/>    int main()<br/>    {<br/>      cout &lt;&lt; "[isprimemeta.cpp]" &lt;&lt; endl;<br/><br/>      // Displaying the prime numbers between 1 and 500<br/>      cout &lt;&lt; "Filtering the numbers between 1 and 500 ";<br/>      cout &lt;&lt; "for of the prime numbers:" &lt;&lt; endl;<br/><br/>      // Consuming PrimeNumberPrinter template<br/>      PrimeNumberPrinter&lt;500&gt; printer;<br/><br/>      // invoking func() method from the template<br/>      printer.func();<br/><br/>      cout &lt;&lt; endl;<br/>      return 0;<br/>    }
</pre>
<p>There are two kinds of templates with different roles--the <strong>prime checker</strong>, that ensures the number that is passed is a prime number, and the <strong>printer</strong>, that displays the prime number to the console. The compiler then generates the class in compile-time when the code accesses <kbd>PrimeNumberPrinter&lt;500&gt; printer</kbd> and <kbd>printer.func()</kbd>. And when we run the preceding <kbd>isprimemeta.cpp</kbd> code, we will see the following output on the console screen:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="187" src="assets/1377d14f-9287-4e54-93b8-39bf5906fe43.png" width="522"/></div>
<p>Since we pass <kbd>500</kbd> to the template, we will get the prime number from <kbd>0</kbd> to <kbd>500</kbd>. The preceding output has proven that the compiler has successfully generated a compile-time class so we can get the correct value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits and drawbacks of metaprogramming</h1>
                </header>
            
            <article>
                
<p>After our discussion about template metaprogramming, the following are the advantages we derive:</p>
<ul>
<li>Template metaprogramming has no side effect since it is immutable, so we cannot modify an existing type</li>
<li>There is better code readability compared to code that does not implement metaprogramming</li>
<li>It reduces repetition of the code</li>
</ul>
<p>Although we can gain benefits from template metaprogramming, there are several disadvantages, which are as follows:</p>
<ul>
<li>The syntax is quite complex.</li>
<li>The compilation time takes longer since we now execute code during compile-time.</li>
<li>The compiler can optimize the generated code much better and perform inlining, for instance, the C <kbd>qsort()</kbd> function and the C++ <kbd>sort</kbd> template. In C, the <kbd>qsort()</kbd> function takes a pointer to a comparison function, so there will be one copy of the <kbd>qsort</kbd> code that is not inlined. It will make a call through the pointer to the comparison routine. In C++, <kbd>std::sort</kbd> is a template, and it can take a <kbd>functor</kbd> object as a comparator. There is a different copy of <kbd>std::sort</kbd> for each different type used as a comparator. If we use a <kbd>functor</kbd> class with an overloaded <kbd>operator()</kbd> function, the call to the comparator can easily be inlined into this copy of <kbd>std::sort</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Metaprogramming, especially template metaprogramming, creates new code for us automatically so we don't need to write a lot of code in our source. By using template metaprogramming, we can refactor the flow control of our code as well as run the code in compile-time execution.<br/>
In the next chapter, we will talk about concurrency techniques that will bring a responsive enhancement to the application that we build. We can run the processes in our code simultaneously using the parallelism technique.</p>


            </article>

            
        </section>
    </body></html>