["```cpp\n#pragma once\n#include <functional>\n#include <map>\n#include \"common/thread_utils.h\"\n#include \"common/lf_queue.h\"\n#include \"common/macros.h\"\n#include \"common/mcast_socket.h\"\n#include \"exchange/market_data/market_update.h\"\nnamespace Trading {\nclass MarketDataConsumer {\nprivate:\n    size_t next_exp_inc_seq_num_ = 1;\n    Exchange::MEMarketUpdateLFQueue *incoming_md_updates_ =\n      nullptr;\n    volatile bool run_ = false;\n    std::string time_str_;\n    Logger logger_;\n    Common::McastSocket incremental_mcast_socket_,\n      snapshot_mcast_socket_;\n    bool in_recovery_ = false;\n    const std::string iface_, snapshot_ip_;\n    const int snapshot_port_;\n    typedef std::map<size_t, Exchange::MEMarketUpdate>\n      QueuedMarketUpdates;\n    QueuedMarketUpdates snapshot_queued_msgs_,\n      incremental_queued_msgs_;\n};\n}\n```", "```cpp\n#include \"market_data_consumer.h\"\nnamespace Trading {\n  MarketDataConsumer::MarketDataConsumer(Common::ClientId\n    client_id, Exchange::MEMarketUpdateLFQueue\n      *market_updates,\nconst std::string &iface,\nconst std::string &snapshot_ip, int snapshot_port,\nconst std::string &incremental_ip, int incremental_port)\n      : incoming_md_updates_(market_updates), run_(false),\n        logger_(\"trading_market_data_consumer_\" + std::\n          to_string(client_id) + \".log\"),\n        incremental_mcast_socket_(logger_),\n          snapshot_mcast_socket_(logger_),\n        iface_(iface), snapshot_ip_(snapshot_ip),\n          snapshot_port_(snapshot_port) {\n```", "```cpp\n    auto recv_callback = [this](auto socket) {\n      recvCallback(socket);\n    };\n    incremental_mcast_socket_.recv_callback_ =\n      recv_callback;\n    ASSERT(incremental_mcast_socket_.init(incremental_ip,\n      iface, incremental_port, /*is_listening*/ true) >= 0,\n           \"Unable to create incremental mcast socket.\n             error:\" + std::string(std::strerror(errno)));\n    ASSERT(incremental_mcast_socket_.join(incremental_ip,\n      iface, incremental_port),\n           \"Join failed on:\" + std::to_string\n              (incremental_mcast_socket_.fd_) + \" error:\" +\n                 std::string(std::strerror(errno)));\n    snapshot_mcast_socket_.recv_callback_ = recv_callback;\n  }\n```", "```cpp\n    auto start() {\n      run_ = true;\n      ASSERT(Common::createAndStartThread(-1,\n        \"Trading/MarketDataConsumer\", [this]() { run(); })\n          != nullptr, \"Failed to start MarketData\n             thread.\");\n    }\n```", "```cpp\n    ~MarketDataConsumer() {\n      stop();\n      using namespace std::literals::chrono_literals;\n      std::this_thread::sleep_for(5s);\n    }\n    auto stop() -> void {\n      run_ = false;\n    }\n```", "```cpp\n  auto MarketDataConsumer::run() noexcept -> void {\n    logger_.log(\"%:% %() %\\n\", __FILE__, __LINE__,\n      __FUNCTION__, Common::getCurrentTimeStr(&time_str_));\n    while (run_) {\n      incremental_mcast_socket_.sendAndRecv();\n      snapshot_mcast_socket_.sendAndRecv();\n    }\n  }\n```", "```cpp\n  auto MarketDataConsumer::recvCallback(McastSocket\n    *socket) noexcept -> void {\n    const auto is_snapshot = (socket->fd_ ==\n      snapshot_mcast_socket_.fd_);\n    if (UNLIKELY(is_snapshot && !in_recovery_)) {\n      socket->next_rcv_valid_index_ = 0;\n      logger_.log(\"%:% %() % WARN Not expecting snapshot\n        messages.\\n\",\n                  __FILE__, __LINE__, __FUNCTION__,\n                    Common::getCurrentTimeStr(&time_str_));\n      return;\n    }\n```", "```cpp\n    if (socket->next_rcv_valid_index_ >= sizeof\n      (Exchange::MDPMarketUpdate)) {\n      size_t i = 0;\n      for (; i + sizeof(Exchange::MDPMarketUpdate) <=\n        socket->next_rcv_valid_index_; i +=\n          sizeof(Exchange::MDPMarketUpdate)) {\n        auto request = reinterpret_cast<const\n          Exchange::MDPMarketUpdate *>(socket->rcv_buffer_\n            + i);\n        logger_.log(\"%:% %() % Received % socket len:%\n          %\\n\", __FILE__, __LINE__, __FUNCTION__,\n                    Common::getCurrentTimeStr(&time_str_),\n                    (is_snapshot ? \"snapshot\" :\n                       \"incremental\"), sizeof\n                         (Exchange::MDPMarketUpdate),\n                           request->toString());\n```", "```cpp\n        const bool already_in_recovery = in_recovery_;\n        in_recovery_ = (already_in_recovery || request->\n          seq_num_ != next_exp_inc_seq_num_);\n```", "```cpp\n        if (UNLIKELY(in_recovery_)) {\n          if (UNLIKELY(!already_in_recovery)) {\n            logger_.log(\"%:% %() % Packet drops on %\n              socket. SeqNum expected:% received:%\\n\",\n                __FILE__, __LINE__, __FUNCTION__,\n                        Common::getCurrentTimeStr\n                          (&time_str_), (is_snapshot ?\n                            \"snapshot\" : \"incremental\"),\n                              next_exp_inc_seq_num_,\n                                 request->seq_num_);\n            startSnapshotSync();\n          }\n          queueMessage(is_snapshot, request);\n        }\n```", "```cpp\n          else if (!is_snapshot) {\n          logger_.log(\"%:% %() % %\\n\", __FILE__, __LINE__,\n            __FUNCTION__,\n                      Common::getCurrentTimeStr\n                        (&time_str_), request->toString());\n          ++next_exp_inc_seq_num_;\n          auto next_write = incoming_md_updates_->\n            getNextToWriteTo();\n          *next_write = std::move(request->\n            me_market_update_);\n          incoming_md_updates_->updateWriteIndex();\n        }\n      }\n```", "```cpp\n      memcpy(socket->rcv_buffer_, socket->rcv_buffer_ + i,\n        socket->next_rcv_valid_index_ - i);\n      socket->next_rcv_valid_index_ -= i;\n    }\n  }\n```", "```cpp\n  auto MarketDataConsumer::startSnapshotSync() -> void {\n    snapshot_queued_msgs_.clear();\n    incremental_queued_msgs_.clear();\n    ASSERT(snapshot_mcast_socket_.init(snapshot_ip_,\n      iface_, snapshot_port_, /*is_listening*/ true) >= 0,\n           \"Unable to create snapshot mcast socket. error:\"\n              + std::string(std::strerror(errno)));\n    ASSERT(snapshot_mcast_socket_.join(snapshot_ip_,\n      iface_, snapshot_port_),\n           \"Join failed on:\" + std::to_string\n             (snapshot_mcast_socket_.fd_) + \" error:\" +\n               std::string(std::strerror(errno)));\n  }\n```", "```cpp\nauto MarketDataConsumer::queueMessage(bool is_snapshot,\n                                        const Exchange::\n                                          MDPMarketUpdate\n                                            *request) {\n    if (is_snapshot) {\n      if (snapshot_queued_msgs_.find(request->seq_num_) !=\n        snapshot_queued_msgs_.end()) {\n        logger_.log(\"%:% %() % Packet drops on snapshot\n          socket. Received for a 2nd time:%\\n\", __FILE__,\n            __LINE__, __FUNCTION__,\n                    Common::getCurrentTimeStr(&time_str_),\n                      request->toString());\n        snapshot_queued_msgs_.clear();\n      }\n      snapshot_queued_msgs_[request->seq_num_] = request->\n        me_market_update_;\n    } else {\n      incremental_queued_msgs_[request->seq_num_] =\n        request->me_market_update_;\n    }\n```", "```cpp\n    logger_.log(\"%:% %() % size snapshot:% incremental:% %\n      => %\\n\", __FILE__, __LINE__, __FUNCTION__,\n                Common::getCurrentTimeStr(&time_str_),\n                  snapshot_queued_msgs_.size(),\n                    incremental_queued_msgs_.size(),\n                      request->seq_num_, request->\n                        toString());\n    checkSnapshotSync();\n}\n```", "```cpp\n  auto MarketDataConsumer::checkSnapshotSync() -> void {\n    if (snapshot_queued_msgs_.empty()) {\n      return;\n    }\n```", "```cpp\n    const auto &first_snapshot_msg =\n      snapshot_queued_msgs_.begin()->second;\n    if (first_snapshot_msg.type_ != Exchange::\n      MarketUpdateType::SNAPSHOT_START) {\n      logger_.log(\"%:% %() % Returning because have not\n        seen a SNAPSHOT_START yet.\\n\",\n                  __FILE__, __LINE__, __FUNCTION__,\n                    Common::getCurrentTimeStr(&time_str_));\n      snapshot_queued_msgs_.clear();\n      return;\n    }\n```", "```cpp\n    std::vector<Exchange::MEMarketUpdate> final_events;\n    auto have_complete_snapshot = true;\n    size_t next_snapshot_seq = 0;\n    for (auto &snapshot_itr: snapshot_queued_msgs_) {\n      logger_.log(\"%:% %() % % => %\\n\", __FILE__, __LINE__,\n        __FUNCTION__,\n                  Common::getCurrentTimeStr(&time_str_),\n                     snapshot_itr.first,\n                       snapshot_itr.second.toString());\n      if (snapshot_itr.first != next_snapshot_seq) {\n        have_complete_snapshot = false;\n        logger_.log(\"%:% %() % Detected gap in snapshot\n          stream expected:% found:% %.\\n\", __FILE__,\n            __LINE__, __FUNCTION__,\n                    Common::getCurrentTimeStr(&time_str_),\n                       next_snapshot_seq,\n                          snapshot_itr.first, snapshot_itr.\n                             second.toString());\n        break;\n      }\n      if (snapshot_itr.second.type_ !=\n         Exchange::MarketUpdateType::SNAPSHOT_START &&\n          snapshot_itr.second.type_ !=\n            Exchange::MarketUpdateType::SNAPSHOT_END)\n        final_events.push_back(snapshot_itr.second);\n      ++next_snapshot_seq;\n    }\n```", "```cpp\n    if (!have_complete_snapshot) {\n      logger_.log(\"%:% %() % Returning because found gaps\n        in snapshot stream.\\n\",\n                  __FILE__, __LINE__, __FUNCTION__,\n                    Common::getCurrentTimeStr(&time_str_));\n      snapshot_queued_msgs_.clear();\n      return;\n    }\n```", "```cpp\n    const auto &last_snapshot_msg = snapshot_queued_msgs_\n      .rbegin()->second;\n    if (last_snapshot_msg.type_ != Exchange::\n      MarketUpdateType::SNAPSHOT_END) {\n      logger_.log(\"%:% %() % Returning because have not\n        seen a SNAPSHOT_END yet.\\n\",\n                  __FILE__, __LINE__, __FUNCTION__,\n                    Common::getCurrentTimeStr(&time_str_));\n      return;\n    }\n```", "```cpp\n    auto have_complete_incremental = true;\n    size_t num_incrementals = 0;\n    next_exp_inc_seq_num_ = last_snapshot_msg.order_id_ + 1;\n```", "```cpp\n    for (auto inc_itr = incremental_queued_msgs_.begin();\n      inc_itr != incremental_queued_msgs_.end(); ++inc_itr) {\n      logger_.log(\"%:% %() % Checking next_exp:% vs. seq:%\n        %.\\n\", __FILE__, __LINE__, __FUNCTION__,\n                  Common::getCurrentTimeStr(&time_str_),\n                    next_exp_inc_seq_num_, inc_itr->first,\n                      inc_itr->second.toString());\n      if (inc_itr->first < next_exp_inc_seq_num_)\n        continue;\n      if (inc_itr->first != next_exp_inc_seq_num_) {\n        logger_.log(\"%:% %() % Detected gap in incremental\n          stream expected:% found:% %.\\n\", __FILE__,\n            __LINE__, __FUNCTION__,\n                    Common::getCurrentTimeStr(&time_str_),\n                      next_exp_inc_seq_num_, inc_itr->\n                        first, inc_itr->second.toString());\n        have_complete_incremental = false;\n        break;\n      }\n```", "```cpp\n      logger_.log(\"%:% %() % % => %\\n\", __FILE__, __LINE__,\n        __FUNCTION__,\n                  Common::getCurrentTimeStr(&time_str_),\n                    inc_itr->first, inc_itr->second\n                       .toString());\n      if (inc_itr->second.type_ != Exchange::\n        MarketUpdateType::SNAPSHOT_START &&\n          inc_itr->second.type_ != Exchange::\n             MarketUpdateType::SNAPSHOT_END)\n        final_events.push_back(inc_itr->second);\n      ++next_exp_inc_seq_num_;\n      ++num_incrementals;\n    }\n```", "```cpp\n    if (!have_complete_incremental) {\n      logger_.log(\"%:% %() % Returning because have gaps in\n        queued incrementals.\\n\",\n                  __FILE__, __LINE__, __FUNCTION__,\n                    Common::getCurrentTimeStr(&time_str_));\n      snapshot_queued_msgs_.clear();\n      return;\n    }\n```", "```cpp\n    for (const auto &itr: final_events) {\n      auto next_write = incoming_md_updates_->\n        getNextToWriteTo();\n      *next_write = itr;\n      incoming_md_updates_->updateWriteIndex();\n    }\n```", "```cpp\n    logger_.log(\"%:% %() % Recovered % snapshot and %\n      incremental orders.\\n\", __FILE__, __LINE__,\n         __FUNCTION__,\n                Common::getCurrentTimeStr(&time_str_),\n                  snapshot_queued_msgs_.size() - 2,\n                    num_incrementals);\n    snapshot_queued_msgs_.clear();\n    incremental_queued_msgs_.clear();\n    in_recovery_ = false;\n    snapshot_mcast_socket_.leave(snapshot_ip_,\n      snapshot_port_);;\n  }\n```", "```cpp\n#pragma once\n#include <array>\n#include <sstream>\n#include \"common/types.h\"\nusing namespace Common;\nnamespace Trading {\n  struct MarketOrder {\n    OrderId order_id_ = OrderId_INVALID;\n    Side side_ = Side::INVALID;\n    Price price_ = Price_INVALID;\n    Qty qty_ = Qty_INVALID;\n    Priority priority_ = Priority_INVALID;\n    MarketOrder *prev_order_ = nullptr;\n    MarketOrder *next_order_ = nullptr;\n```", "```cpp\n    // only needed for use with MemPool.\n    MarketOrder() = default;\n    MarketOrder(OrderId order_id, Side side, Price price,\n      Qty qty, Priority priority, MarketOrder *prev_order,\n        MarketOrder *next_order) noexcept\n        : order_id_(order_id), side_(side), price_(price),\n           qty_(qty), priority_(priority),\n             prev_order_(prev_order),\n               next_order_(next_order) {}\n    auto toString() const -> std::string;\n  };\n```", "```cpp\n  typedef std::array<MarketOrder *, ME_MAX_ORDER_IDS> OrderHashMap;\n```", "```cpp\n  auto MarketOrder::toString() const -> std::string {\n    std::stringstream ss;\n    ss << \"MarketOrder\" << \"[\"\n       << \"oid:\" << orderIdToString(order_id_) << \" \"\n       << \"side:\" << sideToString(side_) << \" \"\n       << \"price:\" << priceToString(price_) << \" \"\n       << \"qty:\" << qtyToString(qty_) << \" \"\n       << \"prio:\" << priorityToString(priority_) << \" \"\n       << \"prev:\" << orderIdToString(prev_order_ ?\n           prev_order_->order_id_ : OrderId_INVALID) << \" \"\n       << \"next:\" << orderIdToString(next_order_ ?\n         next_order_->order_id_ : OrderId_INVALID) << \"]\";\n    return ss.str();\n  }\n```", "```cpp\n  struct MarketOrdersAtPrice {\n    Side side_ = Side::INVALID;\n    Price price_ = Price_INVALID;\n    MarketOrder *first_mkt_order_ = nullptr;\n    MarketOrdersAtPrice *prev_entry_ = nullptr;\n    MarketOrdersAtPrice *next_entry_ = nullptr;\n```", "```cpp\n    MarketOrdersAtPrice() = default;\n    MarketOrdersAtPrice(Side side, Price price, MarketOrder\n      *first_mkt_order, MarketOrdersAtPrice *prev_entry,\n         MarketOrdersAtPrice *next_entry)\n        : side_(side), price_(price),\n          first_mkt_order_(first_mkt_order),\n            prev_entry_(prev_entry),\n              next_entry_(next_entry) {}\n```", "```cpp\n    auto toString() const;\n  };\n```", "```cpp\n  typedef std::array<MarketOrdersAtPrice *,\n    ME_MAX_PRICE_LEVELS> OrdersAtPriceHashMap;\n```", "```cpp\n  struct BBO {\n    Price bid_price_ = Price_INVALID, ask_price_ =\n      Price_INVALID;\n    Qty bid_qty_ = Qty_INVALID, ask_qty_ = Qty_INVALID;\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"BBO{\"\n         << qtyToString(bid_qty_) << \"@\" <<\n           priceToString(bid_price_)\n         << \"X\"\n         << priceToString(ask_price_) << \"@\" <<\n            qtyToString(ask_qty_)\n         << \"}\";\n      return ss.str();\n    };\n  };\n```", "```cpp\n#pragma once\n#include \"common/types.h\"\n#include \"common/mem_pool.h\"\n#include \"common/logging.h\"\n#include \"market_order.h\"\n#include \"exchange/market_data/market_update.h\"\nnamespace Trading {\n  class TradeEngine;\n  class MarketOrderBook final {\n  private:\n    const TickerId ticker_id_;\n    TradeEngine *trade_engine_ = nullptr;\n    OrderHashMap oid_to_order_;\n    MemPool<MarketOrdersAtPrice> orders_at_price_pool_;\n    MarketOrdersAtPrice *bids_by_price_ = nullptr;\n    MarketOrdersAtPrice *asks_by_price_ = nullptr;\n    OrdersAtPriceHashMap price_orders_at_price_;\n    MemPool<MarketOrder> order_pool_;\n    BBO bbo_;\n    std::string time_str_;\n    Logger *logger_ = nullptr;\n  };\n```", "```cpp\n  typedef std::array<MarketOrderBook *, ME_MAX_TICKERS>\n    MarketOrderBookHashMap;\n}\n```", "```cpp\n#include \"market_order_book.h\"\n#include \"trade_engine.h\"\nnamespace Trading {\n  MarketOrderBook::MarketOrderBook(TickerId ticker_id,\n    Logger *logger)\n      : ticker_id_(ticker_id),\n        orders_at_price_pool_(ME_MAX_PRICE_LEVELS),\n          order_pool_(ME_MAX_ORDER_IDS), logger_(logger) {\n  }\n```", "```cpp\n  MarketOrderBook::~MarketOrderBook() {\n    logger_->log(\"%:% %() % OrderBook\\n%\\n\", __FILE__,\n      __LINE__, __FUNCTION__,\n                 Common::getCurrentTimeStr(&time_str_),\n                   toString(false, true));\n    trade_engine_ = nullptr;\n    bids_by_price_ = asks_by_price_ = nullptr;\n    oid_to_order_.fill(nullptr);\n  }\n```", "```cpp\n    auto setTradeEngine(TradeEngine *trade_engine) {\n      trade_engine_ = trade_engine;\n    }\n```", "```cpp\n  auto MarketOrderBook::onMarketUpdate(const\n    Exchange::MEMarketUpdate *market_update) noexcept -> void {\n    const auto bid_updated = (bids_by_price_ &&\n      market_update->side_ == Side::BUY && market_update->\n        price_ >= bids_by_price_->price_);\n    const auto ask_updated = (asks_by_price_ &&\n      market_update->side_ == Side::SELL && market_update->\n         price_ <= asks_by_price_->price_);\n```", "```cpp\n    switch (market_update->type_) {\n      case Exchange::MarketUpdateType::ADD: {\n        auto order = order_pool_.allocate(market_update->\n          order_id_, market_update->side_, market_update->\n            price_,\n            market_update->qty_, market_update->priority_,\n             nullptr, nullptr);\n        addOrder(order);\n      }\n        break;\n```", "```cpp\n      case Exchange::MarketUpdateType::MODIFY: {\n        auto order = oid_to_order_.at(market_update->\n          order_id_);\n        order->qty_ = market_update->qty_;\n      }\n        break;\n```", "```cpp\n      case Exchange::MarketUpdateType::CANCEL: {\n        auto order = oid_to_order_.at(market_update->\n          order_id_);\n        removeOrder(order);\n      }\n        break;\n```", "```cpp\n      case Exchange::MarketUpdateType::TRADE: {\n        trade_engine_->onTradeUpdate(market_update, this);\n        return;\n      }\n        break;\n```", "```cpp\n      case Exchange::MarketUpdateType::CLEAR: {\n        for (auto &order: oid_to_order_) {\n          if (order)\n            order_pool_.deallocate(order);\n        }\n        oid_to_order_.fill(nullptr);\n        if(bids_by_price_) {\n          for(auto bid = bids_by_price_->next_entry_; bid\n            != bids_by_price_; bid = bid->next_entry_)\n            orders_at_price_pool_.deallocate(bid);\n          orders_at_price_pool_.deallocate(bids_by_price_);\n        }\n        if(asks_by_price_) {\n          for(auto ask = asks_by_price_->next_entry_; ask\n            != asks_by_price_; ask = ask->next_entry_)\n            orders_at_price_pool_.deallocate(ask);\n          orders_at_price_pool_.deallocate(asks_by_price_);\n        }\n        bids_by_price_ = asks_by_price_ = nullptr;\n      }\n        break;\n```", "```cpp\n      case Exchange::MarketUpdateType::INVALID:\n      case Exchange::MarketUpdateType::SNAPSHOT_START:\n      case Exchange::MarketUpdateType::SNAPSHOT_END:\n        break;\n    }\n```", "```cpp\n    updateBBO(bid_updated, ask_updated);\n```", "```cpp\n    trade_engine_->onOrderBookUpdate(market_update->\n      ticker_id_, market_update->price_, market_update->\n        side_);\n    logger_->log(\"%:% %() % OrderBook\\n%\\n\", __FILE__,\n      __LINE__, __FUNCTION__,\n                 Common::getCurrentTimeStr(&time_str_),\n                   toString(false, true));\n  }\n```", "```cpp\n    auto updateBBO(bool update_bid, bool update_ask)\n      noexcept {\n      if(update_bid) {\n        if(bids_by_price_) {\n          bbo_.bid_price_ = bids_by_price_->price_;\n          bbo_.bid_qty_ = bids_by_price_->first_mkt_order_-\n            >qty_;\n          for(auto order = bids_by_price_->\n            first_mkt_order_->next_order_; order !=\n              bids_by_price_->first_mkt_order_; order =\n                order->next_order_)\n            bbo_.bid_qty_ += order->qty_;\n        }\n        else {\n          bbo_.bid_price_ = Price_INVALID;\n          bbo_.bid_qty_ = Qty_INVALID;\n        }\n      }\n```", "```cpp\n      if(update_ask) {\n        if(asks_by_price_) {\n          bbo_.ask_price_ = asks_by_price_->price_;\n          bbo_.ask_qty_ = asks_by_price_->first_mkt_order_-\n            >qty_;\n          for(auto order = asks_by_price_->\n            first_mkt_order_->next_order_; order !=\n              asks_by_price_->first_mkt_order_; order =\n                order->next_order_)\n            bbo_.ask_qty_ += order->qty_;\n        }\n        else {\n          bbo_.ask_price_ = Price_INVALID;\n          bbo_.ask_qty_ = Qty_INVALID;\n        }\n      }\n    }\n```", "```cpp\n    auto priceToIndex(Price price) const noexcept;\n    auto getOrdersAtPrice(Price price) const noexcept ->\n      MarketOrdersAtPrice;\n```", "```cpp\n    auto addOrder(MarketOrder *order) noexcept -> void;\n    auto addOrdersAtPrice(MarketOrdersAtPrice\n      *new_orders_at_price) noexcept;\n```", "```cpp\n    Auto removeOrdersAtPrice(Side side, Price price)\n      noexcept;\n    auto removeOrder(MarketOrder *order) noexcept -> void;\n```", "```cpp\n#pragma once\n#include <functional>\n#include \"common/thread_utils.h\"\n#include \"common/macros.h\"\n#include \"common/tcp_server.h\"\n#include \"exchange/order_server/client_request.h\"\n#include \"exchange/order_server/client_response.h\"\nnamespace Trading {\n  class OrderGateway {\n  private:\n    const ClientId client_id_;\n    std::string ip_;\n    const std::string iface_;\n    const int port_ = 0;\n    Exchange::ClientRequestLFQueue *outgoing_requests_ =\n      nullptr;\n    Exchange::ClientResponseLFQueue *incoming_responses_ =\n      nullptr;\n    volatile bool run_ = false;\n    std::string time_str_;\n    Logger logger_;\n    size_t next_outgoing_seq_num_ = 1;\n    size_t next_exp_seq_num_ = 1;\n    Common::TCPSocket tcp_socket_;\n  };\n}\n```", "```cpp\n#include \"order_gateway.h\"\nnamespace Trading {\n  OrderGateway::OrderGateway(ClientId client_id,\n     Exchange::ClientRequestLFQueue *client_requests,\nExchange::ClientResponseLFQueue *client_responses,\n  std::string ip, const std::string &iface, int port)\n      : client_id_(client_id), ip_(ip), iface_(iface),\n        port_(port), outgoing_requests_(client_requests),\n          incoming_responses_(client_responses),\n      logger_(\"trading_order_gateway_\" + std::\n        to_string(client_id) + \".log\"),\n          tcp_socket_(logger_) {\n    tcp_socket_.recv_callback_ = [this](auto socket, auto\n      rx_time) { recvCallback(socket, rx_time); };\n  }\n```", "```cpp\n    auto start() {\n      run_ = true;\n      ASSERT(tcp_socket_.connect(ip_, iface_, port_, false)\n        >= 0,\n             \"Unable to connect to ip:\" + ip_ + \" port:\" +\n               std::to_string(port_) + \" on iface:\" +\n                 iface_ + \" error:\" +\n                   std::string(std::strerror(errno)));\n      ASSERT(Common::createAndStartThread(-1,\n        \"Trading/OrderGateway\", [this]() { run(); }) !=\n           nullptr, \"Failed to start OrderGateway\n             thread.\");\n    }\n```", "```cpp\n    ~OrderGateway() {\n      stop();\n      using namespace std::literals::chrono_literals;\n      std::this_thread::sleep_for(5s);\n    }\n```", "```cpp\n    auto stop() -> void {\n      run_ = false;\n    }\n```", "```cpp\n  auto OrderGateway::run() noexcept -> void {\n    logger_.log(\"%:% %() %\\n\", __FILE__, __LINE__,\n      __FUNCTION__, Common::getCurrentTimeStr(&time_str_));\n    while (run_) {\n      tcp_socket_.sendAndRecv();\n```", "```cpp\n      for(auto client_request = outgoing_requests_->\n        getNextToRead(); client_request; client_request =\n          outgoing_requests_->getNextToRead()) {\n        logger_.log(\"%:% %() % Sending cid:% seq:% %\\n\",\n          __FILE__, __LINE__, __FUNCTION__,\n                    Common::getCurrentTimeStr(&time_str_),\n                      client_id_, next_outgoing_seq_num_,\n                        client_request->toString());\n        tcp_socket_.send(&next_outgoing_seq_num_,\n          sizeof(next_outgoing_seq_num_));\n        tcp_socket_.send(client_request,\n          sizeof(Exchange::MEClientRequest));\n        outgoing_requests_->updateReadIndex();\n        next_outgoing_seq_num_++;\n      }\n    }\n  }\n```", "```cpp\n  auto OrderGateway::recvCallback(TCPSocket *socket, Nanos\n    rx_time) noexcept -> void {\n    logger_.log(\"%:% %() % Received socket:% len:% %\\n\",\n      __FILE__, __LINE__, __FUNCTION__,\n        Common::getCurrentTimeStr(&time_str_), socket->fd_,\n          socket->next_rcv_valid_index_, rx_time);\n    if (socket->next_rcv_valid_index_ >=\n      sizeof(Exchange::OMClientResponse)) {\n      size_t i = 0;\n      for (; i + sizeof(Exchange::OMClientResponse) <=\n        socket->next_rcv_valid_index_; i +=\n          sizeof(Exchange::OMClientResponse)) {\n        auto response = reinterpret_cast<const\n          Exchange::OMClientResponse *>(socket->rcv_buffer_\n            + i);\n        logger_.log(\"%:% %() % Received %\\n\", __FILE__,\n          __LINE__, __FUNCTION__,\n           Common::getCurrentTimeStr(&time_str_), response-\n             >toString());\n```", "```cpp\n        if(response->me_client_response_.client_id_ !=\n          client_id_) {\n          logger_.log(\"%:% %() % ERROR Incorrect client id.\n            ClientId expected:% received:%.\\n\", __FILE__,\n               __LINE__, __FUNCTION__,\n                      Common::getCurrentTimeStr(&time_str_)\n                       , client_id_, response->\n                          me_client_response_.client_id_);\n          continue;\n        }\n```", "```cpp\n        if(response->seq_num_ != next_exp_seq_num_) {\n          logger_.log(\"%:% %() % ERROR Incorrect sequence\n            number. ClientId:%. SeqNum expected:%\n              received:%.\\n\", __FILE__, __LINE__,\n                __FUNCTION__,\n                      Common::getCurrentTimeStr(&time_str_)\n                        , client_id_, next_exp_seq_num_,\n                           response->seq_num_);\n          continue;\n        }\n```", "```cpp\n        ++next_exp_seq_num_;\n        auto next_write = incoming_responses_->\n          getNextToWriteTo();\n        *next_write = std::move(response->\n          me_client_response_);\n        incoming_responses_->updateWriteIndex();\n      }\n      memcpy(socket->rcv_buffer_, socket->rcv_buffer_ + i,\n        socket->next_rcv_valid_index_ - i);\n      socket->next_rcv_valid_index_ -= i;\n    }\n  }\n```"]