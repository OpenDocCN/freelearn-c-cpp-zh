# 4

# 向项目中添加测试

在本章中，我们将向测试库添加一个主要的新功能。这个新功能将允许你在测试中检查条件，以确保一切按计划进行。有时，这些检查被称为*断言*，有时被称为*期望*。无论它们被称为什么，它们都让你确认从被测试的代码中获取的值与期望相符。

对于这本书和我们在创建的测试库，我将把这些检查称为确认。每个确认将被称为*确认*。这样做的原因是断言已经在 C++中使用，使用相同的名称可能会造成混淆。此外，期望在其他测试库中是一个常用术语，这本身并不是避免使用相同术语的理由。我实际上喜欢期望这个术语。但期望还有一个我们不想看到的常见行为。许多其他测试库允许测试在期望失败的情况下继续进行。我真的不喜欢这种行为。一旦出现问题，我认为是时候结束那个测试了。其他测试仍然可以运行。但我们不应该继续运行一个一旦与我们的期望不符就停止的测试。

到目前为止，你可以使用测试库编写多个测试，运行它们，并查看结果。每个测试的结果要么是通过，要么是失败。你甚至可以期望某些失败，并将它们视为通过。还有一个第三种结果，可能不需要在测试库本身之外使用，那就是错过失败。你可以在前三章中了解所有这些功能。

在本章中，我们将涵盖以下主要内容：

+   如何检测测试是通过还是失败

+   增强测试库以支持确认

+   是否应该测试错误情况？

我们之所以等到本章才添加确认，是有原因的。我们正在遵循对测试库本身设计的 TDD（测试驱动开发）方法。这意味着我们让测试驱动设计。这是一种敏捷的软件开发方法。我们考虑下一个最宝贵或最必要的功能或能力是什么，该功能的最终用途是什么，然后编写最少的代码来实现它，并通过添加更多功能来增强设计。

到目前为止，添加确认并没有意义。我们需要首先让基本功能工作，这样我们就可以在考虑测试内部要做什么之前创建和运行测试。也许我们可以在异常处理之前添加确认。但我选择在确认之前先处理异常。异常似乎与测试的基本声明和运行更紧密相关，因此比确认更有价值。

此外，你还会看到我们将使用异常来启用确认。这也是为什么处理异常的基本能力在确认之前的原因。

现在，我们可以将注意力转向带有确认的测试。同样，我们将做最少的努力来使确认功能化和有用。我们将在下一章继续添加更多到确认的能力。

# 技术要求

本章中的所有代码都使用标准 C++，它基于任何现代 C++ 17 或更高版本的编译器和标准库。代码基于前几章并继续发展。

您可以在以下 GitHub 仓库中找到本章的所有代码：

[`github.com/PacktPublishing/Test-Driven-Development-with-CPP`](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)

# 如何检测测试是否通过或失败

在本章中，我们将创建的测试与创建测试不同，因此它们应该有自己的文件。在编写自己的测试时，您也会希望将它们组织到多个文件中。

让我们创建一个名为 `Confirm.cpp` 的新文件，并将其放置在 `tests` 文件夹内。有了这个新文件，项目结构将如下所示：

```cpp
MereTDD project root folder
    Test.h
    tests folder
        main.cpp
        Confirm.cpp
        Creation.cpp
```

然后，向新文件添加一个单独的测试，使其看起来像这样：

```cpp
#include "../Test.h"
TEST("Test will pass without any confirms")
{
}
```

我们已经在 `Creation.cpp` 中有一个空测试，如下所示：

```cpp
TEST("Test can be created")
{
}
```

这两个测试之间唯一的真正区别是名称。我们真的需要另一个执行相同操作但名称不同的测试吗？我可以在关于添加具有不同名称但执行相同操作代码的辩论的任何一边进行争论。有些人可能会看到这一点，认为这是纯粹的代码重复。

对我来说，区别在于 *意图*。是的，这两个测试现在碰巧是相同的。但谁知道将来是否会对其中一个或两个进行修改？如果发生这种情况，我们能否记得测试正在服务于多个目的？

我强烈建议您将每个测试都写成似乎它是您代码和测试旨在防止的错误之间的唯一障碍。或者，也许测试正在执行特定的用法以确保在设计更改后不会出现任何问题。只要它们测试不同的事情，有两个相同的测试是可以接受的。目标是应该独特的。

在这种情况下，原始测试只是确保可以以最基本的形式创建测试。新的测试专门确保空测试可以通过。这两个测试只是碰巧需要相同的测试方法体来实现目标。

现在我们已经在项目中添加了一个新文件和一个新测试，让我们构建并确保一切按预期工作。但它失败了。构建失败的原因如下：

```cpp
ld: 5 duplicate symbols for architecture x86_64
```

代码编译没有问题，但项目无法链接到最终的可执行文件。我们有五个链接器错误。其中一个链接器错误如下所示：

```cpp
duplicate symbol 'Test3::run()'
```

我只列出了一个链接器错误，因为它们都是相似的。问题是现在有两个`Test3`的声明。一个声明来自每个文件，`Creation.cpp`和`Confirm.cpp`；这是因为`TEST`宏根据`TEST`宏在源文件中出现的行号声明了一个具有唯一数字的`Test`类。两个文件恰好都在第 3 行使用了`TEST`宏，因此它们各自声明了一个名为`Test3`的类。

解决这个问题的方法是，在宏中声明类时使用一个**未命名的命名空间**。这样仍然会创建两个类，例如`Test3`，但每个类都将位于一个不扩展到声明它的`.cpp`文件之外的命名空间中。这意味着测试类可以继续基于行号，行号在每`.cpp`文件中都是唯一的，并且现在将不再与在另一个`.cpp`文件中声明在相同行号的任何其他测试冲突。

我们需要做的只是修改`TEST`和`TEST_EX`宏，在每个宏中仅将未命名的命名空间添加到类声明周围。我们不需要将命名空间扩展到宏的末尾，因为宏继续声明`run`方法的开始。幸运的是，`run`方法的声明不需要在命名空间内。否则，我们不得不在`run`方法完全定义后，通过关闭花括号来确定如何结束命名空间。实际上，我们可以在类声明后结束命名空间。`TEST`宏看起来像这样：

```cpp
#define TEST( testName ) \
namespace { \
class MERETDD_CLASS : public MereTDD::TestBase \
{ \
public: \
    MERETDD_CLASS (std::string_view name) \
    : TestBase(name) \
    { \
        MereTDD::getTests().push_back(this); \
    } \
    void run () override; \
}; \
} /* end of unnamed namespace */ \
MERETDD_CLASS MERETDD_INSTANCE(testName); \
void MERETDD_CLASS::run ()
```

`TEST_EX`宏也需要一个类似的未命名的命名空间，如下所示：

```cpp
#define TEST_EX( testName, exceptionType ) \
namespace { \
class MERETDD_CLASS : public MereTDD::TestBase \
{ \
public: \
    MERETDD_CLASS (std::string_view name) \
    : TestBase(name) \
    { \
        MereTDD::getTests().push_back(this); \
    } \
    void runEx () override \
    { \
        try \
        { \
            run(); \
        } \
        catch (exceptionType const &) \
        { \
            return; \
        } \
        throw MereTDD::MissingException(#exceptionType); \
    } \
    void run () override; \
}; \
} /* end of unnamed namespace */ \
MERETDD_CLASS MERETDD_INSTANCE(testName); \
void MERETDD_CLASS::run ()
```

现在项目可以再次构建，运行它将显示新的测试。根据你的链接器构建最终可执行文件的顺序，你可能发现新的测试在之前的测试之前或之后运行。以下是我运行测试项目时的一部分结果：

```cpp
Running 7 tests
---------------
Test will pass without any confirms
Passed
---------------
Test can be created
Passed
---------------
```

其他五个测试和总结没有显示。前一章以六个测试结束，我们刚刚添加了一个，总数达到了七个测试。重要的是，新的测试运行并通过了。现在我们可以考虑确认将是什么样子。确认某件事意味着什么呢？

当运行测试时，你不仅想要验证测试是否完成，还要验证它是否正确完成。在过程中检查以确保一切按预期运行也有帮助。你可以通过比较从被测试的代码中获得的值来确保它们与你自己计算出的预期值相匹配。

假设你有一个函数，它将两个数字相加并返回一个结果。你可以用已知的值调用这个函数，并将返回的和与你自己计算出的预期和进行比较。你确认计算出的和与预期和相匹配。如果值匹配，则确认通过。但如果值不匹配，则确认失败，这应该导致测试也失败。

一个测试可以有多个确认，并且每个都会被检查以确保它们通过。一旦一个确认失败，就没有继续测试的意义，因为它已经失败了。一些 TDD 纯粹主义者会声称测试应该只有一个确认。我认为在只有一个确认和编写试图验证一切的史诗级测试之间有一个很好的折衷方案。

使用多个确认来编写测试的一种流行风格是跟踪通过确认的数量，即使确认失败，测试也会继续。这种风格有一个好处，因为开发者有时可以通过一次测试运行来解决多个问题。我们不采取这种方法，因为我认为在实践中很少能实现这种好处。有些人可能会争论这一点，但请听我说。一旦某件事被证明不符合你的预期，最可能的结果是进一步失败的连锁反应。我很少看到设计良好的测试在一次确认失败后，又 somehow 恢复通过相关的确认。如果测试表现出这种行为，那么它通常是在测试不相关的问题，应该被拆分成多个测试。我们将遵循的实践是：当一个确认失败时，测试本身就已经失败。其他测试可能进行得很好。但带有失败确认的测试已经失败了，继续查看是否测试的某个部分可能仍然正常是没有意义的。

当编写测试时，就像编写常规代码一样，避免重复是好的。换句话说，如果你发现自己通过检查其他测试中已经检查过的值来测试相同的事情，那么是时候考虑每个测试的目标了。编写一个测试，覆盖一些将被多次使用的基功能。然后，在其他使用相同功能的测试中，你可以假设它已经被测试并且工作正常，因此没有必要再次通过额外的确认来验证它。

一些代码可能会使这一切更加清晰。首先，让我们思考在没有确认的情况下如何验证预期的结果。这是一个我们无法直接编写确认将呈现的代码，因为我们还不知道我们希望它做什么的时候。需要进行一点探索。下一节将把在这里进行的探索转化为实际的确认。

让我们暂时假设我们有一个真实的 TDD 项目正在工作。我们将保持事情简单，并说我们需要一种方法来确定学校成绩是否及格。即使这个简单的例子，如果对于通过家庭作业、测验或测试有不同的及格标准，也可能变得复杂。如果是那样的话，可能涉及到整个类层次结构。我们只是需要一种简单的方法来确定 0 到 100 分的分数是否是及格分数。

现在我们有了我们的场景，一个简单的测试看起来会是什么样子？我们没有代码来支持评分要求。这只是我们想要的一般想法。因此，如果我们尝试在创建测试后立即运行，我们预期构建会失败。这就是你可以使用 TDD 来构思设计的方法。

目前，我们将这段代码放在`Confirm.cpp`内部。如果我们真的在为一个学校评分应用程序构建测试项目，那么可能有一个名为`Grades.cpp`的测试文件。因为我们只是在探索，我们将使用我们已有的测试文件，即`Confirm.cpp`，并创建一个这样的测试：

```cpp
TEST("Test passing grades")
{
    bool result = isPassingGrade(0);
    if (result)
    {
        throw 1;
    }
}
```

第一件事是考虑用法。如果你有一个名为`isPassingGrade`的函数，它接受一个分数并返回一个 bool 结果，这会满足你的要求并且易于使用吗？这似乎足够简单。它将执行所需的一切来告诉我们分数是否及格，并在分数及格时返回 true，不及格时返回 false。

然后，你可以考虑如何测试这个函数。测试边界条件总是好的，所以我们可以先问一个分数为 0 是否及格。我们将及格结果赋给一个可以与预期值进行比较的变量。我们预期 0 分是不及格的，这就是为什么如果结果是 true，代码会抛出异常。这将导致测试案例因为意外的异常而失败。

我们正在正确的轨道上。这是我想让你了解的关于在过程中进行检查以确保一切运行正常的内容。我们可以在同一个测试中添加另一个检查，如下所示，以确保 100 分是及格分数：

```cpp
TEST("Test passing grades")
{
    bool result = isPassingGrade(0);
    if (result)
    {
        throw 1;
    }
    result = isPassingGrade(100);
    if (not result)
    {
        throw 1;
    }
}
```

现在，你可以看到单个测试检查了两件事。首先，它确保 0 分是不及格的，然后 100 分是及格的。因为这些检查非常相关，我会把它们放在同一个测试中，并确认第一个案例应该是不及格的，第二个应该是及格的。

测试确认不过是简单地对预期值进行检查，如果预期未满足，则会抛出异常。

一些 TDD 纯粹主义者会建议你将测试分成两个独立的测试。我的建议是使用你的最佳判断。我倾向于避免绝对指导，即你应该“总是”以某种方式做某事。我认为有空间灵活处理。

让我们开始构建，以便我们可以运行它并查看结果。我们唯一需要做的是添加`isPassingGrade`函数。我们将函数添加到`Confirm.cpp`的顶部。如果这是一个你正在工作的真实项目，那么你会有一个更好的地方来放置这个函数。它不会在测试项目中；相反，它将被包含在正在测试的项目中。

在`Confirm.cpp`内部，创建一个名为`isPassingGrade`的函数，如下所示：

```cpp
bool isPassingGrade (int value)
{
    return true;
}
```

现在我们可以构建并运行项目以查看结果。我们感兴趣的测试结果会失败如下：

```cpp
---------------
Test passing grades
Failed
Unexpected exception thrown.
---------------
```

函数显然应该失败，因为它总是返回 true，不管给出的分数是多少。但那不是我们接下来要关注的重点。如果你真的在构建和测试一个评分应用程序，你会增强设计，让测试通过，然后增强测试，并继续直到所有测试都通过。

这足以说明我所说的通过检查正在运行的测试的进度，以确保其按预期进行。现在我们有一个测试，首先检查确保 0 分是一个不及格的分数，然后检查确保 100 分是一个及格的分数。这些检查中的每一个都是一个确认。在每一个点上，我们都在检查实际结果是否与预期相符。并且我们以不同的方式确认，以适应每种条件。

在下一节中，我们将增强测试库，以修复当前解决方案的问题，并使其更容易编写确认。目前，代码在检测到问题时抛出一个整数，虽然抛出确实会导致测试失败，但它会导致一个测试结果说明失败是由意外的异常引起的。

下一节将把`if`语句及其标准以及异常抛出包装成一个易于使用的宏，这将处理一切，并更好地描述实际失败的地方和原因。

# 增强测试库以支持断言

上一节中的及格分数测试有两个确认，我们将在本节中对其进行改进。它看起来是这样的：

```cpp
TEST("Test passing grades")
{
    bool result = isPassingGrade(0);
    if (result)
    {
        throw 1;
    }
    result = isPassingGrade(100);
    if (not result)
    {
        throw 1;
    }
}
```

在第一个确认中，我们想确保`result`是 false，因为我们知道 0 分不应该是一个及格的分数。而在第二个确认中，我们想确保这次`result`是 true，因为我们知道 100 分应该导致及格。

你能看出`if`条件需要与我们要确认的内容相反吗？这是因为当确认不符合预期值时，`if`块会运行。我们需要使其更容易使用，因为如果我们总是必须这样编写确认，这会导致错误。但测试代码中仍然存在更大的问题。

为什么检查失败时会抛出一个整数？这是因为我们仍在探索一个真正的确认应该是什么样子。我们现在的代码只是展示了在测试过程中进行检查的需要，以确保一切按预期进行。本节将改变我们在测试中编写确认的方式。

当一个值不符合预期时抛出一个整数，也会导致错误的测试结果描述。我们不希望测试结果说明抛出了意外的异常。

然而，我们确实想要抛出一个东西。因为一旦测试偏离了预期的路径，我们不想让测试继续进行。它已经表明测试已经失败了。在预期条件未满足时随时抛出是一个在那个点上失败测试的好方法。我们需要找出一种方法来更改测试结果描述，以便更好地告诉我们出了什么问题。

首先，让我们通过抛出一个更有意义的东西来修复测试结果。请注意，以下代码使用了硬编码的数值，例如 17 和 23。这样的数字通常被称为*魔法数字*，应该避免使用。我们很快就会解决这个问题，直接使用意义不明确的数字是为了向您展示有更好的方法。在`Confirm.cpp`中，将及格分数测试从两个确认中抛出`BoolConfirmException`，如下所示：

```cpp
TEST("Test passing grades")
{
    bool result = isPassingGrade(0);
    if (result)
    {
        throw MereTDD::BoolConfirmException(false, 17);
    }
    result = isPassingGrade(100);
    if (not result)
    {
        throw MereTDD::BoolConfirmException(true, 23);
    }
}
```

然后，我们将在稍后创建这个类。现在，我们想按照我们打算使用它的方式来编写代码。它被称为`BoolConfirmException`，因为它将让我们确认一个布尔值是否符合我们的预期。构造函数参数将是预期的布尔值和行号。我使用了行号 17 和 23，因为它们是我编辑器中两个`throw`语句的行号。在本节稍后，我们将使用一个宏，这样宏就可以自动提供行号。通常，你想要避免在代码中硬编码任何数值，除非是简单的值，如 0、1 和可能-1。任何其他值都被称为魔法数字，因为它们的含义是混淆的。

在确认中抛出的异常将基于制作有意义的测试结果描述所需的信息。对于布尔值，预期的值和行号就足够了。其他异常将需要更多信息，将在下一章中解释。我们将有多个异常类型，但它们将是相关的。继承是表示我们将抛出的不同异常类型的好方法。所有类型的基类将被称为`ConfirmException`。

在`Test.h`中，在`MereTDD`命名空间内创建一个名为`ConfirmException`的新类，如下所示：

```cpp
namespace MereTDD
{
class ConfirmException
{
public:
    ConfirmException () = default;
    virtual ~ConfirmException () = default;
    std::string_view reason () const
    {
        return mReason;
    }
protected:
    std::string mReason;
};
```

然后，紧随基异常类之后，我们可以声明派生的`BoolConfirmException`类，如下所示：

```cpp
class BoolConfirmException : public ConfirmException
{
public:
    BoolConfirmException (bool expected, int line)
    {
        mReason =  "Confirm failed on line ";
        mReason += std::to_string(line) + "\n";
        mReason += "    Expected: ";
        mReason += expected ? "true" : "false";
    }
};
```

`BoolConfirmException`的目的是通过基类中的`reason`方法格式化一个有意义的描述。

接下来，我们需要在运行测试时捕获基类，并显示确认原因而不是显示有意外异常的消息。修改`Test.h`中的`runTests`方法，使其能够捕获新的异常基类，并设置适当的失败消息，如下所示：

```cpp
        try
        {
            test->runEx();
        }
        catch (ConfirmException const & ex)
        {
            test->setFailed(ex.reason());
        }
```

确认异常已准备好。构建和运行显示以下测试结果：

```cpp
---------------
Test passing grades
Failed
Confirm failed on line 17
    Expected: false
---------------
```

这比说出现了意外的异常要好得多。现在，我们了解到在第 17 行出现了确认失败，测试期望的值是错误的。第 17 行对应于 0 分，这是我们期望的失败分数。

让我们为确认添加一个宏，这样我们就不必手动提供行号了。并且宏可以在`if`条件中包含反向逻辑以及抛出适当的确认异常。以下是使用宏的测试应该看起来像什么。我们将添加宏，但只有在编写了打算使用宏的代码之后。将`Confirm.cpp`中的及格分数测试更改如下：

```cpp
TEST("Test passing grades")
{
    bool result = isPassingGrade(0);
    CONFIRM_FALSE(result);
    result = isPassingGrade(100);
    CONFIRM_TRUE(result);
}
```

现在测试看起来真的像是在使用确认。此外，宏使得第一个确认期望`result`为假，而第二个确认期望`result`为真变得非常清楚。传递给宏的值称为*实际*值。只要实际值与期望值匹配，确认就通过并允许测试继续。

要定义这些宏，我们将它们放在`Test.h`的末尾。请注意，每个宏几乎与测试手动编写的代码完全相同：

```cpp
#define CONFIRM_FALSE( actual ) \
if (actual) \
{ \
    throw MereTDD::BoolConfirmException(false, __LINE__); \
}
#define CONFIRM_TRUE( actual ) \
if (not actual) \
{ \
    throw MereTDD::BoolConfirmException(true, __LINE__); \
}
```

你可以看到，当确认一个期望的值为假时，`if`条件寻找一个真实的实际值。此外，当确认一个期望的值为真时，`if`条件寻找一个错误实际值。这两个宏都会抛出`BoolConfirmException`并使用`__LINE__`自动获取行号。

现在，运行测试显示几乎完全相同的结果。唯一的区别是及格分数测试失败的行号。这是因为确认宏现在每行使用一个。结果如下所示：

```cpp
---------------
Test passing grades
Failed
Confirm failed on line 15
    Expected: false
---------------
```

现在确认的使用更加简单，它们使得测试更容易阅读和理解。我们的目标不是构建一个学校评分应用程序，所以我们将移除探索性代码。然而，在移除之前，下一节将使用及格分数测试来解释 TDD 的另一个重要方面。那就是关于错误情况应该怎么办的问题。

# 是否也应该测试错误情况？

是否可能达到 100%的测试代码覆盖率？这意味着什么？

让我通过继续使用我们在上一节中探索的及格分数代码来解释。这里再次是测试：

```cpp
TEST("Test passing grades")
{
    bool result = isPassingGrade(0);
    CONFIRM_FALSE(result);
    result = isPassingGrade(100);
    CONFIRM_TRUE(result);
}
```

目前，这个测试确实覆盖了被测试函数的 100%。这意味着`isPassingGrade`函数中的所有代码至少被一个测试运行。我知道，`isPassingGrade`函数是一个简单的函数，只有一行代码，总是返回 true。它看起来像这样：

```cpp
bool isPassingGrade (int value)
{
    return true;
}
```

对于这样一个简单的函数，只需在测试中调用它，就可以确保所有代码都被覆盖或运行。目前，这个函数不起作用，需要增强以通过两个确认。我们可以将其增强为如下所示：

```cpp
bool isPassingGrade (int value)
{
    if (value < 60)
    {
        return false;
    }
    return true;
}
```

现在构建和运行项目可以通过测试。及格分数测试的结果如下所示：

```cpp
---------------
Test passing grades
Passed
---------------
```

而且我们仍然为这个函数保持了 100%的代码覆盖率，因为通过成绩测试调用了函数两次，分别使用 0 和 100 的值。第一次调用使`if`条件为真，从而执行`if`块内的代码。第二次调用使`if`块之后的`return`语句执行。通过使用 0 和 100 的值调用`isPassingGrade`，我们确保了所有代码至少运行一次。这就是实现 100%代码覆盖率的意义。

0 和 100 这两个值都是有效的成绩，使用它们进行测试是有意义的。我们不需要测试如果我们用 1 或 99 的值调用`isPassingGrade`会发生什么。这是因为它们并不有趣。

边缘值几乎总是有趣的。因此，在测试中添加对 59 和 60 这两个值的几个调用是有意义的。虽然这些代表良好的调用值并确认需要添加到测试中，但它们对代码覆盖率没有任何帮助。

这引出了我想让你理解的第一点。仅仅达到 100%的代码覆盖率是不够的。你需要确保测试了所有需要测试的内容。寻找那些即使不会提高你的代码覆盖率，也应该进行测试的边缘情况。

然后寻找错误情况。

错误情况可能会驱使你添加额外的检查以确保错误情况得到适当处理。TDD（测试驱动开发）是驱动这些条件的好方法。或者，你可能会决定改变设计，使错误情况不再适用。

例如，检查一个负分是否通过是否有意义？如果是这样，肯定要添加一个测试，然后添加代码使测试通过。这是我会放入新测试中的事情。记住在每次测试中只有一个确认与允许多个确认之间的平衡？

将调用`isPassingGrade`的 0、59、60 和 100 的值的所有确认包含在一个测试中是有意义的。至少对我来说是这样的。

然而，使用-1 的值调用`isPassingGrade`是足够不同的，应该有它自己的测试。或者，考虑这个测试可能足以让你改变设计，使`isPassingGrade`不再接受 int 参数，而你决定使用无符号 int 参数。对于这个特定的例子，我可能会使用无符号 int。这意味着我们不再需要为-1 或任何负数成绩进行测试。

但关于超过 100 分的成绩呢？也许应该允许它们作为额外学分成绩。如果是这样，那么添加一个新的测试来测试超过 100 分的成绩，并确保它们通过。你可能会发现 101、110 和 1,000,000 这些值很有趣。

为什么是 101、110 和 1,000,000 这些值呢？好吧，101 是一个边缘值，应该包含在内。110 的值看起来像是一个合理的额外加分值。而 1,000,000 的值是一个很好的例子，它是一个荒谬的值，应该包含在内以确保代码不会因为一些意外的异常而失败。你甚至可以考虑将 1,000,000 的值放在自己的测试中。

错误情况应该被测试。理想情况下，你可以在编写测试时考虑错误情况，并在添加处理错误条件的代码之前先编写测试。例如，如果你决定任何超过 1,000 分的成绩都应该抛出异常，那么就编写一个期望异常的测试，并用 1,000 的值调用`isPassingGrade`以确保它确实抛出了异常。

关于测试错误情况的最后一个想法是：我见过很多没有使用 TDD（测试驱动开发）设计的代码，而且让我印象深刻的是，很多这样的代码中错误情况测试起来非常困难。有时，添加某些错误情况的测试已经不再可行，因为它们太难隔离，而且很难让它们运行，以便测试可以验证代码的响应。

一旦你开始遵循 TDD，你会发现你的测试覆盖率要好得多。这是因为你首先设计了测试，包括错误情况的测试。这迫使你从一开始就设计出可测试的设计。

# 摘要

在本章中，你学习了如何编写可以在测试结束前就检测到失败的测试。你学习了如何使用确认来确保实际值与你期望的值相匹配。然而，本章只解释了如何检查布尔值。你还需要检查许多其他类型的值，例如以下内容：

+   你可能有一个需要确认的数字，比如计数。

+   你可能需要检查一个字符串值，以确保它包含你期望的文本。

下一章将添加这些额外的类型，并解释比较分数或浮点数值时常见的一个问题。
