["```cpp\n    std::ofstream ofile(\"sample.bin\", std::ios::binary); \n    ```", "```cpp\n    if(ofile.is_open())\n    {\n      // streamed file operations\n    } \n    ```", "```cpp\n    std::vector<unsigned char> output {0,1,2,3,4,5,6,7,8,9};\n    ofile.write(reinterpret_cast<char*>(output.data()), output.size()); \n    ```", "```cpp\n    ofile.close(); \n    ```", "```cpp\n    std::ifstream ifile(\"sample.bin\", std::ios::binary); \n    ```", "```cpp\n    if(ifile.is_open())\n    {\n      // streamed file operations\n    } \n    ```", "```cpp\n    ifile.seekg(0, std::ios_base::end);\n    auto length = ifile.tellg();\n    ifile.seekg(0, std::ios_base::beg); \n    ```", "```cpp\n    std::vector<unsigned char> input;\n    input.resize(static_cast<size_t>(length)); \n    ```", "```cpp\n    ifile.read(reinterpret_cast<char*>(input.data()), length); \n    ```", "```cpp\n    auto success = !ifile.fail() && length == ifile.gcount(); \n    ```", "```cpp\n    ifile.close(); \n    ```", "```cpp\ntypedef basic_ifstream<char>    ifstream;\ntypedef basic_ifstream<wchar_t> wifstream;\ntypedef basic_ofstream<char>    ofstream;\ntypedef basic_ofstream<wchar_t> wofstream;\ntypedef basic_fstream<char>     fstream;\ntypedef basic_fstream<wchar_t>  wfstream; \n```", "```cpp\nstd::vector<int> numbers{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nstd::ofstream ofile(\"sample.bin\", std::ios::binary);\nif (ofile.is_open())\n{\n   ofile.write(reinterpret_cast<char*>(numbers.data()), \n               numbers.size() * sizeof(int));\n   ofile.close();\n} \n```", "```cpp\nstd::vector<int> input;\nstd::ifstream ifile(\"sample.bin\", std::ios::binary);\nif (ifile.is_open())\n{\n   ifile.seekg(0, std::ios_base::end);\n   auto length = ifile.tellg();\n   ifile.seekg(0, std::ios_base::beg);\n   input.resize(static_cast<size_t>(length) / sizeof(int));\n   ifile.read(reinterpret_cast<char*>(input.data()), length);\n   assert(!ifile.fail() && length == ifile.gcount());\n   ifile.close();\n} \n```", "```cpp\nbool write_data(char const * const filename,\n char const * const data,\n size_t const size)\n{\n  auto success = false;\n  std::ofstream ofile(filename, std::ios::binary);\n  if(ofile.is_open())\n  {\n    try\n    {\n      ofile.write(data, size);\n      success = true;\n    }\n    catch(std::ios_base::failure &)\n    {\n      // handle the error\n    }\n    ofile.close();\n  }\n  return success;\n}\nsize_t read_data(char const * const filename,\n                 std::function<char*(size_t const)> allocator)\n{\n  size_t readbytes = 0;\n  std::ifstream ifile(filename, std::ios::ate | std::ios::binary);\n  if(ifile.is_open())\n  {\n    auto length = static_cast<size_t>(ifile.tellg());\n    ifile.seekg(0, std::ios_base::beg);\n    auto buffer = allocator(length);\n    try\n    {\n      ifile.read(buffer, length);\n      readbytes = static_cast<size_t>(ifile.gcount());\n    }\n    catch (std::ios_base::failure &)\n    {\n      // handle the error\n    }\n    ifile.close();\n  }\n  return readbytes;\n} \n```", "```cpp\nstd::vector<int> output {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nstd::vector<int> input;\nif(write_data(\"sample.bin\",\n              reinterpret_cast<char*>(output.data()),\n              output.size() * sizeof(int)))\n{\n  auto lalloc = [&input](size_t const length) \n  {\n    input.resize(length) / sizeof(int);\n    return reinterpret_cast<char*>(input.data());\n };\n  if(read_data(\"sample.bin\", lalloc) > 0)\n  {\n    std::cout << (output == input ? \"equal\": \"not equal\")\n              << '\\n';\n  }\n} \n```", "```cpp\nstd::vector<int> output {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nstd::unique_ptr<int[]> input = nullptr;\nsize_t readb = 0;\nif(write_data(\"sample.bin\",\n              reinterpret_cast<char*>(output.data()),\n              output.size() * sizeof(int)))\n{\n  if((readb = read_data(\n     \"sample.bin\",\n     [&input](size_t const length) {\n       input.reset(new int[length / sizeof(int)]);\n       return reinterpret_cast<char*>(input.get()); })) > 0)\n  {\n    auto cmp = memcmp(output.data(), input.get(), output.size());\n    std::cout << (cmp == 0 ? \"equal\": \"not equal\") << '\\n';\n  }\n} \n```", "```cpp\n    std::vector<unsigned char> input;\n    std::ifstream ifile(\"sample.bin\", std::ios::binary);\n    if(ifile.is_open())\n    {\n      input = std::vector<unsigned char>(\n        std::istreambuf_iterator<char>(ifile),\n        std::istreambuf_iterator<char>());\n      ifile.close();\n    } \n    ```", "```cpp\n    std::vector<unsigned char> input;\n    std::ifstream ifile(\"sample.bin\", std::ios::binary);\n    if(ifile.is_open())\n    {\n      ifile.seekg(0, std::ios_base::end);\n      auto length = ifile.tellg();\n      ifile.seekg(0, std::ios_base::beg);\n      input.reserve(static_cast<size_t>(length));\n        input.assign(\n        std::istreambuf_iterator<char>(ifile),\n        std::istreambuf_iterator<char>());\n      ifile.close();\n    } \n    ```", "```cpp\n    std::vector<unsigned char> input;\n    std::ifstream ifile(\"sample.bin\", std::ios::binary);\n    if(ifile.is_open())\n    {\n      ifile.seekg(0, std::ios_base::end);\n      auto length = ifile.tellg();\n      ifile.seekg(0, std::ios_base::beg);\n      input.reserve(static_cast<size_t>(length));\n      std::copy(std::istreambuf_iterator<char>(ifile),\n                std::istreambuf_iterator<char>(),\n                std::back_inserter(input));\n      ifile.close();\n    } \n    ```", "```cpp\nclass foo\n{\n  int         i;\n  char        c;\n  std::string s;\npublic:\n  foo(int const i = 0, char const c = 0, std::string const & s = {}):\n    i(i), c(c), s(s)\n  {}\n  foo(foo const &) = default;\n  foo& operator=(foo const &) = default;\n  bool operator==(foo const & rhv) const\n  {\n    return i == rhv.i &&\n           c == rhv.c &&\n           s == rhv.s;\n  }\n  bool operator!=(foo const & rhv) const\n  {\n    return !(*this == rhv);\n  }\n};\nstruct foopod\n{\n  bool a;\n  char b;\n  int  c[2];\n};\nbool operator==(foopod const & f1, foopod const & f2)\n{\n  return f1.a == f2.a && f1.b == f2.b &&\n         f1.c[0] == f2.c[0] && f1.c[1] == f2.c[1];\n} \n```", "```cpp\n    std::vector<foopod> output {\n      {true, '1', {1, 2}},\n      {true, '2', {3, 4}},\n      {false, '3', {4, 5}}\n    };\n    std::ofstream ofile(\"sample.bin\", std::ios::binary);\n    if(ofile.is_open())\n    {\n      for(auto const & value : output)\n      {\n        ofile.write(reinterpret_cast<const char*>(&value),\n                    sizeof(value));\n      }\n      ofile.close();\n    } \n    ```", "```cpp\n    std::vector<foopod> input;\n    std::ifstream ifile(\"sample.bin\", std::ios::binary);\n    if(ifile.is_open())\n    {\n      while(true)\n      {\n        foopod value;\n        ifile.read(reinterpret_cast<char*>(&value), sizeof(value));\n        if(ifile.fail() || ifile.eof()) break;\n        input.push_back(value);\n      }\n      ifile.close();\n    } \n    ```", "```cpp\n    bool write(std::ofstream& ofile) const\n    {\n      ofile.write(reinterpret_cast<const char*>(&i), sizeof(i));\n      ofile.write(&c, sizeof(c));\n      auto size = static_cast<int>(s.size());\n      ofile.write(reinterpret_cast<char*>(&size), sizeof(size));\n      ofile.write(s.data(), s.size());\n      return !ofile.fail();\n    } \n    ```", "```cpp\n    bool read(std::ifstream& ifile)\n    {\n      ifile.read(reinterpret_cast<char*>(&i), sizeof(i));\n      ifile.read(&c, sizeof(c));\n      auto size {0};\n      ifile.read(reinterpret_cast<char*>(&size), sizeof(size));\n      s.resize(size);\n      ifile.read(reinterpret_cast<char*>(&s.front()), size);\n      return !ifile.fail();\n    } \n    ```", "```cpp\n    friend std::ofstream& operator<<(std::ofstream& ofile, foo const& f);\n    friend std::ifstream& operator>>(std::ifstream& ifile, foo& f); \n    ```", "```cpp\n    std::ofstream& operator<<(std::ofstream& ofile, foo const& f)\n    {\n      ofile.write(reinterpret_cast<const char*>(&f.i),\n                  sizeof(f.i));\n      ofile.write(&f.c, sizeof(f.c));\n      auto size = static_cast<int>(f.s.size());\n      ofile.write(reinterpret_cast<char*>(&size), sizeof(size));\n      ofile.write(f.s.data(), f.s.size());\n      return ofile;\n    } \n    ```", "```cpp\n    std::ifstream& operator>>(std::ifstream& ifile, foo& f)\n    {\n      ifile.read(reinterpret_cast<char*>(&f.i), sizeof(f.i));\n      ifile.read(&f.c, sizeof(f.c));\n      auto size {0};\n      ifile.read(reinterpret_cast<char*>(&size), sizeof(size));\n      f.s.resize(size);\n      ifile.read(reinterpret_cast<char*>(&f.s.front()), size);\n      return ifile;\n    } \n    ```", "```cpp\n    char text[] = \"1 1 2 3 5 8\";\n    std::ispanstream is{ std::span<char>{text} };\n    int value;\n    while (is >> value)\n    {\n       std::cout << value << '\\n';\n    } \n    ```", "```cpp\n    char text[15]{};\n    int numbers[]{ 1, 1, 2, 3, 5, 8 };\n    std::ospanstream os{ std::span<char>{text} };         \n    for (int n : numbers)\n    {\n       os << n << ' ';\n    } \n    ```", "```cpp\n    char text[] = \"1 1 2 3 5 8 \";\n    std::vector<int> numbers;\n    std::spanstream ss{ std::span<char>{text} };\n    int value;\n    while (ss >> value)\n    {\n       numbers.push_back(value);\n    }\n    ss.clear();\n    ss.seekp(0);\n    std::for_each(numbers.rbegin(), numbers.rend(), \n                  [&ss](const int n) { ss << n << ' '; });\n    std::cout << text << '\\n'; // prints 8 5 3 2 1 1 \n    ```", "```cpp\nchar const text[] = \"severity=1,code=42,message=generic error\";\nstd::unordered_map<std::string, std::string> m;\nstd::string key, val;\nstd::ispanstream is(text);\nwhile (std::getline(is, key, '=') >> std::ws)\n{\n   if(std::getline(is, val, ','))\n      m[key] = val;\n}\nfor (auto const & [k, v] : m)\n{\n   std::cout << k << \" : \" << v << '\\n';\n} \n```", "```cpp\nchar text[3]{};\nstd::ospanstream os{ std::span<char>{text} };\nos << \"42\";\nauto pos = os.tellp();\nos << \"44\";\nif (!os.good())\n{\n   os.clear();\n   os.seekp(pos);\n}\n// text is {'4','2','4'}\n// prints (examples): 424╠╠╠╠╠... or 424MƂ![](img/11.png) etc.\nstd::cout << text << '\\n';\nos << '\\0';\n// text is {'4','2','\\0'}\n// prints: 42\nstd::cout << text << '\\n'; \n```", "```cpp\nauto now = std::chrono::system_clock::now();\nauto stime = std::chrono::system_clock::to_time_t(now);\nauto ltime = std::localtime(&stime);\nstd::vector<std::string> names\n  {\"John\", \"adele\", \"Øivind\", \"François\", \"Robert\", \"Åke\"};\nauto sort_and_print = [](std::vector<std::string> v,\n                         std::locale const & loc)\n{\n  std::sort(v.begin(), v.end(), loc);\n  for (auto const & s : v) std::cout << s << ' ';\n  std::cout << '\\n';\n}; \n```", "```cpp\n        // default construct\n        auto loc_def = std::locale {};\n        // from a name\n        auto loc_us = std::locale {\"en_US.utf8\"};\n        // from another locale except for a facet\n        auto loc1 = std::locale {loc_def, new std::collate<wchar_t>};\n        // from another local, except the facet in a category\n        auto loc2 = std::locale {loc_def, loc_us, std::locale::collate}; \n        ```", "```cpp\n    auto loc = std::locale::classic(); \n    ```", "```cpp\n    std::locale::global(std::locale(\"en_US.utf8\")); \n    ```", "```cpp\n    std::cout.imbue(std::locale(\"en_US.utf8\")); \n    ```", "```cpp\n    auto loc = std::locale(\"de_DE.utf8\");\n    std::cout.imbue(loc);\n    std::cout << 1000.50 << '\\n';\n    // 1.000,5\n    std::cout << std::showbase << std::put_money(1050) << '\\n';\n    // 10,50 €\n    std::cout << std::put_time(ltime, \"%c\") << '\\n';\n    // So 04 Dez 2016 17:54:06 JST\n    sort_and_print(names, loc);\n    // adele Åke François John Øivind Robert \n    ```", "```cpp\n    auto loc = std::locale(\"\");\n    std::cout.imbue(loc);\n    std::cout << 1000.50 << '\\n';\n    // 1,000.5\n    std::cout << std::showbase << std::put_money(1050) << '\\n';\n    // $10.50\n    std::cout << std::put_time(ltime, \"%c\") << '\\n';\n    // Sun 04 Dec 2016 05:54:06 PM JST\n    sort_and_print(names, loc);\n    // adele Åke François John Øivind Robert \n    ```", "```cpp\n    std::locale::global(std::locale(\"no_NO.utf8\")); // set global\n    auto loc = std::locale{};                       // use global\n    std::cout.imbue(loc);\n    std::cout << 1000.50 << '\\n';\n    // 1 000,5\n    std::cout << std::showbase << std::put_money(1050) << '\\n';\n    // 10,50 kr\n    std::cout << std::put_time(ltime, \"%c\") << '\\n';\n    // sön 4 dec 2016 18:02:29\n    sort_and_print(names, loc);\n    // adele François John Robert Øivind Åke \n    ```", "```cpp\n    auto loc = std::locale::classic();\n    std::cout.imbue(loc);\n    std::cout << 1000.50 << '\\n';\n    // 1000.5\n    std::cout << std::showbase << std::put_money(1050) << '\\n';\n    // 1050\n    std::cout << std::put_time(ltime, \"%c\") << '\\n';\n    // Sun Dec 4 17:55:14 2016\n    sort_and_print(names, loc);\n    // François John Robert adele Åke Øivind \n    ```", "```cpp\nstd::locale loc = std::locale(\"English_US.1252\")\n                  .combine<std::numpunct<char>>(\n                     std::locale(\"Norwegian_Norway.1252\"));\nstd::cout.imbue(loc);\nstd::cout << \"en_US locale with no_NO numpunct: \" << 42.99 << '\\n';\n// en_US locale with no_NO numpunct: 42,99 \n```", "```cpp\n    std::cout << std::boolalpha << true << '\\n';    // true\n    std::cout << false << '\\n';                     // false\n    std::cout << std::noboolalpha << false << '\\n'; // 0 \n    ```", "```cpp\n    std::cout << std::right << std::setw(10) << \"right\\n\";\n    std::cout << std::setw(10) << \"text\\n\";\n    std::cout << std::left << std::setw(10) << \"left\\n\"; \n    ```", "```cpp\n    std::cout << std::fixed << 0.25 << '\\n';         // 0.250000\n    std::cout << std::scientific << 0.25 << '\\n';    // 2.500000e-01\n    std::cout << std::hexfloat << 0.25 << '\\n';      // 0x1p-2\n    std::cout << std::defaultfloat << 0.25 << '\\n';  // 0.25 \n    ```", "```cpp\n    std::cout << std::oct << 42 << '\\n'; // 52\n    std::cout << std::hex << 42 << '\\n'; // 2a\n    std::cout << std::dec << 42 << '\\n'; // 42 \n    ```", "```cpp\n    std::cout << std::right\n              << std::setfill('.') << std::setw(10)\n              << \"right\" << '\\n';\n    // .....right \n    ```", "```cpp\n    std::cout << std::fixed << std::setprecision(2) << 12.345 << '\\n';\n    // 12.35 \n    ```", "```cpp\nstd::ios_base& hex(std::ios_base& str); \n```", "```cpp\ntemplate<class CharT>\n/*unspecified*/ setfill(CharT c); \n```", "```cpp\nstruct Chapter\n{\n  int Number;\n  std::string Title;\n  int Page;\n};\nstruct BookPart\n{\n  std::string Title;\n  std::vector<Chapter> Chapters;\n};\nstruct Book\n{\n  std::string Title;\n  std::vector<BookPart> Parts;\n};\nstd::string to_roman(unsigned int value)\n{\n  struct roman_t { unsigned int value; char const* numeral; };\n  const static roman_t rarr[13] =\n  {\n    {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n    { 100, \"C\"}, { 90, \"XC\"}, { 50, \"L\"}, { 40, \"XL\"},\n    {  10, \"X\"}, {  9, \"IX\"}, {  5, \"V\"}, {  4, \"IV\"},\n    {   1, \"I\"}\n  };\n  std::string result;\n  for (auto const & number : rarr)\n  {\n    while (value >= number.value)\n    {\n      result += number.numeral;\n      value -= number.value;\n    }\n  }\n  return result;\n} \nBook as its argument and prints its content to the console according to the specified requirements. For this purpose, we use the following:\n```", "```cpp\nvoid print_toc(Book const & book)\n{\n  std::cout << book.Title << '\\n';\n  for(auto const & part : book.Parts)\n  {\n    std::cout << std::left << std::setw(15) << std::setfill(' ')\n              << part.Title << '\\n';\n    std::cout << std::left << std::setw(15) << std::setfill('-')\n              << '-' << '\\n';\n    for(auto const & chapter : part.Chapters)\n    {\n      std::cout << std::right << std::setw(4) << std::setfill(' ')\n                << to_roman(chapter.Number) << ' ';\n      std::cout << std::left << std::setw(35) << std::setfill('.')\n                << chapter.Title;\n      std::cout << std::right << std::setw(3) << std::setfill('.')\n                << chapter.Page << '\\n';\n    }\n  }\n} \n```", "```cpp\nauto book = Book\n{\n  \"THE FELLOWSHIP OF THE RING\"s,\n  {\n    {\n      \"BOOK ONE\"s,\n      {\n        {1, \"A Long-expected Party\"s, 21},\n        {2, \"The Shadow of the Past\"s, 42},\n        {3, \"Three Is Company\"s, 65},\n        {4, \"A Short Cut to Mushrooms\"s, 86},\n        {5, \"A Conspiracy Unmasked\"s, 98},\n        {6, \"The Old Forest\"s, 109},\n        {7, \"In the House of Tom Bombadil\"s, 123},\n        {8, \"Fog on the Barrow-downs\"s, 135},\n        {9, \"At the Sign of The Prancing Pony\"s, 149},\n        {10, \"Strider\"s, 163},\n        {11, \"A Knife in the Dark\"s, 176},\n        {12, \"Flight to the Ford\"s, 197},\n      },\n    },\n    {\n      \"BOOK TWO\"s,\n      {\n        {1, \"Many Meetings\"s, 219},\n        {2, \"The Council of Elrond\"s, 239},\n        {3, \"The Ring Goes South\"s, 272},\n        {4, \"A Journey in the Dark\"s, 295},\n        {5, \"The Bridge of Khazad-dum\"s, 321},\n        {6, \"Lothlorien\"s, 333},\n        {7, \"The Mirror of Galadriel\"s, 353},\n        {8, \"Farewell to Lorien\"s, 367},\n        {9, \"The Great River\"s, 380},\n        {10, \"The Breaking of the Fellowship\"s, 390},\n      },\n    },\n  }\n};\nprint_toc(book); \n```", "```cpp\nTHE FELLOWSHIP OF THE RING\nBOOK ONE\n---------------\n   I A Long-expected Party...............21\n  II The Shadow of the Past..............42\n III Three Is Company....................65\n  IV A Short Cut to Mushrooms............86\n   V A Conspiracy Unmasked...............98\n  VI The Old Forest.....................109\n VII In the House of Tom Bombadil.......123\nVIII Fog on the Barrow-downs............135\n  IX At the Sign of The Prancing Pony...149\n   X Strider............................163\n  XI A Knife in the Dark................176\n XII Flight to the Ford.................197\nBOOK TWO\n---------------\n   I Many Meetings......................219\n  II The Council of Elrond..............239\n III The Ring Goes South................272\n  IV A Journey in the Dark..............295\n   V The Bridge of Khazad-dum...........321\n  VI Lothlorien.........................333\n VII The Mirror of Galadriel............353\nVIII Farewell to Lorien.................367\n  IX The Great River....................380\n   X The Breaking of the Fellowship.....390 \n```", "```cpp\nstruct Company\n{\n  std::string Name;\n  std::string Industry;\n  double      Revenue;\n  bool        RevenueIncrease;\n  double      Growth;\n  int         Employees;\n  std::string Country;\n}; \n```", "```cpp\nvoid print_companies(std::vector<Company> const & companies)\n{\n  for(auto const & company : companies)\n  {\n    std::cout << std::left << std::setw(26) << std::setfill(' ')\n              << company.Name;\n    std::cout << std::left << std::setw(18) << std::setfill(' ')\n              << company.Industry;\n    std::cout << std::left << std::setw(5) << std::setfill(' ')\n              << company.Revenue;\n    std::cout << std::left << std::setw(5) << std::setfill(' ')\n              << std::boolalpha << company.RevenueIncrease\n              << std::noboolalpha;\n    std::cout << std::right << std::setw(5) << std::setfill(' ')\n              << std::fixed << std::setprecision(1) << company.Growth\n              << std::defaultfloat << std::setprecision(6) << ' ';\n    std::cout << std::right << std::setw(8) << std::setfill(' ')\n              << company.Employees << ' ';\n    std::cout << std::left << std::setw(2) << std::setfill(' ')\n              << company.Country\n              << '\\n';\n  }\n} \n```", "```cpp\nstd::vector<Company> companies\n{\n  {\"Walmart\"s, \"Retail\"s, 482, false, 0.71,\n    2300000, \"US\"s},\n  {\"State Grid\"s, \"Electric utility\"s, 330, false, 2.91,\n    927839, \"China\"s},\n  {\"Saudi Aramco\"s, \"Oil and gas\"s, 311, true, 40.11,\n    65266, \"SA\"s},\n  {\"China National Petroleum\"s, \"Oil and gas\"s, 299,\n    false, 30.21, 1589508, \"China\"s},\n  {\"Sinopec Group\"s, \"Oil and gas\"s, 294, false, 34.11,\n    810538, \"China\"s},\n};\nprint_companies(companies); \n```", "```cpp\nWalmart                   Retail            482  false  0.7  2300000 US\nState Grid                Electric utility  330  false  2.9   927839 China\nSaudi Aramco              Oil and gas       311  true  40.1    65266 SA\nChina National Petroleum  Oil and gas       299  false 30.2  1589508 China\nSinopec Group             Oil and gas       294  false 34.1   810538 China \n```", "```cpp\n    std::cout.imbue(std::locale(\"en_GB.utf8\")); \n    ```", "```cpp\n    long double mon = 12345.67;\n    std::string smon = \"12345.67\"; \n    ```", "```cpp\n    std::cout << std::showbase << std::put_money(mon)\n              << '\\n'; // £123.46\n    std::cout << std::showbase << std::put_money(smon)\n              << '\\n'; // £123.46 \n    ```", "```cpp\n    std::cout << std::showbase << std::put_money(mon, true)\n              << '\\n'; // GBP 123.46\n    std::cout << std::showbase << std::put_money(smon, true)\n              << '\\n'; // GBP 123.46 \n    ```", "```cpp\n    std::istringstream stext(\"$123.45 567.89 USD\");\n    stext.imbue(std::locale(\"en_US.utf8\")); \n    ```", "```cpp\n    long double v1 = 0;\n    std::string v2; \n    ```", "```cpp\n    stext >> std::get_money(v1) >> std::get_money(v2);\n    // v1 = 12345, v2 = \"56789\" \n    ```", "```cpp\n    std::istringstream stext(\"123.45 567.89\");\n    stext.imbue(std::locale(\"en_US.utf8\"));\n    long double v1 = 0;\n    std::string v2;\n    stext >> std::get_money(v1, true) >> std::get_money(v2, true);\n    // v1 = 12345, v2 = \"56789\" \n    ```", "```cpp\ntemplate <class MoneyT>\n/*unspecified*/ put_money(const MoneyT& mon, bool intl = false);\ntemplate <class MoneyT>\n/*unspecified*/ get_money(MoneyT& mon, bool intl = false); \n```", "```cpp\nstd::cout << std::put_money(12345.67) << '\\n';\n// prints 123.46\nstd::cout << std::showbase << std::put_money(12345.67) << '\\n';\n// prints £123.46 \n123.46, while the second line will print the same numerical value but preceded by the currency symbol.\n```", "```cpp\n    auto now = std::chrono::system_clock::now();\n    auto stime = std::chrono::system_clock::to_time_t(now);\n    auto ltime = std::localtime(&stime);\n    auto ttime = std::time(nullptr);\n    auto ltime = std::localtime(&ttime); \n    ```", "```cpp\n    std::cout.imbue(std::locale(\"en_GB.utf8\"));\n    std::cout << std::put_time(ltime, \"%c\") << '\\n';\n    // Sun 04 Dec 2016 05:26:47 JST \n    ```", "```cpp\n    std::cout << std::put_time(ltime, \"%F\") << '\\n';\n    // 2016-12-04 \n    ```", "```cpp\n    std::cout << std::put_time(ltime, \"%T\") << '\\n';\n    // 05:26:47 \n    ```", "```cpp\n    std::cout << std::put_time(ltime, \"%FT%T%z\") << '\\n';\n    // 2016-12-04T05:26:47+0900 \n    ```", "```cpp\n    std::cout << std::put_time(ltime, \"%Y-W%V\") << '\\n';\n    // 2016-W48 \n    ```", "```cpp\n    std::cout << std::put_time(ltime, \"%Y-W%V-%u\") << '\\n';\n    // 2016-W48-7 \n    ```", "```cpp\n    std::cout << std::put_time(ltime, \"%Y-%j\") << '\\n';\n    // 2016-339 \n    ```", "```cpp\n    auto time = std::tm {}; \n    ```", "```cpp\n    std::istringstream stext(\"2016-12-04T05:26:47+0900\");\n    stext >> std::get_time(&time, \"%Y-%m-%dT%H:%M:%S\");\n    if (!stext.fail()) { /* do something */ } \n    ```", "```cpp\n    std::istringstream stext(\"Sun 04 Dec 2016 05:35:30 JST\");\n    stext.imbue(std::locale(\"en_GB.utf8\"));\n    stext >> std::get_time(&time, \"%c\");\n    if (stext.fail()) { /* do something else */ } \n    ```", "```cpp\ntemplate<class CharT>\n/*unspecified*/ put_time(const std::tm* tmb, const CharT* fmt);\ntemplate<class CharT>\n/*unspecified*/ get_time(std::tm* tmb, const CharT* fmt); \n```", "```cpp\nstd::istringstream stext(\"2016-12-04T05:26:47+0900\");\nauto time = std::tm {};\nstext >> std::get_time(&time, \"%Y-%m-%dT%H:%M:%S%z\"); // fails\nstext >> std::get_time(&time, \"%Y-%m-%dT%H:%M:%S\");   // OK \n```", "```cpp\nnamespace fs = std::filesystem; \n```", "```cpp\n    // Windows\n    auto path = fs::path{\"C:\\\\Users\\\\Marius\\\\Documents\"};\n    // POSIX\n    auto path = fs::path{ \"/home/marius/docs\" }; \n    ```", "```cpp\n    path /= \"Book\";\n    path = path / \"Modern\" / \"Cpp\";\n    path.append(\"Programming\");\n    // Windows: C:\\Users\\Marius\\Documents\\Book\\Modern\\Cpp\\Programming\n    // POSIX:   /home/marius/docs/Book/Modern/Cpp/Programming \n    ```", "```cpp\n    auto path = fs::path{ \"C:\\\\Users\\\\Marius\\\\Documents\" };\n    path += \"\\\\Book\";\n    path.concat(\"\\\\Modern\");\n    // path = C:\\Users\\Marius\\Documents\\Book\\Modern \n    ```", "```cpp\n    auto path =\n      fs::path{\"C:\\\\Users\\\\Marius\\\\Documents\\\\sample.file.txt\"};\n    std::cout\n      << \"root: \"        << path.root_name() << '\\n'\n      << \"root dir: \"    << path.root_directory() << '\\n'\n      << \"root path: \"   << path.root_path() << '\\n'\n      << \"rel path: \"    << path.relative_path() << '\\n'\n      << \"parent path: \" << path.parent_path() << '\\n'\n      << \"filename: \"    << path.filename() << '\\n'\n      << \"stem: \"        << path.stem() << '\\n'\n      << \"extension: \"   << path.extension() << '\\n'; \n    ```", "```cpp\n    auto path =\n      fs::path{\"C:\\\\Users\\\\Marius\\\\Documents\\\\sample.file.txt\"};\n    std::cout\n      << \"has root: \"        << path.has_root_name() << '\\n'\n      << \"has root dir: \"    << path.has_root_directory() << '\\n'\n      << \"has root path: \"   << path.has_root_path() << '\\n'\n      << \"has rel path: \"    << path.has_relative_path() << '\\n'\n      << \"has parent path: \" << path.has_parent_path() << '\\n'\n      << \"has filename: \"    << path.has_filename() << '\\n'\n      << \"has stem: \"        << path.has_stem() << '\\n'\n      << \"has extension: \"   << path.has_extension() << '\\n'; \n    ```", "```cpp\n    auto path2 = fs::path{ \"marius\\\\temp\" };\n    std::cout\n      << \"absolute: \" << path1.is_absolute() << '\\n'\n      << \"absolute: \" << path2.is_absolute() << '\\n'; \n    ```", "```cpp\n    auto path =\n      fs::path{\"C:\\\\Users\\\\Marius\\\\Documents\\\\sample.file.txt\"};\n    path.replace_filename(\"output\");\n    path.replace_extension(\".log\");\n    // path = C:\\Users\\Marius\\Documents\\output.log\n    path.remove_filename();\n    // path = C:\\Users\\Marius\\Documents \n    ```", "```cpp\n    // Windows\n    auto path = fs::path{\"Users/Marius/Documents\"};\n    path.make_preferred();\n    // path = Users\\Marius\\Documents\n    // POSIX\n    auto path = fs::path{ \"\\\\home\\\\marius\\\\docs\" };\n    path.make_preferred();\n    // path = /home/marius/docs \n    ```", "```cpp\nauto path =\n  fs::path{ \"C:\\\\Users\\\\Marius\\\\Documents\\\\sample.file.txt\" };\nfor (auto const & part : path)\n{\n  std::cout << part << '\\n';\n} \n```", "```cpp\nC:\nUsers\nMarius\nDocuments\nsample.file.txt \n```", "```cpp\nauto err = std::error_code{};\nauto basepath = fs::current_path();\nauto path = basepath / \"temp\";\nauto filepath = path / \"sample.txt\"; \n```", "```cpp\n    auto success = fs::create_directory(path, err); \n    ```", "```cpp\n    auto temp = path / \"tmp1\" / \"tmp2\" / \"tmp3\";\n    auto success = fs::create_directories(temp, err); \n    ```", "```cpp\n    auto temp = path / \"tmp1\" / \"tmp2\" / \"tmp3\";\n    auto newtemp = path / \"tmp1\" / \"tmp3\";\n    fs::rename(temp, newtemp, err);\n    if (err) std::cout << err.message() << '\\n'; \n    ```", "```cpp\n    auto temp = path / \"tmp1\" / \"tmp3\";\n    auto newtemp = path / \"tmp1\" / \"tmp4\";\n    fs::rename(temp, newtemp, err);\n    if (err) std::cout << err.message() << '\\n'; \n    ```", "```cpp\n    fs::copy(path, basepath / \"temp2\",\n             fs::copy_options::recursive, err);\n    if (err) std::cout << err.message() << '\\n'; \n    ```", "```cpp\n    auto linkdir = basepath / \"templink\";\n    fs::create_directory_symlink(path, linkdir, err);\n    if (err) std::cout << err.message() << '\\n'; \n    ```", "```cpp\n    auto temp = path / \"tmp1\" / \"tmp4\";\n    auto success = fs::remove(temp, err); \n    ```", "```cpp\n    auto success = fs::remove_all(path, err) !=\n                   static_cast<std::uintmax_t>(-1); \n    ```", "```cpp\n    // replace permissions with specified ones\n    fs::permissions(temp, fs::perms::owner_all | \n                          fs::perms::group_all, err);\n    if (err) std::cout << err.message() << '\\n';\n    // remove specified permissions\n    fs::permissions(temp, fs::perms::group_exec,\n                          fs::perm_options::remove, err);\n    if (err) std::cout << err.message() << '\\n'; \n    ```", "```cpp\n    auto success = fs::copy_file(filepath, path / \"sample.bak\", err);\n    if (!success) std::cout << err.message() << '\\n';\n    fs::copy(filepath, path / \"sample.cpy\", err);\n    if (err) std::cout << err.message() << '\\n'; \n    ```", "```cpp\n    auto newpath = path / \"sample.log\";\n    fs::rename(filepath, newpath, err);\n    if (err) std::cout << err.message() << '\\n'; \n    ```", "```cpp\n    auto newpath = path / \"sample.log\";\n    fs::rename(newpath, path / \"tmp1\" / \"sample.log\", err);\n    if (err) std::cout << err.message() << '\\n'; \n    ```", "```cpp\n    auto linkpath = path / \"sample.txt.link\";\n    fs::create_symlink(filepath, linkpath, err);\n    if (err) std::cout << err.message() << '\\n'; \n    ```", "```cpp\n    auto success = fs::remove(path / \"sample.cpy\", err);\n    if (!success) std::cout << err.message() << '\\n'; \n    ```", "```cpp\nenum class copy_options\n{\n  none               = 0,\n  skip_existing      = 1,\n  overwrite_existing = 2,\n  update_existing    = 4,\n  recursive          = 8,\n  copy_symlinks      = 16,\n  skip_symlinks      = 32,\n  directories_only   = 64,\n  create_symlinks    = 128,\n  create_hard_links  = 256\n}; \n```", "```cpp\n;Shakespeare's plays, listed by genre\n;TRAGEDIES\nTroilus and Cressida\nCoriolanus\nTitus Andronicus\nRomeo and Juliet\nTimon of Athens\nJulius Caesar \n```", "```cpp\nauto path = fs::current_path();\nauto filepath = path / \"sample.dat\";\nauto temppath = path / \"sample.tmp\";\nauto err = std::error_code{}; \n```", "```cpp\n    std::ifstream in(filepath);\n    if (!in.is_open())\n    {\n      std::cout << \"File could not be opened!\" << '\\n';\n      return;\n    } \n    ```", "```cpp\n    std::ofstream out(temppath, std::ios::trunc);\n    if (!out.is_open())\n    {\n      std::cout << \"Temporary file could not be created!\" << '\\n';\n      return;\n    } \n    ```", "```cpp\n    auto line = std::string{};\n    while (std::getline(in, line))\n    {\n      if (!line.empty() && line.at(0) != ';')\n      {\n        out << line << 'n';\n      }\n    } \n    ```", "```cpp\n    in.close();\n    out.close(); \n    ```", "```cpp\n    auto success = fs::remove(filepath, err);\n    if(!success || err)\n    {\n      std::cout << err.message() << '\\n';\n      return;\n    } \n    ```", "```cpp\n    fs::rename(temppath, filepath, err);\n    if (err)\n    {\n      std::cout << err.message() << '\\n';\n    } \n    ```", "```cpp\nauto path = fs::current_path() / \"main.cpp\";\nauto err = std::error_code{}; \n```", "```cpp\n template <typename TP>\n  std::time_t to_time_t(TP tp)\n {\n     using namespace std::chrono;\n     auto sctp = time_point_cast<system_clock::duration>(\n       tp - TP::clock::now() + system_clock::now());\n     return system_clock::to_time_t(sctp);\n  } \n```", "```cpp\n    auto exists = fs::exists(path, err);\n    std::cout << \"file exists: \" << std::boolalpha\n              << exists << '\\n'; \n    ```", "```cpp\n    auto same = fs::equivalent(path,\n                   fs::current_path() / \".\" / \"main.cpp\", err);\n    std::cout << \"equivalent: \" << same << '\\n'; \n    ```", "```cpp\n    auto size = fs::file_size(path, err);\n    std::cout << \"file size: \" << size << '\\n'; \n    ```", "```cpp\n    auto links = fs::hard_link_count(path, err);\n    if(links != static_cast<uintmax_t>(-1))\n      std::cout << \"hard links: \" << links << '\\n';\n    else\n      std::cout << \"hard links: error\" << '\\n'; \n    ```", "```cpp\n    auto lwt = fs::last_write_time(path, err);\n    auto time = to_time_t(lwt);\n    auto localtime = std::localtime(&time);\n    std::cout << \"last write time: \"\n              << std::put_time(localtime, \"%c\") << '\\n'; \n    ```", "```cpp\n    auto print_perm = [](fs::perms p)\n    {\n      std::cout\n        << ((p & fs::perms::owner_read) != fs::perms::none ?\n           \"r\" : \"-\")\n        << ((p & fs::perms::owner_write) != fs::perms::none ?\n           \"w\" : \"-\")\n        << ((p & fs::perms::owner_exec) != fs::perms::none ?\n           \"x\" : \"-\")\n        << ((p & fs::perms::group_read) != fs::perms::none ?\n           \"r\" : \"-\")\n        << ((p & fs::perms::group_write) != fs::perms::none ?\n           \"w\" : \"-\")\n        << ((p & fs::perms::group_exec) != fs::perms::none ?\n           \"x\" : \"-\")\n        << ((p & fs::perms::others_read) != fs::perms::none ?\n           \"r\" : \"-\")\n        << ((p & fs::perms::others_write) != fs::perms::none ?\n           \"w\" : \"-\")\n        << ((p & fs::perms::others_exec) != fs::perms::none ?\n           \"x\" : \"-\")\n        << '\\n';\n    };\n    auto status = fs::status(path, err);\n    std::cout << \"type: \" << static_cast<int>(status.type()) << '\\n';\n    std::cout << \"permissions: \";\n    print_perm(status.permissions()); \n    ```", "```cpp\n    std::cout << \"regular file? \" <<\n              fs::is_regular_file(path, err) << '\\n';\n    std::cout << \"directory? \" <<\n              fs::is_directory(path, err) << '\\n';\n    std::cout << \"char file? \" <<\n              fs::is_character_file(path, err) << '\\n';\n    std::cout << \"symlink? \" <<\n              fs::is_symlink(path, err) << '\\n'; \n    ```", "```cpp\n    bool empty = fs::is_empty(path, err);\n    if (!err)\n    {\n       std::cout << std::boolalpha\n                 << \"is_empty(): \" << empty << '\\n';\n    } \n    ```", "```cpp\n    using namespace std::chrono_literals;\n    auto lwt = fs::last_write_time(path, err);\n    fs::last_write_time(path, lwt - 30min); \n    ```", "```cpp\n    fs::permissions(\n      path,\n      fs::perms::add_perms |\n      fs::perms::owner_all | fs::perms::group_all,\n      err); \n    ```", "```cpp\n    auto s = fs::status(path, err);\n    auto isfile = s.type() == std::filesystem::file_type::regular;\n    auto isfile = fs::is_regular_file(path, err); \n    ```", "```cpp\nauto lwt = fs::last_write_time(path, err);\nif (!err) // success\n{\n   auto time = to_time_t(lwt);\n   auto localtime = std::localtime(&time);\n   std::cout << \"last write time: \"\n             << std::put_time(localtime, \"%c\") << '\\n';\n} \n```", "```cpp\ntry\n{\n   auto exists = fs::exists(path);\n   std::cout << \"file exists: \" << std::boolalpha << exists << '\\n';\n}\ncatch (std::filesystem::filesystem_error const& ex)\n{\n   std::cerr << ex.what() << '\\n';\n} \n```", "```cpp\ntest/\n├──data/\n│ ├──input.dat\n│ └──output.dat\n├──file_1.txt\n├──file_2.txt\n└──file_3.log \n```", "```cpp\nvoid print_line(std::string_view prefix, \n                std::filesystem::path const& path)\n{\n   std::cout << prefix << path << '\\n';\n} \n```", "```cpp\n    void visit_directory(fs::path const & dir)\n    {\n      if (fs::exists(dir) && fs::is_directory(dir))\n      {\n        for (auto const & entry : fs::directory_iterator(dir))\n        {\n          auto filename = entry.path().filename();\n          if (fs::is_directory(entry.status()))\n            print_line(\"[+]\", filename);\n          else if (fs::is_symlink(entry.status()))\n            print_line(\"[>]\", filename);\n          else if (fs::is_regular_file(entry.status()))\n            print_line(\" \", filename);\n          else\n            print_line(\"[?]\", filename);\n        }\n      }\n    } \n    ```", "```cpp\n    void visit_directory_rec(fs::path const & dir)\n    {\n      if (fs::exists(dir) && fs::is_directory(dir))\n      {\n        for (auto const & entry :\n             fs::recursive_directory_iterator(dir))\n        {\n          auto filename = entry.path().filename();\n          if (fs::is_directory(entry.status()))\n            print_line(\"[+]\", filename);\n          else if (fs::is_symlink(entry.status()))\n            print_line(\"[>]\",filename);\n          else if (fs::is_regular_file(entry.status()))\n            print_line(\" \",filename);\n          else\n            print_line(\"[?]\",filename);\n        }\n      }\n    } \n    ```", "```cpp\n    void visit_directory_rec_ordered(\n      fs::path const & dir,\n     bool const recursive = false,\n     unsigned int const level = 0)\n    {\n      if (fs::exists(dir) && fs::is_directory(dir))\n      {\n        auto lead = std::string(level*3, ' ');\n        for (auto const & entry : fs::directory_iterator(dir))\n        {\n          auto filename = entry.path().filename();\n          if (fs::is_directory(entry.status()))\n          {\n            print_line(lead + \"[+]\", filename);\n            if(recursive)\n              visit_directory_rec_ordered(entry, recursive, \n     level+1);\n          }\n          else if (fs::is_symlink(entry.status()))\n            print_line(lead + \"[>]\", filename);\n          else if (fs::is_regular_file(entry.status()))\n            print_line(lead + \" \", filename);\n          else\n            print_line(lead + \"[?]\", filename);\n        }\n      }\n    } \n    ```", "```cpp\nvisit_directory_rec(fs::current_path() / \"test\"); \n```", "```cpp\n[+]data\n   input.dat\n   output.dat\n   file_1.txt\n   file_2.txt\n   file_3.log \n```", "```cpp\nvisit_directory_rec_ordered(fs::current_path() / \"test\", true); \n```", "```cpp\n[+]data\n      input.dat\n      output.dat\n   file_1.txt\n   file_2.txt\n   file_3.log \n```", "```cpp\nstd::uintmax_t dir_size(fs::path const & path)\n{\n   if (fs::exists(path) && fs::is_directory(path))\n   {\n      auto size = static_cast<uintmax_t>(0);\n      for (auto const & entry :\n           fs::recursive_directory_iterator(path))\n      {\n         if (fs::is_regular_file(entry.status()) ||\n            fs::is_symlink(entry.status()))\n         {\n            auto err = std::error_code{};\n            auto filesize = fs::file_size(entry, err);\n            if (!err)\n               size += filesize;\n         }\n      }\n      return size;\n   }\n   return static_cast<uintmax_t>(-1);\n} \n```", "```cpp\nstd::vector<fs::path> find_files(\n    fs::path const & dir,\n    std::function<bool(fs::path const&)> filter)\n{\n  auto result = std::vector<fs::path>{};\n  if (fs::exists(dir))\n  {\n    for (auto const & entry :\n      fs::recursive_directory_iterator(\n        dir,\n        fs::directory_options::follow_directory_symlink))\n    {\n      if (fs::is_regular_file(entry) &&\n          filter(entry))\n      {\n        result.push_back(entry);\n      }\n    }\n  }\n  return result;\n} \n```", "```cpp\nauto results = find_files(\n          fs::current_path() / \"test\",\n          [](fs::path const & p) {\n  auto filename = p.wstring();\n  return filename.find(L\"file_\") != std::wstring::npos;\n});\nfor (auto const & path : results)\n{\n  std::cout << path << '\\n';\n} \n```", "```cpp\ntest\\file_1.txt\ntest\\file_2.txt\ntest\\file_3.log \n```", "```cpp\nauto results = find_files(\n       fs::current_path() / \"test\",\n       [](fs::path const & p) {\n         return p.extension() == L\".dat\";});\nfor (auto const & path : results)\n{\n  std::cout << path << '\\n';\n} \n```", "```cpp\ntest\\data\\input.dat\ntest\\data\\output.dat \n```"]