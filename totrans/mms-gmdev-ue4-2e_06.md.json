["```cpp\nif (mapName == currentMapName)\n{\n        World->ServerTravel(\"?Restart\", true);\n}\nelse\n{\n        UGameplayStatics::OpenLevel(World, *mapName, true);\n}\n```", "```cpp\nUCLASS()\nclass MASTERING_API UMasteringGameInstance : public UGameInstance\n{\n        GENERATED_BODY()\n\npublic:\n        UFUNCTION(BlueprintCallable, Category = \"Mastering Game Instance\")\n        static UMasteringGameInstance* GetInstance();\n\n        virtual void Init() override;\n        virtual void BeginDestroy() override;\n        virtual void FinishDestroy() override;\n\n        bool ShouldPersistInventory() const\n        {\n                return bPersistPlayerInventory;\n        }\n\n        void SetPersistInventory(const bool bPersist = true)\n        {\n                bPersistPlayerInventory = bPersist;\n        }\n\n        void SetPlayerInventory(class UMasteringInventory* Inv);\n\n        FORCEINLINE class UMasteringInventory* GetInventory() const\n        {\n                return PlayerInv;\n        }\n\n        void SetPlayerSafeLocation(const FVector& InLoc)\n        {\n                PlayerSafeLocation = InLoc;\n        }\n\n        FORCEINLINE FVector GetPlayerSafeLocation() const\n        {\n                return PlayerSafeLocation;\n        }\n\n        void ClearData();\n\nprotected:\n\n        UPROPERTY()\n        class UMasteringInventory* PlayerInv;\n\n        bool bPersistPlayerInventory;\n        FVector PlayerSafeLocation;\n};\n\n```", "```cpp\nstatic UMasteringGameInstance* Instance = nullptr;\n\nUMasteringGameInstance* UMasteringGameInstance::GetInstance()\n{\n        checkf(Instance != nullptr, TEXT(\"Someone is trying to use the game instance before it has initialized!\"));\n\n        return Instance;\n}\n\nvoid UMasteringGameInstance::Init()\n{\n        Super::Init();\n\n        Instance = this;\n\n        AddToRoot();\n}\n\nvoid UMasteringGameInstance::BeginDestroy()\n{\n        ClearData();\n        Super::BeginDestroy();\n}\n\nvoid UMasteringGameInstance::FinishDestroy()\n{\n        Super::FinishDestroy();\n}\n\nvoid UMasteringGameInstance::SetPlayerInventory(class UMasteringInventory* Inv)\n{\n        if (PlayerInv == nullptr)\n        {\n                PlayerInv = NewObject<UMasteringInventory>(this, TEXT(\"PlayerInventory\"));\n        }\n\n        PlayerInv->CopyFromOther(Inv);\n}\n\nvoid UMasteringGameInstance::ClearData()\n{\n        bPersistPlayerInventory = false;\n        PlayerInv = nullptr;\n        PlayerSafeLocation = FVector::ZeroVector;\n}\n```", "```cpp\nclass MASTERING_API LoadSaveLibrary\n{\npublic:\n        LoadSaveLibrary();\n        ~LoadSaveLibrary();\n\n        UFUNCTION(BlueprintCallable)\n        static void LoadGameFile(FString SaveFile, UWorld* World);\n\n        UFUNCTION(BlueprintCallable)\n        static void SaveGameFile(FString SaveFile, UWorld* World);\n\n        static void OnGameLoadedFixup(UWorld* World);\n\n        static void FixupPlayer(UWorld* World, class AMasteringCharacter* Char);\n\nprotected:\n        static TArray<uint8> BinaryData;\n};\n```", "```cpp\nTArray<uint8> LoadSaveLibrary::BinaryData;\n\nLoadSaveLibrary::LoadSaveLibrary()\n{\n}\n\nLoadSaveLibrary::~LoadSaveLibrary()\n{\n}\n\nvoid LoadSaveLibrary::LoadGameFile(FString SaveFile, UWorld* World)\n{\n        FString outPath = FPaths::ProjectSavedDir() + SaveFile;\n        if (!FFileHelper::LoadFileToArray(BinaryData, *outPath))\n        {\n                UE_LOG(LogTemp, Warning, TEXT(\"%s\"), *(FString(\"Game Load Failed: \") + outPath));\n                return;\n        }\n\n        checkSlow(World != nullptr);\n        FMemoryReader FromBinary = FMemoryReader(BinaryData, true);\n        FromBinary.Seek(0);\n\n        FGameSavedData SaveGameData;\n        FromBinary << SaveGameData;\n\n        FromBinary.FlushCache();\n        FromBinary.Close();\n\n        UMasteringGameInstance* gameInst = UMasteringGameInstance::GetInstance();\n        FVector playerSafeLoc = SaveGameData.PlayerSafeLocation;\n        gameInst->SetPlayerSafeLocation(playerSafeLoc);\n\n        FString mapName = SaveGameData.MapName.ToString();\n\n        FString currentMapName = World->GetMapName();\n\n        currentMapName.Split(\"UEDPIE_0_\", nullptr, &currentMapName);\n\n        if (mapName == currentMapName)\n        {\n                World->ServerTravel(\"?Restart\", true);\n        }\n        else\n        {\n                UGameplayStatics::OpenLevel(World, *mapName);\n        }\n}\n```", "```cpp\nvoid LoadSaveLibrary::SaveGameFile(FString SaveFile, UWorld* World)\n{\n        checkSlow(World != nullptr);\n        FGameSavedData SaveGameData;\n        FString outPath = FPaths::ProjectSavedDir() + SaveFile;\n\n        SaveGameData.Timestamp = FDateTime::Now();\n\n        FString mapName = World->GetMapName();\n\n        mapName.Split(\"UEDPIE_0_\", nullptr, &mapName);\n\n        SaveGameData.MapName = *mapName;\n\n        UMasteringGameInstance* gameInst = UMasteringGameInstance::GetInstance();\n        SaveGameData.PlayerSafeLocation = gameInst->GetPlayerSafeLocation();\n        gameInst->SetPlayerSafeLocation(FVector::ZeroVector); // so this will not be valid in future saves unless set again\n\n        TArray<AActor*> Actors;\n        UGameplayStatics::GetAllActorsWithInterface(World, USavedActorInterface::StaticClass(), Actors);\n\n        TArray<FActorSavedData> SavedActors;\n        for (auto Actor : Actors)\n        {\n                FActorSavedData ActorRecord;\n                ActorRecord.MyName = FName(*Actor->GetName());\n                ActorRecord.MyClass = Actor->GetClass()->GetPathName();\n                ActorRecord.MyTransform = Actor->GetTransform();\n                ActorRecord.MyVelocity = Actor->GetVelocity();\n\n                FMemoryWriter MemoryWriter(ActorRecord.MyData, true);\n                FSaveGameArchive Ar(MemoryWriter);\n                AMasteringCharacter* Mast = Cast<AMasteringCharacter>(Actor);\n\n                ISavedActorInterface::Execute_ActorSaved(Actor);\n\n                Actor->Serialize(Ar);\n\n                if (Mast != nullptr)\n                {\n                        UMasteringInventory* Inv = Mast->GetInventory();\n                        SaveGameData.InventoryData.CurrentWeapon = Inv->GetCurrentWeapon()->GetPathName();\n                        SaveGameData.InventoryData.CurrentWeaponPower = Inv->GetCurrentWeaponPower();\n                        for (FWeaponProperties weapon : Inv->GetWeaponsArray())\n                        {\n                                FInventoryItemData data;\n                                data.WeaponClass = weapon.WeaponClass->GetPathName();\n                                data.WeaponPower = weapon.WeaponPower;\n                                data.Ammo = weapon.Ammo;\n                                data.TextureClass = weapon.InventoryIcon->GetPathName();\n\n                                SaveGameData.InventoryData.WeaponsArray.Add(data);\n                        }\n                }\n\n                SavedActors.Add(ActorRecord);\n        }\n\n        FBufferArchive SaveData;\n\n        SaveGameData.SavedActors = SavedActors;\n\n        SaveData << SaveGameData;\n\n        FFileHelper::SaveArrayToFile(SaveData, *outPath);\n\n        SaveData.FlushCache();\n        SaveData.Empty();\n}\n```", "```cpp\nvoid LoadSaveLibrary::FixupPlayer(UWorld* World, class AMasteringCharacter* Char)\n{\n        UMasteringGameInstance* gameInst = UMasteringGameInstance::GetInstance();\n\n        // Assuming we found our player character and saved out some inventory, this is where we do its custom serialization and fix-up\n        if (Char != nullptr)\n        {\n                if (!gameInst->GetPlayerSafeLocation().IsZero())\n                {\n                        Char->SetActorLocation(gameInst->GetPlayerSafeLocation());\n                }\n\n                if (gameInst->ShouldPersistInventory())\n                {\n                        UMasteringInventory* NewInv = NewObject<UMasteringInventory>(Char, TEXT(\"PlayerInventory\"), RF_Transient);\n\n                        checkf(gameInst->GetInventory() != nullptr, TEXT(\"Game Instance is trying to persist inventory with no inventory setup!\"));\n                        NewInv->CopyFromOther(gameInst->GetInventory(), Char);\n\n                        Char->SetInventory(NewInv);\n                        NewInv->SetupToCurrent();\n                }\n                else if (BinaryData.Num() > 0)\n                {\n                        FMemoryReader FromBinary = FMemoryReader(BinaryData, true);\n                        FromBinary.Seek(0);\n\n                        FGameSavedData SaveGameData;\n                        FromBinary << SaveGameData;\n\n                        UMasteringInventory* NewInv = NewObject<UMasteringInventory>(Char, TEXT(\"PlayerInventory\"), RF_Transient);\n\n                        Char->SetInventory(NewInv);\n\n                        FWeaponProperties propsEquipped;\n                        for (FInventoryItemData ItemData : SaveGameData.InventoryData.WeaponsArray)\n                        {\n                                FWeaponProperties props;\n                                props.WeaponClass = FindObject<UClass>(ANY_PACKAGE, *ItemData.WeaponClass);\n                                props.InventoryIcon = FindObject<UTexture2D>(ANY_PACKAGE, *ItemData.TextureClass);\n                                props.WeaponPower = ItemData.WeaponPower;\n                                props.Ammo = ItemData.Ammo;\n\n                                if (ItemData.WeaponClass == SaveGameData.InventoryData.CurrentWeapon)\n                                        propsEquipped = props;\n\n                                NewInv->AddWeapon(props);\n                        }\n\n                        Char->GetInventory()->SelectWeapon(propsEquipped);\n                }\n        }\n}\n```", "```cpp\nvoid ALevelTransitionVolume::NotifyActorBeginOverlap(AActor* OtherActor)\n{\n        AMasteringCharacter* Mast = Cast<AMasteringCharacter>(OtherActor);\n        UWorld* World = GetWorld();\n\n        if (Mast != nullptr)\n        {\n                UMasteringGameInstance* gameInst = UMasteringGameInstance::GetInstance();\n                gameInst->SetPersistInventory();\n\n                AMasteringCharacter* Char = Cast<AMasteringCharacter>(World->GetFirstPlayerController()->GetPawn());\n                check(Char != nullptr);\n\n                gameInst->SetPlayerInventory(Char->GetInventory());\n\n                FString currentMapName = World->GetMapName();\n                currentMapName.Split(\"UEDPIE_0_\", nullptr, &currentMapName); // strip out PIE prefix if in PIE\n                FString toMapName = TransitionLevel;\n\n                FString fromFile = currentMapName + TEXT(\"_to_\") + toMapName + TEXT(\".sav\");\n                FString toFile = toMapName + TEXT(\"_to_\") + currentMapName + TEXT(\".sav\");\n\n                gameInst->SetPlayerSafeLocation(GetPlayerSafeLocation());\n\n                // always save on our way out so we can restore the state on the way back\n                LoadSaveLibrary::SaveGameFile(fromFile, World);\n\n                if (FPaths::FileExists(FPaths::ProjectSavedDir() + toFile))\n                {\n                        LoadSaveLibrary::LoadGameFile(toFile, World);\n                }\n                else\n                {\n                        UGameplayStatics::OpenLevel(World, *toMapName);\n                }\n        }\n}\n```", "```cpp\nvoid LoadSaveLibrary::OnGameLoadedFixup(UWorld* World)\n{\n        if (BinaryData.Num() == 0)\n        {\n                checkSlow(World->GetFirstPlayerController() != nullptr);\n                AMasteringCharacter* charPawn = Cast<AMasteringCharacter>(World->GetFirstPlayerController()->GetPawn());\n\n                FixupPlayer(World, charPawn);\n                return;\n        }\n\n        FMemoryReader FromBinary = FMemoryReader(BinaryData, true);\n        FromBinary.Seek(0);\n\n        FGameSavedData SaveGameData;\n        FromBinary << SaveGameData;\n\n        FromBinary.FlushCache();\n        BinaryData.Empty();\n        FromBinary.Close();\n\n        TArray<AActor*> Actors;\n        UGameplayStatics::GetAllActorsWithInterface(World, USavedActorInterface::StaticClass(), Actors);\n\n        TArray<FActorSavedData> ActorDatas = SaveGameData.SavedActors;\n\n        AMasteringCharacter* Char = nullptr; // if ever more than one, we'll need an array and a map to their inventory\n\n        // iterate these arrays backwards as we will remove objects as we go, can also use iterators, but RemoveAt is simpler here for now\n        for (int i = Actors.Num() - 1; i >= 0; --i)\n        {\n                AActor* Actor = Actors[i];\n\n                for (int j = ActorDatas.Num() - 1; j >= 0; --j)\n                {\n                        FActorSavedData ActorRecord = ActorDatas[j];\n\n                        // These are actors spawned into the world that we also found in our save data (TODO: use TArray intersection?)\n                        if (ActorRecord.MyName == *Actor->GetName())\n                        {\n                                FMemoryReader MemoryReader(ActorRecord.MyData, true);\n                                FSaveGameArchive Ar(MemoryReader);\n\n                                AMasteringCharacter* Mast = Cast<AMasteringCharacter>(Actor);\n                                if (Mast != nullptr)\n                                {\n                                        Char = Mast;\n                                }\n\n                                Actor->Serialize(Ar);\n                                Actor->SetActorTransform(ActorRecord.MyTransform);\n                                ISavedActorInterface::Execute_ActorLoaded(Actor);\n\n                                APawn* pawn = Cast<APawn>(Actor);\n                                if (pawn != nullptr)\n                                {\n                                        // controller needs the rotation too as this may set the pawn's rotation once play starts\n                                        AController* controller = pawn->GetController();\n                                        controller->ClientSetRotation(ActorRecord.MyTransform.Rotator());\n                                }\n\n                                ActorDatas.RemoveAt(j);\n                                Actors.RemoveAt(i);\n                                break;\n                        }\n                }\n        }\n\n```", "```cpp\n        FixupPlayer(World, Char);\n\n        // These are actors in our save data, but not in the world, spawn them\n        for (FActorSavedData ActorRecord : ActorDatas)\n        {\n                FVector SpawnPos = ActorRecord.MyTransform.GetLocation();\n                FRotator SpawnRot = ActorRecord.MyTransform.Rotator();\n                FActorSpawnParameters SpawnParams;\n                // if we were in a space when saved, we should be able to spawn there again when loaded, but we could also\n                // be overlapping an object that loaded, but will be subsequently destroyed below as it was there at level start\n                // but not there at save time\n                SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n                SpawnParams.Name = ActorRecord.MyName;\n                UClass* SpawnClass = FindObject<UClass>(ANY_PACKAGE, *ActorRecord.MyClass);\n                if (SpawnClass)\n                {\n                        AActor* NewActor = GWorld->SpawnActor(SpawnClass, &SpawnPos, &SpawnRot, SpawnParams);\n                        FMemoryReader MemoryReader(ActorRecord.MyData, true);\n                        FSaveGameArchive Ar(MemoryReader);\n                        NewActor->Serialize(Ar);\n                        NewActor->SetActorTransform(ActorRecord.MyTransform);\n                        ISavedActorInterface::Execute_ActorLoaded(NewActor);\n                }\n        }\n\n        // These are actors in the world that are not in our save data, destroy them (for example, a weapon pickup that was, well, picked up)\n        for (auto Actor : Actors)\n        {\n                Actor->Destroy();\n        }\n}\n```", "```cpp\nvoid UMasteringInventory::CopyFromOther(UMasteringInventory *Other, class AMasteringCharacter* ownerOverride /* = nullptr */)\n{\n        Reset();\n\n        TArray<FWeaponProperties>& otherProps = Other->GetWeaponsArray();\n        for (auto prop : otherProps)\n        {\n                WeaponsArray.Add(prop);\n        }\n\n        DefaultWeaponPickup = Other->DefaultWeaponPickup;\n        CurrentWeapon = Other->GetCurrentWeapon();\n        CurrentWeaponPower = Other->GetCurrentWeaponPower();\n        MyOwner = ownerOverride == nullptr ? Other->GetOwningCharacter() : ownerOverride;\n}\n\nvoid UMasteringInventory::Reset()\n{\n        WeaponsArray.Empty();\n        CurrentWeapon = nullptr;\n        CurrentWeaponPower = -1;\n        MyOwner = nullptr;\n}\n\nvoid UMasteringInventory::SetupToCurrent()\n{\n        for (auto WeaponIt = WeaponsArray.CreateConstIterator(); WeaponIt; ++WeaponIt)\n        {\n                const FWeaponProperties &currentProps = *WeaponIt;\n                OnWeaponAdded.Broadcast(currentProps);\n                if (currentProps.WeaponClass == CurrentWeapon)\n                {\n                        SelectWeapon(currentProps);\n                }\n        }\n}\n```"]