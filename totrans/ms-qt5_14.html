<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;Qt Hat Tips and Tricks" id="aid-3RV941"><div class="titlepage"><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Qt Hat Tips and Tricks</h1></div></div></div><p>The previous chapter taught you how to package a Qt application on all the major desktop and mobile platforms. This was the final step before shipping your application to your users. This chapter gathers some tips and tricks that will help you to develop your Qt applications with more ease.</p><p>This chapter covers the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Qt Creator tips - Useful keyboard shortcuts, session management, and more</li><li class="listitem">Examining the memory with Qt Creator</li><li class="listitem">Generating random numbers</li><li class="listitem">Silencing unused variables and compiler warnings</li><li class="listitem">How to easily log an object's content to <code class="literal">QDebug</code></li><li class="listitem">Customizing <code class="literal">QDebug</code> formatting</li><li class="listitem">Saving logs to a file</li><li class="listitem">Creating a friendly command-line interface</li><li class="listitem">Sending <code class="literal">HTTP</code><code class="literal">GET</code> and <code class="literal">POST</code> requests</li></ul></div><div class="section" title="Managing your workspace with sessions"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec123"/>Managing your workspace with sessions</h1></div></div></div><p>It is common for a commercial product to be composed of several Qt projects. We regularly encountered this practice in this book-for example, an application composed of a core project and a GUI project. The Qt subdirs project is a nice way of handling inter-dependent projects within the same application.</p><p>However, when your product grows up, you'll want to open some unrelated projects in Qt Creator. In this case, you should use a <span class="strong"><strong>session</strong></span>. A session is a complete snapshot of your workspace in Qt Creator. You can easily create a new session from <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Session Manager</strong></span> | <span class="strong"><strong>New</strong></span>. Do not forget to switch to the new session. For example, you can create a session "Mastering Qt5" and load all project examples in a common workspace.</p><p>The sessions are useful when you need to quickly switch between two different workspaces. The following items in Qt Creator will be automatically saved in the session:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Opened projects of the hierarchical view</li><li class="listitem">Editor's windows (including the splits)</li><li class="listitem">Debug breakpoints and expressions views</li><li class="listitem">Bookmarks</li></ul></div><p>You can change to a different session with <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Session Manager</strong></span> or by using the <span class="strong"><strong>Welcome</strong></span> tab. A session can be destroyed without any impact on your projects.</p></div></div>
<div class="section" title="Searching with the Locator" id="aid-3STPM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec124"/>Searching with the Locator</h1></div></div></div><p>Another way to improve your productivity with Qt Creator is to use keyboard shortcuts. Qt Creator provides a lot of great keyboard shortcuts. Here is our selection:</p><div class="mediaobject"><img src="../Images/image00455.jpeg" alt="Searching with the Locator"/></div><p style="clear:both; height: 1em;"> </p><p>One of our favorites is the Locator. Press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>K</em></span> to activate it. Then you can enjoy several features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Enter a filename (you can even use a partial entry) and press <span class="emphasis"><em>Enter</em></span> to open this file. If the Locator suggests multiple files, you can use the arrows up and down to navigate.</li><li class="listitem">Prefix your search by <code class="literal">. </code> (a dot followed by a space) to search C++ symbols in the current document. For example, on the <code class="literal">Task.cpp</code> file of the first chapter, try to use the Locator with <code class="literal">. set</code> and press <span class="emphasis"><em>Enter</em></span> to go to the  <code class="literal">Task::setName()</code> function.</li><li class="listitem">Enter <code class="literal">l </code> (<span class="emphasis"><em>L</em></span> followed by a space) to go to a specific line. For example, "l 37" will bring us to line 37 of the current file</li></ul></div><p>The Locator provides plenty of features; take a look when you press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>K</em></span> the next time!</p></div>
<div class="section" title="Increasing the compilation speed" id="aid-3TSA81"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec125"/>Increasing the compilation speed</h1></div></div></div><p>You can speed up the compilation on a multicore computer. By default, when you build your project with Qt Creator, you only use one job (and, therefore, one core). But <code class="literal">make</code> supports the compilation with multiple jobs. You can use the <code class="literal">make -j N</code> option to allow N jobs at once. Do not forget to update your packaging scripts!</p><p>If you build your project from Qt Creator, you can set this option from <span class="strong"><strong>Projects</strong></span> | <span class="strong"><strong>Build Steps</strong></span> | <span class="strong"><strong>Make</strong></span>. Click on <span class="strong"><strong>Details</strong></span>, then, in the <span class="strong"><strong>Make arguments</strong></span> field, put the value <code class="literal">-j 8</code> to allow eight jobs during the compilation, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00456.jpeg" alt="Increasing the compilation speed"/></div><p style="clear:both; height: 1em;"> </p></div>
<div class="section" title="Examining the memory with Qt Creator"><div class="titlepage" id="aid-3UQQQ2"><div><div><h1 class="title"><a id="ch14lvl1sec126"/>Examining the memory with Qt Creator</h1></div></div></div><p>For this section, we will use the following code snippet:</p><pre class="programlisting">bool boolean = true; &#13;
int integer = 5; &#13;
char character = 'A'; &#13;
int* integerPointer = &amp;integer; &#13;
 &#13;
qDebug() &lt;&lt; "boolean is:" &lt;&lt; boolean; &#13;
qDebug() &lt;&lt; "integer is:" &lt;&lt; integer; &#13;
qDebug() &lt;&lt; "character is:" &lt;&lt; character; &#13;
qDebug() &lt;&lt; "integerPointer is:" &lt;&lt; integerPointer; &#13;
qDebug() &lt;&lt; "*integerPointer is:" &lt;&lt; *integerPointer; &#13;
qDebug() &lt;&lt; "done!"; &#13;
</pre><p>We declared three primitive types: <code class="literal">boolean</code>, <code class="literal">integer</code>, and <code class="literal">character</code>. We also added a  <code class="literal">integerPointer</code> pointer that refers to the <code class="literal">integer</code> variable. Put a breakpoint at the last line and start the debugging. On the Debug pane, you should have the <span class="strong"><strong>Locals and Expressions</strong></span> view. You can easily add/remove it from <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Views</strong></span> | <span class="strong"><strong>Locals and Expressions</strong></span>. Here is a screenshot of it:</p><div class="mediaobject"><img src="../Images/image00457.jpeg" alt="Examining the memory with Qt Creator"/></div><p style="clear:both; height: 1em;"> </p><p>You can see that all our local variables are displayed with their values. The <code class="literal">character</code> line even displays three formats (ASCII, integer, and hexadecimal) of the letter <span class="strong"><strong>'A'</strong></span>. You may also notice that the <code class="literal">integerPointer</code> line displays the automatically dereferenced value, not the pointer address. You can disable it with a right-click on the background of the <span class="strong"><strong>Locals and Expressions</strong></span> window and then select <span class="strong"><strong>Dereference Pointers automatically</strong></span>. You can see the pointer address and the dereferenced value appearing as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00458.jpeg" alt="Examining the memory with Qt Creator"/></div><p style="clear:both; height: 1em;"> </p><p>The console output displays the following information:</p><pre class="programlisting">boolean is: true &#13;
integer is: 5 &#13;
character is: A &#13;
integerPointer is: 0x7ffe601153ac &#13;
*integerPointer is: 5 &#13;
</pre><p>You can see that we retrieve the same information in the console output. The <span class="strong"><strong>Locals and Expressions</strong></span> view helps you to save time. You can display a lot of information without logging it with a <code class="literal">qDebug()</code> function.</p><p>Qt Creator provides a useful memory editor. You can open it with a right-click on a variable name in the <span class="strong"><strong>Locals and Expressions</strong></span> window, and then select <span class="strong"><strong>Open Memory Editor</strong></span> | <span class="strong"><strong>Open Memory Editor at Object's Address</strong></span>.</p><p>Within the memory editor, look at the value of the <code class="literal">boolean</code> variable:</p><div class="mediaobject"><img src="../Images/image00459.jpeg" alt="Examining the memory with Qt Creator"/></div><p style="clear:both; height: 1em;"> </p><p>A hexadecimal editor appears with three parts (from the left to the right):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The memory address of the data</li><li class="listitem">The hexadecimal representation of the data</li><li class="listitem">The ASCII representation of the data</li></ul></div><p>The selection in the hexadecimal representation corresponds to the variable. We can confirm that the <code class="literal">boolean</code> variable is represented in memory by 1 byte. Because the value is <code class="literal">true</code>, the memory representation is <span class="strong"><strong>0x01</strong></span>.</p><p>Let's examine the <code class="literal">character</code> memory with the <span class="strong"><strong>Memory Editor</strong></span> tool:</p><div class="mediaobject"><img src="../Images/image00460.jpeg" alt="Examining the memory with Qt Creator"/></div><p style="clear:both; height: 1em;"> </p><p>The character is also stored in memory with 1 byte. The hexadecimal representation is <span class="strong"><strong>0x41</strong></span>. The character is encoded with the well-known ASCII format. Note that, on the right-hand side, the ASCII representation displays the <span class="strong"><strong>'A'</strong></span>.</p><p>Here is the <span class="strong"><strong>Memory Editor</strong></span> location of the <code class="literal">integer</code> variable:</p><div class="mediaobject"><img src="../Images/image00461.jpeg" alt="Examining the memory with Qt Creator"/></div><p style="clear:both; height: 1em;"> </p><p>There are two interesting facts to note. The integer is stored on 4 bytes. The value <span class="strong"><strong>05</strong></span> is stored in hexadecimal as <span class="strong"><strong>05 00 00 00</strong></span>. The byte order depends on the endianness of your processor. We are using an Intel CPU that is Little-Endian. Another CPU architecture with a Big-Endian memory storage will display the variable as <span class="strong"><strong>00 00 00 05</strong></span>.</p><p>Before we continue to dive into the memory of our application, look at the last three screenshots closely. You might notice that, in this case, the three variables are contiguous in the stack memory. This behavior is not guaranteed depending on the implementation of your OS.</p><p>Try to open the memory editor on the <code class="literal">integerPointer</code> variable. The context menu offers you two different ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><strong>Open Memory Editor at Object's Address</strong></span> option dereferences the pointer and brings you directly to the pointed value. You get the same result as the integer memory view.</li><li class="listitem">The <span class="strong"><strong>Open Memory Editor at Pointer's Address</strong></span> option displays the raw pointer data, which is a memory address to where it is pointing.</li></ul></div><p>Here is the <span class="strong"><strong>Memory Editor</strong></span> tool showing the pointer's address of <code class="literal">integerPointer</code>:</p><div class="mediaobject"><img src="../Images/image00462.jpeg" alt="Examining the memory with Qt Creator"/></div><p style="clear:both; height: 1em;"> </p><p>We are on a 64-bit OS, so our pointer is stored on 8 bytes. The data of this pointer is the hexadecimal value <code class="literal">ac 53 11 60 fe 7f 00 00</code>. This is the Little-Endian representation of the memory address <code class="literal">0x7ffe601153ac</code> displayed by the <span class="strong"><strong>Locals and Expressions</strong></span> and by our console output.</p><p>We display the memory, but we can also change it. Follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Remove the current breakpoint and add a new one on the first <code class="literal">qDebug()</code> line.</li><li class="listitem">Restart the debugging and look at the <span class="strong"><strong>Locals and Expressions</strong></span>. If you double-click a variable's value, you can edit it. Note that the <span class="strong"><strong>Memory Editor</strong></span> window immediately updates its representation.</li><li class="listitem">In our case, we set <code class="literal">boolean</code> value to false, <code class="literal">character</code> to 68 (that is 'D') and <code class="literal">integer</code> to 9. When you are confident with your changes, continue the debugging.</li></ol><div style="height:10px; width: 1px"/></div><p>Here is the final console output reflecting our modifications:</p><pre class="programlisting">boolean is: false &#13;
integer is: 9 &#13;
character is: D &#13;
integerPointer is: 0x7fff849203dc &#13;
*integerPointer is: 9 &#13;
done! &#13;
</pre><p>The <span class="strong"><strong>Memory Editor</strong></span> is a powerful tool: You can display and change your variable's value, at runtime, without changing your source code and recompiling your application.</p></div>
<div class="section" title="Generating random numbers" id="aid-3VPBC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec127"/>Generating random numbers</h1></div></div></div><p>Generating real random numbers is quite a difficult task for a computer. Commonly, we are using only a <span class="strong"><strong>pseudo-random number generation</strong></span> (<span class="strong"><strong>PRNG</strong></span>). The Qt framework provides the function <code class="literal">qrand()</code>, a thread-safe version of <code class="literal">std::rand()</code>. This function returns an integer between 0 and <code class="literal">RAND_MAX</code> (defined in <code class="literal">stdlib.h</code>). The following code shows two pseudo-random numbers:</p><pre class="programlisting">qDebug() &lt;&lt; "first number is" &lt;&lt; qrand() % 10; &#13;
qDebug() &lt;&lt; "second number is" &lt;&lt; qrand() % 10; &#13;
</pre><p>We are using a modulo operator to get a value between 0 and 9. Try to run your application several times. The numbers are always the same, in our case, 3 then 7. That is because each time we call <code class="literal">qrand()</code>, we retrieve the next number of the pseudo-random sequence, but the sequence is always the same! Fortunately, we can use <code class="literal">qsrand()</code> to initialize the PRNG with a seed. A seed is an unsigned integer that is used to generate a sequence. Try the next snippet:</p><pre class="programlisting">qsrand(3); &#13;
qDebug() &lt;&lt; "first number is" &lt;&lt; qrand() % 10; &#13;
qDebug() &lt;&lt; "second number is" &lt;&lt; qrand() % 10; &#13;
</pre><p>In this example, we are using the seed 3, and we get a different value from <code class="literal">qrand()</code>--on our computer it is 5 and 4. Great, but if you run this application several times, you will always have this sequence. One way of generating a different sequence each time you run your application is to use a different seed on each run. Run the following code snippet:</p><pre class="programlisting">qsrand(QDateTime::currentDateTime().toTime_t()); &#13;
qDebug() &lt;&lt; "first number is" &lt;&lt; qrand() % 10; &#13;
qDebug() &lt;&lt; "second number is" &lt;&lt; qrand() % 10; &#13;
</pre><p>As you can see, we are now initializing the PRNG with the epoch time from <code class="literal">QDateTime</code>. You can try to run your application multiple times to see that we get different numbers each time! However, this solution is not recommended for cryptography. In this case, you should use a stronger random number engine.</p></div>
<div class="section" title="Silencing unused variable warnings" id="aid-40NRU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec128"/>Silencing unused variable warnings</h1></div></div></div><p>If your compiler is configured to output its warnings, you will probably sometimes see this kind of log:</p><pre class="programlisting">warning: unused parameter 'myVariable' [-Wunused-parameter] &#13;
</pre><p>This is a safety warning to tell the developer to keep their code clean and avoid dead variables. It is a good practice to try to minimize this kind of warning. However, sometimes you have no choice: You override an existing function and you do not use all the parameters. You now face a conundrum: On the one hand you can silence the warning for your whole application, and on the other hand, you can let these safety warnings pile up in your compile output. There must be a better option.</p><p>Indeed, you can silence the warning for your function only. There are two ways of doing this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Using the C/C++ syntax</li><li class="listitem">Using a Qt macro</li></ul></div><p>Let's say you override <code class="literal">myFunction(QString name, QString myVariable)</code> and you do not use <code class="literal">myVariable</code>. Using the C/C++ syntax, you just have to implement <code class="literal">myFunction()</code> like so:</p><pre class="programlisting">void myFunction(QString name, QString /*myVariable*/) &#13;
</pre><p>By commenting the variable's name, <code class="literal">myVariable</code>, in the function signature, you ensure that you will not (that is, cannot) use the variable in the function body. The compiler will also interpret it like this and will not output any warning.</p><p>Qt also provides a way of marking unused variables with the <code class="literal">Q_UNUSED</code> macro. Let's see it in action:</p><pre class="programlisting">void myFunction(QString name, QString myVariable) &#13;
{ &#13;
    Q_UNUSED(myVariable) &#13;
    ... &#13;
} &#13;
</pre><p>Simply pass <code class="literal">myVariable</code> to <code class="literal">Q_UNUSED</code> and it will remove the warning from the compiler output. Behind the curtain, <code class="literal">Q_UNUSED</code> does not do anything magical with the variable:</p><pre class="programlisting">#define Q_UNUSED(x) (void)x; &#13;
</pre><p>It is a simple trick to fool the compiler; it sees <code class="literal">myVariable</code> "used", but nothing is done with it.</p></div>
<div class="section" title="Logging custom objects to QDebug" id="aid-41MCG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec129"/>Logging custom objects to QDebug</h1></div></div></div><p>When you are debugging complex objects, it is nice to output their current members' value to <code class="literal">qDebug()</code>. In other languages (such as Java), you may have encountered the <code class="literal">toString()</code> method or equivalent, which is very convenient.</p><p>Sure, you could add a function void <code class="literal">toString()</code> to each object you want to log in order to write code with the following syntax:</p><pre class="programlisting">qDebug() &lt;&lt; "Object content:" &lt;&lt; myObject.toString() &#13;
</pre><p>There must be a more natural way of doing this in C++. Moreover, Qt already provides this kind of feature:</p><pre class="programlisting">QDate today = QDate::currentDate(); &#13;
qDebug() &lt;&lt; today; &#13;
// Output: QDate("2016-10-03") &#13;
</pre><p>To achieve this, we will rely on a C++ operator overload. This will look very similar to what we did with <code class="literal">QDataStream</code> operators in <span><a class="link" title="Chapter 10.  Need IPC? Get Your Minions to Work" href="part0097.xhtml#aid-2SG6I2">Chapter 10</a></span>, <span class="emphasis"><em>Need IPC? Get Your Minions to Work</em></span>.</p><p>Consider a <code class="literal">struct Person</code>:</p><pre class="programlisting">struct Person { &#13;
    QString name; &#13;
    int age; &#13;
}; &#13;
</pre><p>To add the ability to properly output to <code class="literal">QDebug</code>, you just have to override the <code class="literal">&lt;&lt;</code> operator between <code class="literal">QDebug</code> and <code class="literal">Person</code> like so:</p><pre class="programlisting">#include &lt;QDebug&gt; &#13;
 &#13;
struct Person { &#13;
    ... &#13;
}; &#13;
 &#13;
QDebug operator&lt;&lt;(QDebug debug, const Person&amp; person) &#13;
{ &#13;
    QDebugStateSaver saver(debug); &#13;
    debug.nospace() &lt;&lt; "(" &#13;
                    &lt;&lt; "name: " &lt;&lt; person.name &lt;&lt; ", " &#13;
                    &lt;&lt; "age: " &lt;&lt; person.age &#13;
                    &lt;&lt; ")"; &#13;
    return debug; &#13;
} &#13;
</pre><p>The <code class="literal">QDebugStateSaver</code> is a convenience class to save the settings of <code class="literal">QDebug</code> and restore them automatically upon destruction. It is good practice to always use it to be sure that you do not break <code class="literal">QDebug</code> in an <code class="literal">&lt;&lt;</code> operator overload.</p><p>The rest of the function is the usual way of using <code class="literal">QDebug</code> and finally returning the modified <code class="literal">debug</code> variable. You can now use <code class="literal">Person</code> like this:</p><pre class="programlisting">Person person = { "Lenna", 64 }; &#13;
qDebug() &lt;&lt; "Person info" &lt;&lt; person; &#13;
</pre><p>No need for a <code class="literal">toString()</code> function; simply use the person object. For those of you who wondered, yes, <code class="literal">Lenna</code> is really <code class="literal">64</code> at the time of wrting (2016).</p></div>
<div class="section" title="Improving log messages" id="aid-42KT21"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec130"/>Improving log messages</h1></div></div></div><p>Qt offers multiple ways of doing this. A good compromise between the result and its complexity is to combine the Qt log type with a custom message pattern.</p><p>Qt defines five log types, from the least to the most critical level:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">qDebug()</code>: This is used to write custom debug messages</li><li class="listitem"><code class="literal">qInfo()</code>: This is used to write informational messages</li><li class="listitem"><code class="literal">qWarning()</code>: This is used to write warnings and recoverable errors in your applications</li><li class="listitem"><code class="literal">qCrtitical()</code>: This is used to write critical error messages and report system errors</li><li class="listitem"><code class="literal">qFatal()</code>: This is used to write a last message before automatically existing</li></ul></div><p>Try to always use the most appropriate one!</p><p>By default, the message pattern is configured to only display your message without any extra data, but you can customize the pattern to display more information. This pattern can be changed at runtime by setting the <code class="literal">QT_MESSAGE_PATTERN</code> environment variable. You can also call the <code class="literal">qSetMessagePattern</code> function from your software to change the pattern. The pattern is just a string with some placeholders.</p><p>These are the most common placeholders you can use:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">%{appname}</code>: This is your application name</li><li class="listitem"><code class="literal">%{file}</code>: This is the path to the source file</li><li class="listitem"><code class="literal">%{function}</code>: This is the function name</li><li class="listitem"><code class="literal">%{line}</code>: This is a line in the source file</li><li class="listitem"><code class="literal">%{message}</code>: This is an original message</li><li class="listitem"><code class="literal">%{type}</code>: This is the Qt log type ("debug", "info", "warning", "critical" or "fatal")</li><li class="listitem"><code class="literal">%{time [format]}</code>: This is the system time when the message occurred</li></ul></div><p>An easy way to use it is to edit your <code class="literal">main.cpp</code> file like this:</p><pre class="programlisting">#include &lt;QApplication&gt; &#13;
#include &lt;QDebug&gt; &#13;
... &#13;
int main(int argc, char *argv[]) &#13;
{ &#13;
    qSetMessagePattern("[%{time yyyy-MM-dd hh:mm:ss}] [%{type}] &#13;
        %{function} %{message}"); &#13;
    qInfo() &lt;&lt; "Application starting..."; &#13;
 &#13;
    QApplication a(argc, argv); &#13;
    ... &#13;
    return a.exec(); &#13;
} &#13;
</pre><p>You should get something like this in your application output:</p><pre class="programlisting">[2016-10-03 10:22:40] [info] qMain Application starting... &#13;
</pre><p>Try to play around with the Qt log types and the custom message pattern until you find a useful pattern for you.</p><div class="note" title="Note"><h3 class="title"><a id="tip60"/>Tip</h3><p>For more complex applications, you can use the <code class="literal">QLoggingCategory</code> class to define categories of logging. Visit <span><a class="ulink" href="http://doc.qt.io/qt-5/qloggingcategory.html">http://doc.qt.io/qt-5/qloggingcategory.html</a></span> for more information on this.</p></div></div>
<div class="section" title="Saving your logs to a file" id="aid-43JDK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec131"/>Saving your logs to a file</h1></div></div></div><p>A common need for a developer is to have logs. In some situations, you cannot have access to the console output, or you have to study the application state afterwards. In both cases, the log has to be outputted to a file.</p><p>Qt provides a practical way of redirecting your logs (<code class="literal">qDebug</code>, <code class="literal">qInfo</code>, <code class="literal">qWarning</code>, and so on) to any device that is convenient for you: <code class="literal">QtMessageHandler</code>. To use it, you have to register a function that will save the logs to the desired output.</p><p>For example, in your <code class="literal">main.cpp</code>, add the following function:</p><pre class="programlisting">#include &lt;QFile&gt; &#13;
#include &lt;QTextStream&gt; &#13;
 &#13;
void messageHander(QtMsgType type,  &#13;
                   const QMessageLogContext&amp; context,  &#13;
                   const QString&amp; message) { &#13;
    QString levelText; &#13;
    switch (type) { &#13;
        case QtDebugMsg: &#13;
            levelText = "Debug"; &#13;
            break; &#13;
        case QtInfoMsg: &#13;
            levelText = "Info"; &#13;
            break; &#13;
        case QtWarningMsg: &#13;
            levelText = "Warning"; &#13;
            break; &#13;
        case QtCriticalMsg: &#13;
            levelText = "Critical"; &#13;
            break; &#13;
        case QtFatalMsg: &#13;
            levelText = "Fatal"; &#13;
            break; &#13;
    } &#13;
    QString text = QString("[%1] %2") &#13;
                        .arg(levelText) &#13;
                        .arg(message); &#13;
    QFile file("app.log"); &#13;
    file.open(QIODevice::WriteOnly | QIODevice::Append); &#13;
    QTextStream textStream(&amp;file); &#13;
    textStream &lt;&lt; text &lt;&lt; endl; &#13;
} &#13;
</pre><p>The signature of the function must be respected to be properly called by Qt. Let's review the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">QtMsgType type</code>: This is an <code class="literal">enum</code> that describes the function that generated the message (<code class="literal">qDebug()</code>, <code class="literal">qInfo()</code>, <code class="literal">qWarning()</code>, and so on)</li><li class="listitem"><code class="literal">QMessageLogContext&amp; context</code>: This contains additional information about the log message (source file where the log was produced, name of the function, line number, and so on)</li><li class="listitem"><code class="literal">const QString&amp; message</code>: This is the actual message that was logged</li></ul></div><p>The body of the function formats the log message before appending it to a file named <code class="literal">app.log</code>. You can easily add features in this function by adding a rotating log file, sending the logs through the network, or anything else.</p><p>The last missing part is the registration of <code class="literal">messageHandler()</code>, which is done in the <code class="literal">main()</code> function:</p><pre class="programlisting">int main(int argc, char *argv[]) &#13;
{ &#13;
    QCoreApplication a(argc, argv); &#13;
    qInstallMessageHandler(messageHander); &#13;
    ... &#13;
} &#13;
</pre><p>The call to the <code class="literal">qInstallMessageHander()</code> function is enough to reroute all the log messages to <code class="literal">app.log</code>. Once this is done, the logs will no longer be displayed in the console output and will be appended to <code class="literal">app.log</code> only.</p><div class="note" title="Note"><h3 class="title"><a id="tip61"/>Tip</h3><p>If you need to unregister your custom message handler function, call <code class="literal">qInstallMessageHandler(0)</code>.</p></div></div>
<div class="section" title="Generating a command-line interface" id="aid-44HU61"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec132"/>Generating a command-line interface</h1></div></div></div><p>The command-line interface can be a wonderful way to start your application with some specific options. The Qt framework provides an easy way to define your options with the <code class="literal">QCommandLineParser</code> class. You can provide a short (for example, <code class="literal">-t</code>) or a long (for example, <code class="literal">--test</code>) option name. The application version and help menu is automatically generated. You can easily retrieve in your code if an option is set or not. An option can take a value and you can define a default value.</p><p>For example, we can create a CLI to configure the log files. We want to define three options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">-debug</code> command, if set, enables the log file writing</li><li class="listitem">The <code class="literal">-f</code> or <code class="literal">--file</code> command to define where to write the logs</li><li class="listitem">The <code class="literal">-l</code> or <code class="literal">--level &lt;level&gt;</code> command to specify the minimum log level</li></ul></div><p>Look at the following snippet:</p><pre class="programlisting">QCoreApplication app(argc, argv); &#13;
 &#13;
QCoreApplication::setApplicationName("ch14-hat-tips"); &#13;
QCoreApplication::setApplicationVersion("1.0.0"); &#13;
 &#13;
QCommandLineParser parser; &#13;
parser.setApplicationDescription("CLI helper"); &#13;
parser.addHelpOption(); &#13;
parser.addVersionOption(); &#13;
 &#13;
parser.addOptions({ &#13;
    {"debug", &#13;
        "Enable the debug mode."}, &#13;
 &#13;
    {{"f", "file"}, &#13;
        "Write the logs into &lt;file&gt;.", &#13;
        "logfile"}, &#13;
 &#13;
    {{"l", "level"}, &#13;
        "Restrict the logs to level &lt;level&gt;. Default is 'fatal'.", &#13;
        "level", &#13;
        "fatal"}, &#13;
}); &#13;
 &#13;
parser.process(app); &#13;
 &#13;
qDebug() &lt;&lt; "debug mode:" &lt;&lt; parser.isSet("debug"); &#13;
qDebug() &lt;&lt; "file:" &lt;&lt; parser.value("file"); &#13;
qDebug() &lt;&lt; "level:" &lt;&lt; parser.value("level"); &#13;
</pre><p>Let's talk about each step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first part uses the functions from <code class="literal">QCoreApplication</code> to set the application name and version. This information will be used by the <code class="literal">--version</code> option.</li><li class="listitem">Instantiate a <code class="literal">QCommandLineParser</code> class. Then we instruct it to automatically add the help (<code class="literal">-h</code> or <code class="literal">--help</code>) and version (<code class="literal">-v</code> or <code class="literal">--version</code>) options.</li><li class="listitem">Add our options with the <code class="literal">QCommandLineParser::addOptions()</code> function.</li><li class="listitem">Request the <code class="literal">QCommandLineParser</code> class to process the command-line arguments.</li><li class="listitem">Retrieve and use the options.</li></ol><div style="height:10px; width: 1px"/></div><p>Here are the parameters to create an option:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">optionName</code>: By using this parameter, you can use a single or multiple names</li><li class="listitem"><code class="literal">description</code>: In this parameter, the description of the option is displayed in the help menu</li><li class="listitem"><code class="literal">valueName</code> (Optional): This shows the value name if your option expects one</li><li class="listitem"><code class="literal">defaultValue</code> (Optional): This shows the default value of the option</li></ul></div><p>You can retrieve and use the option using <code class="literal">QCommandLineParser::isSet()</code>, which returns true if the option was set by the user. If your option requires a value, you can retrieve it with <code class="literal">QCommandLineParser::value()</code>.</p><p>Here is the display of the generated help menu:</p><pre class="programlisting">$ ./ch14-hat-tips --help &#13;
Usage: ./ch14-hat-tips [options] &#13;
Helper of the command-line interface &#13;
 &#13;
Options: &#13;
  -h, --help            Displays this help. &#13;
  -v, --version         Displays version information. &#13;
  --debug               Enable the debug mode. &#13;
  -f, --file &lt;logfile&gt;  Write the logs into &lt;file&gt;. &#13;
  -l, --level &lt;level&gt;   Restrict the logs to level &lt;level&gt;. Default is 'fatal'. &#13;
</pre><p>Finally, the following snippet displays the CLI in use:</p><pre class="programlisting">$ ./ch14-hat-tips --debug -f log.txt --level info &#13;
debug mode:  true &#13;
file:  "log.txt" &#13;
level:  "info" &#13;
</pre></div>
<div class="section" title="Sending and receiving HTTP data"><div class="titlepage" id="aid-45GEO2"><div><div><h1 class="title"><a id="ch14lvl1sec133"/>Sending and receiving HTTP data</h1></div></div></div><p>Requesting information to an HTTP server is a common task. Here again, the Qt folks prepared some useful classes to make it easy. To achieve this, we will rely on three classes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">QNetworkAccessManager</code>: This class allows your application to send requests and receive replies</li><li class="listitem"><code class="literal">QNetworkRequest</code>: This class holds the request to be sent with all the information (headers, URL, data, and so on)</li><li class="listitem"><code class="literal">QNetworkReply</code>: This class contains the result of a <code class="literal">QNetworkRequest</code> class with the headers and the data</li></ul></div><p>The <code class="literal">QNetworkAccessManager</code> class is the pivot point of the whole Qt HTTP API. It is built around a single <code class="literal">QNetworkAccessManager</code> object that holds the configuration of the client, proxy settings, cache information, and much more. This class is designed to be asynchronous, so you do not need to worry about blocking your current thread.</p><p>Let's see it in action in a custom <code class="literal">HttpRequest</code> class. First, the header:</p><pre class="programlisting">#include &lt;QObject&gt; &#13;
#include &lt;QNetworkAccessManager&gt; &#13;
#include &lt;QNetworkReply&gt; &#13;
 &#13;
class HttpRequest : public QObject &#13;
{ &#13;
    Q_OBJECT &#13;
public: &#13;
    HttpRequest(QObject* parent = 0); &#13;
 &#13;
    void executeGet(); &#13;
 &#13;
private slots: &#13;
    void replyFinished(QNetworkReply* reply); &#13;
 &#13;
private: &#13;
    QNetworkAccessManager mAccessManager; &#13;
}; &#13;
</pre><p>The <code class="literal">QNetworkAccessManager</code> class works with the signal/slot mechanism, so <code class="literal">HttpRequest</code> inherits from <code class="literal">QObject</code> and uses the <code class="literal">Q_OBJECT</code> macro. We declare the following functions and member:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">executeGet()</code>: This is used to trigger an <code class="literal">HTTP GET</code> request</li><li class="listitem"><code class="literal">replyFinished()</code>: This is the slot called when the <code class="literal">GET</code> request has completed</li><li class="listitem"><code class="literal">mAccessManager</code>: This is the object that will be used for all our asynchronous requests</li></ul></div><p>Let's turn our attention to the constructor of the <code class="literal">HttpRequest</code> class in the <code class="literal">HttpRequest.cpp</code>:</p><pre class="programlisting">HttpRequest::HttpRequest(QObject* parent) : &#13;
    QObject(parent), &#13;
    mAccessManager() &#13;
{ &#13;
    connect(&amp;mAccessManager, &amp;QNetworkAccessManager::finished, &#13;
            this, &amp;HttpRequest::replyFinished); &#13;
} &#13;
</pre><p>In the body of the constructor, we connect the <code class="literal">finished()</code> signal from <code class="literal">mAccessManager</code> to our <code class="literal">replyFinished()</code> slot. This implies that every request sent through <code class="literal">mAccessManager</code> will trigger this slot.</p><p>Enough with the preparation; let's see the request and reply in action:</p><pre class="programlisting">// Request &#13;
void HttpRequest::executeGet() &#13;
{ &#13;
    QNetworkRequest request(QUrl("http://httpbin.org/ip")); &#13;
    mAccessManager.get(QNetworkRequest(request)); &#13;
} &#13;
 &#13;
// Response &#13;
void HttpRequest::replyFinished(QNetworkReply* reply) &#13;
{ &#13;
    int statusCode = reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(); &#13;
    qDebug() &lt;&lt; "Reponse network error" &lt;&lt; reply-&gt;error(); &#13;
    qDebug() &lt;&lt; "Reponse HTTP status code" &lt;&lt; statusCode; &#13;
    qDebug() &lt;&lt; "Reply content:" &lt;&lt; reply-&gt;readAll(); &#13;
    reply-&gt;deleteLater(); &#13;
} &#13;
</pre><p>The <code class="literal">HTTP GET</code> request is processed using <code class="literal">mAccessManager.get()</code>. The <code class="literal">QNetworkAccessManager</code> class provides the function for other HTTP verbs (<code class="literal">head()</code>, <code class="literal">post()</code>, <code class="literal">put()</code>, <code class="literal">delete()</code>, and so on. It expects a <code class="literal">QNetworkRequest</code> access, which takes a URL in its constructor. This is the simplest form of an HTTP request.</p><p>Note that we did our request using the URL <a class="ulink" href="http://httpbin.org/ip"><span>http://httpbin.org/ip</span></a>, which will respond to the emitter's IP address in the JSON format:</p><pre class="programlisting">{ &#13;
  "origin": "1.2.3.4" &#13;
} &#13;
</pre><p>This website is a practical developer resource, where you can send your test requests and have useful information sent back to you. It avoids having to launch a custom web server to only test a few requests. This website is an open-source project freely hosted by Runscope. Of course, you can replace the request URL with anything you wish.</p><div class="note" title="Note"><h3 class="title"><a id="note62"/>Note</h3><p>Take a look at <span><a class="ulink" href="http://httpbin.org/">http://httpbin.org/</a></span> to see all the supported request types.</p></div><p>After the <code class="literal">executeGet()</code> function is completed, the <code class="literal">mAccessManager</code> object executes the request in a separate thread and calls our slot, <code class="literal">replyFinished()</code>, with the resulting <code class="literal">QNetworkReply*</code> object. In this code snippet, you can see how to retrieve the HTTP status code and check if any network error happened, as well as how to get the body of the response with <code class="literal">reply-&gt;readAll()</code>.</p><p>The <code class="literal">QNetworkReply</code> class inherits from <code class="literal">QIODevice</code>, and therefore, you can read it all at once with <code class="literal">readAll()</code>, or by chunks with a loop on <code class="literal">read()</code>. This lets you adapt the reading to your needs using a familiar <code class="literal">QIODevice</code> API.</p><p>Note that you are the owner of the <code class="literal">QNetworkReply*</code> object. You should not delete it by hand (your application might crash if you do so); instead, it's better to use the <code class="literal">reply-&gt;deleteLater()</code> function, which will let the Qt event loop pick the appropriate moment to delete this object.</p><p>Now let's see a more complex example of <code class="literal">QNetworkReply</code> with an <code class="literal">HTTP POST</code> method. There are times where you will need to keep track of the <code class="literal">QNetworkReply</code> class and have a more fine-grained control over its life cycle.</p><p>Here is the implementation of an <code class="literal">HTTP POST</code> method that also relies on <code class="literal">HttpRequest::mAccessManager</code>:</p><pre class="programlisting">void HttpRequest::executePost() &#13;
{ &#13;
    QNetworkRequest request(QUrl("http://httpbin.org/post")); &#13;
    request.setHeader(QNetworkRequest::ContentTypeHeader, &#13;
                      "application/x-www-form-urlencoded"); &#13;
    QUrlQuery urlQuery; &#13;
    urlQuery.addQueryItem("book", "Mastering Qt 5"); &#13;
 &#13;
    QUrl params; &#13;
    params.setQuery(urlQuery); &#13;
 &#13;
    QNetworkReply* reply = mAccessManager.post( &#13;
                           request, params.toEncoded()); &#13;
    connect(reply, &amp;QNetworkReply::readyRead,  &#13;
        [reply] () { &#13;
        qDebug() &lt;&lt; "Ready to read from reply"; &#13;
    }); &#13;
    connect(reply, &amp;QNetworkReply::sslErrors,  &#13;
            [this] (QList&lt;QSslError&gt; errors) { &#13;
        qWarning() &lt;&lt; "SSL errors" &lt;&lt; errors; &#13;
    }); &#13;
} &#13;
</pre><p>We start by creating a <code class="literal">QNetworkRequest</code> class with a custom header: <code class="literal">Content-Type</code> is now <code class="literal">application/x-www-form-urlencoded</code> to respect the HTTP RFC. After that, a URL form is built, ready to be sent with the request. You can add as many items as you wish to the <code class="literal">urlQuery</code> object.</p><p>The next part gets interesting. When executing <code class="literal">mAccessManager.post()</code> with the request and the URL encoded form, the <code class="literal">QNetworkReply*</code> object is immediately returned to us. From here, we use some lambdas slots connected directly to reply rather than using <code class="literal">mAccessManage</code> slots. This lets you have precise control over what happens for each reply.</p><p>Note that the <code class="literal">QNetworkReploy::readyRead</code> signal comes from the <code class="literal">QIODevice</code> API and that it does not pass the <code class="literal">QNetworkReply*</code> object in the parameter. It is your job to store the reply in a member field somewhere or retrieve the emitter of the signal.</p><p>Finally, this code snippet does not undo our preceding slot, <code class="literal">replyFinished()</code>, which is connected to <code class="literal">mAccessManager</code>. If you execute this code, you will have the following output sequence:</p><pre class="programlisting">Ready to read from reply &#13;
Reponse network error QNetworkReply::NetworkError(NoError) &#13;
Reponse HTTP status code 200 &#13;
</pre><p>The lambda connected to the <code class="literal">QNetworkReply::readyRead</code> signal is first called, and after that, the <code class="literal">HttpRequest::replyFinished</code> signal is called.</p><p>The last feature we will cover on the Qt HTTP stack is synchronous requests. If you happen to need to manage the request threading yourself, the default asynchronous work mode of <code class="literal">QNetworkAccessManager</code> can get in your way. To circumvent this, you can use a custom <code class="literal">QEventLoop</code>:</p><pre class="programlisting">void HttpRequest::executeBlockingGet() &#13;
{ &#13;
    QNetworkAccessManager localManager; &#13;
    QEventLoop eventLoop; &#13;
    QObject::connect( &#13;
        &amp;localManager, &amp;QNetworkAccessManager::finished,  &#13;
        &amp;eventLoop, &amp;QEventLoop::quit); &#13;
 &#13;
    QNetworkRequest request( &#13;
                QUrl("http://httpbin.org/user-agent")); &#13;
    request.setHeader(QNetworkRequest::UserAgentHeader,  &#13;
                      "MasteringQt5Browser 1.0"); &#13;
 &#13;
    QNetworkReply* reply = localManager.get(request); &#13;
    eventLoop.exec(); &#13;
 &#13;
    qDebug() &lt;&lt; "Blocking GET result:" &lt;&lt; reply-&gt;readAll(); &#13;
    reply-&gt;deleteLater(); &#13;
} &#13;
</pre><p>In this function, we declare another <code class="literal">QNetworkAccessManager</code> that will not interfere with the one declared in <code class="literal">HttpRequest</code>. Right after, a <code class="literal">QEventLoop</code> object is declared and connected to <code class="literal">localManager</code>. When <code class="literal">QNetworkAccessManager</code> emits the <code class="literal">finished()</code> signal, <code class="literal">eventLoop</code> will quit and the calling function will resume.</p><p>The <code class="literal">request</code> is built as usual, the <code class="literal">reply</code> object is retrieved, and the function becomes blocked with the call to <code class="literal">eventLoop.exec()</code>. The function is blocked until <code class="literal">localManager</code> has emitted its finished signal. In other words, the request is still done asynchronously; the sole difference is that the function is blocked until the request is completed.</p><p>Finally, the <code class="literal">reply</code> object can be safely read and deleted at the end of the function. This <code class="literal">QEventLoop</code> trick can be used any time a synchronous wait for a Qt signal is needed; use it wisely to avoid blocking the UI thread!</p></div>
<div class="section" title="Summary" id="aid-46EVA1"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec134"/>Summary</h1></div></div></div><p>In this chapter, you learned some tips that complete your Qt knowledge. You should now have the ability to use Qt Creator with ease and efficiency. The <code class="literal">QDebug</code> format should not hold any secrets now, and you can now save your logs to a file without even blinking. You can create a good-looking CLI interface, debug the memory of any program without shaking, and execute an HTTP request with confidence.</p><p>We sincerely hope that you had as much fun reading this book as we did writing it. In our opinion, Qt is a great framework, and it covers many areas that deserve to be deepened with a book (or several books!). We hope you keep coding C++ Qt code with fun and pleasure by building efficient and beautifully crafted applications.</p></div></body></html>