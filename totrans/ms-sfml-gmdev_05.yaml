- en: Chapter 5. Filling the Tool Belt - a few More Gadgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 填充工具带 - 更多的小工具
- en: The last chapter established a firm ground for us to build on. It is time to
    take full advantage of it and finish what we started, by building a robust set
    of tools, ready to take on a wide variety of design problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章为我们打下了坚实的基础。现在是时候充分利用它，完成我们开始的工作，通过构建一套强大的工具集，准备好应对各种设计问题。
- en: 'In this chapter, we are going to be covering these topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Implementation of selection options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择选项的实现
- en: Design and programming of a tile selection window
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瓦片选择窗口的设计和编程
- en: Management of entities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体管理
- en: There is quite a lot of code to cover, so let us just jump into it!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多代码需要覆盖，所以让我们直接进入正题吧！
- en: Planning the selection options
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划选择选项
- en: Versatile selection options are important when creating a responsive and useful
    application. Without them, any sort of software can feel unintuitive, clunky,
    or unresponsive at best. In this particular case, we are going to be dealing with
    selecting, copying, and placing tiles, entities, and particle emitters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个响应和有用的应用程序时，灵活的选择选项非常重要。没有它们，任何软件最多只能感觉不直观、笨拙或无响应。在这种情况下，我们将处理选择、复制和放置瓦片、实体和粒子发射器。
- en: 'Let us see what such an interface might look like:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这样一个界面可能是什么样子：
- en: '![Planning the selection options](img/image_05_001.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![规划选择选项](img/image_05_001.jpg)'
- en: 'In order to get there, we need to create a flexible class, designed to be able
    to handle any possible combination of options and controls. Let us start by going
    over the most basic data types that are going to come in handy when developing
    this system:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目标，我们需要创建一个灵活的类，设计成能够处理任何可能的选项和控制组合。让我们从回顾在开发这个系统时将非常有用的最基本的数据类型开始：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, the selection mode needs to be enumerated. As shown in the preceding
    snippet, there are three modes we are going to be working with at the moment,
    although this list can easily be expanded in the future. The `NameList` data type
    is going to be used to store the contents of entity and particle directories.
    This is simply the return format for the utility function we are going to be relying
    on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要枚举选择模式。如前所述的片段所示，我们现在将处理三种模式，尽管这个列表可以很容易地在未来扩展。`NameList`数据类型将被用来存储实体和粒子目录的内容。这是我们将依赖的实用函数的返回格式。
- en: 'With the data types out of the way, let us take a stab at creating the blueprint
    of our `SelectionOptions` class:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型的问题已经解决，现在让我们尝试创建`SelectionOptions`类的蓝图：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In order to keep things simple, let us focus on talking about the methods we
    need first, before covering data members. As far as public methods go, we have
    pretty much the assortment anyone would expect. Alongside the `Show()` and `Hide()`
    methods, which are going to be used to manipulate the interface this class encapsulates,
    we pretty much only have a few setters and getters, used to manipulate the `ControlMode`
    and `SelectMode`, select specific entities or particle emitters, and obtain tile
    selection ranges, as well as the range of layer visibility/selection. Additionally,
    this class also needs to provide plenty of callback methods for numerous controls
    of the interface we are working with.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，让我们先讨论我们需要的方法，然后再讨论数据成员。就公共方法而言，我们几乎拥有任何人都会期望的集合。除了`Show()`和`Hide()`方法，这些方法将被用来操作这个类封装的界面之外，我们几乎只有几个设置器和获取器，用于操作`ControlMode`和`SelectMode`，选择特定的实体或粒子发射器，以及获取瓦片选择范围，以及层可见性/选择的范围。此外，这个类还需要为我们在工作的界面中的许多控件提供大量的回调方法。
- en: The private methods mainly consist of code used to update the interface and
    the visual representation of its selection onscreen, as well as methods for updating
    each possible mode the selection interface can be in. It's topped off by a private
    method `DeleteSelection()`, which is going to be useful when removing tiles, entities,
    or particle emitters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法主要是由用于更新界面及其在屏幕上选择视觉表示的代码组成，以及用于更新选择界面可能处于的每个可能模式的代码。它还包括一个私有方法`DeleteSelection()`，当删除瓦片、实体或粒子发射器时将非常有用。
- en: 'Finally, let us take a gander at all of the data members that are going to
    be used to preserve the state of this class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下将要用来保存这个类状态的各个数据成员：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We start by storing the current selection mode, alongside the `RectangleShape`
    object, used to visually represent the selection being made. In order to make
    our tools feel more responsive and lively, we are going to be providing a number
    of different colors, used to represent different states of selection. For example,
    the `m_selectStartColor` and `m_selectEndColor` data members are used to differentiate
    the tile selection that's still being made, and its final state, when the mouse
    button is released. In addition to colors, we also have two vector types that
    store the tile selection range for both axes, and a *boolean* flag, used to determine
    when the rectangle shape should be updated.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先存储当前的选取模式，以及用于视觉表示正在进行的选取的`RectangleShape`对象。为了使我们的工具感觉更加响应和生动，我们将提供多种不同的颜色，用于表示不同的选取状态。例如，`m_selectStartColor`和`m_selectEndColor`数据成员用于区分仍在进行的瓦片选取以及鼠标按钮释放时的最终状态。除了颜色之外，我们还有两种向量类型，用于存储两个轴的瓦片选取范围，以及一个*布尔*标志，用于确定何时更新矩形形状。
- en: For the other two states, we need to store the entity identifier and its position
    component, given we are in an entity selection mode, and a pointer to the particle
    emitter, provided we are currently working with particles. This is also where
    the contents of particle and entity directories are going to be stored, in order
    to populate the drop-down list with the appropriate values.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他两种状态，我们需要存储实体标识符及其位置组件，因为我们处于实体选取模式，以及指向粒子发射器的指针，因为我们目前正在处理粒子。这也是粒子目录和实体目录的内容将被存储的地方，以便用适当的值填充下拉列表。
- en: Additionally, we need to keep track of the layer selection range, as well as
    pointers to the `selectionOptions` interface, the `MapControl` class that was
    covered in the previous chapter, and a map tile selector class, which will be
    covered shortly. Keep in mind that only the `m_selectionOptions` interface is
    technically owned by this class. The other two classes encapsulate their own interfaces,
    thus managing their destruction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要跟踪层选取范围，以及指向`selectionOptions`接口、上一章中提到的`MapControl`类和一个即将介绍的地图瓦片选择类的指针。请注意，只有`m_selectionOptions`接口在技术上属于这个类。其他两个类封装了自己的接口，因此管理它们的销毁。
- en: Lastly, we need to have access to the `eventManager`, `guimanager`, the game
    `map` instance, the tile `brush`, entityManager, and the `particleSystem`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要能够访问`eventManager`、`guimanager`、游戏`map`实例、瓦片`brush`、`entityManager`和`particleSystem`。
- en: Implementing selection options
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现选择选项
- en: 'With all of this data to properly initialize, we have quite a lot of work to
    do in the constructor:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些数据都得到适当初始化的情况下，我们在构造函数中有很多工作要做：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After all of the arguments are properly stored away, the default values of
    all data members are set up. This ensures that the initial state of the selection
    is defined. The body of the constructor is used to appropriately deal with other
    tasks:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有参数都妥善存储之后，所有数据成员的默认值被设置。这确保了选择初始状态的定义。构造函数的主体用于适当地处理其他任务：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, all of the proper callbacks are set up, the interface the class owns is
    loaded, positioned and hidden, and the color values are initialized. Finally,
    the contents of the entity and particle emitter directories are obtained and stored.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有适当的回调都已设置，类拥有的接口被加载、定位并隐藏，颜色值也被初始化。最后，实体和粒子发射器目录的内容被获取并存储。
- en: We're not going to be covering the destructor here, because it simply deals
    with removing all callbacks and the interface that is set up.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会介绍析构函数，因为它只是简单地处理移除所有回调和设置的接口。
- en: 'Speaking of interfaces, the outside code needs to be able to easily show and
    hide the `selectionOptions` window:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 说到接口，外部代码需要能够轻松地显示和隐藏`selectionOptions`窗口：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The desired effect is achieved by either setting the interface as active or
    inactive. In the former case, the `guiManager` is also used in order to position
    the `selectionOptions` interface above everything else, by bringing it to the
    front.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将接口设置为活动或非活动状态，可以达到预期的效果。在前者的情况下，`guiManager`也被用来将`selectionOptions`接口置于所有其他元素之上，将其带到前台。
- en: 'Because this interface/class is a sort of helper, it depends on the control
    mode of our editor. This relationship requires the `selectionOptions` class to
    be notified of `controlMode` changes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个接口/类是一种辅助工具，它依赖于我们编辑器的控制模式。这种关系要求`selectionOptions`类通知`controlMode`的变化：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's only necessary to worry about the `Brush` and `Select` modes, as this interface
    is not even needed for anything else. In case a `Brush` is selected, the interface
    is enabled and focused, while its `TileSelect` element is also enabled. This ensures
    we can select tiles we want to paint with. If the selection tool is picked, we
    want the buttons for solidity toggling and selection copying to be enabled instead.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要担心`Brush`和`Select`模式，因为这个界面甚至不需要用于其他任何事情。如果选择`Brush`，界面被启用并聚焦，同时其`TileSelect`元素也被启用。这确保我们可以选择想要绘制的瓷砖。如果选择选择工具，我们希望启用切换实体固态和选择复制的按钮。
- en: 'The actual selection mode switching needs to be handled too, and can be done
    like so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的选择模式切换也需要处理，可以这样做：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, the `Reset()` method is invoked. It is used to disable all unnecessary
    interface elements and zero out the selection data members to their default values.
    After the actual selection mode is stored and the interface is set to active,
    we begin dealing with the actual mode-specific logic.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，调用`Reset()`方法。它用于禁用所有不必要的界面元素，并将选择数据成员重置为其默认值。在存储实际选择模式并将界面设置为活动状态后，我们开始处理实际的模式特定逻辑。
- en: If we are in the tile selection mode, it simply involves enabling a number of
    interface elements, as well as setting their text to match the context. For the
    sake of simplicity, all of the element manipulation in this method is omitted.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于瓷砖选择模式，它仅仅涉及启用一些界面元素，以及将它们的文本设置为匹配上下文。为了简单起见，此方法中省略了所有元素操作。
- en: Dealing with entity and emitter modes is similar, yet includes an additional
    step, which is populating the drop-down menu with appropriate values. In both
    cases, the drop-down element is obtained and purged of its current entries. The
    appropriate directory list is then iterated over; adding each entry to the drop-down,
    making sure the file type is removed. Once this is done, the drop-down menu is
    instructed to be re-drawn.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 处理实体和发射器模式类似，但包括一个额外的步骤，即用适当的值填充下拉菜单。在这两种情况下，都获取下拉元素并清除其当前条目。然后遍历适当的目录列表；将每个条目添加到下拉菜单中，确保移除文件类型。完成此操作后，指示下拉菜单重新绘制。
- en: 'Let us take a look at what needs to happen when our selection options class
    is instructed to select a particular entity:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们的选择选项类被指示选择特定实体时需要发生什么：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, the argument could be used to de-select an entity, as well as select
    it. If the appropriate de-select value is passed, or an entity position component
    with the provided identifier has not been found, the related interface elements
    are adjusted to match the situation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该参数可用于取消选择实体，以及选择它。如果传递了适当的取消选择值，或者未找到提供的标识符的实体位置组件，则相关的界面元素被调整以匹配该情况。
- en: If an entity with the provided ID does exist, the proper elements are enabled
    and adjusted. The entity position component as well as its identifier is stored
    for later use, and the information text element of the selection options interface
    is changed to reflect the ID of the entity selected. It is also marked to be updated,
    by manipulating the *boolean* flag `m_selectUpdate`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的ID对应的实体存在，则适当的元素被启用并调整。实体位置组件及其标识符被存储以供以后使用，并且选择选项界面中的信息文本元素被更改以反映所选实体的ID。它也被标记为更新，通过操作布尔标志`m_selectUpdate`。
- en: 'A very similar process takes place when selecting an emitter:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 选择发射器时发生的过程非常相似：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is simpler in a sense that we are only working with a pointer to a particle
    emitter. If `nullptr` is passed in, proper elements are disabled and adjusted.
    Otherwise, the interface is updated to reflect the information of the emitter
    that is selected, while also marking the `selectionOptions` interface is properly
    updated afterwards.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，我们只处理一个指向粒子发射器的指针。如果传入`nullptr`，则适当的元素被禁用并调整。否则，界面更新以反映所选发射器的信息，之后还标记`selectionOptions`界面已正确更新。
- en: 'We obviously also need a way to switch between the different selection modes,
    hence this callback:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然还需要一种在不同的选择模式之间切换的方法，因此有了这个回调函数：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It simply cycles through all of the options for selection. One thing worthy
    of pointing out here is that if the interface before cycling is in tile mode,
    we want to make sure that the `ControlMode` is switched to `Select`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它简单地遍历所有选择选项。这里值得指出的一点是，如果循环之前的界面处于瓷砖模式，我们想要确保将`ControlMode`切换到`Select`。
- en: 'Another feature we want to work on is opening up and dealing with tiles being
    selected from the tile-sheet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望工作的另一个特性是打开和处理从瓦片表中选中的瓦片：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we deal with just opening the `tileSelector` interface, provided it is
    not set to active yet. On the other hand, if the interface is open, the select
    button being pressed indicates the user attempting to copy their selection to
    the brush. The `mapControls` class is instructed to switch its mode to `Brush`,
    which is then passed into the `tileSelector` class's `CopySelection()` method,
    responsible for copying actual tile data. Since it returns a *boolean* value that
    indicates its success, the method is invoked inside an `if` statement, which allows
    us to update the solidity element of the interface and request a brush re-draw,
    provided the copying procedure was successful. At any rate, the information text
    element of the `selectionOptions` interface is then updated to hold the total
    count of tiles that have been selected and copied to the brush.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们处理打开 `tileSelector` 接口，前提是它尚未设置为激活状态。另一方面，如果接口已打开，被按下的选择按钮表示用户试图将他们的选择复制到画笔中。`mapControls`
    类被指示将其模式切换到 `Brush`，然后传递给 `tileSelector` 类的 `CopySelection()` 方法，该方法负责复制实际的瓦片数据。由于它返回一个指示其成功的
    *布尔* 值，该方法在 `if` 语句内被调用，这使得我们能够在复制过程成功的情况下更新界面的实体性元素并请求画笔重新绘制。无论如何，`selectionOptions`
    接口的信息文本元素随后被更新，以保存已选并复制到画笔中的瓦片总数。
- en: 'Toggling the solidity of the current portion of the map being selected or the
    brush itself is also possible in our tile editor:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的瓦片编辑器中，切换当前被选中的地图部分或画笔本身的实体性也是可能的：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, we obviously can not toggle the solidity of a selection, if the control
    mode is not set to either the `Brush` or `Select` mode. With that being covered,
    the solidity state label is obtained, as well as its text. After flipping its
    value to its opposite and updating the element's text, we establish a range of
    tiles that will be modified. In the case of a brush having its solidity toggled,
    the range encapsulates the entire structure. On the other hand, the map selection
    range is used when dealing with the select mode.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，显然不能切换选择范围的实体性，如果控制模式没有设置为 `Brush` 或 `Select` 模式。覆盖这一点后，我们获取实体状态标签及其文本。翻转其值到其相反，并更新元素的文本后，我们建立一个将要修改的瓦片范围。在画笔的实体性被切换的情况下，范围包含整个结构。另一方面，当处理选择模式时，使用地图选择范围。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `m_selectRangeX` and `m_selectRangeY` data members represent the selection
    range of the map tiles. Each range is responsible for its own axis. For example,
    `m_selectRangeX.x` is the **starting ** *X* coordinate, and `m_selectRangeX.y`
    is the **ending** *X* coordinate.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_selectRangeX` 和 `m_selectRangeY` 数据成员表示地图瓦片的选取范围。每个范围负责其自身的轴。例如，`m_selectRangeX.x`
    是 **起始** *X* 坐标，而 `m_selectRangeX.y` 是 **结束** *X* 坐标。'
- en: After the range is properly established, we simply need to iterate over it and
    obtain tiles from the appropriate `TileMap`, setting their solidity to the appropriate
    value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在范围被正确建立后，我们只需遍历它，并从适当的 `TileMap` 获取瓦片，将它们的实体性设置为适当的值。
- en: 'Copying a certain portion of the map to the brush could also prove to be a
    useful feature:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将地图的某个部分复制到画笔也可能是一个有用的特性：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We begin by checking if a selection actually was made, which can be done by
    checking any of the select range data members. Afterwards, the size of the selection
    is calculated by subtracting the start-points of the selection from the end-points,
    and increasing the size by one unit on both axes. This is done in order to compensate
    for inclusive ranges that start and end on the same exact tile number.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否确实进行了选择，这可以通过检查任何选择范围的数据成员来完成。之后，通过从选择范围的起点减去终点，并在两个轴上各增加一个单位来计算选择的大小。这样做是为了补偿那些开始和结束在同一确切瓦片编号上的包含范围。
- en: Once the brush tile map is purged and resized, some local variables are set
    up in order to aid the rest of the code. The three *unsigned integers* are going
    to be used as index coordinates for the brush tile map, in order to map the copied
    tiles correctly. The two *boolean* flags and the *unsigned short *changes are
    going to keep track of solidity changes, in order to update the GUI element that
    denotes what solidity state the selection is in.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦清除并调整画笔瓦片地图的大小，就会设置一些局部变量以帮助其余代码。三个*无符号整数*将被用作画笔瓦片地图的索引坐标，以便正确映射复制的瓦片。两个*布尔*标志和*无符号短整型*变化将用于跟踪坚固性变化，以便更新表示选择处于何种坚固状态的用户界面元素。
- en: Next, the tile loops are entered. After the map tile at the specific coordinates
    is obtained and passes the validity check, the brush tile at the current coordinates
    denoted by `b_x`, `b_y`, and `b_l` is set to hold the same tile ID. The solidity
    changes of the tile are then detected and noted, in order to determine if we have
    a mixed selection of solidities. Finally, all other tile properties are transferred
    to the brush, by utilizing the overloaded `=` operator.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入瓦片循环。在获取特定坐标处的地图瓦片并通过有效性检查后，当前坐标由`b_x`、`b_y`和`b_l`表示的画笔瓦片被设置为持有相同的瓦片ID。然后检测并记录瓦片的坚固性变化，以确定我们是否有一个混合的坚固性选择。最后，通过使用重载的`=`运算符，将所有其他瓦片属性转移到画笔上。
- en: In order to keep the interface up–to–date with our actions, the current layer
    selection range is checked for exceeding the actual range of total layers supported
    by the application. If, for example, we support four total layers and the current
    selected layer is two while the brush has all of its layers filled, we want to
    adjust the current layer selection to honour that by calculating the layer difference,
    adjusting the highest layer selected to match the maximum layer supported by the
    application, and subtract the difference from the lowest layer, hence preserving
    the proper range of the brush.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使界面与我们的操作保持同步，当前图层选择范围会被检查是否超出了应用程序支持的总图层实际范围。例如，如果我们支持四个总图层，而当前选中的图层是第二个，同时画笔的所有图层都已填充，我们希望通过计算图层差异，调整所选最高图层以匹配应用程序支持的最大图层，并从最低图层中减去这个差异，从而保持画笔的正确范围。
- en: Lastly, a method for updating the selection options elevation selection text
    is invoked, the map controls class is instructed to switch to the `Brush` mode,
    and the selection options interface is updated with the information of the brush
    tile count and solidity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用一个用于更新选择选项高度选择文本的方法，指示地图控制类切换到`画笔`模式，并使用画笔瓦片计数和坚固性信息更新选择选项界面。
- en: 'Let us drift away from the topic of placing, editing, or copying tiles for
    a second, and talk about actually placing entities or emitters when the **Place**
    button is pressed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时放下放置、编辑或复制瓦片的话题，来谈谈当按下**放置**按钮时实际放置实体或发射器的情况：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are not going to be using this functionality to do anything with tiles, because
    that is what the mouse is designated for. If the `selectionOptions` interface
    is in the proper `Select` mode, the value of the drop-down menu is obtained and
    checked for not being empty. The **Place** button can also act as the **Edit**
    button under appropriate circumstances, such as when an entity or particle emitter
    is selected, so in both cases, the appropriate values are checked for representing
    a selection, or lack thereof. If nothing is selected, the drop-down value is used
    to add a new entity or emitter of the selected type. The `SaveOptions()` method
    is then invoked, so in either case, the information currently stored in the `selectionOptions`
    interface is saved to either the newly created object, or one that was already
    selected.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用这个功能对瓦片进行任何操作，因为那是鼠标的指定用途。如果`selectionOptions`界面处于适当的`选择`模式，会获取下拉菜单的值并检查其是否为空。在适当的情况下，例如选中实体或粒子发射器时，**放置**按钮也可以充当**编辑**按钮，因此在这两种情况下，都会检查适当的值以表示选择或未选择。如果没有选择任何内容，则使用下拉值添加所选类型的新实体或发射器。然后调用`SaveOptions()`方法，因此在这种情况下，当前存储在`selectionOptions`界面中的信息将被保存到新创建的对象或已选中的对象中。
- en: 'Pressing the **Remove** button can be handled like so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按下**删除**按钮可以这样处理：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, a different method is invoked here, with a *boolean* flag being
    passed to it, denoting whether the *Shift* key is being held down, controlling
    how much of the current selection is removed. Let us take a look at the actual
    delete method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里调用了一种不同的方法，传递了一个*布尔*标志，表示是否按下了*Shift*键，控制当前选择中删除多少。让我们看看实际的删除方法：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once again, we deal with all three different selection types: tile, entity,
    and particle emitters. If we are working with tiles, the selection range is checked.
    Provided something actually is selected, the layer range is defined, based on
    whether the argument says everything should be deleted. The map is then instructed
    to remove the tiles and cleat its render texture within the calculated ranges.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次处理所有三种不同的选择类型：瓦片、实体和粒子发射器。如果我们正在处理瓦片，检查选择范围。如果实际上有选择，根据参数是否表示应该删除一切，定义层范围。然后指示地图在计算出的范围内删除瓦片并清除其渲染纹理。
- en: In the cases of entities and particle emitters, it's much less complicated.
    The selected entity/emitter is simply removed, and the appropriate `SelectX` method
    is invoked shortly after, passing in a value for nothing being selected.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体和粒子发射器的情况下，事情要简单得多。所选的实体/发射器被简单地删除，并在不久之后调用适当的`SelectX`方法，传入一个没有选择值的参数。
- en: 'Next, let us handle the ***+*** and ***-*** buttons that control the elevation
    selection being pressed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理控制海拔选择的***+***和***-***按钮：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we want to handle the button clicks in a specific way. Keep in mind that
    support for selecting ranges of layers is also something of great importance.
    Consider the following illustration:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们希望以特定的方式处理按钮点击。请记住，支持选择层范围也是非常重要的。考虑以下插图：
- en: '![Implementing selection options](img/image_05_002.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![实现选择选项](img/image_05_002.jpg)'
- en: Simply clicking either a plus or a minus would affect the low number, which
    represents the lowest elevation selected. Holding a *Shift* key would increase
    the high number, controlling the highest elevation. For this, two integers, `low`
    and `high`, are set up, alongside a *boolean* flag that determines if a *Shift*
    key is being held or not. Based on that and the event name, the numbers are adjusted
    to represent the changes in elevation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 单击加号或减号会影响低数，它代表所选最低海拔。按住*Shift*键会增加高数，控制最高海拔。为此，设置了两个整数`low`和`high`，以及一个*布尔*标志，用于确定是否按下了*Shift*键。根据这一点和事件名称，数字被调整以表示海拔的变化。
- en: Next, we branch out the logic once again. If a `Brush` mode is selected, we
    do not want to deal with any changes of the high elevation at all. Instead, only
    the low layer selection is used here. After a new value for it is established
    by adding the layer delta to the already selected low elevation, the range is
    checked for exceeding the boundaries of [0;`Sheet::NumLayers`). Provided that
    passes, the low elevation selection is updated with the new value, as is the high
    value, which simply takes the low elevation and adds the thickness of the brush
    to it, represented by the brush's highest elevation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次分支逻辑。如果选择了`Brush`模式，我们根本不想处理任何高海拔的变化。相反，这里只使用低层选择。通过将层增量添加到已选择的低海拔，确定新的值，检查范围是否超过[0;`Sheet::NumLayers`)的边界。如果通过，低海拔选择将使用新值更新，高值也更新，它简单地取低海拔并加上画笔的厚度，这由画笔的最高海拔表示。
- en: 'The `Select` mode follows the same basic principle, with one exception: it
    also handles the high elevation. With the deltas properly added to the current
    values, the range is checked for exceeding the allowed limits. The next check
    deals with how we control shift-clicks depending on whether both the low and high
    values are the same. If they are, the deltas are simply added to the low value,
    which is copied over to the high elevation, preserving the equality. Otherwise,
    both low and high values are simply overwritten with the preceding newly calculated
    range.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select`模式遵循相同的基本原则，只有一个例外：它还处理高海拔。通过适当地将增量添加到当前值中，检查范围是否超过允许的限制。下一个检查处理的是，当低值和高值都相同时，我们如何根据情况控制shift-clicks。如果它们相同，增量将简单地添加到低值，并将其复制到高海拔，以保持相等。否则，低值和高值都将简单地用先前计算的范围覆盖。'
- en: 'In both cases, it is also important to invoke the `SelectionElevationUpdate()`
    method, which makes sure the interface elements are kept up-to-date, like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，调用 `SelectionElevationUpdate()` 方法也很重要，它确保界面元素保持最新，如下所示：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After making sure the selection options interface is actually active, the elevation
    label is updated with the proper layer range. The `SaveOptions()` callback is
    then invoked with `nullptr` for its argument. It is responsible for actually saving
    the interface''s information to whatever object happens to be selected. Let us
    take a look at this method now:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选择选项界面实际上处于活动状态后，高度标签会更新为适当的层范围。然后，使用 `nullptr` 作为其参数调用 `SaveOptions()` 回调。它负责将界面信息保存到所选的任何对象。现在让我们看看这个方法：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The most obvious first check is to make sure we are not in tile mode, because
    there is nothing to save there. Afterwards, the values from the text-fields representing
    *X*, *Y*, and *Z* coordinates are obtained and converted to numbers. This is where
    our logic branches out once again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的第一步检查是确保我们不在瓦片模式下，因为那里没有可以保存的内容。之后，代表 *X*、*Y* 和 *Z* 坐标的文本字段中的值被获取并转换为数字。这就是我们的逻辑再次分支的地方。
- en: In the case of dealing with an entity, we must first make sure one is selected.
    If it is, its position is changed to that of the values just obtained from the
    interface. We do not need to use the *Z* coordinate here, because that is replaced
    by the elevation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理实体的情况下，我们首先必须确保已经选择了一个实体。如果是的话，它的位置将改变为从界面获取的值的那个位置。这里我们不需要使用 *Z* 坐标，因为那被高度所取代。
- en: The *Z* coordinate is, however, used when dealing with particle emitters. After
    obtaining the additional value of the emit rate from the interface and converting
    it to a proper number, all of these values are applied to the current particle
    emitter selected.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当处理粒子发射器时，会使用到 *Z* 坐标。从界面获取额外的发射率值并将其转换为适当的数字后，所有这些值都应用于当前选定的粒子发射器。
- en: 'Now, the piece of code that makes everything else tick:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是使其他一切正常工作的代码片段：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At this point, we want to make sure the selection drawable is updated, provided
    the `m_selectUpdate` flag is enabled. The rest of the code can be skipped if the
    `mapControls` class is not letting us know that the left mouse button is pressed.
    However, if it is, an appropriate update method is invoked, depending on what
    `selectMode` the interface is in.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们想要确保选择可绘制的内容被更新，前提是 `m_selectUpdate` 标志被启用。如果 `mapControls` 类没有告诉我们左鼠标按钮被按下，则可以跳过其余的代码。然而，如果是的话，会根据界面中的
    `selectMode` 调用适当的方法进行更新。
- en: 'A good way to keep an application looking neat and responsive is having neat
    indicators of certain selections being made, like so:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 保持应用程序看起来整洁且响应迅速的一个好方法是拥有某些选择清晰的指示，如下所示：
- en: '![Implementing selection options](img/image_05_003.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![实现选择选项](img/image_05_003.jpg)'
- en: 'Let us take a look at how the selection rectangle can be updated for entities
    and emitters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何更新实体和发射器的选择矩形：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As always, our logic branches out, depending on the selection mode we are in.
    Provided we are working with entities, a few checks are necessary in order to
    make sure one is selected. If it is, the next problem at hand is giving the rectangle
    a proper size, origin, and position. The easiest way to do that is by obtaining
    the colloidal component of an entity and manipulating it based on the collision
    primitive. If the entity doesn't have that type of component, we attempt to use
    the next best thing - its sprite sheet. Finally, if there's only a position component
    to work with, the rectangle is centered at the entity's position and given a fixed
    size of *32x32*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们的逻辑会根据我们所在的选取模式分支。如果我们正在处理实体，需要进行一些检查以确保已经选择了一个实体。如果是的话，下一个问题是给矩形一个合适的大小、原点和位置。做到这一点最简单的方法是获取实体的胶体组件并根据碰撞原语进行操作。如果实体没有那种类型的组件，我们尝试使用下一个最好的东西——它的精灵图集。最后，如果只有位置组件可以操作，矩形将位于实体的位置中心，并赋予一个固定的尺寸
    *32x32*。
- en: Dealing with emitters is quite similar, minus the entire component headache.
    Provided one is selected, its 2D position is obtained and used to centre the rectangle,
    while giving it a static size of *32x32*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 处理发射器与处理实体相当相似，只是没有整个组件的烦恼。如果已经选择了一个发射器，它的二维位置会被获取并用来定位矩形，同时给它一个静态的尺寸 *32x32*。
- en: 'Let us move on to updating the tile selection next:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续更新瓦片选择：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the actual method that handles tile selection logic. First, the coordinates
    of the starting tile that got clicked are obtained along with the current mouse
    position in tile coordinates. This information is used to calculate absolute global
    coordinates for the rectangle that will be used to represent the selection. The
    actual rectangle is then updated with this information, as well as set to have
    the `m_selectStartColor` color. Finally, all that is left to do is save this information
    as the current selection range, making sure it is in ascending order.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理瓦片选择逻辑的实际方法。首先，获取被点击的起始瓦片的坐标以及当前鼠标位置的瓦片坐标。这些信息用于计算表示选择的矩形的绝对全局坐标。然后，使用这些信息更新实际的矩形，并将其设置为具有`m_selectStartColor`颜色。最后，剩下的只是将此信息保存为当前选择范围，确保它是升序排列的。
- en: 'Next, updating entity selection deserves a peek:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新实体选择值得一看：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A check is needed to make sure the `mapControls` are in action in the same fashion
    as tile updating. Also, we obviously cannot update an entity that is not even
    selected, so a check is needed for that as well. The final bit of logic simply
    deals with moving the entity by the mouse position difference and updating our
    `selectionOptions` interface to hold its current position and elevation. The layer
    selection range is also updated to hold the elevation information. Finally, the
    select update flag is set to `true`, which requests the selection rectangle to
    be updated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行一项检查以确保`mapControls`与瓦片更新以相同的方式生效。显然，我们无法更新一个未被选中的实体，因此也需要对此进行检查。最后的逻辑部分仅涉及通过鼠标位置差移动实体，并将我们的`selectionOptions`接口更新为保持其实际位置和高度。图层选择范围也更新以保存高度信息。最后，将选择更新标志设置为`true`，这会请求更新选择矩形。
- en: 'It''s time to wrap up the updating logic. The only remaining mode left to update
    is the particle emitter selection:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候总结更新逻辑了。唯一剩下的需要更新的模式是粒子发射器选择：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Just as before, the map control primary action flag is checked before proceeding,
    as well as the actual selection being made. The `X` and `Y` attributes of the
    particle emitter position are pushed by the mouse delta, while the `Z` coordinate
    is preserved as is. Afterwards, it is only a matter of updating the interface
    with the most recent position of the particle emitter, and marking the selection
    drawable for updating.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，在继续之前，会检查地图控制的主要动作标志以及实际的选择。粒子发射器位置的`X`和`Y`属性通过鼠标移动量进行推进，而`Z`坐标保持不变。之后，只需更新接口以包含粒子发射器的最新位置，并标记选择可绘制以进行更新。
- en: 'The last few pieces of the puzzle involve us dealing with mouse input correctly:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几块拼图涉及我们正确处理鼠标输入：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you recall from the previous chapter, this method is invoked by the `mapControls`
    class. It is required to return a *boolean* value that denotes whether a selection
    has been made or not, so that the `mapControls` class can deal with its own logic
    if the set of tools can give the artist a boost they have been looking for latter
    is true. When dealing with tiles, this method always needs to return `true`, allowing
    the control class to know that an action is taking place regardless.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从上一章回忆的那样，此方法由`mapControls`类调用。它需要返回一个表示是否已进行选择的*布尔值*，以便`mapControls`类可以处理自己的逻辑，如果工具集能够为艺术家提供他们一直寻求的助力，那么这个条件为真。在处理瓦片时，此方法始终需要返回`true`，使控制类知道正在发生动作，无论是什么动作。
- en: While in entity mode, the `FindEntityAtPoint` method of the `entityManager`
    class is invoked, with the global position, as well as the layer selection range
    being passed in as arguments. The latter is only true if the user of the tile
    editor has decided to only make selected layers visible. It will return an entity
    ID if an entity has been found at a specific point in space, which is then used
    to call `SelectEntity`. To determine whether an entity has been selected, the
    ID is checked for not being equal to a known value for *not found*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体模式下，`entityManager`类的`FindEntityAtPoint`方法被调用，全局位置以及图层选择范围作为参数传入。后者仅在瓦片编辑器的用户决定仅使选定的图层可见时才为真。如果在空间中的特定点找到了实体，它将返回一个实体ID，然后用于调用`SelectEntity`。为了确定是否已选中实体，将ID检查是否不等于“未找到”的已知值。
- en: A very similar procedure is used to select a particle emitter. Because most
    emitters are single points in space, a `sf::Vector2f` needs to be used here simply
    to define the area around the position that can be clicked in order to select
    it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 用来选择粒子发射器的程序非常相似。因为大多数发射器都是空间中的单个点，所以在这里需要使用`sf::Vector2f`来定义可以点击以选择它的位置周围的区域。
- en: Lastly, if a selection hasn't been made, the position text-fields of the selection
    options interface are filled in with the global coordinates of the click. This
    allows easier positioning of objects in the world before placement.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果尚未进行选择，选择选项界面的位置文本字段将填充为点击的全局坐标。这允许在放置之前更容易地在世界中定位对象。
- en: 'Surprisingly, quite a lot needs to happen when a mouse button is released.
    Let''s take a look:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 意想不到的是，当鼠标按钮释放时，需要发生很多事情。让我们看看：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Most of this logic is concerned with dealing with tile selection. The first
    thing we need to worry about is setting the selection rectangle to its final color,
    indicating the selection is made. After that, the interface buttons for copying
    and removing the selection are made visible, and a loop is used to check the selection
    in order to determine the solidity situation of the entire chunk, which is then
    saved to the appropriate interface element.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分逻辑的大部分都与处理瓦片选择有关。我们首先需要担心的是将选择矩形设置为最终颜色，以指示已进行选择。之后，复制和删除选择界面的按钮变得可见，并使用循环检查选择，以确定整个块的整体坚固情况，然后将其保存到适当的界面元素中。
- en: The entity and emitter modes do not need quite as much maintenance for such
    a simple task. All we need to worry about here is setting the selection rectangle
    colors appropriately.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的任务，实体和发射器模式不需要太多的维护。我们在这里需要担心的是适当地设置选择矩形的颜色。
- en: 'As modes are being switched, all of the important data needs to be reset in
    order to avoid strange bugs:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当模式切换时，所有重要数据都需要重置，以避免奇怪的错误：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition to ranges and IDs being reset, the actual selection of the `DropDownMenu`
    of entities/emitters needs zeroing-out. Finally, all of the mode-specific GUI
    elements we have been working with need to be disabled and/or set to their neutral
    values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了范围和ID被重置之外，实体/发射器的`DropDownMenu`的实际选择也需要归零。最后，我们一直在使用的所有模式特定的GUI元素都需要禁用或设置为它们的默认值。
- en: 'Finally, we are left with only one essential chunk of code left to cover -
    the `Draw()` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只剩下最后一段关键代码需要覆盖 - `Draw()`方法：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only thing that we really need to draw is the selection rectangle. As it
    is quite evident here, it does not need to be drawn if no selection of any kind
    has been made. This includes checking all three select modes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要绘制的东西只有选择矩形。正如这里很明显的那样，如果没有进行任何类型的选择，就不需要绘制它。这包括检查所有三种选择模式。
- en: 'For the sake of completion, we only have a couple of getter methods left to
    look over:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们只剩下几个getter方法需要检查：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This concludes the `selectionOptions` class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`selectionOptions`类。
- en: Building the tile selector
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建瓦片选择器
- en: 'When working with tile maps, it is important to have a fast and intuitive way
    of accessing the tile-sheet, selecting its contents and painting them directly
    onto the game map. A good set of tools can give the artist the boost they have
    been looking for, while an unmanageable application is only a hindrance. Let us
    take a peek at what we are going to be building:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当与瓦片地图一起工作时，有一个快速直观的方式来访问瓦片表，选择其内容并将其直接绘制到游戏地图上是非常重要的。一套好的工具可以为艺术家提供他们一直在寻找的助力，而一个难以管理的应用程序只会成为障碍。让我们看看我们将要构建的内容：
- en: '![Building the tile selector](img/image_05_004.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![构建瓦片选择器](img/image_05_004.jpg)'
- en: 'This interface, just like most others we have been working with, is going to
    be much easier to manage when wrapped in a class of its own:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个界面，就像我们一直在使用的其他大多数界面一样，当封装在自己的类中时，将更容易管理：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Just like before, we have `Show()` and `Hide()` methods to manage its visibility,
    as well as a couple of callbacks. Note the highlighted method. It is going to
    be used for setting the texture of the tile-sheet the map is using.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们有`Show()`和`Hide()`方法来管理其可见性，以及一些回调。注意突出显示的方法。它将被用来设置地图使用的瓦片表的纹理。
- en: The data members are quite predictable for a class like this. Alongside the
    classes that this object relies on, we keep track of a pointer to the actual interface
    it is going to be manipulating, an instance of a `sf::RenderTexture` that we are
    going to be drawing to, the sprite that will be used to display the render texture,
    a rectangle shape, start and end coordinates, and a *boolean* flag for the actual
    selection drawable. Lastly, `m_sheetTexture` is going to simply keep track of
    the texture identifier until it is time to release it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的类，数据成员相当可预测。除了这个对象所依赖的类之外，我们还跟踪一个指向它将要操作的界面指针，一个我们将要绘制到的`sf::RenderTexture`实例，一个用于显示渲染纹理的精灵，一个矩形形状，起始和结束坐标，以及一个表示实际选择可绘制的布尔标志。最后，`m_sheetTexture`将简单地跟踪纹理标识符，直到需要释放它的时候。
- en: Implementing the tile selector
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现瓦片选择器
- en: 'Let us begin by setting all of this data up inside the constructor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在构造函数内设置所有这些数据开始：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After the arguments are taken care of, the three callback methods we need are
    set up. The interface is then loaded and stored as one of the data members, just
    before its content rectangle size and offset are changed in order to allow space
    for control elements, such as the close button to be positioned comfortably. The
    interface is then centered on–screen and set to inactive. Finally, the rectangle
    shape used to represent tile selection is initialized to its default state as
    well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完所有争论之后，我们需要设置三个回调方法。然后加载界面并将其存储为数据成员之一，就在其内容矩形的大小和偏移量改变之前，以便为控制元素留出空间，例如将关闭按钮放置得舒适。接着，界面在屏幕上居中并设置为非活动状态。最后，用于表示瓦片选择的矩形形状被初始化为其默认状态。
- en: 'Let us take a look at the destructor of this class next, in order to make sure
    we are not forgetting to release certain resources:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个类的析构函数，以确保我们没有忘记释放某些资源：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After all three callbacks are released, it is imperative to make sure the tile-sheet
    texture is removed as well, provided its identifier is not empty.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在释放所有三个回调之后，必须确保如果其标识符不为空，则还删除了瓦片纹理。
- en: 'Speaking of the tile-sheet texture, let us see how one can be assigned to this
    class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到瓦片纹理，让我们看看如何将一个分配给这个类：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After the current tile-sheet texture is properly released, the new one is assigned
    and retrieved. Because of this, the actual selector texture that will be passed
    to the main GUI element of our interface needs to be re-drawn and passed into
    said element.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当地释放当前的瓦片纹理之后，新的纹理被分配并检索。因此，实际将传递给界面主GUI元素的选取纹理需要重新绘制并传递到该元素中。
- en: 'A similar procedure takes place when the interface needs to be updated:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当界面需要更新时，发生类似的程序：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It simply consists of the tile-sheet, as well as the selector rectangle being
    drawn to the render texture. The interface is then instructed to re-draw its content,
    as it was changed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它仅由瓦片纹理以及绘制到渲染纹理上的选择矩形组成。然后指示界面重新绘制其内容，因为它已经发生了变化。
- en: 'Next, let us provide a way for outside classes to copy the current tile-sheet
    selection to a `TileMap` structure:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们提供一个方法，以便外部类可以将当前的瓦片纹理选择复制到`TileMap`结构中：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Obviously, we cannot copy anything if nothing has been selected. The first check
    takes care of that. The `TileMap` passed in as the argument is then purged in
    preparation for being overwritten. The tile coordinate range is then calculated,
    and the `TileMap` argument is re-sized to match the size of the selection. After
    a couple of local variables are established to help us calculate the *1D* coordinate
    index, we begin iterating over the calculated range of tiles one by one, adding
    them to the tile map. Because we're not working with any sort of depth when dealing
    with a tile-sheet, the layer is always going to be set to the value `0`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果没有选择任何内容，我们无法复制任何东西。第一个检查处理了这个问题。然后，作为参数传递的`TileMap`被清除，以备覆盖。然后计算瓦片坐标范围，并将`TileMap`参数调整到选择的大小。在建立几个局部变量以帮助我们计算*1D*坐标索引之后，我们开始逐个迭代计算出的瓦片范围，并将它们添加到瓦片图中。因为我们处理瓦片纹理时没有深度，所以层始终设置为值`0`。
- en: 'The following code deals with the mouse-click and mouse-release events, which
    are vital when making a selection:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码处理鼠标点击和鼠标释放事件，这在进行选择时至关重要：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we are dealing with a mouse-left click, we simply need to make note of the
    mouse coordinates at this point in time, as well as reset the `m_selected` flag
    to `false`. On the other hand, if the left mouse button has been released, the
    final mouse position is first checked for not going into negative values on both
    axes. The end coordinates are then stored, and the `m_selected` flag is set to
    `true`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在处理鼠标左键点击，我们只需记录此时鼠标的坐标，并将`m_selected`标志重置为`false`。另一方面，如果左鼠标按钮已经被释放，首先检查最终鼠标位置是否在两个轴上都没有进入负值。然后存储最终坐标，并将`m_selected`标志设置为`true`。
- en: The remaining chunk of code simply deals with making sure the start and end
    coordinates are stored in an ascending order, and calculating the proper position
    and size of the selector rectangle. The `UpdateInterface()` method is then invoked,
    which makes sure everything is re-drawn.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码块仅处理确保起始和结束坐标按升序存储，并计算选择矩形的位置和大小。然后调用`UpdateInterface()`方法，确保一切重新绘制。
- en: 'Let us wrap this up by quickly looking over some of the helper methods of this
    class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下这个类的辅助方法：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `Show()` and `Hide()` methods simply manipulate the interfaces activity,
    while the `Close` callback just invokes `Hide`. Just like that, all of the pieces
    fit together and we are left with a fully functional map editor!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Show()`和`Hide()`方法简单地操作界面的活动，而`Close`回调仅调用`Hide`。就这样，所有的部件都拼凑在一起，我们得到了一个完全功能性的地图编辑器！'
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Building tools for a game may not be the easiest or the most pleasant task in
    the world, but in the end, it always pays off. Dealing with text files, endless
    copy-pasting, or other botch-like solutions may work fine in the short term, but
    nothing beats a fully equipped set of tools, ready to take on any project with
    the click of a button! Although the editor we have built is geared towards a very
    specific task, the idea behind it can, with enough time and energy, be applied
    to any set of production problems.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为游戏构建工具可能不是世界上最容易或最愉快的工作，但最终，它总是值得的。处理文本文件、无尽的复制粘贴或其他糟糕的解决方案可能在短期内效果不错，但没有任何东西能比得上一个全副武装的工具集，只需点击一下按钮就能应对任何项目！虽然我们构建的编辑器针对的是一个非常具体的工作，但只要投入足够的时间和精力，这个想法可以应用于任何一组生产问题。
- en: In the next chapter, we are going to be covering the basics and general uses
    of shaders in SFML. The OpenGL shading language, along with SFML's built in support
    for shaders, is going to allow us to create a very basic day and night cycle.
    See you there!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍SFML中着色器的基本用法和一般用途。OpenGL着色语言，加上SFML内置对着色器的支持，将使我们能够创建一个基本的昼夜循环。那里见！
