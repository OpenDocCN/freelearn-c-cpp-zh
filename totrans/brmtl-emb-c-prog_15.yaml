- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Real-Time Clock (RTC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the **Real-Time Clock** (**RTC**) peripheral,
    an essential component for timekeeping in embedded systems. This peripheral is
    crucial for applications that require accurate time and date maintenance, making
    it fundamental for a wide range of embedded applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by introducing RTCs and understanding how they function. Following
    this, we will delve into the STM32 RTC module, examining its features and capabilities.
    Next, we will analyze the relevant registers from the STM32 reference manual,
    providing a detailed understanding of the configuration and operation of the RTC.
    Finally, we will apply this knowledge to develop an RTC driver, enabling precise
    timekeeping in your embedded projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding RTCs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STM32 RTC module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some key RTC registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the RTC driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of how RTCs
    work and will be equipped with the skills to develop bare-metal RTC drivers, allowing
    you to implement accurate timekeeping in your embedded systems projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding RTCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will enter the world of RTCs, understanding what they are
    and how they work before exploring common use cases through a few interesting
    case studies. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: RTCs are specialized hardware devices found in many microcontrollers and embedded
    systems. Their primary function is to keep track of the current time and date,
    even when the main power supply is turned off. Imagine them as the little timekeepers
    of the digital world, ensuring that the clock never stops ticking, no matter what.
  prefs: []
  type: TYPE_NORMAL
- en: RTCs are crucial in applications where timekeeping is essential. This includes
    everything from simple alarm clocks to complex data logging systems, where accurate
    timestamps are necessary. An RTC continues to operate on a small battery when
    the main system is powered down, maintaining accurate time and date information.
    Let’s see how they work.
  prefs: []
  type: TYPE_NORMAL
- en: How do RTCs work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the heart of an RTC is a crystal oscillator, which provides a stable clock
    signal. This oscillator typically runs at **32.768 kHz**, a frequency chosen because
    it is easily divisible by powers of two, making it convenient for binary counting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simplified breakdown of how an RTC works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Crystal oscillator**: The RTC contains a crystal oscillator that generates
    a precise clock signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Counter**: This clock signal drives a counter. The counter increments at
    a rate determined by the oscillator’s frequency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time and date registers**: The counter’s value is used to update time and
    date registers, which hold the current time (hours, minutes, seconds) and date
    (day, month, year).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Battery backup**: To ensure continuous operation, RTCs often have a battery
    backup. This keeps the oscillator running and the counter active even when the
    main power is off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s consider some common use cases for RTCs.
  prefs: []
  type: TYPE_NORMAL
- en: Common use cases for RTCs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RTCs are incredibly versatile and are used in a wide variety of applications.
    Let’s explore some of the common use cases through a few case studies.
  prefs: []
  type: TYPE_NORMAL
- en: Case study 1 – data logging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the most common applications of RTCs is in data logging. Imagine that
    you’re designing a weather station that collects temperature, humidity, and pressure
    data. Accurate timestamps are crucial for analyzing trends and patterns over time.
    Here’s how an RTC plays a vital role in this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization**: The RTC is initialized and set to the current time and
    date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data collection**: Every time a sensor reading is taken, the RTC provides
    a timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: The sensor data, along with the timestamp, is stored in memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analysis**: When the data is retrieved for analysis, the timestamps ensure
    that each reading can be accurately placed on a timeline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the RTC ensures that every piece of data is accurately timestamped,
    making it possible to track changes and trends with precision.
  prefs: []
  type: TYPE_NORMAL
- en: Case study 2 – alarm clocks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'RTCs are also fundamental in designing alarm clocks. Be it a simple bedside
    alarm clock or a complex scheduling system, the RTC provides the accurate timekeeping
    needed to trigger events at the right moment. Let’s look at a typical alarm clock
    scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timekeeping**: The RTC keeps track of the current time, continuously updating
    the time registers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alarm setting**: The user sets an alarm for a specific time. This information
    is stored in the RTC alarm registers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alarm trigger**: When the RTC time matches the alarm time, an interrupt is
    triggered, activating the alarm mechanism (such as sounding a buzzer or turning
    on a light).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the RTC ensures that the alarm goes off at the precise time set
    by the user, making it an essential component for reliable time-based alerts.
    At this point, your next question might be, “*What’s so special* *about RTCs?*”
  prefs: []
  type: TYPE_NORMAL
- en: Why are RTCs important?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might be wondering why we can’t just use the system clock or general-purpose
    timers for timekeeping. The answer lies in the RTC’s ability to keep accurate
    time, even when the main system is powered down. Here are some key reasons why
    RTCs are indispensable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accuracy**: RTCs use crystal oscillators, which provide highly accurate timekeeping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low power consumption**: RTCs are designed to operate on very low power,
    often running for years on a small battery'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Battery backup**: RTCs continue to keep time even when the main power is
    off, thanks to their battery backup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independence from the main system**: RTCs operate independently of the main
    microcontroller, ensuring continuous timekeeping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding how RTCs work and their common use cases, we can appreciate
    their importance and effectively incorporate them into our embedded projects.
    Whether you’re building a simple alarm clock or a complex data logging system,
    the RTC is an important component that ensures your system always knows the right
    time. In the next section, we will explore the RTC peripheral in our STM32F411
    microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32 RTC module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the RTC module in the STM32F4 microcontroller
    family. Let’s start by looking at its features.
  prefs: []
  type: TYPE_NORMAL
- en: The main features of the STM32F4 RTC module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The STM32F4 RTC module is like the Swiss Army knife of timekeeping, offering
    a rich set of features designed to meet the needs of numerous applications. Here
    are some of the standout features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calendar with sub-seconds**: The RTC module doesn’t just keep track of hours,
    minutes, and seconds; it also maintains sub-second accuracy. This is particularly
    useful for applications that require precise time measurements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alarm functionality**: Imagine that you have two alarm clocks within your
    microcontroller. The STM32F4 RTC module provides two programmable alarms, **Alarm
    A** and **Alarm B**, which can trigger events at specific times. This is perfect
    for tasks that need to be performed at regular intervals or at a specific time
    of day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low power consumption**: One of the biggest advantages of the RTC module
    is its low power usage. This makes it ideal for battery-operated devices, where
    conserving power is paramount.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backup domain**: The RTC can operate independently of the main power supply
    thanks to a backup battery. This means that even if your device loses power, the
    RTC keeps running, maintaining accurate time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Daylight saving time**: With the RTC module, you can program adjustments
    for daylight saving time automatically. No more manual resets twice a year!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic wakeup**: The RTC can generate periodic wakeup signals, bringing
    your system out of low-power modes at preset intervals. This feature is invaluable
    for applications that need to perform regular checks or updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tamper detection**: Security is a critical aspect of many applications, and
    the RTC module has you covered with tamper detection. It can log tamper events,
    providing an added layer of security for your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Digital calibration**: Accuracy is king when it comes to timekeeping. The
    RTC module includes a digital calibration feature to compensate for deviations
    in the crystal oscillator frequency, ensuring your timekeeping remains spot-on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronization with external clocks**: To enhance precision, the RTC can
    synchronize with an external clock source. This is great for applications that
    need to maintain very high accuracy over long periods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s analyze some of the key components of the STM32F4 RTC module.
  prefs: []
  type: TYPE_NORMAL
- en: The key components of the STM32F4 RTC module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a closer look at the key components of the RTC module in the STM32F4
    microcontroller family. We’ll break down each part to understand how they work
    together to provide accurate timekeeping and versatile functionality, starting
    with the clock sources.
  prefs: []
  type: TYPE_NORMAL
- en: Clock sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The driver of the RTC module is its clock sources. *Figure 15**.1* presents
    a detailed block diagram of the RTC module, highlighting the RTC clock sources.
    This diagram, sourced from the reference manual, provides a clear visual representation
    of the various components and their interactions within the RTC module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1: RTC block diagram with clock sources highlighted](img/B21914_15_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: RTC block diagram with clock sources highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: 'The STM32F4 RTC can use multiple clock sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Low-speed external (LSE)**: A 32.768 kHz crystal oscillator known for its
    stability and low power consumption. This is typically the preferred clock source
    for accurate timekeeping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-speed internal (LSI)**: An internal RC oscillator that provides a less
    accurate but convenient option when an external crystal is not available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-speed external (HSI)**: A high-speed clock source that can be used but
    is less common for RTC applications due to its higher power consumption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The selected clock source feeds into the RTC’s prescalers, which are responsible
    for dividing the clock frequency into suitable levels for timekeeping:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2: RTC block diagram – asynchronous and synchronous prescalers](img/B21914_15_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: RTC block diagram – asynchronous and synchronous prescalers'
  prefs: []
  type: TYPE_NORMAL
- en: Prescalers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RTC module employs two types of prescalers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous prescaler**: This prescaler, typically set to divide by **128**,
    reduces the clock frequency to a lower rate that can be managed by the synchronous
    prescaler. It helps balance power consumption and accuracy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronous prescaler**: Often configured to divide by **256**, this prescaler
    further reduces the clock frequency to generate a precise **1 Hz clock**, which
    is essential for updating the time and date registers accurately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These prescalers ensure the RTC can operate efficiently, providing the necessary
    timekeeping precision while conserving power. Next, we have the time and date
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: Time and date registers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 15**.3* highlights the time and date registers of the RTC block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3: RTC block diagram – time and date registers](img/B21914_15_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: RTC block diagram – time and date registers'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the core of the RTC’s functionality are the time and date registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time register (RTC_TR)**: This register holds the current time in hours,
    minutes, and seconds, stored in **Binary-Coded Decimal** (**BCD**) format. It
    is updated every second by the 1 Hz clock from the prescalers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date register (RTC_DR)**: This register maintains the current date, including
    the year, month, and day, also in BCD format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These registers are crucial for maintaining accurate time and date information,
    which can be read and adjusted as needed. The next key component is the RTC alarm.
  prefs: []
  type: TYPE_NORMAL
- en: Alarms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RTC module features two programmable alarms, Alarm A and Alarm B. These
    alarms can be set to trigger at specific times, providing a powerful tool for
    scheduling tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTC_ALRMAR` and `RTC_ALRMBR`) to store the alarm time and date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interrupts**: When an alarm is triggered, it can generate an interrupt, waking
    up the microcontroller from a low-power state or initiating a specific function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The alarm modules are indicated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4: RTC block diagram – alarms](img/B21914_15_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: RTC block diagram – alarms'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the wakeup timer.
  prefs: []
  type: TYPE_NORMAL
- en: Wakeup timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another key feature of the RTC module is the wakeup timer, which is managed
    by the `RTC_WUTR` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5: RTC block diagram – wakeup timer](img/B21914_15_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: RTC block diagram – wakeup timer'
  prefs: []
  type: TYPE_NORMAL
- en: This **16-bit** auto-reload timer can generate periodic wakeup events, bringing
    the system out of low-power modes at regular intervals. It’s ideal for tasks such
    as sensor readings or system checks, ensuring efficient power usage.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also the tamper detection module. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Tamper detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security is a vital aspect of many applications, and the RTC module includes
    tamper detection features. The tamper detection circuitry can log events when
    a tamper attempt is detected, using the timestamp registers to record the exact
    time and date. This adds an extra layer of security, especially in applications
    requiring reliable timekeeping and event logging. Next, we have the calibration
    register features.
  prefs: []
  type: TYPE_NORMAL
- en: Calibration and synchronization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To maintain high accuracy, the RTC module includes calibration features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTC_CALR` register allows for fine adjustments to the clock frequency, compensating
    for any deviations in the crystal oscillator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External clock synchronization**: The RTC can synchronize with an external
    clock source, enhancing accuracy by periodically adjusting the internal clock
    so that it matches the external reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features ensure the RTC maintains precise timekeeping, even in varying
    environmental conditions. We also have the backup and control registers module.
  prefs: []
  type: TYPE_NORMAL
- en: Backup and control registers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RTC module includes several backup and control registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Backup registers**: These registers store critical data that must be retained
    even when the main power supply is off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_CR`) manage the configuration and operation of the RTC, including enabling
    the clock, setting alarms, and configuring wakeup events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The backup and control registers module is indicated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6: RTC block diagram – backup and control registers](img/B21914_15_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: RTC block diagram – backup and control registers'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is the output control block.
  prefs: []
  type: TYPE_NORMAL
- en: Output control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The RTC module can output specific signals, such as a calibration clock or alarm
    outputs, through the `RTC_AF1` pin. This allows the RTC module to interact with
    other components or systems, providing synchronized signals or triggering external
    events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will analyze some of the key registers for configuring
    the RTC peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: Some key RTC registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the characteristics and functions of some of
    the important registers within the RTC module. These registers are the building
    blocks that allow us to configure, control, and utilize the RTC’s features effectively.
    Let’s start with the `RTC_TR`).
  prefs: []
  type: TYPE_NORMAL
- en: RTC Time Register (RTC_TR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RTC_TR` register is responsible for keeping track of the current time.
    It maintains the hours, minutes, and seconds in BCD format, ensuring that time
    is easily readable and manipulable. Here are some of the key fields in this register:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hour tens (HT) and hour units (HU)**: These bits represent the tens and units
    of the hour, respectively. They can handle both **24-hour** and **12-hour** formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minute tens (MNT) and minute units (MNU)**: These bits represent the tens
    and units of the minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second tens (ST) and second units (SU)**: These bits represent the tens and
    units of the seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PM**: This bit indicates the **AM/PM** notation when in **12-hour** format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further information about this register can be found on *page 450* of the *reference
    manual*. Let’s move on to the `RTC_DR`).
  prefs: []
  type: TYPE_NORMAL
- en: RTC Date Register (RTC_DR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RTC_DR` register is responsible for maintaining the current date. It keeps
    track of the year, month, day of the month, and day of the week, all in BCD format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key fields in this register:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Year tens (YT) and year units YU)**: These bits represent the tens and units
    of the year'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Month tens (MT) and month units (MU)**: These bits represent the tens and
    units of the month'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date tens (DT) and date units (DU)**: These bits represent the tens and units
    of the day of the month'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Week day units (WDU)**: This bit represents the day of the week (1 to 7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about this register on *page 451* of the *reference manual*.
    The next crucial register is the `RTC_CR`).
  prefs: []
  type: TYPE_NORMAL
- en: RTC Control Register (RTC_CR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RTC_CR` register is where we control the various operational modes and
    features of the RTC. This register allows us to enable the RTC, configure alarms,
    and set up the wakeup timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the key bits in this register:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WUTE**: Enable the wakeup timer. This bit enables the RTC wakeup timer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TSE**: Enable a timestamp event. This bit enables the timestamping of events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ALRAE and ALRBE**: Enable Alarm A and Alarm B. These bits enable the respective
    alarms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DCE**: Enable digital calibration. This bit enables digital calibration of
    the RTC clock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FMT**: Hour format. This bit sets the hour format to either 24-hour or 12-hour
    (AM/PM).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further details about this register can be found on *page 453* of the *reference
    manual*. Next, we have the `RTC_ISR`).
  prefs: []
  type: TYPE_NORMAL
- en: RTC Initialization and Status Register (RTC_ISR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RTC_ISR` register plays a dual role in both initializing the RTC and monitoring
    its status. This register is crucial during the setup process and for checking
    the RTC’s current state. Here are the key bits in this register:'
  prefs: []
  type: TYPE_NORMAL
- en: '**INIT**: Initialization mode. Setting this bit puts RTC into initialization
    mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RSF**: Registers synchronization flag. This bit indicates that the calendar
    registers are synchronized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INITS**: Initialization status flag. This bit indicates whether the RTC calendar
    has been initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ALRAF and ALRBF**: Alarm A and Alarm B flags. These bits indicate whether
    an alarm has been triggered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the `RTC_PRER`).
  prefs: []
  type: TYPE_NORMAL
- en: RTC Prescaler Register (RTC_PRER)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RTC_PRER` register manages the prescalers that divide the RTC clock source
    to produce the 1 Hz clock necessary for accurate timekeeping. There are two key
    fields in this register:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PREDIV_A**: Asynchronous prescaler. This field sets the value for the asynchronous
    prescaler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PREDIV_S**: Synchronous prescaler. This field sets the value for the synchronous
    prescaler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the `RTC_PRER` register properly is vital for maintaining the accuracy
    of the RTC.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the RTC Alarm Registers, `RTC_ALRMAR` and `RTC_ALRMBR`.
  prefs: []
  type: TYPE_NORMAL
- en: RTC Alarm Registers (RTC_ALRMAR and RTC_ALRMBR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These registers handle the configuration of Alarms A and B. They allow us to
    set specific times when the alarms should trigger. Here are the key fields in
    these registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ALRMASK**: Alarm mask bits. These bits allow you to mask certain parts of
    the alarm time, providing flexibility in how and when the alarms trigger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ALRH, ALRMN, and ALRS**: Hour, minute, and second fields. These fields set
    the specific time for the alarm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RTC_ALRMAR` and `RTC_ALRMBR` registers are vital for applications requiring
    reliable, time-based event triggering. Lastly, let’s explore the `RTC_WUTR`).
  prefs: []
  type: TYPE_NORMAL
- en: RTC Wakeup Timer Register (RTC_WUTR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RTC_WUTR` register configures the wakeup timer, enabling the RTC to periodically
    wake the system from low-power modes. The key field in this register is the **wakeup
    auto-reload value** (**WUT**). This field sets the interval for the wakeup timer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will apply everything we’ve learned in this section
    to develop a driver for the RTC peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the RTC driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop the RTC calendar driver so that we can configure
    and keep track of the time and date.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we will create a copy of our previous project while following the
    steps outlined in earlier chapters. We rename this copied project to `RTC_Calendar`.
    Next, create a new file named `rtc.c` in the `Src` folder and another file named
    `rtc.h` in the `Inc` folder. The RTC configuration can be quite elaborate, so
    we will create several helper functions to modularize the initialization process.
  prefs: []
  type: TYPE_NORMAL
- en: The RTC implementation file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin by populating the `rtc.c` file, starting with the helper functions
    necessary for the initialization function. Here are the macro definitions that
    we will use in the RTC configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break them down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PWREN` (`1U << 28`): This macro enables the clock for the PWR module by setting
    bit 28 in the APB1 peripheral clock enable register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CR_DBP` (`1U << 8`): This enables access to the backup domain by setting bit
    8 in the PWR register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSR_LSION` (`1U << 0`): This macro enables the LSI oscillator by setting bit
    0 in the Clock Control & Status Register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSR_LSIRDY` (`1U << 1`): This macro is used to read the state of the `LSI`
    register. The LSIRDY bit is set to 1 when the LSI is stable and ready to be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BDCR_BDRST` (`1U << 16`): This macro forces a reset of the backup domain by
    setting bit 16 in the Backup Domain Control Register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BDCR_RTCEN` (`1U << 15`): This enables RTC by setting bit 15 in the Backup
    Domain Control Register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_WRITE_PROTECTION_KEY_1` (`(uint8_t)0xCAU`): This key is used to disable
    write protection on the RTC registers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_WRITE_PROTECTION_KEY_2` (`(uint8_t)0x53U`): This is the second key needed
    to disable write protection on the RTC registers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_INIT_MASK` (`0xFFFFFFFFU`): This mask is used to enter initialization
    mode in the RTC peripheral.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISR_INITF` (`1U << 6`): This bit in the `ISR` register indicates that the
    RTC peripheral is in initialization mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WEEKDAY_FRIDAY` (`(uint8_t)0x05U`): This macro is used to configure the weekday
    of the calendar to Friday.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MONTH_DECEMBER` (`(uint8_t)0x12U`): This macro is used to configure the month
    of the calendar to December.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIME_FORMAT_PM` (`1U << 22`): This macro sets the time format to PM in the
    12-hour format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CR_FMT` (`1U << 6`): This macro sets the hour format to 24-hour format in
    the RTC control register (`RTC->CR`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISR_RSF` (`1U << 5`): This bit in the `ISR` register indicates that the RTC
    registers are synchronized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_ASYNCH_PREDIV` (`(uint32_t)0x7F`): This value sets the asynchronous prescaler
    for the RTC peripheral and is used to divide the clock frequency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_SYNCH_PREDIV` (`(uint32_t)0x00F9`): This value sets the synchronous prescaler
    for the RTC peripheral and is used to further divide the clock frequency for timekeeping
    accuracy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s examine the two functions responsible for setting the prescaler values
    for the RTC peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have `rtc_set_asynch_prescaler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This function sets the asynchronous prescaler value for the RTC peripheral.
    Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MODIFY_REG`: This macro modifies specific bits in a register. It is defined
    in the `stm32f4xx.h` header file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC->PRER`: The `PRER` register of the RTC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_PRER_PREDIV_A`: The mask for the asynchronous prescaler bits in the `PRER`
    register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsynchPrescaler << RTC_PRER_PREDIV_A_Pos`: This snippet shifts the `AsynchPrescaler`
    value to the correct position within the `PRER` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In short, this function configures the asynchronous prescaler by updating the
    appropriate bits in the `PRER` register. Next, we have the function for setting
    the synchronous prescaler – that is, `rtc_set_synch_prescaler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This function configures the synchronous prescaler by updating the appropriate
    bits in the `PRER` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTC->PRER`: The `PRER` register of the RTC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_PRER_PREDIV_S`: This is the mask for the synchronous prescaler bits in
    the `PRER` register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SynchPrescaler`: This directly sets the synchronous prescaler value in the
    `PRER` register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we must analyze the other RTC initialization helper functions to understand
    how they work together to configure and synchronize the RTC peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the `_rtc_enable_init_mode` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply put, this function sets the RTC peripheral to initialization mode by
    writing the initialization mask to the `ISR` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTC->ISR`: This is the `RTC_ISR` register of the RTC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_INIT_MASK`: This mask is used to enter initialization mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have `_rtc_disable_init_mode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function disables initialization mode by clearing the initialization mask
    in the ISR register. Here, `~RTC_INIT_MASK` clears the initialization mask, exiting
    initialization mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next helper function is `_rtc_isActiveflag_init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This function returns 1 if the RTC peripheral is in initialization mode by checking
    the `ISR_INITF` bit, which indicates that the RTC peripheral is in initialization
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have `_rtc_isActiveflag_rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function returns 1 if the RTC registers are synchronized by checking the
    `ISR_RSF` bit, which indicates that the RTC registers are synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also the `rtc_init_seq` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function starts the RTC initialization by enabling initialization mode
    and waiting until the RTC peripheral enters initialization mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_rtc_enable_init_mode`: This line puts the RTC peripheral into initialization
    mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_rtc_isActiveflag_init`: This line waits until the RTC peripheral is in initialization
    mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have the `wait_for_synchro` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This function clears the synchronization flag and waits until the RTC registers
    are synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have the `exit_init_seq` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function exits the RTC initialization mode and waits for the registers
    to synchronize to ensure everything is set up correctly. Now, let’s see the functions
    for configuring the date and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have `rtc_date_config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function sets the date in the RTC peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by creating a temporary variable called `temp` to hold the date value.
    This variable is carefully constructed by shifting and combining the weekday,
    day, month, and year into the appropriate positions for the RTC’s date register.
    The `MODIFY_REG` macro is then used to update the RTC’s date register with this
    new value. Here, we can have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WeekDay`: Represents the day of the week'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Day`: Represents the day of the month'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Month`: Represents the month of the year'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Year`: Represents the year'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, `rtc_date_config` takes the date components, assembles them into
    a single value, and writes it to the RTC’s date register, ensuring the RTC peripheral
    accurately tracks the current date.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the `rtc_time_config` function for configuring the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This function sets the time in the RTC peripheral. Much like the date configuration,
    `rtc_time_config` begins by initializing a temporary variable, `temp`, to hold
    the time value. The time components – format, hours, minutes, and seconds – are
    then combined into this variable. The `MODIFY_REG` macro updates the RTC’s time
    register with the newly constructed time value. Here, we have the following additional
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Format12_24`: This determines whether the time is in 12-hour or 24-hour format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hours`: Represents the hour value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minutes`: Represents the minute value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Seconds`: Represents the second value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we’ve implemented all the helper functions required for initialization,
    let’s go ahead and implement the `rtc_init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by enabling the clock for the PWR module. This is crucial as it allows
    us to access and configure the RTC peripheral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must enable access to the backup domain. This step is necessary to
    make changes to the RTC configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we enable the LSI oscillator, which serves as the clock source for the
    RTC peripheral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We must wait until the LSI oscillator is stable and ready to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure a clean configuration, we must force a reset of the backup domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must release the reset, allowing the backup domain to function normally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After, we must configure the RTC peripheral so that it uses the LSI oscillator
    as its clock source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must enable the RTC peripheral by setting the appropriate bit in the
    backup domain control register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow changes to the RTC registers, we must disable write protection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can enter initialization mode using our `rtc_init_seq()` helper function.
    If it fails, we must handle the error appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we must configure the RTC peripheral to the desired date using
    another one of our helper functions. In this example, we will set the date to
    *Friday, December* *29, 2016*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must set the RTC peripheral to the desired time. In this case, we
    will set the time to *11:59:55 P.M.*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must configure the RTC peripheral so that it uses a 24-hour format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must set the asynchronous and synchronous prescaler values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can exit initialization mode using the `exit_init_seq()`
    helper function we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we must re-enable write protection on the RTC registers to prevent
    accidental changes.
  prefs: []
  type: TYPE_NORMAL
- en: This `rtc_init` function meticulously sets up the RTC peripheral by enabling
    the necessary clock, configuring the backup domain, setting the RTC clock source,
    and initializing the date and time.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the `main.c` file, let’s implement a few helper functions
    that are essential for handling various RTC tasks, such as converting values and
    getting the current date and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the `rtc_convert_dec2bcd` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a decimal value and returns its equivalent in BCD format,
    which is useful for setting RTC values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at decimal to BCD conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: First, `((value) / 10U) << 4U` shifts the tens digit to the left by 4 bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, `((value) % 10U)` gets the units digit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OR` operation combines these two to form the BCD value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before going any further, let’s take a closer look at the BCD format and the
    conversion process.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding BCD format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'BCD is a way of representing decimal numbers in binary form. But here’s the
    twist: instead of converting the whole number into a single binary value, each
    decimal digit is represented by its own binary sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: How does BCD work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In BCD, each digit of a decimal number is encoded separately as a 4-bit binary
    number. Let’s break it down with an example to make it clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you have the decimal number *42*. In BCD, this would be represented as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*4* in decimal is *0100* in binary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*2* in decimal is *0010* in binary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, 42 in BCD is *0100 0010*. Notice how each decimal digit is converted into
    a 4-bit binary form and then combined to represent the entire number.
  prefs: []
  type: TYPE_NORMAL
- en: Why use BCD?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might be wondering, why not just use regular binary? Well, BCD has its
    perks, especially in digital systems that need to display numbers or interface
    with human-readable formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of conversion**: Converting between BCD and decimal is straightforward.
    Each 4-bit group corresponds directly to a decimal digit, making it easy to read
    and convert.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display compatibility**: Devices such as digital clocks, calculators, and
    other numeric displays often use BCD because it simplifies the process of converting
    binary values into a form that can be easily shown on a screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s see how this relates to RTCs.
  prefs: []
  type: TYPE_NORMAL
- en: BCD in RTC configurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with RTCs, BCD is particularly handy. The RTC hardware often uses
    BCD to store time and date values because it simplifies how these values can be
    displayed and manipulated. For instance, setting the time to *12:34:56* in BCD
    means we have the following representations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*12* is *0001 0010*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*34* is *0011 0100*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*56* is *0101 0110*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these pairs is easy to interpret and convert back into decimal for display
    or further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'BCD format is a clever way of encoding decimal numbers in a binary system.
    By handling each decimal digit separately, BCD simplifies many operations, especially
    when interfacing with human-readable displays or systems that require precise
    decimal representation. *Figure 15**.6* illustrates how BCD values can easily
    be mapped onto digital displays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7: Display with BCD format](img/B21914_15_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: Display with BCD format'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s analyze the `rtc_convert_bcd2dec` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a BCD value and returns its decimal equivalent, making it
    easier to work with RTC data in a decimal format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the BCD to decimal conversion for this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, `((value) & (uint8_t)0xF0U) >> (uint8_t)0x4U` extracts the tens digit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, `((value) & (uint8_t)0x0FU)` extracts the units digit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication and addition combine these to form the binary value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have a helper function for getting the day – that is, `rtc_date_get_day`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This function reads the RTC date register and returns the current day of the
    month.
  prefs: []
  type: TYPE_NORMAL
- en: We can read the day by using `READ_BIT(RTC->DR, (RTC_DR_DT | RTC_DR_DU))`, which
    reads the day tens and units bits.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting the result to the right positions the value correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a function for the year – that is, `rtc_date_get_year`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function reads the RTC date register and returns the current year.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `READ_BIT(RTC->DR, (RTC_DR_YT | RTC_DR_YU))` reads the year tens and units
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have functions for retrieving the month, second, minute, and hour,
    all of which are implemented using the same approach as the other getter functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have `rtc_date_get_month`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we have `rtc_time_get_second`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, there’s `rtc_time_get_minute`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, there’s `rtc_time_get_hour`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With all of these functions implemented, our `rtc.c` file is complete. Our next
    task is to populate the `rtc.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: The header file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re simply exposing the functions implemented in `rtc.c`, making them
    callable from other files. Let’s go ahead and test our driver’s `main.c` file.
  prefs: []
  type: TYPE_NORMAL
- en: The main file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s update the `main.c` file so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break down the unique aspects of the code, starting with the `display_rtc_calendar`
    function. This function retrieves the current time and date from the RTC peripheral,
    formats these values, prints them out, and stores them in a buffer for further
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are our buffer definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BUFF_LEN`: This defines the length of the buffer for storing the time and
    date string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time_buff`: This is an array that holds the formatted time string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date_buff`: This is an array that holds the formatted date string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the time formatting and display block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sprintf`: This is used to format the time string into `time_buff`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rtc_convert_bcd2dec`: This converts the BCD values from RTC into decimal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rtc_time_get_hour`, `rtc_time_get_minute`, and `rtc_time_get_second`: These
    retrieve the current hour, minute, and second from the RTC peripheral, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printf`: This function is used to print formatted output to the serial port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%.2d`: This format specifier means that the integer will be printed with at
    least 2 digits, padding with leading zeros if necessary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’re now ready to test our RTC calendar driver on the microcontroller. We
    can test the project by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile and upload the project to your microcontroller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch RealTerm or your preferred serial terminal program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the appropriate port and baud rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the time and date values printed and updating in real time,
    as shown in *Figure 15**.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.8: Expected results](img/B21914_15_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.8: Expected results'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the RTC peripheral, a component for timekeeping
    in embedded systems. This peripheral is essential for applications requiring precise
    time and date maintenance, making it fundamental for a wide range of embedded
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: We began by introducing RTCs and understanding their functionality. This included
    a deep dive into how RTCs operate, which involved focusing on the crystal oscillator,
    counters, time and date registers, and the importance of battery backup. We illustrated
    these concepts with case studies, showcasing the practical use of RTCs in data
    logging, alarm clocks, time-stamping transactions, and calendar functions.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we examined the STM32 RTC module, highlighting its key features
    and capabilities. We discussed the calendar in terms of sub-seconds accuracy,
    dual programmable alarms, low power consumption, backup domain, daylight saving
    time adjustments, automatic wakeup, tamper detection, digital calibration, and
    synchronization with external clocks. Each feature was detailed to show its application
    and importance in maintaining accurate timekeeping.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we analyzed the relevant registers from the STM32 reference manual, providing
    a detailed understanding of the configuration and operation of the RTC. We covered
    the `RTC_TR`, `RTC_DR`, `RTC_CR`, `RTC_ISR`, `RTC_PRER`, `RTC_ALRMAR`, `RTC_ALRMBR`,
    and `RTC_WUTR` registers. Each register’s role and key fields were explained to
    ensure you have a comprehensive grasp of how they contribute to the RTC’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we applied this knowledge to develop an RTC driver. We walked through
    the steps to create and configure the RTC driver, starting with the initialization
    sequence and covering functions to set the date and time. We also implemented
    helper functions for converting values between decimal and BCD formats, as well
    as retrieving current time and date values from the RTC peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into another useful peripheral, expanding
    our knowledge and toolkit for embedded systems development.
  prefs: []
  type: TYPE_NORMAL
