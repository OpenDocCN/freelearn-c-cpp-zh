- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: The Real-Time Clock (RTC)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时时钟（RTC）
- en: In this chapter, we will explore the **Real-Time Clock** (**RTC**) peripheral,
    an essential component for timekeeping in embedded systems. This peripheral is
    crucial for applications that require accurate time and date maintenance, making
    it fundamental for a wide range of embedded applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨实时时钟（RTC）外设，这是嵌入式系统中时间维护的关键组件。这个外设在需要精确时间和日期维护的应用中至关重要，对于广泛的嵌入式应用来说是基本的。
- en: We will start by introducing RTCs and understanding how they function. Following
    this, we will delve into the STM32 RTC module, examining its features and capabilities.
    Next, we will analyze the relevant registers from the STM32 reference manual,
    providing a detailed understanding of the configuration and operation of the RTC.
    Finally, we will apply this knowledge to develop an RTC driver, enabling precise
    timekeeping in your embedded projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍RTC及其工作原理。随后，我们将深入研究STM32 RTC模块，检查其特性和功能。接下来，我们将分析STM32参考手册中的相关寄存器，提供对RTC配置和操作的详细理解。最后，我们将应用这些知识来开发RTC驱动程序，使您能够在嵌入式项目中实现精确的时间维护。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding RTCs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解RTC
- en: The STM32 RTC module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32 RTC模块
- en: Some key RTC registers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些关键的RTC寄存器
- en: Developing the RTC driver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发RTC驱动程序
- en: By the end of this chapter, you will have a solid understanding of how RTCs
    work and will be equipped with the skills to develop bare-metal RTC drivers, allowing
    you to implement accurate timekeeping in your embedded systems projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对RTC的工作原理有一个扎实的理解，并具备开发裸机RTC驱动程序的能力，这将使您能够在嵌入式系统项目中实现精确的时间维护。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: Understanding RTCs
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解RTC
- en: In this section, we will enter the world of RTCs, understanding what they are
    and how they work before exploring common use cases through a few interesting
    case studies. Let’s get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进入RTC的世界，了解它们是什么以及它们是如何工作的，然后通过几个有趣的案例研究来探索常见的用例。让我们开始吧！
- en: RTCs are specialized hardware devices found in many microcontrollers and embedded
    systems. Their primary function is to keep track of the current time and date,
    even when the main power supply is turned off. Imagine them as the little timekeepers
    of the digital world, ensuring that the clock never stops ticking, no matter what.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'RTC是许多微控制器和嵌入式系统中发现的专用硬件设备。它们的主要功能是在主电源关闭时跟踪当前的时间和日期。想象一下，它们就像是数字世界中的小时间守护者，确保时钟无论发生什么都不会停止滴答。 '
- en: RTCs are crucial in applications where timekeeping is essential. This includes
    everything from simple alarm clocks to complex data logging systems, where accurate
    timestamps are necessary. An RTC continues to operate on a small battery when
    the main system is powered down, maintaining accurate time and date information.
    Let’s see how they work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: RTCs在需要精确时间维护的应用中至关重要。这包括从简单的闹钟到复杂的数据记录系统，在这些系统中，精确的时间戳是必要的。当主系统断电时，RTC会继续在小型电池上运行，保持准确的时间和日期信息。让我们看看它们是如何工作的。
- en: How do RTCs work?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTC是如何工作的？
- en: At the heart of an RTC is a crystal oscillator, which provides a stable clock
    signal. This oscillator typically runs at **32.768 kHz**, a frequency chosen because
    it is easily divisible by powers of two, making it convenient for binary counting.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: RTC的核心是一个晶振，它提供稳定的时钟信号。这个振荡器通常运行在**32.768 kHz**，这个频率之所以被选择，是因为它很容易被2的幂次整除，这使得它对二进制计数非常方便。
- en: 'Here’s a simplified breakdown of how an RTC works:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简化的RTC工作原理分解：
- en: '**Crystal oscillator**: The RTC contains a crystal oscillator that generates
    a precise clock signal.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**晶振**：RTC包含一个晶振，它产生精确的时钟信号。'
- en: '**Counter**: This clock signal drives a counter. The counter increments at
    a rate determined by the oscillator’s frequency.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器**：这个时钟信号驱动一个计数器。计数器以振荡器频率确定的速率递增。'
- en: '**Time and date registers**: The counter’s value is used to update time and
    date registers, which hold the current time (hours, minutes, seconds) and date
    (day, month, year).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间和日期寄存器**：计数器的值用于更新时间和日期寄存器，这些寄存器存储当前时间（小时、分钟、秒）和日期（日、月、年）。'
- en: '**Battery backup**: To ensure continuous operation, RTCs often have a battery
    backup. This keeps the oscillator running and the counter active even when the
    main power is off.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s consider some common use cases for RTCs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Common use cases for RTCs
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RTCs are incredibly versatile and are used in a wide variety of applications.
    Let’s explore some of the common use cases through a few case studies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Case study 1 – data logging
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the most common applications of RTCs is in data logging. Imagine that
    you’re designing a weather station that collects temperature, humidity, and pressure
    data. Accurate timestamps are crucial for analyzing trends and patterns over time.
    Here’s how an RTC plays a vital role in this scenario:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization**: The RTC is initialized and set to the current time and
    date'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data collection**: Every time a sensor reading is taken, the RTC provides
    a timestamp'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: The sensor data, along with the timestamp, is stored in memory'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analysis**: When the data is retrieved for analysis, the timestamps ensure
    that each reading can be accurately placed on a timeline'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the RTC ensures that every piece of data is accurately timestamped,
    making it possible to track changes and trends with precision.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Case study 2 – alarm clocks
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'RTCs are also fundamental in designing alarm clocks. Be it a simple bedside
    alarm clock or a complex scheduling system, the RTC provides the accurate timekeeping
    needed to trigger events at the right moment. Let’s look at a typical alarm clock
    scenario:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**Timekeeping**: The RTC keeps track of the current time, continuously updating
    the time registers.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alarm setting**: The user sets an alarm for a specific time. This information
    is stored in the RTC alarm registers.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alarm trigger**: When the RTC time matches the alarm time, an interrupt is
    triggered, activating the alarm mechanism (such as sounding a buzzer or turning
    on a light).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the RTC ensures that the alarm goes off at the precise time set
    by the user, making it an essential component for reliable time-based alerts.
    At this point, your next question might be, “*What’s so special* *about RTCs?*”
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Why are RTCs important?
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might be wondering why we can’t just use the system clock or general-purpose
    timers for timekeeping. The answer lies in the RTC’s ability to keep accurate
    time, even when the main system is powered down. Here are some key reasons why
    RTCs are indispensable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Accuracy**: RTCs use crystal oscillators, which provide highly accurate timekeeping'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low power consumption**: RTCs are designed to operate on very low power,
    often running for years on a small battery'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Battery backup**: RTCs continue to keep time even when the main power is
    off, thanks to their battery backup'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independence from the main system**: RTCs operate independently of the main
    microcontroller, ensuring continuous timekeeping'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding how RTCs work and their common use cases, we can appreciate
    their importance and effectively incorporate them into our embedded projects.
    Whether you’re building a simple alarm clock or a complex data logging system,
    the RTC is an important component that ensures your system always knows the right
    time. In the next section, we will explore the RTC peripheral in our STM32F411
    microcontroller.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解RTC的工作原理及其常见用例，我们可以欣赏它们的重要性，并有效地将它们纳入我们的嵌入式项目中。无论您是在构建一个简单的闹钟还是一个复杂的数据记录系统，RTC都是一个重要的组件，确保您的系统始终知道正确的时间。在下一节中，我们将探讨STM32F4微控制器中的RTC外设。
- en: The STM32 RTC module
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STM32 RTC模块
- en: In this section, we will explore the RTC module in the STM32F4 microcontroller
    family. Let’s start by looking at its features.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨STM32F4微控制器系列中的RTC模块。让我们首先看看它的功能。
- en: The main features of the STM32F4 RTC module
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STM32F4 RTC模块的主要功能
- en: 'The STM32F4 RTC module is like the Swiss Army knife of timekeeping, offering
    a rich set of features designed to meet the needs of numerous applications. Here
    are some of the standout features:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F4 RTC模块就像计时领域的瑞士军刀，提供了一组丰富的功能，旨在满足众多应用的需求。以下是一些突出的功能：
- en: '**Calendar with sub-seconds**: The RTC module doesn’t just keep track of hours,
    minutes, and seconds; it also maintains sub-second accuracy. This is particularly
    useful for applications that require precise time measurements.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有秒级的日历**：RTC模块不仅跟踪小时、分钟和秒，还保持秒级精度。这对于需要精确时间测量的应用特别有用。'
- en: '**Alarm functionality**: Imagine that you have two alarm clocks within your
    microcontroller. The STM32F4 RTC module provides two programmable alarms, **Alarm
    A** and **Alarm B**, which can trigger events at specific times. This is perfect
    for tasks that need to be performed at regular intervals or at a specific time
    of day.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闹钟功能**：想象一下，您在微控制器内部有两个闹钟。STM32F4 RTC模块提供了两个可编程的闹钟，**闹钟A**和**闹钟B**，可以在特定时间触发事件。这对于需要定期执行或在一天中的特定时间执行的任务来说非常完美。'
- en: '**Low power consumption**: One of the biggest advantages of the RTC module
    is its low power usage. This makes it ideal for battery-operated devices, where
    conserving power is paramount.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低功耗**：RTC模块最大的优点之一是其低功耗。这使得它非常适合电池供电的设备，在这些设备中，节省电力至关重要。'
- en: '**Backup domain**: The RTC can operate independently of the main power supply
    thanks to a backup battery. This means that even if your device loses power, the
    RTC keeps running, maintaining accurate time.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备份域**：RTC可以通过备用电池独立于主电源运行。这意味着即使您的设备断电，RTC也会继续运行，保持准确的时间。'
- en: '**Daylight saving time**: With the RTC module, you can program adjustments
    for daylight saving time automatically. No more manual resets twice a year!'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**夏令时**：使用RTC模块，您可以自动编程夏令时的调整。不再需要每年手动重置两次！'
- en: '**Automatic wakeup**: The RTC can generate periodic wakeup signals, bringing
    your system out of low-power modes at preset intervals. This feature is invaluable
    for applications that need to perform regular checks or updates.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动唤醒**：RTC可以生成周期性唤醒信号，在预设间隔将您的系统从低功耗模式唤醒。对于需要定期检查或更新的应用，这个特性非常有价值。'
- en: '**Tamper detection**: Security is a critical aspect of many applications, and
    the RTC module has you covered with tamper detection. It can log tamper events,
    providing an added layer of security for your system.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**篡改检测**：对于许多应用来说，安全性是一个关键方面，RTC模块通过篡改检测为您提供了保障。它可以记录篡改事件，为您的系统提供额外的安全层。'
- en: '**Digital calibration**: Accuracy is king when it comes to timekeeping. The
    RTC module includes a digital calibration feature to compensate for deviations
    in the crystal oscillator frequency, ensuring your timekeeping remains spot-on.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字校准**：在计时方面，精度是王道。RTC模块包括数字校准功能，以补偿晶振频率的偏差，确保您的计时保持精确无误。'
- en: '**Synchronization with external clocks**: To enhance precision, the RTC can
    synchronize with an external clock source. This is great for applications that
    need to maintain very high accuracy over long periods.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与外部时钟同步**：为了提高精度，RTC可以与外部时钟源同步。这对于需要长时间内保持非常高精度的应用来说非常棒。'
- en: Now, let’s analyze some of the key components of the STM32F4 RTC module.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析STM32F4 RTC模块的一些关键组件。
- en: The key components of the STM32F4 RTC module
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STM32F4 RTC模块的关键组件
- en: Let’s take a closer look at the key components of the RTC module in the STM32F4
    microcontroller family. We’ll break down each part to understand how they work
    together to provide accurate timekeeping and versatile functionality, starting
    with the clock sources.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Clock sources
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The driver of the RTC module is its clock sources. *Figure 15**.1* presents
    a detailed block diagram of the RTC module, highlighting the RTC clock sources.
    This diagram, sourced from the reference manual, provides a clear visual representation
    of the various components and their interactions within the RTC module:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1: RTC block diagram with clock sources highlighted](img/B21914_15_1.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: RTC block diagram with clock sources highlighted'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The STM32F4 RTC can use multiple clock sources:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '**Low-speed external (LSE)**: A 32.768 kHz crystal oscillator known for its
    stability and low power consumption. This is typically the preferred clock source
    for accurate timekeeping.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-speed internal (LSI)**: An internal RC oscillator that provides a less
    accurate but convenient option when an external crystal is not available.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-speed external (HSI)**: A high-speed clock source that can be used but
    is less common for RTC applications due to its higher power consumption.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The selected clock source feeds into the RTC’s prescalers, which are responsible
    for dividing the clock frequency into suitable levels for timekeeping:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2: RTC block diagram – asynchronous and synchronous prescalers](img/B21914_15_2.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: RTC block diagram – asynchronous and synchronous prescalers'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Prescalers
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RTC module employs two types of prescalers:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous prescaler**: This prescaler, typically set to divide by **128**,
    reduces the clock frequency to a lower rate that can be managed by the synchronous
    prescaler. It helps balance power consumption and accuracy.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronous prescaler**: Often configured to divide by **256**, this prescaler
    further reduces the clock frequency to generate a precise **1 Hz clock**, which
    is essential for updating the time and date registers accurately.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These prescalers ensure the RTC can operate efficiently, providing the necessary
    timekeeping precision while conserving power. Next, we have the time and date
    registers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Time and date registers
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 15**.3* highlights the time and date registers of the RTC block:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3: RTC block diagram – time and date registers](img/B21914_15_3.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: RTC block diagram – time and date registers'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'At the core of the RTC’s functionality are the time and date registers:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '**Time register (RTC_TR)**: This register holds the current time in hours,
    minutes, and seconds, stored in **Binary-Coded Decimal** (**BCD**) format. It
    is updated every second by the 1 Hz clock from the prescalers.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date register (RTC_DR)**: This register maintains the current date, including
    the year, month, and day, also in BCD format.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These registers are crucial for maintaining accurate time and date information,
    which can be read and adjusted as needed. The next key component is the RTC alarm.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Alarms
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RTC module features two programmable alarms, Alarm A and Alarm B. These
    alarms can be set to trigger at specific times, providing a powerful tool for
    scheduling tasks:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '`RTC_ALRMAR` and `RTC_ALRMBR`) to store the alarm time and date.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interrupts**: When an alarm is triggered, it can generate an interrupt, waking
    up the microcontroller from a low-power state or initiating a specific function.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The alarm modules are indicated in the following figure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4: RTC block diagram – alarms](img/B21914_15_4.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: RTC block diagram – alarms'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the wakeup timer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Wakeup timer
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another key feature of the RTC module is the wakeup timer, which is managed
    by the `RTC_WUTR` register:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5: RTC block diagram – wakeup timer](img/B21914_15_5.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: RTC block diagram – wakeup timer'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: This **16-bit** auto-reload timer can generate periodic wakeup events, bringing
    the system out of low-power modes at regular intervals. It’s ideal for tasks such
    as sensor readings or system checks, ensuring efficient power usage.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: There’s also the tamper detection module. Let’s take a look.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Tamper detection
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security is a vital aspect of many applications, and the RTC module includes
    tamper detection features. The tamper detection circuitry can log events when
    a tamper attempt is detected, using the timestamp registers to record the exact
    time and date. This adds an extra layer of security, especially in applications
    requiring reliable timekeeping and event logging. Next, we have the calibration
    register features.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Calibration and synchronization
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To maintain high accuracy, the RTC module includes calibration features:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '`RTC_CALR` register allows for fine adjustments to the clock frequency, compensating
    for any deviations in the crystal oscillator'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External clock synchronization**: The RTC can synchronize with an external
    clock source, enhancing accuracy by periodically adjusting the internal clock
    so that it matches the external reference'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features ensure the RTC maintains precise timekeeping, even in varying
    environmental conditions. We also have the backup and control registers module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Backup and control registers
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RTC module includes several backup and control registers:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Backup registers**: These registers store critical data that must be retained
    even when the main power supply is off'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_CR`) manage the configuration and operation of the RTC, including enabling
    the clock, setting alarms, and configuring wakeup events'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The backup and control registers module is indicated in the following figure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6: RTC block diagram – backup and control registers](img/B21914_15_6.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: RTC block diagram – backup and control registers'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is the output control block.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Output control
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The RTC module can output specific signals, such as a calibration clock or alarm
    outputs, through the `RTC_AF1` pin. This allows the RTC module to interact with
    other components or systems, providing synchronized signals or triggering external
    events.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will analyze some of the key registers for configuring
    the RTC peripheral.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Some key RTC registers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the characteristics and functions of some of
    the important registers within the RTC module. These registers are the building
    blocks that allow us to configure, control, and utilize the RTC’s features effectively.
    Let’s start with the `RTC_TR`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: RTC Time Register (RTC_TR)
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RTC_TR` register is responsible for keeping track of the current time.
    It maintains the hours, minutes, and seconds in BCD format, ensuring that time
    is easily readable and manipulable. Here are some of the key fields in this register:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**Hour tens (HT) and hour units (HU)**: These bits represent the tens and units
    of the hour, respectively. They can handle both **24-hour** and **12-hour** formats.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minute tens (MNT) and minute units (MNU)**: These bits represent the tens
    and units of the minutes.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second tens (ST) and second units (SU)**: These bits represent the tens and
    units of the seconds.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PM**: This bit indicates the **AM/PM** notation when in **12-hour** format.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further information about this register can be found on *page 450* of the *reference
    manual*. Let’s move on to the `RTC_DR`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: RTC Date Register (RTC_DR)
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RTC_DR` register is responsible for maintaining the current date. It keeps
    track of the year, month, day of the month, and day of the week, all in BCD format.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key fields in this register:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**Year tens (YT) and year units YU)**: These bits represent the tens and units
    of the year'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Month tens (MT) and month units (MU)**: These bits represent the tens and
    units of the month'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date tens (DT) and date units (DU)**: These bits represent the tens and units
    of the day of the month'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Week day units (WDU)**: This bit represents the day of the week (1 to 7)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about this register on *page 451* of the *reference manual*.
    The next crucial register is the `RTC_CR`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: RTC Control Register (RTC_CR)
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RTC_CR` register is where we control the various operational modes and
    features of the RTC. This register allows us to enable the RTC, configure alarms,
    and set up the wakeup timer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the key bits in this register:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**WUTE**: Enable the wakeup timer. This bit enables the RTC wakeup timer.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TSE**: Enable a timestamp event. This bit enables the timestamping of events.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ALRAE and ALRBE**: Enable Alarm A and Alarm B. These bits enable the respective
    alarms.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DCE**: Enable digital calibration. This bit enables digital calibration of
    the RTC clock.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FMT**: Hour format. This bit sets the hour format to either 24-hour or 12-hour
    (AM/PM).'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further details about this register can be found on *page 453* of the *reference
    manual*. Next, we have the `RTC_ISR`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: RTC Initialization and Status Register (RTC_ISR)
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RTC_ISR` register plays a dual role in both initializing the RTC and monitoring
    its status. This register is crucial during the setup process and for checking
    the RTC’s current state. Here are the key bits in this register:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**INIT**: Initialization mode. Setting this bit puts RTC into initialization
    mode.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RSF**: Registers synchronization flag. This bit indicates that the calendar
    registers are synchronized.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INITS**: Initialization status flag. This bit indicates whether the RTC calendar
    has been initialized.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ALRAF and ALRBF**: Alarm A and Alarm B flags. These bits indicate whether
    an alarm has been triggered.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the `RTC_PRER`).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: RTC Prescaler Register (RTC_PRER)
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RTC_PRER` register manages the prescalers that divide the RTC clock source
    to produce the 1 Hz clock necessary for accurate timekeeping. There are two key
    fields in this register:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**PREDIV_A**: Asynchronous prescaler. This field sets the value for the asynchronous
    prescaler.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PREDIV_S**: Synchronous prescaler. This field sets the value for the synchronous
    prescaler.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the `RTC_PRER` register properly is vital for maintaining the accuracy
    of the RTC.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the RTC Alarm Registers, `RTC_ALRMAR` and `RTC_ALRMBR`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: RTC Alarm Registers (RTC_ALRMAR and RTC_ALRMBR)
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These registers handle the configuration of Alarms A and B. They allow us to
    set specific times when the alarms should trigger. Here are the key fields in
    these registers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**ALRMASK**: Alarm mask bits. These bits allow you to mask certain parts of
    the alarm time, providing flexibility in how and when the alarms trigger.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ALRH, ALRMN, and ALRS**: Hour, minute, and second fields. These fields set
    the specific time for the alarm.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RTC_ALRMAR` and `RTC_ALRMBR` registers are vital for applications requiring
    reliable, time-based event triggering. Lastly, let’s explore the `RTC_WUTR`).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: RTC Wakeup Timer Register (RTC_WUTR)
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RTC_WUTR` register configures the wakeup timer, enabling the RTC to periodically
    wake the system from low-power modes. The key field in this register is the **wakeup
    auto-reload value** (**WUT**). This field sets the interval for the wakeup timer.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will apply everything we’ve learned in this section
    to develop a driver for the RTC peripheral.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Developing the RTC driver
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop the RTC calendar driver so that we can configure
    and keep track of the time and date.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: As always, we will create a copy of our previous project while following the
    steps outlined in earlier chapters. We rename this copied project to `RTC_Calendar`.
    Next, create a new file named `rtc.c` in the `Src` folder and another file named
    `rtc.h` in the `Inc` folder. The RTC configuration can be quite elaborate, so
    we will create several helper functions to modularize the initialization process.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The RTC implementation file
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin by populating the `rtc.c` file, starting with the helper functions
    necessary for the initialization function. Here are the macro definitions that
    we will use in the RTC configuration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break them down:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '`PWREN` (`1U << 28`): This macro enables the clock for the PWR module by setting
    bit 28 in the APB1 peripheral clock enable register.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CR_DBP` (`1U << 8`): This enables access to the backup domain by setting bit
    8 in the PWR register.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSR_LSION` (`1U << 0`): This macro enables the LSI oscillator by setting bit
    0 in the Clock Control & Status Register.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSR_LSIRDY` (`1U << 1`): This macro is used to read the state of the `LSI`
    register. The LSIRDY bit is set to 1 when the LSI is stable and ready to be used.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BDCR_BDRST` (`1U << 16`): This macro forces a reset of the backup domain by
    setting bit 16 in the Backup Domain Control Register.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BDCR_RTCEN` (`1U << 15`): This enables RTC by setting bit 15 in the Backup
    Domain Control Register.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_WRITE_PROTECTION_KEY_1` (`(uint8_t)0xCAU`): This key is used to disable
    write protection on the RTC registers.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_WRITE_PROTECTION_KEY_2` (`(uint8_t)0x53U`): This is the second key needed
    to disable write protection on the RTC registers.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_INIT_MASK` (`0xFFFFFFFFU`): This mask is used to enter initialization
    mode in the RTC peripheral.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISR_INITF` (`1U << 6`): This bit in the `ISR` register indicates that the
    RTC peripheral is in initialization mode.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WEEKDAY_FRIDAY` (`(uint8_t)0x05U`): This macro is used to configure the weekday
    of the calendar to Friday.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MONTH_DECEMBER` (`(uint8_t)0x12U`): This macro is used to configure the month
    of the calendar to December.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIME_FORMAT_PM` (`1U << 22`): This macro sets the time format to PM in the
    12-hour format.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CR_FMT` (`1U << 6`): This macro sets the hour format to 24-hour format in
    the RTC control register (`RTC->CR`).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISR_RSF` (`1U << 5`): This bit in the `ISR` register indicates that the RTC
    registers are synchronized.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_ASYNCH_PREDIV` (`(uint32_t)0x7F`): This value sets the asynchronous prescaler
    for the RTC peripheral and is used to divide the clock frequency.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_SYNCH_PREDIV` (`(uint32_t)0x00F9`): This value sets the synchronous prescaler
    for the RTC peripheral and is used to further divide the clock frequency for timekeeping
    accuracy.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s examine the two functions responsible for setting the prescaler values
    for the RTC peripheral.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have `rtc_set_asynch_prescaler`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function sets the asynchronous prescaler value for the RTC peripheral.
    Let’s break it down:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '`MODIFY_REG`: This macro modifies specific bits in a register. It is defined
    in the `stm32f4xx.h` header file.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC->PRER`: The `PRER` register of the RTC.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_PRER_PREDIV_A`: The mask for the asynchronous prescaler bits in the `PRER`
    register.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsynchPrescaler << RTC_PRER_PREDIV_A_Pos`: This snippet shifts the `AsynchPrescaler`
    value to the correct position within the `PRER` register.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In short, this function configures the asynchronous prescaler by updating the
    appropriate bits in the `PRER` register. Next, we have the function for setting
    the synchronous prescaler – that is, `rtc_set_synch_prescaler`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function configures the synchronous prescaler by updating the appropriate
    bits in the `PRER` register:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '`RTC->PRER`: The `PRER` register of the RTC'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_PRER_PREDIV_S`: This is the mask for the synchronous prescaler bits in
    the `PRER` register'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SynchPrescaler`: This directly sets the synchronous prescaler value in the
    `PRER` register'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we must analyze the other RTC initialization helper functions to understand
    how they work together to configure and synchronize the RTC peripheral.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the `_rtc_enable_init_mode` function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Simply put, this function sets the RTC peripheral to initialization mode by
    writing the initialization mask to the `ISR` register:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '`RTC->ISR`: This is the `RTC_ISR` register of the RTC'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RTC_INIT_MASK`: This mask is used to enter initialization mode'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have `_rtc_disable_init_mode`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function disables initialization mode by clearing the initialization mask
    in the ISR register. Here, `~RTC_INIT_MASK` clears the initialization mask, exiting
    initialization mode.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The next helper function is `_rtc_isActiveflag_init`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function returns 1 if the RTC peripheral is in initialization mode by checking
    the `ISR_INITF` bit, which indicates that the RTC peripheral is in initialization
    mode.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have `_rtc_isActiveflag_rs`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function returns 1 if the RTC registers are synchronized by checking the
    `ISR_RSF` bit, which indicates that the RTC registers are synchronized.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also the `rtc_init_seq` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function starts the RTC initialization by enabling initialization mode
    and waiting until the RTC peripheral enters initialization mode:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`_rtc_enable_init_mode`: This line puts the RTC peripheral into initialization
    mode'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_rtc_isActiveflag_init`: This line waits until the RTC peripheral is in initialization
    mode'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have the `wait_for_synchro` function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function clears the synchronization flag and waits until the RTC registers
    are synchronized.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have the `exit_init_seq` function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function exits the RTC initialization mode and waits for the registers
    to synchronize to ensure everything is set up correctly. Now, let’s see the functions
    for configuring the date and time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have `rtc_date_config`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function sets the date in the RTC peripheral.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by creating a temporary variable called `temp` to hold the date value.
    This variable is carefully constructed by shifting and combining the weekday,
    day, month, and year into the appropriate positions for the RTC’s date register.
    The `MODIFY_REG` macro is then used to update the RTC’s date register with this
    new value. Here, we can have the following values:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 `temp` 的临时变量来保存日期值。这个变量通过将星期几、日、月和年移位并组合到 RTC 日期寄存器的适当位置来仔细构建。然后使用
    `MODIFY_REG` 宏更新 RTC 的日期寄存器，使用这个新值。在这里，我们可以有以下值：
- en: '`WeekDay`: Represents the day of the week'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeekDay`：表示星期几'
- en: '`Day`: Represents the day of the month'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Day`：表示月份中的日'
- en: '`Month`: Represents the month of the year'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Month`：表示年份中的月'
- en: '`Year`: Represents the year'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Year`：表示年份'
- en: In essence, `rtc_date_config` takes the date components, assembles them into
    a single value, and writes it to the RTC’s date register, ensuring the RTC peripheral
    accurately tracks the current date.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`rtc_date_config` 将日期组件组合成一个单一值，并将其写入 RTC 的日期寄存器，确保 RTC 外设准确跟踪当前日期。
- en: 'We have the `rtc_time_config` function for configuring the time:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 `rtc_time_config` 函数用于配置时间：
- en: '[PRE11]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This function sets the time in the RTC peripheral. Much like the date configuration,
    `rtc_time_config` begins by initializing a temporary variable, `temp`, to hold
    the time value. The time components – format, hours, minutes, and seconds – are
    then combined into this variable. The `MODIFY_REG` macro updates the RTC’s time
    register with the newly constructed time value. Here, we have the following additional
    values:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数设置 RTC 外设中的时间。与日期配置类似，`rtc_time_config` 首先初始化一个临时变量 `temp` 来保存时间值。然后将时间组件——格式、小时、分钟和秒——组合到这个变量中。`MODIFY_REG`
    宏更新 RTC 的时间寄存器，使用新构造的时间值。在这里，我们还有以下额外的值：
- en: '`Format12_24`: This determines whether the time is in 12-hour or 24-hour format'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Format12_24`：这决定了时间是在 12 小时还是 24 小时格式'
- en: '`Hours`: Represents the hour value'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hours`：表示小时值'
- en: '`Minutes`: Represents the minute value'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Minutes`：表示分钟值'
- en: '`Seconds`: Represents the second value'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Seconds`：表示秒值'
- en: 'Now that we’ve implemented all the helper functions required for initialization,
    let’s go ahead and implement the `rtc_init()` function:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了初始化所需的全部辅助函数，让我们继续实现 `rtc_init()` 函数：
- en: '[PRE12]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s break it down:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '[PRE13]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We start by enabling the clock for the PWR module. This is crucial as it allows
    us to access and configure the RTC peripheral:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先启用 PWR 模块的时钟。这一点至关重要，因为它允许我们访问和配置 RTC 外设：
- en: '[PRE14]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we must enable access to the backup domain. This step is necessary to
    make changes to the RTC configuration:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须启用对备份域的访问。这一步是必要的，以便更改 RTC 配置：
- en: '[PRE15]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we enable the LSI oscillator, which serves as the clock source for the
    RTC peripheral:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启用 LSI 振荡器，它作为 RTC 外设的时钟源：
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We must wait until the LSI oscillator is stable and ready to use:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须等待直到 LSI 振荡器稳定并准备好使用：
- en: '[PRE17]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To ensure a clean configuration, we must force a reset of the backup domain:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保配置干净，我们必须强制备份域复位：
- en: '[PRE18]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we must release the reset, allowing the backup domain to function normally:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须释放复位，允许备份域正常工作：
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After, we must configure the RTC peripheral so that it uses the LSI oscillator
    as its clock source:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须配置 RTC 外设，使其使用 LSI 振荡器作为其时钟源：
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we must enable the RTC peripheral by setting the appropriate bit in the
    backup domain control register:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须通过设置备份域控制寄存器中的适当位来启用 RTC 外设：
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To allow changes to the RTC registers, we must disable write protection:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许更改 RTC 寄存器，我们必须禁用写保护：
- en: '[PRE22]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can enter initialization mode using our `rtc_init_seq()` helper function.
    If it fails, we must handle the error appropriately:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的 `rtc_init_seq()` 辅助函数进入初始化模式。如果它失败，我们必须适当地处理错误：
- en: '[PRE23]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, we must configure the RTC peripheral to the desired date using
    another one of our helper functions. In this example, we will set the date to
    *Friday, December* *29, 2016*:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们必须使用我们的另一个辅助函数将 RTC 外设配置为所需的日期。在这个例子中，我们将日期设置为 *2016 年 12 月 29 日星期五*：
- en: '[PRE24]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we must set the RTC peripheral to the desired time. In this case, we
    will set the time to *11:59:55 P.M.*:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将 RTC 外设设置为所需的日期。在这种情况下，我们将时间设置为 *晚上 11:59:55*：
- en: '[PRE25]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we must configure the RTC peripheral so that it uses a 24-hour format:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须配置 RTC 外设，使其使用 24 小时格式：
- en: '[PRE26]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we must set the asynchronous and synchronous prescaler values:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须设置异步和同步预分频器的值：
- en: '[PRE27]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At this point, we can exit initialization mode using the `exit_init_seq()`
    helper function we created earlier:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we must re-enable write protection on the RTC registers to prevent
    accidental changes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: This `rtc_init` function meticulously sets up the RTC peripheral by enabling
    the necessary clock, configuring the backup domain, setting the RTC clock source,
    and initializing the date and time.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the `main.c` file, let’s implement a few helper functions
    that are essential for handling various RTC tasks, such as converting values and
    getting the current date and time.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the `rtc_convert_dec2bcd` function:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function takes a decimal value and returns its equivalent in BCD format,
    which is useful for setting RTC values.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at decimal to BCD conversion:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: First, `((value) / 10U) << 4U` shifts the tens digit to the left by 4 bits
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, `((value) % 10U)` gets the units digit
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OR` operation combines these two to form the BCD value
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before going any further, let’s take a closer look at the BCD format and the
    conversion process.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Understanding BCD format
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'BCD is a way of representing decimal numbers in binary form. But here’s the
    twist: instead of converting the whole number into a single binary value, each
    decimal digit is represented by its own binary sequence.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: How does BCD work?
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In BCD, each digit of a decimal number is encoded separately as a 4-bit binary
    number. Let’s break it down with an example to make it clearer.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you have the decimal number *42*. In BCD, this would be represented as
    follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '*4* in decimal is *0100* in binary'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*2* in decimal is *0010* in binary'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, 42 in BCD is *0100 0010*. Notice how each decimal digit is converted into
    a 4-bit binary form and then combined to represent the entire number.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Why use BCD?
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might be wondering, why not just use regular binary? Well, BCD has its
    perks, especially in digital systems that need to display numbers or interface
    with human-readable formats:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of conversion**: Converting between BCD and decimal is straightforward.
    Each 4-bit group corresponds directly to a decimal digit, making it easy to read
    and convert.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display compatibility**: Devices such as digital clocks, calculators, and
    other numeric displays often use BCD because it simplifies the process of converting
    binary values into a form that can be easily shown on a screen.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s see how this relates to RTCs.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: BCD in RTC configurations
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with RTCs, BCD is particularly handy. The RTC hardware often uses
    BCD to store time and date values because it simplifies how these values can be
    displayed and manipulated. For instance, setting the time to *12:34:56* in BCD
    means we have the following representations:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '*12* is *0001 0010*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*34* is *0011 0100*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*56* is *0101 0110*'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these pairs is easy to interpret and convert back into decimal for display
    or further processing.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'BCD format is a clever way of encoding decimal numbers in a binary system.
    By handling each decimal digit separately, BCD simplifies many operations, especially
    when interfacing with human-readable displays or systems that require precise
    decimal representation. *Figure 15**.6* illustrates how BCD values can easily
    be mapped onto digital displays:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7: Display with BCD format](img/B21914_15_7.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: Display with BCD format'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s analyze the `rtc_convert_bcd2dec` function:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function takes a BCD value and returns its decimal equivalent, making it
    easier to work with RTC data in a decimal format.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the BCD to decimal conversion for this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: First, `((value) & (uint8_t)0xF0U) >> (uint8_t)0x4U` extracts the tens digit
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, `((value) & (uint8_t)0x0FU)` extracts the units digit
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication and addition combine these to form the binary value
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have a helper function for getting the day – that is, `rtc_date_get_day`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function reads the RTC date register and returns the current day of the
    month.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: We can read the day by using `READ_BIT(RTC->DR, (RTC_DR_DT | RTC_DR_DU))`, which
    reads the day tens and units bits.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Shifting the result to the right positions the value correctly.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a function for the year – that is, `rtc_date_get_year`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function reads the RTC date register and returns the current year.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Here, `READ_BIT(RTC->DR, (RTC_DR_YT | RTC_DR_YU))` reads the year tens and units
    bits.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have functions for retrieving the month, second, minute, and hour,
    all of which are implemented using the same approach as the other getter functions:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have `rtc_date_get_month`:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we have `rtc_time_get_second`:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, there’s `rtc_time_get_minute`:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, there’s `rtc_time_get_hour`:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With all of these functions implemented, our `rtc.c` file is complete. Our next
    task is to populate the `rtc.h` file.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: The header file
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we’re simply exposing the functions implemented in `rtc.c`, making them
    callable from other files. Let’s go ahead and test our driver’s `main.c` file.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: The main file
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s update the `main.c` file so that it looks like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let’s break down the unique aspects of the code, starting with the `display_rtc_calendar`
    function. This function retrieves the current time and date from the RTC peripheral,
    formats these values, prints them out, and stores them in a buffer for further
    processing.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are our buffer definitions:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we can see the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '`BUFF_LEN`: This defines the length of the buffer for storing the time and
    date string'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time_buff`: This is an array that holds the formatted time string'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date_buff`: This is an array that holds the formatted date string'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the time formatting and display block:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, we can see the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '`sprintf`: This is used to format the time string into `time_buff`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rtc_convert_bcd2dec`: This converts the BCD values from RTC into decimal'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rtc_time_get_hour`, `rtc_time_get_minute`, and `rtc_time_get_second`: These
    retrieve the current hour, minute, and second from the RTC peripheral, respectively'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rtc_time_get_hour`、`rtc_time_get_minute` 和 `rtc_time_get_second`：这些函数分别从 RTC
    外设检索当前小时、分钟和秒'
- en: '`printf`: This function is used to print formatted output to the serial port'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printf`：此函数用于将格式化输出打印到串行端口'
- en: '`%.2d`: This format specifier means that the integer will be printed with at
    least 2 digits, padding with leading zeros if necessary'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%.2d`：此格式说明符表示整数将以至少 2 位打印，如果需要则用前导零填充'
- en: 'We’re now ready to test our RTC calendar driver on the microcontroller. We
    can test the project by following these steps:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备在微控制器上测试我们的 RTC 日历驱动程序。我们可以通过以下步骤测试项目：
- en: Compile and upload the project to your microcontroller.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并将项目上传到您的微控制器。
- en: Launch RealTerm or your preferred serial terminal program.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 RealTerm 或您首选的串行终端程序。
- en: Configure the appropriate port and baud rate.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置适当的端口和波特率。
- en: 'You should see the time and date values printed and updating in real time,
    as shown in *Figure 15**.7*:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到时间和日期值实时打印并更新，如图 *图15**.7* 所示：
- en: '![Figure 15.8: Expected results](img/B21914_15_8.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8：预期结果](img/B21914_15_8.jpg)'
- en: 'Figure 15.8: Expected results'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8：预期结果
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the RTC peripheral, a component for timekeeping
    in embedded systems. This peripheral is essential for applications requiring precise
    time and date maintenance, making it fundamental for a wide range of embedded
    applications.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 RTC 外设，这是嵌入式系统中用于计时的组件。该外设对于需要精确时间和日期维护的应用至关重要，因此对于广泛的嵌入式应用来说是基本的。
- en: We began by introducing RTCs and understanding their functionality. This included
    a deep dive into how RTCs operate, which involved focusing on the crystal oscillator,
    counters, time and date registers, and the importance of battery backup. We illustrated
    these concepts with case studies, showcasing the practical use of RTCs in data
    logging, alarm clocks, time-stamping transactions, and calendar functions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了 RTC 并理解其功能。这包括深入了解 RTC 的工作原理，涉及关注晶振振荡器、计数器、时间和日期寄存器以及电池备份的重要性。我们通过案例研究说明了这些概念，展示了
    RTC 在数据记录、闹钟、时间戳交易和日历功能中的实际应用。
- en: Following this, we examined the STM32 RTC module, highlighting its key features
    and capabilities. We discussed the calendar in terms of sub-seconds accuracy,
    dual programmable alarms, low power consumption, backup domain, daylight saving
    time adjustments, automatic wakeup, tamper detection, digital calibration, and
    synchronization with external clocks. Each feature was detailed to show its application
    and importance in maintaining accurate timekeeping.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们检查了 STM32 RTC 模块，强调了其关键特性和功能。我们讨论了以亚秒精度为标准的日历，双可编程闹钟，低功耗，备份域，夏令时调整，自动唤醒，篡改检测，数字校准以及与外部时钟的同步。每个特性都进行了详细说明，以展示其在保持精确计时中的应用和重要性。
- en: Next, we analyzed the relevant registers from the STM32 reference manual, providing
    a detailed understanding of the configuration and operation of the RTC. We covered
    the `RTC_TR`, `RTC_DR`, `RTC_CR`, `RTC_ISR`, `RTC_PRER`, `RTC_ALRMAR`, `RTC_ALRMBR`,
    and `RTC_WUTR` registers. Each register’s role and key fields were explained to
    ensure you have a comprehensive grasp of how they contribute to the RTC’s functionality.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们分析了 STM32 参考手册中的相关寄存器，提供了对 RTC 配置和操作的详细理解。我们涵盖了 `RTC_TR`、`RTC_DR`、`RTC_CR`、`RTC_ISR`、`RTC_PRER`、`RTC_ALRMAR`、`RTC_ALRMBR`
    和 `RTC_WUTR` 寄存器。每个寄存器的角色和关键字段都得到了解释，以确保您全面了解它们如何有助于 RTC 的功能。
- en: Finally, we applied this knowledge to develop an RTC driver. We walked through
    the steps to create and configure the RTC driver, starting with the initialization
    sequence and covering functions to set the date and time. We also implemented
    helper functions for converting values between decimal and BCD formats, as well
    as retrieving current time and date values from the RTC peripheral.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这些知识应用于开发 RTC 驱动程序。我们介绍了创建和配置 RTC 驱动程序的步骤，从初始化序列开始，涵盖了设置日期和时间的函数。我们还实现了在十进制和
    BCD 格式之间转换值的辅助函数，以及从 RTC 外设检索当前时间和日期值。
- en: In the next chapter, we will delve into another useful peripheral, expanding
    our knowledge and toolkit for embedded systems development.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解另一个有用的外设，扩展我们的嵌入式系统开发知识和工具集。
