<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Integrating C++ and the Unreal Editor: Part I</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover following recipes:</p>
<ul>
<li><span>Using a class or struct as a  </span>B<span>lueprint variable</span></li>
<li><span><span>Creating classes or structs that can be subclassed in Blueprint</span></span></li>
<li><span><span>Creating functions that can be called in Blueprint</span></span></li>
<li>Creating events that can be implemented in Blueprint</li>
<li><span><span>Exposing multi-cast delegates to Blueprint</span></span></li>
<li><span><span>Creating C++ enums that can be used in Blueprint</span></span></li>
<li><span><span>Editing class properties in different places in the editor</span></span></li>
<li><span><span>Making properties accessible in the Blueprint editor graph</span></span></li>
<li>Responding to property changed events from the editor</li>
<li>Implementing a native code Construction Script</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>One of Unreal's primary strengths is that it provides programmers with the ability to create Actors and other objects that can be customized or used by designers in the editor. This chapter shows you how to do this. Following that, we will try to customize the editor by creating custom Blueprint and Animation nodes from scratch. We will also implement custom editor windows and custom <span class="packt_screen">Details</span> panels to inspect the Types that are created by users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and their requirements can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a class or struct as a blueprint variable</h1>
                </header>
            
            <article>
                
<p>Types that you declare in C++ do not automatically get incorporated into Blueprint for use as variables. This recipe shows you how to make them accessible so that you can use custom native code types as Blueprint function parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new class using the editor. Unlike previous chapters, we are going to create an <kbd>Object</kbd>-based class. <kbd>Object</kbd> isn't visible in the default list of common classes, so we need to tick the <span class="packt_screen">Show All Classes</span> button in the editor UI, then select <span class="packt_screen">Object</span>. Afterward, click on the <span class="packt_screen">Next</span> button:</li>
</ol>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/97bdcafe-9d31-4b14-a8e4-afda49cd46d7.png" style="width:51.83em;height:31.33em;"/></p>
<ol start="2">
<li>Name your new <span class="packt_screen">Object</span> subclass <kbd>TileType</kbd> and then click on the <span class="packt_screen">Create Class</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bb2c7553-314d-4c9a-af49-5814ac547b50.png"/></p>
<ol start="3">
<li>Add the following properties to the <kbd>TileType</kbd> definition:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_09_API UTileType : public UObject<br/>{<br/>    GENERATED_BODY()<br/><strong>public:</strong><br/><strong>    UPROPERTY()</strong><br/><strong>    int32 MovementCost;</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    bool CanBeBuiltOn;</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    FString TileName;</strong><br/>};</pre>
<ol start="4">
<li>Compile your code.</li>
<li>Inside the editor, create a new Blueprint class based on <kbd>Actor</kbd>. Call it <kbd>Tile</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3a50d41d-8514-4f0f-af7e-6129a0374c88.png" style="width:41.42em;height:33.67em;"/></p>
<p class="mce-root"/>
<ol start="6">
<li>Within the blueprint editor for <kbd>Tile</kbd>, add a new variable to Blueprint by going to the <span class="packt_screen">My Blueprint</span> section and moving down to the <span class="packt_screen">Variables</span> section and then hitting the <span class="packt_screen">+</span> button. The <span class="packt_screen">Details</span> panel on the right-hand side of the screen will then fill up with information about this new variable, including what type it is. Check the list of types that you can create as variables under the <span class="packt_screen">Variable Type</span> property, and verify that <kbd>TileType</kbd> is not there:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/930a3f71-eaba-4f0c-9416-39c8cd3f517c.png" style="width:34.42em;height:22.00em;"/></p>
<ol start="7">
<li>Return to Visual Studio and open up the <kbd>TileType.h</kbd> file. Add <kbd>BlueprintType</kbd> to the <kbd>UCLASS</kbd> macro, as follows:</li>
</ol>
<pre style="padding-left: 60px">UCLASS(<strong>BlueprintType</strong>)<br/>class CHAPTER_09_API UTileType : public UObject</pre>
<ol start="8">
<li>Save your script, return to the editor and recompile the project, then return to the <kbd>Tile</kbd> blueprint editor.</li>
</ol>
<ol start="9">
<li>Now, when you add a new variable to your actor, you can select <kbd>TileType</kbd> as the type for your new variable:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f84aea2a-98c2-4c81-8379-494983245449.png" style="width:43.67em;height:29.92em;"/></p>
<ol start="10">
<li>You can now change the <span class="packt_screen">Variable Name</span> to something better, such as <kbd>MyTileType</kbd>.</li>
</ol>
<p style="padding-left: 60px">We've now established a <em>has-a</em> relationship between <kbd>Tile</kbd> and <kbd>TileType</kbd>. Now, <kbd>TileType</kbd> is a Blueprint type that can be used as a function parameter.</p>
<ol start="11">
<li>To do this, go to the <span class="packt_screen">My Blueprint</span> section and scroll down to the <span class="packt_screen">Functions</span> section. From there, you can click on the + button to create a new function. Name this new function <kbd>SetTileType</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4f058424-18ef-43d7-8b36-2b7664febb9b.png"/></p>
<p class="mce-root"/>
<ol start="12">
<li>Once the function has been created, the <span class="packt_screen">Details</span> tab will display information about the function itself. Under the <span class="packt_screen">Inputs</span> section, click on the <span class="packt_screen">+</span> button to add a new input:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a885d752-02c3-406c-8f94-d267d00535c6.png"/></p>
<ol start="13">
<li>Once selected, you'll be able to give the variable a name and select the type from the dropdown that, by default, says <kbd>Boolean</kbd>. Set the input parameter's type to <kbd>TileType</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dca37210-53ef-4160-87e5-6439c6247fa8.png"/></p>
<p style="padding-left: 60px">Once you do this, you'll see that the parameter has been added as an input to the <span class="packt_screen">Set Tile Type</span> function in Blueprints:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6821f604-caf0-4c04-8074-0ae193b002ea.png" style="width:12.75em;height:8.58em;"/></p>
<ol start="14">
<li>Go back to the <span class="packt_screen">My Blueprint</span> section and drag and drop the <kbd>MyTileType</kbd> variable onto the <span class="packt_screen">Set Tile Type</span> graph, next to the first node. You can drag your <kbd>Type</kbd> variable into the viewport and select <span class="packt_screen">Set MyTileType</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3b1d3861-9389-4e2e-aea7-5d96da0a0e5b.png"/></p>
<ol start="15">
<li>Now that we have the two nodes we need, connect the <span class="packt_screen">Exec</span> output pin to the input of the <span class="packt_screen">Set MyTileType</span> node and then connect the parameter from <kbd>SetTileType</kbd> to the <span class="packt_screen">Set</span> node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/44e78dd9-47fe-4cc1-bd19-960caa91ba82.png" style="width:32.17em;height:11.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>For performance reasons, Unreal assumes that classes do not require the extra reflection code that is needed to make the type available to Blueprint.</p>
<p>We can override this default by specifying <kbd>BlueprintType</kbd> in our <kbd>UCLASS</kbd> macro.</p>
<p>With the specifier included, the type is now made available as a parameter or variable in Blueprint and can be used in all the same ways that default types can.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>This recipe shows that you can use a type as a function parameter in Blueprint if its native code declaration includes <kbd>BlueprintType</kbd>.</p>
<p>However, at the moment, none of the properties that we defined in C++ are accessible to Blueprint.</p>
<p>Other recipes in this chapter deal with making those properties accessible so that we can actually do something meaningful with our custom objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating classes or structs that can be subclassed in Blueprint</h1>
                </header>
            
            <article>
                
<p class="chapter-content">While this book focuses on C++, when developing with Unreal a more standard workflow is to implement core gameplay functionality as well as performance-critical code in C++, and expose those features to Blueprint to allow designers to prototype gameplay, which can then be refactored by programmers with additional Blueprint features, or pushed back down to the C++ layer. One of the most common tasks, then, is to <strong>mark up</strong> our classes and structs in such a way that they are visible to the Blueprint system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new C++ class derived from the <kbd>Actor</kbd> class using the editor wizard; name it <kbd>BaseEnemy</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ae20069a-adfb-4955-b837-b70770fa206b.png"/></p>
<ol start="2">
<li>Add the following <kbd>UPROPERTY</kbd> to the class:</li>
</ol>
<pre style="padding-left: 60px">UPROPERTY() 
FString WeaponName; <br/>UPROPERTY() 
int32 MaximumHealth;</pre>
<ol start="3">
<li>Add the following class specifier to the <kbd>UCLASS</kbd> macro:</li>
</ol>
<pre style="padding-left: 60px">UCLASS(Blueprintable)<br/>class CHAPTER_09_API ABaseEnemy : public AActor</pre>
<ol start="4">
<li>Save and then compile the script.</li>
<li>Open the editor and create a new blueprint class. Expand the <span class="packt_screen">All Classes</span> list to show all of the classes and select our <kbd>BaseEnemy</kbd> class as the parent. Afterward, click on the <span class="packt_screen">Select</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/21397387-9ab2-4a72-b976-7f2e71fc8f7b.png" style="width:38.50em;height:52.58em;"/></p>
<ol start="6">
<li>Name the new Blueprint <kbd>EnemyGoblin</kbd> and open it in the Blueprint editor.</li>
</ol>
<p>Note that the <kbd>UPROPERTY</kbd> macros we created earlier still aren't there because we haven't included the appropriate markup to make them visible to Blueprint.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The previous recipe demonstrated the use of <kbd>BlueprintType</kbd> as a class specifier. <kbd>BlueprintType</kbd> allows the type to be used as a type within the Blueprint editor (that is, it can be a variable or a function input/return value).</p>
<p>However, we may want to create blueprints based on our type (using inheritance) rather than composition (placing an instance of our type inside an <kbd>Actor</kbd>, for example).</p>
<p>This is why Epic provided <kbd>Blueprintable</kbd> as a class specifier. <kbd>Blueprintable</kbd> means a developer can mark a class as inheritable by Blueprint classes.</p>
<p>We have both <kbd>BlueprintType</kbd> and <kbd>Blueprintable</kbd> instead of a single combined specifier because sometimes you may only want to expose a partial functionality. For example, certain classes should be usable as variables, but performance reasons forbid creating them in Blueprint. In that instance, you would use <kbd>BlueprintType</kbd> rather than both specifiers.</p>
<p>On the other hand, perhaps we want to use the Blueprint editor to create new subclasses, but we don't want to pass object instances around inside the <kbd>Actor</kbd> blueprints. It is recommended you use <kbd>Blueprintable</kbd>, but omit <kbd>BlueprintType</kbd> in this case.</p>
<p>Like before, neither <kbd>Blueprintable</kbd> nor <kbd>BlueprintType</kbd> specify anything about the member functions or member variables contained inside our class. We'll make those available in later recipes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating functions that can be called in Blueprint</h1>
                </header>
            
            <article>
                
<p class="chapter-content">While marking classes as <kbd>BlueprintType</kbd> or <kbd>Blueprintable</kbd> allows us to pass instances of the class around in Blueprint, or to subclass the type with a Blueprint class, those specifiers don't actually say anything about member functions or variables, and whether they should be exposed to Blueprint. This recipe shows you how to mark a function so that it can be called within Blueprint graphs.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li><span>Create a new C++ class derived from the</span> <kbd>StaticMeshActor</kbd><span> class using the editor wizard; call it</span> <kbd>SlidingDoor</kbd>.</li>
<li>Add the following text that's in bold to the new class:</li>
</ol>
<pre style="padding-left: 60px">class CHAPTER_09_API ASlidingDoor : public AStaticMeshActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    ASlidingDoor();<br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/><strong>    UFUNCTION(BlueprintCallable, Category = Door)</strong><br/><strong>    void Open();</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    bool IsOpen;</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    FVector TargetLocation;</strong><br/>};</pre>
<ol start="3">
<li>Create the class implementation by adding the following text in bold to the <kbd>.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "SlidingDoor.h"<br/><strong>#include "ConstructorHelpers.h"</strong><br/><br/>// Sets default values<br/>ASlidingDoor::ASlidingDoor()<br/>{<br/>    // Set this actor to call Tick() every frame. You can turn<br/>    // this off to improve performance if you don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/>    <strong>auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<br/>    (TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));</strong><br/><br/><strong>    UStaticMeshComponent * SM = GetStaticMeshComponent();</strong><br/><br/><strong>    if (SM != nullptr)</strong><br/><strong>    {</strong><br/><strong>        if (MeshAsset.Object != nullptr)</strong><br/><strong>        {</strong><br/><strong>            SM-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>            SM-&gt;SetGenerateOverlapEvents(true);</strong><br/><strong>        }</strong><br/><br/><strong>        SM-&gt;SetMobility(EComponentMobility::Movable);</strong><br/><strong>        SM-&gt;SetWorldScale3D(FVector(0.3, 2, 3));</strong><br/><strong>    }</strong><br/><br/><strong>    SetActorEnableCollision(true);</strong><br/><br/><strong>    IsOpen = false;</strong><br/><strong>    PrimaryActorTick.bStartWithTickEnabled = true;</strong><br/>}<br/><br/>// Called when the game starts or when spawned<br/>void ASlidingDoor::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/>}<br/><br/>// Called every frame<br/>void ASlidingDoor::Tick(float DeltaTime)<br/>{<br/>    Super::Tick(DeltaTime);<br/><br/><strong>    if (IsOpen)</strong><br/><strong>    {</strong><br/><strong>        SetActorLocation(FMath::Lerp(GetActorLocation(),  </strong><br/><strong>                                     TargetLocation, 0.05));</strong><br/><strong>    }</strong><br/>}<br/><br/><strong>void ASlidingDoor::Open()</strong><br/><strong>{</strong><br/><strong>    TargetLocation = ActorToWorld().TransformPositionNoScale( </strong><br/><strong>                                                   FVector(0, 0, 200));</strong><br/><strong>    IsOpen = true;</strong><br/><strong>}</strong><br/><br/></pre>
<p class="mce-root"/>
<ol start="4">
<li>Compile your code and launch the editor.</li>
<li>Drag a copy of your door out into the level:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7f1a01da-e630-4133-93f7-0a7381a4b1fd.png"/></p>
<div class="packt_tip">An easy way to have objects <em>fall</em> to the ground is by using the End key with the object you want to drop selected. </div>
<ol start="6">
<li>Make sure you have your <kbd>SlidingDoor</kbd> <span>instance selected, then open the Level blueprint by going to <span class="packt_screen">Blueprints | Open Level Blueprint</span>. Right-click on the empty canvas and expand</span> <span class="packt_screen">Call function on Sliding </span> <span class="packt_screen">Door 1</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0b59687a-998c-4e30-99cb-1112f5ef746e.jpg" style="width:17.58em;height:19.58em;"/></p>
<ol start="7">
<li>Expand the <span class="packt_screen">Door</span> section and then select the <kbd>Open</kbd> function:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2e0152ed-e212-411e-a05f-a50e2c0c1a0c.jpg" style="width:17.17em;height:14.50em;"/></p>
<ol start="8">
<li>Link the execution pin (white arrow) from <span class="packt_screen">Event BeginPlay</span> to the white arrow on the <kbd>Open</kbd> node, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8d197815-24a8-4c76-a565-e4c8c4a06e09.png"/></p>
<p class="mce-root"/>
<ol start="9">
<li>Play your level and verify that the door moves up as expected when <kbd>Open</kbd> is invoked on your door instance:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e844796d-e944-4409-9136-09e03f95fa99.jpg" style="width:33.42em;height:22.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Within the declaration of the door, we create a new function for opening the door, a Boolean to track whether the door has been told to open, and a vector allowing us to precompute the target location of the door.</p>
<p>We also override the <kbd>Tick</kbd> actor function so that we can perform some behavior on every frame.</p>
<p>Within the constructor, we load in the cube mesh and scale it to represent our door.</p>
<p>We also set <kbd>IsOpen</kbd> to a known good value of <kbd>false</kbd> and enable actor ticking by using <kbd>bCanEverTick</kbd> and <kbd>bStartWithTickEnabled</kbd>.</p>
<p>These two Booleans control whether ticking can be enabled for this actor and if ticking starts in an enabled state, respectively.</p>
<p>Inside the <kbd>Open</kbd> function, we calculate the target location that's relative to the door's starting position.</p>
<p>We also change the <kbd>IsOpen</kbd> Boolean from <kbd>false</kbd> to <kbd>true</kbd>.</p>
<p>Now that the <kbd>IsOpen</kbd> Boolean is <kbd>true</kbd>, inside the <kbd>Tick</kbd> function, the door tries to move itself toward the target location using <kbd>SetActorLocation</kbd> and <kbd>Lerp</kbd> to interpolate between the current location and the destination.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><a href="cf821ef4-8a19-440c-805d-573748b76d5f.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Handling Events and Delegates</em>, has a number of recipes relating to the spawning of actors</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating events that can be implemented in Blueprints</h1>
                </header>
            
            <article>
                
<p class="mce-root">Another way that C++ can be more tightly integrated with Blueprint is through the creation of functions that can have Blueprint implementations in native code. This allows a programmer to specify an event and invoke it, without needing to know anything about the implementation. The class can then be subclassed in Blueprint, and another member of the production team can implement a handler for the event without ever having to go near a line of C++.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new <kbd>StaticMeshActor</kbd> class called <kbd>Spotter</kbd>. Remember to use the <span class="packt_screen">Show All Classes</span> button to select <kbd>StaticMeshActor</kbd> as the parent class.</li>
<li>Make sure that the following functions are defined and overridden in the class header:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Engine/StaticMeshActor.h"<br/>#include "Spotter.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_09_API ASpotter : public AStaticMeshActor<br/>{<br/>  GENERATED_BODY()<br/>  <br/><strong>public:</strong><br/><strong>    // Sets default values for this actor's properties</strong><br/><strong>    ASpotter();</strong><br/><br/><strong>    // Called every frame</strong><br/><strong>    virtual void Tick(float DeltaSeconds) override;</strong><br/><br/><strong>    UFUNCTION(BlueprintImplementableEvent)</strong><br/><strong>    void OnPlayerSpotted(APawn* Player);</strong><br/><br/>};</pre>
<ol start="3">
<li>In the implementation file (<kbd>Spotter.cpp</kbd>), update the code to the following:</li>
</ol>
<pre style="padding-left: 60px">#include "Spotter.h"<br/>#include "ConstructorHelpers.h"<br/>#include "DrawDebugHelpers.h"<br/><br/>// Sets default values<br/>ASpotter::ASpotter()<br/>{<br/>    // Set this actor to call Tick() every frame. You can<br/>    // turn this off to improve performance if<br/>    // you don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/>    // Set up visual aspect of the spotter<br/>    auto MeshAsset = <br/>    ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<br/>    (TEXT("StaticMesh'/Engine/BasicShapes/Cone.Cone'"));<br/>    <br/>    UStaticMeshComponent * SM = GetStaticMeshComponent();<br/><br/>    if (SM != nullptr)<br/>    {<br/>        if (MeshAsset.Object != nullptr)<br/>        {<br/>            SM-&gt;SetStaticMesh(MeshAsset.Object);<br/>            SM-&gt;SetGenerateOverlapEvents(true);<br/>        }<br/><br/>        SM-&gt;SetMobility(EComponentMobility::Movable);<br/>        SM-&gt;SetRelativeRotation(FRotator(90, 0, 0));<br/>    }<br/><br/>}<br/><br/>// Called every frame<br/>void ASpotter::Tick(float DeltaTime)<br/>{<br/>    Super::Tick(DeltaTime);<br/><br/>    auto EndLocation = GetActorLocation() + <br/>    ActorToWorld().TransformVector(FVector(0, 0, -200));<br/><br/>    // Check if there is an object in front of us<br/>    FHitResult HitResult;<br/>    GetWorld()-&gt;SweepSingleByChannel(HitResult,<br/>    GetActorLocation(), EndLocation, FQuat::Identity, <br/>    ECC_Camera, FCollisionShape::MakeSphere(25), <br/>    FCollisionQueryParams("Spot", true, this));<br/><br/>    APawn* SpottedPlayer = Cast&lt;APawn&gt;(HitResult.Actor.Get());<br/><br/>    // If there is call the OnPlayerSpotted function<br/>    if (SpottedPlayer != nullptr)<br/>    {<br/>        OnPlayerSpotted(SpottedPlayer);<br/>    }<br/><br/>    // Displays where we are checking for collision<br/>    DrawDebugLine(GetWorld(), GetActorLocation(), EndLocation, FColor::Red);<br/><br/>}</pre>
<ol start="5">
<li>Compile and start the editor. Find your <kbd>Spotter</kbd> class in <span class="packt_screen">Content Browser</span>, then left-click and drag a copy out into the game world.</li>
<li>When you play the level, you'll see the red line showing the trace that the <kbd>Actor</kbd> is performing:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9914c7d6-45da-4f8f-b9f5-1a67276f9a50.png" style="width:30.50em;height:19.58em;"/></p>
<ol start="7">
<li>However, nothing will happen if the player walks in front of it because we haven't implemented our <kbd>OnPlayerSpotted</kbd> event.</li>
<li>To implement this event, we need to create a blueprint subclass of our <kbd>Spotter</kbd>.</li>
<li>Right-click on <kbd>Spotter</kbd> in the <span class="packt_screen">Content Browser</span> and select <span class="packt_screen">Create Blueprint class based on Spotter</span>. Name the class <kbd>BPSpotter</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/75939870-ef59-44a6-b9fa-38b3e8635a19.png"/></p>
<div class="packt_figref">Creating a Blueprint class based on Spotter</div>
<ol start="10">
<li>Inside the Blueprint editor, click on the <span class="packt_screen">Override</span> button in the <span class="packt_screen">Functions</span> section of the <span class="packt_screen">My Blueprint</span> panel:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8f457866-8e37-4655-9abc-650ec2e5e8af.png" style="width:35.75em;height:24.92em;"/></p>
<ol start="11">
<li>Select <span class="packt_screen">On Player Spotted</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1e41605e-623d-40fb-844c-b47593bb12fe.png"/></p>
<ol start="12">
<li>To see the event, click on the E<span class="packt_screen">vent Graph</span> tab. Left-click it and drag it away from the white execution pin on our event. In the context menu that appears, select and add a <kbd>Print String</kbd> node so that it is linked to the event:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e38c3014-8e80-4e2a-9787-ceb994895a6e.png"/></p>
<ol start="13">
<li>Delete your previous Spotter object in the level and then drag and drop a <kbd>BPSpotter</kbd> in. Play the level again and verify that walking in front of the trace that the <kbd>BPSpotter</kbd> is using now prints a string to the screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/96f3cfec-578d-40bb-9af1-1e813185972f.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the constructor for our <kbd>Spotter</kbd> object, we load one of the basic primitives, a cone, into our Static Mesh Component as a visual representation.</p>
<p>We then rotate the cone so that it resembles a spotlight pointing to the <em>X</em> axis of the actor.</p>
<p>During the <kbd>Tick</kbd> function, we get the actor's location and then find a point 200 units away from the actor along its local <em>X</em> axis. We call the parent class implementation of <kbd>Tick</kbd> using <kbd>Super::</kbd> to ensure that any other tick functionality is preserved, despite our override.</p>
<p>We convert a local position into a world space position by first acquiring the Actor-to-World transform for the <kbd>Actor</kbd>, then using that to transform a vector specifying the position.</p>
<p>The transform is based on the orientation of the root component, which is the static mesh component that we rotated during the constructor.</p>
<p>As a result of that existing rotation, we need to rotate the vector we want to transform. Given that we want the vector to point out of what was the bottom of the cone, we want a distance along the negative up axis; that is, we want a vector of the form (0,0,-d), where <em>d</em> is the actual distance away.</p>
<p>Having calculated our end location for our trace, we actually perform the trace with the <kbd>SweepSingleByChannel</kbd> function.</p>
<p>Once the sweep is performed, we try to cast the resulting hit <kbd>Actor</kbd> into a pawn.</p>
<p>If the cast was successful, we invoke our Implementable Event of <kbd>OnPlayerSpotted</kbd>, and the user-defined Blueprint code executes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exposing multi-cast delegates to Blueprint</h1>
                </header>
            
            <article>
                
<p class="mce-root">Multi-cast delegates are a great way to broadcast an event to multiple objects that <strong>listen</strong> or <strong>subscribe</strong> to the event in question. They are particularly invaluable if you have a C++ module that generates events that potentially arbitrary Actors might want to be notified about. This recipe shows you how to create a multi-cast delegate in C++ that can notify a group of other Actors during runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new <kbd>StaticMeshActor</kbd> class called <kbd>King</kbd>. Add the following to the class header:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Engine/StaticMeshActor.h"<br/>#include "King.generated.h"<br/><br/><br/><strong>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnKingDeathSignature, AKing*, DeadKing);</strong><br/>UCLASS()<br/>class CHAPTER_09_API AKing : public AStaticMeshActor<br/>{<br/>  GENERATED_BODY()</pre>
<ol start="2">
<li>We also want to display something on the screen, so add a definition for a constructor:</li>
</ol>
<pre style="padding-left: 60px">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnKingDeathSignature, AKing*, DeadKing);<br/>UCLASS()<br/>class CHAPTER_09_API AKing : public AStaticMeshActor<br/>{<br/>    GENERATED_BODY()<br/><br/><strong>    // Sets default values for this actor's properties</strong><br/><strong>    AKing();</strong><br/>};</pre>
<ol start="3">
<li>Add a new <kbd>UFUNCTION</kbd> to the class:</li>
</ol>
<pre style="padding-left: 60px">UFUNCTION(BlueprintCallable, Category = King) 
void Die(); </pre>
<ol start="4">
<li>Add an instance of our multicast delegate to the class as well:</li>
</ol>
<pre style="padding-left: 60px">UPROPERTY(BlueprintAssignable) 
FOnKingDeathSignature OnKingDeath; </pre>
<ol start="5">
<li>Open the <kbd>King.cpp</kbd> file and then add in the implementation for the constructor to perform our mesh initialization (remembering to add an <kbd>#include</kbd> for the <kbd>ConstructionHelpers.h</kbd> file):</li>
</ol>
<pre style="padding-left: 60px">#include "King.h"<br/><strong>#include "ConstructorHelpers.h"</strong><br/><br/><strong>// Sets default values</strong><br/><strong>AKing::AKing()</strong><br/><strong>{</strong><br/><strong>    // Set this actor to call Tick() every frame. You can turn<br/>    // this off to improve performance if you don't need it.</strong><br/><strong>    PrimaryActorTick.bCanEverTick = true;</strong><br/><br/><strong>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<br/>    (TEXT("StaticMesh'/Engine/BasicShapes/Cone.Cone'"));</strong><br/><br/><strong>    UStaticMeshComponent * SM = GetStaticMeshComponent();</strong><br/><br/><strong>    if (SM != nullptr)</strong><br/><strong>    {</strong><br/><strong>        if (MeshAsset.Object != nullptr)</strong><br/><strong>        {</strong><br/><strong>            SM-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>            SM-&gt;SetGenerateOverlapEvents(true);</strong><br/><strong>        }</strong><br/><strong>        SM-&gt;SetMobility(EComponentMobility::Movable);</strong><br/><strong>    }</strong><br/><strong>}</strong></pre>
<ol start="6">
<li>Implement the <kbd>Die</kbd> function:</li>
</ol>
<pre style="padding-left: 60px"><span><span>void AKing :: Die () </span></span>
{ 
  OnKingDeath.Broadcast(this); 
} </pre>
<ol start="7">
<li>Create a new class called <kbd>Peasant</kbd>, also based on <kbd>StaticMeshActor</kbd>.</li>
<li>Declare a default constructor in the class:</li>
</ol>
<pre style="padding-left: 60px"><span><span>APeasant (); </span></span></pre>
<ol start="9">
<li>Declare the following function:</li>
</ol>
<pre style="padding-left: 60px">UFUNCTION(BlueprintCallable, category = Peasant) <span><span>
void Flee (AKing * DeadKing); </span></span></pre>
<ol start="10">
<li>Implement the constructor:</li>
</ol>
<pre style="padding-left: 60px">#include "Peasant.h"<br/>#include "ConstructorHelpers.h"<br/><br/>APeasant::APeasant()<br/>{<br/>  // Set this actor to call Tick() every frame. You can<br/>  // turn this off to improve performance if <br/>  // you don't need it.<br/>  PrimaryActorTick.bCanEverTick = true;<br/><br/>  auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<br/>  (TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));<br/><br/>  UStaticMeshComponent * SM = GetStaticMeshComponent();<br/><br/>  if (SM != nullptr)<br/>  {<br/>    if (MeshAsset.Object != nullptr)<br/>    {<br/>      SM-&gt;SetStaticMesh(MeshAsset.Object);<br/>      SM-&gt;SetGenerateOverlapEvents(true);<br/>    }<br/>    SM-&gt;SetMobility(EComponentMobility::Movable);<br/>  }<br/>}</pre>
<ol start="11">
<li>Implement the <kbd>Flee</kbd> function in the <kbd>.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">void APeasant::Flee(AKing* DeadKing)<br/>{<br/>    // Display message on the screen<br/>    GEngine-&gt;AddOnScreenDebugMessage(-1, 2, FColor::Red,<br/>        TEXT("Waily Waily!"));<br/><br/>    // Get the direction away from the dead king<br/>    FVector FleeVector = GetActorLocation() -<br/>        DeadKing-&gt;GetActorLocation();<br/><br/>    // Set the magnitude (length) of the vector to 1<br/>    FleeVector.Normalize();<br/><br/>    // Make the vector 500 times longer<br/>    FleeVector *= 500;<br/><br/>    // Set the Actor's new location<br/>    SetActorLocation(GetActorLocation() + FleeVector);<br/>}</pre>
<ol start="12">
<li>Return to the Unreal Editor and compile your scripts.</li>
</ol>
<ol start="13">
<li>Afterward, create a Blueprint class based on <kbd>APeasant</kbd>. You can do this by right-clicking on the <kbd>Peasant</kbd> object in the <span class="packt_screen">Content Browser</span> and then selecting <span class="packt_screen">Create Blueprint class based on Peasant</span>. Call the new <kbd>BPPeasant</kbd> class. Afterward, click on the <span class="packt_screen">Create Blueprint Class</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d90c146a-d40e-4b97-ad38-1b4c93c2a64f.png"/></p>
<ol start="14">
<li>Within the Blueprint, click on the <span class="packt_screen">Event Graph</span> tab and move upward to the <kbd>Event BeingPlay</kbd> node. Click and drag it away from the white (execution) pin of your <kbd>BeginPlay</kbd> node. Type <kbd>get all</kbd>, and you should see <span class="packt_screen">Get All Actors Of Class</span>. Select the node to place it in your graph:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/688d8fe5-46f8-4e55-9cbe-814a3c03422c.png"/></p>
<ol start="15">
<li>Set the value of the purple (class) node to <kbd>King</kbd>. You can type <kbd>king</kbd> in the search bar to make locating the class in the list easier:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/024b2403-c44e-4992-81d0-bf62b0f94269.png" style="width:40.83em;height:17.67em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="16">
<li>Drag the blue grid (object array) node out into an empty space and, from the <span class="packt_screen">Actions</span> menu that pops up, type in the word <kbd>get</kbd>. From the options that are available, select the <span class="packt_screen">Get (a copy)</span> option:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4775d89e-250e-4867-879a-5d17ae725240.png"/></p>
<ol start="17">
<li>Drag away from the blue output pin of the get node and place a Not Equal (object) node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f7621e45-e678-460c-a3e5-ef35d2d5ec16.png"/></p>
<ol start="18">
<li>Connect the red (bool) pin of the Not Equal node to a <kbd>Branch</kbd> node, and wire the execution pin of <kbd>Branch</kbd> to our <kbd>Get All Actors Of Class</kbd> node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/57bbbe4c-7469-4ed1-bd16-419682944815.png"/></p>
<ol start="19">
<li>Connect the <span class="packt_screen">True</span> pin of the branch to the <span class="packt_screen">Bind Event to OnKing Death</span> node:</li>
</ol>
<ol start="17"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/165a3781-c973-477d-b8d5-9f92363d1c15.png"/></p>
<div class="packt_infobox"><span>Note that you will probably have to untick </span><span class="packt_screen">Context Sensitive</span><span> in the context menu for the </span><span class="packt_screen">Bind Event</span><span> node to be visible.</span></div>
<ol start="20">
<li>Then, connect the output of the <span class="packt_screen">Get</span> node into the <span class="packt_screen">Target</span> property of the <span class="packt_screen">Bind Event to OnKingDeath</span> node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2b0c31ca-100d-40ba-8f2f-bd1ffbe4b584.png"/></p>
<div class="packt_figref">Connecting the <span> </span><span class="packt_screen">Get</span><span> node into the </span><span class="packt_screen">Target</span><span> property of the </span><span class="packt_screen">Bind Event to OnKingDeath</span><span> node</span></div>
<div class="packt_tip">If you double-click on a connection, you can create a reroute node that you can drag to<span> make it easier to see the connections between nodes.</span></div>
<ol start="21">
<li>Drag out the red pin of the <span class="packt_screen">Bind Event to OnKingDeath</span> node and select<span> </span><span class="packt_screen">Add Custom Event....</span> <span>Give your event the desired name:</span></li>
</ol>
<div class="packt_tip">You may need to uncheck the <span class="packt_screen">Context Sensitive</span> option to see the <span class="packt_screen">Add Custom Event...</span> option.</div>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bc779546-1339-4875-b6b8-2137e577236c.png"/></p>
<div class="packt_figref">Connecting the Custom Event and the Event Binding.</div>
<ol start="22">
<li>Connect the white execution pin for the <span class="packt_screen">Custom Event</span> to a new node named <kbd>Flee</kbd>, which we created back in Step 10:</li>
</ol>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f1f23155-2850-4057-8707-9a47724fd8bf.png"/></p>
<ol start="23">
<li>Lastly, drag the <span class="packt_screen">Dead King</span> property from the <span class="packt_screen">Custom Event</span> into the <kbd>Dead King</kbd> property of the <span class="packt_screen">Flee</span> node.</li>
</ol>
<ol start="24">
<li>Verify that your Blueprint looks like what's shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fb6eb322-517f-46c1-910c-d2f09ba30a3a.png"/></p>
<div class="packt_figref">The completed Blueprint</div>
<ol start="25">
<li>Drag a copy of your <kbd>King</kbd> class into the level, and then add a few <kbd>BPPeasant</kbd> instances around it in a circle:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/287e0110-9b2b-4353-8d05-18ad8101bde9.png"/></p>
<ol start="26">
<li>Open the level Blueprint. Inside it, drag away from <kbd>BeginPlay,</kbd> and add a <kbd>Delay</kbd> node. Set the delay to <span class="packt_screen">5</span> seconds:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b444ee3f-2178-437e-b940-8a63dd56fa2e.jpg" style="width:35.50em;height:12.00em;"/></p>
<ol start="27">
<li>With your <kbd>King</kbd> instance that's selected in the level, right-click in the graph editor for the Level Blueprint.</li>
<li>Select <span class="packt_screen">Call function on King 1</span> and look in the <kbd>King</kbd> category for a function called <kbd>Die</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/287aed93-e6e9-45a3-8ae2-517e3c05e79d.jpg" style="width:30.33em;height:22.42em;"/></p>
<ol start="29">
<li>Select <kbd>Die</kbd>, then connect its execution pin to the output execution pin from the delay:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/23c556e5-53bb-4ff5-8dd7-97bb10398bda.png"/></p>
<ol start="30">
<li>When you play your level, you should see that the king dies after 5 seconds:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b527406e-ae24-4ce9-87d5-1d06077f0ebe.png"/></p>
<p>Afterward, you should see <span>the peasants all wail and flee directly away from the </span>king:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9a1cc2a2-35c1-4201-8fb0-a09cb3f069fc.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We create a new actor (based on <kbd>StaticMeshActor</kbd> for convenience, as it saves us having to declare or create a Static Mesh component for the <kbd>Actor</kbd> visual representation).</p>
<p>We declare a dynamic multicast delegate using the <kbd>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</kbd> macro. Dynamic multicast delegates allow an arbitrary number of objects to subscribe (listen) and unsubscribe (stop listening) so that they will be notified when the delegate is broadcast.</p>
<p>The macro takes a number of arguments <span>– </span>the type name of the new delegate signature being created, the type of the signature's parameter, then the name of the signature's parameter.</p>
<p>We also add a function to <kbd>King</kbd> that will allow us to tell it to die. Because we want to expose the function to Blueprints for prototyping, we mark it as <kbd>BlueprintCallable</kbd>.</p>
<p>The <kbd>DECLARE_DYNAMIC_MULTICAST_DELEGATE</kbd> macro that we used earlier only declared a type; it didn't declare an instance of the delegate, so we do that now, referencing the type name that we provided earlier when invoking the macro.</p>
<p>Dynamic multicast delegates can be marked as <kbd>BlueprintAssignable</kbd> in their <kbd>UPROPERTY</kbd> declaration. This indicates to Unreal that the Blueprint system can dynamically assign events to the delegate that will be called when the delegate's <kbd>Broadcast</kbd> function is called.</p>
<p>As always, we assign a simple mesh to our <kbd>King</kbd> so that it has a visual representation in the game scene.</p>
<p>Within the <kbd>Die</kbd> function, we call <kbd>Broadcast</kbd> on our own delegate. We specified that the delegate would have a parameter that is a pointer to the king which died, so we pass this pointer as a parameter to the broadcast function.</p>
<div class="mce-root packt_infobox">If you want the king to be destroyed, rather than playing an animation or other effect when it dies, you need to change the delegate's declaration and pass in a different type. For example, you could use <kbd>FVector</kbd>, and simply pass in the location of the dead king directly so that the peasants could still flee appropriately.<br/>
<br/>
<span>Without this, you potentially could have a situation where the </span><kbd>King</kbd><span> pointer is valid when </span><kbd>Broadcast</kbd><span> is called, but the call to </span><kbd>Actor::Destroy()</kbd><span> invalidates it before your bound functions are executed.</span></div>
<p>Within our next <kbd>StaticMeshActor</kbd> subclass, called <kbd>Peasant</kbd>, we initialize the static mesh component as usual using a different shape from the one that we used for the <kbd>King</kbd>.</p>
<p>Inside the implementation of the peasant's <kbd>Flee</kbd> function, we simulate the peasants playing sound by printing a message on the screen.</p>
<p>We then calculate a vector to make the peasants flee by first finding a vector from the dead king to this peasant's location.</p>
<p>We normalize the vector to retrieve a unit vector (with a length of 1) pointing in the same direction.</p>
<p>Scaling the normalized vector and adding it to our current location calculates a position at a fixed distance, in the exact direction for the peasant to be fleeing directly away from the dead king.</p>
<p class="mce-root"/>
<p><kbd>SetActorLocation</kbd> is then used to actually teleport the peasants to that location.</p>
<div class="packt_infobox"><span>If you used a Character with an AI controller, you could have the </span><kbd>Peasant</kbd><span> pathfind to the target location rather than teleporting. Alternatively, you could use a </span><kbd>Lerp</kbd><span> function that's invoked during the peasant's </span><kbd>Tick</kbd><span> to make them slide smoothly rather than jump directly to the location.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>See <a href="eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Actors and Components</em>, for more extended discussions about Actors and Components. <a href="cf821ef4-8a19-440c-805d-573748b76d5f.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Handling Events and Delegates</em>, discusses events such as <kbd>Notify</kbd> and <kbd>ActorOverlap</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating C++ enums that can be used in Blueprint</h1>
                </header>
            
            <article>
                
<p class="mce-root">Enums are commonly used in C++ as flags or inputs to switch statements. However, what if you want to pass an <kbd>enum</kbd> value to or from C++ from a Blueprint? Alternatively, if you want to use a <kbd>switch</kbd> statement in Blueprint that uses an <kbd>enum</kbd> from C++, how do you let the Blueprint editor know that your <kbd>enum</kbd> should be accessible within the editor? This recipe shows you how to make enums visible in Blueprint.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new <kbd>StaticMeshActor</kbd> class called <kbd>Tree</kbd> using the editor.</li>
<li>Insert the following code above the class declaration:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Engine/StaticMeshActor.h"<br/>#include "Tree.generated.h"<br/><br/><strong>UENUM(BlueprintType)</strong><br/><strong>enum TreeType</strong><br/><strong>{</strong><br/><strong>    Tree_Poplar,</strong><br/><strong>    Tree_Spruce,</strong><br/><strong>    Tree_Eucalyptus,</strong><br/><strong>    Tree_Redwood</strong><br/><strong>};</strong><br/><br/>UCLASS()<br/>class CHAPTER_09_API ATree : public AStaticMeshActor<br/>{</pre>
<ol start="3">
<li>Add the following to the <kbd>Tree</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_09_API ATree : public AStaticMeshActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    // Sets default values for this actor's properties</strong><br/><strong>    ATree();</strong><br/><br/><strong>    UPROPERTY(BlueprintReadWrite)</strong><br/><strong>    TEnumAsByte&lt;TreeType&gt; Type;</strong><br/>};</pre>
<ol start="4">
<li>Add the following to the <kbd>Tree</kbd> constructor:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">#include "Tree.h"<br/><br/><strong>#include "ConstructorHelpers.h"</strong><br/><br/><strong>// Sets default values</strong><br/><strong>ATree::ATree()</strong><br/><strong>{</strong><br/><strong>    // Set this actor to call Tick() every frame. You can turn<br/>    // this off to improve performance if you don't need it.</strong><br/><strong>    PrimaryActorTick.bCanEverTick = true;</strong><br/><br/><strong>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<br/>    (TEXT("StaticMesh'/Engine/BasicShapes/Cylinder.Cylinder'"));</strong><br/><br/><strong>    UStaticMeshComponent * SM = GetStaticMeshComponent();</strong><br/><br/><strong>    if (SM != nullptr)</strong><br/><strong>    {</strong><br/><strong>        if (MeshAsset.Object != nullptr)</strong><br/><strong>        {</strong><br/><strong>            SM-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>            SM-&gt;SetGenerateOverlapEvents(true);</strong><br/><strong>        }</strong><br/><strong>        SM-&gt;SetMobility(EComponentMobility::Movable);</strong><br/><strong>    }</strong><br/><strong>}</strong><br/><br/></pre>
<ol start="5">
<li>Return to the Unreal Editor and compile your code.</li>
<li>Create a new Blueprint class called <kbd>MyTree</kbd>, based on <kbd>Tree</kbd>, by right-clicking on the Tree object and selecting <span class="packt_screen">Create Blueprint class based on Tree</span>. Once the menu comes up, click on the <span class="packt_screen">Create Blueprint Class</span> button.</li>
<li>Inside the blueprint editor for <kbd>MyTree</kbd>, click on the <span class="packt_screen">Construction Script</span> tab.</li>
<li>Right-click in the empty window and type <kbd>treetype</kbd>. There is a <span class="packt_screen">Get number of entries in TreeType</span> node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8a5f09a0-43b0-4d0e-852f-f28683ca8a5c.png" style="width:30.50em;height:18.33em;"/></p>
<ol start="9">
<li>Where and then connect its <span class="packt_screen">Return value</span> output pin to the <span class="packt_screen">Max</span> property of a new <span class="packt_screen">Random Integer</span> node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aa62d8f0-eac4-4978-903c-33be135516cc.png" style="width:36.67em;height:6.58em;"/></p>
<ol start="10">
<li>Connect the <span class="packt_screen">Return Value</span> output of the random integer to a <span class="packt_screen">ToByte (Integer)</span> node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e638984a-344d-4bcb-9d28-dc2bbdcfe361.png"/></p>
<ol start="11">
<li>In the <span class="packt_screen">Variables</span> section of the <span class="packt_screen">My Blueprint</span> panel, click on the <span class="packt_screen">+</span> button. From there, go to the <span class="packt_screen">Details</span> tab and set the <span class="packt_screen">Variable Type</span> to <kbd>Tree Type</kbd>. Afterward, set the <span class="packt_screen">Variable Name</span> to <kbd>RandomTree</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/43c68378-cfe8-4485-8e5f-1a654392ffb4.png"/></p>
<ol start="12">
<li>Drag the <span class="packt_screen">RandomTree</span> variable into the graph and select <span class="packt_screen">Set Random Tree</span> when you see a small context menu appear.</li>
<li>Connect the <span class="packt_screen">Return Value</span> output of the <kbd>ToByte</kbd> node to the input of the <span class="packt_screen">SET Type</span> node. You'll see an extra conversion node automatically appear.</li>
<li>Lastly, connect the execution pin of <span class="packt_screen">Construction Script</span> to the <span class="packt_screen">SET Type</span> node's execution pin. Your Blueprint should look as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/17bd491f-612b-4926-9485-76609cd128da.png" style="width:45.33em;height:18.08em;"/></p>
<ol start="15">
<li>To verify that the blueprint is correctly functioning and randomly assigning a type to our tree, we are going to add some nodes to the Event Graph.</li>
<li>Place a <kbd>Print String</kbd> node after the <span class="packt_screen">Event BeginPlay</span> event node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/155d1518-6a95-478b-89db-c434fbb4a3ea.png" style="width:33.92em;height:12.08em;"/></p>
<ol start="17">
<li>Place a <kbd>Format Text</kbd> node and connect its output to the input of the <kbd>Print String</kbd> node. A conversion node will be added for you:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/825ac029-d5de-496c-87fe-2f17a6ebcd72.png" style="width:37.67em;height:11.08em;"/></p>
<ol start="18">
<li>Inside the <kbd>Format Text</kbd> node, add <kbd>My Type is {0}!</kbd> to the <span class="packt_screen">Format</span> text box:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d1b858b3-6f18-4cba-a7c8-8d54f5137af8.png" style="width:39.83em;height:13.33em;"/></p>
<p style="padding-left: 60px">You should see that it adds a new parameter, <span class="packt_screen">0</span>, which we can now set.</p>
<ol start="19">
<li>Drag the <span class="packt_screen">RandomTree</span> variable from the <span class="packt_screen">Variables</span> section of the <span class="packt_screen">My Blueprint</span> window into the graph and select <span class="packt_screen">Get</span> from the menu:</li>
</ol>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/76fab5b0-2f7d-4c0e-a8d4-0ed39f776c22.png"/></p>
<ol start="20">
<li>Add an <span class="packt_screen">Enum to Name</span> node to the <kbd>Type</kbd> output pin:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d92b7665-d8ed-4b79-b03a-ad3b56eb5f9f.png" style="width:51.75em;height:24.42em;"/></p>
<ol start="21">
<li>The <span class="packt_screen">Format Text</span> node will not use a Name, so we will need to convert it into Text. Add a <span><span class="packt_screen">ToText (name)</span> </span>node to the <span class="packt_screen"><span>Enum to Name</span><span> </span></span>output pin.</li>
<li>Connect the <span class="packt_screen">Return Value</span> output of the <span>ToText (name)</span> node to the <span class="packt_screen">0</span> input pin on the <span class="packt_screen">Format Text</span> node. Your Event Graph should now look as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f79e30f9-f9b9-46cf-8784-a4a7e93d8c40.png"/></p>
<div class="packt_figref">The completed Blueprint graph</div>
<ol start="23">
<li>Compile your Blueprint and then return to the Unreal Editor.</li>
<li>Drag a few copies of your Blueprint into the level and hit <span class="packt_screen">Play</span>. You should see a number of trees printing information regarding their type, verifying that types are being randomly assigned by the Blueprint code that we created:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b1534f7b-f726-4577-92d5-380d72ddacf2.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As usual, we use <kbd>StaticMeshActor</kbd> as the base class for our <kbd>Actor</kbd> so that we can easily give it a visual representation in the level.</p>
<p>Enumerated types are exposed to the reflection system using the <kbd>UENUM</kbd> macro.</p>
<p>We mark the <kbd>enum</kbd> as Blueprint-available using the <kbd>BlueprintType</kbd> specifier.</p>
<p>The <kbd>enum</kbd> declaration is just the same as we would use in any other context.</p>
<p>Our <kbd>Tree</kbd> requires a <kbd>TreeType</kbd>. Because <em>tree has tree-type</em> is the relationship we want to embody, we include an instance of <kbd>TreeType</kbd> in our <kbd>Tree</kbd> class.</p>
<p>As usual, we need to use <kbd>UPROPERTY()</kbd> to make the member variable accessible to the reflection system.</p>
<p>We use the <kbd>BlueprintReadWrite</kbd> specifier to mark the property as having both get and set support within Blueprint.</p>
<p>Enumerated types require being wrapped in the <kbd>TEnumAsByte</kbd> template when used in <kbd>UPROPERTY</kbd>, so we declare an instance of <kbd>TEnumAsByte&lt;TreeType&gt;</kbd> as the Tree's <kbd>Type</kbd> variable.</p>
<p>The constructor changes for <kbd>Tree</kbd> are simply the standard load and initialize our static mesh component preamble that's used in other recipes.</p>
<p>We create a Blueprint that inherits from our <kbd>Tree</kbd> class so that we can demonstrate the Blueprint-accessibility of the <kbd>TreeType enum</kbd>.</p>
<p>To have the Blueprint assign a type to the tree at random when we create an instance, we need to use the <span class="packt_screen">Construction Script</span> Blueprint.</p>
<p>Within the <span class="packt_screen">Construction Script</span>, we calculate the number of entries in the <kbd>TreeType enum</kbd>.</p>
<p>We generate a random number and use that as an index in the <kbd>TreeType enum</kbd> type to retrieve a value to store as our <kbd>Type</kbd>.</p>
<p>The Random number node, however, returns integers. Enumerated types are treated as bytes in Blueprint, so we need to use a <kbd>ToByte</kbd> node, which can then be implicitly converted by Blueprint into an <kbd>enum</kbd> value.</p>
<p>Now that we have <span class="packt_screen">Construction Script</span> assigning a type to our tree instances as they are created, we need to display the tree's type at runtime.</p>
<p>We do so with the graph attached to the <kbd>BeginPlay</kbd> event within the Event Graph tab.</p>
<p>To display text on screen, we use a <kbd>Print String</kbd> node.</p>
<p>To perform string substitution and print our type out as a human-readable string, we use the <kbd>Format Text</kbd> node.</p>
<p>The <kbd>Format Text</kbd> node takes terms enclosed in curly braces and allows you to substitute other values for those terms by returning the final string.</p>
<p>To substitute our <kbd>Type</kbd> into the <kbd>Format Text</kbd> node, we need to convert our variable stores from the <kbd>enum</kbd> value into the actual name of the value.</p>
<p>We can do so by accessing our <kbd>Type</kbd> variable and then using the <kbd>Enum to Name</kbd> node.</p>
<p><kbd>Names</kbd>, or <kbd>FNames</kbd> in native code, are a type of variable that can be converted into strings by Blueprint so that we can connect our <kbd>Name</kbd> to the input on the <kbd>Format Text</kbd> node.</p>
<p>When we hit Play, the graph executes, retrieving the type of tree instances that have been placed in the level and printing the names to the screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Editing class properties in different places in the editor</h1>
                </header>
            
            <article>
                
<p class="mce-root">When developing with Unreal, it is common for programmers to implement properties on Actors or other objects in C++, and make them visible in the editor for designer use. However, sometimes, it makes sense to view a property, or make it editable, but only on the object's default state. Sometimes, the property should only be modifiable at runtime with the default specified in C++. Fortunately, there are some specifiers that can help us restrict when a property is available.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new <kbd>Actor</kbd> class in the editor called <kbd>PropertySpecifierActor</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1181d0a4-74a1-4ab3-ac08-773bf590a75a.png"/></p>
<ol start="2">
<li>Add the following property definitions to the class:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/>#include "PropertySpecifierActor.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_09_API APropertySpecifierActor : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    APropertySpecifierActor();<br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>    // Property Specifiers<br/>    UPROPERTY(EditDefaultsOnly)<br/>    bool EditDefaultsOnly;<br/><br/>    UPROPERTY(EditInstanceOnly)<br/>    bool EditInstanceOnly;<br/><br/>    UPROPERTY(EditAnywhere)<br/>    bool EditAnywhere;<br/><br/>    UPROPERTY(VisibleDefaultsOnly)<br/>    bool VisibleDefaultsOnly;<br/><br/>    UPROPERTY(VisibleInstanceOnly)<br/>    bool VisibleInstanceOnly;<br/><br/>    UPROPERTY(VisibleAnywhere)<br/>    bool VisibleAnywhere;<br/>};</pre>
<ol start="3">
<li>Perform a <span class="packt_screen">Save</span>, <span class="packt_screen">Compile</span> your code, and launch the editor.</li>
<li>Create a new blueprint based on the class.</li>
<li>Open the blueprint and look at the <span class="packt_screen">Class Defaults</span> section:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/04d585d0-842c-4de5-b9da-731758e27c2b.jpg" style="width:48.58em;height:11.25em;"/></p>
<ol start="6">
<li>Note which properties are editable and visible under the <span class="packt_screen">Property Specifier Actor</span> section:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1d639038-43e2-4ee8-abff-36f3ec2afa6b.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Location of the Property Specifier Actor</div>
<ol start="7">
<li>Place instances in the level and view their <span class="packt_screen">Details</span> panels:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/16d4fe8b-9f98-40b7-96de-36f7d1188c15.png"/></p>
<ol start="8">
<li>Note that a different set of properties is editable.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When specifying <kbd>UPROPERTY</kbd>, we can indicate where we want that value to be available inside the Unreal editor.</p>
<p><kbd>Visible*</kbd> prefixes indicate that the value is viewable in the <span class="packt_screen">Details</span> panel for the indicated object. The value won't be editable, however.</p>
<p>This doesn't mean that the variable is a <kbd>const</kbd> qualifier; however, native code can change the value, for instance.</p>
<p><kbd>Edit*</kbd> prefixes indicate that the property can be altered within the <span class="packt_screen">Details</span> panels inside the editor.</p>
<p><kbd>InstanceOnly</kbd> as a suffix indicates that the property will only be displayed in the <span class="packt_screen">Details</span> panels for instances of your class that have been placed into the game. They won't be visible in the <span class="packt_screen">Class Defaults</span> section of the Blueprint editor, for example.</p>
<p><kbd>DefaultsOnly</kbd> is the inverse of <kbd>InstanceOnly</kbd> <span>–</span> <kbd>UPROPERTY</kbd> will only display in the <span class="packt_screen">Class Defaults section</span>, and can't be viewed on individual instances within the level.</p>
<p>The suffix <kbd>Anywhere</kbd> is the combination of the two previous suffixes <span>– </span>the <kbd>UPROPERTY</kbd> will be visible in all the <span class="packt_screen">Details</span> panels that inspect either the object's defaults or a particular instance in the level.</p>
<div class="packt_infobox">As we mentioned previously, if you are interested in learning more about Property Specifiers, check out the following link: <a href="https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Properties/Specifiers">https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Properties/Specifiers</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>This recipe makes the property in question visible in the inspector, but doesn't allow the property to be referenced in the actual Blueprint Event Graph. See the following recipe for a description of how to make that possible.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making properties accessible in the Blueprint editor graph</h1>
                </header>
            
            <article>
                
<p class="mce-root">The specifiers we mentioned in the previous recipe are all well and good, but they only control the visibility of <kbd>UPROPERTY</kbd> in the <span class="packt_screen">Details</span> panel. By default, even with those specifiers used appropriately, <kbd>UPROPERTY</kbd> won't be viewable or accessible in the actual editor graph for use at <kbd>runtime.Other</kbd> specifiers, which can optionally be used in conjunction with the ones in the previous recipe so that you can interact with properties in the Event Graph.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol start="1">
<li>Create a new <kbd>Actor</kbd> class called <kbd>BlueprintPropertyActor</kbd> using the editor wizard:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/40067092-2b56-401c-8825-8bfea89f5019.png"/></p>
<ol start="2">
<li>Add the following <kbd>UPROPERTY</kbd> to the class using Visual Studio:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/>#include "BlueprintPropertyActor.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_09_API ABlueprintPropertyActor : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    ABlueprintPropertyActor();<br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/><strong>    UPROPERTY(BlueprintReadWrite, Category = Cookbook)</strong><br/><strong>    bool ReadWriteProperty;</strong><br/><br/><strong>    UPROPERTY(BlueprintReadOnly, Category = Cookbook)</strong><br/><strong>    bool ReadOnlyProperty;</strong><br/><br/>};</pre>
<ol start="3">
<li>Perform a <span class="packt_screen">Save</span>, <span class="packt_screen">Compile</span> your project, and start the editor.</li>
<li>Create a Blueprint class based on your <kbd>BlueprintPropertyActor</kbd> and open its graph.</li>
<li>From the <span class="packt_screen">My Blueprint</span> panel, click on the eye icon to the right of the <span class="packt_screen">Search</span> bar. From there, select <span class="packt_screen">Show Inherited Variables</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/04be7b53-3abc-4b96-91df-41feeef6a5b6.png"/></p>
<ol start="6">
<li>Verify that the properties are visible under the <span class="packt_screen">Cookbook</span> <span>category </span>in the <span class="packt_screen">Variables</span> section of the <span class="packt_screen">My Blueprint</span> panel:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bba20056-25a1-4ae7-90cf-639c18d06265.jpg" style="width:18.42em;height:23.58em;"/></p>
<ol start="7">
<li>Left-click and drag the <kbd>ReadWriteProperty</kbd> variable into the <span class="packt_screen">Event Graph</span>. Then select <span class="packt_screen">Get ReadWriteProperty</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5ba2bbaf-baa3-48ca-ab9c-c7c14d66d450.png"/></p>
<ol start="8">
<li>Repeat the previous step, but instead select <span class="packt_screen">Set ReadWriteProperty</span>.</li>
<li>Drag the <span class="packt_screen">ReadOnly</span> property into the graph and note that the <span class="packt_screen">SET</span> node is disabled:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b43adb75-6bdf-41e5-b6ec-2d103fb65f05.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>BlueprintReadWrite</kbd> as a <kbd>UPROPERTY</kbd> specifier indicates to the Unreal Header Tool that the property should have both <kbd>Get</kbd> and <kbd>Set</kbd> operations exposed for use in Blueprints.</p>
<p><kbd>BlueprintReadOnly</kbd> is, as the name implies, a specifier that only allows Blueprint to retrieve the value of the property; never set it.</p>
<p><kbd>BlueprintReadOnly</kbd> can be useful when a property is set by native code, but should be accessible within Blueprint.</p>
<p>It should be noted that <kbd>BlueprintReadWrite</kbd> and <kbd>BlueprintReadOnly</kbd> don't specify anything about the property being accessible in the <span class="packt_screen">Details</span> panels or the <span class="packt_screen">My Blueprint</span> section of the editor:<span> </span>these specifiers only control the generation of the getter/setter nodes for use in Blueprint graphs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Responding to property changed events from the editor</h1>
                </header>
            
            <article>
                
<p class="mce-root">When a designer changes the properties of an <kbd>Actor</kbd> placed in the level, it is often important to show any visual results of that change immediately rather than just when the level is simulated or played. When changes are made using the <span class="packt_screen">Details</span> panels, there's a special event that the editor emits called <kbd>PostEditChangeProperty</kbd>, which gives the class instance a chance to respond to the property being edited. This recipe shows you how to handle <kbd>PostEditChangeProperty</kbd> for immediate in-editor feedback.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new <kbd>Actor</kbd> called <kbd>PostEditChangePropertyActor</kbd> based on <kbd>StaticMeshActor</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/45976a36-1621-403c-973b-afa3c859cabe.png"/></p>
<ol start="2">
<li>Add the following <kbd>UPROPERTY</kbd> and function definition to the class:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_09_API APostEditChangePropertyActor : public <br/>AStaticMeshActor<br/>{<br/>    GENERATED_BODY()<br/><br/><strong>    // Sets default values for this actor's properties</strong><br/><strong>    APostEditChangePropertyActor();</strong><br/><br/><strong>    UPROPERTY(EditAnywhere)</strong><br/><strong>    bool ShowStaticMesh = true;</strong><br/><br/><strong>    virtual void PostEditChangeProperty(FPropertyChangedEvent&amp; <br/>                                        PropertyChangedEvent) override;</strong><br/>    <br/>};</pre>
<ol start="3">
<li>Create the class constructor by adding the following code to the <kbd>PostEditChangePropertyActor.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "PostEditChangePropertyActor.h"<br/><strong>#include "ConstructorHelpers.h"</strong><br/><br/><strong>APostEditChangePropertyActor::APostEditChangePropertyActor()</strong><br/><strong>{</strong><br/><strong>    // Set this actor to call Tick() every frame. You can turn<br/>    // this off to improve performance if you don't need it.</strong><br/><strong>    PrimaryActorTick.bCanEverTick = true;</strong><br/><br/><strong>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<br/>    (TEXT("StaticMesh'/Engine/BasicShapes/Cone.Cone'"));</strong><br/><br/><strong>    UStaticMeshComponent * SM = GetStaticMeshComponent();</strong><br/><br/><strong>    if (SM != nullptr)</strong><br/><strong>    {</strong><br/><strong>        if (MeshAsset.Object != nullptr)</strong><br/><strong>        {</strong><br/><strong>            SM-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>            SM-&gt;SetGenerateOverlapEvents(true);</strong><br/><strong>        }</strong><br/><strong>        SM-&gt;SetMobility(EComponentMobility::Movable);</strong><br/><strong>    }</strong><br/><strong>}</strong></pre>
<ol start="4">
<li>Implement <kbd>PostEditChangeProperty</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void APostEditChangePropertyActor::PostEditChangeProperty( FPropertyChangedEvent&amp; PropertyChangedEvent)<br/>{<br/>    // Check if property is valid<br/>    if (PropertyChangedEvent.Property != nullptr)<br/>    {<br/>        // Get the name of the changed property<br/>        const FName PropertyName( <br/>                            PropertyChangedEvent.Property-&gt;GetFName());<br/><br/>        // If the changed property is ShowStaticMesh then we<br/>        // will set the visibility of the actor<br/>        if (PropertyName == GET_MEMBER_NAME_CHECKED( <br/>                         APostEditChangePropertyActor, ShowStaticMesh))<br/>        {<br/>            UStaticMeshComponent * SM = GetStaticMeshComponent();<br/><br/>            if (SM != nullptr)<br/>            {<br/>                SM-&gt;SetVisibility(ShowStaticMesh);<br/>            }<br/>        }<br/>    }<br/><br/>    // Then call the parent version of this function<br/>    Super::PostEditChangeProperty(PropertyChangedEvent);<br/>}</pre>
<ol start="5">
<li>Compile your code and launch the editor.</li>
<li>Drag an instance of your class into the game world and verify that toggling the Boolean value for <kbd>ShowStaticMesh</kbd> toggles the visibility of the mesh in the editor viewport:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dba850f4-0119-4dac-85a7-e24f6a9e78f0.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The location of the <span class="packt_screen">Show Static Mesh</span> property</div>
<p>Then, if you ever toggle it off, you'll see the object disappear, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/340c8760-1eda-48ab-91fd-99f5034777b0.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We create a new <kbd>Actor</kbd> based on <kbd>StaticMeshActor</kbd> for easy access to a visual representation via the Static Mesh.</p>
<p><kbd>UPROPERTY</kbd> is added to give us a property to change, which causes <kbd>PostEditChangeProperty</kbd> events to be triggered.</p>
<p><kbd>PostEditChangeProperty</kbd> is a virtual function that's defined in <kbd>Actor</kbd>.</p>
<p>As a result, we override the function in our class.</p>
<p>Within our class constructor, we initialize our mesh as usual, and set the default state of our <kbd>bool</kbd> property to match the visibility of the component it controls.</p>
<p>Inside <kbd>PostEditChangeProperty</kbd>, we first check that the property is valid.</p>
<p>Assuming it is, we retrieve the name of the property using <kbd>GetFName()</kbd>.</p>
<p><kbd>FNames</kbd> are stored internally by the engine as a table of unique values.</p>
<p>Next, we need to use the <kbd>GET_MEMBER_NAME_CHECKED</kbd> macro. The macro takes a number of parameters.</p>
<p>The first one is the name of the class to check, while the second parameter is the property to check the class for.</p>
<p class="mce-root"/>
<p>The macro will, at compile-time, verify that the class contains the member specified by name.</p>
<p>We compare the class member name that the macro returns against the name that our property contains.</p>
<p>If they are the same, then we verify that our <kbd>StaticMeshComponent</kbd> is initialized correctly.</p>
<p>If it is, we set its visibility to match the value of our <kbd>ShowStaticMesh</kbd> Boolean.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a native code Construction Script</h1>
                </header>
            
            <article>
                
<p class="mce-root">Within Blueprint, a <span class="packt_screen">Construction Script</span> is an <span class="packt_screen">Event Graph</span> that runs any time a property is changed on the object it is attached to <span>– </span>whether it's being dragged in the editor viewport or changed via a direct entry in a <span class="packt_screen">Details</span> panel. Construction Scripts allow the object in question to <em>rebuild</em> itself based on its new location, for instance, or to change the components it contains based on user-selected options. When coding in C++ with Unreal Engine, the equivalent concept is the <kbd>OnConstruction</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new <kbd>Actor</kbd> called <kbd>OnConstructionActor</kbd> based on <kbd>StaticMeshActor</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e5a597b2-f38a-4fbf-9095-db45235e8c34.png" style="width:40.50em;height:16.58em;"/></p>
<p class="mce-root"/>
<ol start="2">
<li>Update the header file to the following: </li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Engine/StaticMeshActor.h"<br/>#include "OnConstructionActor.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_09_API AOnConstructionActor : public AStaticMeshActor<br/>{<br/>  GENERATED_BODY()<br/><br/><strong>public:</strong><br/><strong>    AOnConstructionActor();</strong><br/><br/><strong>    virtual void OnConstruction(const FTransform&amp; Transform) override;</strong><br/><br/><strong>    UPROPERTY(EditAnywhere)</strong><br/><strong>        bool ShowStaticMesh;</strong><br/>  <br/>};</pre>
<ol start="3">
<li>Go to the implementation file (<kbd>OnConstructionActor.cpp</kbd>) and implement the class constructor:</li>
</ol>
<pre style="padding-left: 60px">#include "OnConstructionActor.h"<br/><strong>#include "ConstructorHelpers.h"</strong><br/><br/><strong>AOnConstructionActor::AOnConstructionActor()</strong><br/><strong>{ </strong><br/><strong>    // Set this actor to call Tick() every frame. You can turn<br/>    // this off </strong><strong>to improve performance if you don't need it.</strong><br/><strong>    PrimaryActorTick.bCanEverTick = true;</strong><br/><br/><strong>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;( </strong><br/><strong>                  TEXT("StaticMesh'/Engine/BasicShapes/Cone.Cone'"));</strong><br/><br/><strong>    UStaticMeshComponent * SM = GetStaticMeshComponent();</strong><br/><br/><strong>    if (SM != nullptr)</strong><br/><strong>    {</strong><br/><strong>        if (MeshAsset.Object != nullptr)</strong><br/><strong>        {</strong><br/><strong>            SM-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>            SM-&gt;SetGenerateOverlapEvents(true);</strong><br/><strong>        }</strong><br/><strong>        SM-&gt;SetMobility(EComponentMobility::Movable);</strong><br/><strong>    }</strong><br/><br/><strong>    // Default value of property</strong><br/><strong>    ShowStaticMesh = true;</strong><br/><strong>}</strong></pre>
<ol start="4">
<li>Implement <kbd>OnConstruction</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void AOnConstructionActor::OnConstruction(const FTransform&amp; Transform) 
{ 
  GetStaticMeshComponent()-&gt;SetVisibility(ShowStaticMesh); 
} </pre>
<ol start="5">
<li>Compile your code and launch the editor.</li>
<li>Drag an instance of your class into the game world, and verify that toggling the Boolean value for <kbd>ShowStaticMesh</kbd> toggles the visibility of the mesh in the editor viewport:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0e5c8d54-687b-45bc-adb7-19163d4c24b0.png"/></p>
<ol start="7">
<li><kbd>OnConstruction</kbd> does not currently run for C++ actors that are placed in a level if they are moved.</li>
<li>To test this, place a breakpoint in your <kbd>OnConstruction</kbd> function, and then move your actor around the level.</li>
</ol>
<div class="packt_tip"><span>To place a breakpoint, place your cursor on the desired line and hit </span><em><span class="KeyPACKT">F9</span></em><span> in Visual Studio.</span></div>
<ol start="9">
<li>You'll notice that the function doesn't get called, but if you toggle the <kbd>ShowStaticMesh</kbd> Boolean, it does, causing your breakpoint to trigger.</li>
</ol>
<div class="packt_infobox"><span>To see why, take a look at the beginning of the </span><kbd>AActor::PostEditMove</kbd><span> function: </span></div>
<pre style="padding-left: 60px">void AActor::PostEditMove(bool bFinished)<br/>{<br/>    if ( ReregisterComponentsWhenModified() &amp;&amp; !FLevelUtils::IsMovingLevel())<br/>    {<br/>        UBlueprint* Blueprint = Cast&lt;UBlueprint&gt;(GetClass()-&gt;ClassGeneratedBy);<br/>        if (bFinished || bRunConstructionScriptOnDrag || (Blueprint &amp;&amp; Blueprint-&gt;bRunConstructionScriptOnDrag))<br/>        {<br/>            FNavigationLockContext NavLock(GetWorld(), ENavigationLockReason::AllowUnregister);<br/>            RerunConstructionScripts();<br/>        }<br/>    }<br/><br/>    // .... </pre>
<div class="packt_infobox"><span><br/></span><span>The top line here casts <kbd>UClass</kbd> for the current object to <kbd>UBlueprint</kbd>, and will only run the construction scripts and <kbd>OnConstruction</kbd> again if the class is a Blueprint.<br/>
<br/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We create a new Actor based on <kbd>StaticMeshActor</kbd> for easy access to a visual representation via the Static Mesh.</p>
<p><kbd>UPROPERTY</kbd> is added to give us a property to change, which causes <kbd>PostEditChangeProperty</kbd> events to be triggered.</p>
<p><kbd>OnConstruction</kbd> is a virtual function that's defined in Actor.</p>
<p>As a result, we override the function in our class.</p>
<p>Within our class constructor, we initialize our mesh as usual, and set the default state of our <kbd>bool</kbd> property to match the visibility of the component that it controls.</p>
<p>Inside <kbd>OnConstruction</kbd>, the actor rebuilds itself using any properties that are required to do so.</p>
<p>For this simple example, we set the visibility of the mesh to match the value of our <kbd>ShowStaticMesh</kbd> property.</p>
<p>This could also be extended to changing other values based on the value of the <kbd>ShowStaticMesh</kbd> variable.</p>
<p>You'll note that we don't explicitly filter on a particular property being changed, like the previous recipe does with <kbd>PostEditChangeProperty</kbd>.</p>
<p>The <kbd>OnConstruction</kbd> script runs in its entirety for every property that gets changed on the object.</p>
<p>It has no way of testing which property was just edited, so you need to be judicious about placing computationally intensive code within it.</p>


            </article>

            
        </section>
    </body></html>