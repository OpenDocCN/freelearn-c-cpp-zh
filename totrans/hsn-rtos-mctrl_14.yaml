- en: Drivers and ISRs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting with the peripherals of a **microcontroller unit** (**MCU**) is
    extremely important in many applications. In this chapter, we'll discuss several
    different ways of implementing peripheral drivers. Up to this point, we've been
    using blinking LEDs as a means of interacting with our development board. This
    is about to change. As we seek to gain a deeper understanding of peripheral drivers,
    we'll start to focus on different ways of implementing a driver for a common communication
    peripheral—the **u****niversal asynchronous receiver/transmitter** (**UART**).
    As we transfer data from one UART to another, we'll uncover the important role
    that peripheral and **direct memory access** (**DMA**) hardware plays when creating
    efficient driver implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by exploring a UART peripheral by implementing an extremely simple
    polled receive-only driver inside a task. After taking a look at the performance
    of that driver, we'll take a close look at **interrupt service routines** (**ISRs**)
    and the different ways they can interact with the RTOS kernel. The driver will
    be re-implemented using interrupts. After that, we'll add in support for a DMA-based
    driver. Finally, we'll explore a few different approaches to how the drivers can
    interact with the rest of the system and take a look at a newer FreeRTOS feature—stream
    buffers. Throughout this chapter, we'll keep a close eye on overall system performance
    using SystemView. By the end, you should have a solid understanding of the trade-offs
    to be made when writing drivers that can take advantage of RTOS features to aid
    usability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the UART
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a polled UART driver
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiating between tasks and ISRs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ISR-based drivers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating DMA-based drivers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FreeRTOS stream buffers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a driver model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using third-party libraries (STM HAL)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the exercises in this chapter, you will require the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A Nucleo F767 dev board
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires—20 to 22 AWG (~0.65 mm) solid core wire
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Micro-USB cable
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STM32CubeIDE and source code (instructions in the *Setting up Our IDE* section
    in [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml), *Selecting an IDE*)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SEGGER J-Link, Ozone, and SystemView (instructions in [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),
    *Debugging Tools for Real-Time Systems*)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All source code used in this chapter is available at [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_10](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_10).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the UART
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we briefly covered in [Chapter 4](c52d7cdb-b6cb-41e8-8d75-72494bc9d4d3.xhtml), *Selecting
    the Right MCU*, the acronym **UART** stands for **Universal Asynchronous Receiver/Transmitter**. UART
    hardware takes bytes of data and transmits them over a wire by modulating the
    voltage of a signal line at a predetermined rate:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc5fb57b-0534-4d40-b752-ae02f2483362.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: The **asynchronous** nature of a UART means no additional clock line is needed
    to monitor individual bit transitions. Instead, the hardware is set up to transition
    each bit at a specific frequency (baud rate). The UART hardware also adds some
    extra framing to the beginning and end of each packet it transmits. Start and
    stop bits signal the beginning and end of a packet. These bits (along with an
    optional parity bit) are used by the hardware to help guarantee the validity of
    packets (which are typically 8 bits long).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: A more general form of UART hardware is the **USART** **universal synchronous/asynchronous
    receiver transmitter** (**USART**). USARTs are capable of transferring data either
    synchronously (with the addition of a clock signal) or asynchronously (without
    a clock signal).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: UARTs are often used to communicate between different chips and systems. They
    form the foundation of many different communication solutions, such as RS232,
    RS422, RS485, Modbus, and so on. UARTs can also be used for multi-processor communication
    and to communicate with different chips in the same system—for example, WiFi and
    Bluetooth transceivers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be developing a few iterations of a UART driver. In
    order to be able to observe system behavior, we''ll be tying two UARTs on the
    Nucleo development board together, as in the following diagram. The two connections
    in the diagram will tie the transmit signal from UART4 to the receive signal of
    USART2\. Likewise, they''ll tie USART2 Tx to UART4 Rx. This will allow bidirectional
    communication between the UARTs. The connections should be made with pre-terminated
    **jumper wires** or 20-22 AWG (~0.65 mm) solid core wires:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b44a7da-7e56-4f6a-8bd2-ed54043bb1fb.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: Now that the connections are made, let's take a closer look at what else needs
    to happen before we can consider transferring data between peripherals on this
    chip.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the UART
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we can see from the following simplified block diagram, there are a few
    components involved when setting up a UART for communication. The UART needs to
    be properly configured to transmit at the correct baud rate, parity settings,
    flow control, and stop bits. Other hardware that interacts with the UART will
    also need to be configured properly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/316246b5-dc2a-4957-abd5-c2795961bf83.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a list of steps that will need to be taken to get UART4 set up. Although
    we''re using UART4 as an example, the same steps will apply to most other peripherals
    that attach to pins of the MCU:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the GPIO lines. Since each GPIO pin on the MCU can be shared with
    many different peripherals, they must be configured to connect to the desired
    peripheral (in this case, the UART). In this example, we''ll cover the steps to
    connect PC10 and PC11 to UART4 signals:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can read more about the pinout of the STM32F7xx series MCUs in *Section
    3, Pinouts and Pin Description*, of STM''s STM32F767xx datasheet *DoCID 029041*. Datasheets
    will typically contain information specific to exact models of MCUs, while reference
    manuals will contain general information about an entire family of MCUs. The following
    excerpt is of a table is from the datasheet and shows alternate function pin mappings:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbd883b1-430b-4c99-84bd-5e5203a066a5.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: Reference the desired port and bit. (In this case, we'll be setting up port
    `C` bit `11` to map to the `UART4_Rx` function).
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the desired alternate function for the pin (`UART4_Rx`).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the alternate function number (`AF8`) to use when configuring the GPIO
    registers.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the appropriate GPIO registers to correctly configure the hardware and
    map the desired UART peripheral to the physical pins.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An STM-supplied `HAL` function is used here for simplicity. The appropriate
    GPIO registers will by written when `HAL_GPIO_Init` is called.  All we need to
    do is fill in a `GPIO_InitTypeDef` struct and pass a reference to `HAL_GPIO_Init`;
    in the following code, the `10` GPIO pin and the `11` GPIO pin on port `C` are
    both initialized to alternative push/pull functions. They are also mapped to `UART4`
    by setting the alternate function member to `AF8`—as determined in step 4:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Enable the necessary peripheral clocks. Since each peripheral clock is turned
    off by default (for power saving), the UART''s peripheral clock must be turned
    on by writing to the **reset and clock control** (**RCC**) register. The following
    line is also from `HAL`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Configure the interrupts (if using them) by configuring settings in the **nested
    vector interrupt controller** (**NVIC**)—details will be included in the examples
    where appropriate.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the DMA (if using it)—details will be included in the examples where
    appropriate.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the peripheral with the necessary settings, such as baud rate, parity,
    flow control, and so on.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code is an excerpt from the `STM_UartInit` function in `BSP/UartQuickDirtyInit.c.`,
    where **`Baudrate`**and **`STM_UART_PERIPH`** are input parameters of `STM_UartInit`,
    which makes it very easy to configure multiple UART peripherals with similar settings,
    without repeating all of the following code every time:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Depending on the desired transmit method (such as polled, interrupt-driven,
    or DMA), some additional setting up will be required; this setting up is typically
    performed immediately before beginning a transfer.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's see how all of this plays out by creating a simple driver to read data
    coming into USART2.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Creating a polled UART driver
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing low-level drivers, it's a must to read through the datasheet in
    order to understand how the peripheral works. Even if you're not writing a low-level
    driver from scratch, it is always a good idea to gain some familiarity with the
    hardware you'll be working with. The more familiarity you have, the easier it
    will be to diagnose unexpected behavior, as well as to create efficient solutions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the UART peripheral we're working with in *Chapter 34*
    of the*STM **RM0410 STM32F76xxx* reference manual (*USART*).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Our first **driver** will take an extremely simple approach to getting data
    from the UART and into a queue that can be easily monitored and consumed by any
    task in the system. By monitoring the **receive not empty** ( `RXNE`) bit of the
    UART peripheral's **interrupt status register** (`ISR`), the driver can determine
    when a new byte is ready to be transferred from the **receive data register**
    (`RDR`) of the UART into the queue. To make this as easy as possible, the `while`
    loop is placed in a task (`polledUartReceive`), which will let other higher-priority
    tasks run.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an excerpt from `Chapter_10/Src/mainUartPolled.c`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is another simple task in this example as well; it monitors the queue
    and prints out whatever has been received:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that our driver is ready, let's see how it performs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the performance
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding code (`uartPolled`)can be programmed onto the MCU and we can
    take a look at the performance using SEGGER SystemView:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f262810-3376-400f-9f34-745d331f11ca.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'After looking at the execution using SystemView, we quickly realize that—although
    easy to program—this driver is *horrifically inefficient*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: SystemView reports that this driver is utilizing *over 96%* of the CPU's resources.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The queue is being called at 960 Hz (which makes perfect sense given the initial
    baud rate of 9,600 baud).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see that, while easy to implement, this solution comes with significant
    performance penalties—all while servicing a fairly slow peripheral. Drivers that
    service peripherals by polling have trade-offs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of a polled driver
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some of the advantages of using a polled driver:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to program.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any task has immediate access to data in the queue.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the same time, there are many issues with this approach:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: It must be one of the highest priority tasks in the system.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a high chance of data loss when not executing at high priority.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is extremely wasteful of CPU cycles.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, we're only transferring data at 9,600 baud. Granted, most of
    the time was spent spinning on the `RXNE` bit, but transferring every byte as
    it is received in a queue is also fairly expensive (when compared to pushing bytes
    into a simple array-based buffer). To put this into perspective, USART2 on STM32F767
    running at 216 MHz has a maximum baud rate of 27 Mbaud, which would mean we would
    need to add each character to the shared queue nearly 3 million times a second
    (it is currently adding < 1,000 characters per second). Transferring this much
    data through a queue quickly isn't feasible on this hardware since queue additions
    take 7 µS each (even if the CPU was doing nothing else, we'd be capable of transferring
    less than 143,000 characters per second into the queue).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只以9,600波特率传输数据。诚然，大部分时间都花在了`RXNE`位上，但将每个字节作为接收到的队列中的数据传输也是相当昂贵的（与将字节推入简单的基于数组的缓冲区相比）。为了更直观地说明这一点，STM32F767上的USART2在216
    MHz的频率下运行，其最大波特率为27 Mbaud，这意味着我们几乎需要每秒将每个字符添加到共享队列中近300万次（目前每秒添加不到1,000个字符）。由于队列添加需要7
    µS（即使CPU不做其他任何事情，我们每秒也最多能将143,000个字符传输到队列中），因此在这种硬件上通过队列快速传输这么多数据是不可行的。
- en: More importantly, there are few opportunities to speed up this polled approach,
    since we may receive a new character once every millisecond. If any other task
    was executing for more than 2 ms, the peripheral could potentially be overrun
    (a new byte is received and overwrites the buffer before the previous byte is
    read). Because of these limitations, there are very specific circumstances where
    polled drivers are most useful.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，由于我们可能每毫秒只接收一个新字符，因此几乎没有机会加快这种轮询方法。如果任何其他任务执行时间超过2 ms，外围设备可能会被溢出（新字节在读取前被接收并覆盖缓冲区）。由于这些限制，轮询驱动程序在非常特定的环境中最有用。
- en: Usage of polled drivers
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询驱动程序的使用
- en: 'There are a few circumstances where polled drivers are especially helpful:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，轮询驱动程序特别有用：
- en: '**System verification**: This is perfectly acceptable when performing initial
    system verification, but at that stage of development, it is debatable whether
    an RTOS should be used at all. If the application happens to be truly single purpose,
    there is nothing else to be done while waiting for data to be transferred, and
    there are no power considerations, this would also be an acceptable approach.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统验证**：在进行初始系统验证时，这是完全可以接受的，但在那个开发阶段，是否应该使用实时操作系统（RTOS）还有待商榷。如果应用程序确实是单一用途的，在等待数据传输的过程中没有其他事情可做，并且没有考虑电源问题，这也是一种可接受的方法。'
- en: '**Special cases**: Occasionally, there may be times when a very special-purpose
    piece of code is needed for a limited scope. For example, a peripheral may need
    to be serviced with an extremely low amount of latency. In other cases, the event
    being polled for could happen extremely quickly. When events are happening in
    the order of nanoseconds or microseconds ns or µs (instead of ms, as in the previous
    example), it often makes more sense to simply poll for the event, rather than
    create a more elaborate synchronization scheme. In event-driven systems, adding
    in blocking calls must be carefully considered and clearly documented.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特殊情况**：偶尔，可能需要为有限的范围编写非常特殊用途的代码。例如，外围设备可能需要以极低的延迟进行服务。在其他情况下，轮询的事件可能发生得非常快。当事件以纳秒或微秒（ns或µs）的顺序发生（而不是像上一个例子中的毫秒ms），简单地轮询事件通常比创建更复杂的同步方案更有意义。在事件驱动系统中，添加阻塞调用必须仔细考虑并明确记录。'
- en: Conversely, if a given event is happening very infrequently and there are no
    specific timing constraints, a polled approach may also be perfectly acceptable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果某个事件发生得非常频繁，并且没有特定的时序限制，轮询方法也可能完全可行。
- en: 'While the driver in this example focused on the receiving side, where poll-based
    drivers are rarely acceptable, it is more common to find them used to transmit
    data. This is because space between the characters is generally acceptable since
    it doesn''t result in loss the of data. This allows the driver to be run at a
    lower priority so that other tasks in the system have a chance to run. There are
    a few cases where there is a reasonable argument for using a polled transmit driver
    that blocks while the transmission is taking place:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The code using the driver must block until the transmission is complete.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transfer is a short amount of data.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data rate is reasonably high (so the transfer takes a relatively small amount
    of time).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all of these conditions are met, it *may* make sense to simply use a polled
    approach, rather than a more elaborate interrupt- or DMA-driven approach, which
    will require the use of callbacks and, potentially, task synchronization mechanisms.
    However, depending on how you choose to structure your drivers, it is also possible
    to have the convenience of blocking calls but without the inefficiency of a polled
    transfer wasting CPU cycles. To take advantage of any of the non-polled approaches,
    we'll need to develop another skill—programming ISRs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating between tasks and ISRs
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into coding a peripheral driver that utilizes interrupts, let's
    take a quick look at how interrupts compare to FreeRTOS tasks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many similarities between tasks and ISRs:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Both provide a way of achieving **parallel** code execution.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both only run when required.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both can be written with C/C++ (ISRs generally no longer need to be written
    in assembly code).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But there are also many differences between tasks and ISRs:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '**ISRs are brought into context by hardware; tasks gain context by the RTOS
    kernel**: Tasks are always brought into context by the FreeRTOS kernel. Interrupts,
    on the other hand, are generated by hardware in the MCU. There are usually a few
    different ways of configuring the generation (and masking) of interrupts.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ISRs must exit as quickly as possible; tasks are more forgiving**: FreeRTOS
    tasks are often set up to run in a similar way to an infinite `while` loop—they
    will be synchronized with the system using primitives (such as queues and semaphores)
    and switched into context according to their priority. At the complete opposite
    end of the spectrum are ISRs, which should generally be coded so that they exit
    quickly. This *quick exit* ensures that the system can respond to other ISRs,
    which keeps everything responsive and ensures no interrupts are missed because
    a single routine was hogging the CPU.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ISR functions do not take input parameters; tasks can**: Unlike tasks, ISRs
    can never have input parameters. Since an interrupt is triggered because of a
    hardware state, the most important job of the ISR is to read the hardware state
    (through memory-mapped registers) and take the appropriate action(s). For example,
    an interrupt can be generated when a UART receives a byte of data. In this case,
    the ISR would read a status register, read (and store) the byte received in a
    static variable, and clear the interrupt.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most (but not all) peripherals on STM32 hardware will automatically clear interrupt
    flags when certain registers are read. Regardless of how the interrupt is cleared,
    it is important to ensure the interrupt is no longer pending—otherwise, the interrupt
    will fire continuously and you will always be executing the associated ISR!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '**ISRs may only access a limited ISR-specific subset of the FreeRTOS API**: FreeRTOS
    is written in a way that provides flexibility while balancing convenience, safety,
    and performance. Accessing data structures such as queues from a task is extremely
    flexible (for example, tasks making API calls to a queue can easily block for
    any period of time). There is an additional set of functions that are available
    to ISRs for operating on queues, but these functions have a limited subset of
    functionality (such as not being able to block—the call always immediately returns).
    This provides a level of safety since the programmer can''t shoot themself in
    the foot by calling a function that blocks from inside an ISR. Calling a non-ISR
    API function from inside an ISR will cause FreeRTOS to trigger `configASSERT`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ISRs may operate completely independently of all RTOS code**: There are many
    cases where an ISR operates on such a low level that it doesn''t *need* access
    to any of the FreeRTOS API at all. In this case, the ISR simply executes as it
    normally would without an RTOS present. The kernel never gets involved (and no
    tasks will interrupt execution).  This makes it very convenient for creating flexible
    solutions that blend high-performing ISRs (operating completely *underneath* the
    RTOS) with extremely convenient tasks.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All ISRs share the same system stack; each task has a dedicated stack**:
    Each task receives a private stack, but all of the ISRs share the same system
    stack. This is noteworthy only because, when writing ISRs, you''ll need to ensure
    you reserve enough stack space to allow them to run (possibly simultaneously)
    if they are nested.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've covered the differences between tasks and ISRs, let's take a
    look at how they can be used together to create very powerful event-driven code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Using the FreeRTOS API from interrupts
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the FreeRTOS primitives covered so far have ISR-safe versions of their
    APIs. For example, `xQueueSend()` has an equivalent ISR-safe version, `xQueueSendFromISR()`.
    There are a few differences between the ISR-safe version and the standard call:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The `FromISR` variants won't block. For example, if `xQueueSendFromISR` encounters
    a full queue, it will immediately return.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FromISR` variants require an extra parameter, `BaseType_t *pxHigherPriorityTaskWoken`,
    which will indicate whether or not a higher-priority task needs to be switched
    into context immediately following the interrupt.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only interrupts that have a *logically* lower priority than what is defined
    by `configMAX_API_CALL_INTERRUPT_PRIORITY` in `FreeRTOSConfig.h` are permitted
    to call FreeRTOS API functions (see the following diagram for an example).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an overview of how the `FreeRTOSConfig.h` and `main_XXX.c`
    files configure interrupts for the examples in this book. Some noteworthy items
    are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`main_XXX.c` makes a call to `NVIC_SetPriorityGrouping(0)` after all STM HAL
    initialization is performed (`HAL` sets priority grouping upon initialization).
    This allows all 4 bits of the **nested interrupt vector controller** (**NVIC**)
    to be used for priorities and results in 16 priority levels.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FreeRTOSConfig.h` is used to set up the relationship between FreeRTOS API
    calls and NVIC priorities. The Cortex-M7 defines `255` as being the lowest priority
    level and `0` as being the highest. Since the STM32F7 only implements 4 bits,
    these 4 bits will be shifted into the 4 MSB bits; the lower 4 bits won''t affect
    operation (see the following diagram):'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configKERNEL_INTERRUPT_PRIORITY` defines the lowest priority interrupt in
    our system (and the ISR priority of the FreeRTOS tasks, since the scheduler is
    called within a SysTick interrupt). Because 4 bits yields a possible range of
    `0` (highest priority) to `15` (lowest priority), the lowest NVIC priority used
    will be `15`. When setting `configKERNEL_INTERRUPT_PRIORITY`, `15` needs to be
    shifted left into the 8 bit representation (used directly in the CortexM registers)
    as `(15 << 4) | 0x0F = 0xFF` or `255`.  Since the lowest 4 bits are don''t cares,
    `0xF0` (decimal 240) is also acceptable.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configMAX_SYSCALL_INTERRUPT_PRIORITY` defines the (logically) highest priority
    interrupt that is allowed to make calls to the FreeRTOS API. This is set to `5`
    in our examples. Shifting left to fill out the 8 bits gives us a value of `0x50`
    or `0x5F` (decimal 80 or 95, respectively):'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c94abcbe-e57f-476c-b15f-15272efe8f64.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding diagram, there are some cases where ISRs can
    be set up to execute at a priority above anything the RTOS might be doing. When
    configured as `0` to `4` NVIC priorities, ISRs are identical to traditional "bare-metal"
    ISRs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: It is *very* important to ensure that the interrupt priority is properly configured *before*
    enabling the interrupt by calling `NVIC_SetPriority` with a priority of <= 5\.
    If an interrupt with a priority that is logically higher than `configMAX_SYSCALL_INTERRUPT_PRIORITY` calls
    a FreeRTOS API function, you'll be greeted with a `configASSERT` failure (see
    [Chapter 17](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml), *Troubleshooting Tips
    and Next Steps*, for more details on `configASSERT`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of the differences between tasks and ISRs,
    as well as some of the ground rules for using FreeRTOS API functions from within
    ISRs, let's take another look at the polled driver to see how it can be implemented
    more efficiently.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Creating ISR-based drivers
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first iteration of the UART driver, a task polled the UART peripheral
    registers to determine when a new byte had been received. The constant polling
    is what caused the task to consume > 95% of CPU cycles. The most meaningful work
    done by this task-based driver was transferring bytes of data out of the UART
    peripheral and into the queue.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: In this iteration of the driver, instead of using a task to continuously poll
    the UART registers, we'll set up the `UART2` peripheral and NVIC to provide an
    interrupt when a new byte is received.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Queue-based driver
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's look at how to more efficiently implement the polled driver (previously
    implemented by polling the UART registers within a task). In this implementation,
    instead of using a task to repeatedly poll the UART registers, a function will
    be used to set up the peripheral to use interrupts and initiate the transfer.
    A complete set of ISR function prototypes can be found in the startup file (for
    the STM32F767 used in our examples, this file is `Chapter_10/startup_stm32f767xx.s`).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Each `*_IRQHandler` instance in `startup_stm32f767xx.s` is used to map the function
    name to an address in the interrupt vector table. On ARM Cortex-M0+, -M3, -M4,
    and -M7 devices, this vector table can be relocated by an offset at runtime. See
    *Further reading* for some links to more information on these concepts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'This example has four primary components:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '`uartPrintOutTask`: This function initializes USART2 and associated hardware,
    starts a reception, and then prints anything placed in the `uart2_BytesReceived`
    queue.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startReceiveInt`: Sets up an interrupt-based reception for USART2.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USART2_IRQHandler`: An ISR is issued when an interrupt occurs for the USART2
    peripheral.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startUart4Traffic`: Starts a continuous stream of data transmitted from UART4
    to be received by USART2 (provided the jumpers are correctly set).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each component in detail. All excerpts in this section
    are from `Chapter_10/Src/mainUartInterruptQueue.c`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: uartPrintOutTask
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only task in this example is `uartPrintOutTask`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`uartPrintOutTask` does the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Performs all peripheral hardware initialization by calling `STM_UartInit`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts an interrupt-based reception by calling `startReceiveInt`
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consumes* and prints each character as it is added to the `uart2_BytesReceived` queue
    by calling `xQueueReceive`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: startReceiveInt
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `startReceiveInt` function starts an interrupt-driven reception:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`startReceiveInt` sets up everything required to receive data on USART2:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '`rxInProgress` is a flag used by the ISR to indicate a reception is in progress.
    The ISR (`USART2_IRQHandler()`) will not attempt to write to the queue until `rxInProgress`
    is true.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USART2 is configured to generate `receive` and `error` interrupts and is then
    enabled.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `NVIC_SetPriority` function (defined by CMSIS in `Drivers/CMSIS/Include/corex_cm7.h`)
    is used to set the interrupt priority. Since this interrupt will call a FreeRTOS
    API function, this priority must be set at or *below* thelogical priority defined
    by  `configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY` in `FreeRTOSConfig.h`. On ARM
    CortexM processors, smaller numbers signify a higher logical priority—in this
    example, `#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5`, so assigning
    a priority of `6` to `USART2_IRQn` will be adequate for allowing the ISR to make
    calls to the ISR-safe function (`xQueueSendFromISR`) provided by FreeRTOS.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the interrupt requests generated by USART2 will be enabled by making
    a call to `NVIC_EnableIRQ`.   If `NVIC_EnableIRQ` is not called, USART2 will still
    generate requests, but the interrupt controller (the "IC" in NVIC) will not *vector* the
    program counter to the ISR (`USART2_IRQHandler` will never be called).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, as with nearly all the code in this chapter, we're writing
    directly to the hardware peripheral registers and not using considerable amounts
    of abstraction. This is done to keep the focus on how the RTOS interacts with
    the MCU. If code reuse is one of your goals, you'll need to provide some level
    of abstraction above raw registers (or STM HAL code, if you're using it). Some
    guidelines on this can be found in [Chapter 12](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml),
    *Tips on Creating Well-Abstracted Architecture*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: USART2_IRQHandler
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the code for `USART2_IRQHandler`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s take a closer look at each component of the ISR:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The USART registers are directly read to determine whether or not the receive
    not empty (`RXNE`) is set. If it is, the contents of the receive data register
    (`RDR`) are stored to a temporary variable (`tempVal`)—this read clears the interrupt
    flag. If a receive is in progress, `tempVal` is sent to the queue.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls to `SEGGER_SYSVIEW_RecordEnterISR` and `SEGGER_SYSVIEW_RecordExitISR`
    are made upon entry and exit, which gives SEGGER SystemView the visibility to
    display the interrupt with all of the other tasks in the system.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `xHigherPriorityTaskWoken` variable is initialized to false. This variable
    is passed to the `xQueueSendFromISR` function and is used to determine whether
    a high-priority task (higher than the one currently in the non-ISR context) is
    blocking because it is waiting on an empty queue. In this case, `xHigherPriorityTaskWoken` will
    be set to true, indicating a higher-priority task should be woken immediately
    after the ISR exits. When the call to `portYIELD_FROM_ISR` is made, if `xHigherPriorityTaskWoken` is
    true, the scheduler will immediately switch to the higher-priority task.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that the ISR has been written, we'll need to make sure it will actually
    be called by the hardware at the appropriate time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Tips for linking ISRs
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing ISRs from scratch (as we''ve done in the previous example), one
    area that can prove to be a source of unexpected trouble is ensuring your ISR
    is properly linked in (and executed). That is, even if you''ve properly set up
    the peripheral to generate interrupts, your new ISR might never be called because
    it isn''t named properly (instead, the default implementation, defined in a startup
    file, will likely be called). Here are some tips to make sure that shiny new ISR
    can be found and properly linked in with the rest of the application:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: STM32 `*_IRQHandler` function names *usually* contain the *exact* peripheral
    name from the datasheet as a sub-string. For example, USART2 maps to `USART2_IRQHandler` (notice
    the "S") and UART4 maps to `UART4_IRQHandler` (no "S" in the peripheral or function
    name).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When writing a new implementation for an ISR, it is a good idea to copy and
    paste the exact `_IQRHandler` name from the startup file. This reduces the chance
    of typos, which can cause debug headaches!
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STM start-up files implement default handlers for every interrupt as an infinite
    loop. If you notice your application becoming unresponsive, it is possible you've
    enabled an interrupt and your `*_IRQHandler` definition isn't being linked in
    properly.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you happen to be implementing `*_IRQHandler` inside a C++ file, be sure to
    use `extern "C"` to prevent *name mangling*. For example, the USART2 definition
    would be written as `extern "C" void USART2_IRQHandler( void)`. This also means
    the ISR definition must *not* be inside a class.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When implementing ISRs, take your time and be sure to get the details (such
    as the *exact* name) right. Don't rush into attempting to debug the rest of your
    application without first ensuring the ISR is called when expected. Using breakpoints
    inside the ISR is an excellent way of doing this.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: startUart4Traffic
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final component that needs to be explored in this example is how data will
    be sent to UART2\. These examples are meant to simulate external data being received
    by USART2.  To achieve this without additional hardware, we wired together UART4
    Tx and USART2 RX pins earlier in the chapter. The call to `startUart4Traffic()` is
    a `TimerHandler` prototype. A oneshot timer is started and set to fire 5 seconds
    after the application starts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中需要探索的最后一个组件是如何将数据发送到UART2。这些示例旨在模拟外部数据被USART2接收。为了在不添加额外硬件的情况下实现这一点，我们在本章早期将UART4的Tx和USART2的RX引脚连接在一起。对`startUart4Traffic()`的调用是一个`TimerHandler`原型。一个单次定时器被启动并设置为在应用程序启动后5秒触发。
- en: The function that does all of the heavy lifting is `SetupUart4ExternalSim()`.
    It sets up a continuous circular DMA transfer (which executes without CPU intervention)
    that transmits the string `data from uart4` repeatedly. A full example using DMA
    will be covered later in this chapter – for now, it is sufficient to realize that
    data is being sent to USART2 without involvement from the CPU.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 执行所有繁重工作的函数是`SetupUart4ExternalSim()`。它设置了一个连续的循环DMA传输（无需CPU干预）来重复传输字符串`data
    from uart4`。本章稍后将详细介绍使用DMA的完整示例——目前，我们只需要意识到数据正在发送到USART2，而不涉及CPU。
- en: '`startUart4Traffic()` creates a *continuous* stream of bytes that will be transmitted
    out of UART4 Tx and into UART2 Rx (with no flow control). Depending on the selected
    baud rate and the amount of time it takes for the receiving code to execute, we
    can expect that, eventually, a byte will be missed on the receiving side during
    some examples. Keep this in mind when running examples on your own. See the *Choosing
    a driver model* section for more details on selecting the appropriate driver type
    for your application.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`startUart4Traffic()`创建了一个*连续*的字节流，这些字节将从UART4的Tx引脚传输到UART2的Rx引脚（没有流量控制）。根据所选的波特率和接收代码执行所需的时间，我们预计在某些示例中，接收端最终会丢失一个字节。在运行自己的示例时请记住这一点。有关选择适当驱动程序类型更详细的信息，请参阅*选择驱动程序模型*部分。'
- en: Performance analysis
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: 'Now, let''s take a look at the performance of this implementation by compiling
    `mainUartInterruptQueue`, loading it onto the MCU, and using SystemView to analyze
    the actual execution:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过编译`mainUartInterruptQueue`，将其加载到MCU上，并使用SystemView分析实际执行来查看此实现的性能：
- en: '![](img/1db4a7e2-4ed1-4022-864f-efba7ed13ab6.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1db4a7e2-4ed1-4022-864f-efba7ed13ab6.png)'
- en: 'This time around, things look considerably better.  Here are some noteworthy
    items from the preceding screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，情况看起来好得多。以下是前一个屏幕截图中的几个值得注意的项目：
- en: The ISR responsible for dealing with the incoming data on USART2 Rx is only
    consuming around 1.6% of the CPU (much better than the 96% we saw when we were
    using a polled approach).
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负责处理USART2 Rx接收到的数据的ISR仅消耗大约1.6%的CPU（比我们使用轮询方法时看到的96%要好得多）。
- en: We are still receiving 960 bytes per second—the same as before.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然以每秒960字节的速度接收数据——与之前相同。
- en: The small tick mark shown here is the exact point in time when `tempVal` is
    added to `uart2_BytesReceived` by the call to the `xQueueSendFromISR` FreeRTOS
    API function.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里显示的小刻度是`tempVal`通过调用FreeRTOS API函数`xQueueSendFromISR`添加到`uart2_BytesReceived`的确切时间点。
- en: We can see the effect of `portYIELD_FROM_ISR` here. The light-blue portion of
    the `uartPrint` task indicates that the task is ready to run. This happens because
    the `uartPrint` task is ready to run since there is an item in the queue. The
    call to `portYIELD_FROM_ISR` forces the scheduler to immediately evaluate which
    task should be brought into context. The green portion (starting at ~21 uS) is
    SystemView's way of signifying that the task is in a **running** state.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在这里看到`portYIELD_FROM_ISR`的效果。`uartPrint`任务中的浅蓝色部分表示任务准备就绪。这是因为`uartPrint`任务由于队列中有项目而准备就绪。对`portYIELD_FROM_ISR`的调用迫使调度器立即评估哪个任务应该被带入上下文。绿色部分（从大约21
    uS开始）是SystemView表示任务处于**运行**状态的方式。
- en: After the `uartPrint` task begins running, it removes the next character from
    the queue and prints it using `SEGGER_SYSVIEW_PrintfHost`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`uartPrint`任务开始运行后，它从队列中移除下一个字符，并使用`SEGGER_SYSVIEW_PrintfHost`打印它。
- en: By switching from a poll-based driver to an interrupt-based driver, we've significantly
    reduced the CPU load. Additionally, systems that use an interrupt-based driver
    can run other tasks while still receiving data through USART2\. This driver also
    uses a queue-based approach, which provides a very convenient ring buffer, allowing
    characters to be continuously received and added to the queue, then read whenever
    it is convenient for higher-level tasks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll work through an example of a similar driver that doesn't use a queue
    at all.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: A buffer-based driver
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the exact size of a transfer is known in advance. In this case, a
    pre-existing buffer can be passed to the driver and used in place of a queue.
    Let's take a look at an example of a buffer-based driver, where the exact number
    of bytes is known in advance. The hardware setup for this example is identical
    to the previous examples—we'll concentrate on receiving data through USART2.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using a queue, `uartPrintOutTask` will supply its own buffer to the `startReceiveInt`
    function. Data received by USART2 will be placed directly in the local buffer
    until the desired number of bytes have been added, then a semaphore will be given
    by the ISR to provide notification of the completion. The entire message will
    be printed as a single string, rather than 1 byte at a time, as it is received
    (which was done in the last example).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the previous example, there are four main components. However, their
    responsibilities vary slightly:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`startReceiveInt`: Sets up an interrupt-based reception for USART2 and configures
    the necessary variables used by the ISR for the transfer.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uartPrintOutTask`: This function initializes USART2 and associated hardware,
    starts a reception, and waits for completion (with a deadline of 100 ms). The
    complete message is either printed or a timeout occurs and an error is printed.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USART2_IRQHandler`: An ISR is issued when an interrupt occurs for the USART2
    peripheral.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startUart4Traffic`: Starts a continuous stream of data transmitted from UART4
    to be received by USART2 (provided the jumpers are correctly set).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each component in detail. All excerpts in this section
    are from `Chapter_10/Src/mainUartInterruptBuffer.c`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: startReceiveInt
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `startReceiveInt` function is very similar to the one used for the queue-based
    driver:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here are the notable differences in this setup:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: This variant takes in a pointer to a buffer (`Buffer`), as well as the desired
    length of the transfer (`Len`). A couple of global variables, `rxBuff` and `rxLen` (which
    will be used by the ISR), are initialized using these parameters.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rxInProgress` is used to determine whether a reception is already in progress
    (returning `-1`  if it is).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An iterator (`rxItr`) that is used to index into the buffer is initialized to
    `0`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the remaining functionality of `startReceiveInt` is identical to the
    example covered in the *Queue-based driver* section earlier in the chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: uartPrintOutTask
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `uartPrintOutTask` function that is responsible for printing out data received
    by USART2 is a bit more complex in this example. This example is also capable
    of comparing the received data against an expected length, as well as some rudimentary
    error detection:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The buffer and length variables are initialized and the UART peripheral is
    set up:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, the body of the `while` loop starts a reception by calling `startReceiveInt`
    and then waits for the `rxDone` semaphore for up to 100 RTOS ticks for the transfer
    to complete.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the transfer completes in time, the total number of bytes received is compared
    against `expectedLen`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the correct number of bytes are present, the content of `rxData` is printed.
    Otherwise, a message providing an explanation of the discrepancy is printed:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The remainder of the `while` loop and function simply prints `timeout` if the
    semaphore is not taken within 100 ticks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: USART2_IRQHandler
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This ISR is also slightly more involved since it is required to keep track
    of the position in a queue:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Private globals are used by `USART2_IRQHandler` because they need to be accessible
    by both the ISR and used by both `USART2_IRQHandler`  and `startReceiveInt`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The same paradigm for storing `xHigherPriorityTaskWoken` and SEGGER SystemView
    tracing is used in this ISR, just like in the last example:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, errors are checked by reading the overrun (`ORE`), noise error (`NE`),
    framing error (`FE`), and parity error (`PE`) bits in the interrupt state register
    (`USART2->ISR`).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If an error is present, it is cleared by a write to the interrupt clear register
    (`USART2->ICR`) and the `rxDone` semaphore is given. It is the responsibility
    of the caller code to check the number of bits in the buffer by looking at the
    `rxItr` variable (shown in the next code block) to ensure the correct number of
    bits were successfully received:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, the ISR checks whether a new byte has been received (by reading the `RXNE`
    bit of `USART2->ISR`). If a new byte is available, it is pushed into the `rxBuff`
    buffer and the `rxItr` iterator is incremented.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the desired number of bytes have been added to the buffer, the `rxDone`
    semaphore is given to notify `uartPrintOutTask`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Don't forget to put a breakpoint in the ISR to make sure it is being called.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: startUart4Traffic
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identical to the previous example, this function sets up a DMA transfer to push
    data out of the UART4 Tx pin into the USART2 Rx pin.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Performance analysis
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the performance of this driver implementation. There
    are several aspects to consider. Unless a transfer is complete, the ISR will normally
    only transfer a byte into `rxBuff`. In this case, the interrupt is fairly short,
    taking less than 3 us to complete:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ba829c9-7e44-4a49-94c4-9c0caabc9a6f.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: 'After all 16 bytes have been received, the ISR execution gets a bit more interesting
    and looks a bit more similar to the previous example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ff7273f-d44e-4b1b-b4a1-f67eb8937997.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Here are some noteworthy points from the preceding screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: After all the bytes have been placed into `rxBuff`, the `rxDone` semaphore is
    given from the ISR using `xSemaphoreGiveFromISR`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task is unblocked after the interrupt is executed by taking the available
    semaphore (`xSemaphoreTake(rxDone,100)`).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exact contents of `rxBuff` are printed. Note that each line contains the
    entire string, rather than individual characters. This is because this implementation
    collects an entire buffer's worth of data before using a semaphore to indicate
    completion.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, let''s have a look at the complete tally of CPU usage:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13db11e2-8cf2-4deb-849d-d83e05492654.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: 'Here are some noteworthy items from the preceding screenshot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The ISR for this implementation is using 0.34% of the CPU (instead of 1.56%
    when each character was pushed to a queue from inside the ISR).
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The FreeRTOS scheduler is using only using 0.06% of the CPU instead of 0.94%
    (each time items are added to queues, the scheduler runs to determine whether
    or not tasks should be unblocked because of the addition).
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The frequency of the USART2 ISR remains at 960 Hz, exactly the same as the previous
    examples, but now the frequency of the `print` task has been reduced to only 60
    Hz, since the `uartPrint` task that only runs after 16 bytes has been transferred
    into `rxBuff`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, this ISR implementation of the driver uses even fewer CPU cycles
    than the queue-based approach. Depending on the use case, it can be an attractive
    alternative. These types of drivers are commonly found in non-RTOS-based systems,
    where callback functions will be used instead of semaphores. This approach is
    flexible enough to be used with or without an RTOS by placing a semaphore in the
    callback. While slightly more complex, this is one of the most flexible approaches
    for code bases that see a large amount of reuse in different applications.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the two variants of drivers implemented with an ISR so far have
    been the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '**A queue-based driver**: Delivers incoming data to tasks by pushing received
    data into a queue one character at a time.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A buffer-based driver**: Delivers incoming data to a single buffer that is
    pre-allocated by the calling function.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the surface, it may seem silly to have two different implementations that
    both take incoming data from a peripheral and present it to the higher layers
    of code. It is important to realize these two different variants of a driver for
    the same hardware vary both in their implementation, efficiency, and ultimately,
    the interface provided to higher-level code. They may both be moving bytes from
    the UART peripheral, but they provide higher-level code with drastically different
    programming models.  These different programming models are each suited to solving
    different types of problems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at how another piece of hardware inside the MCU can be used
    to lighten the burden on the CPU when moving large amounts of data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Creating DMA-based drivers
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw that, compared to a polled approach, the interrupt-based driver is considerably
    better in terms of CPU utilization. But what about applications with a high data
    rate that require millions of transfers per second? The next step in improved
    efficiency can be obtained by having the CPU involved as little as possible by
    pushing most of the work for transferring data around onto specialized peripheral
    hardware within the MCU.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: A short introduction to DMAwas covered in [Chapter 2](84f04852-827d-4e79-99d7-6c954ba3e93c.xhtml),
    *Understanding RTOS Tasks*, in case you need a refresher before diving into this
    example.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll work through creating a driver using the same buffer-based
    interface as the interrupt-based driver. The only difference will be the use of
    DMA hardware to transfer bytes out of the peripheral's read data register (`RDR`)
    and into our buffer. Since we already have a good handle on configuring the USART2
    peripheral from our other drivers, the first order of business for this variant
    is to figure out how to get data from `USART2->RDR` to the DMA controller and
    then into memory.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Configuring DMA peripherals
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'STM32F767 has two DMA controllers. Each controller has 10 channels and 8 streams
    to map DMA requests from one location in the MCU to another. On the STM32F767
    hardware, streams can do the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Can be thought of as a way to *flow* data from one address to another
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can transfer data from peripherals to RAM or RAM to peripherals
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can transfer data from RAM to RAM
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can only transfer data between two points at any given moment in time
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each stream has up to 10 channels for mapping a peripheral register into a
    given stream. In order to configure the DMA controller to handle requests from
    the USART2 `receive`, we''ll reference table 27 from the *STM32F7xx **RM0410* reference
    manual:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a36bd6b0-a7a7-423d-aa0b-30625a0871e0.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: In this table, we can see that DMA1 Channel 4, Stream 5 is the appropriate setup
    to use to handle requests from `USART2_RX`. If we were also interested in handling
    requests for the transmit side, Channel 4, Stream 6 would also need to be set
    up.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the channel and stream numbers, we can add some initialization
    code to set up the DMA1 and USART2 peripherals:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '`DMA1_Stream5` will be used to transfer data from the `receive` data register
    of USART2 directly into a buffer in RAM.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USART2` will not have interrupts enabled (they are not needed since DMA will
    perform all transfers from the peripheral register to RAM).'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DMA1_Stream5` will be set up to trigger an interrupt after the entire buffer
    has been filled.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next few snippets are from the `setupUSART2DMA` function in `Chapter_10/src/mainUartDMABuff.c`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the clock to the DMA peripheral is enabled, interrupt priorities are
    set up, and the interrupts are enabled in the NVIC:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, the DMA stream is configured by filling out a `DMA_HandleTypeDef` struct
    (`usart2DmaRx`) and using `HAL_DMA_Init()`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`HAL` initialization provides some sanity checking on the values passed to
    it. Here''s a highlight of the most immediately relevant portions:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '`DMA1_Stream5` is set as the instance. All calls that use the `usart2DmaRx`
    struct will reference stream `5`.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channel `4` is attached to stream `5`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory incrementing is enabled. The DMA hardware will automatically increment
    the memory address after a transfer, filling the buffer.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peripheral address is not incremented after each transfer—the address of
    the USART2 receive data register (`RDR`) doesn't ever change.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `transfer complete` interrupt is enabled for `DMA1_Stream5`.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USART2 is set up for `DMA receive mode`. It is necessary to set this bit in
    the USART peripheral configuration to signal that the peripheral's receive register
    will be mapped to the DMA controller.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional details about how this struct is used can be found by looking at
    the `DMA_HandleTypeDef` struct definition in `stm32f7xx_hal_dma.h` (line 168)
    and `HAL_DMA_Init()` in `stm32f7xx_hal_dma.c` (line 172). Cross-reference the
    registers used by the HAL code with section 8 (page 245) in the *STM32F76xxx RM0410*
    reference manual. This same technique is often most productive for understanding *exactly*
    what the `HAL` code is doing with individual function parameters and struct members.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Now that the initial DMA configuration is done, we can explore a few different
    interrupt implementations using DMA instead of interrupts.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: A buffer-based driver with DMA
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s an implementation of a driver with identical functionality to the one
    in the *A buffer-based driver* section. The difference is the DMA version of the
    driver doesn''t interrupt the application every time a byte is received. The only
    `interrupt` generated is when the entire transfer is complete. To realize this
    driver, we only need to add the following ISR:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The significant portions of the driver are in bold. If a reception is in progress
    (based on the value of `rxInProgress` and the transmit complete flag, `DMA_HISR_TCIF5`,
    the following takes place:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The DMA interrupt flag is cleared.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rxDone` semaphore is given.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is all that is required when using DMA-based transfers since the DMA controller
    does all of the bookkeeping associated with the buffer. At this point, the rest
    of the code functions in an identical way to the `interrupt` version (the only
    difference is that less CPU time is spent servicing interrupts).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Performance analysis
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the performance of the DMA-based implementation compared
    to the interrupt-driven approach:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff5bfae7-0dec-4e40-9edb-58d00bcffe90.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: 'This time around, we can make the following observations about the overall
    system behavior:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The (DMA) ISR is now consuming < 0.1% of CPU cycles at 9,600 baud.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Scheduler CPU's consumption is still very low.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The frequency of the ISR has been reduced to only 60 Hz (from 960 Hz). This
    is because, rather than creating an interrupt for every byte, there is only an
    interrupt generated at the end of the transfer of 16 bytes. The Idle task is being
    context-switched significantly less often as well. Although it seems trivial with
    these simple examples, excessive context-switching can become a very real problem
    in large applications with many tasks and interrupts.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The overall flow is similar to that of the interrupt buffer-based approach,
    with the only difference being that there is only a single ISR executed when the
    entire transfer is complete (instead of one interrupt for each byte transferred):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99336104-c2df-4bba-9049-a32f2313ccf2.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, we can observe the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The DMA ISR is executed once (after all 16 bytes are transferred into the buffer).
    A semaphore is shown by the tick mark that arrow 1 is pointing to in the screenshot.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ISR wakes up the blocked `uartPrint` function. Arrow 2 is pointing to where
    the semaphore is taken.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two i infoboxes show where the console print messages are generated (~35
    and 40 us after the final byte has been received). The remainder of the time this
    task spends is on re-initializing the buffer and setting up the next transfer.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a wider view of all of the processor activity. Notice that the only
    activity occurs approximately once every 16 ms (after all the bytes have been
    transferred into memory):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c06339b-87a6-4308-90c0-cca4b32f7e05.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: The real capability of a fully DMA-based approach is most valuable when transferring
    large amounts of data very quickly. The following example shows the same dataset
    (only 16 bytes) transferred at 256,400 baud (the fastest that could be reliably
    achieved without error due to poor signal integrity).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The baud rate can be easily changed in the examples by modifying `#define BAUDRATE`  in
    `main<exampleame>.c`. They are configured so that a single change will modify
    both the USART2 and UART4 baud rates.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of transfers being made at 256,000 baud. A new
    set of 16 bytes is available in the buffer, approximately every 624 µS:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9903f26b-f4aa-4047-a4d1-90c6f33ebf80.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: 'By increasing the baud rate from 9,600 to 256,000, our CPU usage has increased
    from around 0.5% to around 11%. This is in line with the 26x increase in baud
    rate—all of the function''s calls are proportionate to the baud rate:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09e72b29-d689-42e0-b687-40eacf3fe51e.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: 'Notice the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The DMA interrupt consumes 2.29%.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `uartPrint` task is the highest consumer of CPU cycles (a little over 6%).
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though we've proved to ourselves that it is possible to efficiently transfer
    data quickly by using DMA, this current setup doesn't have the same convenience
    that the interrupt-driven queue solution did. Tasks rely on entire blocks to be
    transferred, rather than using a queue. This might be fine or might be an inconvenience,
    depending on what the goals of the higher-level code are.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Character-based protocols will tend to be easier to implement when written on
    top of a queue-based driver API, rather than a buffer-based driver API (such as
    the one we've implemented here). However, we saw in the *Queue-based driver* section
    that queues become computationally expensive very quickly. Each byte took around
    30 us to be added to the queue. Transferring data at 256,000 baud would consume
    most of the available CPU in the UART ISR alone (a new byte is received every
    40 us and it takes 30 us to process).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: In the past, if you really needed to implement a character-oriented driver,
    you could roll your own highly efficient ring buffer implementation and feed it
    directly from low-level ISRs (bypassing most of the FreeRTOS primitives to save
    time).  However, as of FreeROTS 10, there is another alternative—stream buffers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Stream buffers (FreeRTOS 10+)
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stream buffers combine the convenience of a queue-based system with the speed
    closer to that of the raw buffer implementations we created previously. They have
    some flexibility limitations that are similar to the limitations of task notification
    systems compared to semaphores. *Stream buffers can only be used by one sender
    and one receiver at a time.* Otherwise, they'll need external protection (such
    as a mutex), if they are to be used by multiple tasks.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: The programming model for stream buffers is very similar to queues, except that
    instead of functions being limited to queueing one item at a time, they can queue
    multiple items at a time (which saves considerable CPU time when queuing blocks
    of data). In this example, we'll explore stream buffers through an efficient DMA-based
    circular buffer implementation for UART reception.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals of this driver example are the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Provide an easy-to-use character-based queue for users of the driver.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain efficiency at high data rates.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always be ready to receive data.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's begin!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Using the stream buffer API
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's take a look at an example of how the stream buffer API will be
    used by `uartPrintOutTask` in this example. The following excerpts are from `mainUartDMAStreamBufferCont.c`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a look at the definition of `xSttreamBufferCreate()`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note the following in the preceding code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '`xBufferSizeBytes` is the number of bytes the buffer is capable of holding.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xTriggerLevelBytes` is the number of bytes that need to be available in the
    stream before a call to `xStreamBufferReceive()` will return (otherwise, a timeout
    will occur).'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example code sets up a stream buffer:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding snippet, we can observe the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '`rxStream` is capable of holding `NUM_BYTES` (100 bytes).'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time a task blocks data from being added to the stream, it won't be unblocked
    until at least `MIN_NUM_BYTES` (2 bytes) are available in the stream. In this
    example, calls to `xStreamBufferReceive` will block until a minimum of 2 bytes
    are available in the stream (or a timeout occurs).
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If using the FreeRTOS heap, be sure to check that there is enough space for
    the allocation of the stream buffer by checking the returned handle isn't `NULL`.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function for receiving data from a stream buffer is `xStreamBufferReceive()`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is a straightforward example of receiving data from a stream buffer:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding snippet, note the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '`rxStream`: The pointer/handle to `StreamBuffer`.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rxBufferedData`: The local buffer that bytes will be copied into.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxBytesReceived`: The maximum number of bytes that will be copied into `rxBufferedData`.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The timeout is `100` ticks (`xStreamBufferReceive()` will return after at least
    `xTriggerLevelBytes` (`2` in this example) are available or 100 ticks have elapsed).
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls to `xStreamBufferReceive()` behave in a similar way to a call to `xQueueReceive()` in
    that they both block until data is available. However, a call to `xStreamBufferReceive()` will
    block until the minimum number of bytes (defined when calling `xStreamBufferCreate()`) or
    the specified number of ticks has elapsed.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the call to `xStreamBufferReceive()` blocks until one of the
    following conditions is met:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The number of bytes in the buffer exceeds `MIN_NUM_BYTES` (`2` in this example).
    If more bytes are available, they will be moved into `rxBufferedData`—but only
    up to the `maxBytesReceived` bytes (`16` in this example).
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timeout occurs. All available bytes in the stream are moved into `rxBufferedData` . 
    The exact number of bytes placed into `rxBufferedData` is returned by `xStreamBuffereReceive() -` ( `0`
    or `1` in this example).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a good idea of what the receiving side looks like, let's look
    at some of the details of the driver itself.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Setting up double-buffered DMA
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw earlier, using DMA can be very beneficial for reducing CPU usage (versus
    interrupts). However, one of the features that wasn't covered in the last example
    was continuously populating a queue (the driver required block-based calls to
    be made before data could be received). The driver in this example will transfer
    data into the stream buffer constantly, without requiring any intervention from
    the code calling it. That is, the driver will always be receiving bytes and pushing
    them into the stream buffer.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Always receiving data presents two interesting problems for a DMA-based system:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: How to deal with **roll-over**—when a buffer has been completely filled and
    high-speed data could still be coming in.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to terminate transfers before a buffer is completely filled. DMA transfers
    typically require the number of bytes to be specified before the transfer starts.
    However, we need a way to stop the transfer when data has stopped being received
    and copy that data into the stream buffer.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DMA double buffering will be used to ensure our driver will always be able
    to accept data (even when a single buffer has been filled). In the previous example,
    a single buffer was filled and an interrupt was generated, then the data was operated
    on directly before restarting the transfer. With double buffering, a second buffer
    is added. After the DMA controller fills the first buffer, it automatically starts
    filling the second buffer:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02139e92-a978-4408-b468-da094f33ff01.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: After the first buffer is filled and the interrupt is generated, the ISR can
    safely operate on data in the first buffer, `rxData1`, while the second buffer, `rxData2`,
    is filled. In our example, we're transferring that data into the FreeRTOS stream
    buffer from inside the ISR.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that `xStreamBufferSendFromISR()` adds a *copy* of
    the data to the stream buffer, not a reference. So, in this example, as long as
    the DMA ISR''s call to `xStreamBufferSendFromISR()` executes before `rxData2` has
    been filled, data will be available with no loss. This is unlike traditional **bare-metal**
    double-buffer implementations since higher-level code making calls to `xStreamBufferReceive() ` isn''t
    required to extract data from `rxData1` before  `rxData2` is filled. It only needs
    to call `xStreamBufferReceive()` before the stream buffer has been filled:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17705c53-8c3d-4ee4-8bd1-494fa6b123eb.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: Even if you're programming for an MCU without an explicit **double-buffer mode**,
    most DMA controllers will have a **circular** mode with **half-transfer** and
    **full-transfer** interrupts. In this case, the same functionality can be achieved
    by generating an interrupt after each half of the buffer is filled.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'The secondary buffer, `rxData2`, is set up by writing its address to the `DMA_SxM1AR`
    register (some casting is required to keep the compiler from complaining too loudly
    that we''re writing a pointer to a 32-bit memory address):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Interestingly enough, STM HAL doesn''t support double-buffer mode directly.
    In fact, calls to `HAL_DMA_Start` explicitly disable the mode. So, some manual
    setup with registers is required (after letting `HAL` take care of most of the
    leg work):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After the DMA stream is enabled, the UART is enabled, which will start transfers
    (this is identical to the previous examples).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Populating the stream buffer
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stream buffer will be populated from inside the DMA ISR:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here are some of the more noteworthy items in this ISR:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '`if(rxInProgress && (DMA1->HISR & DMA_HISR_TCIF5))`: This line guards against
    the stream buffer being written to before the scheduler is started. Even if the
    ISR was to execute before the scheduler was started, `rxInProgress` wouldn''t
    be true until after everything was initialized. Checking the transmit complete
    flag, `DMA_HISR_TCIF5`, guarantees that a transfer has, indeed, completed (rather
    than entering the ISR because of an error).'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DMA1_Stream5->CR & DMA_SxCR_CT`: Checks the current target bit. Since this
    bit indicates which target buffer (`DMA_SxM0AR`  or `DMA_SxM1AR`) is currently
    being **filled** by the DMA controller, we''ll take the other and push that data
    into the stream buffer.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `xStreamBufferSendFromISR` pushes the entirety of `rxBuff1` or `rxBuff2` (each
    of an `RX_BUFF_LEN` length) into `rxStream` in one go.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A few things to remember are as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Data is being transferred to the stream by value (not reference). That is, FreeRTOS
    is using `memcpy` to make a copy of all of the data moving into the stream buffer
    (and again when removing data). The larger the buffer, the more time it will take
    to copy—additional RAM will also be used.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of performing the copy inside the interrupt, under certain circumstances,
    it may be preferable to signal a semaphore or task notification and perform the
    copy in a high-priority task instead—for example, if a large buffer is being filled.
    However, you'll need to guarantee that other interrupts don't starve the task
    performing the `xStreamBufferSend` or data will be lost.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are trade-offs when using DMA. Larger buffers mean fewer interruptions
    to transfer data, but they also mean an increase in latency. The larger the buffer,
    the longer the data will sit in the buffer before being processed.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This implementation is only well suited to continuous data streams—if the data
    stream stops, the last DMA transfer will never complete.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach to pushing received data from a peripheral into memory works very
    well when data is continuously streaming. It can also work extremely well for
    the reception of messages with a known number of bytes. However, there are some
    ways to improve it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Improving the stream buffer
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to deal with an intermittent data stream, there are two possible approaches
    (for this specific setup):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: The USART peripheral on this MCU is capable of detecting an "idle line" and
    generating an interrupt by setting the `USART_CR1:IDLEE` bit when an idle line
    is detected.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The USART peripheral also has a `receive` timeout that can also generate an
    interrupt after no start bits have been detected for a specified number of bit
    times (0-16,777,215).
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This timeout is specified in the `USART_RTOR:RTO[23:0]` register.
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The feature can be enabled with `USART_CR2:RTOEN` and the interrupts can be
    enabled with  `USART_CR1:RTOIE`.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Either of these features could be used to generate a USART interrupt, cut the
    DMA transfer short, and transfer the data to the stream buffer.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: For extremely high baud rates, care needs to be taken when using the idle line
    approach because the number of interrupts generated is only capped by the baud
    rate. If there is inter-character spacing (idle time between each character being
    sent), you'll wind up with an interrupt-driven approach (with even more overhead
    than normal).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, using the `receive` timeout feature means additional latency
    before processing the incoming data. As usual, there is no *one-size-fits-all* solution
    here.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the performance
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, how does this DMA stream buffer implementation compare to the ISR-based
    queue implementation? Well, on one hand, there is no comparison... *the ISR based
    implementation doesn''t work at 256,400 baud*. At this baud rate, a new character
    is received every 39 uS. With the ISR taking around 18 us to execute, we simply
    don''t have enough time to also run `printUartTask()` reliably without dropping
    data:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a06c4874-d4bf-439c-ad97-ae7f348fc6ed.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: Notice that there is absolutely no time spent on the Idle task—the CPU is completely
    consumed by attempting to keep up with the incoming data from UART2.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following screenshot, data is occasionally dropped when
    the processor is set up to receive data at 256,400 baud using an ISR that executes
    once per character:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b455799d-dae7-45c5-8b44-5b0a964e9d05.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
- en: 'Now, for comparison, here''s the (nearly) equivalent implementation using stream
    buffers and DMA:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7c73613-e70d-4ef6-bcd9-679451cc9d15.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
- en: 'The combination of stream buffers and DMA has freed up quite a bit of the CPU
    time; the queue-based ISR implementation consumed > 100% of the CPU. As we can
    see in the following processing breakdown, the total CPU usage for a stream buffer
    using DMA is around 10%:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32c61441-bf2d-4c51-8527-25d5e6805684.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
- en: 'Note the following:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The DMA-/stream buffer-based solution leaves nearly 90% of the CPU cycles available
    for other tasks.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More time is being spent printing debug statements (and pulling bytes off the
    queue) than servicing the DMA ISR.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The multi-byte stream buffer transactions also eliminate a large amount of context
    switching (notice the scheduler is only utilizing around 1% CPU), which will leave
    more contiguous time for other processing tasks.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, now that we've worked through a very simple example of each driver type,
    which one should you implement?
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a driver model
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Selecting the *best* driver for a given system depends on several different
    factors:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: How is the calling code designed?
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much delay is acceptable?
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How fast is data moving?
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What type of device is it?
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's answer these questions one by one.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: How is the calling code designed?
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the intended design of higher-level code using the driver? Will it operate
    on individual characters or bytes as they come in? Or does it make more sense
    for the higher-level code to batch transfers into blocks/frames of bytes?
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'Queue-based drivers are very useful when dealing with unknown amounts (or streams)
    of data that can come in at any point in time. They are also a very natural fit
    for code that processes individual bytes—`uartPrintOutTask` was a good example
    of this:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 基于队列的驱动程序在处理未知数量（或流）的数据时非常有用，这些数据可以在任何时间点到来。它们也非常适合处理单个字节的代码——`uartPrintOutTask`就是一个很好的例子：
- en: '[PRE25]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While ring-buffer implementations (such as the one in the preceding code) are
    perfect for streamed data, other code naturally gravitates toward operating on
    blocks of data. Say, for example, our high-level code is meant to read in one
    of the structures defined in [Chapter 9](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml), *Intertask
    Communication*, over a serial port.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然环形缓冲区实现（如前述代码中的实现）非常适合流数据，但其他代码自然倾向于操作数据块。例如，如果我们的高级代码旨在通过串行端口读取[第9章](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml)中定义的结构之一，即*任务间通信*：
- en: 'The following excerpt is from `Chapter_9/MainQueueCompositePassByValue.c`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 以下摘录来自`Chapter_9/MainQueueCompositePassByValue.c`：
- en: '[PRE26]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Rather than operate on individual bytes, it is very convenient for the receiving
    side to pull in an instance of the entire struct at once. The following code is
    designed to receive an entire copy of `LedStates_t` from a queue. After the struct
    is received, it can be operated on by simply referencing members of the struct,
    such as checking `redLEDState`, in this example:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作单个字节相比，接收方一次性拉取整个结构体的实例要方便得多。以下代码旨在从队列中接收`LedStates_t`的整个副本。在接收到结构体之后，可以通过引用结构体的成员来操作它，例如在这个例子中检查`redLEDState`：
- en: '[PRE27]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This can be accomplished by **serializing** the data structure and passing
    it over the communication medium. Our `LedStates_t` struct can be serialized as
    a block of 5 bytes. All three red, green, and blue state values can be packed
    into 3 bits of a byte and the delay time will take 4 bytes:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过**序列化**数据结构并将其通过通信介质传递来实现。我们的`LedStates_t`结构可以序列化为5字节的块。所有三个红色、绿色和蓝色状态值都可以打包到一个字节的3位中，延迟时间将占用4字节：
- en: '![](img/9a624631-0150-4a45-986d-39bf6189d06c.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a624631-0150-4a45-986d-39bf6189d06c.png)'
- en: Serialization is a broad topic in itself. There are trade-offs to be made for
    portability, ease of use, code fragility, and speed. A discussion on all of these
    points is outside the scope of this chapter. Details of endianness and the *best*
    way of serializing/deserializing this particular data structure have been purposely
    ignored in the diagram. The main takeaway is that the struct can be represented
    by a block of 5 bytes.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化本身是一个广泛的话题。在可移植性、易用性、代码脆弱性和速度之间需要做出权衡。关于所有这些点的讨论超出了本章的范围。关于端序和**最佳**序列化/反序列化此特定数据结构的方法的细节已被故意忽略在图中。主要收获是，结构体可以用5字节的块来表示。
- en: 'In this case, it makes sense for the underlying peripheral driver to operate
    on a buffer of 5 bytes, so a buffer-based approach that groups a transfer into
    a block of 5 bytes is more natural than a stream of bytes. The following pseudo-code
    outlines an approach based on the buffer-based driver we wrote in the previous
    section:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，底层外设驱动程序以5字节为一个缓冲区进行操作是有意义的，因此将传输分组为5字节的缓冲区方法比字节流更自然。以下伪代码概述了基于我们在上一节中编写的基于缓冲区的驱动程序的方案：
- en: '[PRE28]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In a situation like the previous one, we have covered two different approaches
    that can provide efficient implementations:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似前述情况的情况下，我们已经介绍了两种可以提供高效实现的不同方法：
- en: A buffer-based driver (receiving 5 bytes at a time)
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于缓冲区的驱动程序（每次接收5字节）
- en: A stream buffer (the receiving side can be configured to acquire 5 bytes at
    a time)
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流缓冲区（接收方可以配置为每次获取5字节）
- en: FreeRTOS message buffers could also be used instead of a stream buffer to provide
    a more flexible solution. Message buffers are built on top of stream buffers,
    but have a more flexible blocking configuration. They allow different message
    sizes to be configured per `receive` call, so the same buffer can be used to group
    receptions into a size of 5 bytes (or any other desired size) each time `xMessageBufferReceive`
    is called. With stream buffers, the message size is rigidly defined when creating
    the stream buffer by setting the `xTriggerLevelBytes` parameter in `xStreamBufferCreate`. 
    Unlike stream buffers, message buffers will only return full messages, not individual
    bytes.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: How much delay is acceptable?
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the exact function being implemented, minimal delay may be desired.
    In this case, buffer-based implementations can sometimes have a slight advantage.
    They allow the calling code to be set up as an extremely high priority, without
    causing significant context switching in the rest of the application.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: With a buffer-based setup, after the last byte of a message is transferred,
    the task will be notified and immediately run. This is better than having the
    high-priority task perform byte-wise parsing of the message since it will be interrupting
    other tasks continually each time a byte is received. In a byte-wise queue-based
    approach, the task waiting on the queue would need to be set to a very high priority
    if the incoming message was extremely important. This combination causes quite
    a bit of task context switching versus a buffer approach, which only has a single
    semaphore (or direct task notification) when the transfer is finished.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, timing constraints are so tight neither queues nor an entire block
    transfer may be acceptable (bytes might need to be processed as they come in).
    This approach will sometimes eliminate the need for intermediate buffers as well.
    A fully custom ISR can be written in these cases, but it won't be easily reused.
    Try to avoid lumping **business logic** (application-level logic not immediately
    required for servicing the peripheral) into ISRs whenever possible. It complicates
    testing and reduces code reuse. After a few months (or years) of writing code
    like this, you'll likely notice that you've got dozens of ISRs that look *almost* the
    same but behave in subtlety different ways, which can make for buggy systems when
    modifications to higher-level code are required.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: How fast is data moving?
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While extremely convenient, queues are a fairly expensive way to pass individual
    bytes around a system. Even an interrupt-based driver has limitations on how long
    it has to deal with incoming data. Our example used a meager 9,600 baud transfer.
    Individual characters were transferred into the queue within 40 us of being received,
    but what happens if the baud rate is 115,200 baud? Now, instead of having around
    1 character per millisecond, each character would need to be added to the queue
    in less than 9 us. A driver that takes 40 us per interrupt isn't going to be acceptable
    here, so using a simple queue approach isn't a viable option.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: We saw that the stream buffer implementation with DMA was a viable solution
    in place of a queue. Using some type of double-buffering technique for high-speed,
    continuous streams of data is critical. This becomes an especially convenient technique
    when coupled with a highly efficient RTOS primitive, such as stream buffers or
    message buffers.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Interrupts and DMA-based drivers that moved data directly into a **raw** memory
    buffer are also quite viable when speeds are high, but they don't have the convenience
    of a queue-like interface.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: What type of device are you interfacing?
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some peripherals and external devices will naturally lean toward one implementation
    or another. When receiving asynchronous data, queues are a fairly natural choice
    because they provide an easy mechanism for constantly capturing incoming data. UARTs,
    USB virtual comms, network streams, and timer captures are all very naturally
    implemented with a byte-wise queue implementation (at least at the lowest level).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous-based devices, such as a **serial peripheral interface** (**SPI**)
    and **Inter-Integrated Circuit** (**I2C**), are easily implemented with block-based
    transfers on the master side since the number of bytes is known ahead of time (the
    master needs to supply the clock signal for both bytes sent and bytes received).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: When to use queue-based drivers
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some cases where it is an advantage to use a queue as the interface
    of a driver:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: When the peripheral/application needs to receive data of an unknown length
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When data must be received asynchronously to requests
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a driver should receive data from multiple sources without blocking the
    caller
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When data rates are sufficiently slow to allow a minimum of 10's of µS per interrupt
    (when being implemented on the hardware, in this example)
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use buffer-based drivers
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some cases where raw buffer-based drivers are extremely useful are as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: When large buffers are required because large amounts of data will be received
    at once
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During transaction-based communication protocols, especially when the length
    of the received data is known in advance
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use stream buffers
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stream buffers provide speed closer to that of raw buffers, but with the added
    benefit of providing an efficient queue API. They can generally be used anywhere
    a standard queue would be used (as long as there is only one consumer task). Stream
    buffers are also efficient enough to be used in place of raw buffers, in many
    cases. As we saw in the `mainUartDMAStreamBufferCont.c` example, they can be combined
    with circular DMA transfers to provide true continuous data capture, without using
    a significant number of CPU cycles.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: These are just some of the considerations you'll likely face when creating drivers;
    they are mainly aimed at communication peripherals (since that's what our examples
    covered). There are also some considerations to be made when choosing to use third-party
    libraries and drivers.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party libraries (STM HAL)
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve been following along closely, you may have noticed a few things:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: STM HAL (the vendor-supplied hardware abstraction layer) is used for initial
    peripheral configuration. This is because HAL does a very good job of making peripheral
    configuration easy. It is also extremely convenient to use tools such as STM Cube
    to generate some boilerplate code as a point of reference when first interacting
    with a new chip.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When it is time to implement details of interrupt-driven transactions, we''ve
    been making a lot of calls directly to MCU peripheral registers, rather than letting
    HAL manage transactions for us. There were a couple of reasons for this:'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We wanted to be closer to the hardware to get a better understanding of how
    things were really working in the system.
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the setups weren't directly supported by HAL, such as DMA double buffering.
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, you should use as much vendor-supplied code as you (or your project/company)
    are comfortable with. If the code is well written and works reliably, then there
    *usually* aren't too many arguments for *not* using it.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, here are some potential issues when using vendor-supplied
    drivers:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: They may use polling instead of interrupts or DMA.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tying into interrupts may be cumbersome or inflexible.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is potentially *lots* of extra overhead since many chips/use cases are
    likely covered by drivers (they need to solve *everyone's* problems, not just
    yours).
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It might take longer to fully grasp and understand a complex API than working
    directly with the peripheral hardware (for simple peripherals).
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are examples of when to write **bare-metal** drivers:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: When a vendors driver is broken/buggy
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When speed matters
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an exotic configuration is required
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a learning exercise
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, transitioning between third-party drivers and your own drivers would
    be perfectly seamless. If it isn't, it means that the higher-level code is tightly
    coupled to the hardware. This tight coupling is perfectly acceptable for sufficiently
    small *one-off* and *throw-away* projects, but if you're attempting to develop
    a code base for the long term, investing in creating a loosely coupled architecture
    will pay dividends. Having loose coupling (eliminating dependencies between the
    exact driver implementation and higher-level code) also provides flexibility in
    the implementation of the individual components. Loose coupling ensures transitioning
    between custom drivers and third-party drivers doesn't necessitate a major rewrite
    of high-level code. Loose coupling also makes testing small portions of the code
    base in isolation possible—see [Chapter 12](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml)*,
    Tips on Creating Well-Abstracted Architecture*, for details.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we introduced three different ways of implementing low-level
    drivers that interface with hardware peripherals in the MCU. Interrupts and polled-
    and DMA-based drivers were all covered through examples and their performance
    was analyzed and compared using SEGGER SystemView. We also covered three different
    ways that FreeRTOS can interact with ISRs: semaphores, queues, and stream buffers.
    Considerations for choosing between the implementation options were also discussed,
    as well as when it is appropriate to use third-party peripheral drivers (STM HAL)
    and when "rolling your own" is best.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: To get the most out of this chapter, you're encouraged to run through it on
    actual hardware. The development board was chosen (in part) with the hope that
    you might have access to Arduino shields. After running through the examples,
    an excellent next step would be to develop a driver for a shield or another piece
    of real-world hardware.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was really just the tip of the iceberg when it comes to driver
    implementation. There are many additional approaches and techniques that can be
    used when creating efficient implementations, from using different RTOS primitives
    beyond what is presented in this chapter to configuring MCU-specific functionality.
    Your designs don't need to be limited by what happens to be provided by a vendor.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a solid understanding of the many different ways low-level
    drivers can be implemented. In the next chapter, we'll take a look at how these
    drivers can be safely presented to higher-level code across multiple tasks. Providing
    easy access to drivers makes developing the final application fast and flexible.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    of this chapter''s material. You will find the answers in the *Assessments* section
    of the appendix:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: What type of driver is more complicated to write and use?
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Polled
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt-driven
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'True or false: In FreeRTOS, it is possible to call any RTOS function from any
    ISR?'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：在FreeRTOS中，是否可以从任何中断服务例程（ISR）中调用任何RTOS函数？
- en: 'True'
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是
- en: 'False'
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否
- en: 'True or false: When using an RTOS, interrupts are constantly fighting the scheduler
    for CPU time?'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：在使用实时操作系统（RTOS）时，中断始终在与调度器争夺CPU时间？
- en: 'True'
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是
- en: 'False'
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否
- en: Which technique for a peripheral driver requires the fewest CPU resources when
    transferring large amounts of high-speed data?
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在传输大量高速数据时，哪种外围设备驱动技术需要的CPU资源最少？
- en: Polling
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票
- en: Interrupt
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断
- en: DMA
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMA
- en: What does DMA stand for?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMA代表什么？
- en: Name one case when using a raw buffer-based driver is *not* a good idea.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一个使用基于原始缓冲区的驱动程序不是好主意的情况。
- en: Further reading
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Chapter 4* in the *RM0410 STM32F76xxx* reference manual (*USART*)'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RM0410 STM32F76xxx*参考手册的*第4章*（*USART*）'
- en: B1.5.4, **Exception priorities and preemption** section in the *Arm®v7-M Architecture*
    reference manual
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B1.5.4，在*Arm®v7-M Architecture*参考手册的**异常优先级和抢占**部分
- en: FreeRTOS.org's explanation of CortexM priorities, at [https://www.freertos.org/RTOS-Cortex-M3-M4.html](https://www.freertos.org/RTOS-Cortex-M3-M4.html)
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeRTOS.org对CortexM优先级的解释，见[https://www.freertos.org/RTOS-Cortex-M3-M4.html](https://www.freertos.org/RTOS-Cortex-M3-M4.html)
