<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating Classes</h1>
                
            
            
                
<p class="chapter-content">This chapter will cover the following recipes:</p>
<ul>
<li>Making a UCLASS – deriving from UObject</li>
<li>Creating a blueprint from your custom UCLASS</li>
<li>Creating a user-editable UPROPERTY</li>
<li>Accessing a UPROPERTY from blueprints</li>
<li>Specifying a UCLASS as the type of a UPROPERTY</li>
<li>Instantiating UObject-derived classes (ConstructObject&lt;&gt; and NewObject &lt;&gt;)</li>
<li>Destroying UObject-derived classes</li>
<li>Creating a USTRUCT</li>
<li>Creating a UENUM()</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>This chapter focuses on how to create C++ classes and structs that integrate well with the UE4 blueprints editor.</p>
<p>The classes we will be creating in this chapter are graduated versions of the regular C++ classes, and are called <kbd>UCLASS</kbd>.</p>
<p>A <kbd>UCLASS</kbd> is just a C++ class with a whole lot of UE4 macro decoration on top. The macros generate additional C++ header code that enables integration with the UE4 editor itself.</p>
<p>Using <kbd>UCLASS</kbd> is a great practice to get into. The <kbd>UCLASS</kbd> macro, if configured correctly, can possibly make your <kbd>UCLASS</kbd> blueprintable, which can enable your custom C++ objects to be used within Unreal's visual-scripting language blueprints. This can be really useful if you have designers on your team, as they can access and tweak aspects of your project without having to dive into code.</p>
<p>We can have blueprint's visually editable properties (<kbd>UPROPERTY</kbd>) with handy UI widgets such as text fields, sliders, and model selection boxes. You can also have functions (such as <kbd>UFUNCTION</kbd>) that are callable from within a blueprints diagram. Both of these are shown in the following screenshots:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/48b7d5fd-8b17-41f9-b7fd-2d363741cd9e.jpg"/></p>
<p>On the left, two <kbd>UPROPERTY</kbd> decorated class members (a <kbd>UTexture</kbd> reference and an <kbd>FColor</kbd>) show up for editing in a C++ class's blueprint. On the right, a C++ <kbd>GetName</kbd> function marked as <kbd>BlueprintCallable UFUNCTION</kbd> shows up as callable from a blueprints diagram.</p>
<p>Code generated by the <kbd>UCLASS</kbd> macro will be located in a <kbd>ClassName.generated.h</kbd> file, which will be the last <kbd>#include</kbd> required in your <kbd>UCLASS</kbd> header file, <kbd>ClassName.h</kbd>.</p>
<p>You will notice that the sample objects we create in this class, even when blueprintable, will not be placed in levels. That is because in order to be placed in levels, your C++ class must derive from the <kbd>Actor</kbd> base class, or a subclass below it. See <a href="eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml">Chapter 4</a>, <em>Actors and Components</em>, for further details.</p>
<p>UE4 code is, typically, very easy to write and manage once you know the patterns. The code we write to derive from another <kbd>UCLASS</kbd>, or to create a <kbd>UPROPERTY</kbd> or <kbd>UFUNCTION</kbd> instance, is very consistent. This chapter provides recipes for common UE4 coding tasks revolving around basic <kbd>UCLASS</kbd> derivation, property and reference declaration, construction, destruction, and general functionality.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and the requirements for them can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml"/><a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making a UCLASS – deriving from UObject</h1>
                
            
            
                
<p>When coding with C++, you can have your own code that compiles and runs as native C++ code, with appropriate calls to the <kbd>new</kbd> and <kbd>delete</kbd> operators to create and destroy your custom objects. Native C++ code is perfectly acceptable in your UE4 project as long as your <kbd>new</kbd> and <kbd>delete</kbd> calls are appropriately paired so that no memory leaks are present in your code.</p>
<p>You can, however, also declare custom C++ classes, which behave like UE4 classes, by declaring your custom C++ objects using the <kbd>UCLASS</kbd> macro. The <kbd>UCLASS</kbd> macro tells the class to make use of UE4's smart pointers and memory management routines for allocation and de-allocation according to their smart pointer rules, which can be loaded and read by the UE4 editor automatically, and can optionally be accessed from blueprints.</p>
<p>Note that when you use the <kbd>UCLASS</kbd> macro, your <kbd>UCLASS</kbd> object's creation and destruction must be completely managed by UE4: you must use the <kbd>ConstructObject</kbd> function to create an instance of your object (not the C++ native keyword <kbd>new</kbd>), and call the <kbd>UObject::ConditionalBeginDestroy()</kbd> function to destroy the object (not the C++ native keyword <kbd>delete</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, we will outline how to write a C++ class that uses the <kbd>UCLASS</kbd> macro to enable managed memory allocation and de-allocation, as well as to permit access from the UE4 editor and blueprints. To complete this recipe, you will need a UE4 project that you can add new code to.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create your own <kbd>UObject</kbd> derivative class, follow these steps:</p>
<ol>
<li>From your running project, select File | New C++ Class inside the UE4 editor.</li>
<li>In the Add C++ Class dialog that appears, go to the upper-right-hand side of the window and tick the Show All Classes checkbox:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/4dc61190-34b3-4777-a3b1-dbd680a1c64b.png"/></p>
<ol start="3">
<li class="mce-root">Select <kbd>Object</kbd> (top of the hierarchy) as the parent class to inherit from, and then click on Next.</li>
</ol>
<p>Note that although <kbd>Object</kbd> will be written in the dialog box, in your C++ code, the C++ class you will be deriving from is actually <kbd>UObject</kbd> with a leading uppercase <kbd>U</kbd>. This is the naming convention of UE4.<br/>
<br/>
<kbd>UCLASS</kbd> deriving from <kbd>UObject</kbd> (on a branch other than <kbd>Actor</kbd>) must be named with a leading <kbd>U</kbd>.<br/>
<br/>
<kbd>UCLASS</kbd> deriving from <kbd>Actor</kbd> must be named with a leading <kbd>A</kbd> (<a href="eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml">Chapter 4</a>, <em>Actors and Components</em>).<br/>
<br/>
C++ classes (that are not <kbd>UCLASS</kbd>) deriving from nothing do not have a naming convention, but can be named with a leading <kbd>F</kbd> (for example, <kbd>FAssetData</kbd>), if preferred.<br/>
<br/>
Direct derivatives of <kbd>UObject</kbd> will not be level-placeable, even if they contain visual representation elements such as <kbd>UStaticMeshes</kbd>. If you want to place your object inside a UE4 level, you must at least derive from the <kbd>Actor</kbd> class or beneath it in the inheritance hierarchy. See <a href="eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml">Chapter 4</a>, <em>Actors and Components,</em> for more information how to derive from the <kbd>Actor</kbd> class for a level-placeable object.</p>
<div><br/>
This chapter's example code will not be placeable in the level, but you can create and use blueprints based on the C++ classes that we write in this chapter in the UE4 editor.</div>
<ol start="4">
<li>Name your new <kbd>Object</kbd> derivative something appropriate for the object type that you are creating. I'll call mine <kbd>UserProfile</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/17828513-6e03-4510-8764-731dddf869c3.png"/></p>
<p style="padding-left: 60px">This comes off as <kbd>UUserObject</kbd> in the naming of the class in the C++ file that UE4 generates to ensure that the UE4 conventions are followed (In C++, class names with a <kbd>UCLASS</kbd> are preceded with a leading <kbd>U</kbd>).</p>
<ol start="5">
<li>Click on Create Class and the files should be created after file compilation is completed. Afterwards, Visual Studio should open (otherwise, open the solution by going to File | Open Visual Studio), and will open up the <kbd>.cpp</kbd> file of the class we just created (<kbd>UserProfile.cpp</kbd>). Open the header rule (<kbd>UserProfile.h</kbd>) for your class and ensure your class file has the following form:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/NoExportTypes.h"<br/>#include "UserProfile.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_02_API UUserProfile : public UObject<br/>{<br/>  GENERATED_BODY()<br/>  <br/>};<br/><br/></pre>
<ol start="6">
<li>Compile and run your project. You can now use your custom <kbd>UCLASS</kbd> object inside Visual Studio, as well as inside the UE4 editor. See the following recipes for more details on what you can do with it.</li>
</ol>
<p>How to create and destroy your <kbd>UObject</kbd>-derived classes is outlined in the <em>Instantiating UObject-derived classes (ConstructObject &lt;&gt; and NewObject &lt;&gt;)</em> and <em>Destroying UObject-derived classes</em> recipes later in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>UE4 generates and manages a significant amount of code for your custom <kbd>UCLASS</kbd>. This code is generated as a result of the use of the UE4 macros such as <kbd>UPROPERTY</kbd>, <kbd>UFUNCTION</kbd>, and the <kbd>UCLASS</kbd> macro itself. The generated code is put into <kbd>UserProfile.generated.h</kbd>. You must <kbd>#include</kbd> the <kbd>UCLASSNAME.generated.h</kbd> file with the <kbd>UCLASSNAME.h</kbd> file for compilation to succeed, which is why, by default, the editor includes this automatically. Without including the <kbd>UCLASSNAME.generated.h</kbd> file, compilation would fail.</p>
<p>It is also important to note that the <kbd>UCLASSNAME.generated.h</kbd> file must be included as the last <kbd>#include</kbd> in the list of <kbd>#include</kbd> in <kbd>UCLASSNAME.h</kbd>.</p>
<p>Here's a correct example:</p>
<pre>#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/NoExportTypes.h"<br/><br/>#include &lt;list&gt; // Newly added include<br/><br/>// CORRECT: generated file is the last file included<br/>#include "UserProfile.generated.h"</pre>
<p>And here is an incorrect one:</p>
<pre>#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/NoExportTypes.h"<br/>#include "UserProfile.generated.h"<br/><br/>// WRONG: NO INCLUDES AFTER .generated.h FILE<br/>#include &lt;list&gt; // Newly added include</pre>
<p>If the <kbd>UCLASSNAME.generated.h</kbd> file is not the last item within the list of <kbd>#include</kbd> statements shown in the previous code sample, you will get the following error:</p>
<pre>&gt;&gt; #include found after .generated.h file - the .generated.h file <br/> should always be the last #include in a header</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are a bunch of keywords that we want to discuss here, which modify the way a <kbd>UCLASS</kbd> behaves. A <kbd>UCLASS</kbd> can be marked as follows:</p>
<ul>
<li><kbd>Blueprintable</kbd>: This means that you want to be able to construct a blueprint from the Class Viewer inside the UE4 editor (when you right-click it, Create Blueprint Class... becomes available). Without the <kbd>Blueprintable</kbd> keyword, the Create Blueprint Class... option will not be available for your <kbd>UCLASS</kbd>, even if you can find it from within the Class Viewer and right-click on it:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/2c569908-51ef-4c1f-b399-4f45af55f714.jpg" style="width:48.92em;height:10.92em;"/></p>
<ul>
<li>The Create Blueprint Class... option is only available if you specify <kbd>Blueprintable</kbd> in your <kbd>UCLASS</kbd> macro definition. </li>
<li><kbd>BlueprintType</kbd>: Using this keyword implies that the <kbd>UCLASS</kbd> is usable as a variable from another blueprint. You can create blueprint variables from the Variables group in the left-hand panel of any blueprint's EventGraph.</li>
</ul>
<ul>
<li><kbd>NotBlueprintType</kbd>: Using this keyword specifies that you cannot use this blueprint variable type as a variable in a blueprints diagram. Right-clicking the <kbd>UCLASS</kbd> name in the Class Viewer will not show Create Blueprint Class... in its context menu:</li>
</ul>
<div><img src="img/816ad77a-791c-42fc-b5dd-f517e92db546.jpg" style="width:16.75em;height:14.92em;"/></div>
<p>You may be unsure whether to declare your C++ class as a <kbd>UCLASS</kbd> or not. The general rule of thumb is to use <kbd>UCLASS</kbd> unless you have a good reason not to. Unreal Engine 4's code is very well-written and has been tested thoroughly by this point. If you like smart pointers, you may find that <kbd>UCLASS</kbd> not only makes for safer code, but also makes the entire code base more coherent and more consistent.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>To add additional programmable <kbd>UPROPERTY</kbd> to the blueprints diagrams, see the <em>Creating a user-editable UPROPERTY</em> recipe</li>
<li>For details on referring to instances of your <kbd>UCLASS</kbd> using appropriate smart pointers, refer to <a href="03463b9f-098a-445f-97b4-291a2b6182e8.xhtml">Chapter 3</a>, <em>Memory Management, Smart Pointers, and Debugging</em></li>
<li class="mce-root">For more information on <kbd>UCLASS</kbd>, <kbd>UPROPERTY</kbd>, and all of the other similar macros and how they are used by UE4, check out <a href="https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection">https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection</a><a href="https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection"/></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a blueprint from your custom UCLASS</h1>
                
            
            
                
<p>Blueprinting is just the process of deriving a blueprint class for your C++ object. Creating blueprint-derived classes from your UE4 objects allows you to edit the custom <kbd>UPROPERTY</kbd> visually inside the editor. This avoids hardcoding any resources into your C++ code. In addition, your C++ class to be placeable within the level, it must be blueprinted first. But this is only possible if the C++ class underlying the blueprint is an <kbd>Actor</kbd> class-derivative.</p>
<p>There is a way to load resources (such as textures) using <kbd>FStringAssetReferences</kbd> and <kbd>StaticLoadObject</kbd>. These pathways to loading resources (by hardcoding path strings into your C++ code) are generally discouraged, however. Providing an editable value in a <kbd>UPROPERTY()</kbd> and loading from a proper concretely typed asset reference is a much better practice.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You need to have a constructed <kbd>UCLASS</kbd> that you'd like to derive a <kbd>Blueprint</kbd> class from (see the <em>Making a UCLASS – deriving from UObject</em> recipe earlier in this chapter) to follow this recipe. You must have also marked your <kbd>UCLASS</kbd> as <kbd>Blueprintable</kbd> in the <kbd>UCLASS</kbd> macro for blueprinting to be possible inside the engine.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>To blueprint your <kbd>UserProfile</kbd> class, first ensure that <kbd>UCLASS</kbd> has the <kbd>Blueprintable</kbd> tag in the <kbd>UCLASS</kbd> macro. This should look as follows:</li>
</ol>
<pre style="padding-left: 60px">UCLASS( <strong>Blueprintable</strong> ) 
class CHAPTER2_API UUserProfile : public UObject </pre>
<ol start="2">
<li>Compile your code.</li>
</ol>
<ol start="3">
<li>Find the <kbd>UserProfile</kbd> C++ class in the Class Viewer (Window | Developer Tools | Class Viewer). Since the previously created <kbd>UCLASS</kbd> does not derive from <kbd>Actor</kbd>, to find your custom <kbd>UCLASS</kbd>, you must turn off Filters | Actors Only in the Class Viewer (which is checked by default):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1afbf2e4-e1af-4d41-8e0b-a0947e5e6ba6.jpg" style="width:26.08em;height:10.25em;"/></p>
<p style="padding-left: 60px"> If you don't do this, then your custom C++ class may not show!</p>
<p>Keep in mind that you can use the small search box inside the Class Viewer to easily find the <kbd>UserProfile</kbd> class by starting to type it in:<br/>
<br/>
<img src="img/eb3b6c95-62c1-4582-b2fe-2d367fc21356.jpg" style="width:27.67em;height:5.58em;"/><br/></p>
<ol start="4">
<li>Find your <kbd>UserProfile</kbd> class in the Class Viewer, right-click on it, and create a blueprint from it by selecting Create Blueprint....</li>
<li>Name your blueprint. Some prefer to prefix the blueprint class name with <kbd>BP_</kbd>.<br/>
You may choose to follow this convention; just be sure to be consistent.</li>
<li>You will be able to edit any fields that are created for each <kbd>UserProfile</kbd> blueprint instance you create.</li>
</ol>
<p>If the blueprint editor does not open automatically, you can open it by double-clicking on the file in the Content Browser.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Any C++ class you create that has the <kbd>Blueprintable</kbd> tag in its <kbd>UCLASS</kbd> macro can be blueprinted within the UE4 editor. A blueprint allows you to customize properties on the C++ class in the visual GUI interface of UE4.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a user-editable UPROPERTY</h1>
                
            
            
                
<p>Each <kbd>UCLASS</kbd> that you declare can have any number of <kbd>UPROPERTY</kbd> declared for it within it. Each <kbd>UPROPERTY</kbd> can be a visually editable field, or a blueprints-accessible data member of the <kbd>UCLASS</kbd>.</p>
<p>There are a number of qualifiers that we can add to each <kbd>UPROPERTY</kbd>, which change the way it behaves from within the UE4 Editor, such as <kbd>EditAnywhere</kbd> (specifying that the <kbd>UPROPERTY</kbd> can be changed through code or in the editor), and <kbd>BlueprintReadWrite</kbd> (specifying that blueprints can both read and write the variable at any time, in addition to the C++ code being allowed to do so).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To use this recipe, you should have a C++ project that you can add C++ code to. In addition, you should have completed the preceding recipe, <em>Making a UCLASS – deriving from UObject</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>First, we will need to mark the class as <kbd>Blueprintable</kbd> and then add the following members to your <kbd>UCLASS</kbd> declaration, which are shown in bold:</li>
</ol>
<pre style="padding-left: 60px">/**<br/> * <strong>UCLASS macro options sets this C++ class to be</strong><br/><strong> * Blueprintable within the UE4 Editor</strong><br/> */<br/>UCLASS( <strong>Blueprintable</strong> )<br/>class CHAPTER_02_API UUserProfile : public UObject<br/>{<br/>  GENERATED_BODY()<br/><br/><strong>public:</strong><br/><strong>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)</strong><br/><strong>  float Armor;</strong><br/><br/><strong>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)</strong><br/><strong>  float HpMax;</strong><br/>};</pre>
<p class="mce-root"/>
<ol start="2">
<li>Return to Unreal Editor and then hit the Compile button to update our code.</li>
<li>Once updated, create a blueprint of your <kbd>UObject</kbd> class derivative, if it hasn't been created already.</li>
</ol>
<p style="padding-left: 60px">This can be done in the same way that we saw in the previous recipe, but it is also possible to do by hand, which we will do now.</p>
<ol start="4">
<li>To do this, go to the Content Browser tab and click on the folder icon to select what section of the project you want to work in. From the window that pops up, select the Content section:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/cd4114e3-97a9-42b7-abb8-562944beaa03.png"/></p>
<p>Selecting the Content folder in the Content Browser</p>
<div><ol start="5">
<li>From there, select the Add New button and then select Blueprint Class:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c79a081c-e525-4674-84b1-070f83273e06.png"/></p>
<p>Creating a Blueprint Class from the Content Browser</p>
<ol start="6">
<li>From the Pick Parent Class menu, you'll see some buttons for Common Classes. Below that, you'll see the All Classes option with an arrow to click on to expand it. From there, type in the name of your class (in our case, <kbd>UserProfile</kbd>) and then select it from the list. Afterwards, click on the Select button: </li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/818ac6d6-2da2-4908-bea0-7f890a911271.png"/></p>
<ol start="7">
<li>From there, you'll see the item appear in the <kbd>Content Browser</kbd>, where you can rename the instance to whatever you'd like; I named mine <kbd>MyProfile</kbd>.</li>
<li>Once created, we can open the blueprint in the UE4 Editor by double-clicking it.</li>
</ol>
<ol start="9">
<li>You can now specify values in blueprints for the default values of these new <kbd>UPROPERTY</kbd> fields:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/519b9463-1cdd-469b-b1d5-2e8039763b7d.png"/></p>
<p>Since the blueprint is empty, it may open as a data-only blueprint that does not include the middle and left-hand side sections. To see the full blueprint menu, you may need to click Open Full Blueprint Editor at the top of the menu to make the screen look like the one in the previous screenshot. However, the variables should still be visible and modifiable, either way.</p>
<ol start="10">
<li>Specify the per-instance values by creating new instances of the blueprint and editing the values on the object that's placed (by double-clicking on them).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The parameters that are passed to the <kbd>UPROPERTY()</kbd> macro specify a couple of important pieces of information regarding the variable. In the preceding example, we specified the following:</p>
<ul>
<li><kbd>EditAnywhere</kbd>: This means that the property can be edited either directly from the Blueprint, or on each instance of the <kbd>UClass</kbd> object as placed<br/>
in the game level. Contrast this with the following:</li>
<li style="padding-left: 30px"><kbd>EditDefaultsOnly</kbd>: The blueprint's value is editable, but it is not editable on a per-instance basis.</li>
<li style="padding-left: 30px"><kbd>EditInstanceOnly</kbd>: This would allow editing of the property in the game-level instances of the <kbd>UClass</kbd> object, and not on the base blueprint itself.</li>
</ul>
<ul>
<li><kbd>BlueprintReadWrite</kbd>: This indicates that the property is both readable and writable from the blueprints diagrams. <kbd>UPROPERTY()</kbd> with <kbd>BlueprintReadWrite</kbd> must be public members; otherwise, compilation will fail. Contrast this with the following:</li>
<li style="padding-left: 30px"><kbd>BlueprintReadOnly</kbd>: The property must be set from C++ and cannot be changed from the blueprints.</li>
<li><kbd>Category</kbd>: You should always specify a <kbd>Category</kbd> for your <kbd>UPROPERTY()</kbd> as it's a good practice to stay organized. The <kbd>Category</kbd> determines which submenu the <kbd>UPROPERTY()</kbd> will appear under in the property editor. All <kbd>UPROPERTY()</kbd> specified under <kbd>Category=Stats</kbd> will appear in the same <kbd>Stats</kbd> area in the blueprints editor. If no category is specified, the <kbd>UPROPERTY</kbd> will appear under the default category, <kbd>UserProfile</kbd> (or whatever one called their class).</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It is important to understand the entire process, which is why we went through everything here, but you can also create a Blueprint class from a script by right-clicking on the class from the C++ Classes section of the Content Browser and then selecting Create Blueprint class based on UserProfile. Refer to the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/244a29c5-a663-4594-999e-33369eb41c2c.png" style="width:42.33em;height:23.92em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>A complete <kbd>UPROPERTY</kbd> listing is located at <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html">https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html</a>. Give it a browse.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Accessing a UPROPERTY from blueprints</h1>
                
            
            
                
<p>Accessing a <kbd>UPROPERTY</kbd> from blueprints is fairly simple. The member must be exposed as a <kbd>UPROPERTY</kbd> on the member variable that you want to access from your blueprints diagram. You must qualify the <kbd>UPROPERTY</kbd> in your macro declaration as being either <kbd>BlueprintReadOnly</kbd> or <kbd>BlueprintReadWrite</kbd> to specify whether you want the variable to be either readable (only) from Blueprints, or even writable from Blueprints.</p>
<p>You can also use the special value <kbd>BlueprintDefaultsOnly</kbd> to indicate that you only want the default value (before the game starts) to be editable from the blueprints editor. <kbd>BlueprintDefaultsOnly</kbd> indicates that the data member cannot be edited from Blueprints at runtime.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create some <kbd>UObject</kbd>-derivative class, specifying both <kbd>Blueprintable</kbd> and <kbd>BlueprintType</kbd>, such as in the following code, using the same class we created previously:</li>
</ol>
<pre style="padding-left: 60px">/**<br/> * UCLASS macro options sets this C++ class to be<br/> * Blueprintable within the UE4 Editor<br/> */<br/>UCLASS(Blueprintable<strong>, BlueprintType</strong>)<br/>class CHAPTER_02_API UUserProfile : public UObject<br/>{<br/>  GENERATED_BODY()<br/><br/>public:<br/>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)<br/>  float Armor;<br/><br/>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)<br/>  float HpMax;<br/><br/>  <strong>UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)</strong><br/><strong>  FString Name;</strong><br/>};</pre>
<p style="padding-left: 60px">The <kbd>BlueprintType</kbd> declaration in the <kbd>UCLASS</kbd> macro is required to use the <kbd>UCLASS</kbd> as a type within a blueprints diagram.</p>
<ol start="2">
<li>Save and compile your code.</li>
<li>Within the UE4 editor, derive a blueprint class from the C++ class if needed, as shown in the previous recipe or in the <em>Creating a Blueprint from your custom UCLASS</em> recipe.</li>
<li>Double-click on your instance and change the Name variable to have a new value, for instance, <kbd>Billy</kbd>. Afterwards, hit the Compile button to save all of your changes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1472fe26-f9e5-48df-8842-a2e18cc4e7a9.png" style="width:80.50em;height:26.25em;"/></p>
<ol start="5">
<li>In a blueprints diagram that allows function calls (such as the Level Blueprint, which is accessible via Blueprints | Open Level Blueprint), we can now try to make use of the variable we added. Perhaps we can try printing the Name property whenever the game starts.</li>
</ol>
<ol start="6">
<li>To have something happen at the start of the game, we will need to create a BeginPlay event. You can do this by right-clicking in the blueprint graph and selecting Add Event | Event BeginPlay:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/48f3b87f-6a3d-4555-8329-bf4efb26de61.png"/></p>
<p style="padding-left: 60px">Now, need to create an instance of the class. Since it's derived from <kbd>UObject</kbd>, we cannot instantiate it from drag and drop, but we can create something through the Construct Object from Class Blueprint node.</p>
<ol start="7">
<li>Right-click to the right of the node that was just created and from the search bar, type in <kbd>construct</kbd> and select the Construct Object from Class node from the list:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8923bed8-7698-4ffa-a1cd-64ab300272ae.png" style="width:26.50em;height:26.50em;"/></p>
<ol start="8">
<li>Next, connect the line from the right of the Event BeginPlay node to the left of the Construct Node by dragging the arrow on the bottom-right of the Event BeginPlay node to the arrow on the left-hand side of the Construct Node and releasing it.</li>
</ol>
<p>Navigating blueprints diagrams is easy. Right-click and drag to pan a blueprints diagram, <em>Alt</em> + right-click + drag, or use the mouse wheel to zoom. You can left-click and drag any node to position it wherever you want. You can also select multiple nodes at the same time and move them all together. You can find more information on blueprints here: <a href="https://docs.unrealengine.com/en-US/Engine/Blueprints/BestPractices">https://docs.unrealengine.com/en-US/Engine/Blueprints/BestPractices</a>.<a href="https://docs.unrealengine.com/en-US/Engine/Blueprints/BestPractices"/></p>
<ol start="9">
<li>Under the Class section, click on the dropdown and type in the name of the blueprint you created (MyProfile) and select it from the list.</li>
</ol>
<ol start="10">
<li>You also need to select something for the Outer property that will be the owner of the object. Click and drag the blue circle and move the mouse to the left of the node, and then let go of the mouse to create a new node. When the menu pops up, type in the word <kbd>self</kbd> and then select the Get a reference to self option. If all went well, your blueprint should look something like this: </li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/bf976ee7-696b-4cbb-8a58-2eda3acc5830.png" style="width:30.42em;height:9.58em;"/></p>
<p style="padding-left: 60px">This will create a variable using the information from the MyProfile instance we created earlier. However, we have no way to use it yet unless we make it a variable. Drag and drop this to the right of the Return Value property and select Promote to a variable. This will automatically create a variable called <kbd>NewVar_0</kbd> and create a Set node, but you can rename it to whatever you want using the menu on the left-hand side of the menu. </p>
<ol start="11">
<li>To the right of the SET node, drag and drop the white arrow on the top right of the node and create a Print Text node.</li>
<li>We now need something to print, and the Name property will work perfectly for this. To the right of the SET node, drag and drop the blue node and select the Variables | Stats | Get Name node.</li>
<li>Finally, connect the Name value to the In Text property of the Print Text node. It will automatically create a conversion node to change the name string into a Text object that it can understand.</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/223a2a1c-2c4f-4e5c-a49a-bfc510832fc8.png"/></p>
<p>In the end, the entire blueprint should look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f4713373-7763-48e8-b6d5-da8ae46aea27.png"/></p>
<p>The completed blueprint</p>
<p>If all went well, you should be able to hit the Compile button and then play the game by hitting the Play button on the top of the menu:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/eec7e943-df92-4160-8faa-f5435887ca15.png" style="width:49.08em;height:41.25em;"/></p>
<p>Upon playing, you should see Billy show up on the screen, just as we set previously!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p><kbd>UPROPERTY</kbd>s are automatically written <kbd>Get</kbd>/<kbd>Set</kbd> methods for UE4 classes and can be used to access and assign values for properties, as we just saw.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Specifying a UCLASS as the type of a UPROPERTY</h1>
                
            
            
                
<p>So, you've constructed some custom <kbd>UCLASS</kbd>, intended for use inside UE4. We created one in the editor using blueprints in the previous recipe, but how do you instantiate them in C++? Objects in UE4 are reference-counted and memory-managed objects, so you should not allocate them directly using the C++ keyword <kbd>new</kbd>. Instead, you'll have to use a function called <kbd>ConstructObject</kbd> so that we can instantiate your <kbd>UObject</kbd> derivative.</p>
<p><kbd>ConstructObject</kbd> doesn't just take the C++ class name of the object you are creating; it also requires a blueprint class derivative of the C++ class (a <kbd>UClass*</kbd> reference). A <kbd>UClass*</kbd> reference is just a pointer to a blueprint.</p>
<p>How do we instantiate an instance of a particular blueprint from the C++ code? C++ code does not, and should not, know concrete <kbd>UCLASS</kbd> names, since these names are created and edited in the UE4 editor, which you can only access after compilation. We need a way to somehow hand back the blueprint class name to instantiate with the C++ code.</p>
<p>The way we do this is by having the UE4 programmer select the <kbd>UClass</kbd> that the C++ code is to use from a simple drop-down menu listing all the blueprints available (derived from a particular C++ class) inside the UE4 editor. To do this, we simply have to provide a user-editable <kbd>UPROPERTY</kbd> with a <kbd>TSubclassOf&lt;C++ClassName&gt;</kbd> typed variable. Alternatively, you can use <kbd>FStringClassReference</kbd> to achieve the same objective.</p>
<p> <kbd>UCLASS</kbd> should be considered as resources to the C++ code, and their names should never be hardcoded into the code base.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In your UE4 code, you're often going to need to refer to different <kbd>UCLASS</kbd> in the project. For example, say you need to know the <kbd>UCLASS</kbd> of the player object so that you can use <kbd>SpawnObject</kbd> in your code on it. Specifying a <kbd>UCLASS</kbd> from C++ code is extremely awkward, because the C++ code is not supposed to know about the concrete instances of the derived <kbd>UCLASS</kbd> that were created in the blueprints editor at all. Just as we don't want to bake specific asset names into the C++ code, we don't want to hardcode derived blueprints class names into the C++ code.</p>
<p>So, we use a C++ variable (for example, <kbd>UClassOfPlayer</kbd>), and select that from a blueprints dialog in the UE4 editor. You can do so using a <kbd>TSubclassOf</kbd> member or an <kbd>FStringClassReference</kbd> member.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Navigate to the C++ class that you'd like to add the <kbd>UCLASS</kbd> reference member to. </li>
<li>From inside a <kbd>UCLASS</kbd>, use code of the following form to declare a <kbd>UPROPERTY</kbd> that allows for the selection of a <kbd>UClass</kbd> (blueprint class) that derives from <kbd>UObject</kbd> in the hierarchy:</li>
</ol>
<pre style="padding-left: 60px">UCLASS(Blueprintable, BlueprintType)<br/>class CHAPTER_02_API UUserProfile : public UObject<br/>{<br/>  GENERATED_BODY()<br/><br/>public:<br/>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)<br/>  float Armor;<br/><br/>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)<br/>  float HpMax;<br/><br/>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)<br/>  FString Name;<br/><br/><strong>  // Displays any UClasses deriving from UObject in a dropdown </strong><br/><strong>  // menu in Blueprints</strong><br/><strong>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Unit)</strong><br/><strong>  TSubclassOf&lt;UObject&gt; UClassOfPlayer; </strong><br/><br/><strong>  // Displays string names of UCLASSes that derive from</strong><br/><strong>  // the GameMode C++ base class</strong><br/><strong>  UPROPERTY( EditAnywhere, meta=(MetaClass="GameMode"), </strong><br/><strong>             Category = Unit )</strong><br/><strong>  FStringClassReference UClassGameMode;</strong><br/>};</pre>
<p>Visual Studio may underline the <kbd>UClassOfPlayer</kbd> variable and say that an incomplete class is not allowed. This is one of those cases when Visual Studio errors aren't right and can be ignored as it will compile fine inside UE4.</p>
<ol start="3">
<li>Blueprint the C++ class, and then open that blueprint:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/dbb893f3-d100-42be-afc7-4fc7a2076da2.png"/></p>
<p style="padding-left: 60px">Notice that we now have a second category, Unit, and it has the two properties we specified in our script.</p>
<ol start="4">
<li>Click on the drop-down menu beside your <kbd>UClassOfPlayer</kbd> menu.</li>
<li>Select the appropriate <kbd>UClassOfPlayer</kbd> member from the drop-down menu of the listed <kbd>UClass</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/21af16e5-ea46-4084-bd60-4b3f4fa8dac6.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Unreal Engine 4 give us a number of ways to specify a <kbd>UClass</kbd> or expected class type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">TSubclassOf</h1>
                
            
            
                
<p>The <kbd>TSubclassOf&lt; &gt;</kbd> member will allow you to specify a <kbd>UClass</kbd> name using a drop-down menu inside the UE4 editor when editing any blueprints that have <kbd>TSubclassOf&lt; &gt;</kbd> members.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">FStringClassReference</h1>
                
            
            
                
<p>The <kbd>MetaClass</kbd> tag refers to the base C++ class from which you expect the <kbd>UClassName</kbd> to derive. This limits the drop-down menu's contents to only the blueprints derived from that C++ class. You can leave the <kbd>MetaClass</kbd> tag out if you wish to display all the blueprints in the project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Instantiating UObject-derived classes (ConstructObject&lt; &gt; and NewObject&lt; &gt;)</h1>
                
            
            
                
<p>Creating class instances in C++ is traditionally done using the keyword <kbd>new</kbd>. However, UE4 actually creates instances of its classes internally and requires you to call special factory functions to produce copies of any <kbd>UCLASS</kbd> that you want to instantiate. You produce instances of the UE4 blueprints classes, not the C++ class alone. When you create <kbd>UObject</kbd>-derived classes, you will need to instantiate them using special UE4 Engine functions.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The factory method allows UE4 to exercise some memory management on the object, controlling what happens to the object when it is deleted. This method allows UE4 to track all references to an object so that on object destruction, all references to the object can be easily unlinked. This ensures that no dangling pointers with references to invalidated memory exist in the program. This process is usually called <strong>garbage collection</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Instantiating <kbd>UObject</kbd>-derived classes that are not <kbd>AActor</kbd> class derivatives does not use <kbd>UWorld::SpawnActor&lt; &gt;</kbd>. Instead, we have to a special global function: <kbd>ConstructObject&lt; &gt;</kbd> or <kbd>NewObject&lt; &gt;</kbd>. Note that you should not use the bare C++ keyword <kbd>new</kbd> to allocate new instances of your UE4 <kbd>UObject</kbd> class derivatives.</p>
<p>You will need at least two pieces of information to properly instantiate your <kbd>UCLASS</kbd> instance:</p>
<ul>
<li>A C++ typed <kbd>UClass</kbd> reference to the class type that you would like to instantiate (blueprint class)</li>
<li>The original C++ base class from which the blueprint class derives</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In a globally accessible object (such as your <kbd>GameMode</kbd> object), add a <kbd>TSubclassOf&lt; YourC++ClassName &gt; UPROPERTY()</kbd> to specify and supply the <kbd>UCLASS</kbd> name to your C++ code. To do this with the GameMode, do the following:</p>
<ol>
<li>From Visual Studio, open up the <kbd>Chapter02_GameModeBase.h</kbd> file from the Solution Explorer. From there, update the script to the following:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameModeBase.h"<br/><strong>#include "UserProfile.h"</strong><br/>#include "Chapter_02GameModeBase.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_02_API AChapter_02GameModeBase : public AGameModeBase<br/>{<br/>  GENERATED_BODY()<br/><strong>  </strong><br/><strong>public:</strong><br/><strong>  UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = UClassNames ) </strong><br/><strong>  TSubclassOf&lt;UUserProfile&gt; UPBlueprintClassName;</strong> <br/>};</pre>
<ol start="2">
<li>Save and compile your code.</li>
<li>From the UE4 editor, create a blueprint from this class. Double-click on it to enter the blueprints editor and then select your <kbd>UClass</kbd> name from the drop-down menu so that you can see what it does. Save and exit the editor:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1fd16d87-b45d-4366-b178-bc8863d838b8.png" style="width:36.33em;height:36.92em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>In your C++ code, find the section where you want to instantiate the <kbd>UCLASS</kbd> instance.</li>
<li>Instantiate the object using <kbd>ConstructObject&lt; &gt;</kbd> with the following formula:</li>
</ol>
<pre style="padding-left: 60px">ObjectType* object = ConstructObject&lt; ObjectType &gt;( <br/> UClassReference );</pre>
<p>For example, using the <kbd>UserProfile</kbd> object that we specified in the last recipe, we would get code such as this:</p>
<pre>// Get the GameMode object, which has a reference to  
// the UClass name that we should instantiate: 
AChapter2GameMode *gm = Cast&lt;AChapter2GameMode&gt;( <br/>                                        GetWorld()-&gt;GetAuthGameMode()); <br/>if( gm )<br/>{<br/>  UUserProfile* newobject = NewObject&lt;UUserProfile&gt;(                                         <br/>                                      (UObject*)GetTransientPackage(), <br/>                                       UUserProfile::StaticClass() );<br/>}</pre>
<p>You can see an example of this being used in the <kbd>Chapter_02GameModeBase.cpp</kbd> file in this book's example code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Instantiating a <kbd>UObject</kbd> class using <kbd>NewObject</kbd> is simple. <kbd>ConstructObject</kbd> will instantiate an object of the blueprint-class type, and return a C++ pointer of the correct type.</p>
<p>Unfortunately, <kbd>NewObject</kbd> has a nasty first parameter that requires you to pass <kbd>GetTransientPackage()</kbd> with each call.</p>
<p>Do not use the keyword <kbd>new</kbd> when constructing your UE4 <kbd>UObject</kbd> derivative! It will not be properly memory-managed.</p>
<p>For more information on <kbd>NewObject</kbd> and other object creation functions, check out <a href="https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation">https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation</a>.<a href="https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation"> </a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The <kbd>NewObject</kbd> function is what the OOP world refers to as a factory, and is a common design pattern. You ask the factory to make you the object; you don't go about constructing it by yourself. Using a factory pattern enables the engine to easily track objects as they are created.</p>
<p>For more information on design patterns, including the factory pattern, check out <em>Design Patterns: Elements of Reusable Object-Oriented Software </em>by Erich Gamma.<br/>
<br/>
If you are interested in learning more about design patterns for game development, you may wish to check out <em>Game Development Patterns and Best Practices</em>, also available from Packt Publishing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Destroying UObject-derived classes</h1>
                
            
            
                
<p>Removing any <kbd>UObject</kbd> derivative is simple in UE4. When you are ready to delete your <kbd>UObject</kbd>-derived class, we will simply call a single function (<kbd>ConditionalBeginDestroy()</kbd>) on it to begin teardown. We do not use the native C++ <kbd>delete</kbd> command on <kbd>UObject</kbd> derivatives. We will show this in the following recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To complete this recipe, you will need to have an object (<kbd>objectInstance</kbd>, in this case) that you wish to destroy in your project. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Call <kbd>objectInstance-&gt;ConditionalBeginDestroy()</kbd> on your object instance.</li>
<li>Null all your references to <kbd>objectInstance</kbd> in your client code, and do not use <kbd>objectInstance</kbd> again after <kbd>ConditionalBeginDestroy()</kbd> has been called on it:</li>
</ol>
<pre style="padding-left: 60px">// Destroy object<br/>if(newobject)<br/>{<br/>  newobject-&gt;ConditionalBeginDestroy();<br/>  newobject = nullptr;<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>ConditionalBeginDestroy()</kbd> function begins the destruction process by removing all internal engine linkages to it. This marks the object for destruction as far as the engine is concerned. The object is then destroyed some time later by destroying its internal properties, followed by actual destruction of the object.</p>
<p>After <kbd>ConditionalBeginDestroy()</kbd> has been called on an object, your (client) code must consider the object to be destroyed, and must no longer use it.</p>
<p>Actual memory recovery happens some time later than when <kbd>ConditionalBeginDestroy()</kbd> has been called on an object. There is a garbage collection routine that finishes clearing the memory of objects that are no longer referenced by the game program at fixed time intervals. The time interval between garbage collector calls is listed in <kbd>C:\Program Files (x86)\Epic Games\Launcher\Engine\Config\BaseEngine.ini</kbd>, and defaults to one collection every 61.1 seconds:</p>
<pre>gc.TimeBetweenPurgingPendingKillObjects=61.1</pre>
<p>If the memory seems low after several <kbd>ConditionalBeginDestroy()</kbd> calls, you can trigger memory cleanup by calling <kbd>GetWorld()-&gt;ForceGarbageCollection(true)</kbd> to force an internal memory cleanup.</p>
<p>Usually, you do not need to worry about garbage collection or the interval unless you urgently need memory cleared. Do not call garbage collection routines too often, as this may cause unnecessary lag in the game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a USTRUCT</h1>
                
            
            
                
<p>You may want to construct a blueprints editable property in UE4 that contains multiple members. The <kbd>FColoredTexture</kbd> struct that we will create in this recipe will allow you to group together a texture and its color inside the same structure for inclusion and specification in any other <kbd>UObject</kbd>-derivative, <kbd>Blueprintable</kbd> class:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/beee3b48-2091-4242-a170-46e6704965ce.png" style="width:29.67em;height:13.17em;"/></p>
<p>The <kbd>FColoredTexture</kbd> structure does have the visual within the blueprints appearance, as shown in the preceding screenshot.</p>
<p>This is for good organization and convenience of your other <kbd>UCLASS UPROPERTIES()</kbd>.<br/>
You may want to construct a C++ structure in your game using the <kbd>struct</kbd> keyword.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>A <kbd>UObject</kbd> is the base class of all UE4 class objects, while an <kbd>FStruct</kbd> is just any plain old C++ style struct. All objects that use the automatic memory management features within the engine must derive from this class.</p>
<p>If you may recall from the C++ language, the only difference between a C++ <kbd>class</kbd> and a C++ <kbd>struct</kbd> is that C++ classes have default <kbd>private</kbd> members, while structs default to <kbd>public</kbd> members. <br/>
<br/> In languages such as C#, this isn't the case. In C#, a struct is value-typed, while a class is reference-typed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We'll create a structure called <kbd>FColoredTexture</kbd> in C++ code to contain a texture and a modulating color:</p>
<ol>
<li>From Visual Studio, right-click on the Games/Chapter_02/Source/Chapter_02 folder and select Add | New item.... From the menu, select a Header file (.h) and then name the file <kbd>ColoredTexture.h</kbd> (not <kbd>FColoredTexture</kbd>).</li>
<li>Under Location, make sure that you select the same folder as the other script files in the project (in my case, <kbd>C:\Users\admin\Documents\Unreal Projects\Chapter_02\Source\Chapter_02</kbd>) that is not the default:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/894cbb06-baf9-4618-bcde-1bd140907c72.png"/></p>
<ol start="3">
<li>Once created, use the following code in <kbd>ColoredTexture.h</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once <br/><br/>#include "ObjectMacros.h"<br/>#include "ColoredTexture.generated.h"<br/> <br/>USTRUCT(Blueprintable) <br/>struct CHAPTER_02_API FColoredTexture <br/>{<br/>  GENERATED_USTRUCT_BODY()<br/><br/>public: <br/>  UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = HUD ) <br/>  UTexture* Texture; <br/><br/>  UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = HUD ) <br/>  FLinearColor Color; <br/>}; </pre>
<ol start="4">
<li>Use <kbd>ColoredTexture.h</kbd> as a <kbd>UPROPERTY()</kbd> in a blueprintable <kbd>UCLASS()</kbd>, using a <kbd>UPROPERTY()</kbd> declaration such as this:</li>
</ol>
<pre style="padding-left: 60px">#include "CoreMinimal.h"<br/>#include "UObject/NoExportTypes.h"<br/><strong>#include "ColoredTexture.h"</strong><br/>#include "UserProfile.generated.h"<br/><br/><br/>/**<br/> * UCLASS macro options sets this C++ class to be<br/> * Blueprintable within the UE4 Editor<br/> */<br/>UCLASS(Blueprintable, BlueprintType)<br/>class CHAPTER_02_API UUserProfile : public UObject<br/>{<br/>  GENERATED_BODY()<br/><br/>public:<br/>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)<br/>  float Armor;<br/><br/>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)<br/>  float HpMax;<br/><br/>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Stats)<br/>  FString Name;<br/><br/>  // Displays any UClasses deriving from UObject in a dropdown <br/>  // menu in Blueprints<br/>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Unit)<br/>  TSubclassOf&lt;UObject&gt; UClassOfPlayer; <br/><br/>  // Displays string names of UCLASSes that derive from<br/>  // the GameMode C++ base class<br/>  UPROPERTY(EditAnywhere, meta=(MetaClass="GameMode"), Category = Unit )<br/>  FStringClassReference UClassGameMode;<br/><br/><strong>  // Custom struct example</strong><br/><strong>  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = HUD) </strong><br/><strong>  FColoredTexture Texture;</strong> <br/>};</pre>
<ol start="5">
<li>Save your script and compile your changes. Upon entering your object blueprint, you should notice the new properties:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5699f592-65aa-48d5-9511-2035977e0c6f.png" style="width:46.33em;height:46.92em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>UPROPERTY()</kbd> specified for the <kbd>FColoredTexture</kbd> will show up in the editor as editable fields when included as <kbd>UPROPERTY()</kbd> fields inside another class, as shown in step 3.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The main reason for making a struct, that is, a <kbd>USTRUCT()</kbd> instead of just a plain old C++ struct, is to interface with the UE4 Engine functionality. You can use plain C++ code (without creating <kbd>USTRUCT()</kbd> objects) for quick small structures that don't ask the engine to use them directly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a UENUM( )</h1>
                
            
            
                
<p>C++ <kbd>enum</kbd> instances are very useful in typical C++ code. UE4 has a custom type of enumeration called <kbd>UENUM()</kbd>, which allows you to create an <kbd>enum</kbd> that will show up in a drop-down menu inside a blueprint that you are editing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Go to the header file that will use the <kbd>UENUM()</kbd> you are specifying, or create a<br/>
file called <kbd>EnumName.h</kbd>.</li>
<li>Use the following code:</li>
</ol>
<pre style="padding-left: 60px">UENUM() 
enum Status 
{ 
  Stopped     UMETA(DisplayName = "Stopped"), 
  Moving      UMETA(DisplayName = "Moving"), 
  Attacking   UMETA(DisplayName = "Attacking"), 
}; </pre>
<ol start="3">
<li>Use your <kbd>UENUM()</kbd> in a <kbd>UCLASS()</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <br/> Status) 
TEnumAsByte&lt;Status&gt; status; </pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p><kbd>UENUM()</kbd> shows up nicely in the code editor as a drop-down menu in the blueprints editor, from which you can only select one of a few values:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ff0d78df-992a-47b1-bd70-9231db4839c7.png"/></p>
<p>As you can see, the values that were specified are there!</p>


            

            
        
    </body></html>