<html><head></head><body><div><div><h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: An Introduction to Templates</h1>
			<p>As a C++ developer, you should be at least familiar if not well versed in <strong class="bold">template metaprogramming</strong>, in general, referred to in short as <strong class="bold">templates</strong>. Template metaprogramming is a programming technique that uses templates as blueprints for the compiler to generate code and help developers avoid writing repetitive code. Although general-purpose libraries use templates heavily, the syntax and the inner workings of templates in the C++ language can be discouraging. Even <em class="italic">C++ Core Guidelines</em>, which is a collection of dos and don'ts edited by <em class="italic">Bjarne Stroustrup</em>, the creator of the C++ language, and <em class="italic">Herb Sutter</em>, the chair of the C++ standardization committee, calls templates <em class="italic">pretty horrendous</em>.</p>
			<p>This book is intended to shed light on this area of the C++ language and help you become prolific in template metaprogramming. </p>
			<p>In this chapter, we will go through the following topics:</p>
			<ul>
				<li>Understanding the need for templates</li>
				<li>Writing your first templates</li>
				<li>Understanding template terminology</li>
				<li>A brief history of templates</li>
				<li>The pros and cons of templates</li>
			</ul>
			<p>The first step in learning how to use templates is to understand what problem they actually solve. Let's start with that.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Understanding the need for templates</h1>
			<p>Each language <a id="_idIndexMarker000"/>feature is designed to help with a problem or task that developers face when using that language. The purpose of templates is to help us avoid writing repetitive code that only differs slightly.</p>
			<p>To exemplify this, let's take the classical example of a <code>max</code> function. Such a function takes two numerical arguments and returns the largest of the two. We can easily implement this as follows:</p>
			<pre class="source-code">int max(int const a, int const b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &gt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<p>This works pretty well, but as you can see, it will only work for values of the type <code>int</code> (or those that are convertible to <code>int</code>). What if we need the same function but with arguments of the type <code>double</code>? Then, we can overload this function (create a function with the same name but a different number or type of arguments) for the <code>double</code> type:</p>
			<pre class="source-code">double max(double const a, double const b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &gt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<p>However, <code>int</code> and <code>double</code> are not the only numeric types. There is <code>char</code>, <code>short</code>, <code>long</code>, <code>long</code> and their unsigned counterparts, <code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned long</code>, and  <code>unsigned long</code>. There are also the types <code>float</code> and <code>long double</code>. And other types, such as <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, and <code>int64_t</code>. And there could be other types that can be compared, such as <code>bigint</code>, <code>Matrix</code>, <code>point2d</code>, and any user-defined type that overloads <code>operator&gt;</code>. How can a general-purpose library provide a general-purpose function such as <code>max</code> for all these types? It can overload the function for all the built-in types and perhaps other library types but cannot do so for any user-defined type.</p>
			<p>An alternative to overloading functions with different parameters is to use <code>void*</code> to pass arguments of different types. Keep in mind this is a bad practice and the following example is shown only as a possible alternative in a world without templates. However, for the sake of discussion, we can design a sorting function that will run the quick sort algorithm on an array of elements of any possible type that provides a strict weak ordering. The details of the quicksort algorithm can be looked up online, such as on Wikipedia at <a href="https://en.wikipedia.org/wiki/Quicksort">https://en.wikipedia.org/wiki/Quicksort</a>. </p>
			<p>The quicksort algorithm needs to compare and swap any two elements. However, since we don't know their type, the implementation cannot do this directly. The solution is to rely on <strong class="bold">callbacks</strong>, which <a id="_idIndexMarker001"/>are functions passed as arguments that will be invoked when necessary. A <a id="_idIndexMarker002"/>possible implementation can be as follows:</p>
			<pre class="source-code">using swap_fn = void(*)(void*, int const, int const);</pre>
			<pre class="source-code">using compare_fn = bool(*)(void*, int const, int const);</pre>
			<pre class="source-code">int partition(void* arr, int const low, int const high, </pre>
			<pre class="source-code">              compare_fn fcomp, swap_fn fswap)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int i = low - 1;</pre>
			<pre class="source-code">   for (int j = low; j &lt;= high - 1; j++)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      if (fcomp(arr, j, high))</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         i++;</pre>
			<pre class="source-code">         fswap(arr, i, j);</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   fswap(arr, i + 1, high);</pre>
			<pre class="source-code">   return i + 1;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">void quicksort(void* arr, int const low, int const high, </pre>
			<pre class="source-code">               compare_fn fcomp, swap_fn fswap)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (low &lt; high)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      int const pi = partition(arr, low, high, fcomp, </pre>
			<pre class="source-code">         fswap);</pre>
			<pre class="source-code">      quicksort(arr, low, pi - 1, fcomp, fswap);</pre>
			<pre class="source-code">      quicksort(arr, pi + 1, high, fcomp, fswap);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>In order to<a id="_idIndexMarker003"/> invoke the <code>quicksort</code> function, we need to provide implementations for these comparisons and swapping functions for each type of array that we pass to the function. The following are implementations for the <code>int</code> type:</p>
			<pre class="source-code">void swap_int(void* arr, int const i, int const j)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int* iarr = (int*)arr;</pre>
			<pre class="source-code">   int t = iarr[i];</pre>
			<pre class="source-code">   iarr[i] = iarr[j];</pre>
			<pre class="source-code">   iarr[j] = t;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">bool less_int(void* arr, int const i, int const j)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int* iarr = (int*)arr;</pre>
			<pre class="source-code">   return iarr[i] &lt;= iarr[j];</pre>
			<pre class="source-code">}</pre>
			<p>With all these defined, we can write code that sorts arrays of integers as follows:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int arr[] = { 13, 1, 8, 3, 5, 2, 1 };</pre>
			<pre class="source-code">   int n = sizeof(arr) / sizeof(arr[0]);</pre>
			<pre class="source-code">   quicksort(arr, 0, n - 1, less_int, swap_int);</pre>
			<pre class="source-code">}</pre>
			<p>These <a id="_idIndexMarker004"/>examples focused on functions but the same problem applies to classes. Consider that you want to write a class that models a collection of numerical values that has variable size and stores the elements contiguously in memory. You could provide the following implementation (only the declaration is sketched here) for storing integers:</p>
			<pre class="source-code">struct int_vector</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int_vector();</pre>
			<pre class="source-code">   size_t size() const;</pre>
			<pre class="source-code">   size_t capacity() const;</pre>
			<pre class="source-code">   bool empty() const;</pre>
			<pre class="source-code">   void clear();</pre>
			<pre class="source-code">   void resize(size_t const size);</pre>
			<pre class="source-code">   void push_back(int value);</pre>
			<pre class="source-code">   void pop_back();</pre>
			<pre class="source-code">   int at(size_t const index) const;</pre>
			<pre class="source-code">   int operator[](size_t const index) const;</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   int* data_;</pre>
			<pre class="source-code">   size_t size_;</pre>
			<pre class="source-code">   size_t capacity_;</pre>
			<pre class="source-code">};</pre>
			<p>This all looks good<a id="_idIndexMarker005"/> but the moment you need to store values of the type <code>double</code>, or <code>std::string</code>, or any user-defined type you'll have to write the same code, each time only changing the type of the elements. This is something nobody wants to do because it is repetitive work and because when something needs to change (such as adding a new feature or fixing a bug) you need to apply the same change in multiple places.</p>
			<p>Lastly, a similar problem can be encountered, although less often, when you need to define variables. Let's consider the case of a variable that holds the new line character. You can declare it as follows:</p>
			<pre class="source-code">constexpr char NewLine = '\n';</pre>
			<p>What if you need the same constant but for a different encoding, such as wide string literals, UTF-8, and so on? You can have multiple variables, having different names, such as in the following example:</p>
			<pre class="source-code">constexpr wchar_t NewLineW = L'\n';</pre>
			<pre class="source-code">constexpr char8_t NewLineU8 = u8'\n';</pre>
			<pre class="source-code">constexpr char16_t NewLineU16 = u'\n';</pre>
			<pre class="source-code">constexpr char32_t NewLineU32 = U'\n';</pre>
			<p>Templates are a technique that allows developers to write blueprints that enable the compiler to <a id="_idIndexMarker006"/>generate all this repetitive code for us. In the following section, we will see how to transform the preceding snippets into C++ templates.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Writing your first templates</h1>
			<p>It is now time<a id="_idIndexMarker007"/> to see how templates are written in the C++ language. In this section, we will start with three simple examples, one for each of the snippets presented earlier.</p>
			<p>A template version of the <code>max</code> function discussed previously would look as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T max(T const a, T const b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &gt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<p>You will notice here that the type name (such as <code>int</code> or <code>double</code>) has been replaced with <code>T</code> (which <a id="_idIndexMarker008"/>stands for <em class="italic">type</em>). <code>T</code> is called a <code>template&lt;typename T&gt; or typename&lt;class T&gt;</code>. Keep in mind that <code>T</code> is a parameter, therefore it can have any name. We will learn more about template parameters in the next chapter.</p>
			<p>At this point, this template that you put in the source code is only a blueprint. The compiler will generate code from it based on its use. More precisely, it will instantiate a function overload for each type the template is used with. Here is an example:</p>
			<pre class="source-code">struct foo{};</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{   </pre>
			<pre class="source-code">   foo f1, f2;</pre>
			<pre class="source-code">   max(1, 2);     // OK, compares ints</pre>
			<pre class="source-code">   max(1.0, 2.0); // OK, compares doubles</pre>
			<pre class="source-code">   max(f1, f2);   // Error, operator&gt; not overloaded for </pre>
			<pre class="source-code">                  // foo</pre>
			<pre class="source-code">}</pre>
			<p>In this snippet, we are first calling <code>max</code> with two integers, which is OK because <code>operator&gt;</code> is available for the type <code>int</code>. This will generate an overload <code>int max(int const a, int const b)</code>. Second, we are calling <code>max</code> with two doubles, which again is all right since <code>operator&gt;</code> works for doubles. Therefore, the compiler will <a id="_idIndexMarker009"/>generate another overload, <code>double max(double const a, double const b)</code>. However, the third call to <code>max</code> will generate a compiler error, because the <code>foo</code> type does not have the <code>operator&gt;</code> overloaded.</p>
			<p>Without getting into too many details at this point, it should be mentioned that the complete syntax for calling the <code>max</code> function is the following:</p>
			<pre class="source-code">max&lt;int&gt;(1, 2);</pre>
			<pre class="source-code">max&lt;double&gt;(1.0, 2.0);</pre>
			<pre class="source-code">max&lt;foo&gt;(f1, f2);</pre>
			<p>The compiler is able to deduce the type of the template parameter, making it redundant to write it. There are cases, however, when that is not possible; in those situations, you need to specify the type explicitly, using this syntax.</p>
			<p>The second example involving functions from the previous section, <em class="italic">Understanding the need for templates</em>, was the <code>quicksort()</code> implementation that dealt with <code>void*</code> arguments. The implementation can be easily transformed into a template version with very few changes. This is shown in the following snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void swap(T* a, T* b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T t = *a;</pre>
			<pre class="source-code">   *a = *b;</pre>
			<pre class="source-code">   *b = t;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">int partition(T arr[], int const low, int const high)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T pivot = arr[high];</pre>
			<pre class="source-code">   int i = (low - 1);</pre>
			<pre class="source-code">   for (int j = low; j &lt;= high - 1; j++)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      if (arr[j] &lt; pivot)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         i++;</pre>
			<pre class="source-code">         swap(&amp;arr[i], &amp;arr[j]);</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   swap(&amp;arr[i + 1], &amp;arr[high]);</pre>
			<pre class="source-code">   return i + 1;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void quicksort(T arr[], int const low, int const high)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (low &lt; high)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      int const pi = partition(arr, low, high);</pre>
			<pre class="source-code">      quicksort(arr, low, pi - 1);</pre>
			<pre class="source-code">      quicksort(arr, pi + 1, high);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>The use of the <code>quicksort</code> function template is very similar to what we have seen earlier, except <a id="_idIndexMarker010"/>there is no need to pass pointers to callback functions:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int arr[] = { 13, 1, 8, 3, 5, 2, 1 };</pre>
			<pre class="source-code">   int n = sizeof(arr) / sizeof(arr[0]);</pre>
			<pre class="source-code">   quicksort(arr, 0, n - 1);</pre>
			<pre class="source-code">}</pre>
			<p>The third example we looked at in the previous section was the <code>vector</code> class. A template version of it will look as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct vector</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   vector();</pre>
			<pre class="source-code">   size_t size() const;</pre>
			<pre class="source-code">   size_t capacity() const;</pre>
			<pre class="source-code">   bool empty() const;</pre>
			<pre class="source-code">   void clear();</pre>
			<pre class="source-code">   void resize(size_t const size);</pre>
			<pre class="source-code">   void push_back(T value);</pre>
			<pre class="source-code">   void pop_back();</pre>
			<pre class="source-code">   T at(size_t const index) const;</pre>
			<pre class="source-code">   T operator[](size_t const index) const;</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   T* data_;</pre>
			<pre class="source-code">   size_t size_;</pre>
			<pre class="source-code">   size_t capacity_;</pre>
			<pre class="source-code">};</pre>
			<p>As in the case<a id="_idIndexMarker011"/> of the <code>max</code> function, the changes are minimal. There is the template declaration on the line above the class and the type <code>int</code> of the elements has been replaced with the type template parameter <code>T</code>. This implementation can be used as follows:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{   </pre>
			<pre class="source-code">   vector&lt;int&gt; v;</pre>
			<pre class="source-code">   v.push_back(1);</pre>
			<pre class="source-code">   v.push_back(2);</pre>
			<pre class="source-code">}</pre>
			<p>One thing to notice here is that we have to specify the type of the elements when declaring the variable <code>v</code>, which is <code>int</code> in our snippet because the compiler would not be able to infer their <a id="_idIndexMarker012"/>type otherwise. There are cases when this is possible, in C++17, and this topic, called <strong class="bold">class template argument deduction</strong>, will be discussed in <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>.</p>
			<p>The fourth and last example concerned the declaration of several variables when only the type was different. We could replace all those variables with a template, as shown in the following snippet:</p>
			<pre class="source-code">template&lt;typename T&gt;</pre>
			<pre class="source-code">constexpr T NewLine = T('\n');</pre>
			<p>This template can be used as follows:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::wstring test = L"demo";</pre>
			<pre class="source-code">   test += NewLine&lt;wchar_t&gt;;</pre>
			<pre class="source-code">   std::wcout &lt;&lt; test;</pre>
			<pre class="source-code">}</pre>
			<p>The examples in this section show that the syntax for declaring and using templates is the same<a id="_idIndexMarker013"/> whether they represent functions, classes, or variables. This leads us to the next section where we will discuss the types of templates and template terminology.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Understanding template terminology</h1>
			<p>So far in this <a id="_idIndexMarker014"/>chapter, we have used the general term templates. However, there are four different terms describing the kind of templates we have written:</p>
			<ul>
				<li><code>max</code> template seen previously.</li>
				<li><code>class</code>, <code>struct</code>, or <code>union</code> keyword). An example is the <code>vector</code> class we wrote in the previous section.</li>
				<li><code>NewLine</code> template from the previous section.</li>
				<li><strong class="bold">Alias template</strong> is the <a id="_idIndexMarker018"/>term used for templated type aliases. We will see examples for alias templates in the next chapter.</li>
			</ul>
			<p>Templates are parameterized with one or more parameters (in the examples we have seen so far, there was a single parameter). These<a id="_idIndexMarker019"/> are called <strong class="bold">template parameters</strong> and can be of<a id="_idIndexMarker020"/> three categories:</p>
			<ul>
				<li><code>template&lt;typename T&gt;</code>, where the parameter represents a type specified when the template is used.</li>
				<li><code>template&lt;size_t N&gt;</code> or <code>template&lt;auto n&gt;</code>, where each parameter must have a structural type, which includes integral types, floating-point types (as for C++20), pointer types, enumeration types, lvalue reference types, and others.</li>
				<li><code>template&lt;typename K, typename V, template&lt;typename&gt; typename C&gt;</code>, where the type of a parameter is another template.</li>
			</ul>
			<p>Templates can be specialized by providing alternative implementations. These implementations can depend on the characteristics of the template parameters. The purpose of specialization is to enable optimizations or reduce code bloat. There are two forms of specialization:</p>
			<ul>
				<li><strong class="bold">Partial specialization</strong>: This is an alternative implementation provided for only some of the template parameters.</li>
				<li><strong class="bold">(Explicit) full specialization</strong>: This is a specialization of a template when all the template arguments are provided.</li>
			</ul>
			<p>The process of generating code from a template by the compiler is called <code>vector&lt;int&gt;</code>, the compiler substituted the <code>int</code> type in every place where <code>T</code> appeared. </p>
			<p>Template instantiation can have two forms:</p>
			<ul>
				<li><code>vector&lt;int&gt;</code> and <code>vector&lt;double&gt;</code>, it will instantiate the <code>vector</code> class template for the types <code>int</code> and <code>double</code> and nothing more.</li>
				<li><strong class="bold">Explicit instantiation</strong>: This is a way to explicitly tell the compiler what instantiations of a template to create, even if those instantiations are not explicitly used in your code. This is useful, for instance, when creating library files, because uninstantiated templates are not put into object files. They also help reduce compile times and object sizes, in ways that we will see at a later time.</li>
			</ul>
			<p>All the terms <a id="_idIndexMarker024"/>and topics mentioned in this section will be detailed in other chapters of the book. This section is intended as a short reference guide to template terminology. Keep in mind though that there are many other terms related to templates that will be introduced at the appropriate time.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>A brief history of templates</h1>
			<p>Template <a id="_idIndexMarker025"/>metaprogramming is the C++ implementation of generic programming. This paradigm was first explored in the 1970s and the first major languages to support it were Ada and Eiffel in the first half of the 1980s. David Musser and Alexander Stepanov defined generic programming, in a paper called <em class="italic">Generic Programming</em>, in 1989, as follows:</p>
			<p class="author-quote">Generic programming centers around the idea of abstracting from concrete, efficient algorithms to obtain generic algorithms that can be combined with different data representations to produce a wide variety of useful software.</p>
			<p>This defines a paradigm of programming where algorithms are defined in terms of types that are specified later and instantiated based on their use.</p>
			<p>Templates were not part of the<a id="_idIndexMarker026"/> initial <strong class="bold">C with Classes</strong> language developed by Bjarne Stroustrup. Stroustrup's first papers describing templates in C++ appeared in 1986, one year after the publication of his book, <em class="italic">The C++ Programming Language, First Edition</em>. Templates became available in the C++ language in 1990, before the ANSI and ISO C++ committees for standardization were founded. </p>
			<p>In the early 1990s, Alexander Stepanov, David Musser, and Meng Lee experimented with the implementation in C++ of <a id="_idIndexMarker027"/>various generic concepts. This led to the first implementation of the <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>). When the ANSI/ISO committee became aware of the library in 1994, it quickly added it to the drafted specifications. STL was standardized along with the C++ language in 1998 in what became known as C++98.</p>
			<p>Newer versions of the C++ standard, collectively <a id="_idIndexMarker028"/>referred to as <strong class="bold">modern C++</strong>, have introduced <a id="_idIndexMarker029"/>various improvements to template metaprogramming. The following table lists them briefly:</p>
			<div><div><img src="img/B18367_Table_1.1.jpg" alt="Table 1.1&#13;&#10;" width="1646" height="1650"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.1</p>
			<p>All these features, along with other aspects of template metaprogramming, will make the sole <a id="_idIndexMarker030"/>subject of this book and will be presented in detail in the following chapters. For now, let's see what the advantages and disadvantages are of using templates.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>The pros and cons of templates</h1>
			<p>Before you <a id="_idIndexMarker031"/>start <a id="_idIndexMarker032"/>using templates, it's important to understand the benefits of using them as well as the disadvantages they may incur. </p>
			<p>Let's start by pointing out the advantages:</p>
			<ul>
				<li>Templates help us avoid writing repetitive code.</li>
				<li>Templates foster the creation of generic libraries providing algorithms and types, such as the standard C++ library (sometimes incorrectly referred to as the STL), which can be used in many applications, regardless of their type.</li>
				<li>The use of templates can result in less and better code. For instance, using algorithms from the standard library can help write less code that is likely easier to understand and maintain and also probably more robust because of the effort put into the development and testing of these algorithms.</li>
			</ul>
			<p>When it comes to disadvantages, the following are worth mentioning:</p>
			<ul>
				<li>The syntax is considered complex and cumbersome, although with a little practice <a id="_idIndexMarker033"/>this should not really pose a real hurdle in the development<a id="_idIndexMarker034"/> and use of templates.</li>
				<li>Compiler errors related to template code can often be long and cryptic, making it very hard to identify their cause. Newer versions of the C++ compilers have made progress in simplifying these kinds of errors, although they generally remain an important issue. The inclusion of concepts in the C++20 standard has been seen as an attempt, among others, to help provide better diagnostics for compiling errors.</li>
				<li>They increase the compilation times because they are implemented entirely in headers. Whenever a change to a template is made, all the translation units in which that header is included must be recompiled.</li>
				<li>Template libraries are provided as a collection of one or more headers that must be compiled together with the code that uses them. </li>
				<li>Another disadvantage that results from the implementation of templates in headers is that there is no information hiding. The entire template code is available in headers for anyone to read. Library developers often resort to the use of namespaces with names such as <code>detail</code> or <code>details</code> to contain code that is supposed to be internal for a library and should not be called directly by those using the library.</li>
				<li>They could be harder to validate since code that is not used is not instantiated by the compiler. It is, therefore, important that when writing unit tests, good code coverage must be ensured. This is especially the case for libraries.</li>
			</ul>
			<p>Although the list of disadvantages may seem longer, the use of templates is not a bad thing or something to be avoided. On the contrary, templates are a powerful feature of the C++ language. Templates are not always properly understood and sometimes are misused <a id="_idIndexMarker035"/>or <a id="_idIndexMarker036"/>overused. However, the judicious use of templates has unquestionable advantages. This book will try to provide a better understanding of templates and their use.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Summary</h1>
			<p>This chapter introduced the concept of templates in the C++ programming language. </p>
			<p>We started by learning about the problems for which the solution is the use of templates. We then saw how templates look with simple examples of function templates, class templates, and variable templates. We introduced the basic terminology for templates, which we will discuss more in the forthcoming chapters. Toward the end of the chapter, we saw a brief history of templates in the C++ programming language. We ended the chapter with a discussion on the advantages and disadvantages of using templates. All these topics will lead us to understand the next chapters better.</p>
			<p>In the next chapter, we will explore the fundamentals of templates in C++.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Questions</h1>
			<ol>
				<li>Why do we need templates? What advantages do they provide?</li>
				<li>How do you call a function that is a template? What about a class that is a template?</li>
				<li>How many kinds of template parameters exist and what are they?</li>
				<li>What is partial specialization? What about full specialization?</li>
				<li>What are the main disadvantages of using templates?</li>
			</ol>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Further reading</h1>
			<ul>
				<li><em class="italic">Generic Programming, David Musser, Alexander Stepanov</em>, <a href="http://stepanovpapers.com/genprog.pdf">http://stepanovpapers.com/genprog.pdf</a></li>
				<li><em class="italic">A History of C++: 1979−1991, Bjarne Stroustrup</em>, <a href="https://www.stroustrup.com/hopl2.pdf">https://www.stroustrup.com/hopl2.pdf</a></li>
				<li><em class="italic">History of C++</em>, <a href="https://en.cppreference.com/w/cpp/language/history">https://en.cppreference.com/w/cpp/language/history</a></li>
				<li><em class="italic">Templates in C++ - Pros and Cons, Sergey Chepurin</em>, <a href="https://www.codeproject.com/Articles/275063/Templates-in-Cplusplus-Pros-and-Cons">https://www.codeproject.com/Articles/275063/Templates-in-Cplusplus-Pros-and-Cons</a></li>
			</ul>
		</div>
	</div></body></html>