- en: '*Chapter 5*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*'
- en: Standard Library Containers and Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库容器和算法
- en: Chapter Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本章目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Explain what iterators are
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释迭代器是什么
- en: Demonstrate the use of sequential containers, container adaptors, and associative
    containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示使用顺序容器、容器适配器和关联容器
- en: Understand and use unconventional containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用非传统容器
- en: Explain cases of iterator invalidation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释迭代器失效的情况
- en: Discover algorithms implemented in the standard library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现标准库中实现的自定义算法
- en: Use user-defined operations on algorithms with lambda expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式在算法中执行用户定义的操作
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: The core of C++ is its **Standard Template Library** (**STL**), which represents
    a set of important data structures and algorithms that facilitates the programmer's
    task and improves code efficiency.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的核心是其 **标准模板库**（**STL**），它代表了一组重要的数据结构和算法，有助于简化程序员的任务并提高代码效率。
- en: The components of the STL are parametric so that they can be reused and combined
    in different ways. The STL is mainly made up of container classes, iterators,
    and algorithms.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的组件是参数化的，因此它们可以被以不同的方式重用和组合。STL 主要由容器类、迭代器和算法组成。
- en: Containers are used to store collections of elements of a certain type. Usually,
    the type of the container is a template parameter, which allows the same container
    class to support arbitrary elements. There are several container classes, each
    of them with different characteristics and features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 容器用于存储特定类型的元素集合。通常，容器的类型是一个模板参数，它允许相同的容器类支持任意元素。有几个容器类，每个类都有不同的特性和功能。
- en: Iterators are used to traverse the elements of a container. Iterators offer
    the programmer a simple and common interface to access containers of a different
    type.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器用于遍历容器中的元素。迭代器为程序员提供了一个简单且通用的接口来访问不同类型的容器。
- en: Iterators are similar to raw pointers, which can also iterate through elements
    using the increment and the decrement operators, or can access a specific element
    using the de-reference (`*`) operator.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器类似于原始指针，它们可以使用增量或减量运算符遍历元素，或者使用解引用（`*`）运算符访问特定元素。
- en: Algorithms are used to perform standard operations on the elements stored in
    the containers. They use iterators to traverse the collections, since their interface
    is common to all the containers, so that the algorithm can be agnostic about the
    container it's operating on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 算法用于在容器中执行标准操作。它们使用迭代器遍历集合，因为它们的接口对所有容器都是通用的，这样算法就可以对它操作的容器一无所知。
- en: Algorithms treat functions as parameters that are provided by the programmer
    in order to be more flexible in the operation that's being performed. It is common
    to see an algorithm applied to a container of objects of a user-defined type.
    This algorithm, to execute correctly, needs to know how to treat the object in
    detail. For this reason, the programmer provides a function to the algorithm to
    specify the operations to be executed on the objects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 算法将函数作为参数处理，这些参数由程序员提供，以便在执行操作时更加灵活。通常，算法应用于用户定义类型的对象容器。为了正确执行，该算法需要知道如何详细处理对象。因此，程序员向算法提供一个函数，以指定对对象要执行的操作。
- en: Sequence Containers
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序容器
- en: '**Sequence containers,** sometimes referred to as **sequential containers**,
    are a particular class of containers where the order in which their elements are
    stored is decided by the *programmer* rather than by the values of the elements.
    Every element has a certain position that is independent of its value.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺序容器**，有时也称为 **顺序容器**，是一类特定的容器，其中元素的存储顺序由 *程序员* 决定，而不是由元素值决定。每个元素都有一个特定的位置，与其值无关。'
- en: 'The STL contains five sequence container classes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: STL 包含五个序列容器类：
- en: '![Figure 5.1: Table representing the sequence container class and their description](img/C11557_05_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：表示序列容器类及其描述的表格](img/C11557_05_01.jpg)'
- en: 'Figure 5.1: Table presenting the sequence container classes and their descriptions'
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.1：展示序列容器类及其描述的表格
- en: Array
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: 'The array container is a fixed-size data structure of contiguous elements.
    It recalls the static array that we saw in *Chapter 1*, *Getting Started*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 数组容器是一个固定大小的连续元素数据结构。它使我们想起了在 *第一章*，*入门* 中看到的静态数组：
- en: '![Figure 5.2: Array elements are stored in contiguous memory](img/C11557_05_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：数组元素存储在连续内存中](img/C11557_05_02.jpg)'
- en: 'Figure 5.2: Array elements are stored in contiguous memory'
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.2：数组元素存储在连续内存中
- en: An array's size needs to be specified at compile time. Once defined, the size
    of the array *cannot be changed*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的大小需要在编译时指定。一旦定义，数组的大小*不能更改*。
- en: When an array is created, the `size` elements it contains are initialized next
    to each other in memory. While elements cannot be added or removed, their values
    can be modified.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组被创建时，它包含的`size`个元素在内存中相邻初始化。虽然不能添加或删除元素，但可以修改它们的值。
- en: Arrays can be randomly accessed using the access operator with the corresponding
    element's index. To access an element at a given position, we can use the operator
    `[]` or the `at()` member function. The former does not perform any range checks,
    while the latter throws an exception if the index is out of range. Moreover, the
    first and the last element can be accessed using the `front()` and `back()` member
    functions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用访问运算符和相应元素的索引随机访问数组。要访问给定位置的元素，我们可以使用运算符`[]`或`at()`成员函数。前者不执行任何范围检查，而后者如果索引超出范围，则抛出异常。此外，可以使用`front()`和`back()`成员函数访问第一个和最后一个元素。
- en: 'These operations are fast: since the elements are contiguous, we can compute
    the position in memory of an element given its position in the array, and access
    that directly.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作很快：由于元素是连续的，我们可以根据数组中的位置计算出元素的内存位置，并直接访问它。
- en: The size of the array can be obtained using the `size()` member function. Whether
    the container is empty can be checked using the `empty()` function, which returns
    *true* if `size()` is zero.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`size()`成员函数获取数组的大小。是否为空容器可以使用`empty()`函数检查，如果`size()`为零，则返回*true*。
- en: The array class is defined in the `<array>` header file, which has to be included
    before usage.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数组类在`<array>`头文件中定义，在使用之前必须包含。
- en: Vector
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量
- en: 'The vector container is a data structure of contiguous elements whose size
    can be dynamically modified: it does not require to specify its size at creation
    time:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 向量容器是一个可以动态修改大小的连续元素数据结构：在创建时不需要指定其大小：
- en: '![Figure 5.3: Vector elements are contiguous, and their size can grow dynamically](img/C11557_05_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：向量元素是连续的，并且其大小可以动态增长](img/C11557_05_03.jpg)'
- en: 'Figure 5.3: Vector elements are contiguous, and their size can grow dynamically'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.3：向量元素是连续的，并且其大小可以动态增长
- en: The `vector` class is defined in the `<vector>` header file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`类在`<vector>`头文件中定义。'
- en: 'A vector stores the elements it contains in a single section of memory. Usually,
    the section of memory has enough space for more elements than the number of elements
    stored in the vector. When a new element is added to the vector, if there is enough
    space in the section of memory, the element is added after the last element in
    the vector. If there isn''t enough space, the vector gets a new, bigger section
    of memory and copies all the existing elements into the new section of memory,
    then it deletes the old section of memory. To us, it will seem like the size of
    the section of memory has increased:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 向量将包含的元素存储在内存的单个部分中。通常，这个内存部分有足够的空间来存储比向量中存储的元素数量更多的元素。当向向量中添加新元素时，如果内存部分中有足够的空间，则该元素将被添加到向量的最后一个元素之后。如果没有足够的空间，向量将获得一个新的、更大的内存部分，并将所有现有元素复制到新的内存部分中，然后删除旧的内存部分。对我们来说，这会给人一种内存部分大小增加的印象：
- en: '![Figure 5.4: Memory allocation of vectors](img/C11557_05_04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：向量的内存分配](img/C11557_05_04.jpg)'
- en: 'Figure 5.4: Memory allocation of vectors'
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.4：向量的内存分配
- en: When the vector is created, it is empty.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当向量被创建时，它是空的。
- en: Most of the interface is similar to the array's, but with a few differences.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数接口与数组类似，但有一些差异。
- en: Elements can be appended using the `push_back()` function or inserted at a generic
    position using the `insert()` function. The last element can be removed using
    `pop_back()` or at a generic position using the `erase()` function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`push_back()`函数追加元素，或使用`insert()`函数在通用位置插入元素。可以使用`pop_back()`移除最后一个元素，或使用`erase()`函数在通用位置移除元素。
- en: 'Appending or deleting the last element is fast, while inserting or removing
    other elements of the vector is considered slow, as it requires moving all the
    elements to make space for the new element or to keep all the elements contiguous:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 添加或删除最后一个元素是快速的，而插入或删除 vector 的其他元素被认为是慢的，因为这需要移动所有元素来为新元素腾出空间或保持所有元素连续：
- en: '![Figure 5.5: Elements being moved during insertions or deletions inside a
    vector](img/C11557_05_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5：在 vector 中插入或删除元素时正在移动的元素](img/C11557_05_05.jpg)'
- en: 'Figure 5.5: Elements being moved during insertions or deletions inside a vector'
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.5：在 vector 中插入或删除元素时正在移动的元素
- en: Vectors, just like arrays, allow efficient access of elements at random positions.
    A vector's size is also retrieved with the `size()` member function, but this
    should not be confused with `capacity()`. The former is the actual number of elements
    in the vector, and the latter returns the maximum number of elements that can
    be inserted in the current section of memory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，就像数组一样，允许高效地访问随机位置的元素。向量的大小也可以通过 `size()` 成员函数检索，但不应与 `capacity()` 混淆。前者是向量中实际元素的数量，后者返回当前内存区域可以插入的最大元素数量。
- en: For example, in the preceding diagram, initially, the array had a size of 4
    and a capacity of 8\. So, even when an element had to be moved to the right, the
    vector's capacity did not change, as we never had to get a new, bigger section
    of memory to store the elements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在先前的图中，最初数组的大小为 4，容量为 8。因此，即使需要将元素移动到右侧，vector 的容量也不会改变，因为我们从未需要获取一个更大的内存区域来存储元素。
- en: The operation of getting a new section of memory is called reallocation. Since
    reallocation is considered an expensive operation, it is possible to *reserve*
    enough memory for a given number of elements by enlarging a vector's capacity
    using the `reserve()` member function. The vector's capacity can also be reduced
    to fit the number of elements using the `shrink_to_fit()` function in order to
    release memory that is not needed anymore.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 获取新内存区域的操作称为重新分配。由于重新分配被认为是一项昂贵的操作，因此可以通过使用 `reserve()` 成员函数扩大 vector 的容量来为给定数量的元素预留足够的内存。还可以使用
    `shrink_to_fit()` 函数来减少 vector 的容量以适应元素数量，从而释放不再需要的内存。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Vector is the most commonly used container for a sequence of elements and is
    often the best one performance-wise.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是最常用的元素序列容器，并且在性能方面通常是最佳选择。
- en: 'Let''s look at the following example to understand how `vector::front()` and
    `vector::back()` work in C++:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来了解 C++ 中的 `vector::front()` 和 `vector::back()` 是如何工作的：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Deque
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双端队列
- en: 'The *deque* container (pronounced *deck)* is short for "double-ended queue."
    Like *vector*, it allows for fast, direct access of deque elements and fast insertion
    and deletion at the back. Unlike *vector*, it also allows for fast insertion and
    deletion at the front of the deque:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*deque* 容器（发音为 *deck*）代表“双端队列”。与 *vector* 类似，它允许快速直接访问 deque 元素，并在两端快速插入和删除。与
    *vector* 不同，它还允许在 deque 的前端快速插入和删除：'
- en: '![Figure 5.6: Deque elements can be added and removed at the start and the
    end](img/C11557_05_06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：双端队列元素可以在开始和结束处添加和删除](img/C11557_05_06.jpg)'
- en: 'Figure 5.6: Deque elements can be added and removed at the start and the end'
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.6：双端队列元素可以在开始和结束处添加和删除
- en: The `deque` class is defined in the `<deque>` header file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`deque` 类定义在 `<deque>` 头文件中。'
- en: '*Deque* generally requires more memory than *vector*, and *vector* is more
    performant for accessing the elements and `push_back`, so unless it is required
    to insert at the front, *vector* is usually preferred.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*deque* 通常比 *vector* 需要更多的内存，而 *vector* 在访问元素和 `push_back` 操作方面性能更优，因此除非需要在前端插入，否则通常更倾向于使用
    *vector*。'
- en: List
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'The list container is a data structure of nonadjacent elements that can be
    dynamically grown:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表容器是一种非相邻元素的数据结构，可以动态增长：
- en: '![Figure 5.7: List elements are stored in different sections of memory, and
    have connecting links ](img/C11557_05_07.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：列表元素存储在内存的不同部分，并且有连接的链接](img/C11557_05_07.jpg)'
- en: 'Figure 5.7: List elements are stored in different sections of memory, and have
    connecting links'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.7：列表元素存储在内存的不同部分，并且有连接的链接
- en: The `list` class is defined in the `<list>` header file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 类定义在 `<list>` 头文件中。'
- en: Each element in the list has its memory segment and a link to its predecessor
    and its successor. The structure containing the element, which is the link to
    its predecessor and to its successor, is called a **node**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个元素都有其内存段以及指向其前驱和后继的链接。包含元素的结构，即指向其前驱和后继的链接，称为 **节点**。
- en: 'When an element is inserted in a list, the predecessor node needs to be updated
    so that its successor link points to the new element. Similarly, the successor
    node needs to be updated so that its predecessor link points to the new element:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当在列表中插入元素时，需要更新前驱节点，以便其后继链接指向新元素。同样，后继节点也需要更新，以便其前驱链接指向新元素：
- en: '![Figure 5.8: C is to be inserted between A and B. A''s successor and B''s
    predecessor link must be updated to point to C (orange). C''s link to the predecessor
    and successor are updated to points A and B (green)](img/C11557_05_08.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8：C 应插入到 A 和 B 之间。A 的后继节点和B的前驱链接必须更新以指向 C（橙色）。C 的前驱和后继链接更新为指向 A 和 B（绿色）](img/C11557_05_08.jpg)'
- en: 'Figure 5.8: C is to be inserted between A and B. A''s successor and B''s predecessor
    link must be updated to point to C (orange). C''s link to the predecessor and
    successor are updated to points A and B (green)'
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.8：C 应插入到 A 和 B 之间。A 的后继节点和B的前驱链接必须更新以指向 C（橙色）。C 的前驱和后继链接更新为指向 A 和 B（绿色）
- en: When an element is removed from the list, we need to update the successor link
    of the predecessor node to point to the successor of the removed node. Similarly,
    the predecessor link of the successor node needs to be updated to point to the
    predecessor of the removed node.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当从列表中删除元素时，需要更新前驱节点的前驱链接，使其指向被删除节点的后继。同样，后继节点的前驱链接需要更新，使其指向被删除节点的前驱。
- en: In the preceding diagram, if we were to remove **C**, we would have to update
    **A**'s successor to point to **C**'s successor (**B**), and **B**'s predecessor
    to point to **C**'s predecessor (**A**).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，如果我们删除 **C**，我们必须更新 **A** 的后继以指向 **C** 的后继（**B**），以及 **B** 的前驱以指向 **C**
    的前驱（**A**）。
- en: 'Unlike vectors, lists do not provide random access. Elements are accessed by
    linearly following the chain of elements: starting from the first, we can follow
    the successor link to find the next node, or from the last node we can follow
    the predecessor link to find the previous node, until we reach the element we
    are interested into.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与向量不同，列表不提供随机访问。元素通过线性遍历元素链来访问：从第一个开始，我们可以跟随后继链接找到下一个节点，或者从最后一个节点开始，我们可以跟随前驱链接找到前一个节点，直到我们达到感兴趣的元素。
- en: The advantage of `list` is that insertion and removal are fast at any position,
    if we already know the node at which we want to insert or remove. The disadvantage
    of this is that getting to a specific node is slow.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 的优点是，如果我们已经知道想要插入或删除的节点，则插入和删除操作在任何位置都很快。缺点是到达特定节点较慢。'
- en: The interface is similar to a vector, except that lists don't provide `operator[]`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接口类似于向量，除了列表不提供 `operator[]`。
- en: Forward-List
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前向链表
- en: 'The `forward_list` container is similar to the list container, with the difference
    that its nodes only have the link to the successor. For this reason, it is not
    possible to iterate over a `forward_list` in backward order:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward_list` 容器类似于列表容器，不同之处在于其节点只有指向后继的链接。因此，无法以反向顺序遍历 `forward_list`：'
- en: '![Figure 5.9: Forward-list elements are like List, but only have one-way connecting
    links](img/C11557_05_09.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9：前向链表元素类似于链表，但只有单向连接链接](img/C11557_05_09.jpg)'
- en: 'Figure 5.9: Forward-list elements are like List elements, but only have one-way
    connecting links'
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.9：前向链表元素类似于链表元素，但只有单向连接链接
- en: As usual, the `forward_list` class is defined in the `<forward_list>` header
    file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，`forward_list` 类在 `<forward_list>` 头文件中定义。
- en: The `forward_list` class does not even provide `push_back()` or `size()`. Inserting
    an element is done using `insert_after()`, which is a variation of the `insert()`
    function, where the new element is inserted after the provided position. The same
    idea applies to element removal, which is done through `erase_after()`, which
    removes the element after the provided position.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward_list` 类甚至不提供 `push_back()` 或 `size()`。插入元素是通过 `insert_after()` 完成的，它是
    `insert()` 函数的一种变体，其中新元素被插入到提供的位置之后。同样的原理也适用于元素删除，通过 `erase_after()` 完成删除，它删除提供的位置之后的元素。'
- en: Providing Initial Values to Sequence Containers
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向序列容器提供初始值
- en: All the sequence containers we have looked at are empty when they are first
    created.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看的所有序列容器在首次创建时都是空的。
- en: When we want to create a container containing some elements, it can be repetitive
    to call the `push_back()` or `insert()` functions repeatedly for each element.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要创建包含一些元素的容器时，对于每个元素重复调用`push_back()`或`insert()`函数可能会很繁琐。
- en: Fortunately, all the containers can be initialized with a sequence of elements
    when they are created.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，所有容器在创建时都可以使用一系列元素进行初始化。
- en: 'The sequence must be provided in curly brackets, and the elements need to be
    comma-separated. This is called an initializer list:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在花括号内提供序列，并且元素需要用逗号分隔。这被称为初始化列表：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This works for any of the containers we have seen in this chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于本章中我们看到的任何容器。
- en: 'Activity 19: Storing User Accounts'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动第19项：存储用户账户
- en: We want to store the account balance, stored as an `int` instance, for 10 users.
    The account balance starts with 0\. We then want to increase the balance of the
    first and last user by 100.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要存储10个用户的账户余额，存储为`int`实例，初始值为0。然后我们想要将第一个和最后一个用户的余额增加100。
- en: 'These steps will help you complete the activity:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成活动：
- en: Include the header for the `array` class.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含`array`类的头文件。
- en: Declare an integer array of ten elements.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个包含十个元素的整数数组。
- en: Initialize the array using the `for` loop. The `size()` operator to evaluate
    the size of the array and the `operator[]` to access every position of the array.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环初始化数组。使用`size()`运算符来评估数组的大小，以及使用`operator[]`来访问数组的每个位置。
- en: Update the value for the first and last user.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新第一个和最后一个用户的值。
- en: Note
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 304.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第304页找到。
- en: 'Now let’s do the same using a vector:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用vector来做同样的事情：
- en: Include the **vector** header.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含**vector**头文件。
- en: Declare a vector of integer type and reserve memory to store 100 users with
    resize it to be able to contain 10 users.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个整数类型的`vector`并预留内存以存储100个用户，并能够调整大小以容纳10个用户。
- en: Use a for loop to initialize the vector.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用for循环初始化vector。
- en: With this activity, we learned how we can store an arbitrary number of accounts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个活动，我们学习了如何存储任意数量的账户。
- en: Associative Containers
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联容器
- en: '`operator<`, although the user can supply a `Functor` (function object) as
    a parameter to specify how the elements should be compared. The `<functional>`
    header contains many such objects that can be used to sort the associative containers,
    like `std::less` or `std::less`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator<`，尽管用户可以提供一个`Functor`（函数对象）作为参数来指定元素应该如何比较。《<functional>`头文件包含许多这样的对象，可以用于排序关联容器，如`std::less`或`std::less`。'
- en: '![Figure 5.10: Table representing associative containers and its description](img/C11557_05_10.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10：表示关联容器及其描述的表格](img/C11557_05_10.jpg)'
- en: 'Figure 5.10: Table presenting associative containers and their descriptions'
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.10：展示关联容器及其描述的表格
- en: Typically, associative containers are implemented as variations of binary trees,
    providing fast element lookup by exploiting the logarithmic complexity of the
    underlying structure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关联容器被实现为二叉树的变体，通过利用底层结构的对数复杂度提供快速的元素查找。
- en: Set and Multiset
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Set和Multiset
- en: 'A **Set** is a container that contains a unique group of sorted elements. A
    **Multiset** is similar to *Set*, but it allows duplicate elements:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Set**是一个包含一组排序元素的容器。**Multiset**与*Set*类似，但它允许重复元素：'
- en: '![Figure 5.11: Set and Multiset store a sorted group of elements](img/C11557_05_11.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11：Set和Multiset存储一组排序后的元素](img/C11557_05_11.jpg)'
- en: 'Figure 5.11: Set and Multiset store a sorted group of elements'
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.11：Set和Multiset存储一组排序后的元素
- en: Set and multiset have `size()` and `empty()` function members to check how many
    elements are contained and whether any elements are contained.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`和`multiset`有`size()`和`empty()`成员函数来检查包含了多少个元素以及是否包含任何元素。'
- en: Insertion and removal is done through the `insert()` and `erase()` functions.
    Because the order of the elements is determined by the *comparator*, they do not
    take a position argument like they do for sequential containers. Both insertion
    and removal are fast.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 插入和删除操作通过`insert()`和`erase()`函数完成。由于元素的顺序由*比较器*决定，它们不需要像顺序容器那样提供一个位置参数。插入和删除操作都很快速。
- en: Since sets are optimized for element lookup, they provide special search functions.
    The `find()` function returns the position of the first element equal to the provided
    value, or the position past the end of the set when the element is not found.
    When we look for an element with `find`, we should always compare it with the
    result of calling `end()` on the container to check whether the element was found.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合优化了元素查找，它们提供了特殊的搜索函数。`find()` 函数返回与提供的值相等的第一个元素的位置，如果找不到元素，则返回集合末尾之后的位置。当我们使用
    `find` 查找元素时，我们应该始终将其与容器上调用 `end()` 的结果进行比较，以检查元素是否被找到。
- en: 'Let''s examine the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下代码：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, `count()` returns the number of elements equal to the value provided.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`count()` 返回与提供的值相等的元素数量。
- en: The `set` and `multiset` classes are defined in the `<set>` header file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 和 `multiset` 类定义在 `<set>` 头文件中。'
- en: 'Example of a set with a custom comparator:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义比较器的集合示例：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: 'Ascending numbers: 1 2 3 4 5'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 递增数字：1 2 3 4 5
- en: 'Descending numbers: 5 4 3 2 1'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 递减数字：5 4 3 2 1
- en: Map and Multimap
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Map 和 Multimap
- en: '**Map** and **multimap** are containers that manage **key/value** pairs as
    elements. The elements are sorted automatically according to the provided comparator
    and applied to the *key*: the *value* does not influence the order of the elements:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**Map** 和 **multimap** 是管理 **键/值** 对作为元素的容器。元素根据提供的比较器自动排序并应用于 *键*：*值* 不影响元素的顺序：'
- en: '![Figure 5.12: Map and multimap store a sorted group of keys, which is associated
    to a value](img/C11557_05_12.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12：Map 和 multimap 存储一组排序后的键，这些键与值相关联](img/C11557_05_12.jpg)'
- en: 'Figure 5.12: Map and multimap store a sorted group of keys, which is associated
    to a value'
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.12：Map 和 multimap 存储一组排序后的键，这些键与值相关联
- en: Map allows you to associate a single value to a key, while multimap allows you
    to associate multiple values to the same key.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Map 允许您将单个值与键关联，而 multimap 允许您将多个值与相同的键关联。
- en: The `map` and `multimap` classes are defined in the `<map>` header file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 和 `multimap` 类定义在 `<map>` 头文件中。'
- en: To insert values into a map, we can call `insert()`, providing a `true` if the
    element was inserted, or `false` if an element with the same key already exists.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值插入到映射中，我们可以调用 `insert()`，如果元素被插入，则提供 `true`，如果已存在具有相同键的元素，则提供 `false`。
- en: Once values are inserted into the map, there are several ways to look up a key/value
    pair in a map.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将值插入到映射中，就有几种方法可以在映射中查找键/值对。
- en: Similar to set, map provides a `find()` function, which looks for a key in the
    map and returns the position of the key/value pair if it exists, or the same result
    of calling `end()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与集合类似，map 提供了一个 `find()` 函数，该函数在映射中查找一个键，如果存在，则返回键/值对的位置，如果找不到元素，则返回调用 `end()`
    的相同结果。
- en: 'From the position, we can access the key with `position->first` and the value
    with `position->second`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从位置，我们可以使用 `position->first` 访问键，使用 `position->second` 访问值：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An alternative to accessing a value from a key is to use `at()`, which takes
    a key and returns the associated value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从键访问值的一个替代方法是使用 `at()`，它接受一个键并返回关联的值。
- en: If there is no associated value, `at()` will throw an exception.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有关联的值，`at()` 将抛出异常。
- en: A last alternative to get the value associated with a key is to use `operator[]`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 获取与键关联的值的最后一个替代方法是使用 `operator[]`。
- en: 'The `operator[]` returns the value associated with a key, and if the key is
    not present, it inserts a new key/value pair with the provided key, and a default
    value for the value. Because `operator[]` could modify the map by inserting into
    it, it cannot be used on a *const* map:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator[]` 返回与键关联的值，如果键不存在，则使用提供的键插入一个新的键/值对，并为值提供一个默认值。因为 `operator[]` 可能会通过插入来修改映射，所以它不能用于
    `*const*` 映射：'
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Activity 20: Retrieving a User''s Balance from their Given Username'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 20：从给定的用户名中检索用户的余额
- en: We'd like to be able to quickly retrieve the balance of a user given their username.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够快速检索给定用户名的用户余额。
- en: To quickly retrieve the balance from the username, we store the balance inside
    a map, using the name of the user as a key.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速从用户名中检索余额，我们使用用户名作为键，将余额存储在一个映射中。
- en: The name of the user is of type `std::string`, while the balance is an `int`.
    Add the balance for the users `Alice`, `Bob`, and `Charlie` with a balance of
    50 each. Then, check whether the user `Donald` has a balance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名是 `std::string` 类型，而余额是 `int` 类型。为用户 `Alice`、`Bob` 和 `Charlie` 每人添加 50 的余额。然后，检查用户
    `Donald` 是否有余额。
- en: 'Finally, print the account balance of `Alice`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打印 `Alice` 的账户余额：
- en: 'Include the header file for the `map` class and the header for `string`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 `map` 类的头部文件和 `string` 的头部文件：
- en: '[PRE6]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create a map with the key being `std::string` and the value being `int`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个键为 `std::string`，值为 `int` 的映射。
- en: 'Insert the balances of the users inside the map by using `insert` and `std::make_pair`.
    The first argument is the `key`, while the second one is the `value`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `insert` 和 `std::make_pair` 将用户的余额插入到映射中。第一个参数是 `key`，而第二个参数是 `value`：
- en: '[PRE7]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Use the `find` function, providing the name of the user to find the position
    of the account in the map. Compare it with `end()` to check whether a position
    was found.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `find` 函数，提供要查找的用户名以找到账户在映射中的位置。将其与 `end()` 进行比较以检查是否找到了位置。
- en: 'Now, look for the account of Alice. We know Alice has an account, so there
    is no need to check whether we found a valid position. We can print the value
    of the account using `->second`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，查找爱丽丝的账户。我们知道爱丽丝有一个账户，因此没有必要检查我们是否找到了一个有效的位置。我们可以使用 `->second` 打印账户的值：
- en: '[PRE8]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 305.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第305页找到。
- en: Unordered Containers
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无序容器
- en: '**Unordered associative containers** differ from associative containers in
    that the elements have no defined order. Visually, unordered containers are often
    imagined as bags of elements. Because the elements are not sorted, unordered containers
    do not accept a comparator object to provide an order to the elements. On the
    other hand, all the unordered containers depend on a hash function.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**无序关联容器**与关联容器不同，其元素没有定义的顺序。直观上，无序容器通常被想象成元素的袋子。因为元素没有排序，无序容器不接受比较器对象来为元素提供顺序。另一方面，所有无序容器都依赖于哈希函数。'
- en: 'he user can provide a `Functor` (function object) as a parameter to specify
    how the keys should be hashed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以将 `Functor`（函数对象）作为参数提供，以指定如何对键进行哈希：
- en: '![Figure 5.13: Table representing unordered container and its description](img/C11557_05_13.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13：表示无序容器及其描述的表](img/C11557_05_13.jpg)'
- en: 'Figure 5.13: Table presenting unordered containers and their descriptions'
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.13：展示无序容器及其描述的表
- en: Typically, unordered containers are implemented as **hash tables**. The position
    in the array is determined using the hash function, which given a value returns
    the position at which it should be stored. Ideally, most of the elements will
    be mapped into different positions, but the hash function can potentially return
    the same position for different elements. This is called a *collision*. This problem
    is solved by using linked lists to chain elements that map into the same position,
    so that multiple elements can be stored in the same position. Because there might
    be multiple elements at the same position, the position is often called **bucket**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，无序容器被实现为 **哈希表**。数组的定位是通过哈希函数确定的，该函数给定一个值返回它应该存储的位置。理想情况下，大多数元素将被映射到不同的位置，但哈希函数可能会为不同的元素返回相同的位置。这被称为
    *碰撞*。这个问题通过使用链表将映射到相同位置的元素链接起来来解决，这样就可以在同一个位置存储多个元素。因为可能在同一个位置有多个元素，所以这个位置通常被称为
    **桶**。
- en: 'Implementing unordered containers using a hash table allows us to find an element
    with a specific value in constant time complexity, which translates to an even
    faster lookup when compared to associative containers:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希表实现无序容器允许我们在常数时间内找到具有特定值的元素，这比关联容器更快：
- en: '![Figure 5.14: When an element is added to the set, its hash is computed to
    decide in which bucket the element should be added. The elements inside a bucket
    are stored in a list.](img/C11557_05_14.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14：当元素被添加到集合中时，计算其哈希值以决定元素应该添加到哪个桶中。桶内的元素存储在列表中。](img/C11557_05_14.jpg)'
- en: 'Figure 5.14: When an element is added to the set, its hash is computed to decide
    in which bucket the element should be added. The elements inside a bucket are
    stored as nodes of a list.'
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.14：当元素被添加到集合中时，计算其哈希值以决定元素应该添加到哪个桶中。桶内的元素存储为列表的节点。
- en: 'When a key/value pair is added to the map, the hash of the key is computed
    to decide in which bucket the key/value pair should be added:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当将键/值对添加到映射中时，计算键的哈希值以决定键/值对应该添加到哪个桶中：
- en: '![Figure 5.15: Representation of storing the bucket elements in a list.](img/C11557_05_15.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图5.15：表示在列表中存储桶元素。](img/C11557_05_15.jpg)'
- en: 'Figure 5.15: Representation of computing the bucket of an element from the
    key, and storing the key/value pair as nodes in a list.'
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.15：从键计算元素桶的表示，并将键/值对作为列表中的节点存储。
- en: Unordered associative containers and ordered associative containers provide
    the same functionalities, and the explanations in the previous section apply to
    the unordered associative containers as well. Unordered associative containers
    can be used to get better performances when the order of the elements is not important.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 无序关联容器和有序关联容器提供相同的功能，前一小节中的解释也适用于无序关联容器。无序关联容器可以在元素顺序不重要时提供更好的性能。
- en: Container Adaptors
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器适配器
- en: Additional container classes that are provided by the STL library are container
    adaptors. Container adaptors provide constrained access policies on top of the
    containers we have looked at in this chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: STL 库提供的附加容器类是容器适配器。容器适配器在我们在本章中查看的容器之上提供了受限的访问策略。
- en: 'Container adaptors have a template parameter that the user can provide to specify
    the type of container to wrap:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 容器适配器有一个模板参数，用户可以提供以指定要包装的容器类型：
- en: '![](img/Image18089.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image18089.jpg)'
- en: 'Figure 5.16: Table presenting container adaptors and their descriptions'
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.16：展示容器适配器和其描述的表格
- en: Stack
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈
- en: The stack container implements the LIFO access policy, where the elements are
    virtually stacked one on the top of the other so that the last inserted element
    is always on top. Elements can only be read or removed from the top, so the last
    inserted element is the first that gets removed. A stack is implemented using
    a sequence container class internally, which is used to store all the elements
    and emulate the stack behavior.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 栈容器实现了 LIFO 访问策略，其中元素虚拟地堆叠在彼此之上，使得最后插入的元素始终位于顶部。元素只能从顶部读取或移除，因此最后插入的元素是第一个被移除的。栈是通过内部使用序列容器类实现的，用于存储所有元素并模拟栈行为。
- en: 'The access pattern of the stack data structure happens mainly through three
    core member functions: `push()`, `top()`, and `pop()`. The `push()` function is
    used to insert an element into the stack, `top()` used to access the element on
    top of the stack, and `pop()` is used to remove the top element.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 栈数据结构的访问模式主要通过三个核心成员函数：`push()`、`top()` 和 `pop()`。`push()` 函数用于将元素插入栈中，`top()`
    用于访问栈顶元素，而 `pop()` 用于移除栈顶元素。
- en: The `stack` class is defined in the `<stack>` header file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`stack` 类在 `<stack>` 头文件中定义。'
- en: Queue
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列
- en: The `queue` class implements the FIFO access policy, where the elements are
    enqueued one after the other, so that elements inserted before are ahead of elements
    inserted after. Elements are inserted at the end of the queue and removed at the
    start.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue` 类实现了 FIFO 访问策略，其中元素依次入队，因此先插入的元素位于后插入的元素之前。元素在队列末尾插入，在队列开头移除。'
- en: The interface of the queue data structure is composed of the `push()`, `front()`,
    `back()`, and `pop()` member functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 队列数据结构的接口由 `push()`、`front()`、`back()` 和 `pop()` 成员函数组成。
- en: The `push()` function is used to insert an element into the `queue()`; `front()`
    and `back()` return the next and last elements of the queue, respectively; the
    `pop()` is used to remove the next element from the queue.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()` 函数用于将一个元素插入到 `queue()` 中；`front()` 和 `back()` 分别返回队列的下一个和最后一个元素；`pop()`
    用于从队列中移除下一个元素。'
- en: The `queue` class is defined in the `<queue>` header file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue` 类在 `<queue>` 头文件中定义。'
- en: Priority Queue
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先队列
- en: Finally, the priority queue is a queue where the elements are accessed according
    to their priority, in descending order (highest priority first).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，优先队列是一个根据元素的优先级进行访问的队列，按降序排列（优先级最高者先访问）。
- en: The interface is similar to the normal queue, where `push()` inserts a new element
    and `top()` and `pop()` access and remove the next element. The difference is
    in the way the next element is determined. Rather than being the first inserted
    element, it is the element that has the highest priority.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接口类似于正常队列，其中 `push()` 插入新元素，`top()` 和 `pop()` 访问和移除下一个元素。不同之处在于确定下一个元素的方式。它不是第一个插入的元素，而是具有最高优先级的元素。
- en: By default, the priority of the elements is computed by comparing the elements
    with the `operator<`, so that an element that is less than another comes after
    it. A user-defined sorting criterion can be provided to specify how to sort the
    elements by priority in regard to their priority in the queue.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，元素的优先级是通过比较元素与`operator<`来计算的，因此小于另一个元素的元素会跟在其后。可以提供一个用户定义的排序标准来指定如何根据优先级对队列中的元素进行排序。
- en: The priority queue class is also defined in the `<queue>` header file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列类也在`<queue>`头文件中定义。
- en: 'Activity 21: Processing User Registration in Order'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动21：按顺序处理用户注册
- en: When a user registers to our website, we need to process the registration form
    at the end of the day.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户注册到我们的网站时，我们需要在当天结束时处理注册表单。
- en: 'We want to process the registration in reverse order of registration:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望按注册顺序的相反顺序处理注册：
- en: 'Assume that the class for the registration form is already provided:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设注册表单的类已经提供：
- en: '[PRE9]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create a `stack` to store the users.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`stack`来存储用户。
- en: 'We want to store the user registration form when the user registers, as well
    as process the registration at the end of the day. The function for processing
    the form is provided:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在用户注册时存储用户注册表单，并在当天结束时处理注册。处理表单的函数已提供：
- en: '[PRE10]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Additionally, there are already two functions that are called when a user registers.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，当用户注册时，已经有两个函数被调用。
- en: 'Fill the code inside the following two functions to store the user form and
    process it:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下两个函数中填写代码以存储用户表单并处理它：
- en: '[PRE11]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We'll see that the registration forms are processed in reverse order as the
    users are registered.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到，由于用户注册，注册表单是按注册顺序的相反顺序处理的。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found at page 306.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第306页找到。
- en: Unconventional Containers
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非常规容器
- en: Up until now, we've seen containers that are used to store groups of elements
    of the same type.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了用于存储相同类型元素组的容器。
- en: The C++ standard defines some other types that can contain types but offer a
    different set of functionalities from the containers we saw previously.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准定义了一些其他类型，可以包含类型，但它们提供的功能集与之前看到的容器不同。
- en: 'These types are as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型如下：
- en: String
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串
- en: Pair and tuple
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对和元组
- en: Optional
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选
- en: Variant
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变体
- en: Strings
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A string is a data structure that''s used to manipulate mutable sequences of
    contiguous characters. The C++ string classes are STL containers: they behave
    similarly to *vectors*, but provide additional functionalities that ease the programmer
    to perform common operations of sequences of characters easily.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一种用于操作连续字符的可变序列的数据结构。C++字符串类是STL容器：它们的行为类似于*向量*，但提供了额外的功能，使程序员能够轻松地执行字符序列的常见操作。
- en: There exist several string implementations in the standard library that are
    useful for different lengths of character sets, such as `string`, `wstring`, `u16string`,
    and `u32string`. All of them are a specialization of the `basic_string` base class
    and they all have the same interface.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中存在几种字符串实现，适用于不同长度的字符集，例如`string`、`wstring`、`u16string`和`u32string`。所有这些都是`basic_string`基类的特化，并且它们都具有相同的接口。
- en: The most commonly used type is `std::string`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的类型是`std::string`。
- en: All types and functions for strings are deﬁned in the `<string>` header file.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字符串类型和函数都在`<string>`头文件中定义。
- en: A string can be converted into a *null-terminating string*, which is an array
    of characters that terminate with the special null character (represented with
    '`\0`') via the use of the `data()` or `c_str()` functions. Null-terminating strings,
    also called *C-strings*, are the way to represent sequences of character in the
    C language and they are often used when the program needs to interoperate with
    a C library; they are represented with the `const char *` type and are the type
    of the *literal strings* in our programs.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以被转换为*空终止字符串*，这是一个以特殊空字符（用`'\0'`表示）终止的字符数组，通过使用`data()`或`c_str()`函数实现。空终止字符串，也称为*C-字符串*，是在C语言中表示字符序列的方式，它们在程序需要与C库交互时经常被使用；它们以`const
    char *`类型表示，并且是我们程序中*字面字符串*的类型。
- en: 'Exercise 12: Demonstrating Working Mechanism of the `c_str()` Function'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习12：演示`c_str()`函数的工作机制
- en: 'Let''s examine the following code to understand how the `c_str()` function
    works:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下代码以了解`c_str()`函数的工作原理：
- en: 'First include the required header files as illustrated:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先按照以下示例包含所需的头文件：
- en: '[PRE12]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, in the `main` function add a constant char variable named `charString`
    with capacity as `8` characters:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `main` 函数中添加一个名为 `charString` 的常量字符变量，其容量为 `8` 个字符：
- en: '[PRE13]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use the `c_str()` function and assign the value of `strString` to `charString2`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `c_str()` 函数并将 `strString` 的值赋给 `charString2`：
- en: '[PRE14]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Print the `charString` and `charString2` using the print function:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用打印函数打印 `charString` 和 `charString2`：
- en: '[PRE15]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As for vectors, strings have `size()`, `empty()`, and `capacity()` member functions,
    but there is an additional function called `length()`, which is just an alias
    for `size()`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向量而言，字符串有 `size()`、`empty()` 和 `capacity()` 成员函数，但还有一个额外的函数称为 `length()`，它只是
    `size()` 的别名。
- en: 'Strings can be accessed in a character-by-character fashion using `operator[]`
    or the `at()`, `front()`, and `back()` member functions:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `operator[]` 或 `at()`、`front()` 和 `back()` 成员函数逐字符访问字符串：
- en: '[PRE17]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The usual comparison operators are provided for strings, thus simplifying the
    way two string objects can be compared.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串提供了通常的比较运算符，从而简化了两个字符串对象之间的比较方式。
- en: Since strings are like vectors, we can add and remove characters from them.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串类似于向量，我们可以向它们添加和删除字符。
- en: Strings can be made empty by assigning an empty string, by calling the `clear()`,
    or `erase()` functions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过分配一个空字符串、调用 `clear()` 或 `erase()` 函数来使字符串为空。
- en: 'Let''s look at the following code to understand the usage of the `clear()`
    and `erase()` functions:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码，以了解 `clear()` 和 `erase()` 函数的用法：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: C++ also provides many convenience functions to convert a string into numeric
    values or vice versa. For example, the `stoi()` and `stod()` functions (which
    stand for *string-to-int* and *string-to-double*) are used to convert `string`
    to `int` and `double`, respectively. Instead, to convert a value into a string,
    it is possible to use the overloaded function `to_string()`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 还提供了许多便利函数，可以将字符串转换为数值或将数值转换为字符串。例如，`stoi()` 和 `stod()` 函数（分别代表 *string-to-int*
    和 *string-to-double*）用于将 `string` 转换为 `int` 和 `double`，相反，要将值转换为字符串，可以使用重载函数 `to_string()`。
- en: 'Let''s demystify these functions using the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码来揭示这些函数的神秘之处：
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Pairs and Tuples
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象对和元组
- en: The **pair** and **tuple** classes are similar to some extent, in the way they
    can store a collection of heterogeneous elements.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**pair** 和 **tuple** 类在某种程度上是相似的，因为它们可以存储异构元素集合。'
- en: The **pair** class can store the values of two types, while the **tuple** class
    extended this concept to any length.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**pair** 类可以存储两种类型的值，而 **tuple** 类扩展了这个概念，使其可以存储任意长度的值。'
- en: Pair is defined in the `<utility>` header, while tuple is in the `<tuple>` header.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对象对（Pair）定义在 `<utility>` 头文件中，而元组（tuple）定义在 `<tuple>` 头文件中。
- en: The pair constructor takes two types as template parameters, used to specify
    the types for the first and second values. Those elements are accessed directly
    using the `first` and `second` data. Equivalently, these members can be accessed
    with the `get<0>()` and `get<1>()` functions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对象对构造函数接受两个模板参数，用于指定第一个和第二个值的类型。这些元素可以直接使用 `first` 和 `second` 数据访问。等效地，这些成员也可以通过
    `get<0>()` 和 `get<1>()` 函数访问。
- en: 'The `make_pair()` convenience function is used to create a value pair without
    explicitly specifying the types:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 便利函数 `make_pair()` 用于创建一个值对，无需显式指定类型：
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second line is equivalent to the following one:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行等同于以下一行：
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Pairs are used by unordered map, unordered multimap, map, and multimap containers
    to manage their key/value elements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对象对（Pairs）被无序映射（unordered map）、无序多重映射（unordered multimap）、映射（map）和多重映射（multimap）容器用来管理它们的键/值元素。
- en: Tuples are similar to pairs. The constructor allows you to provide a variable
    number of template arguments. Elements are accessed with the `get<N>()` function
    only, which returns the nth element inside the tuple, and there is a convenience
    function to create them similar to that for pair, named `make_tuple()`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与对象对类似。构造函数允许你提供可变数量的模板参数。元素只能通过 `get<N>()` 函数访问，该函数返回元组内的第 n 个元素，并且有一个类似于对象对的便利函数来创建它们，名为
    `make_tuple()`。
- en: Additionally, tuples have another convenience function that's used to extract
    values from them. The `tie()` function allows for the creation of a tuple of references,
    which is useful in assigning selected elements from a tuple to specific variables.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，元组还有一个用于从它们中提取值的便利函数。`tie()` 函数允许创建一个引用元组，这在将元组中的选定元素赋给特定变量时很有用。
- en: 'Let''s understand how to use the `make_tuple()` and `get()` functions to retrieve
    data from a tuple:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何使用`make_tuple()`和`get()`函数从元组中检索数据：
- en: '[PRE22]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: std::optional
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`std::optional`'
- en: '`optional<T>` is a that''s used to contain a value that might be present or
    not.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`optional<T>`是一个用于包含可能存在或不存在值的模板。'
- en: The class takes a template parameter, `T`, which represents the type that the
    `std::optional` template class might contain. Value type means that the instance
    of the class contains the value. Copying `optional` will create a new copy of
    the contained data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 该类接受一个模板参数`T`，它表示`std::optional`模板类可能包含的类型。值类型表示类的实例包含值。复制`optional`将创建包含数据的新的副本。
- en: At any point in the execution of the program, `optional<T>` either contains
    nothing, when it's empty, or contains a value of type `T`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行的任何时刻，`optional<T>`要么为空，要么包含类型为`T`的值。
- en: Optional is defined in the `<optional>` header.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`定义在`<optional>`头文件中。'
- en: 'Let''s imagine our application is using a class named `User` for managing registered
    users. We would like to have a function that gets us the information of a user
    from their email: `User getUserByEmail(Email email);`.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们的应用程序正在使用名为`User`的类来管理注册用户。我们希望有一个函数可以从用户的电子邮件中获取用户信息：`User getUserByEmail(Email
    email);`。
- en: But what happens when a user is not registered? That is, when we can determine
    that our system does not have the associated `User` instance?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 但当用户未注册时会发生什么？也就是说，当我们确定我们的系统没有关联的`User`实例时？
- en: Some would suggest throwing an exception. In C++, exceptions are used for *exceptional*
    situations, ones that should almost never happen. A user not being registered
    on our website is a perfectly normal situation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人会建议抛出异常。在C++中，异常用于*异常*情况，这些情况几乎永远不会发生。用户未在我们的网站上注册是一个完全正常的情况。
- en: 'In these situations, we can use the `optional` template class to represent
    the fact that we might not have the data:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们可以使用`optional`模板类来表示我们可能没有数据的事实：
- en: '[PRE23]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `optional` template provides two easy methods to work with:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`optional`模板类提供了两种简单的方法来处理：'
- en: '`has_value()`: This returns `true` if `optional` is currently holding a value,
    and `false` if the variant is empty.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has_value()`: 如果`optional`当前持有值，则返回`true`，如果变体为空，则返回`false`。'
- en: '`value()`: This function returns the value currently held by `optional`, or
    throws an exception if it''s not present.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value()`: 此函数返回`optional`当前持有的值，如果不存在则抛出异常。'
- en: 'Additionally, `optional` can be used as a condition in an `if` statement: it
    will evaluate to `true` if it contains a value, or `false` otherwise.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，`optional`可以用作`if`语句中的条件：如果它包含值，则评估为`true`，否则为`false`。
- en: 'Let''s look at the following example to understand how the `has_value()` and
    `value()` functions work:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来了解`has_value()`和`value()`函数是如何工作的：
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `optional` template comes with additional convenience features. We can
    assign the `std::nullopt` value to `optional` to make it explicit when we want
    it empty, and we can use the `make_optional` value to create an optional from
    a value. Additionally, we can use the dereference operator, `*`, to access the
    value of `optional` without throwing an exception if the value is not present.
    In such cases, we will access invalid data, so we need to be sure that `optional`
    contains a value when we use `*`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`optional`模板类附带了一些额外的便利特性。我们可以将`std::nullopt`值赋给`optional`，以便在需要使其为空时明确表示，并且可以使用`make_optional`值从值创建一个可选对象。此外，我们可以使用解引用运算符`*`来访问`optional`的值，而无需抛出异常，如果值不存在。在这种情况下，我们将访问无效数据，因此我们需要确保在使用`*`时`optional`包含一个值：'
- en: '[PRE25]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Another handy method is `value_or(defaultValue)`. This function takes a default
    value and returns the value contained by `optional` if it currently holds a value,
    otherwise it returns the default value. Let''s explore the following example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方便的方法是`value_or(defaultValue)`。此函数接受一个默认值，如果`optional`当前持有值，则返回`optional`包含的值，否则返回默认值。让我们探索以下示例：
- en: '[PRE26]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In addition to return values, `optional` is useful when accepting it as an argument
    to represent arguments that can be present or not.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回值外，`optional`在作为参数接受时也很有用，可以表示可能存在或不存在的数据。
- en: 'Let''s recall our `User` class that''s composed of an email address, a phone
    number, and a physical address. Sometimes, users don''t have a phone number and
    don''t want to provide a physical address, so the only required field we have
    in `User` is the email address:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下由电子邮件地址、电话号码和物理地址组成的 `User` 类。有时，用户没有电话号码，也不希望提供物理地址，因此 `User` 中唯一必需的字段是电子邮件地址：
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This constructor allows us to pass in all the information we have on the user.
    If, instead of using `optional`, we used multiple overloads, we would have had
    four overloads:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此构造函数允许我们传入我们拥有的所有用户信息。如果我们不使用 `optional`，而是使用多个重载，我们将有四个重载：
- en: Only email
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅电子邮件
- en: Email and phone number
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电子邮件和电话号码
- en: Email and address
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电子邮件和地址
- en: Email with phone number and address
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电子邮件、电话号码和地址
- en: You can see that the number of overloads grows quickly when there are more arguments
    that we might not want to pass.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当有更多我们可能不想传递的参数时，重载的数量会迅速增加。
- en: std::variant
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::variant
- en: '`variant` is a value type that''s used to represent a *choice of types*. The
    class takes a list of types, and the variant will be able to contain one value
    of any of those types.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`variant` 是一个用于表示 *类型选择* 的值类型。该类接受一个类型列表，并且 `variant` 将能够包含这些类型中的任何一个值。'
- en: It is often referred to as **tagged union**, because similar to a union, it
    can store multiple types, with only one present at a time. It also keeps track
    of which type is currently stored.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常被称为 **标签联合体**，因为与联合体类似，它可以存储多个类型，但一次只有一个。它还跟踪当前存储的是哪种类型。
- en: During the execution of a program, `variant` will contain exactly one of the
    possible types at a time.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行过程中，`variant` 将一次只包含可能类型中的一个。
- en: 'Like `optional`, `variant` is a value type: when we create a copy of `variant`,
    the element that is currently stored is copied into the new `variant`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `optional` 类似，`variant` 是一个值类型：当我们创建 `variant` 的副本时，当前存储的元素将被复制到新的 `variant`
    中。
- en: 'To interact with `std::variant`, the C++ standard library gives us two main
    functions:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 `std::variant` 交互，C++ 标准库为我们提供了两个主要函数：
- en: '`holds_alternative<Type>(variant)`: It returns `true` if the variant is currently
    holding the provided type, if not then `false`.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holds_alternative<Type>(variant)`: 如果 `variant` 当前持有提供的类型，则返回 `true`，否则返回
    `false`。'
- en: '`get(variant)`: There are two versions: `get<Type>(variant)` and `get<Index>(variant)`.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(variant)`: 有两种版本：`get<Type>(variant)` 和 `get<Index>(variant)`。'
- en: '`get<Type>(variant)` gets the value of the type that''s currently stored inside
    the variant. Before calling this function, the caller needs to be sure that `holds_alternative<Type>(variant)`
    returns `true`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`get<Type>(variant)` 获取 `variant` 内当前存储的类型值。在调用此函数之前，调用者需要确保 `holds_alternative<Type>(variant)`
    返回 `true`。'
- en: '`get<Index>(variant)` gets the value of the index type that''s currently stored
    inside `variant`. Like before, the caller needs to be sure that `variant` is holding
    the correct type.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`get<Index>(variant)` 获取 `variant` 内当前存储的索引类型值。像之前一样，调用者需要确保 `variant` 持有正确的类型。'
- en: 'For example, with `std::variant<string, float> variant`, calling `get<0>(variant)`
    will give us the `string` value, but we need to be sure that `variant` is currently
    storing a string at the moment. Usually, it is preferable to access the elements
    with `get<Type>()` so that we are explicit on the type that we expect and that
    if the order of the types in the variant changes, we will still get the same result:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 `std::variant<string, float> variant`，调用 `get<0>(variant)` 将给出 `string`
    值，但我们需要确保 `variant` 当前存储的是字符串。通常，最好使用 `get<Type>()` 来访问元素，这样我们可以明确地指出我们期望的类型，并且如果
    `variant` 中类型的顺序发生变化，我们仍然会得到相同的结果：
- en: 'Exercise 13: Using Variant in the Program'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 13：在程序中使用 Variant
- en: 'Let''s perform the following steps to understand how to use variant in the
    program:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来了解如何在程序中使用 `variant`：
- en: 'Include the required header files:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含所需的头文件：
- en: '[PRE28]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the main function, add the variant with the value type as string and integer:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，添加具有字符串和整数值类型的 `variant`：
- en: '[PRE29]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now using the two print statements call the variant in different ways:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过两个打印语句以不同的方式调用 `variant`：
- en: '[PRE30]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'An alternative way to get the content of `variant` is to use `std::visit(visitor,
    variant)`, which takes `variant` and a callable object. The callable objects need
    to support an overload of `operator()`, taking a type for each of the possible
    types stored inside `variant`. Then, `visit` will make sure to call the function
    that accepts the current type that''s stored inside `variant`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`variant`内容的一种替代方法是使用`std::visit(visitor, variant)`，它接受`variant`和一个可调用对象。可调用对象需要支持`operator()`的重载，该重载接受`variant`内部可能存储的每种类型的类型。然后，`visit`将确保调用接受`variant`内部当前存储类型的函数：
- en: 'Exercise 14: Visitor Variant'
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 14：访问者变体
- en: 'Let''s perform the following steps to understand how to use std::visit(visitor,
    variant) in the program:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来了解如何在程序中使用`std::visit(visitor, variant)`：
- en: 'Add the following header files at the start of the program:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序开始处添加以下头文件：
- en: '[PRE32]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, add the struct Visitor as illustrated:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加如所示的结构体`Visitor`：
- en: '[PRE33]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, in the main function, call the struct Visitor and pass values as illustrated:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在主函数中，调用结构体`Visitor`并按如下所示传递值：
- en: '[PRE34]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE35]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`variant` is incredibly valuable when we want to represent a set of values
    of different types. Typical examples are as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要表示一组不同类型的数据时，`variant`非常有用。以下是一些典型示例：
- en: A function returning different types depending on the current state of the program
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据程序当前状态返回不同类型的函数
- en: A class that represents several states
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示多个状态的一个类
- en: Let's imagine our `std::optional<User> tryGetUserByEmail()` function, which
    we described earlier.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们之前描述的`std::optional<User> tryGetUserByEmail()`函数。
- en: Thanks to `optional`, we could now write the function in a clear way, showing
    that sometimes we would not retrieve the user. It is likely that if the user is
    not registered, we might ask them whether they want to register.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`optional`，我们现在可以以清晰的方式编写函数，表明有时我们可能不会检索到用户。如果用户未注册，我们可能会询问他们是否想要注册。
- en: Let's imagine we have `struct UserRegistrationForm`, which contains the information
    that's needed to let the user register.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们有一个`struct UserRegistrationForm`，它包含让用户注册所需的信息。
- en: Our function can now return `std::variant<User, UserRegistrationForm> tryGetUserByEmail()`.
    When the user is registered, we return `User`, but if the user is not registered,
    we can return the registration form.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能现在可以返回`std::variant<User, UserRegistrationForm> tryGetUserByEmail()`。当用户已注册时，我们返回`User`，但如果用户未注册，我们可以返回注册表单。
- en: 'Additionally, what should we do when there is an error? With `variant`, we
    could have `struct GetUserError` storing all the information we have so that our
    application will be able to recover from the error and add it to the return type:
    `std::variant<User`, `UserRegistrationForm`, `GetUserError>`, or `tryGetUserByEmail()`.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当出现错误时，我们应该怎么做？使用`variant`，我们可以有`struct GetUserError`存储所有信息，以便我们的应用程序能够从错误中恢复并添加到返回类型：`std::variant<User,
    UserRegistrationForm, GetUserError>`或`tryGetUserByEmail()`。
- en: Now we can have the complete picture of what is going to happen when we call
    `getUserByEmail()` by just looking at the function signature, and the compiler
    will help us make sure that we handle all the cases.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需查看函数签名，就可以看到调用`getUserByEmail()`时将要发生的事情的完整情况，编译器将帮助我们确保处理所有情况。
- en: Alternatively, `variant` can also be used to represent the various states in
    which a class can be. Each state contains the data that's required for that state,
    and the class only manages the transitions from one state to another.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`variant`也可以用来表示一个类可能处于的各种状态。每个状态包含该状态所需的数据，而类只管理从一个状态到另一个状态的转换。
- en: 'Activity 22: Airport System Management'
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 22：机场系统管理
- en: 'Let''s write a program to create airport system management:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序来创建机场系统管理：
- en: 'We want to represent the state of an airplane in an airport system. The airplane
    can be in three states: `at_gate`, `taxi`, or `flying`. The three states store
    different information.'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想在机场系统中表示飞机的状态。飞机可以在三种状态中：`at_gate`、`taxi`或`flying`。三种状态存储不同的信息。
- en: 'With `at_gate`, the airplane stores the gate number at which it is. With `taxi`,
    we store which lane the airplane is assigned and how many passengers are on board.
    With `flying`, we store the speed:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`at_gate`，飞机存储其所在的登机口编号。使用`taxi`，我们存储分配给飞机的航站楼车道以及机上的乘客数量。使用`flying`，我们存储速度：
- en: '[PRE36]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The airplane should have three methods:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 飞机应该有三个方法：
- en: '`startTaxi()`: This method takes the lane the airplane should go on and the
    number of passengers on board. The airplane can start taxi only if it is at the
    gate.'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startTaxi()`: 此方法接受飞机应行驶的航向和机上的乘客数量。飞机只有在位于登机口时才能开始滑行。'
- en: '`takeOff()`: This method takes the speed at which the airplane should fly.
    The airplane can start flying only if it is in the taxi state.'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeOff()`: 此方法接受飞机应飞行的速度。飞机只有在处于滑行状态时才能开始飞行。'
- en: '`currentStatus()`: This method prints the current status of the airplane.'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentStatus()`: 此方法打印飞机的当前状态。'
- en: Note
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 306.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第306页找到。
- en: Iterators
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'In this chapter, we''ve mentioned multiple times that elements have a position
    in a container: for example, we said that we can insert an element in a specific
    position in a list.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们多次提到元素在容器中有一个位置：例如，我们说我们可以在列表的特定位置插入一个元素。
- en: Iterators are the way in which the position of an element in a container is
    represented.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是表示容器中元素位置的方式。
- en: They provide a consistent way to operate on elements of the container, abstracting
    the details of the container to which the elements belong.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 它们提供了一种一致的方式来操作容器中的元素，抽象出元素所属容器的细节。
- en: An iterator always belongs to a range. The iterator representing the start of
    the range, can be accessed by the `begin()` function, while the iterator representing
    the end of the range, non-inclusive, can be obtained with the `end()` function.
    The range where the first element is included, but where the last one is excluded,
    is referred to as half-open.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器始终属于一个范围。表示范围开始的迭代器可以通过`begin()`函数访问，而表示范围结束的迭代器（非包含），可以通过`end()`函数获得。第一个元素包含但最后一个元素排除的范围被称为半开区间。
- en: 'The interface that the iterator must offer is composed of four functions:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器必须提供接口由四个函数组成：
- en: The `*` operator provides access to the element at the position currently referenced
    by the iterator.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*`运算符提供了访问迭代器当前引用位置的元素的方法。'
- en: The `++` operator is used to move forward to the next element.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`++`运算符用于向前移动到下一个元素。'
- en: Then, the `==` operator is used to compare two iterators to check whether they
    are pointing to the same position.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`==`运算符来比较两个迭代器，以检查它们是否指向相同的位置。
- en: 'Note that two iterators can only be compared if they are part of the same range:
    they must represent the position of elements of the same container.'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，只有当两个迭代器属于同一范围时，它们才能进行比较：它们必须代表同一容器中元素的位置。
- en: Finally, the `=` operator is used to assign an iterator.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`=`运算符来分配迭代器。
- en: Every container class in C++ must specify the type of iterator that it provides
    to access its elements as a member type alias named `iterator`. For example, for
    a vector of integer, the type would be `std::vector<int>::iterator`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，每个容器类都必须指定它提供的迭代器类型，作为名为`iterator`的成员类型别名。例如，对于整数向量，类型将是`std::vector<int>::iterator`。
- en: 'Let''s see how we could use iterators to iterate over all the elements of a
    container (a vector, in this case):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何可以使用迭代器遍历容器（在这种情况下是向量）的所有元素：
- en: '[PRE37]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This looks complex for such an operation, and we saw in *Chapter 1, Getting
    Started* how we can use *range-based for:*
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的操作，这看起来很复杂，我们在*第一章，入门*中看到了我们如何使用*基于范围的for循环*：
- en: '[PRE38]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'R*ange-based for* works thanks to iterators: the compiler rewrites our *range-based
    for* to look like the one we wrote with iterators. This allows the *range-based
    for* to work with any type that provides `begin()` and `end()` functions and returns
    iterators.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的for循环之所以能够工作，是因为迭代器：编译器将我们的*基于范围的for循环*重写为看起来像我们使用迭代器编写的那样。这使得*基于范围的for循环*可以与任何提供`begin()`和`end()`函数并返回迭代器的类型一起工作。
- en: The way operators provided by the iterators are implemented depends on the container
    on which the iterator operates.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器提供的操作符的实现方式取决于迭代器操作的容器。
- en: 'Iterator can be grouped into four categories. Each category builds on the previous
    category, thus offering additional functionality:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器可以分为四类。每一类都是基于前一类构建的，从而提供额外的功能：
- en: '![](img/C11557_05_17.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11557_05_17.jpg)'
- en: 'Figure 5.17: Table presenting iterators and their descriptions'
  id: totrans-352
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.17：展示迭代器和其描述的表格
- en: 'The following diagram gives more detail about C++ iterators:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了关于C++迭代器的更多详细信息：
- en: '![Figure 5.18: Representation of iterators in C++](img/C11557_05_18.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图5.18：C++中迭代器的表示](img/C11557_05_18.jpg)'
- en: 'Figure 5.18: Representation of iterators hierarchy in C++'
  id: totrans-355
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.18：C++ 中迭代器层次结构的表示
- en: 'Let''s understand each of these iterators in more detail:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解这些迭代器：
- en: '`==` and `!=` operators to check whether the iterator is equal to the `end()`
    value.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `==` 和 `!=` 运算符来检查迭代器是否等于 `end()` 值。
- en: Typically, input iterators are used to access elements from a stream of elements,
    where the whole sequence is not stored in memory, but we are obtaining one element
    at a time.
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，输入迭代器用于从元素流中访问元素，其中整个序列没有存储在内存中，但我们一次获取一个元素。
- en: '**Forward iterators** are very similar to input iterators but provide additional
    guarantees.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前向迭代器**与输入迭代器非常相似，但提供了额外的保证。'
- en: The same iterator can be dereferenced several times to access the element it
    points to.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同一个迭代器可以被多次解引用以访问它指向的元素。
- en: 'Additionally, when we increment or dereference a forward iterator, the other
    copies are not invalidated: if we make a copy of a forward iterator, we can advance
    the first one, and the second can still be used to access the previous element.'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，当我们递增或解引用前向迭代器时，其他副本不会被无效化：如果我们复制了一个前向迭代器，我们可以前进第一个，第二个仍然可以用来访问前一个元素。
- en: Two iterators that refer to the same element are guaranteed to be equal.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指向相同元素的两个迭代器保证是相等的。
- en: '`operator--` (position decrement) member function.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator--`（位置减量）成员函数。'
- en: '`operator[]` member function to access elements at generic indexes and the
    binary `operator+` and `operator-` to step forward and backward of any quantity.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `operator[]` 成员函数来访问泛型索引处的元素，以及使用二进制 `operator+` 和 `operator-` 来前进和后退任何数量。
- en: 'Exercise 15: Exploring Iterator'
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 15：探索迭代器
- en: 'Perform the following steps to explore the four categories discussed in the
    previous section and writing to the element it points to, it is also an Output
    Iterator:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来探索上一节中讨论的四个类别，并将值写入它指向的元素，它也是一个输出迭代器：
- en: 'Add the following header files at the start of the program:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序开始处添加以下头文件：
- en: '[PRE39]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the main function declare the vector named number:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中声明名为 number 的向量：
- en: '[PRE40]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Perform the various arithmetic operations as illustrated:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行如图所示的各项算术运算：
- en: '[PRE41]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Many of the iterators we will talk about are defined in the `<iterator>` header.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的许多迭代器都定义在 `<iterator>` 头文件中。
- en: Reverse Iterators
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向迭代器
- en: Sometimes, we need to iterate though a collection of elements in reverse order.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要以相反的顺序遍历元素集合。
- en: 'C++ provides an iterator that allows us to do this: the *reverse iterator*.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 提供了一个迭代器，允许我们这样做：*反向迭代器*。
- en: A *reverse iterator* wraps a *bidirectional iterator* and swaps the operation
    increment with the operation of decrement, and vice versa.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *反向迭代器* 包装一个 *双向迭代器*，并交换增量操作与减量操作，反之亦然。
- en: Because of this, when we are iterating a reverse iterator in the forward direction,
    we are visiting the elements in a range in backward order.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，当我们正向迭代反向迭代器时，我们是在反向顺序访问范围内的元素。
- en: 'We can reverse the range of a container by calling the following methods on
    a container:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在容器上调用以下方法来反转容器的范围：
- en: '![Figure 5.19: Table representing iterator functions and its description](img/C11557_05_19.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19：表示迭代器函数及其描述的表格](img/C11557_05_19.jpg)'
- en: 'Figure 5.19: Table presenting iterator functions and their descriptions'
  id: totrans-383
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.19：表示迭代器函数及其描述的表格
- en: Code that works on normal iterators, it will also work with reverse iterators.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常迭代器上工作的代码，也可以与反向迭代器一起工作。
- en: For example, we can see how similar the code is to iterate in reverse order.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以看到代码如何与反向顺序迭代相似。
- en: 'Exercise 16: Exploring Functions of Reverse Iterator'
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 16：探索反向迭代器的功能
- en: 'Let''s perform the following steps to understand how functions in reverse iterator
    works:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来了解反向迭代器中函数的工作方式：
- en: 'Add the following header files at the start of the program:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序开始处添加以下头文件：
- en: '[PRE43]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the main function, add the vector named numbers as illustrated:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，如图所示添加名为 numbers 的向量：
- en: '[PRE44]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now iterate through the number vector as illustrated:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在如图所示遍历 number 向量：
- en: '[PRE45]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output is as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE46]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Insert Iterators
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入迭代器
- en: '**Insert iterators**, also called **inserters**, are used to insert new values
    into a container rather than overwrite them.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入迭代器**，也称为**插入器**，用于将新值插入到容器中而不是覆盖它们。'
- en: There exist three types of inserters, which differ on the position in the container
    at which they insert the elements.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 存在三种类型的插入器，它们在容器中插入元素的位置上有所不同。
- en: 'The following table summarizes the different categories:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了不同的类别：
- en: '![Figure 5.20: Table representing iterator functions and its description](img/C11557_05_20.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20：表示迭代器函数及其描述的表格](img/C11557_05_20.jpg)'
- en: 'Figure 5.20: Table presenting iterator functions and their descriptions'
  id: totrans-401
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.20：表示迭代器函数及其描述的表格
- en: Some algorithms, which we are going to see later in this chapter, require an
    iterator for storing data. Insert iterators are usually used with such algorithms.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法，我们将在本章后面看到，需要迭代器来存储数据。插入迭代器通常与这些算法一起使用。
- en: Stream Iterators
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流迭代器
- en: '`Stream iterators` allow us to use streams as a source to read elements from
    or as a destination to write elements to:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream iterators` 允许我们将流用作读取元素的源或写入元素的目的地：'
- en: '![Figure 5.21: Table representing iterator functions and its description ](img/C11557_05_21.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21：表示迭代器函数及其描述的表格](img/C11557_05_21.jpg)'
- en: 'Figure 5.21: Table presenting iterator functions and their descriptions'
  id: totrans-406
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5.21：表示迭代器函数及其描述的表格
- en: Because we don't have a container in this case, we cannot call the `end()` method
    to get the `end` iterator. A default constructed stream iterator counts as the
    end of any stream range.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这种情况下我们没有容器，我们无法调用 `end()` 方法来获取 `end` 迭代器。默认构造的流迭代器被视为任何流范围的末尾。
- en: Let's look at a program that reads space-separated integers from the standard
    input.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个从标准输入读取空格分隔整数的程序。
- en: 'Exercise 17: Stream Iterator'
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 17：流迭代器
- en: 'Let''s perform the following steps to understand how functions in reverse stream
    works:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来了解反向流函数的工作原理：
- en: 'Add the required header files as illustrated:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加如图所示的所需头文件：
- en: '[PRE47]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, in the main function, add the istream iterator as illustrated:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在主函数中，添加如图所示的 istream 迭代器：
- en: '[PRE48]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows (input: 10):'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下（输入：10）：
- en: '[PRE49]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Iterator Invalidation
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器无效化
- en: As we said, iterators represent the position of elements in a container.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，迭代器表示容器中元素的位置。
- en: 'This means that they are tightly tied with the container, and changes to the
    container might move the elements: this means that iterators pointing to such
    an element can no longer be used – they are **invalidated**.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它们与容器紧密相关，对容器的更改可能会移动元素：这意味着指向此类元素的迭代器将无法再使用——它们被**无效化**了。
- en: It is extremely important to always check the invalidation contract when using
    iterators with containers, as it is not specified what happens when using an invalidated
    iterator. More commonly, invalid data is accessed or the program crashes, leading
    to bugs that are hard to find.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用容器和迭代器时，始终检查无效化合同非常重要，因为未指定使用无效迭代器时会发生什么。更常见的是，访问无效数据或程序崩溃，导致难以找到的bug。
- en: If we keep in mind how the containers are implemented, as we saw earlier in
    this chapter, we can more easily remember when an iterator is invalidated.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记住容器是如何实现的，就像我们在本章前面看到的，我们就可以更容易地记住何时迭代器被无效化。
- en: 'For example, we said that when we insert an element in a vector, we might have
    to get more memory to store the element, in which case all the previous elements
    are moved to the newly obtained memory. This means that all the iterators pointing
    to the elements are now pointing to the old location of the elements: they are
    invalidated.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们说过，当我们向向量中插入一个元素时，我们可能需要更多的内存来存储该元素，在这种情况下，所有前面的元素都需要移动到新获得的内存中。这意味着所有指向元素的迭代器现在都指向了元素的老位置：它们被无效化了。
- en: 'On the other hand, we saw that when we insert an element into the list, we
    only have to update the predecessor and successor nodes, but the elements are
    not moved. This means that the iterators to the elements remain valid:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们看到了当我们向列表中插入一个元素时，我们只需要更新前驱和后继节点，但元素本身并不移动。这意味着指向元素的迭代器仍然有效：
- en: '[PRE50]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When there is a need to store iterators to elements, iterator invalidation is
    an important consideration to make when deciding which container to use.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要存储指向元素的迭代器时，在决定使用哪个容器时，迭代器无效化是一个重要的考虑因素。
- en: 'Exercise 18: Printing All of the Customers'' Balances'
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 18：打印所有客户的余额
- en: We want to print the balances for all of the customers of our application. The
    balances are already stored inside a vector as integers.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望打印我们应用程序中所有客户的余额。余额已经以整数的形式存储在向量中。
- en: 'We want to use iterators to traverse the vector of balances. Follow these steps
    to do so:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想使用迭代器遍历余额向量。按照以下步骤进行：
- en: 'Initially, we include the header file for the `vector` class, and we declare
    a vector of 10 elements of type `int`:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，我们包含`vector`类的头文件，并声明一个包含10个`int`类型元素的向量：
- en: '[PRE51]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `for` loop has been modified to iterate using the vector''s iterator, starting
    from the position returned by `begin()` until it reaches the one returned by `end()`:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`循环已被修改为使用向量的迭代器迭代，从`begin()`返回的位置开始，直到它达到`end()`返回的位置：'
- en: '[PRE52]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The element of the array is accessed using the dereference operator (`*`) on
    the iterator:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用迭代器的解引用运算符（`*`）访问数组元素：
- en: '[PRE53]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Algorithms Provided by the C++ Standard Template Library
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++标准模板库提供的算法
- en: Algorithms are a way to operate on containers in an abstract way.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是以抽象方式操作容器的一种方式。
- en: The C++ standard library provides a wide range of algorithms for all the common
    operations that can be performed on ranges of elements.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库为可以在元素范围上执行的所有常见操作提供了一组广泛的算法。
- en: Because algorithms accept iterators, they can operate on any container, even
    user-defined containers, as long as they provide iterators.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 因为算法接受迭代器，所以它们可以操作任何容器，甚至是用户定义的容器，只要它们提供迭代器。
- en: This allows us to have a large number of algorithms that work with a large number
    of containers, without the need for the algorithm to know how the container is
    implemented.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们拥有大量算法，这些算法可以与大量容器一起工作，而无需算法知道容器是如何实现的。
- en: The following are some of the most important and common algorithms that are
    provided by the STL.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些由STL提供的最重要和最常用的算法。
- en: Note
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Algorithms operate on ranges, so they normally take a pair of iterators: *first*
    and *last*.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 算法操作范围，因此它们通常接受一对迭代器：*first*和*last*。
- en: As we said earlier in this chapter, the *last* iterator denotes the element
    past the end of the range – it is not part of the range.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面所说的，*last*迭代器表示范围结束之后的元素——它不是范围的一部分。
- en: This means that when we want to operate on a full container, we can pass `begin()`
    and `end()` as arguments to the algorithm, but if we want to operate on a shorter
    sequence, we must be sure that our *last* iterator is past the last item we want
    to include in the range.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们想要操作一个完整的容器时，我们可以将`begin()`和`end()`作为参数传递给算法，但如果我们想要操作一个较短的序列，我们必须确保我们的最后一个迭代器已经超过了我们想要包含在范围内的最后一个项目。
- en: Lambda
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda
- en: 'Most of the algorithms accept a unary or binary predicate: a `Functor` (function
    object), which accepts either one or two parameters. These predicates allow the
    user to specify some of the actions that the algorithm requires. What the actions
    are vary from algorithm to algorithm.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数算法接受一个一元或二元谓词：一个`Functor`（函数对象），它接受一个或两个参数。这些谓词允许用户指定算法所需的一些操作。这些操作因算法而异。
- en: As we saw at the end of *Chapter 3, Classes*, to write a function object, we
    have to create a class and overload the `operator()`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第3章，类*的结尾所看到的，要编写一个函数对象，我们必须创建一个类并重载`operator()`。
- en: This can be very verbose, especially when the functor should perform a simple
    operation.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能非常冗长，尤其是当函数对象应该执行简单操作时。
- en: To overcome this with C++, the user has to write a **lambda expression**, also
    called just a *lambda*.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用C++克服这个问题，用户必须编写一个**lambda表达式**，也称为*lambda*。
- en: A *lambda expression* creates a special function object, with a type known only
    by the compiler, that behaves like a function but can access the variables in
    the scope in which it is created.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*lambda表达式*创建了一个特殊的函数对象，其类型只有编译器知道，它表现得像一个函数，但可以访问它创建的作用域中的变量。
- en: 'It is defined with a syntax very similar to the one of functions:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用与函数非常相似的语法定义：
- en: '[PRE54]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This creates a new object that, when called with the arguments specified in
    the lambda expression, executes the body of the function.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个新对象，当使用lambda表达式中指定的参数调用时，执行函数体。
- en: '*Arguments* is the list of arguments the function accepts, and *body* is the
    sequence of statements to execute when the function is invoked. They have the
    same meaning that they have for functions, and the same rules we saw in *Chapter
    2, Functions,* apply.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '*参数*是函数接受的参数列表，*主体*是当函数被调用时要执行的语句序列。它们与函数具有相同的含义，并且适用于函数的相同规则我们在*第2章，函数*中看到。'
- en: 'For example, let''s create a lambda that takes two integers and returns their
    sum:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个接受两个整数并返回它们的和的lambda：
- en: '[PRE55]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: By default, the body of the lambda can only reference the variables that are
    defined in the argument list and inside the body, like for functions.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，lambda函数体的作用域只能引用在参数列表和函数体内部定义的变量，就像函数一样。
- en: Additionally, *lambdas* can **capture** a variable in the local scope, and use
    it in their body.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*lambda*可以捕获局部作用域中的变量，并在其函数体中使用它。
- en: '*Captured variables* entail a list of variable names that can be referenced
    in the body of the lambda.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '*捕获的变量*包含可以在lambda函数体中引用的变量名列表。'
- en: When a variable is captured, it is stored inside the created function object,
    and it can be referenced in the body.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量被捕获时，它被存储在创建的函数对象内部，并且可以在函数体中引用。
- en: 'By default, the variables are *captured by value*, so they are copied inside
    the function object:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，变量是通过值捕获的，因此它们被复制到函数对象内部：
- en: '[PRE56]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When we created the lambda, we captured `addend` by value: it was copied into
    the `sum_numbers` object. Even if we modified the value of `addend`, we did not
    change the copy stored inside `sum_numbers`, so when `sum_numbers` is executed,
    it sums 1 to `b`.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建lambda时，我们通过值捕获了`addend`：它被复制到`sum_numbers`对象中。即使我们修改了`addend`的值，我们也没有改变存储在`sum_numbers`内部的副本，所以当`sum_numbers`执行时，它将1加到`b`上。
- en: In some situations, we want to be able to modify the value of a variable in
    the scope in which the *lambda* is created, or we want to access the actual value,
    not the value that the variable had when the lambda was created.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望能够在创建lambda的作用域中修改变量的值，或者我们希望访问实际的值，而不是lambda创建时变量的值。
- en: In that case, we can capture by reference by prepending `&` to the variable
    name.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我们可以通过在变量名前加上`&`来通过引用捕获。
- en: Note
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: When we capture by reference, we need to make sure that the variable that's
    been captured by reference is still valid when the lambda is invoked, otherwise
    the body of the function accesses an invalid object, resulting in bugs.Prefer
    to capture by value when it is possible.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过引用捕获时，我们需要确保在lambda被调用时，被引用捕获的变量仍然有效，否则函数体的作用域访问了一个无效的对象，导致错误。如果可能，最好通过值捕获。
- en: 'Let''s look at an example:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE57]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we capture the `multiplier` variable by reference: only a reference to
    it was stored into `multiply_numbers`.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们通过引用捕获了`multiplier`变量：只有它的引用被存储到`multiply_numbers`中。
- en: When we invoke `multiply_numbers`, the body accesses the current value of `multiplier`,
    and since `multiplier` was changed to 2, that is the value that's used by the
    *lambda*.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`multiply_numbers`时，函数体访问`multiplier`的当前值，由于`multiplier`被改为2，这就是*lambda*使用的值。
- en: A lambda can capture multiple variables, and each one can be either captured
    by value or by reference, independently one from the other.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: lambda可以捕获多个变量，每个变量可以是独立于其他变量的值捕获或引用捕获。
- en: Read-Only Algorithms
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读算法
- en: Read-only algorithms are algorithms that inspect the elements stored inside
    a container but do not modify the order of the elements of the container.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 只读算法是检查容器内存储的元素但不修改容器元素顺序的算法。
- en: 'The following are the most common operations that inspect the elements of a
    range:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常见的检查范围元素的操作：
- en: '![Figure 5.22: Table representing the operations that inspect elements of a
    range](img/C11557_05_22.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![图5.22：表示检查范围元素操作的表格](img/C11557_05_22.jpg)'
- en: 'Figure 5.22: Table presenting the operations that inspect elements of a range'
  id: totrans-477
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.22：展示检查范围元素操作的表格
- en: 'Let''s see how we can use these functions:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这些函数：
- en: '[PRE58]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Modifying Algorithms
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改算法
- en: 'Modifying algorithms are algorithms that modify the collections they iterate
    on:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 修改算法是修改它们迭代的集合的算法：
- en: '![Figure 5.23: Table representing the modifying algorithms](img/C11557_05_23.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![图5.23：表示修改算法的表格](img/C11557_05_23.jpg)'
- en: 'Figure 5.23: Table presenting the modifying algorithms'
  id: totrans-483
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.23：展示修改算法的表格
- en: 'Let''s see these algorithms in action:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些算法的实际应用：
- en: '[PRE59]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Mutating Algorithms
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改算法
- en: 'Mutating algorithms are algorithms that change the order of elements:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 修改算法是改变元素顺序的算法：
- en: '![Figure 5.24: Table representing the mutating algorithms](img/C11557_05_24.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![图5.24：表示修改算法的表格](img/C11557_05_24.jpg)'
- en: 'Figure 5.24: Table presenting mutating algorithms'
  id: totrans-489
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.24：展示修改算法的表格
- en: 'Let''s see how we can use them:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用它们：
- en: '[PRE60]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Sorting Algorithms
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序算法
- en: 'This class of algorithms rearranges the order of elements within a container
    in a specific order:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这类算法以特定顺序重新排列容器内元素的顺序：
- en: '![Figure 5.25: Table representing the sorting algorithms](img/C11557_05_25.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![图5.25：表示排序算法的表格](img/C11557_05_25.jpg)'
- en: 'Figure 5.25: Table presenting sorting algorithms'
  id: totrans-495
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.25：展示排序算法的表格
- en: 'Here is how to sort a vector:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何对向量进行排序的方法：
- en: '[PRE61]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Binary Search Algorithms
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二分搜索算法
- en: 'The following table explains the use of `binary_search`:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了`binary_search`的使用：
- en: '![](img/C11557_05_26.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11557_05_26.jpg)'
- en: 'Figure 5.26: Table presenting the use of binary_search'
  id: totrans-501
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.26：展示`binary_search`使用的表格
- en: 'Here''s how you can utilize the binary search algorithm:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何利用二分搜索算法的方法：
- en: '[PRE62]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Numeric Algorithms
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值算法
- en: 'This class of algorithms combines numeric elements using a linear operation
    in different ways:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这类算法以不同的方式使用线性运算组合数值元素：
- en: '![Figure 5.27: Table representing the numeric algorithm](img/C11557_05_27.jpg)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![图5.27：表示数值算法的表格](img/C11557_05_27.jpg)'
- en: 'Figure 5.27: Table presenting the numeric algorithm'
  id: totrans-507
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5.27：展示数值算法的表格
- en: 'Let''s see how we can use `accumulate` in the following program:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在以下程序中使用`accumulate`：
- en: '[PRE63]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Exercise 19: Customer Analytics'
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习19：客户分析
- en: We have the information of many customers of our application and we want to
    compute analytics data on that.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们应用程序许多客户的详细信息，并希望计算这些信息上的分析数据。
- en: Given a map that has a username as a key and a user account as a value, we would
    like to print the balances of the new users in descending order.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个以用户名作为键和用户账户作为值的映射，我们希望按降序打印新用户的余额。
- en: 'A user is considered new if they registered no more than 15 days ago. The struct
    representing the user''s account is provided and is as follows:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在15天内注册，则被视为新用户。提供表示用户账户的结构如下：
- en: '[PRE64]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Write the `void computeAnalytics(std::map<std::string, UserAccount>& accounts)`
    function, which prints the desired balances.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 编写`void computeAnalytics(std::map<std::string, UserAccount>& accounts)`函数，该函数打印所需的余额。
- en: 'Make sure to include all the required headers for the solution:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保包含解决方案所需的全部标题：
- en: '[PRE65]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'First, we need to extract `UserAccount` from the map. Remember that the element
    the map stores is `pair` containing a key and value. Since we need to transform
    the type into `UserAccount`, we can use `std::transform`, by passing a `lambda`
    that only returns the user account from the `pair`. To insert this into `vector`,
    we can use `std::back_inserter`. Make sure to use a `const` reference when accepting
    `pair` in the lambda that''s passed to transform:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从映射中提取`UserAccount`。记住，映射存储的元素是包含键和值的`pair`。由于我们需要将类型转换为`UserAccount`，我们可以使用`std::transform`，通过传递一个只返回用户账户的`lambda`。为了将其插入到`vector`中，我们可以使用`std::back_inserter`。确保在lambda中接受`pair`时使用`const`引用：
- en: '[PRE66]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'After we have extracted the accounts in `vector`, we can use `remove_if` to
    remove all accounts that are older than 15 days:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们从`vector`中提取账户后，我们可以使用`remove_if`来移除所有超过15天的账户：
- en: '[PRE67]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After removing the old accounts, we need to sort the balances in descending
    order. By default, `std::sort` uses an ascending order, so we need to provide
    a `lambda` to change the order:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在移除旧账户后，我们需要按降序排序余额。默认情况下，`std::sort`使用升序，因此我们需要提供一个`lambda`来改变顺序：
- en: '[PRE68]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can now invoke our function with the following test data:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下测试数据调用我们的函数：
- en: '[PRE69]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Summary
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we introduced sequential containers – containers whose elements
    can be accessed in sequence. We looked at the `array`, `vector`, `deque`, `list`,
    and `forward_list` sequential containers.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了顺序容器——其元素可以按顺序访问的容器。我们研究了`array`、`vector`、`deque`、`list`和`forward_list`顺序容器。
- en: We saw what functionality they offer and how we can operate on them, and we
    saw how they are implemented and how storage works for vector and list.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了它们提供的功能以及如何操作它们，我们还看到了它们的实现以及vector和list的存储方式。
- en: We followed this up with associative containers, containers that allow the fast
    lookup of their elements, always kept in order. `Set`, `multiset`, `map`, and
    `multimap` are part of this category.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着介绍了关联容器，这些容器允许快速查找其元素，并且始终保持有序。`Set`、`multiset`、`map`和`multimap`属于这一类别。
- en: We looked at the operations they support and how map and multimap are used to
    associate a value to a key. We also saw their unordered version, which does not
    keep elements in order but provides higher performance. `Unordered_set` and `unordered_map`
    are in this category.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了它们支持的操作以及如何使用map和multimap将值关联到键。我们还看到了它们的无序版本，它不保持元素顺序但提供更高的性能。`Unordered_set`和`unordered_map`属于这一类别。
- en: Finally, we looked at unconventional containers. `String` is used to manipulate
    sequences of characters, `pair` and `tuple` are used to hold various elements
    of different types, `optional` is used to add optionality to a type, and `variant`
    is used to store a value that could be of several types.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了非传统的容器。`String` 用于操作字符序列，`pair` 和 `tuple` 用于存储不同类型的不同元素，`optional` 用于向类型添加可选性，而
    `variant` 用于存储可能属于几种类型的值。
- en: We then explored iterators and learned how they are used to abstract the concept
    of containers and provide a common set of functionalities.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了迭代器，并学习了它们是如何用于抽象容器概念并提供一组通用功能的。
- en: We looked at the various types of iterators, and we learned what iterator invalidation
    is and why it is important to be aware of it.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了各种迭代器的类型，并了解了迭代器失效的概念及其重要性。
- en: We finally moved on to algorithms in the C++ standard, after explaining that
    `lambda` is a convenient way of defining a function that can also access variables
    in the scope in which it is created.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了 `lambda` 是定义一个可以访问其创建作用域中变量的函数的便捷方式之后，我们最终转向了 C++ 标准中的算法。
- en: We divided the most common algorithms into various categories, and we looked
    at the most important algorithms in those categories, including `find`, `remove`,
    and `sort`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最常见的算法分为各种类别，并研究了这些类别中最重要的算法，包括 `find`、`remove` 和 `sort`。
- en: In the next chapter, you will learn how to use the advanced features of C++
    to create dynamic programs.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用 C++ 的高级特性来创建动态程序。
