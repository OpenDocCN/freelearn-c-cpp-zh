- en: '*Chapter 5*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standard Library Containers and Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain what iterators are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrate the use of sequential containers, container adaptors, and associative
    containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand and use unconventional containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain cases of iterator invalidation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover algorithms implemented in the standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use user-defined operations on algorithms with lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core of C++ is its **Standard Template Library** (**STL**), which represents
    a set of important data structures and algorithms that facilitates the programmer's
    task and improves code efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: The components of the STL are parametric so that they can be reused and combined
    in different ways. The STL is mainly made up of container classes, iterators,
    and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are used to store collections of elements of a certain type. Usually,
    the type of the container is a template parameter, which allows the same container
    class to support arbitrary elements. There are several container classes, each
    of them with different characteristics and features.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators are used to traverse the elements of a container. Iterators offer
    the programmer a simple and common interface to access containers of a different
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators are similar to raw pointers, which can also iterate through elements
    using the increment and the decrement operators, or can access a specific element
    using the de-reference (`*`) operator.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms are used to perform standard operations on the elements stored in
    the containers. They use iterators to traverse the collections, since their interface
    is common to all the containers, so that the algorithm can be agnostic about the
    container it's operating on.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms treat functions as parameters that are provided by the programmer
    in order to be more flexible in the operation that's being performed. It is common
    to see an algorithm applied to a container of objects of a user-defined type.
    This algorithm, to execute correctly, needs to know how to treat the object in
    detail. For this reason, the programmer provides a function to the algorithm to
    specify the operations to be executed on the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Sequence containers,** sometimes referred to as **sequential containers**,
    are a particular class of containers where the order in which their elements are
    stored is decided by the *programmer* rather than by the values of the elements.
    Every element has a certain position that is independent of its value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL contains five sequence container classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Table representing the sequence container class and their description](img/C11557_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Table presenting the sequence container classes and their descriptions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The array container is a fixed-size data structure of contiguous elements.
    It recalls the static array that we saw in *Chapter 1*, *Getting Started*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Array elements are stored in contiguous memory](img/C11557_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Array elements are stored in contiguous memory'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An array's size needs to be specified at compile time. Once defined, the size
    of the array *cannot be changed*.
  prefs: []
  type: TYPE_NORMAL
- en: When an array is created, the `size` elements it contains are initialized next
    to each other in memory. While elements cannot be added or removed, their values
    can be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays can be randomly accessed using the access operator with the corresponding
    element's index. To access an element at a given position, we can use the operator
    `[]` or the `at()` member function. The former does not perform any range checks,
    while the latter throws an exception if the index is out of range. Moreover, the
    first and the last element can be accessed using the `front()` and `back()` member
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'These operations are fast: since the elements are contiguous, we can compute
    the position in memory of an element given its position in the array, and access
    that directly.'
  prefs: []
  type: TYPE_NORMAL
- en: The size of the array can be obtained using the `size()` member function. Whether
    the container is empty can be checked using the `empty()` function, which returns
    *true* if `size()` is zero.
  prefs: []
  type: TYPE_NORMAL
- en: The array class is defined in the `<array>` header file, which has to be included
    before usage.
  prefs: []
  type: TYPE_NORMAL
- en: Vector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The vector container is a data structure of contiguous elements whose size
    can be dynamically modified: it does not require to specify its size at creation
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Vector elements are contiguous, and their size can grow dynamically](img/C11557_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Vector elements are contiguous, and their size can grow dynamically'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `vector` class is defined in the `<vector>` header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A vector stores the elements it contains in a single section of memory. Usually,
    the section of memory has enough space for more elements than the number of elements
    stored in the vector. When a new element is added to the vector, if there is enough
    space in the section of memory, the element is added after the last element in
    the vector. If there isn''t enough space, the vector gets a new, bigger section
    of memory and copies all the existing elements into the new section of memory,
    then it deletes the old section of memory. To us, it will seem like the size of
    the section of memory has increased:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Memory allocation of vectors](img/C11557_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Memory allocation of vectors'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When the vector is created, it is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the interface is similar to the array's, but with a few differences.
  prefs: []
  type: TYPE_NORMAL
- en: Elements can be appended using the `push_back()` function or inserted at a generic
    position using the `insert()` function. The last element can be removed using
    `pop_back()` or at a generic position using the `erase()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Appending or deleting the last element is fast, while inserting or removing
    other elements of the vector is considered slow, as it requires moving all the
    elements to make space for the new element or to keep all the elements contiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Elements being moved during insertions or deletions inside a
    vector](img/C11557_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Elements being moved during insertions or deletions inside a vector'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vectors, just like arrays, allow efficient access of elements at random positions.
    A vector's size is also retrieved with the `size()` member function, but this
    should not be confused with `capacity()`. The former is the actual number of elements
    in the vector, and the latter returns the maximum number of elements that can
    be inserted in the current section of memory.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the preceding diagram, initially, the array had a size of 4
    and a capacity of 8\. So, even when an element had to be moved to the right, the
    vector's capacity did not change, as we never had to get a new, bigger section
    of memory to store the elements.
  prefs: []
  type: TYPE_NORMAL
- en: The operation of getting a new section of memory is called reallocation. Since
    reallocation is considered an expensive operation, it is possible to *reserve*
    enough memory for a given number of elements by enlarging a vector's capacity
    using the `reserve()` member function. The vector's capacity can also be reduced
    to fit the number of elements using the `shrink_to_fit()` function in order to
    release memory that is not needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Vector is the most commonly used container for a sequence of elements and is
    often the best one performance-wise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example to understand how `vector::front()` and
    `vector::back()` work in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Deque
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *deque* container (pronounced *deck)* is short for "double-ended queue."
    Like *vector*, it allows for fast, direct access of deque elements and fast insertion
    and deletion at the back. Unlike *vector*, it also allows for fast insertion and
    deletion at the front of the deque:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Deque elements can be added and removed at the start and the
    end](img/C11557_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Deque elements can be added and removed at the start and the end'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `deque` class is defined in the `<deque>` header file.
  prefs: []
  type: TYPE_NORMAL
- en: '*Deque* generally requires more memory than *vector*, and *vector* is more
    performant for accessing the elements and `push_back`, so unless it is required
    to insert at the front, *vector* is usually preferred.'
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The list container is a data structure of nonadjacent elements that can be
    dynamically grown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: List elements are stored in different sections of memory, and
    have connecting links ](img/C11557_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: List elements are stored in different sections of memory, and have
    connecting links'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `list` class is defined in the `<list>` header file.
  prefs: []
  type: TYPE_NORMAL
- en: Each element in the list has its memory segment and a link to its predecessor
    and its successor. The structure containing the element, which is the link to
    its predecessor and to its successor, is called a **node**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an element is inserted in a list, the predecessor node needs to be updated
    so that its successor link points to the new element. Similarly, the successor
    node needs to be updated so that its predecessor link points to the new element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: C is to be inserted between A and B. A''s successor and B''s
    predecessor link must be updated to point to C (orange). C''s link to the predecessor
    and successor are updated to points A and B (green)](img/C11557_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: C is to be inserted between A and B. A''s successor and B''s predecessor
    link must be updated to point to C (orange). C''s link to the predecessor and
    successor are updated to points A and B (green)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When an element is removed from the list, we need to update the successor link
    of the predecessor node to point to the successor of the removed node. Similarly,
    the predecessor link of the successor node needs to be updated to point to the
    predecessor of the removed node.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, if we were to remove **C**, we would have to update
    **A**'s successor to point to **C**'s successor (**B**), and **B**'s predecessor
    to point to **C**'s predecessor (**A**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike vectors, lists do not provide random access. Elements are accessed by
    linearly following the chain of elements: starting from the first, we can follow
    the successor link to find the next node, or from the last node we can follow
    the predecessor link to find the previous node, until we reach the element we
    are interested into.'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of `list` is that insertion and removal are fast at any position,
    if we already know the node at which we want to insert or remove. The disadvantage
    of this is that getting to a specific node is slow.
  prefs: []
  type: TYPE_NORMAL
- en: The interface is similar to a vector, except that lists don't provide `operator[]`.
  prefs: []
  type: TYPE_NORMAL
- en: Forward-List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `forward_list` container is similar to the list container, with the difference
    that its nodes only have the link to the successor. For this reason, it is not
    possible to iterate over a `forward_list` in backward order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Forward-list elements are like List, but only have one-way connecting
    links](img/C11557_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Forward-list elements are like List elements, but only have one-way
    connecting links'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As usual, the `forward_list` class is defined in the `<forward_list>` header
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The `forward_list` class does not even provide `push_back()` or `size()`. Inserting
    an element is done using `insert_after()`, which is a variation of the `insert()`
    function, where the new element is inserted after the provided position. The same
    idea applies to element removal, which is done through `erase_after()`, which
    removes the element after the provided position.
  prefs: []
  type: TYPE_NORMAL
- en: Providing Initial Values to Sequence Containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the sequence containers we have looked at are empty when they are first
    created.
  prefs: []
  type: TYPE_NORMAL
- en: When we want to create a container containing some elements, it can be repetitive
    to call the `push_back()` or `insert()` functions repeatedly for each element.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, all the containers can be initialized with a sequence of elements
    when they are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence must be provided in curly brackets, and the elements need to be
    comma-separated. This is called an initializer list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This works for any of the containers we have seen in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 19: Storing User Accounts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want to store the account balance, stored as an `int` instance, for 10 users.
    The account balance starts with 0\. We then want to increase the balance of the
    first and last user by 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the header for the `array` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare an integer array of ten elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the array using the `for` loop. The `size()` operator to evaluate
    the size of the array and the `operator[]` to access every position of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the value for the first and last user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 304.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let’s do the same using a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the **vector** header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a vector of integer type and reserve memory to store 100 users with
    resize it to be able to contain 10 users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a for loop to initialize the vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this activity, we learned how we can store an arbitrary number of accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Associative Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`operator<`, although the user can supply a `Functor` (function object) as
    a parameter to specify how the elements should be compared. The `<functional>`
    header contains many such objects that can be used to sort the associative containers,
    like `std::less` or `std::less`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Table representing associative containers and its description](img/C11557_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Table presenting associative containers and their descriptions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Typically, associative containers are implemented as variations of binary trees,
    providing fast element lookup by exploiting the logarithmic complexity of the
    underlying structure.
  prefs: []
  type: TYPE_NORMAL
- en: Set and Multiset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **Set** is a container that contains a unique group of sorted elements. A
    **Multiset** is similar to *Set*, but it allows duplicate elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Set and Multiset store a sorted group of elements](img/C11557_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Set and Multiset store a sorted group of elements'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Set and multiset have `size()` and `empty()` function members to check how many
    elements are contained and whether any elements are contained.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion and removal is done through the `insert()` and `erase()` functions.
    Because the order of the elements is determined by the *comparator*, they do not
    take a position argument like they do for sequential containers. Both insertion
    and removal are fast.
  prefs: []
  type: TYPE_NORMAL
- en: Since sets are optimized for element lookup, they provide special search functions.
    The `find()` function returns the position of the first element equal to the provided
    value, or the position past the end of the set when the element is not found.
    When we look for an element with `find`, we should always compare it with the
    result of calling `end()` on the container to check whether the element was found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `count()` returns the number of elements equal to the value provided.
  prefs: []
  type: TYPE_NORMAL
- en: The `set` and `multiset` classes are defined in the `<set>` header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of a set with a custom comparator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ascending numbers: 1 2 3 4 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Descending numbers: 5 4 3 2 1'
  prefs: []
  type: TYPE_NORMAL
- en: Map and Multimap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Map** and **multimap** are containers that manage **key/value** pairs as
    elements. The elements are sorted automatically according to the provided comparator
    and applied to the *key*: the *value* does not influence the order of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Map and multimap store a sorted group of keys, which is associated
    to a value](img/C11557_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Map and multimap store a sorted group of keys, which is associated
    to a value'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Map allows you to associate a single value to a key, while multimap allows you
    to associate multiple values to the same key.
  prefs: []
  type: TYPE_NORMAL
- en: The `map` and `multimap` classes are defined in the `<map>` header file.
  prefs: []
  type: TYPE_NORMAL
- en: To insert values into a map, we can call `insert()`, providing a `true` if the
    element was inserted, or `false` if an element with the same key already exists.
  prefs: []
  type: TYPE_NORMAL
- en: Once values are inserted into the map, there are several ways to look up a key/value
    pair in a map.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to set, map provides a `find()` function, which looks for a key in the
    map and returns the position of the key/value pair if it exists, or the same result
    of calling `end()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the position, we can access the key with `position->first` and the value
    with `position->second`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An alternative to accessing a value from a key is to use `at()`, which takes
    a key and returns the associated value.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no associated value, `at()` will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: A last alternative to get the value associated with a key is to use `operator[]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `operator[]` returns the value associated with a key, and if the key is
    not present, it inserts a new key/value pair with the provided key, and a default
    value for the value. Because `operator[]` could modify the map by inserting into
    it, it cannot be used on a *const* map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 20: Retrieving a User''s Balance from their Given Username'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'd like to be able to quickly retrieve the balance of a user given their username.
  prefs: []
  type: TYPE_NORMAL
- en: To quickly retrieve the balance from the username, we store the balance inside
    a map, using the name of the user as a key.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the user is of type `std::string`, while the balance is an `int`.
    Add the balance for the users `Alice`, `Bob`, and `Charlie` with a balance of
    50 each. Then, check whether the user `Donald` has a balance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, print the account balance of `Alice`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the header file for the `map` class and the header for `string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a map with the key being `std::string` and the value being `int`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the balances of the users inside the map by using `insert` and `std::make_pair`.
    The first argument is the `key`, while the second one is the `value`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `find` function, providing the name of the user to find the position
    of the account in the map. Compare it with `end()` to check whether a position
    was found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, look for the account of Alice. We know Alice has an account, so there
    is no need to check whether we found a valid position. We can print the value
    of the account using `->second`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 305.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unordered Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Unordered associative containers** differ from associative containers in
    that the elements have no defined order. Visually, unordered containers are often
    imagined as bags of elements. Because the elements are not sorted, unordered containers
    do not accept a comparator object to provide an order to the elements. On the
    other hand, all the unordered containers depend on a hash function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'he user can provide a `Functor` (function object) as a parameter to specify
    how the keys should be hashed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Table representing unordered container and its description](img/C11557_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Table presenting unordered containers and their descriptions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Typically, unordered containers are implemented as **hash tables**. The position
    in the array is determined using the hash function, which given a value returns
    the position at which it should be stored. Ideally, most of the elements will
    be mapped into different positions, but the hash function can potentially return
    the same position for different elements. This is called a *collision*. This problem
    is solved by using linked lists to chain elements that map into the same position,
    so that multiple elements can be stored in the same position. Because there might
    be multiple elements at the same position, the position is often called **bucket**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing unordered containers using a hash table allows us to find an element
    with a specific value in constant time complexity, which translates to an even
    faster lookup when compared to associative containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: When an element is added to the set, its hash is computed to
    decide in which bucket the element should be added. The elements inside a bucket
    are stored in a list.](img/C11557_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: When an element is added to the set, its hash is computed to decide
    in which bucket the element should be added. The elements inside a bucket are
    stored as nodes of a list.'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When a key/value pair is added to the map, the hash of the key is computed
    to decide in which bucket the key/value pair should be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: Representation of storing the bucket elements in a list.](img/C11557_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Representation of computing the bucket of an element from the
    key, and storing the key/value pair as nodes in a list.'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unordered associative containers and ordered associative containers provide
    the same functionalities, and the explanations in the previous section apply to
    the unordered associative containers as well. Unordered associative containers
    can be used to get better performances when the order of the elements is not important.
  prefs: []
  type: TYPE_NORMAL
- en: Container Adaptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Additional container classes that are provided by the STL library are container
    adaptors. Container adaptors provide constrained access policies on top of the
    containers we have looked at in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Container adaptors have a template parameter that the user can provide to specify
    the type of container to wrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image18089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Table presenting container adaptors and their descriptions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The stack container implements the LIFO access policy, where the elements are
    virtually stacked one on the top of the other so that the last inserted element
    is always on top. Elements can only be read or removed from the top, so the last
    inserted element is the first that gets removed. A stack is implemented using
    a sequence container class internally, which is used to store all the elements
    and emulate the stack behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The access pattern of the stack data structure happens mainly through three
    core member functions: `push()`, `top()`, and `pop()`. The `push()` function is
    used to insert an element into the stack, `top()` used to access the element on
    top of the stack, and `pop()` is used to remove the top element.'
  prefs: []
  type: TYPE_NORMAL
- en: The `stack` class is defined in the `<stack>` header file.
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `queue` class implements the FIFO access policy, where the elements are
    enqueued one after the other, so that elements inserted before are ahead of elements
    inserted after. Elements are inserted at the end of the queue and removed at the
    start.
  prefs: []
  type: TYPE_NORMAL
- en: The interface of the queue data structure is composed of the `push()`, `front()`,
    `back()`, and `pop()` member functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `push()` function is used to insert an element into the `queue()`; `front()`
    and `back()` return the next and last elements of the queue, respectively; the
    `pop()` is used to remove the next element from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: The `queue` class is defined in the `<queue>` header file.
  prefs: []
  type: TYPE_NORMAL
- en: Priority Queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, the priority queue is a queue where the elements are accessed according
    to their priority, in descending order (highest priority first).
  prefs: []
  type: TYPE_NORMAL
- en: The interface is similar to the normal queue, where `push()` inserts a new element
    and `top()` and `pop()` access and remove the next element. The difference is
    in the way the next element is determined. Rather than being the first inserted
    element, it is the element that has the highest priority.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the priority of the elements is computed by comparing the elements
    with the `operator<`, so that an element that is less than another comes after
    it. A user-defined sorting criterion can be provided to specify how to sort the
    elements by priority in regard to their priority in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: The priority queue class is also defined in the `<queue>` header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 21: Processing User Registration in Order'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a user registers to our website, we need to process the registration form
    at the end of the day.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to process the registration in reverse order of registration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that the class for the registration form is already provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `stack` to store the users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want to store the user registration form when the user registers, as well
    as process the registration at the end of the day. The function for processing
    the form is provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Additionally, there are already two functions that are called when a user registers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill the code inside the following two functions to store the user form and
    process it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll see that the registration forms are processed in reverse order as the
    users are registered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found at page 306.
  prefs: []
  type: TYPE_NORMAL
- en: Unconventional Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, we've seen containers that are used to store groups of elements
    of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ standard defines some other types that can contain types but offer a
    different set of functionalities from the containers we saw previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'These types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pair and tuple
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optional
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variant
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A string is a data structure that''s used to manipulate mutable sequences of
    contiguous characters. The C++ string classes are STL containers: they behave
    similarly to *vectors*, but provide additional functionalities that ease the programmer
    to perform common operations of sequences of characters easily.'
  prefs: []
  type: TYPE_NORMAL
- en: There exist several string implementations in the standard library that are
    useful for different lengths of character sets, such as `string`, `wstring`, `u16string`,
    and `u32string`. All of them are a specialization of the `basic_string` base class
    and they all have the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used type is `std::string`.
  prefs: []
  type: TYPE_NORMAL
- en: All types and functions for strings are deﬁned in the `<string>` header file.
  prefs: []
  type: TYPE_NORMAL
- en: A string can be converted into a *null-terminating string*, which is an array
    of characters that terminate with the special null character (represented with
    '`\0`') via the use of the `data()` or `c_str()` functions. Null-terminating strings,
    also called *C-strings*, are the way to represent sequences of character in the
    C language and they are often used when the program needs to interoperate with
    a C library; they are represented with the `const char *` type and are the type
    of the *literal strings* in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12: Demonstrating Working Mechanism of the `c_str()` Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s examine the following code to understand how the `c_str()` function
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First include the required header files as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `main` function add a constant char variable named `charString`
    with capacity as `8` characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `c_str()` function and assign the value of `strString` to `charString2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the `charString` and `charString2` using the print function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As for vectors, strings have `size()`, `empty()`, and `capacity()` member functions,
    but there is an additional function called `length()`, which is just an alias
    for `size()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings can be accessed in a character-by-character fashion using `operator[]`
    or the `at()`, `front()`, and `back()` member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The usual comparison operators are provided for strings, thus simplifying the
    way two string objects can be compared.
  prefs: []
  type: TYPE_NORMAL
- en: Since strings are like vectors, we can add and remove characters from them.
  prefs: []
  type: TYPE_NORMAL
- en: Strings can be made empty by assigning an empty string, by calling the `clear()`,
    or `erase()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code to understand the usage of the `clear()`
    and `erase()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: C++ also provides many convenience functions to convert a string into numeric
    values or vice versa. For example, the `stoi()` and `stod()` functions (which
    stand for *string-to-int* and *string-to-double*) are used to convert `string`
    to `int` and `double`, respectively. Instead, to convert a value into a string,
    it is possible to use the overloaded function `to_string()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demystify these functions using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Pairs and Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **pair** and **tuple** classes are similar to some extent, in the way they
    can store a collection of heterogeneous elements.
  prefs: []
  type: TYPE_NORMAL
- en: The **pair** class can store the values of two types, while the **tuple** class
    extended this concept to any length.
  prefs: []
  type: TYPE_NORMAL
- en: Pair is defined in the `<utility>` header, while tuple is in the `<tuple>` header.
  prefs: []
  type: TYPE_NORMAL
- en: The pair constructor takes two types as template parameters, used to specify
    the types for the first and second values. Those elements are accessed directly
    using the `first` and `second` data. Equivalently, these members can be accessed
    with the `get<0>()` and `get<1>()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `make_pair()` convenience function is used to create a value pair without
    explicitly specifying the types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line is equivalent to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Pairs are used by unordered map, unordered multimap, map, and multimap containers
    to manage their key/value elements.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are similar to pairs. The constructor allows you to provide a variable
    number of template arguments. Elements are accessed with the `get<N>()` function
    only, which returns the nth element inside the tuple, and there is a convenience
    function to create them similar to that for pair, named `make_tuple()`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, tuples have another convenience function that's used to extract
    values from them. The `tie()` function allows for the creation of a tuple of references,
    which is useful in assigning selected elements from a tuple to specific variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand how to use the `make_tuple()` and `get()` functions to retrieve
    data from a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: std::optional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`optional<T>` is a that''s used to contain a value that might be present or
    not.'
  prefs: []
  type: TYPE_NORMAL
- en: The class takes a template parameter, `T`, which represents the type that the
    `std::optional` template class might contain. Value type means that the instance
    of the class contains the value. Copying `optional` will create a new copy of
    the contained data.
  prefs: []
  type: TYPE_NORMAL
- en: At any point in the execution of the program, `optional<T>` either contains
    nothing, when it's empty, or contains a value of type `T`.
  prefs: []
  type: TYPE_NORMAL
- en: Optional is defined in the `<optional>` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine our application is using a class named `User` for managing registered
    users. We would like to have a function that gets us the information of a user
    from their email: `User getUserByEmail(Email email);`.'
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when a user is not registered? That is, when we can determine
    that our system does not have the associated `User` instance?
  prefs: []
  type: TYPE_NORMAL
- en: Some would suggest throwing an exception. In C++, exceptions are used for *exceptional*
    situations, ones that should almost never happen. A user not being registered
    on our website is a perfectly normal situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these situations, we can use the `optional` template class to represent
    the fact that we might not have the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `optional` template provides two easy methods to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`has_value()`: This returns `true` if `optional` is currently holding a value,
    and `false` if the variant is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value()`: This function returns the value currently held by `optional`, or
    throws an exception if it''s not present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, `optional` can be used as a condition in an `if` statement: it
    will evaluate to `true` if it contains a value, or `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following example to understand how the `has_value()` and
    `value()` functions work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `optional` template comes with additional convenience features. We can
    assign the `std::nullopt` value to `optional` to make it explicit when we want
    it empty, and we can use the `make_optional` value to create an optional from
    a value. Additionally, we can use the dereference operator, `*`, to access the
    value of `optional` without throwing an exception if the value is not present.
    In such cases, we will access invalid data, so we need to be sure that `optional`
    contains a value when we use `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Another handy method is `value_or(defaultValue)`. This function takes a default
    value and returns the value contained by `optional` if it currently holds a value,
    otherwise it returns the default value. Let''s explore the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In addition to return values, `optional` is useful when accepting it as an argument
    to represent arguments that can be present or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recall our `User` class that''s composed of an email address, a phone
    number, and a physical address. Sometimes, users don''t have a phone number and
    don''t want to provide a physical address, so the only required field we have
    in `User` is the email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor allows us to pass in all the information we have on the user.
    If, instead of using `optional`, we used multiple overloads, we would have had
    four overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: Only email
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Email and phone number
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Email and address
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Email with phone number and address
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see that the number of overloads grows quickly when there are more arguments
    that we might not want to pass.
  prefs: []
  type: TYPE_NORMAL
- en: std::variant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`variant` is a value type that''s used to represent a *choice of types*. The
    class takes a list of types, and the variant will be able to contain one value
    of any of those types.'
  prefs: []
  type: TYPE_NORMAL
- en: It is often referred to as **tagged union**, because similar to a union, it
    can store multiple types, with only one present at a time. It also keeps track
    of which type is currently stored.
  prefs: []
  type: TYPE_NORMAL
- en: During the execution of a program, `variant` will contain exactly one of the
    possible types at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `optional`, `variant` is a value type: when we create a copy of `variant`,
    the element that is currently stored is copied into the new `variant`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To interact with `std::variant`, the C++ standard library gives us two main
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`holds_alternative<Type>(variant)`: It returns `true` if the variant is currently
    holding the provided type, if not then `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get(variant)`: There are two versions: `get<Type>(variant)` and `get<Index>(variant)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get<Type>(variant)` gets the value of the type that''s currently stored inside
    the variant. Before calling this function, the caller needs to be sure that `holds_alternative<Type>(variant)`
    returns `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`get<Index>(variant)` gets the value of the index type that''s currently stored
    inside `variant`. Like before, the caller needs to be sure that `variant` is holding
    the correct type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with `std::variant<string, float> variant`, calling `get<0>(variant)`
    will give us the `string` value, but we need to be sure that `variant` is currently
    storing a string at the moment. Usually, it is preferable to access the elements
    with `get<Type>()` so that we are explicit on the type that we expect and that
    if the order of the types in the variant changes, we will still get the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13: Using Variant in the Program'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to understand how to use variant in the
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the required header files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the main function, add the variant with the value type as string and integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now using the two print statements call the variant in different ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative way to get the content of `variant` is to use `std::visit(visitor,
    variant)`, which takes `variant` and a callable object. The callable objects need
    to support an overload of `operator()`, taking a type for each of the possible
    types stored inside `variant`. Then, `visit` will make sure to call the function
    that accepts the current type that''s stored inside `variant`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14: Visitor Variant'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to understand how to use std::visit(visitor,
    variant) in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following header files at the start of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the struct Visitor as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the main function, call the struct Visitor and pass values as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`variant` is incredibly valuable when we want to represent a set of values
    of different types. Typical examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A function returning different types depending on the current state of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class that represents several states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's imagine our `std::optional<User> tryGetUserByEmail()` function, which
    we described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to `optional`, we could now write the function in a clear way, showing
    that sometimes we would not retrieve the user. It is likely that if the user is
    not registered, we might ask them whether they want to register.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine we have `struct UserRegistrationForm`, which contains the information
    that's needed to let the user register.
  prefs: []
  type: TYPE_NORMAL
- en: Our function can now return `std::variant<User, UserRegistrationForm> tryGetUserByEmail()`.
    When the user is registered, we return `User`, but if the user is not registered,
    we can return the registration form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, what should we do when there is an error? With `variant`, we
    could have `struct GetUserError` storing all the information we have so that our
    application will be able to recover from the error and add it to the return type:
    `std::variant<User`, `UserRegistrationForm`, `GetUserError>`, or `tryGetUserByEmail()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can have the complete picture of what is going to happen when we call
    `getUserByEmail()` by just looking at the function signature, and the compiler
    will help us make sure that we handle all the cases.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, `variant` can also be used to represent the various states in
    which a class can be. Each state contains the data that's required for that state,
    and the class only manages the transitions from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 22: Airport System Management'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s write a program to create airport system management:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to represent the state of an airplane in an airport system. The airplane
    can be in three states: `at_gate`, `taxi`, or `flying`. The three states store
    different information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `at_gate`, the airplane stores the gate number at which it is. With `taxi`,
    we store which lane the airplane is assigned and how many passengers are on board.
    With `flying`, we store the speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The airplane should have three methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`startTaxi()`: This method takes the lane the airplane should go on and the
    number of passengers on board. The airplane can start taxi only if it is at the
    gate.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takeOff()`: This method takes the speed at which the airplane should fly.
    The airplane can start flying only if it is in the taxi state.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentStatus()`: This method prints the current status of the airplane.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 306.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve mentioned multiple times that elements have a position
    in a container: for example, we said that we can insert an element in a specific
    position in a list.'
  prefs: []
  type: TYPE_NORMAL
- en: Iterators are the way in which the position of an element in a container is
    represented.
  prefs: []
  type: TYPE_NORMAL
- en: They provide a consistent way to operate on elements of the container, abstracting
    the details of the container to which the elements belong.
  prefs: []
  type: TYPE_NORMAL
- en: An iterator always belongs to a range. The iterator representing the start of
    the range, can be accessed by the `begin()` function, while the iterator representing
    the end of the range, non-inclusive, can be obtained with the `end()` function.
    The range where the first element is included, but where the last one is excluded,
    is referred to as half-open.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface that the iterator must offer is composed of four functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `*` operator provides access to the element at the position currently referenced
    by the iterator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `++` operator is used to move forward to the next element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the `==` operator is used to compare two iterators to check whether they
    are pointing to the same position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that two iterators can only be compared if they are part of the same range:
    they must represent the position of elements of the same container.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, the `=` operator is used to assign an iterator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every container class in C++ must specify the type of iterator that it provides
    to access its elements as a member type alias named `iterator`. For example, for
    a vector of integer, the type would be `std::vector<int>::iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we could use iterators to iterate over all the elements of a
    container (a vector, in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This looks complex for such an operation, and we saw in *Chapter 1, Getting
    Started* how we can use *range-based for:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'R*ange-based for* works thanks to iterators: the compiler rewrites our *range-based
    for* to look like the one we wrote with iterators. This allows the *range-based
    for* to work with any type that provides `begin()` and `end()` functions and returns
    iterators.'
  prefs: []
  type: TYPE_NORMAL
- en: The way operators provided by the iterators are implemented depends on the container
    on which the iterator operates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterator can be grouped into four categories. Each category builds on the previous
    category, thus offering additional functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C11557_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: Table presenting iterators and their descriptions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following diagram gives more detail about C++ iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18: Representation of iterators in C++](img/C11557_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: Representation of iterators hierarchy in C++'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s understand each of these iterators in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`==` and `!=` operators to check whether the iterator is equal to the `end()`
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, input iterators are used to access elements from a stream of elements,
    where the whole sequence is not stored in memory, but we are obtaining one element
    at a time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Forward iterators** are very similar to input iterators but provide additional
    guarantees.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same iterator can be dereferenced several times to access the element it
    points to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Additionally, when we increment or dereference a forward iterator, the other
    copies are not invalidated: if we make a copy of a forward iterator, we can advance
    the first one, and the second can still be used to access the previous element.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Two iterators that refer to the same element are guaranteed to be equal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`operator--` (position decrement) member function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator[]` member function to access elements at generic indexes and the
    binary `operator+` and `operator-` to step forward and backward of any quantity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 15: Exploring Iterator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform the following steps to explore the four categories discussed in the
    previous section and writing to the element it points to, it is also an Output
    Iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following header files at the start of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the main function declare the vector named number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform the various arithmetic operations as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Many of the iterators we will talk about are defined in the `<iterator>` header.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse Iterators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we need to iterate though a collection of elements in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ provides an iterator that allows us to do this: the *reverse iterator*.'
  prefs: []
  type: TYPE_NORMAL
- en: A *reverse iterator* wraps a *bidirectional iterator* and swaps the operation
    increment with the operation of decrement, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, when we are iterating a reverse iterator in the forward direction,
    we are visiting the elements in a range in backward order.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reverse the range of a container by calling the following methods on
    a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19: Table representing iterator functions and its description](img/C11557_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: Table presenting iterator functions and their descriptions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Code that works on normal iterators, it will also work with reverse iterators.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can see how similar the code is to iterate in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16: Exploring Functions of Reverse Iterator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to understand how functions in reverse iterator
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following header files at the start of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the main function, add the vector named numbers as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now iterate through the number vector as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Insert Iterators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Insert iterators**, also called **inserters**, are used to insert new values
    into a container rather than overwrite them.'
  prefs: []
  type: TYPE_NORMAL
- en: There exist three types of inserters, which differ on the position in the container
    at which they insert the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the different categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: Table representing iterator functions and its description](img/C11557_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: Table presenting iterator functions and their descriptions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some algorithms, which we are going to see later in this chapter, require an
    iterator for storing data. Insert iterators are usually used with such algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Stream Iterators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Stream iterators` allow us to use streams as a source to read elements from
    or as a destination to write elements to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: Table representing iterator functions and its description ](img/C11557_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: Table presenting iterator functions and their descriptions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because we don't have a container in this case, we cannot call the `end()` method
    to get the `end` iterator. A default constructed stream iterator counts as the
    end of any stream range.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a program that reads space-separated integers from the standard
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17: Stream Iterator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to understand how functions in reverse stream
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the required header files as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the main function, add the istream iterator as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows (input: 10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Iterator Invalidation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we said, iterators represent the position of elements in a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that they are tightly tied with the container, and changes to the
    container might move the elements: this means that iterators pointing to such
    an element can no longer be used – they are **invalidated**.'
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely important to always check the invalidation contract when using
    iterators with containers, as it is not specified what happens when using an invalidated
    iterator. More commonly, invalid data is accessed or the program crashes, leading
    to bugs that are hard to find.
  prefs: []
  type: TYPE_NORMAL
- en: If we keep in mind how the containers are implemented, as we saw earlier in
    this chapter, we can more easily remember when an iterator is invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we said that when we insert an element in a vector, we might have
    to get more memory to store the element, in which case all the previous elements
    are moved to the newly obtained memory. This means that all the iterators pointing
    to the elements are now pointing to the old location of the elements: they are
    invalidated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we saw that when we insert an element into the list, we
    only have to update the predecessor and successor nodes, but the elements are
    not moved. This means that the iterators to the elements remain valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When there is a need to store iterators to elements, iterator invalidation is
    an important consideration to make when deciding which container to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18: Printing All of the Customers'' Balances'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want to print the balances for all of the customers of our application. The
    balances are already stored inside a vector as integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to use iterators to traverse the vector of balances. Follow these steps
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we include the header file for the `vector` class, and we declare
    a vector of 10 elements of type `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `for` loop has been modified to iterate using the vector''s iterator, starting
    from the position returned by `begin()` until it reaches the one returned by `end()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The element of the array is accessed using the dereference operator (`*`) on
    the iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Algorithms Provided by the C++ Standard Template Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Algorithms are a way to operate on containers in an abstract way.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ standard library provides a wide range of algorithms for all the common
    operations that can be performed on ranges of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Because algorithms accept iterators, they can operate on any container, even
    user-defined containers, as long as they provide iterators.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to have a large number of algorithms that work with a large number
    of containers, without the need for the algorithm to know how the container is
    implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The following are some of the most important and common algorithms that are
    provided by the STL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Algorithms operate on ranges, so they normally take a pair of iterators: *first*
    and *last*.'
  prefs: []
  type: TYPE_NORMAL
- en: As we said earlier in this chapter, the *last* iterator denotes the element
    past the end of the range – it is not part of the range.
  prefs: []
  type: TYPE_NORMAL
- en: This means that when we want to operate on a full container, we can pass `begin()`
    and `end()` as arguments to the algorithm, but if we want to operate on a shorter
    sequence, we must be sure that our *last* iterator is past the last item we want
    to include in the range.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most of the algorithms accept a unary or binary predicate: a `Functor` (function
    object), which accepts either one or two parameters. These predicates allow the
    user to specify some of the actions that the algorithm requires. What the actions
    are vary from algorithm to algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw at the end of *Chapter 3, Classes*, to write a function object, we
    have to create a class and overload the `operator()`.
  prefs: []
  type: TYPE_NORMAL
- en: This can be very verbose, especially when the functor should perform a simple
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this with C++, the user has to write a **lambda expression**, also
    called just a *lambda*.
  prefs: []
  type: TYPE_NORMAL
- en: A *lambda expression* creates a special function object, with a type known only
    by the compiler, that behaves like a function but can access the variables in
    the scope in which it is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is defined with a syntax very similar to the one of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new object that, when called with the arguments specified in
    the lambda expression, executes the body of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '*Arguments* is the list of arguments the function accepts, and *body* is the
    sequence of statements to execute when the function is invoked. They have the
    same meaning that they have for functions, and the same rules we saw in *Chapter
    2, Functions,* apply.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create a lambda that takes two integers and returns their
    sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: By default, the body of the lambda can only reference the variables that are
    defined in the argument list and inside the body, like for functions.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, *lambdas* can **capture** a variable in the local scope, and use
    it in their body.
  prefs: []
  type: TYPE_NORMAL
- en: '*Captured variables* entail a list of variable names that can be referenced
    in the body of the lambda.'
  prefs: []
  type: TYPE_NORMAL
- en: When a variable is captured, it is stored inside the created function object,
    and it can be referenced in the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the variables are *captured by value*, so they are copied inside
    the function object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When we created the lambda, we captured `addend` by value: it was copied into
    the `sum_numbers` object. Even if we modified the value of `addend`, we did not
    change the copy stored inside `sum_numbers`, so when `sum_numbers` is executed,
    it sums 1 to `b`.'
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, we want to be able to modify the value of a variable in
    the scope in which the *lambda* is created, or we want to access the actual value,
    not the value that the variable had when the lambda was created.
  prefs: []
  type: TYPE_NORMAL
- en: In that case, we can capture by reference by prepending `&` to the variable
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we capture by reference, we need to make sure that the variable that's
    been captured by reference is still valid when the lambda is invoked, otherwise
    the body of the function accesses an invalid object, resulting in bugs.Prefer
    to capture by value when it is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we capture the `multiplier` variable by reference: only a reference to
    it was stored into `multiply_numbers`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we invoke `multiply_numbers`, the body accesses the current value of `multiplier`,
    and since `multiplier` was changed to 2, that is the value that's used by the
    *lambda*.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda can capture multiple variables, and each one can be either captured
    by value or by reference, independently one from the other.
  prefs: []
  type: TYPE_NORMAL
- en: Read-Only Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read-only algorithms are algorithms that inspect the elements stored inside
    a container but do not modify the order of the elements of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the most common operations that inspect the elements of a
    range:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: Table representing the operations that inspect elements of a
    range](img/C11557_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: Table presenting the operations that inspect elements of a range'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s see how we can use these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Modifying Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Modifying algorithms are algorithms that modify the collections they iterate
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: Table representing the modifying algorithms](img/C11557_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: Table presenting the modifying algorithms'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s see these algorithms in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Mutating Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mutating algorithms are algorithms that change the order of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: Table representing the mutating algorithms](img/C11557_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: Table presenting mutating algorithms'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s see how we can use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Sorting Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class of algorithms rearranges the order of elements within a container
    in a specific order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25: Table representing the sorting algorithms](img/C11557_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.25: Table presenting sorting algorithms'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here is how to sort a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Binary Search Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table explains the use of `binary_search`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C11557_05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.26: Table presenting the use of binary_search'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here''s how you can utilize the binary search algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Numeric Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class of algorithms combines numeric elements using a linear operation
    in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27: Table representing the numeric algorithm](img/C11557_05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.27: Table presenting the numeric algorithm'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s see how we can use `accumulate` in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 19: Customer Analytics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have the information of many customers of our application and we want to
    compute analytics data on that.
  prefs: []
  type: TYPE_NORMAL
- en: Given a map that has a username as a key and a user account as a value, we would
    like to print the balances of the new users in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'A user is considered new if they registered no more than 15 days ago. The struct
    representing the user''s account is provided and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Write the `void computeAnalytics(std::map<std::string, UserAccount>& accounts)`
    function, which prints the desired balances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to include all the required headers for the solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we need to extract `UserAccount` from the map. Remember that the element
    the map stores is `pair` containing a key and value. Since we need to transform
    the type into `UserAccount`, we can use `std::transform`, by passing a `lambda`
    that only returns the user account from the `pair`. To insert this into `vector`,
    we can use `std::back_inserter`. Make sure to use a `const` reference when accepting
    `pair` in the lambda that''s passed to transform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After we have extracted the accounts in `vector`, we can use `remove_if` to
    remove all accounts that are older than 15 days:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After removing the old accounts, we need to sort the balances in descending
    order. By default, `std::sort` uses an ascending order, so we need to provide
    a `lambda` to change the order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now invoke our function with the following test data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we introduced sequential containers – containers whose elements
    can be accessed in sequence. We looked at the `array`, `vector`, `deque`, `list`,
    and `forward_list` sequential containers.
  prefs: []
  type: TYPE_NORMAL
- en: We saw what functionality they offer and how we can operate on them, and we
    saw how they are implemented and how storage works for vector and list.
  prefs: []
  type: TYPE_NORMAL
- en: We followed this up with associative containers, containers that allow the fast
    lookup of their elements, always kept in order. `Set`, `multiset`, `map`, and
    `multimap` are part of this category.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the operations they support and how map and multimap are used to
    associate a value to a key. We also saw their unordered version, which does not
    keep elements in order but provides higher performance. `Unordered_set` and `unordered_map`
    are in this category.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at unconventional containers. `String` is used to manipulate
    sequences of characters, `pair` and `tuple` are used to hold various elements
    of different types, `optional` is used to add optionality to a type, and `variant`
    is used to store a value that could be of several types.
  prefs: []
  type: TYPE_NORMAL
- en: We then explored iterators and learned how they are used to abstract the concept
    of containers and provide a common set of functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the various types of iterators, and we learned what iterator invalidation
    is and why it is important to be aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: We finally moved on to algorithms in the C++ standard, after explaining that
    `lambda` is a convenient way of defining a function that can also access variables
    in the scope in which it is created.
  prefs: []
  type: TYPE_NORMAL
- en: We divided the most common algorithms into various categories, and we looked
    at the most important algorithms in those categories, including `find`, `remove`,
    and `sort`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to use the advanced features of C++
    to create dynamic programs.
  prefs: []
  type: TYPE_NORMAL
