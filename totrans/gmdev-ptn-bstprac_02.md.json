["```cpp\nclass ModifierExamples \n{ \n  public int publicInteger; \n  private void PrivateMethod() {} \n  protected float protectedNumber; \n};\n\n```", "```cpp\nclass MoreModifierExamples \n{ \n  public: \n    // until we reach another tag, all variables and functions  \n    // will be public \n    int publicIntegar; \n    int anotherExample; \n\n  private: \n    // Now, they'll be private \n    void PrivateFunction() {} \n    double safeValue; \n\n  protected: \n    // And now... protected \n    float protectedNumber; \n    int AlsoProtected() { return 0; } \n};\n\n```", "```cpp\n#include <string> \n\nclass StaticExamples \n{ \npublic: \n  void InFunction() \n  { \n    static int enemyCount = 0; \n\n    // Increase the value of enemyCount \n    enemyCount += 10; \n\n    std::string toDisplay = \"\\n Value of enemyCount:  \" +  \n                std::to_string(enemyCount); \n\n    printf(toDisplay.c_str()); \n  } \n};\n\n```", "```cpp\n  StaticExamples se; \n\n  se.InFunction(); \n  se.InFunction();\n\n```", "```cpp\nclass StaticExamples \n\n{ \npublic: \n static float classVariable; static void StaticFunction() \n  { \n    // Note, can only use static variables and functions within \n    // static function \n std::string toDisplay = \"\\n I can be called anywhere! classVariable value: \" + std::to_string(classVariable); \n\n    printf(toDisplay.c_str()); \n  } \n\n  void InFunction() \n  { \n    static int enemyCount = 0; \n\n    // Increase the value of enemyCount \n    enemyCount += 10; \n\n    std::string toDisplay = \"\\n Value of enemyCount:  \" +  \n                std::to_string(enemyCount); \n\n    printf(toDisplay.c_str()); \n  } \n};\n\n```", "```cpp\n// StaticExamples.cpp \nfloat StaticExamples::classVariable = 2.5f;\n\n```", "```cpp\nStaticExamples::StaticFunction(); \nStaticExamples::classVariable = 5; \nStaticExamples::StaticFunction();\n\n```", "```cpp\nclass Singleton \n{ \n  public: \n    static Singleton * GetInstance() \n    { \n      // If the instance does not exist, create one \n      if (!instance) \n      { \n        instance = new Singleton; \n      } \n\n      return instance; \n    } \n\n  private: \n    static Singleton * instance;  \n};\n\n```", "```cpp\nSingleton singleton;\n\n```", "```cpp\nSingleton instanceCopy(*(Singleton::GetInstance()));\n\n```", "```cpp\nclass Singleton \n{ \npublic: \n  static Singleton * GetInstance() \n  { \n    // If the instance does not exist, create one \n    if (!instance) \n    { \n      instance = new Singleton; \n    } \n\n    return instance; \n  } \n\nprivate: \n  static Singleton * instance;  \n\n // Disable usability of silently generated functions Singleton(); ~Singleton(); Singleton(const Singleton &); Singleton& operator=(const Singleton&); \n\n};\n\n```", "```cpp\nstatic Singleton& GetInstance() \n{ \n  // If the instance does not exist, create one \n  if (!instance) \n  { \n    instance = new Singleton; \n  } \n\n  return *instance; \n}\n\n```", "```cpp\nSingleton& singleton = Singleton::GetInstance(); \ndelete &singleton;\n\n```", "```cpp\nvoid SpawnEnemy() \n{ \n  static int numberOfEnemies = 0; \n  ++numberOfEnemies; \n\n  // Spawn the enemy \n}\n\n```", "```cpp\nclass Singleton \n{ \n  public: \n    static Singleton & GetInstance() \n    { \n      static Singleton instance; \n      return instance; \n    } \n\n  private: \n    // Disable usability of silently generated functions \n    Singleton(); \n    ~Singleton(); \n    Singleton(const Singleton &); \n    Singleton& operator=(const Singleton&); \n\n};\n\n```", "```cpp\n#include <iostream> // std::cout \n\ntemplate <class T> \nclass TemplateExample \n{ \npublic: \n  // Constructor \n  TemplateExample(); \n  // Destructor \n  ~TemplateExample(); \n  // Function \n  T TemplatedFunction(T); \n};\n\n```", "```cpp\ntemplate <class T> TemplateExample<T>::TemplateExample() \n{ \n  printf(\"\\nConstructor!\"); \n} \n\ntemplate <class T> TemplateExample<T>::~TemplateExample() \n{ \n  printf(\"\\nDeconstructor!\"); \n} \n\ntemplate <class T> T TemplateExample<T>::TemplatedFunction(T obj) \n{ \n  std::cout << \"\\nValue: \" << obj; \n  return obj; \n}\n\n```", "```cpp\n  TemplateExample<int> teInt; \n  teInt.TemplatedFunction(5); \n\n  TemplateExample<float> teFloat; \n  teFloat.TemplatedFunction(2.5); \n\n  TemplateExample<std::string> teString; \n  teString.TemplatedFunction(\"Testing\");\n\n```", "```cpp\ntemplate <typename T> \nclass Singleton \n{ \npublic: \n  Singleton() \n  { \n    // Set our instance variable when we are created \n    if (instance == nullptr) \n    { \n      instance = static_cast<T*>(this); \n    } \n    else \n    { \n      // If instance already exists, we have a problem \n      printf(\"\\nError: Trying to create more than one Singleton\"); \n    } \n  } \n\n  // Once destroyed, remove access to instance \n  virtual ~Singleton() \n  { \n    instance = nullptr; \n  } \n\n  // Get a reference to our instance \n  static T & GetInstance() \n  { \n    return *instance; \n  } \n\n  // Creates an instance of our instance \n  static void CreateInstance() \n  {   \n    new T(); \n  } \n\n  // Deletes the instance, needs to be called or resource leak \n  static void RemoveInstance() \n  { \n    delete instance; \n  } \n\nprivate: \n  // Note, needs to be a declaration \n  static T * instance; \n\n}; \n\ntemplate <typename T> T * Singleton<T>::instance = nullptr;\n\n```", "```cpp\nclass HighScoreManager : public Singleton<HighScoreManager> \n{ \npublic: \n  void CheckHighScore(int score); \n\nprivate: \n  int highScore; \n};\n\n```", "```cpp\nvoid HighScoreManager::CheckHighScore(int score) \n{ \n  std::string toDisplay; \n\n  if (highScore < score) \n  { \n    highScore = score; \n    toDisplay = \"\\nNew High Score: \" + std::to_string(score); \n    printf(toDisplay.c_str()); \n  } \n  else \n  { \n    toDisplay = \"\\nCurrent High Score: \" + std::to_string(highScore); \n    printf(toDisplay.c_str()); \n  } \n}\n\n```", "```cpp\nvoid SplashStage::Init(void) \n{ \n  //This code will only show in the console if it is active and you  \n  //are in debug mode. \n  M5DEBUG_PRINT(\"This is a demo of the different things you can do\\n\"); \n  M5DEBUG_PRINT(\"in the Mach 5 Engine.  Play with the demo but you must\\n\"); \n  M5DEBUG_PRINT(\"also inspect the code and comments.\\n\\n\"); \n  M5DEBUG_PRINT(\"If you find errors, report to lazersquad@gmail.com\"); \n\n HighScoreManager::CreateInstance(); HighScoreManager::GetInstance().CheckHighScore(10); HighScoreManager::GetInstance().CheckHighScore(100); HighScoreManager::GetInstance().CheckHighScore(50); \n\n  //Create ini reader and starting vars \n  M5IniFile iniFile; \n\n  // etc. etc.\n\n```", "```cpp\nvoid SplashStage::Shutdown(void) \n{ \n HighScoreManager::RemoveInstance(); \n\n  M5ObjectManager::DestroyAllObjects(); \n}\n\n```", "```cpp\n//! Singleton class to Control the Window \nclass M5App \n{ \npublic: \n  friend class M5StageManager; \n\n  /*Call These in Main*/ \n\n  /*This must be called first, before the game is started*/ \n  static void Init(const M5InitData& initStruct); \n  /*Call this after you add your stages to start the game*/ \n  static void Update(void); \n  /*Call this after Update is finished*/ \n  static void Shutdown(void); \n\n  /*Call these to control or get info about the application*/ \n\n  /*Use this to change to fullscreen and back*/ \n  static void SetFullScreen(bool fullScreen); \n  /*Use this to show and hide the window*/ \n  static void ShowWindow(bool show); \n  /*Use this to show and hide the default window cursor*/ \n  static void ShowCursor(bool showCursor); \n  /*Use this to change the resolution of the game*/ \n  static void SetResolution(int width, int height); \n  /*Returns the width and height of the window (client area)*/ \n  static M5Vec2 GetResolution(void); \n\nprivate: \n  static LRESULT CALLBACK M5WinProc(HWND win, UINT msg, WPARAM wp, LPARAM lp); \n  static void ProcessMessages(void); \n\n};//end M5APP\n\n```", "```cpp\nint WINAPI WinMain(HINSTANCE instance, \n                   HINSTANCE /*prev*/,  \n                   LPSTR /*commandLine*/,  \n                   int /*show*/) \n{ \n  /*This should appear at the top of winmain to have windows find memory leaks*/ \n  M5DEBUG_LEAK_CHECKS(-1); \n\n  M5InitData initData;          /*Declare my InitStruct*/ \n  M5GameData gameData = { 0 };  /*Create my game data initial values*/ \n  M5IniFile iniFile;            /*To load my init data from file*/ \n\n  iniFile.ReadFile(\"GameData/InitData.ini\"); \n  iniFile.SetToSection(\"InitData\"); \n\n  /*Set up my InitStruct*/ \n  iniFile.GetValue(\"width\", initData.width); \n  iniFile.GetValue(\"height\", initData.height); \n  iniFile.GetValue(\"framesPerSecond\", initData.fps); \n  iniFile.GetValue(\"fullScreen\", initData.fullScreen); \n\n  initData.title        = \"AstroShot\"; \n  initData.instance     = instance; \n  /*Information about your specific gamedata */ \n  initData.pGData       = &gameData; \n  initData.gameDataSize = sizeof(M5GameData); \n\n  /*Pass InitStruct to Function.  This function must be called first!!!*/ \n M5App::Init(initData); \n\n  /*Make sure to add what stage we will start in*/ \n  M5StageManager::SetStartStage(ST_SplashStage); \n\n /*Start running the game*/ M5App::Update(); /*This function must be called after the window has closed!!!*/ M5App::Shutdown(); \n\n  return 0; \n}\n\n```", "```cpp\nvoid M5App::Init(const M5InitData& initData) \n{ \n  // ... \n    // Other init code above... \n\n M5StageManager::Init(initData.pGData, initData.gameDataSize, initData.fps); M5ObjectManager::Init(); M5Input::Init(); \n}\n\n```"]