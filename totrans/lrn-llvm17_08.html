<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer021">&#13;
			<h1 id="_idParaDest-99" class="chapter-number"><a id="_idTextAnchor101"/>6</h1>&#13;
			<h1 id="_idParaDest-100"><a id="_idTextAnchor102"/>Advanced IR Generation</h1>&#13;
			<p>With IR generation introduced in the previous chapters, you can already implement most of the functionality required in a compiler. In this chapter, we will look at some advanced topics that often arise in real-world compilers. For example, many modern languages make use of exception handling, so we’ll look at how to translate this into <span class="No-Break">LLVM IR.</span></p>&#13;
			<p>To support the LLVM optimizer so that it can produce better code in certain situations, we must add additional type metadata to the IR code. Moreover, attaching debug metadata enables the compiler’s user to take advantage of source-level <span class="No-Break">debug tools.</span></p>&#13;
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>&#13;
			<ul>&#13;
				<li><em class="italic">Throwing and catching exceptions</em>: Here, you will learn how to implement exception handling in <span class="No-Break">your compiler</span></li>&#13;
				<li><em class="italic">Generating metadata for type-based alias analysis</em>: Here, you will attach additional metadata to LLVM IR, which helps LLVM to better optimize <span class="No-Break">the code</span></li>&#13;
				<li><em class="italic">Adding debug metadata</em>: Here, you will implement the support classes needed to add debug information to the generated <span class="No-Break">IR code</span></li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you will have learned about exception handling, as well as metadata for type-based alias analysis and <span class="No-Break">debug information.</span></p>&#13;
			<h1 id="_idParaDest-101"><a id="_idTextAnchor103"/>Throwing and catching exceptions</h1>&#13;
			<p>Exception handling in LLVM IR is closely tied to platform support. Here, we will look at the most <a id="_idIndexMarker327"/>common type of exception handling using <strong class="source-inline">libunwind</strong>. Its full <a id="_idIndexMarker328"/>potential is used by C++, so we will look at an example in C++ first, where the <strong class="source-inline">bar()</strong> function can throw an <strong class="source-inline">int</strong> or <span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break"> value:</span></p>&#13;
			<pre class="source-code">&#13;
int bar(int x) {&#13;
  if (x == 1) throw 1;&#13;
  if (x == 2) throw 42.0;&#13;
  return x;&#13;
}</pre>			<p>The <strong class="source-inline">foo()</strong> function calls <strong class="source-inline">bar()</strong>, but only handles a thrown <strong class="source-inline">int</strong>. It also declares that it only throws <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> values:</span></p>&#13;
			<pre class="source-code">&#13;
int foo(int x) {&#13;
  int y = 0;&#13;
  try {&#13;
    y = bar(x);&#13;
  }&#13;
  catch (int e) {&#13;
    y = e;&#13;
  }&#13;
  return y;&#13;
}</pre>			<p>Throwing an <a id="_idIndexMarker329"/>exception requires two calls into the runtime library; this can be seen in the <strong class="source-inline">bar()</strong> function. First, memory for the exception is allocated <a id="_idIndexMarker330"/>with a call to <strong class="source-inline">__cxa_allocate_exception()</strong>. This function takes the number of bytes to allocate as a parameter. The exception payload (the <strong class="source-inline">int</strong> or <strong class="source-inline">double</strong> value in this example) is copied to the allocated memory. The exception is then raised with a call to <strong class="source-inline">__cxa_throw()</strong>. This function takes three arguments: the pointer to the allocated exception, type information about the payload, and a pointer to a destructor, in case the exception payload has one. The <strong class="source-inline">__cxa_throw()</strong> function initiates the stack unwinding process and never returns. In LLVM IR, this is done for the <strong class="source-inline">int</strong> value, <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
%eh = call ptr @__cxa_allocate_exception(i64 4)&#13;
store i32 1, ptr %eh&#13;
call void @__cxa_throw(ptr %eh, ptr @_ZTIi, ptr null)&#13;
unreachable</pre>			<p><strong class="source-inline">_ZTIi</strong> is the type information describing an <strong class="source-inline">int</strong> type. For a double type, it would <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">_ZTId</strong></span><span class="No-Break">.</span></p>&#13;
			<p>So far, nothing LLVM-specific is done. This changes in the <strong class="source-inline">foo()</strong> function because the call to <strong class="source-inline">bar()</strong> can raise an exception. If it is an <strong class="source-inline">int</strong> type exception, then the control flow must be transferred to the IR code of the catch clause. To accomplish this, the <strong class="source-inline">invoke</strong> instruction must be used instead of the <span class="No-Break"><strong class="source-inline">call</strong></span><span class="No-Break"> instruction:</span></p>&#13;
			<pre class="source-code">&#13;
%y = invoke i32 @_Z3bari(i32 %x) to label %next&#13;
                                 unwind label %lpad</pre>			<p>The difference <a id="_idIndexMarker331"/>between both instructions is that <strong class="source-inline">invoke</strong> has two labels associated. The first label is where execution continues in case the called <a id="_idIndexMarker332"/>function ends normally, usually with a <strong class="source-inline">ret</strong> instruction. In the example code, this label is called <strong class="source-inline">%next</strong>. If an exception occurs, then execution <a id="_idIndexMarker333"/>continues at a so-called <em class="italic">landing pad</em>, with a label <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">%lpad</strong></span><span class="No-Break">.</span></p>&#13;
			<p>The landing pad is a basic block that must begin with a <strong class="source-inline">landingpad</strong> instruction. The <strong class="source-inline">landingpad</strong> instruction gives LLVM information about the handled exception types. For example, a possible landing pad could look <span class="No-Break">like this:</span></p>&#13;
			<pre class="source-code">&#13;
lpad:&#13;
%exc = landingpad { ptr, i32 }&#13;
          cleanup&#13;
          catch ptr @_ZTIi&#13;
          filter [1 x ptr] [ptr @_ZTIi]</pre>			<p>There are three possible types of <span class="No-Break">action here:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">cleanup</strong>: This denotes that code to clean up the current state is present. Usually, this is used to call destructors of local objects. If this marker is present, then the landing pad is always called during <span class="No-Break">stack unwinding.</span></li>&#13;
				<li><strong class="source-inline">catch</strong>: This is a list of type-value pairs and denotes the exception types that can be handled. The landing pad is called if the thrown exception type is found in this list. In the case of the <strong class="source-inline">foo()</strong> function, the value is the pointer to the C++ runtime type information for the <strong class="source-inline">int</strong> type, similar to the parameter of the <span class="No-Break"><strong class="source-inline">__cxa_throw()</strong></span><span class="No-Break"> function.</span></li>&#13;
				<li><strong class="source-inline">filter</strong>: This specifies an array of exception types. The landing pad is called if the exception type of the current exception is not found in the array. This is used to implement the <strong class="source-inline">throw()</strong> specification. For the <strong class="source-inline">foo()</strong> function, the array has only one member – the type information for the <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> type.</span></li>&#13;
			</ul>&#13;
			<p>The result type of the <strong class="source-inline">landingpad</strong> instruction is the <strong class="source-inline">{ ptr, i32 }</strong> structure. The first element <a id="_idIndexMarker334"/>is a pointer to the thrown exception, while the <a id="_idIndexMarker335"/>second is a type selector. Let’s extract both from <span class="No-Break">the structure:</span></p>&#13;
			<pre class="source-code">&#13;
%exc.ptr = extractvalue { ptr, i32 } %exc, 0&#13;
%exc.sel = extractvalue { ptr, i32 } %exc, 1</pre>			<p>The <em class="italic">type selector</em> is a number <a id="_idIndexMarker336"/>that helps us identify the cause of <em class="italic">why the landing pad is called</em>. It is a positive value if the current exception type matches one of the exception types given in the <strong class="source-inline">catch</strong> part of the <strong class="source-inline">landingpad</strong> instruction. If the current exception type does not match any of the values given in the <strong class="source-inline">filter</strong> part, then the value is negative. It is <strong class="source-inline">0</strong> if the cleanup code should <span class="No-Break">be called.</span></p>&#13;
			<p>The type selector is an offset into a type information table, constructed from the values given in the <strong class="source-inline">catch</strong> and <strong class="source-inline">filter</strong> parts of the <strong class="source-inline">landingpad</strong> instruction. During optimization, multiple landing pads can be combined into one, which means that the structure of this table is not known at the IR level. To retrieve the type selector for a given type, we need to call the intrinsic <strong class="source-inline">@llvm.eh.typeid.for</strong> function. We need this to check if the type selector value corresponds to the type information for <strong class="source-inline">int</strong> so that we can execute the code in the <strong class="source-inline">catch (int e) {}</strong> <span class="No-Break">block:</span></p>&#13;
			<pre class="source-code">&#13;
%tid.int = call i32 @llvm.eh.typeid.for(ptr @_ZTIi)&#13;
%tst.int = icmp eq i32 %exc.sel, %tid.int&#13;
br i1 %tst.int, label %catchint, label %filterorcleanup</pre>			<p>The handling of an exception is framed by calls to <strong class="source-inline">__cxa_begin_catch()</strong> and <strong class="source-inline">__cxa_end_catch()</strong>. The <strong class="source-inline">__cxa_begin_catch()</strong> function needs one argument – the current exception – which is one of the values returned by the <strong class="source-inline">landingpad</strong> instruction. It returns a pointer to the exception payload – an <strong class="source-inline">int</strong> value in <span class="No-Break">our case.</span></p>&#13;
			<p>The <strong class="source-inline">__cxa_end_catch()</strong> function marks the end of exception handling and deallocates the memory allocated with <strong class="source-inline">__cxa_allocate_exception()</strong>. Please note that <a id="_idIndexMarker337"/>the runtime behavior is much more complicated if <a id="_idIndexMarker338"/>another exception is thrown inside the <strong class="source-inline">catch</strong> block. The exception is handled <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
catchint:&#13;
%payload = call ptr @__cxa_begin_catch(ptr %exc.ptr)&#13;
%retval = load i32, ptr %payload&#13;
call void @__cxa_end_catch()&#13;
br label %return</pre>			<p>If the type of the current exception does not match the list in the <strong class="source-inline">throws()</strong> declaration, the unexpected exception handler is called. First, we need to check the type <span class="No-Break">selector again:</span></p>&#13;
			<pre class="source-code">&#13;
filterorcleanup:&#13;
%tst.blzero = icmp slt i32 %exc.sel, 0&#13;
br i1 %tst.blzero, label %filter, label %cleanup</pre>			<p>If the value of the type selector is lower than <strong class="source-inline">0</strong>, then we call <span class="No-Break">the handler:</span></p>&#13;
			<pre class="source-code">&#13;
filter:&#13;
call void @__cxa_call_unexpected(ptr %exc.ptr) #4&#13;
unreachable</pre>			<p>Again, the handler is not expected to <span class="No-Break">come back.</span></p>&#13;
			<p>No cleanup work is needed in this case, so all the cleanup code does is resume the execution of the <span class="No-Break">stack unwinder:</span></p>&#13;
			<pre class="source-code">&#13;
cleanup:&#13;
resume { ptr, i32 } %exc</pre>			<p>One piece is still missing: <strong class="source-inline">libunwind</strong> drives the stack unwinding process, but it is not tied to a single language. Language-dependent handling is done in the personality function. For C++ on Linux, the personality function is called <strong class="source-inline">__gxx_personality_v0()</strong>. Depending on the platform or compiler, this name can vary. Each function that needs to take part in stack unwinding has a personality function attached. This personality function analyzes if the function catches an exception, has a non-matching filter list, or needs a cleanup call. It gives this information back to the unwinder, which acts accordingly. In LLVM IR, the pointer to the personality function is given as a part of the <span class="No-Break">function definition:</span></p>&#13;
			<pre class="source-code">&#13;
define i32 @_Z3fooi(i32) personality ptr @__gxx_personality_v0</pre>			<p>With this, the exception handling facility <span class="No-Break">is complete.</span></p>&#13;
			<p>To use exception <a id="_idIndexMarker339"/>handling in the compiler for your programming language, the simplest strategy is to piggyback on the existing C++ runtime functions. This also <a id="_idIndexMarker340"/>has the advantage that your exceptions are interoperable with C++. The disadvantage is that you tie some of the C++ runtime into the runtime of your language, most notably memory management. If you want to avoid this, then you need to create your own equivalents of the <strong class="source-inline">_cxa_</strong> functions. Still, you will want to use <strong class="source-inline">libunwind</strong>, which provides the stack <span class="No-Break">unwinding mechanism:</span></p>&#13;
			<ol>&#13;
				<li>Let’s look at how to create this IR. We created the <strong class="source-inline">calc</strong> expression compiler in <a href="B19561_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">The Structure of a Compiler</em>. Now, we will extend the code generator of the expression compiler to raise and handle an exception in case a division by zero is performed. The generated IR will check if the divisor of a division is <strong class="source-inline">0</strong>. If true, then an exception will be raised. We will also add a landing pad to the function, which catches the exception and prints <strong class="source-inline">Divide by zero!</strong> to the console and ends the calculation. Using exception handling is not necessary in this simple case, but it allows us to concentrate on the code generation process. We must add all the code to the <strong class="source-inline">CodeGen.cpp</strong> file. We begin by adding the required new fields and some helper methods. First of all, we need to store the LLVM declaration of the <strong class="source-inline">__cxa_allocate_exception()</strong> and <strong class="source-inline">__cxa_throw()</strong> functions, which consist of the function type and the function itself. A <strong class="source-inline">GlobalVariable</strong> instance is needed to hold the type information. We also need references to the basic blocks holding the landing pad and a basic block containing just an <span class="No-Break"><strong class="source-inline">unreachable</strong></span><span class="No-Break"> instruction:</span><pre class="source-code">&#13;
  GlobalVariable *TypeInfo = nullptr;&#13;
  FunctionType *AllocEHFty = nullptr;&#13;
  Function *AllocEHFn = nullptr;&#13;
  FunctionType *ThrowEHFty = nullptr;&#13;
  Function *ThrowEHFn = nullptr;&#13;
  BasicBlock *LPadBB = nullptr;&#13;
  BasicBlock *UnreachableBB = nullptr;</pre></li>				<li>We will <a id="_idIndexMarker341"/>also add a new helper function to create the IR for comparing two values. The <strong class="source-inline">createICmpEq()</strong> function takes the <strong class="source-inline">Left</strong> and <strong class="source-inline">Right</strong> values to compare as parameters. It creates a compare instruction <a id="_idIndexMarker342"/>testing for equality of the values, and a branch instruction to two basic blocks, for the equal and inequal cases. The two basic blocks are returned via references in the <strong class="source-inline">TrueDest</strong> and <strong class="source-inline">FalseDest</strong> parameters. Furthermore, a label for the new basic blocks can be given in the <strong class="source-inline">TrueLabel</strong> and <strong class="source-inline">FalseLabel</strong> parameters. The code is <span class="No-Break">as follows:</span><pre class="source-code">&#13;
  void createICmpEq(Value *Left, Value *Right,&#13;
                    BasicBlock *&amp;TrueDest,&#13;
                    BasicBlock *&amp;FalseDest,&#13;
                    const Twine &amp;TrueLabel = "",&#13;
                    const Twine &amp;FalseLabel = "") {&#13;
    Function *Fn =&#13;
        Builder.GetInsertBlock()-&gt;getParent();&#13;
    TrueDest = BasicBlock::Create(M-&gt;getContext(),&#13;
                                  TrueLabel, Fn);&#13;
    FalseDest = BasicBlock::Create(M-&gt;getContext(),&#13;
                                   FalseLabel, Fn);&#13;
    Value *Cmp = Builder.CreateCmp(CmpInst::ICMP_EQ,&#13;
                                   Left, Right);&#13;
    Builder.CreateCondBr(Cmp, TrueDest, FalseDest);&#13;
  }</pre></li>				<li>To use the <a id="_idIndexMarker343"/>functions from the runtime, we need to create several function declarations. In LLVM, a function type gives the signature, and the <a id="_idIndexMarker344"/>function itself must be constructed. We use the <strong class="source-inline">createFunc()</strong> method to create both objects. The functions need references to the <strong class="source-inline">FunctionType</strong> and <strong class="source-inline">Function</strong> pointers, the name of the newly declared function, and the result type. The parameter type list is optional, and the flag to indicate a variable parameter list is set to <strong class="source-inline">false</strong>, indicating that there is no variable part in the <span class="No-Break">parameter list:</span><pre class="source-code">&#13;
  void createFunc(FunctionType *&amp;Fty, Function *&amp;Fn,&#13;
                  const Twine &amp;N, Type *Result,&#13;
                  ArrayRef&lt;Type *&gt; Params = None,&#13;
                  bool IsVarArgs = false) {&#13;
    Fty = FunctionType::get(Result, Params, IsVarArgs);&#13;
    Fn = Function::Create(&#13;
        Fty, GlobalValue::ExternalLinkage, N, M);&#13;
  }</pre></li>			</ol>&#13;
			<p>With these preparations done, we can generate the IR to raise <span class="No-Break">an exception.</span></p>&#13;
			<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/>Raising an exception</h2>&#13;
			<p>To generate the IR code to raise an exception, we will add the <strong class="source-inline">addThrow()</strong> method. This new <a id="_idIndexMarker345"/>method needs to initialize the new fields and then generate the IR to raise an exception via the <strong class="source-inline">__cxa_throw()</strong> function. The payload of the raised exception is of the <strong class="source-inline">int</strong> type and can be set to an arbitrary value. Here is what we need <span class="No-Break">to code:</span></p>&#13;
			<ol>&#13;
				<li>The new <strong class="source-inline">addThrow()</strong> method begins by checking if the <strong class="source-inline">TypeInfo</strong> field has been initialized. If it has not been initialized, then a global external constant of an <strong class="source-inline">i8</strong> pointer type called <strong class="source-inline">_ZTIi</strong> is created. This represents the C++ metadata describing the C++ <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> type:</span><pre class="source-code">&#13;
  void addThrow(int PayloadVal) {&#13;
    if (!TypeInfo) {&#13;
      TypeInfo = new GlobalVariable(&#13;
          *M, Int8PtrTy,&#13;
          /*isConstant=*/true,&#13;
          GlobalValue::ExternalLinkage,&#13;
          /*Initializer=*/nullptr, "_ZTIi");</pre></li>				<li>The initialization continues with creating the IR declaration for the <strong class="source-inline">__cxa_allocate_exception()</strong> and <strong class="source-inline">__cxa_throw()</strong> functions using our helper <span class="No-Break"><strong class="source-inline">createFunc()</strong></span><span class="No-Break"> method:</span><pre class="source-code">&#13;
      createFunc(AllocEHFty, AllocEHFn,&#13;
                 "__cxa_allocate_exception", Int8PtrTy,&#13;
                 {Int64Ty});&#13;
      createFunc(ThrowEHFty, ThrowEHFn, "__cxa_throw",&#13;
                 VoidTy,&#13;
                 {Int8PtrTy, Int8PtrTy, Int8PtrTy});</pre></li>				<li>A function that uses exception handling needs a personality function, which helps with stack unwinding. We add the IR code to declare the <strong class="source-inline">__gxx_personality_v0()</strong> personality function from the C++ library and set it as the <a id="_idIndexMarker346"/>personality routine of the current function. The current function is not stored as a field, but we can use the <strong class="source-inline">Builder</strong> instance to query the current basic block, which has the function stored as a <span class="No-Break"><strong class="source-inline">Parent</strong></span><span class="No-Break"> field:</span><pre class="source-code">&#13;
      FunctionType *PersFty;&#13;
      Function *PersFn;&#13;
      createFunc(PersFty, PersFn,&#13;
                 "__gxx_personality_v0", Int32Ty, std::nulopt,                  true);&#13;
      Function *Fn =&#13;
          Builder.GetInsertBlock()-&gt;getParent();&#13;
      Fn-&gt;setPersonalityFn(PersFn);</pre></li>				<li>Next, we must create and populate the basic block for the landing pad. First, we need to save the pointer to the current basic block. Then, we must create a new basic block, set it in the builder so that it can be used as the basic block to insert instructions, and call the <strong class="source-inline">addLandingPad()</strong> method. This method generates the IR code for handling an exception and is described in the next section, <em class="italic">Catching an exception</em>. This code populates the basic block for the <span class="No-Break">landing pad:</span><pre class="source-code">&#13;
      BasicBlock *SaveBB = Builder.GetInsertBlock();&#13;
      LPadBB = BasicBlock::Create(M-&gt;getContext(),&#13;
                                  "lpad", Fn);&#13;
      Builder.SetInsertPoint(LPadBB);&#13;
      addLandingPad();</pre></li>				<li>The initialization part is completed by creating the basic block holding an <strong class="source-inline">unreachable</strong> instruction. Again, we create the basic block and set it as an insertion point at the builder. Then, we can add the <strong class="source-inline">unreachable</strong> instruction to it. Lastly, we can set the insertion point of the builder back to the saved <strong class="source-inline">SaveBB</strong> instance so that the following IR is added to the right <span class="No-Break">basic block:</span><pre class="source-code">&#13;
      UnreachableBB = BasicBlock::Create(&#13;
          M-&gt;getContext(), "unreachable", Fn);&#13;
      Builder.SetInsertPoint(UnreachableBB);&#13;
      Builder.CreateUnreachable();&#13;
      Builder.SetInsertPoint(SaveBB);&#13;
    }</pre></li>				<li>To raise an exception, we need to allocate memory for the exception and the payload via a call to the <strong class="source-inline">__cxa_allocate_exception()</strong> function. Our payload is <a id="_idIndexMarker347"/>of the C++ <strong class="source-inline">int</strong> type, which usually has a size of 4 bytes. We create a constant unsigned value for the size and call the function with it as a parameter. The function type and the function declaration are already initialized, so we only need to create the <span class="No-Break"><strong class="source-inline">call</strong></span><span class="No-Break"> instruction:</span><pre class="source-code">&#13;
    Constant *PayloadSz =&#13;
        ConstantInt::get(Int64Ty, 4, false);&#13;
    CallInst *EH = Builder.CreateCall(&#13;
        AllocEHFty, AllocEHFn, {PayloadSz});</pre></li>				<li>Next, we store the <strong class="source-inline">PayloadVal</strong> value in the allocated memory. To do so, we need to create an LLVM IR constant with a call to the <strong class="source-inline">ConstantInt::get()</strong> function. The pointer to the allocated memory is of an <strong class="source-inline">i8</strong> pointer type; to store a value of the <strong class="source-inline">i32</strong> type, we need to create a <strong class="source-inline">bitcast</strong> instruction to cast <span class="No-Break">the type:</span><pre class="source-code">&#13;
    Value *PayloadPtr =&#13;
        Builder.CreateBitCast(EH, Int32PtrTy);&#13;
    Builder.CreateStore(&#13;
        ConstantInt::get(Int32Ty, PayloadVal, true),&#13;
        PayloadPtr);</pre></li>				<li>Finally, we must raise the exception with a call to the <strong class="source-inline">__cxa_throw()</strong> function. As this function raises an exception, which is also handled in the same function, we need to use the <strong class="source-inline">invoke</strong> instruction instead of the <strong class="source-inline">call</strong> instruction. Unlike the <strong class="source-inline">call</strong> instruction, the <strong class="source-inline">invoke</strong> instruction ends a basic block because it has two successor basic blocks. Here, these are the <strong class="source-inline">UnreachableBB</strong> and <strong class="source-inline">LPadBB</strong> basic blocks. If the function raises no exception, the control flow is transferred to the <strong class="source-inline">UnreachableBB</strong> basic blocks. Due to the <a id="_idIndexMarker348"/>design of the <strong class="source-inline">__cxa_throw()</strong> function, this will never happen because the control flow is transferred to the <strong class="source-inline">LPadBB</strong> basic block to handle the exception. This finishes the implementation of the <span class="No-Break"><strong class="source-inline">addThrow()</strong></span><span class="No-Break"> method:</span><pre class="source-code">&#13;
    Builder.CreateInvoke(&#13;
        ThrowEHFty, ThrowEHFn, UnreachableBB, LPadBB,&#13;
        {EH,&#13;
         ConstantExpr::getBitCast(TypeInfo, Int8PtrTy),&#13;
         ConstantPointerNull::get(Int8PtrTy)});&#13;
  }</pre></li>			</ol>&#13;
			<p>Next, we’ll add the code to generate the IR to handle <span class="No-Break">the exception.</span></p>&#13;
			<h2 id="_idParaDest-103"><a id="_idTextAnchor105"/>Catching an exception</h2>&#13;
			<p>To generate <a id="_idIndexMarker349"/>the IR code to catch an exception, we must add the <strong class="source-inline">addLandingPad()</strong> method. The generated IR extracts the type information from the exception. If it matches the C++ <strong class="source-inline">int</strong> type, then the exception is handled by printing <strong class="source-inline">Divide by zero!</strong> to the console and returning from the function. If the type does not match, we simply execute the <strong class="source-inline">resume</strong> instruction, which transfers control back to the runtime. As there are no other functions in the call hierarchy to handle this exception, the runtime will terminate the application. The following steps <a id="_idIndexMarker350"/>describe the code that is needed to generate the IR for catching <span class="No-Break">an exception:</span></p>&#13;
			<ol>&#13;
				<li>In the generated IR, we need to call the <strong class="source-inline">__cxa_begin_catch()</strong> and <strong class="source-inline">__cxa_end_catch()</strong> functions from the C++ runtime library. To print the error message, we will generate a call to the <strong class="source-inline">puts()</strong> function from the C runtime library. Furthermore, to get the type information from the exception, we must generate a call to the <strong class="source-inline">llvm.eh.typeid.for</strong> intrinsic. We also need the <strong class="source-inline">FunctionType</strong> and <strong class="source-inline">Function</strong> instances for all of them; we will take advantage of our <strong class="source-inline">createFunc()</strong> method to <span class="No-Break">create them:</span><pre class="source-code">&#13;
  void addLandingPad() {&#13;
    FunctionType *TypeIdFty; Function *TypeIdFn;&#13;
    createFunc(TypeIdFty, TypeIdFn,&#13;
               "llvm.eh.typeid.for", Int32Ty,&#13;
               {Int8PtrTy});&#13;
    FunctionType *BeginCatchFty; Function *BeginCatchFn;&#13;
    createFunc(BeginCatchFty, BeginCatchFn,&#13;
               "__cxa_begin_catch", Int8PtrTy,&#13;
               {Int8PtrTy});&#13;
    FunctionType *EndCatchFty; Function *EndCatchFn;&#13;
    createFunc(EndCatchFty, EndCatchFn,&#13;
               "__cxa_end_catch", VoidTy);&#13;
    FunctionType *PutsFty; Function *PutsFn;&#13;
    createFunc(PutsFty, PutsFn, "puts", Int32Ty,&#13;
               {Int8PtrTy});</pre></li>				<li>The <strong class="source-inline">landingpad</strong> instruction is the first instruction we generate. The result type is a structure containing fields of an <strong class="source-inline">i8</strong> pointer and an <strong class="source-inline">i32</strong> type. This structure is generated with a call to the <strong class="source-inline">StructType::get()</strong> function. Moreover, since we need to handle an exception of a C++ <strong class="source-inline">int</strong> type, we need to also add this <a id="_idIndexMarker351"/>as a clause to the <strong class="source-inline">landingpad</strong> instruction, which must be a constant of an <strong class="source-inline">i8</strong> pointer type. This means that generating a <strong class="source-inline">bitcast</strong> instruction is required to convert the <strong class="source-inline">TypeInfo</strong> value into this type. After, we must store the value that’s returned from the instruction for later use in the <span class="No-Break"><strong class="source-inline">Exc</strong></span><span class="No-Break"> variable:</span><pre class="source-code">&#13;
    LandingPadInst *Exc = Builder.CreateLandingPad(&#13;
        StructType::get(Int8PtrTy, Int32Ty), 1, "exc");&#13;
    Exc-&gt;addClause(&#13;
        ConstantExpr::getBitCast(TypeInfo, Int8PtrTy));</pre></li>				<li>Next, we extract the type selector from the returned value. With a call to the <strong class="source-inline">llvm.eh.typeid.for</strong> intrinsic, we retrieve the type ID for the <strong class="source-inline">TypeInfo</strong> field, representing the C++ <strong class="source-inline">int</strong> type. With this IR, we have generated the two values we need to compare to decide if we can handle <span class="No-Break">the exception:</span><pre class="source-code">&#13;
    Value *Sel =&#13;
        Builder.CreateExtractValue(Exc, {1}, "exc.sel");&#13;
    CallInst *Id =&#13;
        Builder.CreateCall(TypeIdFty, TypeIdFn,&#13;
                           {ConstantExpr::getBitCast(&#13;
                               TypeInfo, Int8PtrTy)});</pre></li>				<li>To generate the IR for the comparison, we must call our <strong class="source-inline">createICmpEq()</strong> function. This function also generates two basic blocks, which we store in the <strong class="source-inline">TrueDest</strong> and <span class="No-Break"><strong class="source-inline">FalseDest</strong></span><span class="No-Break"> variables:</span><pre class="source-code">&#13;
    BasicBlock *TrueDest, *FalseDest;&#13;
    createICmpEq(Sel, Id, TrueDest, FalseDest, "match",&#13;
                 "resume");</pre></li>				<li>If the two <a id="_idIndexMarker352"/>values do not match, the control flow continues at the <strong class="source-inline">FalseDest</strong> basic block. This basic block only contains a <strong class="source-inline">resume</strong> instruction, to give control back to the <span class="No-Break">C++ runtime:</span><pre class="source-code">&#13;
    Builder.SetInsertPoint(FalseDest);&#13;
    Builder.CreateResume(Exc);</pre></li>				<li>If the two values are equal, the control flow continues at the <strong class="source-inline">TrueDest</strong> basic block. First, we generate the IR code to extract the pointer to the exception from the return value of the <strong class="source-inline">landingpad</strong> instruction, stored in the <strong class="source-inline">Exc</strong> variable. Then, we generate a call to the <strong class="source-inline">__cxa_begin_catch ()</strong> function, passing the pointer to the exception as a parameter. This indicates the beginning of handling the exception for <span class="No-Break">the runtime:</span><pre class="source-code">&#13;
    Builder.SetInsertPoint(TrueDest);&#13;
    Value *Ptr =&#13;
        Builder.CreateExtractValue(Exc, {0}, "exc.ptr");&#13;
    Builder.CreateCall(BeginCatchFty, BeginCatchFn,&#13;
                       {Ptr});</pre></li>				<li>The exception is then handled by calling the <strong class="source-inline">puts()</strong> function to print a message to the console. For this, we generate a pointer to the string with a call to the <strong class="source-inline">CreateGlobalStringPtr()</strong> function, and then pass this pointer as a parameter in the generated call to the <span class="No-Break"><strong class="source-inline">puts()</strong></span><span class="No-Break"> function:</span><pre class="source-code">&#13;
    Value *MsgPtr = Builder.CreateGlobalStringPtr(&#13;
        "Divide by zero!", "msg", 0, M);&#13;
    Builder.CreateCall(PutsFty, PutsFn, {MsgPtr});</pre></li>				<li>Now that <a id="_idIndexMarker353"/>we’ve handled the exception, we must generate a call to the <strong class="source-inline">__cxa_end_catch()</strong> function to inform the runtime about it. Finally, we return from the function with a <span class="No-Break"><strong class="source-inline">ret</strong></span><span class="No-Break"> instruction:</span><pre class="source-code">&#13;
    Builder.CreateCall(EndCatchFty, EndCatchFn);&#13;
    Builder.CreateRet(Int32Zero);&#13;
  }</pre></li>			</ol>&#13;
			<p>With the <strong class="source-inline">addThrow()</strong> and <strong class="source-inline">addLandingPad()</strong> functions, we can generate the IR to raise an exception and handle an exception. However, we still need to add the IR to check if the divisor is <strong class="source-inline">0</strong>. We’ll cover this in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/>Integrating the exception handling code into the application</h2>&#13;
			<p>The IR <a id="_idIndexMarker354"/>for the division is generated inside the <strong class="source-inline">visit(BinaryOp &amp;)</strong> method. Instead of just generating a <strong class="source-inline">sdiv</strong> instruction, we must generate an IR to compare the divisor with <strong class="source-inline">0</strong>. If the divisor is 0, then the control flow continues in a basic block, raising the exception. Otherwise, the control flow continues in a basic block with the <strong class="source-inline">sdiv</strong> instruction. With the help of the <strong class="source-inline">createICmpEq()</strong> and <strong class="source-inline">addThrow()</strong> functions, we can code this <span class="No-Break">very easily:</span></p>&#13;
			<pre class="source-code">&#13;
    case BinaryOp::Div:&#13;
      BasicBlock *TrueDest, *FalseDest;&#13;
      createICmpEq(Right, Int32Zero, TrueDest,&#13;
                   FalseDest, "divbyzero", "notzero");&#13;
      Builder.SetInsertPoint(TrueDest);&#13;
      addThrow(42); // Arbitrary payload value.&#13;
      Builder.SetInsertPoint(FalseDest);&#13;
      V = Builder.CreateSDiv(Left, Right);&#13;
      break;</pre>			<p>The code generation part is now complete. To build the application, we must change into the build directory and run the <span class="No-Break"><strong class="source-inline">ninja</strong></span><span class="No-Break"> tool:</span></p>&#13;
			<pre class="console">&#13;
$ ninja</pre>			<p>Once the build has finished, you can check the generated IR with the <strong class="source-inline">with a: </strong><span class="No-Break"><strong class="source-inline">3/a</strong></span><span class="No-Break"> expression:</span></p>&#13;
			<pre class="console">&#13;
$ src/calc "with a: 3/a"</pre>			<p>You will <a id="_idIndexMarker355"/>see the additional IR needed to raise and catch <span class="No-Break">the exception.</span></p>&#13;
			<p>The generated IR now depends on the C++ runtime. The easiest way to link against the required libraries is to use the <strong class="source-inline">clang++</strong> compiler. Rename the <strong class="source-inline">rtcalc.c</strong> file with the runtime functions for the expression calculator to <strong class="source-inline">rtcalc.cpp</strong>, and add <strong class="source-inline">extern "C"</strong> in front of each function inside the file. Then, use the <strong class="source-inline">llc</strong> tool to turn the generated IR into an object file, and the <strong class="source-inline">clang++</strong> compiler to create <span class="No-Break">an executable:</span></p>&#13;
			<pre class="console">&#13;
$ src/calc "with a: 3/a" | llc -filetype obj -o exp.o&#13;
$ clang++ -o exp exp.o ../rtcalc.cpp</pre>			<p>Now, we can run the generated application with <span class="No-Break">different values:</span></p>&#13;
			<pre class="console">&#13;
$ ./exp&#13;
Enter a value for a: 1&#13;
The result is: 3&#13;
$ ./exp&#13;
Enter a value for a: 0&#13;
Divide by zero!</pre>			<p>In the second run, the input is <strong class="source-inline">0</strong>, and this raises the exception. It works <span class="No-Break">as expected!</span></p>&#13;
			<p>In this section, we learned how to raise and catch exceptions. The code to generate the IR can be used as a blueprint for other compilers. Of course, the type information that’s used and the number of catch clauses depends on the input to the compiler, but the IR we need to generate still follows the pattern presented in <span class="No-Break">this section.</span></p>&#13;
			<p>Adding metadata is another way to provide further information to LLVM. In the next section, we’ll add type metadata to support the LLVM optimizer in <span class="No-Break">certain situations.</span></p>&#13;
			<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/>Generating metadata for type-based alias analysis</h1>&#13;
			<p>Two pointers may point to the same memory cell, at which point they alias each other. Memory <a id="_idIndexMarker356"/>is not typed in the LLVM model, which makes it difficult for the optimizer to decide if two pointers alias each other or not. If the compiler can prove that two pointers do not alias each other, then more optimizations are possible. In the next section, we will have a closer look at the problem and investigate how adding additional metadata will help before we implement <span class="No-Break">this approach.</span></p>&#13;
			<h2 id="_idParaDest-106"><a id="_idTextAnchor108"/>Understanding the need for additional metadata</h2>&#13;
			<p>To demonstrate the problem, let’s look at the <span class="No-Break">following function:</span></p>&#13;
			<pre class="source-code">&#13;
void doSomething(int *p, float *q) {&#13;
  *p = 42;&#13;
  *q = 3.1425;&#13;
}</pre>			<p>The optimizer <a id="_idIndexMarker357"/>cannot decide if the pointers, <strong class="source-inline">p</strong> and <strong class="source-inline">q</strong>, point to the same <a id="_idIndexMarker358"/>memory cell or not. During optimization, an important analysis can be performed called <strong class="bold">alias analysis</strong>. If <strong class="source-inline">p</strong> and <strong class="source-inline">q</strong> point to the same memory cell, then they are aliases. Moreover, if the optimizer can prove that both pointers never alias each other, this enables additional optimization opportunities. For example, in the <strong class="source-inline">doSomething()</strong> function, the stores can be reordered without altering the result in <span class="No-Break">this case.</span></p>&#13;
			<p>In addition, it depends on the definition of the source language if a variable of one type can be an alias of another variable of a different type. Please note that languages may also contain expressions that break the type-based alias assumption – for example, type casts between <span class="No-Break">unrelated types.</span></p>&#13;
			<p>The solution chosen by the LLVM developers is to add metadata to the <strong class="source-inline">load</strong> and <strong class="source-inline">store</strong> instructions. The added metadata serves <span class="No-Break">two purposes:</span></p>&#13;
			<ul>&#13;
				<li>First, it defines the type hierarchy based on which type may alias <span class="No-Break">another type</span></li>&#13;
				<li>Second, it describes the memory access in a <strong class="source-inline">load</strong> or <span class="No-Break"><strong class="source-inline">store</strong></span><span class="No-Break"> instruction</span></li>&#13;
			</ul>&#13;
			<p>Let’s have a look at the type hierarchy in C. Each type of hierarchy starts with a root node, either <strong class="bold">named</strong> or <strong class="bold">anonymous</strong>. LLVM assumes that root nodes with the same name describe the same type of hierarchy. You can use different type hierarchies in the same LLVM modules, and LLVM makes the safe assumption that these types may alias. Beneath the root node, there are the nodes for scalar types. Nodes for aggregate types are not attached <a id="_idIndexMarker359"/>to the root node, but they refer to scalar types and other aggregate types. Clang defines the hierarchy for C <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li>The root node is called <strong class="source-inline">Simple </strong><span class="No-Break"><strong class="source-inline">C/C++ TBAA</strong></span><span class="No-Break">.</span></li>&#13;
				<li>Beneath the root node is the node for the <strong class="source-inline">char</strong> types. This is a special type in C because all pointers can be converted into a pointer <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">char</strong></span><span class="No-Break">.</span></li>&#13;
				<li>Beneath the <strong class="source-inline">char</strong> node are the nodes for the other scalar types and a type for all pointers, called <span class="No-Break"><strong class="source-inline">any pointer</strong></span><span class="No-Break">.</span></li>&#13;
			</ul>&#13;
			<p>In addition to this, aggregate types are defined as a sequence of member types <span class="No-Break">and offsets.</span></p>&#13;
			<p>These metadata definitions are used in access tags attached to the <strong class="source-inline">load</strong> and <strong class="source-inline">store</strong> instructions. An access tag is made up of three parts: a base type, an access type, and an offset. Depending on the base type, there are two possible ways the access tag describes <span class="No-Break">memory access:</span></p>&#13;
			<ol>&#13;
				<li>If the base type is an aggregate type, then the access tag describes the memory access of a <strong class="source-inline">struct</strong> member with the necessary access type and is located at the <span class="No-Break">given offset.</span></li>&#13;
				<li>If the base type is a scalar type, then the access type must be the same as the base type and the offset must <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>&#13;
			</ol>&#13;
			<p>With these definitions, we can now define a relation on the access tags, which is used to evaluate if two pointers may alias each other or not. Let’s take a closer look at the options for the immediate parent of a <strong class="source-inline">(base type, </strong><span class="No-Break"><strong class="source-inline">offset)</strong></span><span class="No-Break"> tuple:</span></p>&#13;
			<ol>&#13;
				<li>If the base type is a scalar type and the offset is 0, then the immediate parent is <strong class="source-inline">(parent type, 0)</strong>, with the parent type being the type of the parent node, as defined in the type hierarchy. If the offset is not 0, then the immediate parent <span class="No-Break">is undefined.</span></li>&#13;
				<li>If the base type is an aggregate type, then the immediate parent of the <strong class="source-inline">(base type, offset)</strong> tuple is the <strong class="source-inline">(new type, new offset)</strong> tuple, with the new type being the type of the member at offset. The new offset is the offset of the new type, adjusted to its <span class="No-Break">new start.</span></li>&#13;
			</ol>&#13;
			<p>The transitive <a id="_idIndexMarker360"/>closure of this relation is the parent relation. Two memory accesses, (base type 1, access type 1, offset 1) and (base type 2, access type 2, offset 2), may alias one another if (base type 1, offset 1) and (base type 2, offset 2) or vice versa are related in the <span class="No-Break">parent relation.</span></p>&#13;
			<p>Let’s illustrate this with <span class="No-Break">an example:</span></p>&#13;
			<pre class="source-code">&#13;
struct Point { float x, y; }&#13;
void func(struct Point *p, float *x, int *i, char *c) {&#13;
  p-&gt;x = 0; p-&gt;y = 0; *x = 0.0; *i = 0; *c = 0;&#13;
}</pre>			<p>When using the memory access tag definition for scalar types, the access tag for the <strong class="source-inline">i</strong> parameter is (<strong class="source-inline">int</strong>, <strong class="source-inline">int</strong>, 0), while for the <strong class="source-inline">c</strong> parameter, it is (<strong class="source-inline">char</strong>, <strong class="source-inline">char</strong>, 0). In the type hierarchy, the parent of the node for the <strong class="source-inline">int</strong> type is the <strong class="source-inline">char</strong> node. Therefore, the immediate parent of (<strong class="source-inline">int</strong>, 0) is (<strong class="source-inline">char</strong>, 0) and both pointers can alias. The same is true for the <strong class="source-inline">x</strong> and <strong class="source-inline">c</strong> parameters. However, the <strong class="source-inline">x</strong> and <strong class="source-inline">i</strong> parameters are not related, so they do not alias each other. The access for the <strong class="source-inline">y</strong> member of <strong class="source-inline">struct Point</strong> is (<strong class="source-inline">Point</strong>, <strong class="source-inline">float</strong>, 4), with 4 being the offset of the <strong class="source-inline">y</strong> member in the struct. The immediate parent of (<strong class="source-inline">Point</strong>, 4) is (<strong class="source-inline">float</strong>, 0), so the access to <strong class="source-inline">p-&gt;y</strong> and <strong class="source-inline">x</strong> may alias, and with the same reasoning also with the <span class="No-Break"><strong class="source-inline">c</strong></span><span class="No-Break"> parameter.</span></p>&#13;
			<h2 id="_idParaDest-107"><a id="_idTextAnchor109"/>Creating TBAA metadata in LLVM</h2>&#13;
			<p>To create <a id="_idIndexMarker361"/>the metadata, we must use the <strong class="source-inline">llvm::MDBuilder</strong> class, which is declared in the <strong class="source-inline">llvm/IR/MDBuilder.h</strong> header file. The data itself is stored in instances of the <strong class="source-inline">llvm::MDNode</strong> and <strong class="source-inline">llvm::MDString</strong> classes. Using the builder class shields us from the internal details of <span class="No-Break">the construction.</span></p>&#13;
			<p>A root node is created with a call to the <strong class="source-inline">createTBAARoot()</strong> method, which expects the name of the type hierarchy as a parameter and returns the root node. An anonymous, unique root node can be created with the <span class="No-Break"><strong class="source-inline">createAnonymousTBAARoot()</strong></span><span class="No-Break"> method.</span></p>&#13;
			<p>A scalar <a id="_idIndexMarker362"/>type is added to the hierarchy with the <strong class="source-inline">createTBAAScalarTypeNode()</strong> method, which takes the name of the type and the parent node as <span class="No-Break">a parameter.</span></p>&#13;
			<p>On the other hand, adding a type node for an aggregate type is slightly more complex. The <strong class="source-inline">createTBAAStructTypeNode()</strong> method takes the name of the type and a list of the fields as parameters. Specifically, the fields are given as a <strong class="source-inline">std::pair&lt;llvm::MDNode*, uint64_t&gt;</strong> instance, where the first element indicates the type of the member and the second element represents the offset <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">struct</strong></span><span class="No-Break">.</span></p>&#13;
			<p>An access tag is created with the <strong class="source-inline">createTBAAStructTagNode()</strong> method, which takes the base type, the access type, and the offset <span class="No-Break">as parameters.</span></p>&#13;
			<p>Lastly, the metadata must be attached to a <strong class="source-inline">load</strong> or <strong class="source-inline">store</strong> instruction. The <strong class="source-inline">llvm::Instruction</strong> class contains a method called <strong class="source-inline">setMetadata()</strong>, which is used to add various type-based alias analysis metadata. The first parameter must be of the <strong class="source-inline">llvm::LLVMContext::MD_tbaa</strong> type and the second must be the <span class="No-Break">access tag.</span></p>&#13;
			<p>Equipped <a id="_idIndexMarker363"/>with this knowledge, we must add metadata for <strong class="bold">type-based alias analysis</strong> (<strong class="bold">TBAA</strong>) <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">tinylang</strong></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-108"><a id="_idTextAnchor110"/>Adding TBAA metadata to tinylang</h2>&#13;
			<p>To support TBAA, we must add a new <strong class="source-inline">CGTBAA</strong> class. This class is responsible for generating <a id="_idIndexMarker364"/>the metadata nodes. Furthermore, we make the <strong class="source-inline">CGTBAA</strong> class a member of the <strong class="source-inline">CGModule</strong> class, calling <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">TBAA</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Every load and store instruction must be annotated. A new function is created for this purpose in the <strong class="source-inline">CGModule</strong> class called <strong class="source-inline">decorateInst()</strong>. This function tries to create the tag access information. If this is successful, the metadata is attached to the respective load or store instruction. Moreover, this design also allows us to turn off the metadata generation process in case we do not need it, such as in builds with optimizations <span class="No-Break">turned off:</span></p>&#13;
			<pre class="source-code">&#13;
void CGModule::decorateInst(llvm::Instruction *Inst,&#13;
                            TypeDeclaration *Type) {&#13;
  if (auto *N = TBAA.getAccessTagInfo(Type))&#13;
    Inst-&gt;setMetadata(llvm::LLVMContext::MD_tbaa, N);&#13;
}</pre>			<p>We <a id="_idIndexMarker365"/>put the declaration of the new <strong class="source-inline">CGTBAA</strong> class in the <strong class="source-inline">include/tinylang/CodeGen/CGTBAA.h</strong> header file and the definition in the <strong class="source-inline">lib/CodeGen/CGTBAA.cpp</strong> file. Aside from the AST definitions, the header file needs to include the files for defining the metadata nodes <span class="No-Break">and builder:</span></p>&#13;
			<pre class="source-code">&#13;
#include "tinylang/AST/AST.h"&#13;
#include "llvm/IR/MDBuilder.h"&#13;
#include "llvm/IR/Metadata.h"</pre>			<p>The <strong class="source-inline">CGTBAA</strong> class needs to store some data members. So, let’s see how to do this step <span class="No-Break">by step:</span></p>&#13;
			<ol>&#13;
				<li>First of all, we need to cache the root of the <span class="No-Break">type hierarchy:</span><pre class="source-code">&#13;
 class CGTBAA {&#13;
  llvm::MDNode *Root;</pre></li>				<li>To construct the metadata nodes, we need an instance of the <span class="No-Break"><strong class="source-inline">MDBuilder</strong></span><span class="No-Break"> class:</span><pre class="source-code">&#13;
  llvm::MDBuilder MDHelper;</pre></li>				<li>Lastly, we must store the metadata that’s been generated for a type <span class="No-Break">for reuse:</span><pre class="source-code">&#13;
  llvm::DenseMap&lt;TypeDenoter *, llvm::MDNode *&gt; MetadataCache;&#13;
// …&#13;
};</pre></li>			</ol>&#13;
			<p>Now that we’ve defined the variables that are required for the construction, we must add the methods that are required to create <span class="No-Break">the metadata:</span></p>&#13;
			<ol>&#13;
				<li>The constructor initializes the <span class="No-Break">data members:</span><pre class="source-code">&#13;
CGTBAA::CGTBAA(CGModule &amp;CGM)&#13;
      : CGM(CGM),&#13;
        MDHelper(llvm::MDBuilder(CGM.getLLVMCtx())),&#13;
        Root(nullptr) {}</pre></li>				<li>We <a id="_idIndexMarker366"/>must lazily instantiate the root of the type hierarchy, which we name <strong class="source-inline">Simple </strong><span class="No-Break"><strong class="source-inline">tinylang TBAA</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
llvm::MDNode *CGTBAA::getRoot() {&#13;
  if (!Root)&#13;
    Root = MDHelper.createTBAARoot("Simple tinylang TBAA");&#13;
  return Root;&#13;
}</pre></li>				<li>For a scalar type, we must create a metadata node with the help of the <strong class="source-inline">MDBuilder</strong> class based on the name of the type. The new metadata node is stored in <span class="No-Break">the cache:</span><pre class="source-code">&#13;
llvm::MDNode *&#13;
CGTBAA::createScalarTypeNode(TypeDeclaration *Ty,&#13;
                             StringRef Name,&#13;
                             llvm::MDNode *Parent) {&#13;
  llvm::MDNode *N =&#13;
      MDHelper.createTBAAScalarTypeNode(Name, Parent);&#13;
  return MetadataCache[Ty] = N;&#13;
}</pre></li>				<li>The method to create the metadata for a record is more complicated as we have <a id="_idIndexMarker367"/>to enumerate all the fields of the record. Similar to scalar types, the new metadata node is stored in <span class="No-Break">the cache:</span><pre class="source-code">&#13;
llvm::MDNode *CGTBAA::createStructTypeNode(&#13;
    TypeDeclaration *Ty, StringRef Name,&#13;
    llvm::ArrayRef&lt;std::pair&lt;llvm::MDNode *, uint64_t&gt;&gt;&#13;
        Fields) {&#13;
  llvm::MDNode *N =&#13;
      MDHelper.createTBAAStructTypeNode(Name, Fields);&#13;
  return MetadataCache[Ty] = N;&#13;
}</pre></li>				<li>To return the metadata for a <strong class="source-inline">tinylang</strong> type, we need to create the type hierarchy. Due to the type system of <strong class="source-inline">tinylang</strong> being very restricted, we can use a simple approach. Each scalar type is mapped to a unique type attached to the root node, and we map all pointers to a single type. Structured types then refer to these nodes. If we cannot map a type, then we <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">nullptr</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
llvm::MDNode *CGTBAA::getTypeInfo(TypeDeclaration *Ty) {&#13;
  if (llvm::MDNode *N = MetadataCache[Ty])&#13;
    return N;&#13;
  if (auto *Pervasive =&#13;
          llvm::dyn_cast&lt;PervasiveTypeDeclaration&gt;(Ty)) {&#13;
    StringRef Name = Pervasive-&gt;getName();&#13;
    return createScalarTypeNode(Pervasive, Name, getRoot());&#13;
  }&#13;
  if (auto *Pointer =&#13;
          llvm::dyn_cast&lt;PointerTypeDeclaration&gt;(Ty)) {&#13;
    StringRef Name = "any pointer";&#13;
    return createScalarTypeNode(Pointer, Name, getRoot());&#13;
  }&#13;
  if (auto *Array =&#13;
         llvm::dyn_cast&lt;ArrayTypeDeclaration&gt;(Ty)) {&#13;
    StringRef Name = Array-&gt;getType()-&gt;getName();&#13;
    return createScalarTypeNode(Array, Name, getRoot());&#13;
  }&#13;
  if (auto *Record =&#13;
          llvm::dyn_cast&lt;RecordTypeDeclaration&gt;(Ty)) {&#13;
    llvm::SmallVector&lt;std::pair&lt;llvm::MDNode *, uint64_t&gt;,     4&gt; Fields;&#13;
    auto *Rec =&#13;
        llvm::cast&lt;llvm::StructType&gt;(CGM.convertType(Record));&#13;
    const llvm::StructLayout *Layout =&#13;
        CGM.getModule()-&gt;getDataLayout().getStructLayout(Rec);&#13;
    unsigned Idx = 0;&#13;
    for (const auto &amp;F : Record-&gt;getFields()) {&#13;
      uint64_t Offset = Layout-&gt;getElementOffset(Idx);&#13;
      Fields.emplace_back(getTypeInfo(F.getType()), Offset);&#13;
      ++Idx;&#13;
    }&#13;
    StringRef Name = CGM.mangleName(Record);&#13;
    return createStructTypeNode(Record, Name, Fields);&#13;
  }&#13;
  return nullptr;&#13;
}</pre></li>				<li>The general method to get the metadata is <strong class="source-inline">getAccessTagInfo()</strong>. To get the <a id="_idIndexMarker368"/>TBAA access tag information, a call to the <strong class="source-inline">getTypeInfo()</strong> function must be added. This function expects <strong class="source-inline">TypeDeclaration</strong> as its parameter, which is retrieved from the instructions we want to produce <span class="No-Break">metadata for:</span><pre class="source-code">&#13;
llvm::MDNode *CGTBAA::getAccessTagInfo(TypeDeclaration *Ty) {&#13;
    return getTypeInfo(Ty);&#13;
}</pre></li>			</ol>&#13;
			<p>Finally, to enable the generation of TBAA metadata, we simply need to attach the metadata to all of the load and store instructions that we generate <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">tinylang</strong></span><span class="No-Break">.</span></p>&#13;
			<p>For example, in <strong class="source-inline">CGProcedure::writeVariable()</strong>, a store to a global variable uses a <span class="No-Break">store instruction:</span></p>&#13;
			<pre class="source-code">&#13;
      Builder.CreateStore(Val, CGM.getGlobal(D));</pre>			<p>To decorate <a id="_idIndexMarker369"/>this particular instruction, we need to replace this line with the following lines, where <strong class="source-inline">decorateInst()</strong> adds the TBAA metadata to this <span class="No-Break">store instruction:</span></p>&#13;
			<pre class="source-code">&#13;
      auto *Inst = Builder.CreateStore(Val, CGM.getGlobal(D));&#13;
      // NOTE: V is of the VariableDeclaration class, and&#13;
      // the getType() method in this class retrieves the&#13;
      // TypeDeclaration that is needed for decorateInst().&#13;
      CGM.decorateInst(Inst, V-&gt;getType());</pre>			<p>With these changes in place, we have finished generating the <span class="No-Break">TBAA metadata.</span></p>&#13;
			<p>We can now compile a sample <strong class="source-inline">tinylang</strong> file into an LLVM intermediate representation to see our newly implemented TBAA metadata. For instance, consider the following <span class="No-Break">file, </span><span class="No-Break"><strong class="source-inline">Person.mod</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="console">&#13;
MODULE Person;&#13;
TYPE&#13;
  Person = RECORD&#13;
             Height: INTEGER;&#13;
             Age: INTEGER&#13;
           END;&#13;
PROCEDURE Set(VAR p: Person);&#13;
BEGIN&#13;
  p.Age := 18;&#13;
END Set;&#13;
END Person.</pre>			<p>The <strong class="source-inline">tinylang</strong> compiler that is built in the build directory of this chapter can be used to generate the intermediate representation for <span class="No-Break">this file:</span></p>&#13;
			<pre class="console">&#13;
$ tools/driver/tinylang -emit-llvm ../examples/Person.mod</pre>			<p>In the <a id="_idIndexMarker370"/>newly generated <strong class="source-inline">Person.ll</strong> file, we can see that the store instruction is decorated with the TBAA metadata that we have generated within this chapter, where the metadata reflects the fields of the record type that was <span class="No-Break">originally declared:</span></p>&#13;
			<pre class="console">&#13;
; ModuleID = '../examples/Person.mod'&#13;
source_filename = "../examples/Person.mod"&#13;
target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"&#13;
target triple = "arm64-apple-darwin22.6.0"&#13;
define void @_t6Person3Set(ptr nocapture dereferenceable(16) %p) {&#13;
entry:&#13;
  %0 = getelementptr inbounds ptr, ptr %p, i32 0, i32 1&#13;
  store i64 18, ptr %0, align 8, !tbaa !0&#13;
  ret void&#13;
}&#13;
!0 = !{!"_t6Person6Person", !1, i64 0, !1, i64 8}&#13;
!1 = !{!"INTEGER", !2, i64 0}&#13;
!2 = !{!"Simple tinylang TBAA"}</pre>			<p>Now that we have learned how to generate TBAA metadata, we will explore a very similar topic in the next section: generating <span class="No-Break">debug metadata.</span></p>&#13;
			<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/>Adding debug metadata</h1>&#13;
			<p>To allow source-level debugging, we have to add debug information. Support for debug information in <a id="_idIndexMarker371"/>LLVM uses debug metadata to describe the types of the source language and other static information, and intrinsics to track variable values. The LLVM core libraries generate debug information in the <em class="italic">DWARF format on Unix systems</em> and in <em class="italic">PDB format for Windows</em>. We’ll look at the general structure in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>Understanding the general structure of debug metadata</h2>&#13;
			<p>To describe the general structure, LLVM uses metadata similar to the metadata for type-based analysis. The static <a id="_idIndexMarker372"/>structure describes the file, the compilation unit, functions and lexical blocks, and the used <span class="No-Break">data types.</span></p>&#13;
			<p>The main class we use is <strong class="source-inline">llvm::DIBuilder</strong>, and we need to use the <strong class="source-inline">llvm/IR/DIBuilder</strong> header file to get the class declaration. This builder class provides an easy-to-use interface to create the debug metadata. Later, the metadata is either added to LLVM objects such as global variables, or is used in calls to debug intrinsics. Here’s some important metadata that the builder class <span class="No-Break">can create:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">llvm::DIFile</strong>: This describes a file using the filename and the absolute path of the directory containing the file. You use the <strong class="source-inline">createFile()</strong> method to create it. A file can contain the main compilation unit or it could contain <span class="No-Break">imported declarations.</span></li>&#13;
				<li><strong class="source-inline">llvm::DICompileUnit</strong>: This is used to describe the current compilation unit. Among other things, you specify the source language, a compiler-specific producer string, whether optimizations are enabled or not, and, of course, <strong class="source-inline">DIFile</strong>, in which the compilation unit resides. You create it with a call <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">createCompileUnit()</strong></span><span class="No-Break">.</span></li>&#13;
				<li><strong class="source-inline">llvm::DISubprogram</strong>: This describes a function. The most important information here is the scope (usually <strong class="source-inline">DICompileUnit</strong> or <strong class="source-inline">DISubprogram</strong> for a nested function), the name of the function, the mangled name of the function, and the function type. It is created with a call <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">createFunction()</strong></span><span class="No-Break">.</span></li>&#13;
				<li><strong class="source-inline">llvm::DILexicalBlock</strong>: This describes a lexical block and models the block scoping found in many high-level languages. You can create this with a call <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">createLexicalBlock()</strong></span><span class="No-Break">.</span></li>&#13;
			</ul>&#13;
			<p>LLVM makes no assumptions about the language your compiler translates. As a consequence, it has <a id="_idIndexMarker373"/>no information about the data types of the language. To support source-level debugging, especially displaying variable values in a debugger, type information must be added too. Here are some <span class="No-Break">important constructs:</span></p>&#13;
			<ul>&#13;
				<li>The <strong class="source-inline">createBasicType()</strong> function, which returns a pointer to the <strong class="source-inline">llvm::DIBasicType</strong> class, creates the metadata to describe a basic type such as <strong class="source-inline">INTEGER</strong> in <strong class="source-inline">tinylang</strong> or <strong class="source-inline">int</strong> in C++. Besides the name of the type, the required parameters are the size in bits and the encoding – for example, if it is a signed or <span class="No-Break">unsigned type.</span></li>&#13;
				<li>There are several ways to construct the metadata for composite data types, as represented by the <strong class="source-inline">llvm::DIComposite</strong> class. You can use the <strong class="source-inline">createArrayType()</strong>, <strong class="source-inline">createStructType()</strong>, <strong class="source-inline">createUnionType()</strong>, and <strong class="source-inline">createVectorType()</strong> functions to instantiate the metadata for array, struct, union, and vector data types, respectively. These functions require the parameter you expect, such as the base type and the number of subscriptions for an array type or a list of the field members of a <span class="No-Break">struct type.</span></li>&#13;
				<li>There are also methods to support enumerations, templates, classes, and <span class="No-Break">so on.</span></li>&#13;
			</ul>&#13;
			<p>The list of functions shows you that you have to add every detail of the source language to the debug information. Let’s assume your instance of the <strong class="source-inline">llvm::DIBuilder</strong> class is called <strong class="source-inline">DBuilder</strong>. Let’s also assume that you have some <strong class="source-inline">tinylang</strong> source in a file called <strong class="source-inline">File.mod</strong> in the <strong class="source-inline">/home/llvmuser</strong> folder. Inside this file is the <strong class="source-inline">Func():INTEGER</strong> function at <em class="italic">line 5</em>, which contains a local <strong class="source-inline">VAR i:INTEGER</strong> declaration at <em class="italic">line 7</em>. Let’s create the metadata for this, beginning with the information for the file. You need to specify the filename and the absolute path of the folder in which the <span class="No-Break">file resides:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::DIFile *DbgFile = DBuilder.createFile("File.mod",&#13;
                                            "/home/llvmuser");</pre>			<p>The file is <a id="_idIndexMarker374"/>a module in <strong class="source-inline">tinylang</strong>, which makes it the compilation unit for LLVM. This carries a lot <span class="No-Break">of information:</span></p>&#13;
			<pre class="source-code">&#13;
bool IsOptimized = false;&#13;
llvm::StringRef CUFlags;&#13;
unsigned ObjCRunTimeVersion = 0;&#13;
llvm::StringRef SplitName;&#13;
llvm::DICompileUnit::DebugEmissionKind EmissionKind =&#13;
      llvm::DICompileUnit::DebugEmissionKind::FullDebug;&#13;
llvm::DICompileUnit *DbgCU = DBuilder.createCompileUnit(&#13;
      llvm::dwarf::DW_LANG_Modula2, DbgFile, „tinylang",&#13;
      IsOptimized, CUFlags, ObjCRunTimeVersion, SplitName,&#13;
      EmissionKind);</pre>			<p>Furthermore, the debugger needs to know the source language. The DWARF standard defines an enumeration with all the common values. One disadvantage of this is that you cannot simply add a new source language. To do that, you have to create a request at the DWARF committee. Be aware that the debugger and other debug tools also need support for a new language – just adding a new member to the enumeration is <span class="No-Break">not enough.</span></p>&#13;
			<p>In many cases, it is sufficient to choose a language that is close to your source language. In the case of <strong class="source-inline">tinylang</strong>, this is Modula-2, and we use <strong class="source-inline">DW_LANG_Modula2</strong> as the language identifier. A compilation unit resides in a file, which is identified by the <strong class="source-inline">DbgFile</strong> variable we created previously. Additionally, the debug information can carry information about the producer, which can be the name of the compiler and version information. Here, we just pass the <strong class="source-inline">tinylang</strong> string. If you do not want to add this information, then you can simply use an empty string as <span class="No-Break">a parameter.</span></p>&#13;
			<p>The next set of information includes the <strong class="source-inline">IsOptimized</strong> flag, which should indicate if the compiler has turned optimization on or not. Usually, this flag is derived from the <strong class="source-inline">–O</strong> command-line switch. You can pass additional parameter settings to the debugger with the <strong class="source-inline">CUFlags</strong> parameter. This is not used here, and we pass an empty string. We also do not use Objective-C, so we pass <strong class="source-inline">0</strong> as the Objective-C <span class="No-Break">runtime version.</span></p>&#13;
			<p>Normally, debug information is embedded in the object file we are creating. If we want to write the <a id="_idIndexMarker375"/>debug information into a separate file, then the <strong class="source-inline">SplitName</strong> parameter must contain the name of this file. Otherwise, simply passing an empty string is sufficient. Finally, you can define the level of debug information that should be emitted. The default is full debug information, as indicated by the use of the <strong class="source-inline">FullDebug</strong> enum value, but you can also choose the <strong class="source-inline">LineTablesOnly</strong> value if you want to emit only line numbers, or the <strong class="source-inline">NoDebug</strong> value for no debug information at all. For the latter, it is better to not create debug information in the <span class="No-Break">first place.</span></p>&#13;
			<p>Our minimalistic source only uses the <strong class="source-inline">INTEGER</strong> data type, which is a signed 32-bit value. Creating the metadata for this type <span class="No-Break">is straightforward:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::DIBasicType *DbgIntTy =&#13;
                       DBuilder.createBasicType("INTEGER", 32,&#13;
                                  llvm::dwarf::DW_ATE_signed);</pre>			<p>To create the debug metadata for the function, we have to create a type for the signature first, and then the metadata for the function itself. This is similar to the creation of IR for a function. The signature of the function is an array with all the types of parameters in source order and the return type of the function as the first element at index <strong class="source-inline">0</strong>. Usually, this array is constructed dynamically. In our case, we can also construct the metadata statically. This is useful for internal functions, such as for module initializing. Typically, the parameters of these functions are always known, and the compiler writer can <span class="No-Break">hard-code them:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::Metadata *DbgSigTy = {DbgIntTy};&#13;
llvm::DITypeRefArray DbgParamsTy =&#13;
                      DBuilder.getOrCreateTypeArray(DbgSigTy);&#13;
llvm::DISubroutineType *DbgFuncTy =&#13;
                   DBuilder.createSubroutineType(DbgParamsTy);</pre>			<p>Our function has the <strong class="source-inline">INTEGER</strong> return type and no further parameters, so the <strong class="source-inline">DbgSigTy</strong> array only contains the pointer to the metadata for this type. This static array is turned <a id="_idIndexMarker376"/>into a type array, which is then used to create the type for <span class="No-Break">the function.</span></p>&#13;
			<p>The function itself requires <span class="No-Break">more data:</span></p>&#13;
			<pre class="source-code">&#13;
unsigned LineNo = 5;&#13;
unsigned ScopeLine = 5;&#13;
llvm::DISubprogram *DbgFunc = DBuilder.createFunction(&#13;
      DbgCU, "Func", "_t4File4Func", DbgFile, LineNo,&#13;
      DbgFuncTy, ScopeLine, llvm::DISubprogram::FlagPrivate,&#13;
      llvm::DISubprogram::SPFlagLocalToUnit);</pre>			<p>A function belongs to a compilation unit, which in our case is stored in the <strong class="source-inline">DbgCU</strong> variable. We need to specify the name of the function in the source file, which is <strong class="source-inline">Func</strong>, and the mangled name is stored in the object file. This information helps the debugger locate the machine code of the function. The mangled name, based on the rules of <strong class="source-inline">tinylang</strong>, is <strong class="source-inline">_t4File4Func</strong>. We also have to specify the file that contains <span class="No-Break">the function.</span></p>&#13;
			<p>This may sound surprising at first, but think of the include mechanism in C and C++: a function can be stored in a different file, which is then included with <strong class="source-inline">#include</strong> in the main compilation unit. Here, this is not the case and we use the same file as the one the compilation unit uses. Next, the line number of the function and the function type are passed. The line number of the function may not be the line number where the lexical scope of the function begins. In this case, you can specify a different <strong class="source-inline">ScopeLine</strong>. A function also has protection, which we specify here with the <strong class="source-inline">FlagPrivate</strong> value to indicate a private function. Other possible values for function protection are <strong class="source-inline">FlagPublic</strong> and <strong class="source-inline">FlagProtected</strong>, for public and protected <span class="No-Break">functions, respectively.</span></p>&#13;
			<p>Besides the protection level, other flags can be specified here. For example, <strong class="source-inline">FlagVirtual</strong> indicates a virtual function and <strong class="source-inline">FlagNoReturn</strong> indicates that the function does not return to the caller. You can find the complete list of possible values in the LLVM include file – that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">llvm/include/llvm/IR/DebugInfoFlags.def</strong></span><span class="No-Break">.</span></p>&#13;
			<p>Lastly, flags specific to a function can be specified. The most commonly used flag is the <strong class="source-inline">SPFlagLocalToUnit</strong> value, which indicates that the function is local to this compilation unit. The <strong class="source-inline">MainSubprogram</strong> value is also used often, indicating that this function is <a id="_idIndexMarker377"/>the main function of the application. The LLVM include file mentioned previously also lists all possible values related to flags specific <span class="No-Break">to functions.</span></p>&#13;
			<p>So far, we have only created the metadata referring to static data. Variables are dynamic, so we’ll explore how to attach the static metadata to the IR code for accessing variables in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-111"><a id="_idTextAnchor113"/>Tracking variables and their values</h2>&#13;
			<p>To be useful, the type metadata described in the previous section needs to be associated <a id="_idIndexMarker378"/>with variables of the source program. For a <a id="_idIndexMarker379"/>global variable, this is pretty easy. The <strong class="source-inline">createGlobalVariableExpression()</strong> function of the <strong class="source-inline">llvm::DIBuilder</strong> class creates the metadata to describe a global variable. This includes the name of the variable in the source, the mangled name, the source file, and so on. A global variable in LLVM IR is represented by an instance of the <strong class="source-inline">GlobalVariable</strong> class. This class has a method called <strong class="source-inline">addDebugInfo()</strong>, which associates the metadata node returned from <strong class="source-inline">createGlobalVariableExpression()</strong> with the <span class="No-Break">global variable.</span></p>&#13;
			<p>For local variables, we need to take another approach. LLVM IR does not know of a class representing a local variable as it only knows about values. The solution the LLVM community has <a id="_idIndexMarker380"/>developed is to insert calls to intrinsic functions into the IR code of a function. An <strong class="bold">intrinsic function</strong> is a function that LLVM knows about and, therefore, can do some magic with it. In most cases, intrinsic functions do not result in a subroutine call at the machine level. Here, the function call is a convenient vehicle to associate the metadata with a value. The most important intrinsic functions for debug metadata are <strong class="source-inline">llvm.dbg.declare</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">llvm.dbg.value</strong></span><span class="No-Break">.</span></p>&#13;
			<p>The <strong class="source-inline">llvm.dbg.declare</strong> intrinsic provides information and is generated once by the frontend to declare a local variable. Essentially, this intrinsic describes the address of a local variable. During optimization, passes can replace this intrinsic with (possibly multiple) calls to <strong class="source-inline">llvm.dbg.value</strong> to preserve the debug information and to track the local source variables. After optimization, multiple calls to <strong class="source-inline">llvm.dbg.declare</strong> may be <a id="_idIndexMarker381"/>present as it is used to describe the program points <a id="_idIndexMarker382"/>where the local variables live <span class="No-Break">within memory.</span></p>&#13;
			<p>On the other hand, the <strong class="source-inline">llvm.dbg.value</strong> intrinsic is called whenever a local variable is set to a new value. This intrinsic describes the value of a local variable, not <span class="No-Break">its address.</span></p>&#13;
			<p>How does all of this work? The LLVM IR representation and the programmatic creation via the <strong class="source-inline">llvm::DIBuilder</strong> class differ a bit, so we will look <span class="No-Break">at both.</span></p>&#13;
			<p>Continuing with our example from the previous section, we’ll allocate local storage for the <strong class="source-inline">I</strong> variable inside the <strong class="source-inline">Func</strong> function with the <span class="No-Break"><strong class="source-inline">alloca</strong></span><span class="No-Break"> instruction:</span></p>&#13;
			<pre class="source-code">&#13;
@i = alloca i32</pre>			<p>After that, we must add a call to the <span class="No-Break"><strong class="source-inline">llvm.dbg.declare</strong></span><span class="No-Break"> intrinsic:</span></p>&#13;
			<pre class="source-code">&#13;
call void @llvm.dbg.declare(metadata ptr %i,&#13;
                        metadata !1, metadata !DIExpression())</pre>			<p>The first parameter is the address to the local variable. The second parameter is the metadata describing the local variable, which is created by a call to either <strong class="source-inline">createAutoVariable()</strong> for a local variable or <strong class="source-inline">createParameterVariable()</strong> for a parameter of the <strong class="source-inline">llvm::DIBuilder</strong> class. Finally, the third parameter describes an address expression, which will be <span class="No-Break">explained later.</span></p>&#13;
			<p>Let’s implement the IR creation. You can allocate the storage for the local <strong class="source-inline">@i</strong> variable with a call to the <strong class="source-inline">CreateAlloca()</strong> method of the <span class="No-Break"><strong class="source-inline">llvm::IRBuilder&lt;&gt;</strong></span><span class="No-Break"> class:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::Type *IntTy = llvm::Type::getInt32Ty(LLVMCtx);&#13;
llvm::Value *Val = Builder.CreateAlloca(IntTy, nullptr, "i");</pre>			<p>The <strong class="source-inline">LLVMCtx</strong> variable is the used context class, and <strong class="source-inline">Builder</strong> is the used instance of the <span class="No-Break"><strong class="source-inline">llvm::IRBuilder&lt;&gt;</strong></span><span class="No-Break"> class.</span></p>&#13;
			<p>A local variable also needs to be described <span class="No-Break">by metadata:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::DILocalVariable *DbgLocalVar =&#13;
 Dbuilder.createAutoVariable(DbgFunc, "i", DbgFile,&#13;
                             7, DbgIntTy);</pre>			<p>Using the values <a id="_idIndexMarker383"/>from the previous section, we can specify <a id="_idIndexMarker384"/>that the variable is part of the <strong class="source-inline">DbgFunc</strong> function, is called <strong class="source-inline">i</strong>, is defined in the <strong class="source-inline">DbgFile</strong> file at <em class="italic">line 7</em>, and is of the <span class="No-Break"><strong class="source-inline">DbgIntTy</strong></span><span class="No-Break"> type.</span></p>&#13;
			<p>Finally, we associate the debug metadata with the address of the variable using the <strong class="source-inline">llvm.dbg.declare</strong> intrinsic. Using <strong class="source-inline">llvm::DIBuilder</strong> shields you from all of the details of adding <span class="No-Break">a call:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::DILocation *DbgLoc =&#13;
                llvm::DILocation::get(LLVMCtx, 7, 5, DbgFunc);&#13;
DBuilder.insertDeclare(Val, DbgLocalVar,&#13;
                       DBuilder.createExpression(), DbgLoc,&#13;
                       Val.getParent());</pre>			<p>Again, we have to specify a source location for the variable. An instance of <strong class="source-inline">llvm::DILocation</strong> is a container that holds the line and column of a location associated with a scope. Furthermore, the <strong class="source-inline">insertDeclare()</strong> method adds the call to the intrinsic function of the LLVM IR. In terms of this function’s parameters, it requires the address of the variable, stored in <strong class="source-inline">Val</strong>, and the debug metadata for the variable, stored in <strong class="source-inline">DbgValVar</strong>. We also pass an empty address expression and the debug location we created previously. As with normal instructions, we need to specify into which basic block the call is inserted. If we specify a basic block, then the call is inserted at the end. Alternatively, we can specify an instruction, and the call is inserted before that instruction. We also have the pointer to the <strong class="source-inline">alloca</strong> instruction, which is the last instruction that we inserted into the underlying basic block. Therefore, we can use this basic block, and the call gets appended after the <span class="No-Break"><strong class="source-inline">alloca</strong></span><span class="No-Break"> instruction.</span></p>&#13;
			<p>If the value of a local variable changes, then a call to <strong class="source-inline">llvm.dbg.value</strong> must be added to the IR to set the new value of a local variable. The <strong class="source-inline">insertValue()</strong> method of the <strong class="source-inline">llvm::DIBuilder</strong> class can be used to <span class="No-Break">achieve this.</span></p>&#13;
			<p>When we implemented the IR generation for functions, we used an advanced algorithm that mainly used values and avoided allocating storage for local variables. In terms of adding debug information, this only means that we use <strong class="source-inline">llvm.dbg.value</strong> much more often than you see it in <span class="No-Break">clang-generated IR.</span></p>&#13;
			<p>What can we <a id="_idIndexMarker385"/>do if the variable does not have dedicated storage space but is part of a larger, aggregate type? One of the situations where this can arise is with the use of nested functions. To implement access to the stack frame of the caller, you must collect all used variables in a structure and pass a pointer to this record to the called function. Inside the called function, you can refer to the variables of the caller as if they are local to the function. What is different is that these variables are now part of <span class="No-Break">an aggregate.</span></p>&#13;
			<p>In the call to <strong class="source-inline">llvm.dbg.declare</strong>, you use an empty expression if the debug metadata describes the whole memory the first parameter is pointing to. However, if it only describes a part of the memory, then you need to add an expression indicating which part of the memory the metadata <span class="No-Break">applies to.</span></p>&#13;
			<p>In the case of the nested frame, you need to calculate the offset in the frame. You need access to a <strong class="source-inline">DataLayout</strong> instance, which you can get from the LLVM module into which you are creating the IR code. If the <strong class="source-inline">llvm::Module</strong> instance is named <strong class="source-inline">Mod</strong>, and the variable holding the nested frame structure is named <strong class="source-inline">Frame</strong> and is of the <strong class="source-inline">llvm::StructType</strong> type, you can access the third member of the frame in the following manner. This access gives you the offset of <span class="No-Break">the member:</span></p>&#13;
			<pre class="source-code">&#13;
const llvm::DataLayout &amp;DL = Mod-&gt;getDataLayout();&#13;
uint64_t Ofs = DL.getStructLayout(Frame)-&gt;getElementOffset(3);</pre>			<p>Moreover, the expression is created from a sequence of operations. To access the third member of the frame, the debugger needs to add the offset to the base pointer. As an example, you need to create an array and this information <span class="No-Break">like so:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::SmallVector&lt;int64_t, 2&gt; AddrOps;&#13;
AddrOps.push_back(llvm::dwarf::DW_OP_plus_uconst);&#13;
AddrOps.push_back(Offset);</pre>			<p>From this array, you can create the expression that you must then pass to <strong class="source-inline">llvm.dbg.declare</strong> instead of the <span class="No-Break">empty expression:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::DIExpression *Expr = DBuilder.createExpression(AddrOps);</pre>			<p>It is important <a id="_idIndexMarker386"/>to note that you are not limited to this offset operation. DWARF knows many different operators, and you can create fairly complex expressions. You can find the complete list of operators in the LLVM include file, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">llvm/include/llvm/BinaryFormat/Dwarf.def</strong></span><span class="No-Break">.</span></p>&#13;
			<p>At this point, you can create debug information for variables. To enable the debugger to follow the control flow in the source, you also need to provide line number information. This is the topic of the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-112"><a id="_idTextAnchor114"/>Adding line numbers</h2>&#13;
			<p>A debugger allows a programmer to step through an application line by line. For this, the debugger <a id="_idIndexMarker387"/>needs to know which machine instructions belong to which line in the source. LLVM allows adding a source location to each instruction. In the previous section, we created location information of the <strong class="source-inline">llvm::DILocation</strong> type. A debug location provides more information than just the line, column, and scope. If needed, the scope into which this line is inlined can be specified. It is also possible to indicate that this debug location belongs to implicit code – that is, code that the frontend has generated but is not in <span class="No-Break">the source.</span></p>&#13;
			<p>Before this information can be attached to an instruction, we must wrap the debug location in a <strong class="source-inline">llvm::DebugLoc</strong> object. To do so, you must simply pass the location information obtained from the <strong class="source-inline">llvm::DILocation</strong> class to the <strong class="source-inline">llvm::DebugLoc</strong> constructor. With this wrapping, LLVM can track the location information. While the location in the source does not change, the generated machine code for a source-level statement or expression can be dropped during optimization. This encapsulation helps deal with these <span class="No-Break">possible changes.</span></p>&#13;
			<p>Adding line number information mostly boils down to retrieving the line number information from the AST and adding it to the generated instructions. The <strong class="source-inline">llvm::Instruction</strong> class has the <strong class="source-inline">setDebugLoc()</strong> method, which attaches the location information to <span class="No-Break">the instruction.</span></p>&#13;
			<p>In the next section, we’ll learn how to generate debug information and add it to our <span class="No-Break"><strong class="source-inline">tinylang</strong></span><span class="No-Break"> compiler.</span></p>&#13;
			<h2 id="_idParaDest-113"><a id="_idTextAnchor115"/>Adding debug support to tinylang</h2>&#13;
			<p>We encapsulate <a id="_idIndexMarker388"/>the generation of debug metadata in the new <strong class="source-inline">CGDebugInfo</strong> class. Additionally, we place the declaration in the <strong class="source-inline">tinylang/CodeGen/CGDebugInfo.h</strong> header file and the definition in the <span class="No-Break"><strong class="source-inline">tinylang/CodeGen/CGDebugInfo.cpp</strong></span><span class="No-Break"> file.</span></p>&#13;
			<p>The <strong class="source-inline">CGDebugInfo</strong> class has five important members. We need a reference to the code generator for the module, <strong class="source-inline">CGM</strong>, because we need to convert types from AST representation into LLVM types. Of course, we also need an instance of the <strong class="source-inline">llvm::DIBuilder</strong> class called <strong class="source-inline">Dbuilder</strong>, as we did in the previous sections. A pointer to the instance of the compile unit is also needed; we store it in the <span class="No-Break"><strong class="source-inline">CU</strong></span><span class="No-Break"> member.</span></p>&#13;
			<p>To avoid having to create the debug metadata for types again, we must also add a map to cache this information. The member is called <strong class="source-inline">TypeCache</strong>. Finally, we need a way to manage the scope information, for which we must create a stack based on the <strong class="source-inline">llvm::SmallVector&lt;&gt;</strong> class called <strong class="source-inline">ScopeStack</strong>. Thus, we have <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code">&#13;
  CGModule &amp;CGM;&#13;
  llvm::DIBuilder DBuilder;&#13;
  llvm::DICompileUnit *CU;&#13;
 llvm::DenseMap&lt;TypeDeclaration *, llvm::DIType *&gt;&#13;
      TypeCache;&#13;
  llvm::SmallVector&lt;llvm::DIScope *, 4&gt; ScopeStack;</pre>			<p>The following methods of the <strong class="source-inline">CGDebugInfo</strong> class make use of <span class="No-Break">these members:</span></p>&#13;
			<ol>&#13;
				<li>First, we need to create the compile unit, which we do in the constructor. We also create the file containing the compile unit here. Later, we can refer to the file through the <strong class="source-inline">CU</strong> member. The code for the constructor is <span class="No-Break">as follows:</span><pre class="source-code">&#13;
CGDebugInfo::CGDebugInfo(CGModule &amp;CGM)&#13;
    : CGM(CGM), DBuilder(*CGM.getModule()) {&#13;
  llvm::SmallString&lt;128&gt; Path(&#13;
      CGM.getASTCtx().getFilename());&#13;
  llvm::sys::fs::make_absolute(Path);&#13;
  llvm::DIFile *File = DBuilder.createFile(&#13;
      llvm::sys::path::filename(Path),&#13;
      llvm::sys::path::parent_path(Path));&#13;
  bool IsOptimized = false;&#13;
  llvm::StringRef CUFlags;&#13;
  unsigned ObjCRunTimeVersion = 0;&#13;
  llvm::StringRef SplitName;&#13;
  llvm::DICompileUnit::DebugEmissionKind EmissionKind =&#13;
      llvm::DICompileUnit::DebugEmissionKind::FullDebug;&#13;
  CU = DBuilder.createCompileUnit(&#13;
      llvm::dwarf::DW_LANG_Modula2, File, "tinylang",&#13;
      IsOptimized, CUFlags, ObjCRunTimeVersion,&#13;
      SplitName, EmissionKind);&#13;
}</pre></li>				<li>Often, we need <a id="_idIndexMarker389"/>to provide a line number. The line number can be derived from the source manager location, which is available in most AST nodes. The source manager can convert this into a <span class="No-Break">line number:</span><pre class="source-code">&#13;
unsigned CGDebugInfo::getLineNumber(SMLoc Loc) {&#13;
  return CGM.getASTCtx().getSourceMgr().FindLineNumber(&#13;
      Loc);&#13;
}</pre></li>				<li>The information about a scope is held on a stack. We need methods to open and close a <a id="_idIndexMarker390"/>scope and retrieve the current scope. The compilation unit is the global scope, which we <span class="No-Break">add automatically:</span><pre class="source-code">&#13;
llvm::DIScope *CGDebugInfo::getScope() {&#13;
  if (ScopeStack.empty())&#13;
    openScope(CU-&gt;getFile());&#13;
  return ScopeStack.back();&#13;
}&#13;
void CGDebugInfo::openScope(llvm::DIScope *Scope) {&#13;
  ScopeStack.push_back(Scope);&#13;
}&#13;
void CGDebugInfo::closeScope() {&#13;
  ScopeStack.pop_back();&#13;
}</pre></li>				<li>Next, we must create a method for each category of type we need to transform. The <strong class="source-inline">getPervasiveType()</strong> method creates the debug metadata for basic types. Note the use of the encoding parameter, which declares the <strong class="source-inline">INTEGER</strong> type as a signed type and the <strong class="source-inline">BOOLEAN</strong> type encoded as <span class="No-Break">a Boolean:</span><pre class="source-code">&#13;
llvm::DIType *&#13;
CGDebugInfo::getPervasiveType(TypeDeclaration *Ty) {&#13;
  if (Ty-&gt;getName() == "INTEGER") {&#13;
    return DBuilder.createBasicType(&#13;
        Ty-&gt;getName(), 64, llvm::dwarf::DW_ATE_signed);&#13;
  }&#13;
  if (Ty-&gt;getName() == "BOOLEAN") {&#13;
    return DBuilder.createBasicType(&#13;
        Ty-&gt;getName(), 1, llvm::dwarf::DW_ATE_boolean);&#13;
  }&#13;
  llvm::report_fatal_error(&#13;
      "Unsupported pervasive type");&#13;
}</pre></li>				<li>If the type name is simply renamed, then we must map this to a type definition. Here, we need <a id="_idIndexMarker391"/>to make use of the scope and line <span class="No-Break">number information:</span><pre class="source-code">&#13;
llvm::DIType *&#13;
CGDebugInfo::getAliasType(AliasTypeDeclaration *Ty) {&#13;
  return DBuilder.createTypedef(&#13;
      getType(Ty-&gt;getType()), Ty-&gt;getName(),&#13;
      CU-&gt;getFile(), getLineNumber(Ty-&gt;getLocation()),&#13;
      getScope());&#13;
}</pre></li>				<li>Creating the debug information for an array requires specifying the size and the alignment. We can retrieve this data from the <strong class="source-inline">DataLayout</strong> class. We also need to <a id="_idIndexMarker392"/>specify the index range of <span class="No-Break">the array:</span><pre class="source-code">&#13;
llvm::DIType *&#13;
CGDebugInfo::getArrayType(ArrayTypeDeclaration *Ty) {&#13;
  auto *ATy =&#13;
      llvm::cast&lt;llvm::ArrayType&gt;(CGM.convertType(Ty));&#13;
  const llvm::DataLayout &amp;DL =&#13;
      CGM.getModule()-&gt;getDataLayout();&#13;
  Expr *Nums = Ty-&gt;getNums();&#13;
  uint64_t NumElements =&#13;
      llvm::cast&lt;IntegerLiteral&gt;(Nums)&#13;
          -&gt;getValue()&#13;
          .getZExtValue();&#13;
  llvm::SmallVector&lt;llvm::Metadata *, 4&gt; Subscripts;&#13;
  Subscripts.push_back(&#13;
      DBuilder.getOrCreateSubrange(0, NumElements));&#13;
  return DBuilder.createArrayType(&#13;
      DL.getTypeSizeInBits(ATy) * 8,&#13;
      1 &lt;&lt; Log2(DL.getABITypeAlign(ATy)),&#13;
      getType(Ty-&gt;getType()),&#13;
      DBuilder.getOrCreateArray(Subscripts));&#13;
}</pre></li>				<li>Using all these single methods, we can create a central method to create the metadata for a type. This metadata is also responsible for caching <span class="No-Break">the data:</span><pre class="source-code">&#13;
llvm::DIType *&#13;
CGDebugInfo::getType(TypeDeclaration *Ty) {&#13;
  if (llvm::DIType *T = TypeCache[Ty])&#13;
    return T;&#13;
  if (llvm::isa&lt;PervasiveTypeDeclaration&gt;(Ty))&#13;
    return TypeCache[Ty] = getPervasiveType(Ty);&#13;
  else if (auto *AliasTy =&#13;
               llvm::dyn_cast&lt;AliasTypeDeclaration&gt;(Ty))&#13;
    return TypeCache[Ty] = getAliasType(AliasTy);&#13;
  else if (auto *ArrayTy =&#13;
               llvm::dyn_cast&lt;ArrayTypeDeclaration&gt;(Ty))&#13;
    return TypeCache[Ty] = getArrayType(ArrayTy);&#13;
  else if (auto *RecordTy =&#13;
               llvm ::dyn_cast&lt;RecordTypeDeclaration&gt;(&#13;
                   Ty))&#13;
    return TypeCache[Ty] = getRecordType(RecordTy);&#13;
  llvm::report_fatal_error("Unsupported type");&#13;
  return nullptr;&#13;
}</pre></li>				<li>We also <a id="_idIndexMarker393"/>need to add a method to emit metadata for <span class="No-Break">global variables:</span><pre class="source-code">&#13;
void CGDebugInfo::emitGlobalVariable(&#13;
    VariableDeclaration *Decl,&#13;
    llvm::GlobalVariable *V) {&#13;
  llvm::DIGlobalVariableExpression *GV =&#13;
      DBuilder.createGlobalVariableExpression(&#13;
          getScope(), Decl-&gt;getName(), V-&gt;getName(),&#13;
          CU-&gt;getFile(),&#13;
          getLineNumber(Decl-&gt;getLocation()),&#13;
          getType(Decl-&gt;getType()), false);&#13;
  V-&gt;addDebugInfo(GV);&#13;
}</pre></li>				<li>To emit the debug information for procedures, we need to create the metadata for the procedure type. For this, we need a list of the types of the parameter, with the <a id="_idIndexMarker394"/>return type being the first entry. If the procedure has no return type, then we must use an unspecified type; this is called <strong class="source-inline">void</strong>, similar to how it is in C. If a parameter is a reference, then we need to add the reference type; otherwise, we must add the type to <span class="No-Break">the list:</span><pre class="source-code">&#13;
llvm::DISubroutineType *&#13;
CGDebugInfo::getType(ProcedureDeclaration *P) {&#13;
  llvm::SmallVector&lt;llvm::Metadata *, 4&gt; Types;&#13;
  const llvm::DataLayout &amp;DL =&#13;
      CGM.getModule()-&gt;getDataLayout();&#13;
  // Return type at index 0&#13;
  if (P-&gt;getRetType())&#13;
    Types.push_back(getType(P-&gt;getRetType()));&#13;
  else&#13;
    Types.push_back(&#13;
        DBuilder.createUnspecifiedType("void"));&#13;
  for (const auto *FP : P-&gt;getFormalParams()) {&#13;
    llvm::DIType *PT = getType(FP-&gt;getType());&#13;
    if (FP-&gt;isVar()) {&#13;
      llvm::Type *PTy = CGM.convertType(FP-&gt;getType());&#13;
      PT = DBuilder.createReferenceType(&#13;
          llvm::dwarf::DW_TAG_reference_type, PT,&#13;
          DL.getTypeSizeInBits(PTy) * 8,&#13;
          1 &lt;&lt; Log2(DL.getABITypeAlign(PTy)));&#13;
    }&#13;
    Types.push_back(PT);&#13;
  }&#13;
  return DBuilder.createSubroutineType(&#13;
      DBuilder.getOrCreateTypeArray(Types));&#13;
}</pre></li>				<li>For the <a id="_idIndexMarker395"/>procedure itself, we can now create the debug information using the procedure type we created in the previous step. A procedure also opens a new scope, so we must push the procedure onto the scope stack. We must also associate the LLVM function object with the new <span class="No-Break">debug information:</span><pre class="source-code">&#13;
void CGDebugInfo::emitProcedure(&#13;
    ProcedureDeclaration *Decl, llvm::Function *Fn) {&#13;
  llvm::DISubroutineType *SubT = getType(Decl);&#13;
  llvm::DISubprogram *Sub = DBuilder.createFunction(&#13;
      getScope(), Decl-&gt;getName(), Fn-&gt;getName(),&#13;
      CU-&gt;getFile(), getLineNumber(Decl-&gt;getLocation()),&#13;
      SubT, getLineNumber(Decl-&gt;getLocation()),&#13;
      llvm::DINode::FlagPrototyped,&#13;
      llvm::DISubprogram::SPFlagDefinition);&#13;
  openScope(Sub);&#13;
  Fn-&gt;setSubprogram(Sub);&#13;
}</pre></li>				<li>When the <a id="_idIndexMarker396"/>end of a procedure is reached, we must inform the builder to finish constructing the debug information for this procedure. We also need to remove the procedure from the <span class="No-Break">scope stack:</span><pre class="source-code">&#13;
void CGDebugInfo::emitProcedureEnd(&#13;
    ProcedureDeclaration *Decl, llvm::Function *Fn) {&#13;
  if (Fn &amp;&amp; Fn-&gt;getSubprogram())&#13;
    DBuilder.finalizeSubprogram(Fn-&gt;getSubprogram());&#13;
  closeScope();&#13;
}</pre></li>				<li>Lastly, when we’ve finished adding the debug information, we need to implement the <strong class="source-inline">finalize()</strong> method on the builder. The generated debug information is then validated. This is an important step during development as it helps you find wrongly <span class="No-Break">generated metadata:</span><pre class="source-code">&#13;
void CGDebugInfo::finalize() { DBuilder.finalize(); }</pre></li>			</ol>&#13;
			<p>Debug information should only be generated if the user requested it. This means that we will need a new command-line switch for this. We will add this to the file of the <strong class="source-inline">CGModule</strong> class, and we will also use it inside <span class="No-Break">this class:</span></p>&#13;
			<pre class="source-code">&#13;
static llvm::cl::opt&lt;bool&gt;&#13;
    Debug("g", llvm::cl::desc("Generate debug information"),&#13;
          llvm::cl::init(false));</pre>			<p>The <strong class="source-inline">-g</strong> option can be used with the <strong class="source-inline">tinylang</strong> compiler to generate <span class="No-Break">debug metadata.</span></p>&#13;
			<p>Furthermore, the <strong class="source-inline">CGModule</strong> class holds an instance of the <strong class="source-inline">std::unique_ptr&lt;CGDebugInfo&gt;</strong> class. The pointer is initialized in the constructor for setting the <span class="No-Break">command-line switch:</span></p>&#13;
			<pre class="source-code">&#13;
  if (Debug)&#13;
    DebugInfo.reset(new CGDebugInfo(*this));</pre>			<p>In the getter <a id="_idIndexMarker397"/>method defined in <strong class="source-inline">CGModule.h</strong>, we simply return <span class="No-Break">the pointer:</span></p>&#13;
			<pre class="source-code">&#13;
CGDebugInfo *getDbgInfo() {&#13;
  return DebugInfo.get();&#13;
}</pre>			<p>The common pattern to generate the debug metadata is to retrieve the pointer and check if it is valid. For example, after creating a global variable, we can add the debug information <span class="No-Break">like so:</span></p>&#13;
			<pre class="source-code">&#13;
VariableDeclaration *Var = …;&#13;
llvm::GlobalVariable *V = …;&#13;
if (CGDebugInfo *Dbg = getDbgInfo())&#13;
  Dbg-&gt;emitGlobalVariable(Var, V);</pre>			<p>To add line number information, we need a conversion method called <strong class="source-inline">getDebugLoc()</strong> in the <strong class="source-inline">CGDebugInfo</strong> class, which turns the location information from the AST into the <span class="No-Break">debug metadata:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::DebugLoc CGDebugInfo::getDebugLoc(SMLoc Loc) {&#13;
  std::pair&lt;unsigned, unsigned&gt; LineAndCol =&#13;
      CGM.getASTCtx().getSourceMgr().getLineAndColumn(Loc);&#13;
  llvm::DILocation *DILoc = llvm::DILocation::get(&#13;
      CGM.getLLVMCtx(), LineAndCol.first, LineAndCol.second,&#13;
      getScope());&#13;
  return llvm::DebugLoc(DILoc);&#13;
}</pre>			<p>Additionally, a utility <a id="_idIndexMarker398"/>function in the <strong class="source-inline">CGModule</strong> class can be called to add the line number information to <span class="No-Break">an instruction:</span></p>&#13;
			<pre class="source-code">&#13;
void CGModule::applyLocation(llvm::Instruction *Inst,&#13;
                             llvm::SMLoc Loc) {&#13;
  if (CGDebugInfo *Dbg = getDbgInfo())&#13;
    Inst-&gt;setDebugLoc(Dbg-&gt;getDebugLoc(Loc));&#13;
}</pre>			<p>In this way, you can add the debug information for <span class="No-Break">your compiler.</span></p>&#13;
			<h1 id="_idParaDest-114"><a id="_idTextAnchor116"/>Summary</h1>&#13;
			<p>In this chapter, you learned how throwing and catching exceptions work in LLVM and the IR you can generate to exploit this feature. To enhance the scope of IR, you learned how you can attach various metadata to instructions. Metadata for type-based alias analysis provides additional information to the LLVM optimizer and helps with certain optimizations to produce better machine code. Users always appreciate the possibility of using a source-level debugger, and by adding debug information to the IR code, you can implement this important feature of <span class="No-Break">a compiler.</span></p>&#13;
			<p>Optimizing the IR code is the core task of LLVM. In the next chapter, we will learn how the pass manager works and how we can influence the optimization pipeline the pass <span class="No-Break">manager governs.</span></p>&#13;
		</div>&#13;
	</div></body></html>