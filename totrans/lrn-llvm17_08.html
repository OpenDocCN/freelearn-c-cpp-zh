<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-99" class="chapter-number"><a id="_idTextAnchor101"/>6</h1>&#13;
			<h1 id="_idParaDest-100"><a id="_idTextAnchor102"/>Advanced IR Generation</h1>&#13;
			<p>With IR generation introduced in the previous chapters, you can already implement most of the functionality required in a compiler. In this chapter, we will look at some advanced topics that often arise in real-world compilers. For example, many modern languages make use of exception handling, so we’ll look at how to translate this into LLVM IR.</p>&#13;
			<p>To support the LLVM optimizer so that it can produce better code in certain situations, we must add additional type metadata to the IR code. Moreover, attaching debug metadata enables the compiler’s user to take advantage of source-level debug tools.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li><em class="italic">Throwing and catching exceptions</em>: Here, you will learn how to implement exception handling in your compiler</li>&#13;
				<li><em class="italic">Generating metadata for type-based alias analysis</em>: Here, you will attach additional metadata to LLVM IR, which helps LLVM to better optimize the code</li>&#13;
				<li><em class="italic">Adding debug metadata</em>: Here, you will implement the support classes needed to add debug information to the generated IR code</li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you will have learned about exception handling, as well as metadata for type-based alias analysis and debug information.</p>&#13;
			<h1 id="_idParaDest-101"><a id="_idTextAnchor103"/>Throwing and catching exceptions</h1>&#13;
			<p>Exception handling in LLVM IR is closely tied to platform support. Here, we will look at the most <a id="_idIndexMarker327"/>common type of exception handling using <code>libunwind</code>. Its full <a id="_idIndexMarker328"/>potential is used by C++, so we will look at an example in C++ first, where the <code>bar()</code> function can throw an <code>int</code> or <code>double</code> value:</p>&#13;
			<pre class="source-code">&#13;
int bar(int x) {&#13;
  if (x == 1) throw 1;&#13;
  if (x == 2) throw 42.0;&#13;
  return x;&#13;
}</pre>			<p>The <code>foo()</code> function calls <code>bar()</code>, but only handles a thrown <code>int</code>. It also declares that it only throws <code>int</code> values:</p>&#13;
			<pre class="source-code">&#13;
int foo(int x) {&#13;
  int y = 0;&#13;
  try {&#13;
    y = bar(x);&#13;
  }&#13;
  catch (int e) {&#13;
    y = e;&#13;
  }&#13;
  return y;&#13;
}</pre>			<p>Throwing an <a id="_idIndexMarker329"/>exception requires two calls into the runtime library; this can be seen in the <code>bar()</code> function. First, memory for the exception is allocated <a id="_idIndexMarker330"/>with a call to <code>__cxa_allocate_exception()</code>. This function takes the number of bytes to allocate as a parameter. The exception payload (the <code>int</code> or <code>double</code> value in this example) is copied to the allocated memory. The exception is then raised with a call to <code>__cxa_throw()</code>. This function takes three arguments: the pointer to the allocated exception, type information about the payload, and a pointer to a destructor, in case the exception payload has one. The <code>__cxa_throw()</code> function initiates the stack unwinding process and never returns. In LLVM IR, this is done for the <code>int</code> value, as follows:</p>&#13;
			<pre class="source-code">&#13;
%eh = call ptr @__cxa_allocate_exception(i64 4)&#13;
store i32 1, ptr %eh&#13;
call void @__cxa_throw(ptr %eh, ptr @_ZTIi, ptr null)&#13;
unreachable</pre>			<p><code>_ZTIi</code> is the type information describing an <code>int</code> type. For a double type, it would be <code>_ZTId</code>.</p>&#13;
			<p>So far, nothing LLVM-specific is done. This changes in the <code>foo()</code> function because the call to <code>bar()</code> can raise an exception. If it is an <code>int</code> type exception, then the control flow must be transferred to the IR code of the catch clause. To accomplish this, the <code>invoke</code> instruction must be used instead of the <code>call</code> instruction:</p>&#13;
			<pre class="source-code">&#13;
%y = invoke i32 @_Z3bari(i32 %x) to label %next&#13;
                                 unwind label %lpad</pre>			<p>The difference <a id="_idIndexMarker331"/>between both instructions is that <code>invoke</code> has two labels associated. The first label is where execution continues in case the called <a id="_idIndexMarker332"/>function ends normally, usually with a <code>ret</code> instruction. In the example code, this label is called <code>%next</code>. If an exception occurs, then execution <a id="_idIndexMarker333"/>continues at a so-called <em class="italic">landing pad</em>, with a label of <code>%lpad</code>.</p>&#13;
			<p>The landing pad is a basic block that must begin with a <code>landingpad</code> instruction. The <code>landingpad</code> instruction gives LLVM information about the handled exception types. For example, a possible landing pad could look like this:</p>&#13;
			<pre class="source-code">&#13;
lpad:&#13;
%exc = landingpad { ptr, i32 }&#13;
          cleanup&#13;
          catch ptr @_ZTIi&#13;
          filter [1 x ptr] [ptr @_ZTIi]</pre>			<p>There are three possible types of action here:</p>&#13;
			<ul>&#13;
				<li><code>cleanup</code>: This denotes that code to clean up the current state is present. Usually, this is used to call destructors of local objects. If this marker is present, then the landing pad is always called during stack unwinding.</li>&#13;
				<li><code>catch</code>: This is a list of type-value pairs and denotes the exception types that can be handled. The landing pad is called if the thrown exception type is found in this list. In the case of the <code>foo()</code> function, the value is the pointer to the C++ runtime type information for the <code>int</code> type, similar to the parameter of the <code>__cxa_throw()</code> function.</li>&#13;
				<li><code>filter</code>: This specifies an array of exception types. The landing pad is called if the exception type of the current exception is not found in the array. This is used to implement the <code>throw()</code> specification. For the <code>foo()</code> function, the array has only one member – the type information for the <code>int</code> type.</li>&#13;
			</ul>&#13;
			<p>The result type of the <code>landingpad</code> instruction is the <code>{ ptr, i32 }</code> structure. The first element <a id="_idIndexMarker334"/>is a pointer to the thrown exception, while the <a id="_idIndexMarker335"/>second is a type selector. Let’s extract both from the structure:</p>&#13;
			<pre class="source-code">&#13;
%exc.ptr = extractvalue { ptr, i32 } %exc, 0&#13;
%exc.sel = extractvalue { ptr, i32 } %exc, 1</pre>			<p>The <em class="italic">type selector</em> is a number <a id="_idIndexMarker336"/>that helps us identify the cause of <em class="italic">why the landing pad is called</em>. It is a positive value if the current exception type matches one of the exception types given in the <code>catch</code> part of the <code>landingpad</code> instruction. If the current exception type does not match any of the values given in the <code>filter</code> part, then the value is negative. It is <code>0</code> if the cleanup code should be called.</p>&#13;
			<p>The type selector is an offset into a type information table, constructed from the values given in the <code>catch</code> and <code>filter</code> parts of the <code>landingpad</code> instruction. During optimization, multiple landing pads can be combined into one, which means that the structure of this table is not known at the IR level. To retrieve the type selector for a given type, we need to call the intrinsic <code>@llvm.eh.typeid.for</code> function. We need this to check if the type selector value corresponds to the type information for <code>int</code> so that we can execute the code in the <code>catch (int e) {}</code> block:</p>&#13;
			<pre class="source-code">&#13;
%tid.int = call i32 @llvm.eh.typeid.for(ptr @_ZTIi)&#13;
%tst.int = icmp eq i32 %exc.sel, %tid.int&#13;
br i1 %tst.int, label %catchint, label %filterorcleanup</pre>			<p>The handling of an exception is framed by calls to <code>__cxa_begin_catch()</code> and <code>__cxa_end_catch()</code>. The <code>__cxa_begin_catch()</code> function needs one argument – the current exception – which is one of the values returned by the <code>landingpad</code> instruction. It returns a pointer to the exception payload – an <code>int</code> value in our case.</p>&#13;
			<p>The <code>__cxa_end_catch()</code> function marks the end of exception handling and deallocates the memory allocated with <code>__cxa_allocate_exception()</code>. Please note that <a id="_idIndexMarker337"/>the runtime behavior is much more complicated if <a id="_idIndexMarker338"/>another exception is thrown inside the <code>catch</code> block. The exception is handled as follows:</p>&#13;
			<pre class="source-code">&#13;
catchint:&#13;
%payload = call ptr @__cxa_begin_catch(ptr %exc.ptr)&#13;
%retval = load i32, ptr %payload&#13;
call void @__cxa_end_catch()&#13;
br label %return</pre>			<p>If the type of the current exception does not match the list in the <code>throws()</code> declaration, the unexpected exception handler is called. First, we need to check the type selector again:</p>&#13;
			<pre class="source-code">&#13;
filterorcleanup:&#13;
%tst.blzero = icmp slt i32 %exc.sel, 0&#13;
br i1 %tst.blzero, label %filter, label %cleanup</pre>			<p>If the value of the type selector is lower than <code>0</code>, then we call the handler:</p>&#13;
			<pre class="source-code">&#13;
filter:&#13;
call void @__cxa_call_unexpected(ptr %exc.ptr) #4&#13;
unreachable</pre>			<p>Again, the handler is not expected to come back.</p>&#13;
			<p>No cleanup work is needed in this case, so all the cleanup code does is resume the execution of the stack unwinder:</p>&#13;
			<pre class="source-code">&#13;
cleanup:&#13;
resume { ptr, i32 } %exc</pre>			<p>One piece is still missing: <code>libunwind</code> drives the stack unwinding process, but it is not tied to a single language. Language-dependent handling is done in the personality function. For C++ on Linux, the personality function is called <code>__gxx_personality_v0()</code>. Depending on the platform or compiler, this name can vary. Each function that needs to take part in stack unwinding has a personality function attached. This personality function analyzes if the function catches an exception, has a non-matching filter list, or needs a cleanup call. It gives this information back to the unwinder, which acts accordingly. In LLVM IR, the pointer to the personality function is given as a part of the function definition:</p>&#13;
			<pre class="source-code">&#13;
define i32 @_Z3fooi(i32) personality ptr @__gxx_personality_v0</pre>			<p>With this, the exception handling facility is complete.</p>&#13;
			<p>To use exception <a id="_idIndexMarker339"/>handling in the compiler for your programming language, the simplest strategy is to piggyback on the existing C++ runtime functions. This also <a id="_idIndexMarker340"/>has the advantage that your exceptions are interoperable with C++. The disadvantage is that you tie some of the C++ runtime into the runtime of your language, most notably memory management. If you want to avoid this, then you need to create your own equivalents of the <code>_cxa_</code> functions. Still, you will want to use <code>libunwind</code>, which provides the stack unwinding mechanism:</p>&#13;
			<ol>&#13;
				<li>Let’s look at how to create this IR. We created the <code>calc</code> expression compiler in <a href="B19561_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">The Structure of a Compiler</em>. Now, we will extend the code generator of the expression compiler to raise and handle an exception in case a division by zero is performed. The generated IR will check if the divisor of a division is <code>0</code>. If true, then an exception will be raised. We will also add a landing pad to the function, which catches the exception and prints <code>Divide by zero!</code> to the console and ends the calculation. Using exception handling is not necessary in this simple case, but it allows us to concentrate on the code generation process. We must add all the code to the <code>CodeGen.cpp</code> file. We begin by adding the required new fields and some helper methods. First of all, we need to store the LLVM declaration of the <code>__cxa_allocate_exception()</code> and <code>__cxa_throw()</code> functions, which consist of the function type and the function itself. A <code>GlobalVariable</code> instance is needed to hold the type information. We also need references to the basic blocks holding the landing pad and a basic block containing just an <code>unreachable</code> instruction:<pre class="source-code">&#13;
  GlobalVariable *TypeInfo = nullptr;&#13;
  FunctionType *AllocEHFty = nullptr;&#13;
  Function *AllocEHFn = nullptr;&#13;
  FunctionType *ThrowEHFty = nullptr;&#13;
  Function *ThrowEHFn = nullptr;&#13;
  BasicBlock *LPadBB = nullptr;&#13;
  BasicBlock *UnreachableBB = nullptr;</pre></li>				<li>We will <a id="_idIndexMarker341"/>also add a new helper function to create the IR for comparing two values. The <code>createICmpEq()</code> function takes the <code>Left</code> and <code>Right</code> values to compare as parameters. It creates a compare instruction <a id="_idIndexMarker342"/>testing for equality of the values, and a branch instruction to two basic blocks, for the equal and inequal cases. The two basic blocks are returned via references in the <code>TrueDest</code> and <code>FalseDest</code> parameters. Furthermore, a label for the new basic blocks can be given in the <code>TrueLabel</code> and <code>FalseLabel</code> parameters. The code is as follows:<pre class="source-code">&#13;
  void createICmpEq(Value *Left, Value *Right,&#13;
                    BasicBlock *&amp;TrueDest,&#13;
                    BasicBlock *&amp;FalseDest,&#13;
                    const Twine &amp;TrueLabel = "",&#13;
                    const Twine &amp;FalseLabel = "") {&#13;
    Function *Fn =&#13;
        Builder.GetInsertBlock()-&gt;getParent();&#13;
    TrueDest = BasicBlock::Create(M-&gt;getContext(),&#13;
                                  TrueLabel, Fn);&#13;
    FalseDest = BasicBlock::Create(M-&gt;getContext(),&#13;
                                   FalseLabel, Fn);&#13;
    Value *Cmp = Builder.CreateCmp(CmpInst::ICMP_EQ,&#13;
                                   Left, Right);&#13;
    Builder.CreateCondBr(Cmp, TrueDest, FalseDest);&#13;
  }</pre></li>				<li>To use the <a id="_idIndexMarker343"/>functions from the runtime, we need to create several function declarations. In LLVM, a function type gives the signature, and the <a id="_idIndexMarker344"/>function itself must be constructed. We use the <code>createFunc()</code> method to create both objects. The functions need references to the <code>FunctionType</code> and <code>Function</code> pointers, the name of the newly declared function, and the result type. The parameter type list is optional, and the flag to indicate a variable parameter list is set to <code>false</code>, indicating that there is no variable part in the parameter list:<pre class="source-code">&#13;
  void createFunc(FunctionType *&amp;Fty, Function *&amp;Fn,&#13;
                  const Twine &amp;N, Type *Result,&#13;
                  ArrayRef&lt;Type *&gt; Params = None,&#13;
                  bool IsVarArgs = false) {&#13;
    Fty = FunctionType::get(Result, Params, IsVarArgs);&#13;
    Fn = Function::Create(&#13;
        Fty, GlobalValue::ExternalLinkage, N, M);&#13;
  }</pre></li>			</ol>&#13;
			<p>With these preparations done, we can generate the IR to raise an exception.</p>&#13;
			<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/>Raising an exception</h2>&#13;
			<p>To generate the IR code to raise an exception, we will add the <code>addThrow()</code> method. This new <a id="_idIndexMarker345"/>method needs to initialize the new fields and then generate the IR to raise an exception via the <code>__cxa_throw()</code> function. The payload of the raised exception is of the <code>int</code> type and can be set to an arbitrary value. Here is what we need to code:</p>&#13;
			<ol>&#13;
				<li>The new <code>addThrow()</code> method begins by checking if the <code>TypeInfo</code> field has been initialized. If it has not been initialized, then a global external constant of an <code>i8</code> pointer type called <code>_ZTIi</code> is created. This represents the C++ metadata describing the C++ <code>int</code> type:<pre class="source-code">&#13;
  void addThrow(int PayloadVal) {&#13;
    if (!TypeInfo) {&#13;
      TypeInfo = new GlobalVariable(&#13;
          *M, Int8PtrTy,&#13;
          /*isConstant=*/true,&#13;
          GlobalValue::ExternalLinkage,&#13;
          /*Initializer=*/nullptr, "_ZTIi");</pre></li>				<li>The initialization continues with creating the IR declaration for the <code>__cxa_allocate_exception()</code> and <code>__cxa_throw()</code> functions using our helper <code>createFunc()</code> method:<pre class="source-code">&#13;
      createFunc(AllocEHFty, AllocEHFn,&#13;
                 "__cxa_allocate_exception", Int8PtrTy,&#13;
                 {Int64Ty});&#13;
      createFunc(ThrowEHFty, ThrowEHFn, "__cxa_throw",&#13;
                 VoidTy,&#13;
                 {Int8PtrTy, Int8PtrTy, Int8PtrTy});</pre></li>				<li>A function that uses exception handling needs a personality function, which helps with stack unwinding. We add the IR code to declare the <code>__gxx_personality_v0()</code> personality function from the C++ library and set it as the <a id="_idIndexMarker346"/>personality routine of the current function. The current function is not stored as a field, but we can use the <code>Builder</code> instance to query the current basic block, which has the function stored as a <code>Parent</code> field:<pre class="source-code">&#13;
      FunctionType *PersFty;&#13;
      Function *PersFn;&#13;
      createFunc(PersFty, PersFn,&#13;
                 "__gxx_personality_v0", Int32Ty, std::nulopt,                  true);&#13;
      Function *Fn =&#13;
          Builder.GetInsertBlock()-&gt;getParent();&#13;
      Fn-&gt;setPersonalityFn(PersFn);</pre></li>				<li>Next, we must create and populate the basic block for the landing pad. First, we need to save the pointer to the current basic block. Then, we must create a new basic block, set it in the builder so that it can be used as the basic block to insert instructions, and call the <code>addLandingPad()</code> method. This method generates the IR code for handling an exception and is described in the next section, <em class="italic">Catching an exception</em>. This code populates the basic block for the landing pad:<pre class="source-code">&#13;
      BasicBlock *SaveBB = Builder.GetInsertBlock();&#13;
      LPadBB = BasicBlock::Create(M-&gt;getContext(),&#13;
                                  "lpad", Fn);&#13;
      Builder.SetInsertPoint(LPadBB);&#13;
      addLandingPad();</pre></li>				<li>The initialization part is completed by creating the basic block holding an <code>unreachable</code> instruction. Again, we create the basic block and set it as an insertion point at the builder. Then, we can add the <code>unreachable</code> instruction to it. Lastly, we can set the insertion point of the builder back to the saved <code>SaveBB</code> instance so that the following IR is added to the right basic block:<pre class="source-code">&#13;
      UnreachableBB = BasicBlock::Create(&#13;
          M-&gt;getContext(), "unreachable", Fn);&#13;
      Builder.SetInsertPoint(UnreachableBB);&#13;
      Builder.CreateUnreachable();&#13;
      Builder.SetInsertPoint(SaveBB);&#13;
    }</pre></li>				<li>To raise an exception, we need to allocate memory for the exception and the payload via a call to the <code>__cxa_allocate_exception()</code> function. Our payload is <a id="_idIndexMarker347"/>of the C++ <code>int</code> type, which usually has a size of 4 bytes. We create a constant unsigned value for the size and call the function with it as a parameter. The function type and the function declaration are already initialized, so we only need to create the <code>call</code> instruction:<pre class="source-code">&#13;
    Constant *PayloadSz =&#13;
        ConstantInt::get(Int64Ty, 4, false);&#13;
    CallInst *EH = Builder.CreateCall(&#13;
        AllocEHFty, AllocEHFn, {PayloadSz});</pre></li>				<li>Next, we store the <code>PayloadVal</code> value in the allocated memory. To do so, we need to create an LLVM IR constant with a call to the <code>ConstantInt::get()</code> function. The pointer to the allocated memory is of an <code>i8</code> pointer type; to store a value of the <code>i32</code> type, we need to create a <code>bitcast</code> instruction to cast the type:<pre class="source-code">&#13;
    Value *PayloadPtr =&#13;
        Builder.CreateBitCast(EH, Int32PtrTy);&#13;
    Builder.CreateStore(&#13;
        ConstantInt::get(Int32Ty, PayloadVal, true),&#13;
        PayloadPtr);</pre></li>				<li>Finally, we must raise the exception with a call to the <code>__cxa_throw()</code> function. As this function raises an exception, which is also handled in the same function, we need to use the <code>invoke</code> instruction instead of the <code>call</code> instruction. Unlike the <code>call</code> instruction, the <code>invoke</code> instruction ends a basic block because it has two successor basic blocks. Here, these are the <code>UnreachableBB</code> and <code>LPadBB</code> basic blocks. If the function raises no exception, the control flow is transferred to the <code>UnreachableBB</code> basic blocks. Due to the <a id="_idIndexMarker348"/>design of the <code>__cxa_throw()</code> function, this will never happen because the control flow is transferred to the <code>LPadBB</code> basic block to handle the exception. This finishes the implementation of the <code>addThrow()</code> method:<pre class="source-code">&#13;
    Builder.CreateInvoke(&#13;
        ThrowEHFty, ThrowEHFn, UnreachableBB, LPadBB,&#13;
        {EH,&#13;
         ConstantExpr::getBitCast(TypeInfo, Int8PtrTy),&#13;
         ConstantPointerNull::get(Int8PtrTy)});&#13;
  }</pre></li>			</ol>&#13;
			<p>Next, we’ll add the code to generate the IR to handle the exception.</p>&#13;
			<h2 id="_idParaDest-103"><a id="_idTextAnchor105"/>Catching an exception</h2>&#13;
			<p>To generate <a id="_idIndexMarker349"/>the IR code to catch an exception, we must add the <code>addLandingPad()</code> method. The generated IR extracts the type information from the exception. If it matches the C++ <code>int</code> type, then the exception is handled by printing <code>Divide by zero!</code> to the console and returning from the function. If the type does not match, we simply execute the <code>resume</code> instruction, which transfers control back to the runtime. As there are no other functions in the call hierarchy to handle this exception, the runtime will terminate the application. The following steps <a id="_idIndexMarker350"/>describe the code that is needed to generate the IR for catching an exception:</p>&#13;
			<ol>&#13;
				<li>In the generated IR, we need to call the <code>__cxa_begin_catch()</code> and <code>__cxa_end_catch()</code> functions from the C++ runtime library. To print the error message, we will generate a call to the <code>puts()</code> function from the C runtime library. Furthermore, to get the type information from the exception, we must generate a call to the <code>llvm.eh.typeid.for</code> intrinsic. We also need the <code>FunctionType</code> and <code>Function</code> instances for all of them; we will take advantage of our <code>createFunc()</code> method to create them:<pre class="source-code">&#13;
  void addLandingPad() {&#13;
    FunctionType *TypeIdFty; Function *TypeIdFn;&#13;
    createFunc(TypeIdFty, TypeIdFn,&#13;
               "llvm.eh.typeid.for", Int32Ty,&#13;
               {Int8PtrTy});&#13;
    FunctionType *BeginCatchFty; Function *BeginCatchFn;&#13;
    createFunc(BeginCatchFty, BeginCatchFn,&#13;
               "__cxa_begin_catch", Int8PtrTy,&#13;
               {Int8PtrTy});&#13;
    FunctionType *EndCatchFty; Function *EndCatchFn;&#13;
    createFunc(EndCatchFty, EndCatchFn,&#13;
               "__cxa_end_catch", VoidTy);&#13;
    FunctionType *PutsFty; Function *PutsFn;&#13;
    createFunc(PutsFty, PutsFn, "puts", Int32Ty,&#13;
               {Int8PtrTy});</pre></li>				<li>The <code>landingpad</code> instruction is the first instruction we generate. The result type is a structure containing fields of an <code>i8</code> pointer and an <code>i32</code> type. This structure is generated with a call to the <code>StructType::get()</code> function. Moreover, since we need to handle an exception of a C++ <code>int</code> type, we need to also add this <a id="_idIndexMarker351"/>as a clause to the <code>landingpad</code> instruction, which must be a constant of an <code>i8</code> pointer type. This means that generating a <code>bitcast</code> instruction is required to convert the <code>TypeInfo</code> value into this type. After, we must store the value that’s returned from the instruction for later use in the <code>Exc</code> variable:<pre class="source-code">&#13;
    LandingPadInst *Exc = Builder.CreateLandingPad(&#13;
        StructType::get(Int8PtrTy, Int32Ty), 1, "exc");&#13;
    Exc-&gt;addClause(&#13;
        ConstantExpr::getBitCast(TypeInfo, Int8PtrTy));</pre></li>				<li>Next, we extract the type selector from the returned value. With a call to the <code>llvm.eh.typeid.for</code> intrinsic, we retrieve the type ID for the <code>TypeInfo</code> field, representing the C++ <code>int</code> type. With this IR, we have generated the two values we need to compare to decide if we can handle the exception:<pre class="source-code">&#13;
    Value *Sel =&#13;
        Builder.CreateExtractValue(Exc, {1}, "exc.sel");&#13;
    CallInst *Id =&#13;
        Builder.CreateCall(TypeIdFty, TypeIdFn,&#13;
                           {ConstantExpr::getBitCast(&#13;
                               TypeInfo, Int8PtrTy)});</pre></li>				<li>To generate the IR for the comparison, we must call our <code>createICmpEq()</code> function. This function also generates two basic blocks, which we store in the <code>TrueDest</code> and <code>FalseDest</code> variables:<pre class="source-code">&#13;
    BasicBlock *TrueDest, *FalseDest;&#13;
    createICmpEq(Sel, Id, TrueDest, FalseDest, "match",&#13;
                 "resume");</pre></li>				<li>If the two <a id="_idIndexMarker352"/>values do not match, the control flow continues at the <code>FalseDest</code> basic block. This basic block only contains a <code>resume</code> instruction, to give control back to the C++ runtime:<pre class="source-code">&#13;
    Builder.SetInsertPoint(FalseDest);&#13;
    Builder.CreateResume(Exc);</pre></li>				<li>If the two values are equal, the control flow continues at the <code>TrueDest</code> basic block. First, we generate the IR code to extract the pointer to the exception from the return value of the <code>landingpad</code> instruction, stored in the <code>Exc</code> variable. Then, we generate a call to the <code>__cxa_begin_catch ()</code> function, passing the pointer to the exception as a parameter. This indicates the beginning of handling the exception for the runtime:<pre class="source-code">&#13;
    Builder.SetInsertPoint(TrueDest);&#13;
    Value *Ptr =&#13;
        Builder.CreateExtractValue(Exc, {0}, "exc.ptr");&#13;
    Builder.CreateCall(BeginCatchFty, BeginCatchFn,&#13;
                       {Ptr});</pre></li>				<li>The exception is then handled by calling the <code>puts()</code> function to print a message to the console. For this, we generate a pointer to the string with a call to the <code>CreateGlobalStringPtr()</code> function, and then pass this pointer as a parameter in the generated call to the <code>puts()</code> function:<pre class="source-code">&#13;
    Value *MsgPtr = Builder.CreateGlobalStringPtr(&#13;
        "Divide by zero!", "msg", 0, M);&#13;
    Builder.CreateCall(PutsFty, PutsFn, {MsgPtr});</pre></li>				<li>Now that <a id="_idIndexMarker353"/>we’ve handled the exception, we must generate a call to the <code>__cxa_end_catch()</code> function to inform the runtime about it. Finally, we return from the function with a <code>ret</code> instruction:<pre class="source-code">&#13;
    Builder.CreateCall(EndCatchFty, EndCatchFn);&#13;
    Builder.CreateRet(Int32Zero);&#13;
  }</pre></li>			</ol>&#13;
			<p>With the <code>addThrow()</code> and <code>addLandingPad()</code> functions, we can generate the IR to raise an exception and handle an exception. However, we still need to add the IR to check if the divisor is <code>0</code>. We’ll cover this in the next section.</p>&#13;
			<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/>Integrating the exception handling code into the application</h2>&#13;
			<p>The IR <a id="_idIndexMarker354"/>for the division is generated inside the <code>visit(BinaryOp &amp;)</code> method. Instead of just generating a <code>sdiv</code> instruction, we must generate an IR to compare the divisor with <code>0</code>. If the divisor is 0, then the control flow continues in a basic block, raising the exception. Otherwise, the control flow continues in a basic block with the <code>sdiv</code> instruction. With the help of the <code>createICmpEq()</code> and <code>addThrow()</code> functions, we can code this very easily:</p>&#13;
			<pre class="source-code">&#13;
    case BinaryOp::Div:&#13;
      BasicBlock *TrueDest, *FalseDest;&#13;
      createICmpEq(Right, Int32Zero, TrueDest,&#13;
                   FalseDest, "divbyzero", "notzero");&#13;
      Builder.SetInsertPoint(TrueDest);&#13;
      addThrow(42); // Arbitrary payload value.&#13;
      Builder.SetInsertPoint(FalseDest);&#13;
      V = Builder.CreateSDiv(Left, Right);&#13;
      break;</pre>			<p>The code generation part is now complete. To build the application, we must change into the build directory and run the <code>ninja</code> tool:</p>&#13;
			<pre class="console">&#13;
$ ninja</pre>			<p>Once the build has finished, you can check the generated IR with the <code>with a: </code><code>3/a</code> expression:</p>&#13;
			<pre class="console">&#13;
$ src/calc "with a: 3/a"</pre>			<p>You will <a id="_idIndexMarker355"/>see the additional IR needed to raise and catch the exception.</p>&#13;
			<p>The generated IR now depends on the C++ runtime. The easiest way to link against the required libraries is to use the <code>clang++</code> compiler. Rename the <code>rtcalc.c</code> file with the runtime functions for the expression calculator to <code>rtcalc.cpp</code>, and add <code>extern "C"</code> in front of each function inside the file. Then, use the <code>llc</code> tool to turn the generated IR into an object file, and the <code>clang++</code> compiler to create an executable:</p>&#13;
			<pre class="console">&#13;
$ src/calc "with a: 3/a" | llc -filetype obj -o exp.o&#13;
$ clang++ -o exp exp.o ../rtcalc.cpp</pre>			<p>Now, we can run the generated application with different values:</p>&#13;
			<pre class="console">&#13;
$ ./exp&#13;
Enter a value for a: 1&#13;
The result is: 3&#13;
$ ./exp&#13;
Enter a value for a: 0&#13;
Divide by zero!</pre>			<p>In the second run, the input is <code>0</code>, and this raises the exception. It works as expected!</p>&#13;
			<p>In this section, we learned how to raise and catch exceptions. The code to generate the IR can be used as a blueprint for other compilers. Of course, the type information that’s used and the number of catch clauses depends on the input to the compiler, but the IR we need to generate still follows the pattern presented in this section.</p>&#13;
			<p>Adding metadata is another way to provide further information to LLVM. In the next section, we’ll add type metadata to support the LLVM optimizer in certain situations.</p>&#13;
			<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/>Generating metadata for type-based alias analysis</h1>&#13;
			<p>Two pointers may point to the same memory cell, at which point they alias each other. Memory <a id="_idIndexMarker356"/>is not typed in the LLVM model, which makes it difficult for the optimizer to decide if two pointers alias each other or not. If the compiler can prove that two pointers do not alias each other, then more optimizations are possible. In the next section, we will have a closer look at the problem and investigate how adding additional metadata will help before we implement this approach.</p>&#13;
			<h2 id="_idParaDest-106"><a id="_idTextAnchor108"/>Understanding the need for additional metadata</h2>&#13;
			<p>To demonstrate the problem, let’s look at the following function:</p>&#13;
			<pre class="source-code">&#13;
void doSomething(int *p, float *q) {&#13;
  *p = 42;&#13;
  *q = 3.1425;&#13;
}</pre>			<p>The optimizer <a id="_idIndexMarker357"/>cannot decide if the pointers, <code>p</code> and <code>q</code>, point to the same <a id="_idIndexMarker358"/>memory cell or not. During optimization, an important analysis can be performed called <code>p</code> and <code>q</code> point to the same memory cell, then they are aliases. Moreover, if the optimizer can prove that both pointers never alias each other, this enables additional optimization opportunities. For example, in the <code>doSomething()</code> function, the stores can be reordered without altering the result in this case.</p>&#13;
			<p>In addition, it depends on the definition of the source language if a variable of one type can be an alias of another variable of a different type. Please note that languages may also contain expressions that break the type-based alias assumption – for example, type casts between unrelated types.</p>&#13;
			<p>The solution chosen by the LLVM developers is to add metadata to the <code>load</code> and <code>store</code> instructions. The added metadata serves two purposes:</p>&#13;
			<ul>&#13;
				<li>First, it defines the type hierarchy based on which type may alias another type</li>&#13;
				<li>Second, it describes the memory access in a <code>load</code> or <code>store</code> instruction</li>&#13;
			</ul>&#13;
			<p>Let’s have a look at the type hierarchy in C. Each type of hierarchy starts with a root node, either <strong class="bold">named</strong> or <strong class="bold">anonymous</strong>. LLVM assumes that root nodes with the same name describe the same type of hierarchy. You can use different type hierarchies in the same LLVM modules, and LLVM makes the safe assumption that these types may alias. Beneath the root node, there are the nodes for scalar types. Nodes for aggregate types are not attached <a id="_idIndexMarker359"/>to the root node, but they refer to scalar types and other aggregate types. Clang defines the hierarchy for C as follows:</p>&#13;
			<ul>&#13;
				<li>The root node is called <code>Simple </code><code>C/C++ TBAA</code>.</li>&#13;
				<li>Beneath the root node is the node for the <code>char</code> types. This is a special type in C because all pointers can be converted into a pointer to <code>char</code>.</li>&#13;
				<li>Beneath the <code>char</code> node are the nodes for the other scalar types and a type for all pointers, called <code>any pointer</code>.</li>&#13;
			</ul>&#13;
			<p>In addition to this, aggregate types are defined as a sequence of member types and offsets.</p>&#13;
			<p>These metadata definitions are used in access tags attached to the <code>load</code> and <code>store</code> instructions. An access tag is made up of three parts: a base type, an access type, and an offset. Depending on the base type, there are two possible ways the access tag describes memory access:</p>&#13;
			<ol>&#13;
				<li>If the base type is an aggregate type, then the access tag describes the memory access of a <code>struct</code> member with the necessary access type and is located at the given offset.</li>&#13;
				<li>If the base type is a scalar type, then the access type must be the same as the base type and the offset must be <code>0</code>.</li>&#13;
			</ol>&#13;
			<p>With these definitions, we can now define a relation on the access tags, which is used to evaluate if two pointers may alias each other or not. Let’s take a closer look at the options for the immediate parent of a <code>(base type, </code><code>offset)</code> tuple:</p>&#13;
			<ol>&#13;
				<li>If the base type is a scalar type and the offset is 0, then the immediate parent is <code>(parent type, 0)</code>, with the parent type being the type of the parent node, as defined in the type hierarchy. If the offset is not 0, then the immediate parent is undefined.</li>&#13;
				<li>If the base type is an aggregate type, then the immediate parent of the <code>(base type, offset)</code> tuple is the <code>(new type, new offset)</code> tuple, with the new type being the type of the member at offset. The new offset is the offset of the new type, adjusted to its new start.</li>&#13;
			</ol>&#13;
			<p>The transitive <a id="_idIndexMarker360"/>closure of this relation is the parent relation. Two memory accesses, (base type 1, access type 1, offset 1) and (base type 2, access type 2, offset 2), may alias one another if (base type 1, offset 1) and (base type 2, offset 2) or vice versa are related in the parent relation.</p>&#13;
			<p>Let’s illustrate this with an example:</p>&#13;
			<pre class="source-code">&#13;
struct Point { float x, y; }&#13;
void func(struct Point *p, float *x, int *i, char *c) {&#13;
  p-&gt;x = 0; p-&gt;y = 0; *x = 0.0; *i = 0; *c = 0;&#13;
}</pre>			<p>When using the memory access tag definition for scalar types, the access tag for the <code>i</code> parameter is (<code>int</code>, <code>int</code>, 0), while for the <code>c</code> parameter, it is (<code>char</code>, <code>char</code>, 0). In the type hierarchy, the parent of the node for the <code>int</code> type is the <code>char</code> node. Therefore, the immediate parent of (<code>int</code>, 0) is (<code>char</code>, 0) and both pointers can alias. The same is true for the <code>x</code> and <code>c</code> parameters. However, the <code>x</code> and <code>i</code> parameters are not related, so they do not alias each other. The access for the <code>y</code> member of <code>struct Point</code> is (<code>Point</code>, <code>float</code>, 4), with 4 being the offset of the <code>y</code> member in the struct. The immediate parent of (<code>Point</code>, 4) is (<code>float</code>, 0), so the access to <code>p-&gt;y</code> and <code>x</code> may alias, and with the same reasoning also with the <code>c</code> parameter.</p>&#13;
			<h2 id="_idParaDest-107"><a id="_idTextAnchor109"/>Creating TBAA metadata in LLVM</h2>&#13;
			<p>To create <a id="_idIndexMarker361"/>the metadata, we must use the <code>llvm::MDBuilder</code> class, which is declared in the <code>llvm/IR/MDBuilder.h</code> header file. The data itself is stored in instances of the <code>llvm::MDNode</code> and <code>llvm::MDString</code> classes. Using the builder class shields us from the internal details of the construction.</p>&#13;
			<p>A root node is created with a call to the <code>createTBAARoot()</code> method, which expects the name of the type hierarchy as a parameter and returns the root node. An anonymous, unique root node can be created with the <code>createAnonymousTBAARoot()</code> method.</p>&#13;
			<p>A scalar <a id="_idIndexMarker362"/>type is added to the hierarchy with the <code>createTBAAScalarTypeNode()</code> method, which takes the name of the type and the parent node as a parameter.</p>&#13;
			<p>On the other hand, adding a type node for an aggregate type is slightly more complex. The <code>createTBAAStructTypeNode()</code> method takes the name of the type and a list of the fields as parameters. Specifically, the fields are given as a <code>std::pair&lt;llvm::MDNode*, uint64_t&gt;</code> instance, where the first element indicates the type of the member and the second element represents the offset in <code>struct</code>.</p>&#13;
			<p>An access tag is created with the <code>createTBAAStructTagNode()</code> method, which takes the base type, the access type, and the offset as parameters.</p>&#13;
			<p>Lastly, the metadata must be attached to a <code>load</code> or <code>store</code> instruction. The <code>llvm::Instruction</code> class contains a method called <code>setMetadata()</code>, which is used to add various type-based alias analysis metadata. The first parameter must be of the <code>llvm::LLVMContext::MD_tbaa</code> type and the second must be the access tag.</p>&#13;
			<p>Equipped <a id="_idIndexMarker363"/>with this knowledge, we must add metadata for <code>tinylang</code>.</p>&#13;
			<h2 id="_idParaDest-108"><a id="_idTextAnchor110"/>Adding TBAA metadata to tinylang</h2>&#13;
			<p>To support TBAA, we must add a new <code>CGTBAA</code> class. This class is responsible for generating <a id="_idIndexMarker364"/>the metadata nodes. Furthermore, we make the <code>CGTBAA</code> class a member of the <code>CGModule</code> class, calling it <code>TBAA</code>.</p>&#13;
			<p>Every load and store instruction must be annotated. A new function is created for this purpose in the <code>CGModule</code> class called <code>decorateInst()</code>. This function tries to create the tag access information. If this is successful, the metadata is attached to the respective load or store instruction. Moreover, this design also allows us to turn off the metadata generation process in case we do not need it, such as in builds with optimizations turned off:</p>&#13;
			<pre class="source-code">&#13;
void CGModule::decorateInst(llvm::Instruction *Inst,&#13;
                            TypeDeclaration *Type) {&#13;
  if (auto *N = TBAA.getAccessTagInfo(Type))&#13;
    Inst-&gt;setMetadata(llvm::LLVMContext::MD_tbaa, N);&#13;
}</pre>			<p>We <a id="_idIndexMarker365"/>put the declaration of the new <code>CGTBAA</code> class in the <code>include/tinylang/CodeGen/CGTBAA.h</code> header file and the definition in the <code>lib/CodeGen/CGTBAA.cpp</code> file. Aside from the AST definitions, the header file needs to include the files for defining the metadata nodes and builder:</p>&#13;
			<pre class="source-code">&#13;
#include "tinylang/AST/AST.h"&#13;
#include "llvm/IR/MDBuilder.h"&#13;
#include "llvm/IR/Metadata.h"</pre>			<p>The <code>CGTBAA</code> class needs to store some data members. So, let’s see how to do this step by step:</p>&#13;
			<ol>&#13;
				<li>First of all, we need to cache the root of the type hierarchy:<pre class="source-code">&#13;
 class CGTBAA {&#13;
  llvm::MDNode *Root;</pre></li>				<li>To construct the metadata nodes, we need an instance of the <code>MDBuilder</code> class:<pre class="source-code">&#13;
  llvm::MDBuilder MDHelper;</pre></li>				<li>Lastly, we must store the metadata that’s been generated for a type for reuse:<pre class="source-code">&#13;
  llvm::DenseMap&lt;TypeDenoter *, llvm::MDNode *&gt; MetadataCache;&#13;
// …&#13;
};</pre></li>			</ol>&#13;
			<p>Now that we’ve defined the variables that are required for the construction, we must add the methods that are required to create the metadata:</p>&#13;
			<ol>&#13;
				<li>The constructor initializes the data members:<pre class="source-code">&#13;
CGTBAA::CGTBAA(CGModule &amp;CGM)&#13;
      : CGM(CGM),&#13;
        MDHelper(llvm::MDBuilder(CGM.getLLVMCtx())),&#13;
        Root(nullptr) {}</pre></li>				<li>We <a id="_idIndexMarker366"/>must lazily instantiate the root of the type hierarchy, which we name <code>Simple </code><code>tinylang TBAA</code>:<pre class="source-code">&#13;
llvm::MDNode *CGTBAA::getRoot() {&#13;
  if (!Root)&#13;
    Root = MDHelper.createTBAARoot("Simple tinylang TBAA");&#13;
  return Root;&#13;
}</pre></li>				<li>For a scalar type, we must create a metadata node with the help of the <code>MDBuilder</code> class based on the name of the type. The new metadata node is stored in the cache:<pre class="source-code">&#13;
llvm::MDNode *&#13;
CGTBAA::createScalarTypeNode(TypeDeclaration *Ty,&#13;
                             StringRef Name,&#13;
                             llvm::MDNode *Parent) {&#13;
  llvm::MDNode *N =&#13;
      MDHelper.createTBAAScalarTypeNode(Name, Parent);&#13;
  return MetadataCache[Ty] = N;&#13;
}</pre></li>				<li>The method to create the metadata for a record is more complicated as we have <a id="_idIndexMarker367"/>to enumerate all the fields of the record. Similar to scalar types, the new metadata node is stored in the cache:<pre class="source-code">&#13;
llvm::MDNode *CGTBAA::createStructTypeNode(&#13;
    TypeDeclaration *Ty, StringRef Name,&#13;
    llvm::ArrayRef&lt;std::pair&lt;llvm::MDNode *, uint64_t&gt;&gt;&#13;
        Fields) {&#13;
  llvm::MDNode *N =&#13;
      MDHelper.createTBAAStructTypeNode(Name, Fields);&#13;
  return MetadataCache[Ty] = N;&#13;
}</pre></li>				<li>To return the metadata for a <code>tinylang</code> type, we need to create the type hierarchy. Due to the type system of <code>tinylang</code> being very restricted, we can use a simple approach. Each scalar type is mapped to a unique type attached to the root node, and we map all pointers to a single type. Structured types then refer to these nodes. If we cannot map a type, then we return <code>nullptr</code>:<pre class="source-code">&#13;
llvm::MDNode *CGTBAA::getTypeInfo(TypeDeclaration *Ty) {&#13;
  if (llvm::MDNode *N = MetadataCache[Ty])&#13;
    return N;&#13;
  if (auto *Pervasive =&#13;
          llvm::dyn_cast&lt;PervasiveTypeDeclaration&gt;(Ty)) {&#13;
    StringRef Name = Pervasive-&gt;getName();&#13;
    return createScalarTypeNode(Pervasive, Name, getRoot());&#13;
  }&#13;
  if (auto *Pointer =&#13;
          llvm::dyn_cast&lt;PointerTypeDeclaration&gt;(Ty)) {&#13;
    StringRef Name = "any pointer";&#13;
    return createScalarTypeNode(Pointer, Name, getRoot());&#13;
  }&#13;
  if (auto *Array =&#13;
         llvm::dyn_cast&lt;ArrayTypeDeclaration&gt;(Ty)) {&#13;
    StringRef Name = Array-&gt;getType()-&gt;getName();&#13;
    return createScalarTypeNode(Array, Name, getRoot());&#13;
  }&#13;
  if (auto *Record =&#13;
          llvm::dyn_cast&lt;RecordTypeDeclaration&gt;(Ty)) {&#13;
    llvm::SmallVector&lt;std::pair&lt;llvm::MDNode *, uint64_t&gt;,     4&gt; Fields;&#13;
    auto *Rec =&#13;
        llvm::cast&lt;llvm::StructType&gt;(CGM.convertType(Record));&#13;
    const llvm::StructLayout *Layout =&#13;
        CGM.getModule()-&gt;getDataLayout().getStructLayout(Rec);&#13;
    unsigned Idx = 0;&#13;
    for (const auto &amp;F : Record-&gt;getFields()) {&#13;
      uint64_t Offset = Layout-&gt;getElementOffset(Idx);&#13;
      Fields.emplace_back(getTypeInfo(F.getType()), Offset);&#13;
      ++Idx;&#13;
    }&#13;
    StringRef Name = CGM.mangleName(Record);&#13;
    return createStructTypeNode(Record, Name, Fields);&#13;
  }&#13;
  return nullptr;&#13;
}</pre></li>				<li>The general method to get the metadata is <code>getAccessTagInfo()</code>. To get the <a id="_idIndexMarker368"/>TBAA access tag information, a call to the <code>getTypeInfo()</code> function must be added. This function expects <code>TypeDeclaration</code> as its parameter, which is retrieved from the instructions we want to produce metadata for:<pre class="source-code">&#13;
llvm::MDNode *CGTBAA::getAccessTagInfo(TypeDeclaration *Ty) {&#13;
    return getTypeInfo(Ty);&#13;
}</pre></li>			</ol>&#13;
			<p>Finally, to enable the generation of TBAA metadata, we simply need to attach the metadata to all of the load and store instructions that we generate within <code>tinylang</code>.</p>&#13;
			<p>For example, in <code>CGProcedure::writeVariable()</code>, a store to a global variable uses a store instruction:</p>&#13;
			<pre class="source-code">&#13;
      Builder.CreateStore(Val, CGM.getGlobal(D));</pre>			<p>To decorate <a id="_idIndexMarker369"/>this particular instruction, we need to replace this line with the following lines, where <code>decorateInst()</code> adds the TBAA metadata to this store instruction:</p>&#13;
			<pre class="source-code">&#13;
      auto *Inst = Builder.CreateStore(Val, CGM.getGlobal(D));&#13;
      // NOTE: V is of the VariableDeclaration class, and&#13;
      // the getType() method in this class retrieves the&#13;
      // TypeDeclaration that is needed for decorateInst().&#13;
      CGM.decorateInst(Inst, V-&gt;getType());</pre>			<p>With these changes in place, we have finished generating the TBAA metadata.</p>&#13;
			<p>We can now compile a sample <code>tinylang</code> file into an LLVM intermediate representation to see our newly implemented TBAA metadata. For instance, consider the following file, <code>Person.mod</code>:</p>&#13;
			<pre class="console">&#13;
MODULE Person;&#13;
TYPE&#13;
  Person = RECORD&#13;
             Height: INTEGER;&#13;
             Age: INTEGER&#13;
           END;&#13;
PROCEDURE Set(VAR p: Person);&#13;
BEGIN&#13;
  p.Age := 18;&#13;
END Set;&#13;
END Person.</pre>			<p>The <code>tinylang</code> compiler that is built in the build directory of this chapter can be used to generate the intermediate representation for this file:</p>&#13;
			<pre class="console">&#13;
$ tools/driver/tinylang -emit-llvm ../examples/Person.mod</pre>			<p>In the <a id="_idIndexMarker370"/>newly generated <code>Person.ll</code> file, we can see that the store instruction is decorated with the TBAA metadata that we have generated within this chapter, where the metadata reflects the fields of the record type that was originally declared:</p>&#13;
			<pre class="console">&#13;
; ModuleID = '../examples/Person.mod'&#13;
source_filename = "../examples/Person.mod"&#13;
target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"&#13;
target triple = "arm64-apple-darwin22.6.0"&#13;
define void @_t6Person3Set(ptr nocapture dereferenceable(16) %p) {&#13;
entry:&#13;
  %0 = getelementptr inbounds ptr, ptr %p, i32 0, i32 1&#13;
  store i64 18, ptr %0, align 8, !tbaa !0&#13;
  ret void&#13;
}&#13;
!0 = !{!"_t6Person6Person", !1, i64 0, !1, i64 8}&#13;
!1 = !{!"INTEGER", !2, i64 0}&#13;
!2 = !{!"Simple tinylang TBAA"}</pre>			<p>Now that we have learned how to generate TBAA metadata, we will explore a very similar topic in the next section: generating debug metadata.</p>&#13;
			<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/>Adding debug metadata</h1>&#13;
			<p>To allow source-level debugging, we have to add debug information. Support for debug information in <a id="_idIndexMarker371"/>LLVM uses debug metadata to describe the types of the source language and other static information, and intrinsics to track variable values. The LLVM core libraries generate debug information in the <em class="italic">DWARF format on Unix systems</em> and in <em class="italic">PDB format for Windows</em>. We’ll look at the general structure in the next section.</p>&#13;
			<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>Understanding the general structure of debug metadata</h2>&#13;
			<p>To describe the general structure, LLVM uses metadata similar to the metadata for type-based analysis. The static <a id="_idIndexMarker372"/>structure describes the file, the compilation unit, functions and lexical blocks, and the used data types.</p>&#13;
			<p>The main class we use is <code>llvm::DIBuilder</code>, and we need to use the <code>llvm/IR/DIBuilder</code> header file to get the class declaration. This builder class provides an easy-to-use interface to create the debug metadata. Later, the metadata is either added to LLVM objects such as global variables, or is used in calls to debug intrinsics. Here’s some important metadata that the builder class can create:</p>&#13;
			<ul>&#13;
				<li><code>llvm::DIFile</code>: This describes a file using the filename and the absolute path of the directory containing the file. You use the <code>createFile()</code> method to create it. A file can contain the main compilation unit or it could contain imported declarations.</li>&#13;
				<li><code>llvm::DICompileUnit</code>: This is used to describe the current compilation unit. Among other things, you specify the source language, a compiler-specific producer string, whether optimizations are enabled or not, and, of course, <code>DIFile</code>, in which the compilation unit resides. You create it with a call to <code>createCompileUnit()</code>.</li>&#13;
				<li><code>llvm::DISubprogram</code>: This describes a function. The most important information here is the scope (usually <code>DICompileUnit</code> or <code>DISubprogram</code> for a nested function), the name of the function, the mangled name of the function, and the function type. It is created with a call to <code>createFunction()</code>.</li>&#13;
				<li><code>llvm::DILexicalBlock</code>: This describes a lexical block and models the block scoping found in many high-level languages. You can create this with a call to <code>createLexicalBlock()</code>.</li>&#13;
			</ul>&#13;
			<p>LLVM makes no assumptions about the language your compiler translates. As a consequence, it has <a id="_idIndexMarker373"/>no information about the data types of the language. To support source-level debugging, especially displaying variable values in a debugger, type information must be added too. Here are some important constructs:</p>&#13;
			<ul>&#13;
				<li>The <code>createBasicType()</code> function, which returns a pointer to the <code>llvm::DIBasicType</code> class, creates the metadata to describe a basic type such as <code>INTEGER</code> in <code>tinylang</code> or <code>int</code> in C++. Besides the name of the type, the required parameters are the size in bits and the encoding – for example, if it is a signed or unsigned type.</li>&#13;
				<li>There are several ways to construct the metadata for composite data types, as represented by the <code>llvm::DIComposite</code> class. You can use the <code>createArrayType()</code>, <code>createStructType()</code>, <code>createUnionType()</code>, and <code>createVectorType()</code> functions to instantiate the metadata for array, struct, union, and vector data types, respectively. These functions require the parameter you expect, such as the base type and the number of subscriptions for an array type or a list of the field members of a struct type.</li>&#13;
				<li>There are also methods to support enumerations, templates, classes, and so on.</li>&#13;
			</ul>&#13;
			<p>The list of functions shows you that you have to add every detail of the source language to the debug information. Let’s assume your instance of the <code>llvm::DIBuilder</code> class is called <code>DBuilder</code>. Let’s also assume that you have some <code>tinylang</code> source in a file called <code>File.mod</code> in the <code>/home/llvmuser</code> folder. Inside this file is the <code>Func():INTEGER</code> function at <em class="italic">line 5</em>, which contains a local <code>VAR i:INTEGER</code> declaration at <em class="italic">line 7</em>. Let’s create the metadata for this, beginning with the information for the file. You need to specify the filename and the absolute path of the folder in which the file resides:</p>&#13;
			<pre class="source-code">&#13;
llvm::DIFile *DbgFile = DBuilder.createFile("File.mod",&#13;
                                            "/home/llvmuser");</pre>			<p>The file is <a id="_idIndexMarker374"/>a module in <code>tinylang</code>, which makes it the compilation unit for LLVM. This carries a lot of information:</p>&#13;
			<pre class="source-code">&#13;
bool IsOptimized = false;&#13;
llvm::StringRef CUFlags;&#13;
unsigned ObjCRunTimeVersion = 0;&#13;
llvm::StringRef SplitName;&#13;
llvm::DICompileUnit::DebugEmissionKind EmissionKind =&#13;
      llvm::DICompileUnit::DebugEmissionKind::FullDebug;&#13;
llvm::DICompileUnit *DbgCU = DBuilder.createCompileUnit(&#13;
      llvm::dwarf::DW_LANG_Modula2, DbgFile, „tinylang",&#13;
      IsOptimized, CUFlags, ObjCRunTimeVersion, SplitName,&#13;
      EmissionKind);</pre>			<p>Furthermore, the debugger needs to know the source language. The DWARF standard defines an enumeration with all the common values. One disadvantage of this is that you cannot simply add a new source language. To do that, you have to create a request at the DWARF committee. Be aware that the debugger and other debug tools also need support for a new language – just adding a new member to the enumeration is not enough.</p>&#13;
			<p>In many cases, it is sufficient to choose a language that is close to your source language. In the case of <code>tinylang</code>, this is Modula-2, and we use <code>DW_LANG_Modula2</code> as the language identifier. A compilation unit resides in a file, which is identified by the <code>DbgFile</code> variable we created previously. Additionally, the debug information can carry information about the producer, which can be the name of the compiler and version information. Here, we just pass the <code>tinylang</code> string. If you do not want to add this information, then you can simply use an empty string as a parameter.</p>&#13;
			<p>The next set of information includes the <code>IsOptimized</code> flag, which should indicate if the compiler has turned optimization on or not. Usually, this flag is derived from the <code>–O</code> command-line switch. You can pass additional parameter settings to the debugger with the <code>CUFlags</code> parameter. This is not used here, and we pass an empty string. We also do not use Objective-C, so we pass <code>0</code> as the Objective-C runtime version.</p>&#13;
			<p>Normally, debug information is embedded in the object file we are creating. If we want to write the <a id="_idIndexMarker375"/>debug information into a separate file, then the <code>SplitName</code> parameter must contain the name of this file. Otherwise, simply passing an empty string is sufficient. Finally, you can define the level of debug information that should be emitted. The default is full debug information, as indicated by the use of the <code>FullDebug</code> enum value, but you can also choose the <code>LineTablesOnly</code> value if you want to emit only line numbers, or the <code>NoDebug</code> value for no debug information at all. For the latter, it is better to not create debug information in the first place.</p>&#13;
			<p>Our minimalistic source only uses the <code>INTEGER</code> data type, which is a signed 32-bit value. Creating the metadata for this type is straightforward:</p>&#13;
			<pre class="source-code">&#13;
llvm::DIBasicType *DbgIntTy =&#13;
                       DBuilder.createBasicType("INTEGER", 32,&#13;
                                  llvm::dwarf::DW_ATE_signed);</pre>			<p>To create the debug metadata for the function, we have to create a type for the signature first, and then the metadata for the function itself. This is similar to the creation of IR for a function. The signature of the function is an array with all the types of parameters in source order and the return type of the function as the first element at index <code>0</code>. Usually, this array is constructed dynamically. In our case, we can also construct the metadata statically. This is useful for internal functions, such as for module initializing. Typically, the parameters of these functions are always known, and the compiler writer can hard-code them:</p>&#13;
			<pre class="source-code">&#13;
llvm::Metadata *DbgSigTy = {DbgIntTy};&#13;
llvm::DITypeRefArray DbgParamsTy =&#13;
                      DBuilder.getOrCreateTypeArray(DbgSigTy);&#13;
llvm::DISubroutineType *DbgFuncTy =&#13;
                   DBuilder.createSubroutineType(DbgParamsTy);</pre>			<p>Our function has the <code>INTEGER</code> return type and no further parameters, so the <code>DbgSigTy</code> array only contains the pointer to the metadata for this type. This static array is turned <a id="_idIndexMarker376"/>into a type array, which is then used to create the type for the function.</p>&#13;
			<p>The function itself requires more data:</p>&#13;
			<pre class="source-code">&#13;
unsigned LineNo = 5;&#13;
unsigned ScopeLine = 5;&#13;
llvm::DISubprogram *DbgFunc = DBuilder.createFunction(&#13;
      DbgCU, "Func", "_t4File4Func", DbgFile, LineNo,&#13;
      DbgFuncTy, ScopeLine, llvm::DISubprogram::FlagPrivate,&#13;
      llvm::DISubprogram::SPFlagLocalToUnit);</pre>			<p>A function belongs to a compilation unit, which in our case is stored in the <code>DbgCU</code> variable. We need to specify the name of the function in the source file, which is <code>Func</code>, and the mangled name is stored in the object file. This information helps the debugger locate the machine code of the function. The mangled name, based on the rules of <code>tinylang</code>, is <code>_t4File4Func</code>. We also have to specify the file that contains the function.</p>&#13;
			<p>This may sound surprising at first, but think of the include mechanism in C and C++: a function can be stored in a different file, which is then included with <code>#include</code> in the main compilation unit. Here, this is not the case and we use the same file as the one the compilation unit uses. Next, the line number of the function and the function type are passed. The line number of the function may not be the line number where the lexical scope of the function begins. In this case, you can specify a different <code>ScopeLine</code>. A function also has protection, which we specify here with the <code>FlagPrivate</code> value to indicate a private function. Other possible values for function protection are <code>FlagPublic</code> and <code>FlagProtected</code>, for public and protected functions, respectively.</p>&#13;
			<p>Besides the protection level, other flags can be specified here. For example, <code>FlagVirtual</code> indicates a virtual function and <code>FlagNoReturn</code> indicates that the function does not return to the caller. You can find the complete list of possible values in the LLVM include file – that is, <code>llvm/include/llvm/IR/DebugInfoFlags.def</code>.</p>&#13;
			<p>Lastly, flags specific to a function can be specified. The most commonly used flag is the <code>SPFlagLocalToUnit</code> value, which indicates that the function is local to this compilation unit. The <code>MainSubprogram</code> value is also used often, indicating that this function is <a id="_idIndexMarker377"/>the main function of the application. The LLVM include file mentioned previously also lists all possible values related to flags specific to functions.</p>&#13;
			<p>So far, we have only created the metadata referring to static data. Variables are dynamic, so we’ll explore how to attach the static metadata to the IR code for accessing variables in the next section.</p>&#13;
			<h2 id="_idParaDest-111"><a id="_idTextAnchor113"/>Tracking variables and their values</h2>&#13;
			<p>To be useful, the type metadata described in the previous section needs to be associated <a id="_idIndexMarker378"/>with variables of the source program. For a <a id="_idIndexMarker379"/>global variable, this is pretty easy. The <code>createGlobalVariableExpression()</code> function of the <code>llvm::DIBuilder</code> class creates the metadata to describe a global variable. This includes the name of the variable in the source, the mangled name, the source file, and so on. A global variable in LLVM IR is represented by an instance of the <code>GlobalVariable</code> class. This class has a method called <code>addDebugInfo()</code>, which associates the metadata node returned from <code>createGlobalVariableExpression()</code> with the global variable.</p>&#13;
			<p>For local variables, we need to take another approach. LLVM IR does not know of a class representing a local variable as it only knows about values. The solution the LLVM community has <a id="_idIndexMarker380"/>developed is to insert calls to intrinsic functions into the IR code of a function. An <code>llvm.dbg.declare</code> and <code>llvm.dbg.value</code>.</p>&#13;
			<p>The <code>llvm.dbg.declare</code> intrinsic provides information and is generated once by the frontend to declare a local variable. Essentially, this intrinsic describes the address of a local variable. During optimization, passes can replace this intrinsic with (possibly multiple) calls to <code>llvm.dbg.value</code> to preserve the debug information and to track the local source variables. After optimization, multiple calls to <code>llvm.dbg.declare</code> may be <a id="_idIndexMarker381"/>present as it is used to describe the program points <a id="_idIndexMarker382"/>where the local variables live within memory.</p>&#13;
			<p>On the other hand, the <code>llvm.dbg.value</code> intrinsic is called whenever a local variable is set to a new value. This intrinsic describes the value of a local variable, not its address.</p>&#13;
			<p>How does all of this work? The LLVM IR representation and the programmatic creation via the <code>llvm::DIBuilder</code> class differ a bit, so we will look at both.</p>&#13;
			<p>Continuing with our example from the previous section, we’ll allocate local storage for the <code>I</code> variable inside the <code>Func</code> function with the <code>alloca</code> instruction:</p>&#13;
			<pre class="source-code">&#13;
@i = alloca i32</pre>			<p>After that, we must add a call to the <code>llvm.dbg.declare</code> intrinsic:</p>&#13;
			<pre class="source-code">&#13;
call void @llvm.dbg.declare(metadata ptr %i,&#13;
                        metadata !1, metadata !DIExpression())</pre>			<p>The first parameter is the address to the local variable. The second parameter is the metadata describing the local variable, which is created by a call to either <code>createAutoVariable()</code> for a local variable or <code>createParameterVariable()</code> for a parameter of the <code>llvm::DIBuilder</code> class. Finally, the third parameter describes an address expression, which will be explained later.</p>&#13;
			<p>Let’s implement the IR creation. You can allocate the storage for the local <code>@i</code> variable with a call to the <code>CreateAlloca()</code> method of the <code>llvm::IRBuilder&lt;&gt;</code> class:</p>&#13;
			<pre class="source-code">&#13;
llvm::Type *IntTy = llvm::Type::getInt32Ty(LLVMCtx);&#13;
llvm::Value *Val = Builder.CreateAlloca(IntTy, nullptr, "i");</pre>			<p>The <code>LLVMCtx</code> variable is the used context class, and <code>Builder</code> is the used instance of the <code>llvm::IRBuilder&lt;&gt;</code> class.</p>&#13;
			<p>A local variable also needs to be described by metadata:</p>&#13;
			<pre class="source-code">&#13;
llvm::DILocalVariable *DbgLocalVar =&#13;
 Dbuilder.createAutoVariable(DbgFunc, "i", DbgFile,&#13;
                             7, DbgIntTy);</pre>			<p>Using the values <a id="_idIndexMarker383"/>from the previous section, we can specify <a id="_idIndexMarker384"/>that the variable is part of the <code>DbgFunc</code> function, is called <code>i</code>, is defined in the <code>DbgFile</code> file at <em class="italic">line 7</em>, and is of the <code>DbgIntTy</code> type.</p>&#13;
			<p>Finally, we associate the debug metadata with the address of the variable using the <code>llvm.dbg.declare</code> intrinsic. Using <code>llvm::DIBuilder</code> shields you from all of the details of adding a call:</p>&#13;
			<pre class="source-code">&#13;
llvm::DILocation *DbgLoc =&#13;
                llvm::DILocation::get(LLVMCtx, 7, 5, DbgFunc);&#13;
DBuilder.insertDeclare(Val, DbgLocalVar,&#13;
                       DBuilder.createExpression(), DbgLoc,&#13;
                       Val.getParent());</pre>			<p>Again, we have to specify a source location for the variable. An instance of <code>llvm::DILocation</code> is a container that holds the line and column of a location associated with a scope. Furthermore, the <code>insertDeclare()</code> method adds the call to the intrinsic function of the LLVM IR. In terms of this function’s parameters, it requires the address of the variable, stored in <code>Val</code>, and the debug metadata for the variable, stored in <code>DbgValVar</code>. We also pass an empty address expression and the debug location we created previously. As with normal instructions, we need to specify into which basic block the call is inserted. If we specify a basic block, then the call is inserted at the end. Alternatively, we can specify an instruction, and the call is inserted before that instruction. We also have the pointer to the <code>alloca</code> instruction, which is the last instruction that we inserted into the underlying basic block. Therefore, we can use this basic block, and the call gets appended after the <code>alloca</code> instruction.</p>&#13;
			<p>If the value of a local variable changes, then a call to <code>llvm.dbg.value</code> must be added to the IR to set the new value of a local variable. The <code>insertValue()</code> method of the <code>llvm::DIBuilder</code> class can be used to achieve this.</p>&#13;
			<p>When we implemented the IR generation for functions, we used an advanced algorithm that mainly used values and avoided allocating storage for local variables. In terms of adding debug information, this only means that we use <code>llvm.dbg.value</code> much more often than you see it in clang-generated IR.</p>&#13;
			<p>What can we <a id="_idIndexMarker385"/>do if the variable does not have dedicated storage space but is part of a larger, aggregate type? One of the situations where this can arise is with the use of nested functions. To implement access to the stack frame of the caller, you must collect all used variables in a structure and pass a pointer to this record to the called function. Inside the called function, you can refer to the variables of the caller as if they are local to the function. What is different is that these variables are now part of an aggregate.</p>&#13;
			<p>In the call to <code>llvm.dbg.declare</code>, you use an empty expression if the debug metadata describes the whole memory the first parameter is pointing to. However, if it only describes a part of the memory, then you need to add an expression indicating which part of the memory the metadata applies to.</p>&#13;
			<p>In the case of the nested frame, you need to calculate the offset in the frame. You need access to a <code>DataLayout</code> instance, which you can get from the LLVM module into which you are creating the IR code. If the <code>llvm::Module</code> instance is named <code>Mod</code>, and the variable holding the nested frame structure is named <code>Frame</code> and is of the <code>llvm::StructType</code> type, you can access the third member of the frame in the following manner. This access gives you the offset of the member:</p>&#13;
			<pre class="source-code">&#13;
const llvm::DataLayout &amp;DL = Mod-&gt;getDataLayout();&#13;
uint64_t Ofs = DL.getStructLayout(Frame)-&gt;getElementOffset(3);</pre>			<p>Moreover, the expression is created from a sequence of operations. To access the third member of the frame, the debugger needs to add the offset to the base pointer. As an example, you need to create an array and this information like so:</p>&#13;
			<pre class="source-code">&#13;
llvm::SmallVector&lt;int64_t, 2&gt; AddrOps;&#13;
AddrOps.push_back(llvm::dwarf::DW_OP_plus_uconst);&#13;
AddrOps.push_back(Offset);</pre>			<p>From this array, you can create the expression that you must then pass to <code>llvm.dbg.declare</code> instead of the empty expression:</p>&#13;
			<pre class="source-code">&#13;
llvm::DIExpression *Expr = DBuilder.createExpression(AddrOps);</pre>			<p>It is important <a id="_idIndexMarker386"/>to note that you are not limited to this offset operation. DWARF knows many different operators, and you can create fairly complex expressions. You can find the complete list of operators in the LLVM include file, called <code>llvm/include/llvm/BinaryFormat/Dwarf.def</code>.</p>&#13;
			<p>At this point, you can create debug information for variables. To enable the debugger to follow the control flow in the source, you also need to provide line number information. This is the topic of the next section.</p>&#13;
			<h2 id="_idParaDest-112"><a id="_idTextAnchor114"/>Adding line numbers</h2>&#13;
			<p>A debugger allows a programmer to step through an application line by line. For this, the debugger <a id="_idIndexMarker387"/>needs to know which machine instructions belong to which line in the source. LLVM allows adding a source location to each instruction. In the previous section, we created location information of the <code>llvm::DILocation</code> type. A debug location provides more information than just the line, column, and scope. If needed, the scope into which this line is inlined can be specified. It is also possible to indicate that this debug location belongs to implicit code – that is, code that the frontend has generated but is not in the source.</p>&#13;
			<p>Before this information can be attached to an instruction, we must wrap the debug location in a <code>llvm::DebugLoc</code> object. To do so, you must simply pass the location information obtained from the <code>llvm::DILocation</code> class to the <code>llvm::DebugLoc</code> constructor. With this wrapping, LLVM can track the location information. While the location in the source does not change, the generated machine code for a source-level statement or expression can be dropped during optimization. This encapsulation helps deal with these possible changes.</p>&#13;
			<p>Adding line number information mostly boils down to retrieving the line number information from the AST and adding it to the generated instructions. The <code>llvm::Instruction</code> class has the <code>setDebugLoc()</code> method, which attaches the location information to the instruction.</p>&#13;
			<p>In the next section, we’ll learn how to generate debug information and add it to our <code>tinylang</code> compiler.</p>&#13;
			<h2 id="_idParaDest-113"><a id="_idTextAnchor115"/>Adding debug support to tinylang</h2>&#13;
			<p>We encapsulate <a id="_idIndexMarker388"/>the generation of debug metadata in the new <code>CGDebugInfo</code> class. Additionally, we place the declaration in the <code>tinylang/CodeGen/CGDebugInfo.h</code> header file and the definition in the <code>tinylang/CodeGen/CGDebugInfo.cpp</code> file.</p>&#13;
			<p>The <code>CGDebugInfo</code> class has five important members. We need a reference to the code generator for the module, <code>CGM</code>, because we need to convert types from AST representation into LLVM types. Of course, we also need an instance of the <code>llvm::DIBuilder</code> class called <code>Dbuilder</code>, as we did in the previous sections. A pointer to the instance of the compile unit is also needed; we store it in the <code>CU</code> member.</p>&#13;
			<p>To avoid having to create the debug metadata for types again, we must also add a map to cache this information. The member is called <code>TypeCache</code>. Finally, we need a way to manage the scope information, for which we must create a stack based on the <code>llvm::SmallVector&lt;&gt;</code> class called <code>ScopeStack</code>. Thus, we have the following:</p>&#13;
			<pre class="source-code">&#13;
  CGModule &amp;CGM;&#13;
  llvm::DIBuilder DBuilder;&#13;
  llvm::DICompileUnit *CU;&#13;
 llvm::DenseMap&lt;TypeDeclaration *, llvm::DIType *&gt;&#13;
      TypeCache;&#13;
  llvm::SmallVector&lt;llvm::DIScope *, 4&gt; ScopeStack;</pre>			<p>The following methods of the <code>CGDebugInfo</code> class make use of these members:</p>&#13;
			<ol>&#13;
				<li>First, we need to create the compile unit, which we do in the constructor. We also create the file containing the compile unit here. Later, we can refer to the file through the <code>CU</code> member. The code for the constructor is as follows:<pre class="source-code">&#13;
CGDebugInfo::CGDebugInfo(CGModule &amp;CGM)&#13;
    : CGM(CGM), DBuilder(*CGM.getModule()) {&#13;
  llvm::SmallString&lt;128&gt; Path(&#13;
      CGM.getASTCtx().getFilename());&#13;
  llvm::sys::fs::make_absolute(Path);&#13;
  llvm::DIFile *File = DBuilder.createFile(&#13;
      llvm::sys::path::filename(Path),&#13;
      llvm::sys::path::parent_path(Path));&#13;
  bool IsOptimized = false;&#13;
  llvm::StringRef CUFlags;&#13;
  unsigned ObjCRunTimeVersion = 0;&#13;
  llvm::StringRef SplitName;&#13;
  llvm::DICompileUnit::DebugEmissionKind EmissionKind =&#13;
      llvm::DICompileUnit::DebugEmissionKind::FullDebug;&#13;
  CU = DBuilder.createCompileUnit(&#13;
      llvm::dwarf::DW_LANG_Modula2, File, "tinylang",&#13;
      IsOptimized, CUFlags, ObjCRunTimeVersion,&#13;
      SplitName, EmissionKind);&#13;
}</pre></li>				<li>Often, we need <a id="_idIndexMarker389"/>to provide a line number. The line number can be derived from the source manager location, which is available in most AST nodes. The source manager can convert this into a line number:<pre class="source-code">&#13;
unsigned CGDebugInfo::getLineNumber(SMLoc Loc) {&#13;
  return CGM.getASTCtx().getSourceMgr().FindLineNumber(&#13;
      Loc);&#13;
}</pre></li>				<li>The information about a scope is held on a stack. We need methods to open and close a <a id="_idIndexMarker390"/>scope and retrieve the current scope. The compilation unit is the global scope, which we add automatically:<pre class="source-code">&#13;
llvm::DIScope *CGDebugInfo::getScope() {&#13;
  if (ScopeStack.empty())&#13;
    openScope(CU-&gt;getFile());&#13;
  return ScopeStack.back();&#13;
}&#13;
void CGDebugInfo::openScope(llvm::DIScope *Scope) {&#13;
  ScopeStack.push_back(Scope);&#13;
}&#13;
void CGDebugInfo::closeScope() {&#13;
  ScopeStack.pop_back();&#13;
}</pre></li>				<li>Next, we must create a method for each category of type we need to transform. The <code>getPervasiveType()</code> method creates the debug metadata for basic types. Note the use of the encoding parameter, which declares the <code>INTEGER</code> type as a signed type and the <code>BOOLEAN</code> type encoded as a Boolean:<pre class="source-code">&#13;
llvm::DIType *&#13;
CGDebugInfo::getPervasiveType(TypeDeclaration *Ty) {&#13;
  if (Ty-&gt;getName() == "INTEGER") {&#13;
    return DBuilder.createBasicType(&#13;
        Ty-&gt;getName(), 64, llvm::dwarf::DW_ATE_signed);&#13;
  }&#13;
  if (Ty-&gt;getName() == "BOOLEAN") {&#13;
    return DBuilder.createBasicType(&#13;
        Ty-&gt;getName(), 1, llvm::dwarf::DW_ATE_boolean);&#13;
  }&#13;
  llvm::report_fatal_error(&#13;
      "Unsupported pervasive type");&#13;
}</pre></li>				<li>If the type name is simply renamed, then we must map this to a type definition. Here, we need <a id="_idIndexMarker391"/>to make use of the scope and line number information:<pre class="source-code">&#13;
llvm::DIType *&#13;
CGDebugInfo::getAliasType(AliasTypeDeclaration *Ty) {&#13;
  return DBuilder.createTypedef(&#13;
      getType(Ty-&gt;getType()), Ty-&gt;getName(),&#13;
      CU-&gt;getFile(), getLineNumber(Ty-&gt;getLocation()),&#13;
      getScope());&#13;
}</pre></li>				<li>Creating the debug information for an array requires specifying the size and the alignment. We can retrieve this data from the <code>DataLayout</code> class. We also need to <a id="_idIndexMarker392"/>specify the index range of the array:<pre class="source-code">&#13;
llvm::DIType *&#13;
CGDebugInfo::getArrayType(ArrayTypeDeclaration *Ty) {&#13;
  auto *ATy =&#13;
      llvm::cast&lt;llvm::ArrayType&gt;(CGM.convertType(Ty));&#13;
  const llvm::DataLayout &amp;DL =&#13;
      CGM.getModule()-&gt;getDataLayout();&#13;
  Expr *Nums = Ty-&gt;getNums();&#13;
  uint64_t NumElements =&#13;
      llvm::cast&lt;IntegerLiteral&gt;(Nums)&#13;
          -&gt;getValue()&#13;
          .getZExtValue();&#13;
  llvm::SmallVector&lt;llvm::Metadata *, 4&gt; Subscripts;&#13;
  Subscripts.push_back(&#13;
      DBuilder.getOrCreateSubrange(0, NumElements));&#13;
  return DBuilder.createArrayType(&#13;
      DL.getTypeSizeInBits(ATy) * 8,&#13;
      1 &lt;&lt; Log2(DL.getABITypeAlign(ATy)),&#13;
      getType(Ty-&gt;getType()),&#13;
      DBuilder.getOrCreateArray(Subscripts));&#13;
}</pre></li>				<li>Using all these single methods, we can create a central method to create the metadata for a type. This metadata is also responsible for caching the data:<pre class="source-code">&#13;
llvm::DIType *&#13;
CGDebugInfo::getType(TypeDeclaration *Ty) {&#13;
  if (llvm::DIType *T = TypeCache[Ty])&#13;
    return T;&#13;
  if (llvm::isa&lt;PervasiveTypeDeclaration&gt;(Ty))&#13;
    return TypeCache[Ty] = getPervasiveType(Ty);&#13;
  else if (auto *AliasTy =&#13;
               llvm::dyn_cast&lt;AliasTypeDeclaration&gt;(Ty))&#13;
    return TypeCache[Ty] = getAliasType(AliasTy);&#13;
  else if (auto *ArrayTy =&#13;
               llvm::dyn_cast&lt;ArrayTypeDeclaration&gt;(Ty))&#13;
    return TypeCache[Ty] = getArrayType(ArrayTy);&#13;
  else if (auto *RecordTy =&#13;
               llvm ::dyn_cast&lt;RecordTypeDeclaration&gt;(&#13;
                   Ty))&#13;
    return TypeCache[Ty] = getRecordType(RecordTy);&#13;
  llvm::report_fatal_error("Unsupported type");&#13;
  return nullptr;&#13;
}</pre></li>				<li>We also <a id="_idIndexMarker393"/>need to add a method to emit metadata for global variables:<pre class="source-code">&#13;
void CGDebugInfo::emitGlobalVariable(&#13;
    VariableDeclaration *Decl,&#13;
    llvm::GlobalVariable *V) {&#13;
  llvm::DIGlobalVariableExpression *GV =&#13;
      DBuilder.createGlobalVariableExpression(&#13;
          getScope(), Decl-&gt;getName(), V-&gt;getName(),&#13;
          CU-&gt;getFile(),&#13;
          getLineNumber(Decl-&gt;getLocation()),&#13;
          getType(Decl-&gt;getType()), false);&#13;
  V-&gt;addDebugInfo(GV);&#13;
}</pre></li>				<li>To emit the debug information for procedures, we need to create the metadata for the procedure type. For this, we need a list of the types of the parameter, with the <a id="_idIndexMarker394"/>return type being the first entry. If the procedure has no return type, then we must use an unspecified type; this is called <code>void</code>, similar to how it is in C. If a parameter is a reference, then we need to add the reference type; otherwise, we must add the type to the list:<pre class="source-code">&#13;
llvm::DISubroutineType *&#13;
CGDebugInfo::getType(ProcedureDeclaration *P) {&#13;
  llvm::SmallVector&lt;llvm::Metadata *, 4&gt; Types;&#13;
  const llvm::DataLayout &amp;DL =&#13;
      CGM.getModule()-&gt;getDataLayout();&#13;
  // Return type at index 0&#13;
  if (P-&gt;getRetType())&#13;
    Types.push_back(getType(P-&gt;getRetType()));&#13;
  else&#13;
    Types.push_back(&#13;
        DBuilder.createUnspecifiedType("void"));&#13;
  for (const auto *FP : P-&gt;getFormalParams()) {&#13;
    llvm::DIType *PT = getType(FP-&gt;getType());&#13;
    if (FP-&gt;isVar()) {&#13;
      llvm::Type *PTy = CGM.convertType(FP-&gt;getType());&#13;
      PT = DBuilder.createReferenceType(&#13;
          llvm::dwarf::DW_TAG_reference_type, PT,&#13;
          DL.getTypeSizeInBits(PTy) * 8,&#13;
          1 &lt;&lt; Log2(DL.getABITypeAlign(PTy)));&#13;
    }&#13;
    Types.push_back(PT);&#13;
  }&#13;
  return DBuilder.createSubroutineType(&#13;
      DBuilder.getOrCreateTypeArray(Types));&#13;
}</pre></li>				<li>For the <a id="_idIndexMarker395"/>procedure itself, we can now create the debug information using the procedure type we created in the previous step. A procedure also opens a new scope, so we must push the procedure onto the scope stack. We must also associate the LLVM function object with the new debug information:<pre class="source-code">&#13;
void CGDebugInfo::emitProcedure(&#13;
    ProcedureDeclaration *Decl, llvm::Function *Fn) {&#13;
  llvm::DISubroutineType *SubT = getType(Decl);&#13;
  llvm::DISubprogram *Sub = DBuilder.createFunction(&#13;
      getScope(), Decl-&gt;getName(), Fn-&gt;getName(),&#13;
      CU-&gt;getFile(), getLineNumber(Decl-&gt;getLocation()),&#13;
      SubT, getLineNumber(Decl-&gt;getLocation()),&#13;
      llvm::DINode::FlagPrototyped,&#13;
      llvm::DISubprogram::SPFlagDefinition);&#13;
  openScope(Sub);&#13;
  Fn-&gt;setSubprogram(Sub);&#13;
}</pre></li>				<li>When the <a id="_idIndexMarker396"/>end of a procedure is reached, we must inform the builder to finish constructing the debug information for this procedure. We also need to remove the procedure from the scope stack:<pre class="source-code">&#13;
void CGDebugInfo::emitProcedureEnd(&#13;
    ProcedureDeclaration *Decl, llvm::Function *Fn) {&#13;
  if (Fn &amp;&amp; Fn-&gt;getSubprogram())&#13;
    DBuilder.finalizeSubprogram(Fn-&gt;getSubprogram());&#13;
  closeScope();&#13;
}</pre></li>				<li>Lastly, when we’ve finished adding the debug information, we need to implement the <code>finalize()</code> method on the builder. The generated debug information is then validated. This is an important step during development as it helps you find wrongly generated metadata:<pre class="source-code">&#13;
void CGDebugInfo::finalize() { DBuilder.finalize(); }</pre></li>			</ol>&#13;
			<p>Debug information should only be generated if the user requested it. This means that we will need a new command-line switch for this. We will add this to the file of the <code>CGModule</code> class, and we will also use it inside this class:</p>&#13;
			<pre class="source-code">&#13;
static llvm::cl::opt&lt;bool&gt;&#13;
    Debug("g", llvm::cl::desc("Generate debug information"),&#13;
          llvm::cl::init(false));</pre>			<p>The <code>-g</code> option can be used with the <code>tinylang</code> compiler to generate debug metadata.</p>&#13;
			<p>Furthermore, the <code>CGModule</code> class holds an instance of the <code>std::unique_ptr&lt;CGDebugInfo&gt;</code> class. The pointer is initialized in the constructor for setting the command-line switch:</p>&#13;
			<pre class="source-code">&#13;
  if (Debug)&#13;
    DebugInfo.reset(new CGDebugInfo(*this));</pre>			<p>In the getter <a id="_idIndexMarker397"/>method defined in <code>CGModule.h</code>, we simply return the pointer:</p>&#13;
			<pre class="source-code">&#13;
CGDebugInfo *getDbgInfo() {&#13;
  return DebugInfo.get();&#13;
}</pre>			<p>The common pattern to generate the debug metadata is to retrieve the pointer and check if it is valid. For example, after creating a global variable, we can add the debug information like so:</p>&#13;
			<pre class="source-code">&#13;
VariableDeclaration *Var = …;&#13;
llvm::GlobalVariable *V = …;&#13;
if (CGDebugInfo *Dbg = getDbgInfo())&#13;
  Dbg-&gt;emitGlobalVariable(Var, V);</pre>			<p>To add line number information, we need a conversion method called <code>getDebugLoc()</code> in the <code>CGDebugInfo</code> class, which turns the location information from the AST into the debug metadata:</p>&#13;
			<pre class="source-code">&#13;
llvm::DebugLoc CGDebugInfo::getDebugLoc(SMLoc Loc) {&#13;
  std::pair&lt;unsigned, unsigned&gt; LineAndCol =&#13;
      CGM.getASTCtx().getSourceMgr().getLineAndColumn(Loc);&#13;
  llvm::DILocation *DILoc = llvm::DILocation::get(&#13;
      CGM.getLLVMCtx(), LineAndCol.first, LineAndCol.second,&#13;
      getScope());&#13;
  return llvm::DebugLoc(DILoc);&#13;
}</pre>			<p>Additionally, a utility <a id="_idIndexMarker398"/>function in the <code>CGModule</code> class can be called to add the line number information to an instruction:</p>&#13;
			<pre class="source-code">&#13;
void CGModule::applyLocation(llvm::Instruction *Inst,&#13;
                             llvm::SMLoc Loc) {&#13;
  if (CGDebugInfo *Dbg = getDbgInfo())&#13;
    Inst-&gt;setDebugLoc(Dbg-&gt;getDebugLoc(Loc));&#13;
}</pre>			<p>In this way, you can add the debug information for your compiler.</p>&#13;
			<h1 id="_idParaDest-114"><a id="_idTextAnchor116"/>Summary</h1>&#13;
			<p>In this chapter, you learned how throwing and catching exceptions work in LLVM and the IR you can generate to exploit this feature. To enhance the scope of IR, you learned how you can attach various metadata to instructions. Metadata for type-based alias analysis provides additional information to the LLVM optimizer and helps with certain optimizations to produce better machine code. Users always appreciate the possibility of using a source-level debugger, and by adding debug information to the IR code, you can implement this important feature of a compiler.</p>&#13;
			<p>Optimizing the IR code is the core task of LLVM. In the next chapter, we will learn how the pass manager works and how we can influence the optimization pipeline the pass manager governs.</p>&#13;
		</p>&#13;
	</div></body></html>