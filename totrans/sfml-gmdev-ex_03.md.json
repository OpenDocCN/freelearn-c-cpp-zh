["```cpp\nstruct SnakeSegment{\n    SnakeSegment(int x, int y) : position(x,y){}\n    sf::Vector2i position;\n};\n```", "```cpp\nusing SnakeContainer = std::vector<SnakeSegment>;\n```", "```cpp\nstd::vector<SnakeSegment>::iterator someIterator = ...\n```", "```cpp\nenum class Direction{ None, Up, Down, Left, Right };\n```", "```cpp\nclass Snake{\npublic:\n    Snake(int l_blockSize);\n    ~Snake();\n\n    // Helper methods.\n    void SetDirection(Direction l_dir);\n    Direction GetDirection();\n    int GetSpeed();\n    sf::Vector2i GetPosition();\n    int GetLives();\n    int GetScore();\n    void IncreaseScore();\n    bool HasLost();\n\n    void Lose(); // Handle losing here.\n    void ToggleLost();\n\n    void Extend(); // Grow the snake.\n    void Reset(); // Reset to starting position.\n\n    void Move(); // Movement method.\n    void Tick(); // Update method.\n    void Cut(int l_segments); // Method for cutting snake.\n    void Render(sf::RenderWindow& l_window);\nprivate:\n    void CheckCollision(); // Checking for collisions.\n\n    SnakeContainer m_snakeBody; // Segment vector.\n    int m_size; // Size of the graphics.\n    Direction m_dir; // Current direction.\n    int m_speed; // Speed of the snake.\n    int m_lives; // Lives.\n    int m_score; // Score.\n    bool m_lost; // Losing state.\n    sf::RectangleShape m_bodyRect; // Shape used in rendering.\n};\n```", "```cpp\nSnake::Snake(int l_blockSize){\n    m_size = l_blockSize;\n    m_bodyRect.setSize(sf::Vector2f(m_size - 1, m_size - 1));\n    Reset();\n}\nSnake::~Snake(){}\n```", "```cpp\nvoid Snake::Reset(){\n    m_snakeBody.clear();\n\n    m_snakeBody.push_back(SnakeSegment(5,7));\n    m_snakeBody.push_back(SnakeSegment(5,6));\n    m_snakeBody.push_back(SnakeSegment(5,5));\n\n    SetDirection(Direction::None); // Start off still.\n    m_speed = 15;\n    m_lives = 3;\n    m_score = 0;\n    m_lost = false;\n}\n```", "```cpp\nvoid Snake::SetDirection(Direction l_dir){ m_dir = l_dir; }\nDirection Snake::GetDirection(){ return m_dir; }\nint Snake::GetSpeed(){ return m_speed; }\n\nsf::Vector2i Snake::GetPosition(){\n   return (!m_snakeBody.empty() ?\n      m_snakeBody.front().position : sf::Vector2i(1,1));\n}\n\nint Snake::GetLives(){ return m_lives; }\nint Snake::GetScore(){ return m_score; }\n\nvoid Snake::IncreaseScore(){ m_score += 10; }\nbool Snake::HasLost(){ return m_lost; }\nvoid Snake::Lose(){ m_lost = true; }\nvoid Snake::ToggleLost(){ m_lost = !m_lost; }\n```", "```cpp\nvoid Snake::Extend(){\n  if (m_snakeBody.empty()){ return; }\n  SnakeSegment& tail_head = \n    m_snakeBody[m_snakeBody.size() - 1];\n\n  if(m_snakeBody.size() > 1){\n    SnakeSegment& tail_bone = \n      m_snakeBody[m_snakeBody.size() - 2];\n\n    if(tail_head.position.x == tail_bone.position.x){\n      if(tail_head.position.y > tail_bone.position.y){\n        m_snakeBody.push_back(SnakeSegment(\n          tail_head.position.x, tail_head.position.y + 1));\n      } else {\n        m_snakeBody.push_back(SnakeSegment(\n          tail_head.position.x, tail_head.position.y - 1));\n      }\n    } else if(tail_head.position.y == tail_bone.position.y){\n      if(tail_head.position.x > tail_bone.position.x){\n        m_snakeBody.push_back(SnakeSegment(\n          tail_head.position.x + 1, tail_head.position.y));\n      } else {\n        m_snakeBody.push_back(SnakeSegment(\n          tail_head.position.x - 1, tail_head.position.y));\n      }\n    }\n  } else {\n    if(m_dir == Direction::Up){\n      m_snakeBody.push_back(SnakeSegment(\n        tail_head.position.x, tail_head.position.y + 1));\n    } else if (m_dir == Direction::Down){\n      m_snakeBody.push_back(SnakeSegment(\n        tail_head.position.x, tail_head.position.y - 1));\n    } else if (m_dir == Direction::Left){\n      m_snakeBody.push_back(SnakeSegment(\n        tail_head.position.x + 1, tail_head.position.y));\n    } else if (m_dir == Direction::Right){\n      m_snakeBody.push_back(SnakeSegment(\n        tail_head.position.x - 1, tail_head.position.y));\n    }\n  }\n}\n```", "```cpp\nvoid Snake::Tick(){\n    if (m_snakeBody.empty()){ return; }\n    if (m_dir == Direction::None){ return; }\n    Move();\n    CheckCollision();\n}\n```", "```cpp\nvoid Snake::Move(){\n   for (int i = m_snakeBody.size() - 1; i > 0; --i){\n      m_snakeBody[i].position = m_snakeBody[i - 1].position;\n   }\n   if (m_dir == Direction::Left){\n      --m_snakeBody[0].position.x;\n   } else if (m_dir == Direction::Right){\n      ++m_snakeBody[0].position.x;\n   } else if (m_dir == Direction::Up){\n      --m_snakeBody[0].position.y;\n   } else if (m_dir == Direction::Down){\n      ++m_snakeBody[0].position.y;\n   }\n}\n```", "```cpp\nvoid Snake::CheckCollision(){\n   if (m_snakeBody.size() < 5){ return; }\n   SnakeSegment& head = m_snakeBody.front();\n   for(auto itr = m_snakeBody.begin() + 1; \n      itr != m_snakeBody.end(); ++itr)\n   {\n      if(itr->position == head.position){\n         int segments = m_snakeBody.end() - itr;\n         Cut(segments);\n         break;\n      }\n   }\n}\n```", "```cpp\nvoid Snake::Cut(int l_segments){\n   for (int i = 0; i < l_segments; ++i){\n      m_snakeBody.pop_back();\n   }\n   --m_lives;\n   if (!m_lives){ Lose(); return; }\n}\n```", "```cpp\nvoid Snake::Render(sf::RenderWindow& l_window){\n   if (m_snakeBody.empty()){ return; }\n\n   auto head = m_snakeBody.begin();\n   m_bodyRect.setFillColor(sf::Color::Yellow);\n   m_bodyRect.setPosition(head->position.x * m_size,\n      head->position.y * m_size);\n   l_window.draw(m_bodyRect);\n\n   m_bodyRect.setFillColor(sf::Color::Green);\n   for(auto itr = m_snakeBody.begin() + 1;\n      itr != m_snakeBody.end(); ++itr)\n   {\n      m_bodyRect.setPosition(itr->position.x * m_size, \n         itr->position.y * m_size);\n      l_window.draw(m_bodyRect);\n   }\n}\n```", "```cpp\nclass World{\npublic:\n    World(sf::Vector2u l_windSize);\n    ~World();\n\n    int GetBlockSize();\n\n    void RespawnApple();\n\n    void Update(Snake& l_player);\n    void Render(sf::RenderWindow& l_window);\nprivate:\n    sf::Vector2u m_windowSize;\n    sf::Vector2i m_item;\n    int m_blockSize;\n\n    sf::CircleShape m_appleShape;\n    sf::RectangleShape m_bounds[4];\n};\n```", "```cpp\nWorld::World(sf::Vector2u l_windSize){\n  m_blockSize = 16;\n\n  m_windowSize = l_windSize;\n  RespawnApple();\n  m_appleShape.setFillColor(sf::Color::Red);\n  m_appleShape.setRadius(m_blockSize / 2);\n\n  for(int i = 0; i < 4; ++i){\n    m_bounds[i].setFillColor(sf::Color(150,0,0));\n    if(!((i + 1) % 2)){\n      m_bounds[i].setSize(sf::Vector2f(m_windowSize.x,\n        m_blockSize));\n    } else {\n      m_bounds[i].setSize(sf::Vector2f(m_blockSize,\n        m_windowSize.y));\n    }\n    if(i < 2){\n      m_bounds[i].setPosition(0,0);\n    } else {\n      m_bounds[i].setOrigin(m_bounds[i].getSize());\n      m_bounds[i].setPosition(sf::Vector2f(m_windowSize));\n    }\n  }\n}\n\nWorld::~World(){}\n```", "```cpp\nvoid World::RespawnApple(){\n    int maxX = (m_windowSize.x / m_blockSize) - 2;\n    int maxY = (m_windowSize.y / m_blockSize) - 2;\n    m_item = sf::Vector2i(\n        rand() % maxX + 1, rand() % maxY + 1);\n    m_appleShape.setPosition(\n        m_item.x * m_blockSize,\n        m_item.y * m_blockSize);\n}\n```", "```cpp\nvoid World::Update(Snake& l_player){\n    if(l_player.GetPosition() == m_item){\n        l_player.Extend();\n        l_player.IncreaseScore();\n        RespawnApple();\n    }\n\n    int gridSize_x = m_windowSize.x / m_blockSize;\n    int gridSize_y = m_windowSize.y / m_blockSize;\n\n    if(l_player.GetPosition().x <= 0 ||\n        l_player.GetPosition().y <= 0 ||\n        l_player.GetPosition().x >= gridSize_x â€“ 1 ||\n        l_player.GetPosition().y >= gridSize_y - 1)\n    {\n            l_player.Lose();\n    }\n}\n```", "```cpp\nvoid World::Render(sf::RenderWindow& l_window){\n    for(int i = 0; i < 4; ++i){\n        l_window.draw(m_bounds[i]);\n    }\n    l_window.draw(m_appleShape);\n}\n```", "```cpp\nint World::GetBlockSize(){ return m_blockSize; }\n```", "```cpp\nclass Game{\n...\nprivate:\n...\n    World m_world;\n    Snake m_snake;\n};\n```", "```cpp\nGame::Game(): m_window(\"Snake\", sf::Vector2u(800, 600)),m_snake(m_world.GetBlockSize()),m_world(sf::Vector2u(800,600))\n{\n    ...\n}\n```", "```cpp\nif(sf::Keyboard::isKeyPressed(sf::Keyboard::Up) \n   && m_snake.GetDirection() != Direction::Down)\n{\n   m_snake.SetDirection(Direction::Up);\n} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Down) \n   && m_snake.GetDirection() != Direction::Up)\n{\n   m_snake.SetDirection(Direction::Down);\n} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Left) \n   && m_snake.GetDirection() != Direction::Right)\n{\n   m_snake.SetDirection(Direction::Left);\n} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Right) \n   && m_snake.GetDirection() != Direction::Left)\n{\n   m_snake.SetDirection(Direction::Right);\n}\n```", "```cpp\nvoid Game::Update(){\n...\n    float timestep = 1.0f / m_snake.GetSpeed();\n\n    if(m_elapsed >= timestep){\n        m_snake.Tick();\n        m_world.Update(m_snake);\n        m_elapsed -= timestep;\n        if(m_snake.HasLost()){\n            m_snake.Reset();\n        }\n    }\n...\n}\n```", "```cpp\nvoid Game::Render(){\n    m_window.BeginDraw();\n    // Render here.\n    m_world.Render(*m_window.GetRenderWindow());\n    m_snake.Render(*m_window.GetRenderWindow());\n\n    m_window.EndDraw();\n}\n```", "```cpp\nif(var1 != something && var2 == something && var3 == true && var4 == !var3 ...)\n```", "```cpp\nDirection Snake::GetPhysicalDirection(){\n    if(m_snakeBody.size() <= 1){\n        return Direction::None;\n    }\n\n    SnakeSegment& head = m_snakeBody[0];\n    SnakeSegment& neck = m_snakeBody[1];\n\n    if(head.position.x == neck.position.x){\n        return (head.position.y > neck.position.y ? Direction::Down : Direction::Up);\n    } else if(head.position.y == neck.position.y){\n        return (head.position.x > neck.position.x ? Direction::Right : Direction::Left);\n    }\n\n    return Direction::None;\n}\n```", "```cpp\nif(sf::Keyboard::isKeyPressed(sf::Keyboard::Up) && m_snake.GetPhysicalDirection() != Direction::Down)\n{\n    m_snake.SetDirection(Direction::Up);\n} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Down) && m_snake.GetPhysicalDirection() != Direction::Up)\n{\n    m_snake.SetDirection(Direction::Down);\n} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Left) && m_snake.GetPhysicalDirection() != Direction::Right)\n{\n    m_snake.SetDirection(Direction::Left);\n} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Right) && m_snake.GetPhysicalDirection() != Direction::Left)\n{\n    m_snake.SetDirection(Direction::Right);\n}\n```", "```cpp\nusing MessageContainer = std::vector<std::string>;\n\nclass Textbox{\npublic:\n    Textbox();\n    Textbox(int l_visible, int l_charSize, int l_width, sf::Vector2f l_screenPos);\n    ~Textbox();\n\n    void Setup(int l_visible, int l_charSize, int l_width, sf::Vector2f l_screenPos);\n    void Add(std::string l_message);\n    void Clear();\n\n    void Render(sf::RenderWindow& l_wind);\nprivate:\n    MessageContainer m_messages;\n    int m_numVisible;\n\n    sf::RectangleShape m_backdrop;\n    sf::Font m_font;\n    sf::Text m_content;\n};\n```", "```cpp\nTextbox::Textbox(){\n    Setup(5,9,200,sf::Vector2f(0,0));\n}\n\nTextbox::Textbox(int l_visible, int l_charSize, \nint l_width, sf::Vector2f l_screenPos){\n    Setup(l_visible, l_charSize, l_width, l_screenPos);\n}\n\nTextbox::~Textbox(){ Clear(); }\n```", "```cpp\nvoid Textbox::Setup(int l_visible, int l_charSize, int l_width, sf::Vector2f l_screenPos)\n{\n    m_numVisible = l_visible;\n\n    sf::Vector2f l_offset(2.0f, 2.0f);\n\n    m_font.loadFromFile(\"arial.ttf\");\n    m_content.setFont(m_font);\n    m_content.setString(\"\");\n    m_content.setCharacterSize(l_charSize);\n    m_content.setColor(sf::Color::White);\n    m_content.setPosition(l_screenPos + l_offset);\n\n    m_backdrop.setSize(sf::Vector2f(\n        l_width, (l_visible * (l_charSize * 1.2f))));\n    m_backdrop.setFillColor(sf::Color(90,90,90,90));\n    m_backdrop.setPosition(l_screenPos);\n}\n```", "```cpp\nvoid Textbox::Add(std::string l_message){\n    m_messages.push_back(l_message);\n    if(m_messages.size() < 6){ return; }\n    m_messages.erase(m_messages.begin());\n}\n\nvoid Textbox::Clear(){ m_messages.clear(); }\n```", "```cpp\nvoid Textbox::Render(sf::RenderWindow& l_wind){\n  std::string l_content;\n\n  for(auto &itr : m_messages){\n    l_content.append(itr+\"\\n\");\n  }\n\n  if(l_content != \"\"){\n    m_content.setString(l_content);\n    l_wind.draw(m_backdrop);\n    l_wind.draw(m_content);\n  }\n}\n```", "```cpp\nGame::Game() ... {\n...\n    m_textbox.Setup(5,14,350,sf::Vector2f(225,0));\n...\n    m_textbox.Add(\"Seeded random number generator with: \" + std::to_string(time(NULL)));\n}\n```", "```cpp\nvoid Game::Render(){\n    m_window.BeginDraw();\n    // Render here.\n    m_world.Render(*m_window.GetRenderWindow());\n    m_snake.Render(*m_window.GetRenderWindow());\n    m_textbox.Render(*m_window.GetRenderWindow());\n\n    m_window.EndDraw();\n}\n```", "```cpp\nsrand(time(nullptr));\n```", "```cpp\nusing SnakeContainer = std::vector<SnakeSegment>;\n```", "```cpp\nUsing SnakeContainer = std::deque<SnakeSegment>;\n```"]