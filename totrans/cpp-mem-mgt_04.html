<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-62"><a id="_idTextAnchor062"/>4</h1>
<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/>Using Destructors</h1>
<p>Our journey to a better and deeper understanding of memory management in C++ now emerges into the world of clean code and contemporary practices. In previous chapters we have explored fundamental concepts of in-memory representation (what are objects, references, pointers, and so on), what pitfalls await us if we stray from sound programming practices in inappropriate ways, and how we can lie to the type system in a controlled and disciplined manner, all of which will be helpful in the rest of this book. We will now discuss fundamental aspects of resource management in our language; memory being a special kind of resource, the ideas and techniques found in this chapter will help us write clean and robust code, including code that performs memory management tasks.</p>
<p>C++ is a programming language that supports (among other paradigms) object-oriented programming, but with actual objects. This sounds like a jest of sorts, but it’s actually a true statement: many languages only provide indirect access to objects (through pointers or references), which means that in these languages the semantics of assignment are usually sharing the referred <a id="_idIndexMarker196"/>object (<em class="italic">the pointee</em>). There are upsides to this, of course: for example, copying a reference typically cannot fail whereas copying an object can fail if the copy constructor or copy assignment (depending on the situation) throws an exception.</p>
<p>In C++, by default, programs use objects, copy objects, assign to objects, and so on, and indirect access is opt-in, requiring additional syntax both for pointers and references. This requires C++ programmers to think about object lifetimes, what it means to copy an object, what it means to move from an object… These can be deep topics depending on the types involved.</p>
<p class="callout-heading">Note</p>
<p class="callout">See <a href="B21071_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a> for more information on objects and object lifetime, including the role of constructors and destructors.</p>
<p>Even if having actual objects in your source code requires adjusting your mindset when programming, it also provides a significant advantage: automatic objects are destroyed when they reach the end of the scope in which they were declared (when they reach the closing brace of that scope) and when an object gets destroyed a special function, the type’s <code>}</code>, the closing brace.</p>
<p>In this chapter, we will look at what destructors do, what they should not do, when they should be written (and when we should stick to what the compiler does by default), as well as how our code can use destructors effectively to manage resources in general… and memory more specifically. Then, we will take a quick look at some key types from the standard library that use destructors to our advantage.</p>
<p>In more detail, in his chapter, we will:</p>
<ul>
<li>Provide a general overview of how resources can be managed safely in C++;</li>
<li>Take a close look at the RAII idiom, a well-known idiomatic practice that uses an object’s lifetime to ensure that resources managed by that object are properly released;</li>
<li>Examine some pitfalls associated with automated resource management;</li>
<li>Give a quick overview of some automated resource management tools provided by the standard library.</li>
</ul>
<p>By the end of this chapter, we will understand the most common ideas and practices one associates with resource management in C++. This will allow us to build more powerful abstractions throughout the remainder of the book.</p>
<h1 id="_idParaDest-64">Technical requiremen<a id="_idTextAnchor064"/>ts</h1>
<p>You can find the code files for this chapter in the book’s GitHub repository here: <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter4">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter4</a>.</p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/>On destructors: a short recap</h1>
<p>This chapter aims to <a id="_idIndexMarker199"/>discuss the use of destructors to manage resources, in particular memory, but since we discussed destructors a while ago (in <a href="B21071_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>) we will allow ourselves a quick recap of the basic idea behind this powerful idea:</p>
<ul>
<li>When an object reaches the end of its lifetime, a special member function called the destructor is called. For some class <code>X</code>, that member function is named <code>X::~X()</code>. This function is an occasion for type <code>X</code> to perform a few “last-minute” actions before concluding its lifetime. As we will discuss in this chapter, one idiomatic use of the destructor is to release resources held by the object being destroyed;</li>
<li>In a class hierarchy, when an object reaches the end of its lifetime, what happens is (a) the destructor for that object gets called, then the same goes for (b) the destructor of each of its non-<code>static</code> data member in order of declaration followed by (c) the destructor of each of its base class sub-objects (its “parents”, informally) in order of declaration;</li>
<li>When explicitly destroying an object through the application of <code>operator delete</code> on a pointer, the resulting process involves the destruction of the pointee followed by the deallocation of the memory block where the object was located. Unsurprisingly, there are caveats to this as we will see <a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic">Chapter 7</em></a>;</li>
<li>In some situations, notably when some class <code>X</code> exposes at least one <code>virtual </code>member function, this sends the message that an <code>X*</code> might in practice point to an object of a class <code>Y</code> directly or indirectly derived from <code>X</code>. To ensure that the destructor of <code>Y</code> is actually called, not the destructor of <code>X</code>, it is customary to also qualify <code>X::~X()</code> as <code>virtual</code>. Not doing so risks not calling the correct destructor, leading to resource leaks.</li>
</ul>
<p>For a small example, consider the following:</p>
<pre class="source-code">
#include &lt;iostream&gt;
struct Base {
    ~Base() { std::cout &lt;&lt; "~Base()\n"; }
};
struct DerivedA : Base {
    ~DerivedA() { std::cout &lt;&lt; "~DerivedA()\n"; }
};
struct VirtBase {
    virtual ~VirtBase() {
       std::cout &lt;&lt; "~VirtBase()\n";
    }
};
struct DerivedB : VirtBase {
    ~DerivedB() {
       std::cout &lt;&lt; "~DerivedB()\n";
    }
};
int main() {
   {
      Base base;
   }
   {
      DerivedA derivedA;
   }
   std::cout &lt;&lt; "----\n";
   Base *pBase = new DerivedA;
   delete pBase; // bad
   VirtBase *pVirtBase = new DerivedB;
   delete pVirtBase; // Ok
}</pre> <p>If you run that code, you will see one destructor called for <code>base</code> and two called for <code>derivedA</code>: the derived class’ destructor followed by the base class’ destructor. This is as expected, and this part of the code is correct.</p>
<p>The problematic case is <code>pBase</code>, a pointer of type <code>Base*</code> which points to an object of a class derived from <code>Base</code>, as the destructor of <code>Base</code> is not <code>virtual</code> which indicates that trying to <code>delete</code> the derived object through a pointer to the base class is probably a breach of intent: <code>delete pBase</code> only calls <code>Base::~Base()</code>, never calling <code>DerivedA::~DerivedA()</code>. With <code>pVirtBase</code> this problem is avoided as <code>VirtBase::~VirtBase()</code> is <code>virtual</code>.</p>
<p>Of course, in C++, we have options because there are always surprising use-cases that come up, and we will see one in <a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic">Chapter 7</em></a> where we will delete a pointer-to-derived from a pointer-to-base without the mediation of a <code>virtual</code> destructor for good (if specialized) reasons.</p>
<p>Note that <code>virtual</code> member functions are useful, but they have costs: a typical implementation will make a table of function pointers per type with at least one <code>virtual</code> member function and store a pointer to that table in each such object, which makes objects slightly bigger. As such, use <code>virtual</code> destructors when you expect to use a pointer to a derived object from a pointer to one of its bases, particularly when you expect the <a id="_idIndexMarker200"/>destructor to be called through a pointer to said base class.</p>
<p>With that being said, let’s examine how all this relates to resource management.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/>Managing resources</h1>
<p>Suppose you<a id="_idIndexMarker201"/> are writing a<a id="_idIndexMarker202"/> function that opens a file, reads from it, and closes it afterward. You are developing on a procedural platform (like most operating system APIs are) offering a set of functions to perform these tasks. Note that all “operating system” functions in this example are deliberately fictional but resemble their real-world counterparts. The functions interesting to us in that API are:</p>
<pre class="source-code">
// opens the file called "name", returns a pointer
// to a file descriptor for that file (nullptr on failure)
FILE *open_file(const char *name);
// returns the number of bytes read from the file into
// buf. Preconditions: file is non-null and valid, buf
// points to a buffer of at least capacity bytes, and
// capacity &gt;= 0
int read_from(FILE *file, char *buf, int capacity);
// closes file. Precondition: file is non-null and valid,
void close_file(FILE *file);</pre> <p>Suppose your code needs to process the data read from the file, but that this processing can throw an exception. The reason for that exception is unimportant here: it can be corrupt data, failure<a id="_idIndexMarker203"/> to allocate memory, calling some auxiliary function that<a id="_idIndexMarker204"/> throws, and so on. The key point is that there is a risk that the function will throw.</p>
<p>If we try to write code for that function naïvely, it might look like this:</p>
<pre class="source-code">
void f(const char *name) {
   FILE *file = open_file(name);
   if(!file) return false; // failure
   vector&lt;char&gt; v;
   char buf[N]; // N is a positive integral constant
   for(int n = read_from(file, buf, N); n != 0;
       n = read_from(file, buf, N))
      v.insert(end(v), buf + 0, buf + n);
   process(v); // our processing function
   close_file(file);
}</pre> <p>That code works, and in the absence of exceptions does pretty much what we want. Now, suppose <code>process(v)</code> throws an exception… What happens?</p>
<p>In this case, function <code>f()</code> exits, failing to meet its postconditions. The call to <code>process(v)</code> never concludes… and <code>close_file(file);</code> never gets called. We have a leak. Not necessarily a <em class="italic">memory</em> leak, but a leak nonetheless as <code>file</code> never gets closed, since an exception thrown from <code>process()</code> but not caught in calling code <code>f()</code> will conclude <code>f()</code> and let the exception flow through to<code> f()</code>’s caller (and so on, until caught or until the program crashes, whichever comes first).</p>
<p>There are ways around this situation. One is to proceed “manually” and add a <code>try</code> … <code>catch</code> block <a id="_idIndexMarker205"/>around the<a id="_idIndexMarker206"/> code that could throw:</p>
<pre class="source-code">
void f(const char *name) {
   FILE *file = open_file(name);
   if(!file) return; // failure
   vector&lt;char&gt; v;
   char buf[N]; // N is a positive integral constant
   try {
      for(int n = read_from(file, buf, N); n != 0;
          n = read_from(file, buf, N))
         v.insert(end(v), buf + 0, buf + n);
      process(v); // our processing function
      close_file(file);
   } catch(...) { // catch anything
      close_file(file);
      throw; // re-throw what we caught
   }
}</pre> <p>I agree this is a bit “clunky”, with two occurrences of <code>close_file(file)</code>, one at the end of the <code>try</code> block to close the file under normal occurrences, and another at the end of the <code>catch</code> block to avoid leaking the file’s resources.</p>
<p>The manual approach can be made to work, but that is a brittle approach to the problem: in C++, any function that is neither <code>noexcept</code> nor <code>noexcept(true)</code> could throw; this<a id="_idIndexMarker207"/> means<a id="_idIndexMarker208"/> that in practice, almost any expression could throw.</p>
<p class="callout-heading">Catching anything</p>
<p class="callout">In C++, there’s no single, mandated base class for all exception types as one could see in some other languages. Indeed, <code>throw 3;</code> is totally legal C++ code. On top of this, C++ has extremely powerful generic programming mechanisms which makes generic code prevalent in our language. Consequently, we often find ourselves calling functions that could throw but for which we cannot really know what could be thrown. Know that <code>catch(...)</code> will catch any C++ object used to represent an exception: you will not know <em class="italic">what</em> you caught, but you <em class="italic">will</em> have caught it.</p>
<p class="callout">In such cases, we will typically want to intercept exceptions, probably to do some cleanup, then let that exception continue on its way unchanged in order to let client code deal with it as needed. The cleanup part is because we want our function to be <code>catch(...)</code> block, simply use <code>throw;</code> which is said to be the “re-throw”.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/>Exception handling… or not?</h2>
<p>This leads to <a id="_idIndexMarker211"/>another question: in a function such as <code>f()</code> where we only aim to consume data and process it for our purposes, should we really seek to handle exceptions? Think about it: the requirements for throwing an exception are significantly different from those for <em class="italic">handling</em> an exception.</p>
<p>Indeed, we throw an exception from a function to signal that our function cannot achieve its postconditions (it cannot do the task it was meant to do): maybe memory is insufficient, maybe the file to read from does not exist, maybe performing that integral division you asked for would lead to dividing by zero, therefore destroying the universe (and we don’t want that to happen), maybe one of the functions called by our function cannot satisfy its own postconditions in ways we did not foresee or did not want to handle… There are plenty of reasons for a function to fail. Many are the situations where a function might find itself in a position where to proceed further would lead to severe problems, and in some cases (constructors and overloaded operators come to mind) exceptions really are the only sensible way to signal a problem to client code.</p>
<p>Handling an exception per se is a much rarer occurrence: to throw an exception, one has to recognize a problem, but to handle an exception one needs an understanding of context. Indeed, the actions one would perform in reaction to an exception in an interactive console application are different from those performed for an audio application when people are moving on the dance floor, or from those required when facing a nuclear code meltdown.</p>
<p>Most functions need to be exception-safe to some extent (there are flavors to this) more than they need to handle the problem. In our example, the difficulties stem from the manual closing of <code>file</code> in the advent of an exception. The easiest way to avoid this manual resource handling is to automate it, and what happens at the end of a function whether that function completes normally (reaching the function’s closing brace, hitting a <code>return</code> statement, seeing an exception “fly by”) is better modelled by a destructor. This practice has become <a id="_idIndexMarker212"/>so well ingrained in C++ programmers’ practices that it is considered idiomatic and has been given a name: the <em class="italic">RAII idiom</em>.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/>The RAII idiom</h1>
<p>C++ programmers tend <a id="_idIndexMarker213"/>to use destructors <a id="_idIndexMarker214"/>to automate the releasing of resources, and this can truly be said to be an idiomatic programming technique in our language, so much that we have given it a name. Probably not the best of names, but a well-known name nonetheless: <strong class="bold">RAII</strong>, which <a id="_idIndexMarker215"/>stands for <strong class="bold">Resource acquisition is initialization</strong> (some have also suggested <strong class="bold">Responsibility acquisition is initialization</strong>, which also works and carries a similar meaning). The general idea is that objects tend to acquire resources at construction time (or later), but (and more importantly!) that releasing resources held by an object is something that usually should be done at the end of that object’s lifetime. Thus, RAII has more to do with destructors than with constructors, but as I said, we tend to be bad with names and acronyms.</p>
<p>Revisiting our file reading and processing example from the Managing resources section, earlier in this chapter, we can build an RAII resource handler to facilitate file closing regardless of how the function concludes:</p>
<pre class="source-code">
<strong class="bold">class FileCloser { // perfectible, as we will see</strong>
<strong class="bold">   FILE * file;</strong>
<strong class="bold">public:</strong>
<strong class="bold">   FileCloser(FILE *file) : file{ file } {</strong>
<strong class="bold">   }</strong>
<strong class="bold">   ~FileCloser() {</strong>
<strong class="bold">      close_file(file);</strong>
<strong class="bold">   </strong><strong class="bold">}</strong>
<strong class="bold">};</strong>
void f(const char *name) {
   FILE *file = open_file(name);
   if(!file) return; // failure
   <strong class="bold">FileCloser fc{ file }; // &lt;-- fc manages file now</strong>
   vector&lt;char&gt; v;
   char buf[N]; // N is a positive integral constant
   for(int n = read_from(file, buf, N); n != 0;
       n = read_from(file, buf, N))
      v.insert(end(v), buf + 0, buf + n);
   process(v); // our processing function
} <code>FileCloser</code> does will vary with our perception of its role: does this class just manage the closing of the file or does it actually represent the file with all of its services? I went for the former in this case but both options are reasonable: it all depends on the semantics you are seeking to implement. The key point is that by using a <code>FileCloser</code> object, we are relieving client code of a responsibility, instead delegating the responsibility of closing a file to an object that automates this task, simplifying our own code and reducing the risks of inadvertently leaving it open.</p>
<p>This <code>FileCloser</code> object is very specific to our task. We could generalize it in many ways, for example <a id="_idIndexMarker218"/>through <a id="_idIndexMarker219"/>a generic object that performs a user-supplied set of actions when destroyed:</p>
<pre class="source-code">
template &lt;class F&gt; class scoped_finalizer { // simplified
   F f;
public:
   scoped_finalizer(F f) : f{ f } {
   }
   ~scoped_finalizer() {
      f();
   }
};
void f(const char *name) {
   FILE *file = open_file(name);
   if(!file) return; // failure
   <strong class="bold">auto sf = scoped_finalizer{ [&amp;file] {</strong>
<strong class="bold">      close_file(file);</strong>
<strong class="bold">   } }; // &lt;-- sf manages file now</strong>
   vector&lt;char&gt; v;
   char buf[N]; // N is a positive integral constant
   for(int n = read_from(file, buf, N); n != 0;
       n = read_from(file, buf, N))
      v.insert(end(v), buf + 0, buf + n);
   process(v); // our processing function
} <code>using</code> blocks, Java has <code>try</code>-with blocks, Go has a <code>defer</code> keyword, etc., but in C++ the possibility to use scope in order to automate actions, often<a id="_idIndexMarker220"/> related to resource management, flows directly from the type <a id="_idIndexMarker221"/>system and makes objects, not user code, the ones that idiomatically manage resources.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>RAII and C++’s special member functions</h2>
<p><a href="B21071_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a> described<a id="_idIndexMarker222"/> the six special member<a id="_idIndexMarker223"/> functions (default constructor, destructor, copy <a id="_idIndexMarker224"/>constructor, copy assignment, move constructor, and move assignment). When one implements these functions in a class, it usually means that class is responsible for some resource. As mentioned in <a href="B21071_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, when a class does not explicitly manage resources, we can often leave those functions to the compiler and the resulting default behavior will usually lead to simpler and more efficient code.</p>
<p>Consider now that the RAII idiom is mostly about resource management, as we associate the moment of destruction for an object with the act of releasing previously acquired resources. Numerous RAII objects (including classes <code>FileCloser</code> and <code>scoped_finalizer</code> in the preceding examples) can be said to be responsible for the resources we provide them with, which means that copying these objects could induce bugs (who would be responsible for the resources, the original or the copy?). Thus, consider deleting the copy operations for your RAII types unless you have a good reason to implement them explicitly:</p>
<pre class="source-code">
template &lt;class F&gt; class scoped_finalizer {
   F f;
public:
   <strong class="bold">scoped_finalizer(const scoped_finalizer&amp;) = delete;</strong>
<strong class="bold">   scoped_finalizer&amp; operator=</strong>
      <strong class="bold">(const scoped_finalizer&amp;) = delete;</strong>
   scoped_finalizer(F f) : f{ f } {
   }
   ~scoped_finalizer() {
      f();
   }
};</pre> <p>Like most idioms, RAII is a generally accepted good programming practice, but it’s not a panacea and the same goes for the use of destructors in general. We will look at some risks<a id="_idIndexMarker225"/> involved <a id="_idIndexMarker226"/>with<a id="_idIndexMarker227"/> destructors, and how we can avoid getting in such trouble.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/>Some pitfalls</h1>
<p>Destructors are <a id="_idIndexMarker228"/>wonderful. They allow us to automate tasks, they simplify code and they make it safer in general. Still, there are some caveats, some aspects of using destructors that require particular attention.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>Destructors should not throw</h2>
<p>The title of this section says it quite simply: destructors should not throw. They <em class="italic">can</em> throw, but it’s a bad idea to do so.</p>
<p>That might seem surprising at first. After all, constructors can (and do!) throw exceptions. When a constructor throws, it means that the constructor cannot satisfy its postconditions: the object under construction was not constructed (the constructor did not complete!) so that object does not exist. That’s a simple, working model.</p>
<p>If a destructor throws… well, it’s probably the end of your program. Indeed, destructors are implicitly <code>noexcept</code>, which means that throwing from a destructor will call <code>std::terminate()</code> and that will be the end of your program.</p>
<p>Well, you might think, what if I explicitly mark my destructor as <code>noexcept(false)</code> then, thus overriding the default behavior? Well, this can work, but be careful as if a destructor throws during stack unwinding, such as what happens when an exception is already in flight, then this still calls <code>std::terminate()</code> and since you’ve been bad and have broken the rules, the compiler can optimize some of your code away. For example, in the following program it’s quite possible that neither <code>"A\n"</code> nor <code>"B\n"</code> will be printed even though the destructor of <code>Evil</code> has not been called at that point:</p>
<pre class="source-code">
#include &lt;iostream&gt;
class Darn {};
void f() { throw 3; }
struct Evil {
   Evil() { std::cout &lt;&lt; "Evil::Evil()\n"; }
   ~Evil() noexcept(false) {
      std::cout &lt;&lt; "Evil::~Evil()\n";
      throw Darn {};
   }
};
void g() {
    std::cout &lt;&lt; "A\n";
    Evil e;
    std::cout &lt;&lt; "B\n";
    f();
    std::cout &lt;&lt; "C\n";
}
int main() {
   try {
      g();
   } catch(int) {
      std::cerr &lt;&lt; "catch(int)\n";
   } catch(Darn) {
      std::cerr &lt;&lt; "darn...\n";
   }
}</pre> <p>A probable result<a id="_idIndexMarker229"/> from this code can simply be that the program will display nothing at all, and some information to the effect that throwing <code>Darn</code> has led to calling <code>std::terminate()</code> will be output. Why is some of the code (notably the messages we tried to output) visibly removed by the compiler? The answer is that an exception thrown but never caught enters implementation-defined behavior, and the throwing of <code>Darn</code> in this case cannot be caught (it directly calls <code>std::terminate()</code> as it happens during stack unwinding) which lets the compiler optimize our code significantly.</p>
<p>Summarizing: don’t throw from a destructor unless you really know what you’re doing, control the context where it will be called, and have discussed it with others to make sure it’s reasonable even though all evidence points to the contrary. Even then, it’s probably better to look for alternative approaches.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>Know thy destruction order</h2>
<p>The title of this<a id="_idIndexMarker230"/> section might seem like a funny admonition. Why is it important to know about the order in which our objects will be destroyed? After all, the basic rule is simple: construction and destruction of objects are symmetrical, thus objects are destroyed in reverse order of construction… right?</p>
<p>Well, that is the case for local, automatic objects. If you write the following:</p>
<pre class="source-code">
void f() {
   A a; // a's ctor
   B b; // b's ctor
   {
      C c; // c's ctor
   } // c's dtor
   D d; // d's ctor
} // d's dtor, b's dtor, a's dtor (in that order)</pre> <p>… then the order of construction and destruction will be as noted in the comments: automatic objects in scope are destroyed in reverse order of construction, and nested scopes behave as expected.</p>
<p>The situation gets more complex if you add non-automatic objects to the mix. C++ lets one have <code>static</code> objects declared within a function: these are constructed when the function is called for the first time and stay alive from that point on until the end of the program’s execution. C++ lets one have global variables (there are many nuances here with linkage specifications such as <code>static</code> or <code>extern</code>) C++ lets one have <code>static</code> data members in a class: these are essentially global variables too. I won’t even get to <code>thread_local</code> variables here as they are out of scope for this book but if you use them, know that they can be lazily initialized which adds to the complexity of the overall picture. Global objects are destroyed in reverse order of construction, but that order of construction is not always trivial to predict from our human perspective.</p>
<p>Consider the following example, which uses <code>Verbose</code> objects that inform us of their moment of<a id="_idIndexMarker231"/> construction as well as of their moment of destruction:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;format&gt;
struct Verbose {
   int n;
   Verbose(int n) : n{ n } {
      std::cout &lt;&lt; std::format(«Verbose({})\n», n);
   }
   ~Verbose(){
      std::cout &lt;&lt; std::format(«~Verbose({})\n», n);
   }
};
class X {
   static inline Verbose v0 { 0 };
   Verbose v1{ 1 };
};
Verbose v2{ 2 };
static void f() {
    static Verbose v3 { 3 };
    Verbose v4{ 4 };
}
static void g() { // note : never called
    static Verbose v5 { 5 };
}
int main() {
   Verbose v6{ 6 };
   {
      Verbose v7{ 7 };
      f();
      X x;
   }
   f();
   X x;
}</pre> <p>Take a moment to let this example sink in and try to figure out what will be displayed. We have a global object, a <code>static</code> and <code>inline</code> data member in a class, two <code>static</code> objects local to<a id="_idIndexMarker232"/> functions as well as some local automatic objects.</p>
<p>So, what will be displayed if we run this program? If you try it, you should see:</p>
<pre class="console">
Verbose(0)
Verbose(2)
Verbose(6)
Verbose(7)
Verbose(3)
Verbose(4)
~Verbose(4)
Verbose(1)
~Verbose(1)
~Verbose(7)
Verbose(4)
~Verbose(4)
Verbose(1)
~Verbose(1)
~Verbose(6)
~Verbose(3)
~Verbose(2)
~Verbose(0)</pre> <p>The first one to be constructed (and the last one to be destroyed) is <code>v0</code>, the <code>static</code> <code>inline</code> data member. It also happens to be our first global object, followed by <code>v2</code> (our second global object). We then enter <code>main()</code> and create <code>v6</code> which will be destroyed at the end of <code>main()</code>.</p>
<p>Now, if you look at the output for that program, you’ll see that symmetry breaks down at this point since after the construction of <code>v6</code>, we construct <code>v7</code> (in an inner, narrower scope; <code>v7</code> will be destructed soon after) and then call <code>f()</code> for the first time which constructs <code>v3</code>, but <code>v3</code> is a global object and will for that reason be destroyed <em class="italic">after</em> <code>v6</code> and <code>v7</code>.</p>
<p>The overall process is <a id="_idIndexMarker233"/>mechanical and deterministic, but understanding it requires some thought and analysis. If we use our objects’ destructors to release resources, failure to understand what happens and when it happens can lead to our code trying to use resources that have already been freed.</p>
<p>For a concrete example involving a mix of automated and manual resource management, let’s look at something the C++ standard knows nothing about: dynamically linked libraries (<code>.dll</code> files). I’m not going to get into details here, so know that if you are on a Linux machine (using shared objects, <code>.so</code> files) or on a Mac (<code>.dylib</code> files), the general idea’s the same but the function names will differ.</p>
<p>Our program will (a) load a dynamically linked library, (b) get the address of a function, (c) call this function and (d) unload the library. Suppose the library is named <code>Lib</code> and the function we want to call is named <code>factory</code> which returns a <code>X*</code> from which we want to call member function <code>f()</code>:</p>
<pre class="source-code">
#include "Lib.h"
#include &lt;Windows.h&gt; // LoadLibrary, GetProcAddress
int main() {
   using namespace std;
   HMODULE hMod = LoadLibrary(L"Lib.dll");
   // suppose the signature of factory is in Lib.h
   auto factory_ptr = reinterpret_cast&lt;
      decltype(&amp;factory)
   &gt;(GetProcAddress(hMod, "factory"));
   <strong class="bold">X *p = factory_ptr();</strong>
   p-&gt;f();
   <strong class="bold">delete p;</strong>
   FreeLibrary(hMod);
}</pre> <p>You might have noticed<a id="_idIndexMarker234"/> the manual memory management in there: we acquire a resource (a <code>X*</code> pointing to something that’s at least an <code>X</code>) calling <code>factory()</code> through <code>factory_ptr</code>, then we use (call <code>f()</code> on) and manually dispose of the <em class="italic">pointee</em>.</p>
<p>At this point, you’re probably telling yourself that manual resource management’s not the best of ideas (here: what happens to the resource if <code>p-&gt;f()</code> throws?), so you look through the standard and find that an object of type <code>std::unique_ptr</code> will take responsibility over the <em class="italic">pointee</em> and destroy it when its destructor is reached. Beautiful, isn’t it? And indeed it probably is, but consider the following excerpt, rewritten to use a <code>std::unique_ptr</code> and automate the resource management process:</p>
<pre class="source-code">
#include "Lib.h"
<strong class="bold">#include &lt;memory&gt; // std::unique_ptr</strong>
#include &lt;Windows.h&gt; // LoadLibrary, GetProcAddress
int main() {
   using namespace std;
   HMODULE hMod = LoadLibrary(L"Lib.dll");
   // suppose the signature of factory is in Lib.h
   auto factory_ptr = reinterpret_cast&lt;
      decltype(&amp;factory)
   &gt;(GetProcAddress(hMod, "factory"));
   <strong class="bold">std::unique_ptr&lt;X&gt; p { factory_ptr() };</strong>
   p-&gt;f();
   <strong class="bold">// delete p; // not needed anymore</strong>
   FreeLibrary(hMod);
} <code>p</code> is now an RAII object responsible for the destruction of the <em class="italic">pointee</em>. Being destroyed at the closing brace of our <code>main()</code> function, we <a id="_idIndexMarker235"/>know that the destructor of the <em class="italic">pointee</em> will be called even if <code>p-&gt;f()</code> throws, so we consider ourselves more exception-safe than before…</p>
<p>… except that this code crashes on that closing brace! If you investigate the source of the crash, you will probably end up realizing that the crash happens at the point where the destructor of <code>p</code> calls operator <code>delete</code> on the <code>X*</code> it has stored internally. Reading further, you will notice that the reason why this crash happens is that the library the object came from has been freed (call to <code>FreeLibrary()</code>) before the destructor ran.</p>
<p>Does that mean we cannot use an automated memory management tool here? Of course not, but we need to be more careful with the way in which we put object lifetime to contribution. In this example, we want to make sure that <code>p</code> is destroyed before the call to <code>FreeLibrary()</code> happens; this can be achieved through the simple introduction of a scope in our function:</p>
<pre class="source-code">
#include "Lib.h"
#include &lt;memory&gt; // std::unique_ptr
#include &lt;Windows.h&gt; // LoadLibrary, GetProcAddress
int main() {
   using namespace std;
   HMODULE hMod = LoadLibrary(L"Lib.dll");
   // suppose the signature of factory is in Lib.h
   auto factory_ptr = reinterpret_cast&lt;
      decltype(&amp;factory)
   &gt;(GetProcAddress(hMod, "factory"));
   <strong class="bold">{</strong>
<strong class="bold">      std::unique_ptr&lt;X&gt; p { factory_ptr() };</strong>
<strong class="bold">      p-&gt;f();</strong>
<strong class="bold">   </strong><strong class="bold">} // p is destroyed here</strong>
   FreeLibrary(hMod);
}</pre> <p>In this specific example, we could find a simple solution; in other cases we might have to move some declarations around to make sure the scopes in which our objects find themselves don’t <a id="_idIndexMarker236"/>alter the intended semantics of our function. Understanding the order in which objects are destroyed is essential to properly using this precious resource management facility that is the destructor.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/>Standard resource management automation tools</h1>
<p>The standard library<a id="_idIndexMarker237"/> offers a significant <a id="_idIndexMarker238"/>number of classes that manage memory efficiently. One needs only consider the standard containers to see shining examples of the sort. In this section, we will take a quick look at a few examples of types useful for resource management. Far from providing an exhaustive list, we’ll try to show different ways to benefit from the RAII idiom.</p>
<p>As mentioned before, when expressing a type that provides automated resource management, the key aspects of that type’s behavior are expressed through its six special member functions. For that reason, with each of the following types, we will take a brief look at what the semantics of these functions are.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>unique_ptr&lt;T&gt; and shared_ptr&lt;T&gt;</h2>
<p>This short section<a id="_idIndexMarker239"/> aims to provide a brief overview of the two main standard smart pointers types in the C++ standard library: <code>std::unique_ptr&lt;T&gt;</code> and <code>std::shared_ptr&lt;T&gt;</code>. It is meant to provide a broad overview of each type’s role; a more detailed examination of how these types can be used appears in <a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a>, and we will implement simplified versions of both types (as well as of a few other smart pointer types) in <a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>.</p>
<p>We have seen an example using <code>std::unique_ptr&lt;T&gt;</code> earlier in this chapter. An object of this type implements “single ownership of the resource” semantics: an object of type <code>std::unique_ptr&lt;T&gt;</code> is uncopiable, and when provided with a <code>T*</code> to manage, it destroys the <em class="italic">pointee</em> at the end of its lifetime. By default, this type will call <code>delete</code> on the pointer it manages, but it can be made to use some other means of disposal if needed.</p>
<p>A default <code>std::unique_ptr&lt;T&gt;</code> represents an empty object and mostly behaves like a null pointer. Since this type expresses exclusive ownership of a resource, it is uncopiable. Moving from a <code>std::unique_ptr&lt;T&gt;</code> transfers ownership of the resource, leaving the moved-from object into an empty state conceptually analogous to a null pointer. The destructor of this type destroys the resource managed by the object, if any.</p>
<p>Type <code>std::shared_ptr&lt;T&gt;</code> implements “shared ownership of the resource” semantics. With this type, each <code>std::shared_ptr&lt;T&gt;</code> object that co-owns a given pointer shares responsibilities with respect to the pointee’s lifetime and the last co-owner of the resource is responsible for freeing it; as is the case with most smart pointers, this responsibility falls on the object’s destructor. This type is surprisingly complicated to write, even in a somewhat naïve implementation like the one we will write in <a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>, and is less frequently useful than some people think, as the main use case (expressing ownership in the type system for cases where the last owner of the pointee is a priori unknown, something most frequently seen in multithreaded code) is more specialized than many would believe, but when one needs to fill this niche, it’s the kind of type that’s immensely useful.</p>
<p>A default <code>std::shared_ptr&lt;T&gt;</code> also represents an empty object and mostly behaves like a null pointer. Since this type expresses shared ownership of a resource, it is copyable but copying an object means sharing the <em class="italic">pointee</em>; copy assignment releases the resource held by the object on the left hand of the assignment and then shares the resource held by the object on the right side of the assignment between both objects. Moving from a <code>std::unique_ptr&lt;T&gt;</code> transfers ownership of the resource, leaving the moved-from object into an empty state. The destructor of this type releases ownership of the<a id="_idIndexMarker240"/> shared<a id="_idIndexMarker241"/> resource, destroying the resource managed by the object if that object was the last owner thereof.</p>
<p class="callout-heading">What does the “shared” in shared_ptr mean?</p>
<p class="callout">There can be confusion <a id="_idIndexMarker242"/>with respect to what the word “shared” in the name of the <code>std::shared_ptr</code> type actually means. For example, should we use that type whenever we want to share a pointer between caller and callee? Should we use it when whenever client code makes a copy of a pointer with the intent of sharing the pointee, such as when passing a pointer by value to a function or sharing resources stored in a global manager object?</p>
<p class="callout">The short answer is that this is the wrong way to approach smart pointers. Sharing a dynamically allocated resource does not mean co-owning that resource: only the latter is what <code>std::shared_ptr</code> models, whereas the former can be done with much more lightweight types. We will examine this idea in detail in <a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a> from a usage perspective, then reexamine it in <a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a> with our implementer eyes, hopefully building a<a id="_idIndexMarker243"/> more comprehensive understanding of these deep and subtle issues.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>lock_guard and scoped_lock</h2>
<p>Owning a <a id="_idIndexMarker244"/>resource is not limited to owning memory. Indeed, consider the following code excerpt and<a id="_idIndexMarker245"/> suppose that <code>string_mutator</code> is a class used to perform arbitrary transformations to characters in a <code>string</code>, but is expected to be used in a multithreaded context in the sense that one needs to synchronize accesses to that <code>string</code> object:</p>
<pre class="source-code">
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;string_view&gt;
class string_mutator {
   std::string text;
   mutable std::mutex m;
public:
   // note: m in uncopiable so string_mutator
   // also is uncopiable
   string_mutator(std::string_view src)
      : text{ src.begin(), src.end() } {
   }
   template &lt;class F&gt; void operator()(F f) {
      <strong class="bold">m.lock();</strong>
      std::transform(text.begin(), text.end(),
                     text.begin(), f);
      <strong class="bold">m.unlock();</strong>
   }
   std::string grab_snapshot() const {
      <strong class="bold">m.lock();</strong>
      std::string s = text;
      <strong class="bold">m.unlock();</strong>
      return s;
   }
};</pre> <p>In this example, a <code>string_mutator</code> object’s function call operator accepts an arbitrary function <code>f</code> applicable to a <code>char</code> and that returns something that can be converted to a <code>char</code>, then applies <code>f</code> to each <code>char</code> in the sequence. For example, the following call would display <code>"I LOVE </code><code>MY INSTRUCTOR"</code>:</p>
<pre class="source-code">
// ...
string_mutator sm{ "I love my instructor" };
sm([](char c) {
   return static_cast&lt;char&gt;(std::toupper(c));
});
std::cout &lt;&lt; sm.grab_snaphot();
// ...</pre> <p>Now, since <code>string_mutator::operator()(F)</code> accepts any function of the appropriate<a id="_idIndexMarker246"/> signature <a id="_idIndexMarker247"/>as argument, it could among other things accept a function that could throw an exception. Looking at the implementation of that operator, you will notice that with the current (naïve) implementation, this would lock <code>m</code> but never unlock it, a bad situation indeed.</p>
<p>There are languages that offer specialized language constructs to solve this problem. In C++, there’s no need for such specialized support as robust code just flows from the fact that one could write an object that locks a mutex at construction time and unlocks it when destroyed… and that’s pretty much all we need. In C++, the simplest such type is <code>std::lock_guard&lt;M&gt;</code>, where a simple implementation could look like:</p>
<pre class="source-code">
template &lt;class M&gt;
   class lock_guard { // simplified version
      M &amp;m;
   public:
      lock_guard(M &amp;m) : m { m } { m.lock(); }
      ~lock_guard() { m.unlock(); }
      lock_guard(const lock_guard&amp;) = delete;
      lock_guard&amp; operator=(const lock_guard&amp;) = delete;
   };</pre> <p>The simplest types <a id="_idIndexMarker248"/>are often <a id="_idIndexMarker249"/>the best. Indeed, applying this type to our <code>string_mutator</code> example, we end up with a simpler, yet much more robust implementation:</p>
<pre class="source-code">
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;string_view&gt;
class string_mutator {
   std::string text;
   mutable std::mutex m;
public:
   // note: m in uncopiable so string_mutator
   // also is uncopiable
   string_mutator(std::string_view src)
      : text{ src.begin(), src.end() } {
   }
   template &lt;class F&gt; void operator()(F f) {
      <strong class="bold">std::lock_guard lck{ m };</strong>
      std::transform(text.begin(), text.end(),
                     text.begin(), f);
   } <strong class="bold">// implicit m.unlock</strong>
   std::string grab_snapshot() const {
      <strong class="bold">std::lock_guard lck{ m };</strong>
      return text;
   } <strong class="bold">// implicit m.unlock</strong>
};</pre> <p>Clearly, using<a id="_idIndexMarker250"/> destructors<a id="_idIndexMarker251"/> to automate unlocking our mutex is advantageous for cases such as this: it simplifies code and helps make it exception-safe.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>stream objects</h2>
<p>In C++, stream<a id="_idIndexMarker252"/> objects are<a id="_idIndexMarker253"/> also resource owners. Consider the following code example where we copy each byte from file <code>in.txt</code> to the standard output stream:</p>
<pre class="source-code">
#include &lt;fstream&gt;
#include &lt;iostream&gt;
int main() {
   std::ifstream in{ "in.txt" };
   for(char c; in.get(c); )
      std::cout &lt;&lt; c;
}</pre> <p>You might notice a few interesting details in this code: we never call <code>close()</code>, there’s no <code>try</code> block where we would be preparing ourselves for exception management, there’s no call to <code>open()</code> in order to open the file, there’s no explicit check for some end-of-file state… yet, this code works correctly, does what it’s supposed to do, and does not leak resources.</p>
<p>How can such a simple program do all that? Through “the magic of destructors”, or (more precisely) the magic of a good API. Think about it:</p>
<ul>
<li>The constructor’s role is to put the object in a correct initial state. Thus, we use it to open the file as it would be both pointless and inefficient to default-construct the stream, then open it later.</li>
<li>Errors when reading from a stream are not exceptional at all… Think about it, how often do we face errors when reading from a stream? In C++, reading from a stream (here: calling <code>in.get(c)</code>) returns a reference to the stream after reading from it, and that stream behaves like a <code>false</code> Boolean value if the stream is in an error state.</li>
<li>Finally, the destructor of a stream object closes whatever representation of a stream it is responsible for. Calling <code>close()</code> on a stream in C++ is unnecessary most of the time; just using the stream object in a limited scope generally suffices.</li>
</ul>
<p>Destructors (and constructors!), when<a id="_idIndexMarker254"/> used <a id="_idIndexMarker255"/>appropriately, lead <a id="_idIndexMarker256"/>to more robust and simpler code.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>vector&lt;T&gt; and other containers</h2>
<p>We will not <a id="_idIndexMarker257"/>write a full-blown comparison of containers with raw arrays or other low-level constructs such as linked lists with manually managed nodes or dynamic arrays maintained explicitly through client code. We will however examine how one can write containers such as <code>std::vector</code> or <code>std::list</code> in later chapters of this book (<em class="italic">Chapters 12</em>, <em class="italic">13</em>, and <em class="italic">14</em>) when we know a bit more on memory management techniques.</p>
<p>Please note, still, that using <code>std::vector&lt;T&gt;</code> (for example) is not only significantly simpler and safer than managing a dynamically allocated array of <code>T</code>: in practice, it’s most probably significantly <em class="italic">faster</em>, at least if used knowledgeably. As we will come to see, there’s no way users can invest the care and attention that goes into memory management and object creation, destruction and copying or movement that goes in a standard container when writing day-to-day code. The destructor of these types, coupled with the<a id="_idIndexMarker258"/> way their other special member functions are implemented, make them almost as easy to use <a id="_idIndexMarker259"/>as <code>int</code> objects, a worthy goal if there ever was one!</p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/>Summary</h1>
<p>In this chapter, we have discussed some safety-related issues, with a focus on those involving exceptions. We have seen that some standard library types offer specialized semantics with respect to resource management, where “resource” includes but is not limited to memory. In <a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a>, we will spend some time examining how to use and benefit from standard smart pointer; then, in <a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>, we will go further and look at some of the challenges behind writing your own versions of these smart pointers, as well as some other smart pointer-inspired types with other semantics. Then, we will delve into deeper memory management-related concerns.</p>
</div>
</body></html>