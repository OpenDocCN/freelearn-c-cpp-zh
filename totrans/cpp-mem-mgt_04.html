<html><head></head><body>
<div epub:type="chapter" id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-62"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.2.1">Using Destructors</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Our journey to a better and deeper understanding of memory management in C++ now emerges into the world of clean code and contemporary practices. </span><span class="koboSpan" id="kobo.3.2">In previous chapters we have explored fundamental concepts of in-memory representation (what are objects, references, pointers, and so on), what pitfalls await us if we stray from sound programming practices in inappropriate ways, and how we can lie to the type system in a controlled and disciplined manner, all of which will be helpful in the rest of this book. </span><span class="koboSpan" id="kobo.3.3">We will now discuss fundamental aspects of resource management in our language; memory being a special kind of resource, the ideas and techniques found in this chapter will help us write clean and robust code, including code that performs memory </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">management tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">C++ is a programming language that supports (among other paradigms) object-oriented programming, but with actual objects. </span><span class="koboSpan" id="kobo.5.2">This sounds like a jest of sorts, but it’s actually a true statement: many languages only provide indirect access to objects (through pointers or references), which means that in these languages the semantics of assignment are usually sharing the referred </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.6.1">object (</span><em class="italic"><span class="koboSpan" id="kobo.7.1">the pointee</span></em><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">There are upsides to this, of course: for example, copying a reference typically cannot fail whereas copying an object can fail if the copy constructor or copy assignment (depending on the situation) throws </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">an exception.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In C++, by default, programs use objects, copy objects, assign to objects, and so on, and indirect access is opt-in, requiring additional syntax both for pointers and references. </span><span class="koboSpan" id="kobo.10.2">This requires C++ programmers to think about object lifetimes, what it means to copy an object, what it means to move from an object… These can be deep topics depending on the </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">types involved.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.12.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.13.1">See </span><a href="B21071_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.15.1"> for more information on objects and object lifetime, including the role of constructors </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">and destructors.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">Even if having actual objects in your source code requires adjusting your mindset when programming, it also provides a significant advantage: automatic objects are destroyed when they reach the end of the scope in which they were declared (when they reach the closing brace of that scope) and when an object gets destroyed a special function, the type’s </span><strong class="bold"><span class="koboSpan" id="kobo.18.1">destructor</span></strong><span class="koboSpan" id="kobo.19.1">, gets</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.20.1"> called. </span><span class="koboSpan" id="kobo.20.2">This special moment allows us to execute arbitrary code at definite moments and is a part of a key C++ idiom named </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">RAII</span></strong><span class="koboSpan" id="kobo.22.1">, an acronym we will</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.23.1"> explain in the </span><em class="italic"><span class="koboSpan" id="kobo.24.1">The RAII idiom</span></em><span class="koboSpan" id="kobo.25.1"> section later in this chapter. </span><span class="koboSpan" id="kobo.25.2">This has led some luminaries to claim that the most beautiful instruction in C++ is </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">}</span></strong><span class="koboSpan" id="kobo.27.1">, the </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">closing brace.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">In this chapter, we will look at what destructors do, what they should not do, when they should be written (and when we should stick to what the compiler does by default), as well as how our code can use destructors effectively to manage resources in general… and memory more specifically. </span><span class="koboSpan" id="kobo.29.2">Then, we will take a quick look at some key types from the standard library that use destructors to </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">our advantage.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">In more detail, in his chapter, </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">we will:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.33.1">Provide a general overview of how resources can be managed safely </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">in C++;</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Take a close look at the RAII idiom, a well-known idiomatic practice that uses an object’s lifetime to ensure that resources managed by that object are </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">properly released;</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">Examine some pitfalls associated with automated </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">resource management;</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">Give a quick overview of some automated resource management tools provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">standard library.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.41.1">By the end of this chapter, we will understand the most common ideas and practices one associates with resource management in C++. </span><span class="koboSpan" id="kobo.41.2">This will allow us to build more powerful abstractions throughout the remainder of </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">the book.</span></span></p>
<h1 id="_idParaDest-64"><span class="koboSpan" id="kobo.43.1">Technical requiremen</span><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.44.1">ts</span></h1>
<p><span class="koboSpan" id="kobo.45.1">You can find the code files for this chapter in the book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">here: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter4"><span class="No-Break"><span class="koboSpan" id="kobo.47.1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter4</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.48.1">.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.49.1">On destructors: a short recap</span></h1>
<p><span class="koboSpan" id="kobo.50.1">This chapter aims to </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.51.1">discuss the use of destructors to manage resources, in particular memory, but since we discussed destructors a while ago (in </span><a href="B21071_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.52.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.53.1">) we will allow ourselves a quick recap of the basic idea behind this </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">powerful idea:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.55.1">When an object reaches the end of its lifetime, a special member function called the destructor is called. </span><span class="koboSpan" id="kobo.55.2">For some class </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">X</span></strong><span class="koboSpan" id="kobo.57.1">, that member function is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">X::~X()</span></strong><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">This function is an occasion for type </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">X</span></strong><span class="koboSpan" id="kobo.61.1"> to perform a few “last-minute” actions before concluding its lifetime. </span><span class="koboSpan" id="kobo.61.2">As we will discuss in this chapter, one idiomatic use of the destructor is to release resources held by the object </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">being destroyed;</span></span></li>
<li><span class="koboSpan" id="kobo.63.1">In a class hierarchy, when an object reaches the end of its lifetime, what happens is (a) the destructor for that object gets called, then the same goes for (b) the destructor of each of its non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">static</span></strong><span class="koboSpan" id="kobo.65.1"> data member in order of declaration followed by (c) the destructor of each of its base class sub-objects (its “parents”, informally) in order </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">of declaration;</span></span></li>
<li><span class="koboSpan" id="kobo.67.1">When explicitly destroying an object through the application of </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">operator delete</span></strong><span class="koboSpan" id="kobo.69.1"> on a pointer, the resulting process involves the destruction of the pointee followed by the deallocation of the memory block where the object was located. </span><span class="koboSpan" id="kobo.69.2">Unsurprisingly, there are caveats to this as we will see </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.70.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.71.1">;</span></span></li>
<li><span class="koboSpan" id="kobo.72.1">In some situations, notably when some class </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">X</span></strong><span class="koboSpan" id="kobo.74.1"> exposes at least one </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">virtual </span></strong><span class="koboSpan" id="kobo.76.1">member function, this sends the message that an </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">X*</span></strong><span class="koboSpan" id="kobo.78.1"> might in practice point to an object of a class </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">Y</span></strong><span class="koboSpan" id="kobo.80.1"> directly or indirectly derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">X</span></strong><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">To ensure that the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">Y</span></strong><span class="koboSpan" id="kobo.84.1"> is actually called, not the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">X</span></strong><span class="koboSpan" id="kobo.86.1">, it is customary to also qualify </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">X::~X()</span></strong><span class="koboSpan" id="kobo.88.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">virtual</span></strong><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">Not doing so risks not calling the correct destructor, leading to </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">resource leaks.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.92.1">For a small example, consider </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
#include &lt;iostream&gt;
struct Base {
    ~Base() { std::cout &lt;&lt; "~Base()\n"; }
};
struct DerivedA : Base {
    ~DerivedA() { std::cout &lt;&lt; "~DerivedA()\n"; }
};
struct VirtBase {
    virtual ~VirtBase() {
       std::cout &lt;&lt; "~VirtBase()\n";
    }
};
struct DerivedB : VirtBase {
    ~DerivedB() {
       std::cout &lt;&lt; "~DerivedB()\n";
    }
};
int main() {
   {
      Base base;
   }
   {
      DerivedA derivedA;
   }
   std::cout &lt;&lt; "----\n";
   Base *pBase = new DerivedA;
   delete pBase; // bad
   VirtBase *pVirtBase = new DerivedB;
   delete pVirtBase; // Ok
}</span></pre> <p><span class="koboSpan" id="kobo.95.1">If you run that code, you will see one destructor called for </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">base</span></strong><span class="koboSpan" id="kobo.97.1"> and two called for </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">derivedA</span></strong><span class="koboSpan" id="kobo.99.1">: the derived class’ destructor followed by the base class’ destructor. </span><span class="koboSpan" id="kobo.99.2">This is as expected, and this part of the code </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">is correct.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">The problematic case is </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">pBase</span></strong><span class="koboSpan" id="kobo.103.1">, a pointer of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">Base*</span></strong><span class="koboSpan" id="kobo.105.1"> which points to an object of a class derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">Base</span></strong><span class="koboSpan" id="kobo.107.1">, as the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">Base</span></strong><span class="koboSpan" id="kobo.109.1"> is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">virtual</span></strong><span class="koboSpan" id="kobo.111.1"> which indicates that trying to </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">delete</span></strong><span class="koboSpan" id="kobo.113.1"> the derived object through a pointer to the base class is probably a breach of intent: </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">delete pBase</span></strong><span class="koboSpan" id="kobo.115.1"> only calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">Base::~Base()</span></strong><span class="koboSpan" id="kobo.117.1">, never calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">DerivedA::~DerivedA()</span></strong><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">pVirtBase</span></strong><span class="koboSpan" id="kobo.121.1"> this problem is avoided as </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">VirtBase::~VirtBase()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.123.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">virtual</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">Of course, in C++, we have options because there are always surprising use-cases that come up, and we will see one in </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.127.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.128.1"> where we will delete a pointer-to-derived from a pointer-to-base without the mediation of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">virtual</span></strong><span class="koboSpan" id="kobo.130.1"> destructor for good (if </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">specialized) reasons.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">virtual</span></strong><span class="koboSpan" id="kobo.134.1"> member functions are useful, but they have costs: a typical implementation will make a table of function pointers per type with at least one </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">virtual</span></strong><span class="koboSpan" id="kobo.136.1"> member function and store a pointer to that table in each such object, which makes objects slightly bigger. </span><span class="koboSpan" id="kobo.136.2">As such, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">virtual</span></strong><span class="koboSpan" id="kobo.138.1"> destructors when you expect to use a pointer to a derived object from a pointer to one of its bases, particularly when you expect the </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.139.1">destructor to be called through a pointer to said </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">base class.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">With that being said, let’s examine how all this relates to </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">resource management.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.143.1">Managing resources</span></h1>
<p><span class="koboSpan" id="kobo.144.1">Suppose you</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.145.1"> are writing a</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.146.1"> function that opens a file, reads from it, and closes it afterward. </span><span class="koboSpan" id="kobo.146.2">You are developing on a procedural platform (like most operating system APIs are) offering a set of functions to perform these tasks. </span><span class="koboSpan" id="kobo.146.3">Note that all “operating system” functions in this example are deliberately fictional but resemble their real-world counterparts. </span><span class="koboSpan" id="kobo.146.4">The functions interesting to us in that </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">API are:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.148.1">
// opens the file called "name", returns a pointer
// to a file descriptor for that file (nullptr on failure)
FILE *open_file(const char *name);
// returns the number of bytes read from the file into
// buf. </span><span class="koboSpan" id="kobo.148.2">Preconditions: file is non-null and valid, buf
// points to a buffer of at least capacity bytes, and
// capacity &gt;= 0
int read_from(FILE *file, char *buf, int capacity);
// closes file. </span><span class="koboSpan" id="kobo.148.3">Precondition: file is non-null and valid,
void close_file(FILE *file);</span></pre> <p><span class="koboSpan" id="kobo.149.1">Suppose your code needs to process the data read from the file, but that this processing can throw an exception. </span><span class="koboSpan" id="kobo.149.2">The reason for that exception is unimportant here: it can be corrupt data, failure</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.150.1"> to allocate memory, calling some auxiliary function that</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.151.1"> throws, and so on. </span><span class="koboSpan" id="kobo.151.2">The key point is that there is a risk that the function </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">will throw.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">If we try to write code for that function naïvely, it might look </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">
void f(const char *name) {
   FILE *file = open_file(name);
   if(!file) return false; // failure
   vector&lt;char&gt; v;
   char buf[N]; // N is a positive integral constant
   for(int n = read_from(file, buf, N); n != 0;
       n = read_from(file, buf, N))
      v.insert(end(v), buf + 0, buf + n);
   process(v); // our processing function
   close_file(file);
}</span></pre> <p><span class="koboSpan" id="kobo.156.1">That code works, and in the absence of exceptions does pretty much what we want. </span><span class="koboSpan" id="kobo.156.2">Now, suppose </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">process(v)</span></strong><span class="koboSpan" id="kobo.158.1"> throws an exception… </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">What happens?</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">In this case, function </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">f()</span></strong><span class="koboSpan" id="kobo.162.1"> exits, failing to meet its postconditions. </span><span class="koboSpan" id="kobo.162.2">The call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">process(v)</span></strong><span class="koboSpan" id="kobo.164.1"> never concludes… and </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">close_file(file);</span></strong><span class="koboSpan" id="kobo.166.1"> never gets called. </span><span class="koboSpan" id="kobo.166.2">We have a leak. </span><span class="koboSpan" id="kobo.166.3">Not necessarily a </span><em class="italic"><span class="koboSpan" id="kobo.167.1">memory</span></em><span class="koboSpan" id="kobo.168.1"> leak, but a leak nonetheless as </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">file</span></strong><span class="koboSpan" id="kobo.170.1"> never gets closed, since an exception thrown from </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">process()</span></strong><span class="koboSpan" id="kobo.172.1"> but not caught in calling code </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">f()</span></strong><span class="koboSpan" id="kobo.174.1"> will conclude </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">f()</span></strong><span class="koboSpan" id="kobo.176.1"> and let the exception flow through to</span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1"> f()</span></strong><span class="koboSpan" id="kobo.178.1">’s caller (and so on, until caught or until the program crashes, whichever </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">comes first).</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">There are ways around this situation. </span><span class="koboSpan" id="kobo.180.2">One is to proceed “manually” and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">try</span></strong><span class="koboSpan" id="kobo.182.1"> … </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">catch</span></strong><span class="koboSpan" id="kobo.184.1"> block </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.185.1">around the</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.186.1"> code that </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">could throw:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.188.1">
void f(const char *name) {
   FILE *file = open_file(name);
   if(!file) return; // failure
   vector&lt;char&gt; v;
   char buf[N]; // N is a positive integral constant
   try {
      for(int n = read_from(file, buf, N); n != 0;
          n = read_from(file, buf, N))
         v.insert(end(v), buf + 0, buf + n);
      process(v); // our processing function
      close_file(file);
   } catch(...) { // catch anything
      close_file(file);
      throw; // re-throw what we caught
   }
}</span></pre> <p><span class="koboSpan" id="kobo.189.1">I agree this is a bit “clunky”, with two occurrences of </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">close_file(file)</span></strong><span class="koboSpan" id="kobo.191.1">, one at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">try</span></strong><span class="koboSpan" id="kobo.193.1"> block to close the file under normal occurrences, and another at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">catch</span></strong><span class="koboSpan" id="kobo.195.1"> block to avoid leaking the </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">file’s resources.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">The manual approach can be made to work, but that is a brittle approach to the problem: in C++, any function that is neither </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">noexcept</span></strong><span class="koboSpan" id="kobo.199.1"> nor </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">noexcept(true)</span></strong><span class="koboSpan" id="kobo.201.1"> could throw; this</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.202.1"> means</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.203.1"> that in practice, almost any expression </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">could throw.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.205.1">Catching anything</span></p>
<p class="callout"><span class="koboSpan" id="kobo.206.1">In C++, there’s no single, mandated base class for all exception types as one could see in some other languages. </span><span class="koboSpan" id="kobo.206.2">Indeed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">throw 3;</span></strong><span class="koboSpan" id="kobo.208.1"> is totally legal C++ code. </span><span class="koboSpan" id="kobo.208.2">On top of this, C++ has extremely powerful generic programming mechanisms which makes generic code prevalent in our language. </span><span class="koboSpan" id="kobo.208.3">Consequently, we often find ourselves calling functions that could throw but for which we cannot really know what could be thrown. </span><span class="koboSpan" id="kobo.208.4">Know that </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">catch(...)</span></strong><span class="koboSpan" id="kobo.210.1"> will catch any C++ object used to represent an exception: you will not know </span><em class="italic"><span class="koboSpan" id="kobo.211.1">what</span></em><span class="koboSpan" id="kobo.212.1"> you caught, but you </span><em class="italic"><span class="koboSpan" id="kobo.213.1">will</span></em><span class="koboSpan" id="kobo.214.1"> have </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">caught it.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.216.1">In such cases, we will typically want to intercept exceptions, probably to do some cleanup, then let that exception continue on its way unchanged in order to let client code deal with it as needed. </span><span class="koboSpan" id="kobo.216.2">The cleanup part is because we want our function to be </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">exception-safe</span></strong><span class="koboSpan" id="kobo.218.1"> (no leaks, no corrupted state, and so on.) as well as </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">exception-neutral</span></strong><span class="koboSpan" id="kobo.220.1"> (do </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.221.1">not hide the </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.222.1">nature of the problem from those who will want to handle it). </span><span class="koboSpan" id="kobo.222.2">To rethrow whatever exception object you have caught, even from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">catch(...)</span></strong><span class="koboSpan" id="kobo.224.1"> block, simply use </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">throw;</span></strong><span class="koboSpan" id="kobo.226.1"> which is said to be </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">the “re-throw”.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.228.1">Exception handling… or not?</span></h2>
<p><span class="koboSpan" id="kobo.229.1">This leads to </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.230.1">another question: in a function such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">f()</span></strong><span class="koboSpan" id="kobo.232.1"> where we only aim to consume data and process it for our purposes, should we really seek to handle exceptions? </span><span class="koboSpan" id="kobo.232.2">Think about it: the requirements for throwing an exception are significantly different from those for </span><em class="italic"><span class="koboSpan" id="kobo.233.1">handling</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.234.1">an exception.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Indeed, we throw an exception from a function to signal that our function cannot achieve its postconditions (it cannot do the task it was meant to do): maybe memory is insufficient, maybe the file to read from does not exist, maybe performing that integral division you asked for would lead to dividing by zero, therefore destroying the universe (and we don’t want that to happen), maybe one of the functions called by our function cannot satisfy its own postconditions in ways we did not foresee or did not want to handle… There are plenty of reasons for a function to fail. </span><span class="koboSpan" id="kobo.235.2">Many are the situations where a function might find itself in a position where to proceed further would lead to severe problems, and in some cases (constructors and overloaded operators come to mind) exceptions really are the only sensible way to signal a problem to </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">client code.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">Handling an exception per se is a much rarer occurrence: to throw an exception, one has to recognize a problem, but to handle an exception one needs an understanding of context. </span><span class="koboSpan" id="kobo.237.2">Indeed, the actions one would perform in reaction to an exception in an interactive console application are different from those performed for an audio application when people are moving on the dance floor, or from those required when facing a nuclear </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">code meltdown.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Most functions need to be exception-safe to some extent (there are flavors to this) more than they need to handle the problem. </span><span class="koboSpan" id="kobo.239.2">In our example, the difficulties stem from the manual closing of </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">file</span></strong><span class="koboSpan" id="kobo.241.1"> in the advent of an exception. </span><span class="koboSpan" id="kobo.241.2">The easiest way to avoid this manual resource handling is to automate it, and what happens at the end of a function whether that function completes normally (reaching the function’s closing brace, hitting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">return</span></strong><span class="koboSpan" id="kobo.243.1"> statement, seeing an exception “fly by”) is better modelled by a destructor. </span><span class="koboSpan" id="kobo.243.2">This practice has become </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.244.1">so well ingrained in C++ programmers’ practices that it is considered idiomatic and has been given a name: the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.245.1">RAII idiom</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">.</span></span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.247.1">The RAII idiom</span></h1>
<p><span class="koboSpan" id="kobo.248.1">C++ programmers tend </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.249.1">to use destructors </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.250.1">to automate the releasing of resources, and this can truly be said to be an idiomatic programming technique in our language, so much that we have given it a name. </span><span class="koboSpan" id="kobo.250.2">Probably not the best of names, but a well-known name nonetheless: </span><strong class="bold"><span class="koboSpan" id="kobo.251.1">RAII</span></strong><span class="koboSpan" id="kobo.252.1">, which </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.253.1">stands for </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">Resource acquisition is initialization</span></strong><span class="koboSpan" id="kobo.255.1"> (some have also suggested </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">Responsibility acquisition is initialization</span></strong><span class="koboSpan" id="kobo.257.1">, which also works and carries a similar meaning). </span><span class="koboSpan" id="kobo.257.2">The general idea is that objects tend to acquire resources at construction time (or later), but (and more importantly!) that releasing resources held by an object is something that usually should be done at the end of that object’s lifetime. </span><span class="koboSpan" id="kobo.257.3">Thus, RAII has more to do with destructors than with constructors, but as I said, we tend to be bad with names </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">and acronyms.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">Revisiting our file reading and processing example from the Managing resources section, earlier in this chapter, we can build an RAII resource handler to facilitate file closing regardless of how the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">function concludes:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.261.1">class FileCloser { // perfectible, as we will see</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.262.1">   FILE * file;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.263.1">public:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.264.1">   FileCloser(FILE *file) : file{ file } {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.265.1">   }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.266.1">   ~FileCloser() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.267.1">      close_file(file);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.268.1">   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.269.1">}</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.270.1">};</span></strong><span class="koboSpan" id="kobo.271.1">
void f(const char *name) {
   FILE *file = open_file(name);
   if(!file) return; // failure
   </span><strong class="bold"><span class="koboSpan" id="kobo.272.1">FileCloser fc{ file }; // &lt;-- fc manages file now</span></strong><span class="koboSpan" id="kobo.273.1">
   vector&lt;char&gt; v;
   char buf[N]; // N is a positive integral constant
   for(int n = read_from(file, buf, N); n != 0;
       n = read_from(file, buf, N))
      v.insert(end(v), buf + 0, buf + n);
   process(v); // our processing function
} </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">// implicit close_file(file)</span></strong></pre> <p><span class="koboSpan" id="kobo.275.1">The details and </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.276.1">granularity </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.277.1">of what </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">FileCloser</span></strong><span class="koboSpan" id="kobo.279.1"> does will vary with our perception of its role: does this class just manage the closing of the file or does it actually represent the file with all of its services? </span><span class="koboSpan" id="kobo.279.2">I went for the former in this case but both options are reasonable: it all depends on the semantics you are seeking to implement. </span><span class="koboSpan" id="kobo.279.3">The key point is that by using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">FileCloser</span></strong><span class="koboSpan" id="kobo.281.1"> object, we are relieving client code of a responsibility, instead delegating the responsibility of closing a file to an object that automates this task, simplifying our own code and reducing the risks of inadvertently leaving </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">it open.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">FileCloser</span></strong><span class="koboSpan" id="kobo.285.1"> object is very specific to our task. </span><span class="koboSpan" id="kobo.285.2">We could generalize it in many ways, for example </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.286.1">through </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.287.1">a generic object that performs a user-supplied set of actions </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">when destroyed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
template &lt;class F&gt; class scoped_finalizer { // simplified
   F f;
public:
   scoped_finalizer(F f) : f{ f } {
   }
   ~scoped_finalizer() {
      f();
   }
};
void f(const char *name) {
   FILE *file = open_file(name);
   if(!file) return; // failure
   </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">auto sf = scoped_finalizer{ [&amp;file] {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.291.1">      close_file(file);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.292.1">   } }; // &lt;-- sf manages file now</span></strong><span class="koboSpan" id="kobo.293.1">
   vector&lt;char&gt; v;
   char buf[N]; // N is a positive integral constant
   for(int n = read_from(file, buf, N); n != 0;
       n = read_from(file, buf, N))
      v.insert(end(v), buf + 0, buf + n);
   process(v); // our processing function
} </span><strong class="bold"><span class="koboSpan" id="kobo.294.1">// implicit close_file(file) through sf's destructor</span></strong></pre> <p><span class="koboSpan" id="kobo.295.1">The RAII idiom is pretty much everywhere in C++; one could say it’s the language’s most pervasive idiom, and one of its most recognizable and defining programming practice. </span><span class="koboSpan" id="kobo.295.2">Many languages offer similar features today: C# has </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">using</span></strong><span class="koboSpan" id="kobo.297.1"> blocks, Java has </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">try</span></strong><span class="koboSpan" id="kobo.299.1">-with blocks, Go has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">defer</span></strong><span class="koboSpan" id="kobo.301.1"> keyword, etc., but in C++ the possibility to use scope in order to automate actions, often</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.302.1"> related to resource management, flows directly from the type </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.303.1">system and makes objects, not user code, the ones that idiomatically </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">manage resources.</span></span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.305.1">RAII and C++’s special member functions</span></h2>
<p><a href="B21071_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.306.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.307.1"> described</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.308.1"> the six special member</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.309.1"> functions (default constructor, destructor, copy </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.310.1">constructor, copy assignment, move constructor, and move assignment). </span><span class="koboSpan" id="kobo.310.2">When one implements these functions in a class, it usually means that class is responsible for some resource. </span><span class="koboSpan" id="kobo.310.3">As mentioned in </span><a href="B21071_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.311.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.312.1">, when a class does not explicitly manage resources, we can often leave those functions to the compiler and the resulting default behavior will usually lead to simpler and more </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">efficient code.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">Consider now that the RAII idiom is mostly about resource management, as we associate the moment of destruction for an object with the act of releasing previously acquired resources. </span><span class="koboSpan" id="kobo.314.2">Numerous RAII objects (including classes </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">FileCloser</span></strong><span class="koboSpan" id="kobo.316.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">scoped_finalizer</span></strong><span class="koboSpan" id="kobo.318.1"> in the preceding examples) can be said to be responsible for the resources we provide them with, which means that copying these objects could induce bugs (who would be responsible for the resources, the original or the copy?). </span><span class="koboSpan" id="kobo.318.2">Thus, consider deleting the copy operations for your RAII types unless you have a good reason to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">them explicitly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
template &lt;class F&gt; class scoped_finalizer {
   F f;
public:
   </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">scoped_finalizer(const scoped_finalizer&amp;) = delete;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.322.1">   scoped_finalizer&amp; operator=</span></strong><span class="koboSpan" id="kobo.323.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">(const scoped_finalizer&amp;) = delete;</span></strong><span class="koboSpan" id="kobo.325.1">
   scoped_finalizer(F f) : f{ f } {
   }
   ~scoped_finalizer() {
      f();
   }
};</span></pre> <p><span class="koboSpan" id="kobo.326.1">Like most idioms, RAII is a generally accepted good programming practice, but it’s not a panacea and the same goes for the use of destructors in general. </span><span class="koboSpan" id="kobo.326.2">We will look at some risks</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.327.1"> involved </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.328.1">with</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.329.1"> destructors, and how we can avoid getting in </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">such trouble.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.331.1">Some pitfalls</span></h1>
<p><span class="koboSpan" id="kobo.332.1">Destructors are </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.333.1">wonderful. </span><span class="koboSpan" id="kobo.333.2">They allow us to automate tasks, they simplify code and they make it safer in general. </span><span class="koboSpan" id="kobo.333.3">Still, there are some caveats, some aspects of using destructors that require </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">particular attention.</span></span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.335.1">Destructors should not throw</span></h2>
<p><span class="koboSpan" id="kobo.336.1">The title of this section says it quite simply: destructors should not throw. </span><span class="koboSpan" id="kobo.336.2">They </span><em class="italic"><span class="koboSpan" id="kobo.337.1">can</span></em><span class="koboSpan" id="kobo.338.1"> throw, but it’s a bad idea to </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">do so.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">That might seem surprising at first. </span><span class="koboSpan" id="kobo.340.2">After all, constructors can (and do!) throw exceptions. </span><span class="koboSpan" id="kobo.340.3">When a constructor throws, it means that the constructor cannot satisfy its postconditions: the object under construction was not constructed (the constructor did not complete!) so that object does not exist. </span><span class="koboSpan" id="kobo.340.4">That’s a simple, </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">working model.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">If a destructor throws… well, it’s probably the end of your program. </span><span class="koboSpan" id="kobo.342.2">Indeed, destructors are implicitly </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">noexcept</span></strong><span class="koboSpan" id="kobo.344.1">, which means that throwing from a destructor will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">std::terminate()</span></strong><span class="koboSpan" id="kobo.346.1"> and that will be the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">your program.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">Well, you might think, what if I explicitly mark my destructor as </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">noexcept(false)</span></strong><span class="koboSpan" id="kobo.350.1"> then, thus overriding the default behavior? </span><span class="koboSpan" id="kobo.350.2">Well, this can work, but be careful as if a destructor throws during stack unwinding, such as what happens when an exception is already in flight, then this still calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">std::terminate()</span></strong><span class="koboSpan" id="kobo.352.1"> and since you’ve been bad and have broken the rules, the compiler can optimize some of your code away. </span><span class="koboSpan" id="kobo.352.2">For example, in the following program it’s quite possible that neither </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">"A\n"</span></strong><span class="koboSpan" id="kobo.354.1"> nor </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">"B\n"</span></strong><span class="koboSpan" id="kobo.356.1"> will be printed even though the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">Evil</span></strong><span class="koboSpan" id="kobo.358.1"> has not been called at </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">that point:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
#include &lt;iostream&gt;
class Darn {};
void f() { throw 3; }
struct Evil {
   Evil() { std::cout &lt;&lt; "Evil::Evil()\n"; }
   ~Evil() noexcept(false) {
      std::cout &lt;&lt; "Evil::~Evil()\n";
      throw Darn {};
   }
};
void g() {
    std::cout &lt;&lt; "A\n";
    Evil e;
    std::cout &lt;&lt; "B\n";
    f();
    std::cout &lt;&lt; "C\n";
}
int main() {
   try {
      g();
   } catch(int) {
      std::cerr &lt;&lt; "catch(int)\n";
   } catch(Darn) {
      std::cerr &lt;&lt; "darn...\n";
   }
}</span></pre> <p><span class="koboSpan" id="kobo.361.1">A probable result</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.362.1"> from this code can simply be that the program will display nothing at all, and some information to the effect that throwing </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">Darn</span></strong><span class="koboSpan" id="kobo.364.1"> has led to calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">std::terminate()</span></strong><span class="koboSpan" id="kobo.366.1"> will be output. </span><span class="koboSpan" id="kobo.366.2">Why is some of the code (notably the messages we tried to output) visibly removed by the compiler? </span><span class="koboSpan" id="kobo.366.3">The answer is that an exception thrown but never caught enters implementation-defined behavior, and the throwing of </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">Darn</span></strong><span class="koboSpan" id="kobo.368.1"> in this case cannot be caught (it directly calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">std::terminate()</span></strong><span class="koboSpan" id="kobo.370.1"> as it happens during stack unwinding) which lets the compiler optimize our </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">code significantly.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">Summarizing: don’t throw from a destructor unless you really know what you’re doing, control the context where it will be called, and have discussed it with others to make sure it’s reasonable even though all evidence points to the contrary. </span><span class="koboSpan" id="kobo.372.2">Even then, it’s probably better to look for </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">alternative approaches.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.374.1">Know thy destruction order</span></h2>
<p><span class="koboSpan" id="kobo.375.1">The title of this</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.376.1"> section might seem like a funny admonition. </span><span class="koboSpan" id="kobo.376.2">Why is it important to know about the order in which our objects will be destroyed? </span><span class="koboSpan" id="kobo.376.3">After all, the basic rule is simple: construction and destruction of objects are symmetrical, thus objects are destroyed in reverse order of </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">construction… right?</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">Well, that is the case for local, automatic objects. </span><span class="koboSpan" id="kobo.378.2">If you write </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.380.1">
void f() {
   A a; // a's ctor
   B b; // b's ctor
   {
      C c; // c's ctor
   } // c's dtor
   D d; // d's ctor
} // d's dtor, b's dtor, a's dtor (in that order)</span></pre> <p><span class="koboSpan" id="kobo.381.1">… then the order of construction and destruction will be as noted in the comments: automatic objects in scope are destroyed in reverse order of construction, and nested scopes behave </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">The situation gets more complex if you add non-automatic objects to the mix. </span><span class="koboSpan" id="kobo.383.2">C++ lets one have </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">static</span></strong><span class="koboSpan" id="kobo.385.1"> objects declared within a function: these are constructed when the function is called for the first time and stay alive from that point on until the end of the program’s execution. </span><span class="koboSpan" id="kobo.385.2">C++ lets one have global variables (there are many nuances here with linkage specifications such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">static</span></strong><span class="koboSpan" id="kobo.387.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">extern</span></strong><span class="koboSpan" id="kobo.389.1">) C++ lets one have </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">static</span></strong><span class="koboSpan" id="kobo.391.1"> data members in a class: these are essentially global variables too. </span><span class="koboSpan" id="kobo.391.2">I won’t even get to </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">thread_local</span></strong><span class="koboSpan" id="kobo.393.1"> variables here as they are out of scope for this book but if you use them, know that they can be lazily initialized which adds to the complexity of the overall picture. </span><span class="koboSpan" id="kobo.393.2">Global objects are destroyed in reverse order of construction, but that order of construction is not always trivial to predict from our </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">human perspective.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">Consider the following example, which uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">Verbose</span></strong><span class="koboSpan" id="kobo.397.1"> objects that inform us of their moment of</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.398.1"> construction as well as of their moment </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">of destruction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
#include &lt;iostream&gt;
#include &lt;format&gt;
struct Verbose {
   int n;
   Verbose(int n) : n{ n } {
      std::cout &lt;&lt; std::format(«Verbose({})\n», n);
   }
   ~Verbose(){
      std::cout &lt;&lt; std::format(«~Verbose({})\n», n);
   }
};
class X {
   static inline Verbose v0 { 0 };
   Verbose v1{ 1 };
};
Verbose v2{ 2 };
static void f() {
    static Verbose v3 { 3 };
    Verbose v4{ 4 };
}
static void g() { // note : never called
    static Verbose v5 { 5 };
}
int main() {
   Verbose v6{ 6 };
   {
      Verbose v7{ 7 };
      f();
      X x;
   }
   f();
   X x;
}</span></pre> <p><span class="koboSpan" id="kobo.401.1">Take a moment to let this example sink in and try to figure out what will be displayed. </span><span class="koboSpan" id="kobo.401.2">We have a global object, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">static</span></strong><span class="koboSpan" id="kobo.403.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">inline</span></strong><span class="koboSpan" id="kobo.405.1"> data member in a class, two </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">static</span></strong><span class="koboSpan" id="kobo.407.1"> objects local to</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.408.1"> functions as well as some local </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">automatic objects.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">So, what will be displayed if we run this program? </span><span class="koboSpan" id="kobo.410.2">If you try it, you </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">should see:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.412.1">
Verbose(0)
Verbose(2)
Verbose(6)
Verbose(7)
Verbose(3)
Verbose(4)
~Verbose(4)
Verbose(1)
~Verbose(1)
~Verbose(7)
Verbose(4)
~Verbose(4)
Verbose(1)
~Verbose(1)
~Verbose(6)
~Verbose(3)
~Verbose(2)
~Verbose(0)</span></pre> <p><span class="koboSpan" id="kobo.413.1">The first one to be constructed (and the last one to be destroyed) is </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">v0</span></strong><span class="koboSpan" id="kobo.415.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">static</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.417.1">inline</span></strong><span class="koboSpan" id="kobo.418.1"> data member. </span><span class="koboSpan" id="kobo.418.2">It also happens to be our first global object, followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">v2</span></strong><span class="koboSpan" id="kobo.420.1"> (our second global object). </span><span class="koboSpan" id="kobo.420.2">We then enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">main()</span></strong><span class="koboSpan" id="kobo.422.1"> and create </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">v6</span></strong><span class="koboSpan" id="kobo.424.1"> which will be destroyed at the end </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">main()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">Now, if you look at the output for that program, you’ll see that symmetry breaks down at this point since after the construction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">v6</span></strong><span class="koboSpan" id="kobo.430.1">, we construct </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">v7</span></strong><span class="koboSpan" id="kobo.432.1"> (in an inner, narrower scope; </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">v7</span></strong><span class="koboSpan" id="kobo.434.1"> will be destructed soon after) and then call </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">f()</span></strong><span class="koboSpan" id="kobo.436.1"> for the first time which constructs </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">v3</span></strong><span class="koboSpan" id="kobo.438.1">, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">v3</span></strong><span class="koboSpan" id="kobo.440.1"> is a global object and will for that reason be destroyed </span><em class="italic"><span class="koboSpan" id="kobo.441.1">after</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.442.1">v6</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.443.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">v7</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">The overall process is </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.447.1">mechanical and deterministic, but understanding it requires some thought and analysis. </span><span class="koboSpan" id="kobo.447.2">If we use our objects’ destructors to release resources, failure to understand what happens and when it happens can lead to our code trying to use resources that have already </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">been freed.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">For a concrete example involving a mix of automated and manual resource management, let’s look at something the C++ standard knows nothing about: dynamically linked libraries (</span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">.dll</span></strong><span class="koboSpan" id="kobo.451.1"> files). </span><span class="koboSpan" id="kobo.451.2">I’m not going to get into details here, so know that if you are on a Linux machine (using shared objects, </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">.so</span></strong><span class="koboSpan" id="kobo.453.1"> files) or on a Mac (</span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">.dylib</span></strong><span class="koboSpan" id="kobo.455.1"> files), the general idea’s the same but the function names </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">will differ.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">Our program will (a) load a dynamically linked library, (b) get the address of a function, (c) call this function and (d) unload the library. </span><span class="koboSpan" id="kobo.457.2">Suppose the library is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">Lib</span></strong><span class="koboSpan" id="kobo.459.1"> and the function we want to call is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">factory</span></strong><span class="koboSpan" id="kobo.461.1"> which returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">X*</span></strong><span class="koboSpan" id="kobo.463.1"> from which we want to call member </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">function </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">f()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.467.1">
#include "Lib.h"
#include &lt;Windows.h&gt; // LoadLibrary, GetProcAddress
int main() {
   using namespace std;
   HMODULE hMod = LoadLibrary(L"Lib.dll");
   // suppose the signature of factory is in Lib.h
   auto factory_ptr = reinterpret_cast&lt;
      decltype(&amp;factory)
   &gt;(GetProcAddress(hMod, "factory"));
   </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">X *p = factory_ptr();</span></strong><span class="koboSpan" id="kobo.469.1">
   p-&gt;f();
   </span><strong class="bold"><span class="koboSpan" id="kobo.470.1">delete p;</span></strong><span class="koboSpan" id="kobo.471.1">
   FreeLibrary(hMod);
}</span></pre> <p><span class="koboSpan" id="kobo.472.1">You might have noticed</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.473.1"> the manual memory management in there: we acquire a resource (a </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">X*</span></strong><span class="koboSpan" id="kobo.475.1"> pointing to something that’s at least an </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">X</span></strong><span class="koboSpan" id="kobo.477.1">) calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">factory()</span></strong><span class="koboSpan" id="kobo.479.1"> through </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">factory_ptr</span></strong><span class="koboSpan" id="kobo.481.1">, then we use (call </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">f()</span></strong><span class="koboSpan" id="kobo.483.1"> on) and manually dispose of </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">the </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.485.1">pointee</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">At this point, you’re probably telling yourself that manual resource management’s not the best of ideas (here: what happens to the resource if </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">p-&gt;f()</span></strong><span class="koboSpan" id="kobo.489.1"> throws?), so you look through the standard and find that an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.491.1"> will take responsibility over the </span><em class="italic"><span class="koboSpan" id="kobo.492.1">pointee</span></em><span class="koboSpan" id="kobo.493.1"> and destroy it when its destructor is reached. </span><span class="koboSpan" id="kobo.493.2">Beautiful, isn’t it? </span><span class="koboSpan" id="kobo.493.3">And indeed it probably is, but consider the following excerpt, rewritten to use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.495.1"> and automate the resource </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">management process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.497.1">
#include "Lib.h"
</span><strong class="bold"><span class="koboSpan" id="kobo.498.1">#include &lt;memory&gt; // std::unique_ptr</span></strong><span class="koboSpan" id="kobo.499.1">
#include &lt;Windows.h&gt; // LoadLibrary, GetProcAddress
int main() {
   using namespace std;
   HMODULE hMod = LoadLibrary(L"Lib.dll");
   // suppose the signature of factory is in Lib.h
   auto factory_ptr = reinterpret_cast&lt;
      decltype(&amp;factory)
   &gt;(GetProcAddress(hMod, "factory"));
   </span><strong class="bold"><span class="koboSpan" id="kobo.500.1">std::unique_ptr&lt;X&gt; p { factory_ptr() };</span></strong><span class="koboSpan" id="kobo.501.1">
   p-&gt;f();
   </span><strong class="bold"><span class="koboSpan" id="kobo.502.1">// delete p; // not needed anymore</span></strong><span class="koboSpan" id="kobo.503.1">
   FreeLibrary(hMod);
} </span><strong class="bold"><span class="koboSpan" id="kobo.504.1">// p is destroyed here... </span><span class="koboSpan" id="kobo.504.2">but is this good?</span></strong></pre> <p><span class="koboSpan" id="kobo.505.1">At first glance, this new version seems safer since </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">p</span></strong><span class="koboSpan" id="kobo.507.1"> is now an RAII object responsible for the destruction of the </span><em class="italic"><span class="koboSpan" id="kobo.508.1">pointee</span></em><span class="koboSpan" id="kobo.509.1">. </span><span class="koboSpan" id="kobo.509.2">Being destroyed at the closing brace of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">main()</span></strong><span class="koboSpan" id="kobo.511.1"> function, we </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.512.1">know that the destructor of the </span><em class="italic"><span class="koboSpan" id="kobo.513.1">pointee</span></em><span class="koboSpan" id="kobo.514.1"> will be called even if </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">p-&gt;f()</span></strong><span class="koboSpan" id="kobo.516.1"> throws, so we consider ourselves more exception-safe </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">than before…</span></span></p>
<p><span class="koboSpan" id="kobo.518.1">… except that this code crashes on that closing brace! </span><span class="koboSpan" id="kobo.518.2">If you investigate the source of the crash, you will probably end up realizing that the crash happens at the point where the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">p</span></strong><span class="koboSpan" id="kobo.520.1"> calls operator </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">delete</span></strong><span class="koboSpan" id="kobo.522.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">X*</span></strong><span class="koboSpan" id="kobo.524.1"> it has stored internally. </span><span class="koboSpan" id="kobo.524.2">Reading further, you will notice that the reason why this crash happens is that the library the object came from has been freed (call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">FreeLibrary()</span></strong><span class="koboSpan" id="kobo.526.1">) before the </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">destructor ran.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">Does that mean we cannot use an automated memory management tool here? </span><span class="koboSpan" id="kobo.528.2">Of course not, but we need to be more careful with the way in which we put object lifetime to contribution. </span><span class="koboSpan" id="kobo.528.3">In this example, we want to make sure that </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">p</span></strong><span class="koboSpan" id="kobo.530.1"> is destroyed before the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">FreeLibrary()</span></strong><span class="koboSpan" id="kobo.532.1"> happens; this can be achieved through the simple introduction of a scope in </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">our function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
#include "Lib.h"
#include &lt;memory&gt; // std::unique_ptr
#include &lt;Windows.h&gt; // LoadLibrary, GetProcAddress
int main() {
   using namespace std;
   HMODULE hMod = LoadLibrary(L"Lib.dll");
   // suppose the signature of factory is in Lib.h
   auto factory_ptr = reinterpret_cast&lt;
      decltype(&amp;factory)
   &gt;(GetProcAddress(hMod, "factory"));
   </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.536.1">      std::unique_ptr&lt;X&gt; p { factory_ptr() };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.537.1">      p-&gt;f();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.538.1">   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.539.1">} // p is destroyed here</span></strong><span class="koboSpan" id="kobo.540.1">
   FreeLibrary(hMod);
}</span></pre> <p><span class="koboSpan" id="kobo.541.1">In this specific example, we could find a simple solution; in other cases we might have to move some declarations around to make sure the scopes in which our objects find themselves don’t </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.542.1">alter the intended semantics of our function. </span><span class="koboSpan" id="kobo.542.2">Understanding the order in which objects are destroyed is essential to properly using this precious resource management facility that is </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">the destructor.</span></span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.544.1">Standard resource management automation tools</span></h1>
<p><span class="koboSpan" id="kobo.545.1">The standard library</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.546.1"> offers a significant </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.547.1">number of classes that manage memory efficiently. </span><span class="koboSpan" id="kobo.547.2">One needs only consider the standard containers to see shining examples of the sort. </span><span class="koboSpan" id="kobo.547.3">In this section, we will take a quick look at a few examples of types useful for resource management. </span><span class="koboSpan" id="kobo.547.4">Far from providing an exhaustive list, we’ll try to show different ways to benefit from the </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">RAII idiom.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">As mentioned before, when expressing a type that provides automated resource management, the key aspects of that type’s behavior are expressed through its six special member functions. </span><span class="koboSpan" id="kobo.549.2">For that reason, with each of the following types, we will take a brief look at what the semantics of these </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">functions are.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.551.1">unique_ptr&lt;T&gt; and shared_ptr&lt;T&gt;</span></h2>
<p><span class="koboSpan" id="kobo.552.1">This short section</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.553.1"> aims to provide a brief overview of the two main standard smart pointers types in the C++ standard library: </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.555.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">std::shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.557.1">. </span><span class="koboSpan" id="kobo.557.2">It is meant to provide a broad overview of each type’s role; a more detailed examination of how these types can be used appears in </span><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.558.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.559.1">, and we will implement simplified versions of both types (as well as of a few other smart pointer types) in </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.560.1">Chapter 6</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.561.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">We have seen an example using </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.564.1"> earlier in this chapter. </span><span class="koboSpan" id="kobo.564.2">An object of this type implements “single ownership of the resource” semantics: an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.566.1"> is uncopiable, and when provided with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">T*</span></strong><span class="koboSpan" id="kobo.568.1"> to manage, it destroys the </span><em class="italic"><span class="koboSpan" id="kobo.569.1">pointee</span></em><span class="koboSpan" id="kobo.570.1"> at the end of its lifetime. </span><span class="koboSpan" id="kobo.570.2">By default, this type will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">delete</span></strong><span class="koboSpan" id="kobo.572.1"> on the pointer it manages, but it can be made to use some other means of disposal </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">A default </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.576.1"> represents an empty object and mostly behaves like a null pointer. </span><span class="koboSpan" id="kobo.576.2">Since this type expresses exclusive ownership of a resource, it is uncopiable. </span><span class="koboSpan" id="kobo.576.3">Moving from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.578.1"> transfers ownership of the resource, leaving the moved-from object into an empty state conceptually analogous to a null pointer. </span><span class="koboSpan" id="kobo.578.2">The destructor of this type destroys the resource managed by the object, </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">if any.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">Type </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">std::shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.582.1"> implements “shared ownership of the resource” semantics. </span><span class="koboSpan" id="kobo.582.2">With this type, each </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">std::shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.584.1"> object that co-owns a given pointer shares responsibilities with respect to the pointee’s lifetime and the last co-owner of the resource is responsible for freeing it; as is the case with most smart pointers, this responsibility falls on the object’s destructor. </span><span class="koboSpan" id="kobo.584.2">This type is surprisingly complicated to write, even in a somewhat naïve implementation like the one we will write in </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.585.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.586.1">, and is less frequently useful than some people think, as the main use case (expressing ownership in the type system for cases where the last owner of the pointee is a priori unknown, something most frequently seen in multithreaded code) is more specialized than many would believe, but when one needs to fill this niche, it’s the kind of type that’s </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">immensely useful.</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">A default </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">std::shared_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.590.1"> also represents an empty object and mostly behaves like a null pointer. </span><span class="koboSpan" id="kobo.590.2">Since this type expresses shared ownership of a resource, it is copyable but copying an object means sharing the </span><em class="italic"><span class="koboSpan" id="kobo.591.1">pointee</span></em><span class="koboSpan" id="kobo.592.1">; copy assignment releases the resource held by the object on the left hand of the assignment and then shares the resource held by the object on the right side of the assignment between both objects. </span><span class="koboSpan" id="kobo.592.2">Moving from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">std::unique_ptr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.594.1"> transfers ownership of the resource, leaving the moved-from object into an empty state. </span><span class="koboSpan" id="kobo.594.2">The destructor of this type releases ownership of the</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.595.1"> shared</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.596.1"> resource, destroying the resource managed by the object if that object was the last </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">owner thereof.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.598.1">What does the “shared” in shared_ptr mean?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.599.1">There can be confusion </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.600.1">with respect to what the word “shared” in the name of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.602.1"> type actually means. </span><span class="koboSpan" id="kobo.602.2">For example, should we use that type whenever we want to share a pointer between caller and callee? </span><span class="koboSpan" id="kobo.602.3">Should we use it when whenever client code makes a copy of a pointer with the intent of sharing the pointee, such as when passing a pointer by value to a function or sharing resources stored in a global </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">manager object?</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.604.1">The short answer is that this is the wrong way to approach smart pointers. </span><span class="koboSpan" id="kobo.604.2">Sharing a dynamically allocated resource does not mean co-owning that resource: only the latter is what </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.606.1"> models, whereas the former can be done with much more lightweight types. </span><span class="koboSpan" id="kobo.606.2">We will examine this idea in detail in </span><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.607.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.608.1"> from a usage perspective, then reexamine it in </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.609.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.610.1"> with our implementer eyes, hopefully building a</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.611.1"> more comprehensive understanding of these deep and </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">subtle issues.</span></span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.613.1">lock_guard and scoped_lock</span></h2>
<p><span class="koboSpan" id="kobo.614.1">Owning a </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.615.1">resource is not limited to owning memory. </span><span class="koboSpan" id="kobo.615.2">Indeed, consider the following code excerpt and</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.616.1"> suppose that </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">string_mutator</span></strong><span class="koboSpan" id="kobo.618.1"> is a class used to perform arbitrary transformations to characters in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">string</span></strong><span class="koboSpan" id="kobo.620.1">, but is expected to be used in a multithreaded context in the sense that one needs to synchronize accesses to that </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.622.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;string_view&gt;
class string_mutator {
   std::string text;
   mutable std::mutex m;
public:
   // note: m in uncopiable so string_mutator
   // also is uncopiable
   string_mutator(std::string_view src)
      : text{ src.begin(), src.end() } {
   }
   template &lt;class F&gt; void operator()(F f) {
      </span><strong class="bold"><span class="koboSpan" id="kobo.624.1">m.lock();</span></strong><span class="koboSpan" id="kobo.625.1">
      std::transform(text.begin(), text.end(),
                     text.begin(), f);
      </span><strong class="bold"><span class="koboSpan" id="kobo.626.1">m.unlock();</span></strong><span class="koboSpan" id="kobo.627.1">
   }
   std::string grab_snapshot() const {
      </span><strong class="bold"><span class="koboSpan" id="kobo.628.1">m.lock();</span></strong><span class="koboSpan" id="kobo.629.1">
      std::string s = text;
      </span><strong class="bold"><span class="koboSpan" id="kobo.630.1">m.unlock();</span></strong><span class="koboSpan" id="kobo.631.1">
      return s;
   }
};</span></pre> <p><span class="koboSpan" id="kobo.632.1">In this example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">string_mutator</span></strong><span class="koboSpan" id="kobo.634.1"> object’s function call operator accepts an arbitrary function </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">f</span></strong><span class="koboSpan" id="kobo.636.1"> applicable to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">char</span></strong><span class="koboSpan" id="kobo.638.1"> and that returns something that can be converted to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">char</span></strong><span class="koboSpan" id="kobo.640.1">, then applies </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">f</span></strong><span class="koboSpan" id="kobo.642.1"> to each </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">char</span></strong><span class="koboSpan" id="kobo.644.1"> in the sequence. </span><span class="koboSpan" id="kobo.644.2">For example, the following call would display </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">"I LOVE </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">MY INSTRUCTOR"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.648.1">
// ...
</span><span class="koboSpan" id="kobo.648.2">string_mutator sm{ "I love my instructor" };
sm([](char c) {
   return static_cast&lt;char&gt;(std::toupper(c));
});
std::cout &lt;&lt; sm.grab_snaphot();
// ...</span></pre> <p><span class="koboSpan" id="kobo.649.1">Now, since </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">string_mutator::operator()(F)</span></strong><span class="koboSpan" id="kobo.651.1"> accepts any function of the appropriate</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.652.1"> signature </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.653.1">as argument, it could among other things accept a function that could throw an exception. </span><span class="koboSpan" id="kobo.653.2">Looking at the implementation of that operator, you will notice that with the current (naïve) implementation, this would lock </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">m</span></strong><span class="koboSpan" id="kobo.655.1"> but never unlock it, a bad </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">situation indeed.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">There are languages that offer specialized language constructs to solve this problem. </span><span class="koboSpan" id="kobo.657.2">In C++, there’s no need for such specialized support as robust code just flows from the fact that one could write an object that locks a mutex at construction time and unlocks it when destroyed… and that’s pretty much all we need. </span><span class="koboSpan" id="kobo.657.3">In C++, the simplest such type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">std::lock_guard&lt;M&gt;</span></strong><span class="koboSpan" id="kobo.659.1">, where a simple implementation could </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
template &lt;class M&gt;
   class lock_guard { // simplified version
      M &amp;m;
   public:
      lock_guard(M &amp;m) : m { m } { m.lock(); }
      ~lock_guard() { m.unlock(); }
      lock_guard(const lock_guard&amp;) = delete;
      lock_guard&amp; operator=(const lock_guard&amp;) = delete;
   };</span></pre> <p><span class="koboSpan" id="kobo.662.1">The simplest types </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.663.1">are often </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.664.1">the best. </span><span class="koboSpan" id="kobo.664.2">Indeed, applying this type to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">string_mutator</span></strong><span class="koboSpan" id="kobo.666.1"> example, we end up with a simpler, yet much more </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">robust implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.668.1">
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;string_view&gt;
class string_mutator {
   std::string text;
   mutable std::mutex m;
public:
   // note: m in uncopiable so string_mutator
   // also is uncopiable
   string_mutator(std::string_view src)
      : text{ src.begin(), src.end() } {
   }
   template &lt;class F&gt; void operator()(F f) {
      </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">std::lock_guard lck{ m };</span></strong><span class="koboSpan" id="kobo.670.1">
      std::transform(text.begin(), text.end(),
                     text.begin(), f);
   } </span><strong class="bold"><span class="koboSpan" id="kobo.671.1">// implicit m.unlock</span></strong><span class="koboSpan" id="kobo.672.1">
   std::string grab_snapshot() const {
      </span><strong class="bold"><span class="koboSpan" id="kobo.673.1">std::lock_guard lck{ m };</span></strong><span class="koboSpan" id="kobo.674.1">
      return text;
   } </span><strong class="bold"><span class="koboSpan" id="kobo.675.1">// implicit m.unlock</span></strong><span class="koboSpan" id="kobo.676.1">
};</span></pre> <p><span class="koboSpan" id="kobo.677.1">Clearly, using</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.678.1"> destructors</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.679.1"> to automate unlocking our mutex is advantageous for cases such as this: it simplifies code and helps make </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">it exception-safe.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.681.1">stream objects</span></h2>
<p><span class="koboSpan" id="kobo.682.1">In C++, stream</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.683.1"> objects are</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.684.1"> also resource owners. </span><span class="koboSpan" id="kobo.684.2">Consider the following code example where we copy each byte from file </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">in.txt</span></strong><span class="koboSpan" id="kobo.686.1"> to the standard </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">output stream:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.688.1">
#include &lt;fstream&gt;
#include &lt;iostream&gt;
int main() {
   std::ifstream in{ "in.txt" };
   for(char c; in.get(c); )
      std::cout &lt;&lt; c;
}</span></pre> <p><span class="koboSpan" id="kobo.689.1">You might notice a few interesting details in this code: we never call </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">close()</span></strong><span class="koboSpan" id="kobo.691.1">, there’s no </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">try</span></strong><span class="koboSpan" id="kobo.693.1"> block where we would be preparing ourselves for exception management, there’s no call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">open()</span></strong><span class="koboSpan" id="kobo.695.1"> in order to open the file, there’s no explicit check for some end-of-file state… yet, this code works correctly, does what it’s supposed to do, and does not </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">leak resources.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">How can such a simple program do all that? </span><span class="koboSpan" id="kobo.697.2">Through “the magic of destructors”, or (more precisely) the magic of a good API. </span><span class="koboSpan" id="kobo.697.3">Think </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">about it:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.699.1">The constructor’s role is to put the object in a correct initial state. </span><span class="koboSpan" id="kobo.699.2">Thus, we use it to open the file as it would be both pointless and inefficient to default-construct the stream, then open </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">it later.</span></span></li>
<li><span class="koboSpan" id="kobo.701.1">Errors when reading from a stream are not exceptional at all… Think about it, how often do we face errors when reading from a stream? </span><span class="koboSpan" id="kobo.701.2">In C++, reading from a stream (here: calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">in.get(c)</span></strong><span class="koboSpan" id="kobo.703.1">) returns a reference to the stream after reading from it, and that stream behaves like a </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">false</span></strong><span class="koboSpan" id="kobo.705.1"> Boolean value if the stream is in an </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">error state.</span></span></li>
<li><span class="koboSpan" id="kobo.707.1">Finally, the destructor of a stream object closes whatever representation of a stream it is responsible for. </span><span class="koboSpan" id="kobo.707.2">Calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">close()</span></strong><span class="koboSpan" id="kobo.709.1"> on a stream in C++ is unnecessary most of the time; just using the stream object in a limited scope </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">generally suffices.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.711.1">Destructors (and constructors!), when</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.712.1"> used </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.713.1">appropriately, lead </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.714.1">to more robust and </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">simpler code.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.716.1">vector&lt;T&gt; and other containers</span></h2>
<p><span class="koboSpan" id="kobo.717.1">We will not </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.718.1">write a full-blown comparison of containers with raw arrays or other low-level constructs such as linked lists with manually managed nodes or dynamic arrays maintained explicitly through client code. </span><span class="koboSpan" id="kobo.718.2">We will however examine how one can write containers such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">std::vector</span></strong><span class="koboSpan" id="kobo.720.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">std::list</span></strong><span class="koboSpan" id="kobo.722.1"> in later chapters of this book (</span><em class="italic"><span class="koboSpan" id="kobo.723.1">Chapters 12</span></em><span class="koboSpan" id="kobo.724.1">, </span><em class="italic"><span class="koboSpan" id="kobo.725.1">13</span></em><span class="koboSpan" id="kobo.726.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.727.1">14</span></em><span class="koboSpan" id="kobo.728.1">) when we know a bit more on memory </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">management techniques.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">Please note, still, that using </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.732.1"> (for example) is not only significantly simpler and safer than managing a dynamically allocated array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">T</span></strong><span class="koboSpan" id="kobo.734.1">: in practice, it’s most probably significantly </span><em class="italic"><span class="koboSpan" id="kobo.735.1">faster</span></em><span class="koboSpan" id="kobo.736.1">, at least if used knowledgeably. </span><span class="koboSpan" id="kobo.736.2">As we will come to see, there’s no way users can invest the care and attention that goes into memory management and object creation, destruction and copying or movement that goes in a standard container when writing day-to-day code. </span><span class="koboSpan" id="kobo.736.3">The destructor of these types, coupled with the</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.737.1"> way their other special member functions are implemented, make them almost as easy to use </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.738.1">as </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">int</span></strong><span class="koboSpan" id="kobo.740.1"> objects, a worthy goal if there ever </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">was one!</span></span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.742.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.743.1">In this chapter, we have discussed some safety-related issues, with a focus on those involving exceptions. </span><span class="koboSpan" id="kobo.743.2">We have seen that some standard library types offer specialized semantics with respect to resource management, where “resource” includes but is not limited to memory. </span><span class="koboSpan" id="kobo.743.3">In </span><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.744.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.745.1">, we will spend some time examining how to use and benefit from standard smart pointer; then, in </span><a href="B21071_06.xhtml#_idTextAnchor096"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.746.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.747.1">, we will go further and look at some of the challenges behind writing your own versions of these smart pointers, as well as some other smart pointer-inspired types with other semantics. </span><span class="koboSpan" id="kobo.747.2">Then, we will delve into deeper memory </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">management-related concerns.</span></span></p>
</div>
</body></html>