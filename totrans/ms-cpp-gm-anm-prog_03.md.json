["```cpp\nlayout (std430, binding = 0) readonly buffer Matrices {\n  mat4 matrix[];\n};\n...\nvoid main() {\n  ...\n  mat4 boneMat = matrix[index];\n  ...\n} \n```", "```cpp\nlayout(local_size_x = 16, local_size_y = 32,\n  local_size_z = 1) in; \n```", "```cpp\nglDispatchCompute(10, 10, 1); \n```", "```cpp\n16*32*1*10*10*1 = 51200 \n```", "```cpp\nImGui::SliderInt(\"##MassInstanceCreation\",\n  &manyInstanceCreateNum, 1, **100**, \"%d\", flags); \n```", "```cpp\n1601*41*3*2 = 393846 \n```", "```cpp\n1601*4*16 = 102464 \n```", "```cpp\n     for (const auto& channel : animChannels) {\n        std::string nodeNameToAnimate =\n          channel->getTargetNodeName();\n        std::shared_ptr<AssimpNode> node =\n          mAssimpModel->getNodeMap().at(nodeNameToAnimate);\n        node->setRotation(\n          channel->getRotation(\n          mInstanceSettings.isAnimPlayTimePos));\n        node->setScaling(\n          channel->getScaling(\n          mInstanceSettings.isAnimPlayTimePos));\n        node->setTranslation(\n          channel->getTranslation(\n          mInstanceSettings.isAnimPlayTimePos));\n      } \n    ```", "```cpp\n     mBoneMatrices.clear();\n      for (auto& bone : mAssimpModel->getBoneList()) {\n        std::string nodeName = bone->getBoneName();\n        std::shared_ptr<AssimpNode> node =\n           mAssimpModel->getNodeMap().at(nodeName);\n        node->updateTRSMatrix(); \n    ```", "```cpp\n     if (mAssimpModel->getBoneOffsetMatrices().count(\n          nodeName) > 0) {\n          mBoneMatrices.emplace_back(\n            mAssimpModel->getNodeMap().at(\n            nodeName)->getTRSMatrix() *\n          mAssimpModel->getBoneOffsetMatrices().at(nodeName));\n        }\n      } \n    ```", "```cpp\n     for (unsigned int i = 0; i < numberOfInstances; ++i) {\n            modelType.second.at(i)->updateAnimation(\n              deltaTime);\n            std::vector<glm::mat4> instanceBoneMatrices =\n              modelType.second.at(i)->getBoneMatrices();\n            mModelBoneMatrices.insert(\n              mModelBoneMatrices.end(),\n              instanceBoneMatrices.begin(),\n              instanceBoneMatrices.end());\n          } \n    ```", "```cpp\n     mShaderBoneMatrixBuffer.uploadSsboData(\n              mModelBoneMatrices, 1); \n    ```", "```cpp\nlayout (std430, binding = 1) readonly buffer BoneMatrices {\n  mat4 boneMat[];\n}; \n```", "```cpp\n     mat4 skinMat =\n        aBoneWeight.x * boneMat[int(aBoneNum.x) +\n          gl_InstanceID * aModelStride] +\n        aBoneWeight.y * boneMat[int(aBoneNum.y) +\n          gl_InstanceID * aModelStride] +\n        aBoneWeight.z * boneMat[int(aBoneNum.z) +\n          gl_InstanceID * aModelStride] +\n        aBoneWeight.w * boneMat[int(aBoneNum.w) +\n          gl_InstanceID * aModelStride]; \n    ```", "```cpp\n     gl_Position = projection * view * skinMat *\n        vec4(aPos, 1.0); \n    ```", "```cpp\nstruct NodeTransformData {\n  glm::vec4 translation = glm::vec4(0.0f);\n  glm::vec4 scale = glm::vec4(1.0f);\n  glm::vec4 rotation = glm::vec4(1.0f, 0.0f, 0.0f, 0.0f);\n} \n```", "```cpp\n std::vector<NodeTransformData> mNodeTransformData{}; \n```", "```cpp\n for (const auto& channel : animChannels) {\n    NodeTransformData nodeTransform;\n    nodeTransform.translation =\n      channel->getTranslation(\n      mInstanceSettings.isAnimPlayTimePos);\n    nodeTransform.rotation =\n      channel->getRotation(\n      mInstanceSettings.isAnimPlayTimePos);\n    nodeTransform.scale =\n      channel->getScaling(\n      mInstanceSettings.isAnimPlayTimePos); \n```", "```cpp\n int boneId = channel->getBoneId();\n    if (boneId >= 0) {\n      mNodeTransformData.at(boneId) = nodeTransform;\n    }\n  } \n```", "```cpp\n for (unsigned int i = 0; i < numberOfInstances; ++i) {\n    modelType.second.at(i)->updateAnimation(deltaTime); \n```", "```cpp\n std::vector<NodeTransformData> instanceNodeTransform =\n      modelType.second.at(i)->getNodeTransformData();\n    std::copy(instanceNodeTransform.begin(),\n      instanceNodeTransform.end(),\n      mNodeTransFormData.begin() + i * numberOfBones);\n  } \n```", "```cpp\nmNodeTransformBuffer.uploadSsboData(mNodeTransFormData, 0); \n```", "```cpp\nmBoneMatrices.emplace_back(\n    mAssimpModel->getNodeMap().at(\n    nodeName)->getTRSMatrix() *\n    **mAssimpModel->****getBoneOffsetMatrices****().****at****(nodeName)**); \n```", "```cpp\n ShaderStorageBuffer mShaderBoneMatrixOffsetBuffer{}; \n```", "```cpp\n std::vector<glm::mat4> boneOffsetMatricesList{};\n  for (const auto& bone : mBoneList) {\n    boneOffsetMatricesList.emplace_back(\n      bone->getOffsetMatrix());\n  }\n  mShaderBoneMatrixOffsetBuffer.uploadSsboData(\n    boneOffsetMatricesList); \n```", "```cpp\n modelType.second.at(0)->getModel()\n      ->bindBoneMatrixOffsetBuffer(2); \n```", "```cpp\n if (std::shared_ptr<AssimpNode> parentNode =\n      mParentNode.lock()) {\n    mParentNodeMatrix = parentNode->getTRSMatrix();\n  }\n  mLocalTRSMatrix = mRootTransformMatrix *\n    mParentNodeMatrix * mTranslationMatrix *\n    mRotationMatrix * mScalingMatrix; \n```", "```cpp\n std::string parentNodeName = mNodeMap.at(\n      bone->getBoneName())->getParentNodeName();\n    const auto boneIter = std::find_if(mBoneList.begin(),\n      mBoneList.end(),\n      [parentNodeName](std::shared_ptr<AssimpBone>& bone)\n       { return bone->getBoneName() == parentNodeName; }); \n```", "```cpp\n if (boneIter == mBoneList.end()) {\n      boneParentIndexList.emplace_back(-1);\n    } else {\n      boneParentIndexList.emplace_back(\n        std::distance(mBoneList.begin(), boneIter));\n    } \n```", "```cpp\nmShaderBoneParentBuffer.uploadSsboData(boneParentIndexList); \n```", "```cpp\n modelType.second.at(0)->getModel()\n        ->bindBoneParentBuffer(1); \n```", "```cpp\n mAssimpModel->getNodeMap().at(\n    mAssimpModel->getBoneList().at(0)->getBoneName())\n    ->setRootTransformMatrix(mLocalTransformMatrix *\n    mAssimpModel->getRootTranformationMatrix()); \n```", "```cpp\nglCreateShader(**GL_COMPUTE_SHADER**); \n```", "```cpp\nVkPipelineShaderStageCreateInfo computeShaderStageInfo{};\ncomputeShaderStageInfo.sType =\n  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; computeShaderStageInfo.stage =\n  **VK_SHADER_STAGE_COMPUTE_BIT**; \n```", "```cpp\n if (!mAssimpTransformComputeShader.loadComputeShader(\n      \"shader/assimp_instance_transform.comp\")) {\n    return false;\n  } \n```", "```cpp\n ShaderStorageBuffer mShaderTRSMatrixBuffer{}; \n```", "```cpp\n ShaderStorageBuffer mShaderBoneMatrixBuffer{}; \n```", "```cpp\n size_t trsMatrixSize = numberOfBones *\n numberOfInstances * sizeof(glm::mat4); \n```", "```cpp\n mShaderBoneMatrixBuffer.checkForResize(trsMatrixSize);\n  mShaderTRSMatrixBuffer.checkForResize(trsMatrixSize); \n```", "```cpp\n mAssimpTransformComputeShader.use();\n    mNodeTransformBuffer.uploadSsboData(\n      mNodeTransFormData, 0);\n    mShaderTRSMatrixBuffer.bind(1) \n```", "```cpp\n#version 460 core\nlayout(local_size_x = 1, local_size_y = 32,\n  local_size_z = 1) in; \n```", "```cpp\nstruct NodeTransformData {\n  vec4 translation;\n  vec4 scale;\n  vec4 rotation;\n}; \n```", "```cpp\nlayout (std430, binding = 0) readonly restrict\n    buffer TransformData {\n  NodeTransformData data[];\n};\nlayout (std430, binding = 1) writeonly restrict\n    buffer TRSMatrix {\n  mat4 trsMat[];\n}; \n```", "```cpp\nmat4 getTranslationMatrix(uint index) {\n  return mat4(1.0, 0.0, 0.0, 0.0,\n              0.0, 1.0, 0.0, 0.0,\n              0.0, 0.0, 1.0, 0.0,\n              data[index].translation[0],\n                   data[index].translation[1],\n                        data[index].translation[2],\n                            1.0);\n} \n```", "```cpp\nvoid main() {\n  uint node = gl_GlobalInvocationID.x;\n  uint instance = gl_GlobalInvocationID.y; \n```", "```cpp\n uint numberOfBones = gl_NumWorkGroups.x; \n```", "```cpp\n uint index = node + numberOfBones * instance; \n```", "```cpp\n trsMat[index] = getTranslationMatrix(index) *\n    getRotationMatrix(index) * getScaleMatrix(index);\n} \n```", "```cpp\n glDispatchCompute(numberOfBones,\n      std::ceil(numberOfInstances / 32.0f), 1);\n    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT); \n```", "```cpp\n vkCmdDispatch(commandBuffer, numberOfBones,\n      std::ceil(numberOfInstances / 32.0f), 1); \n```", "```cpp\nboneMatrixBufferSize +=\n  numberOfBones * ((numberOfInstances - 1) / 32 + 1) * 32; \n```", "```cpp\nVkMemoryBarrier memoryBarrier {}\n  ...\n memoryBarrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT:\n memoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;\nvkCmdPipelineBarrier(...\n  VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,\n  VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,\n  1, &memoryBarrier, ...); \n```", "```cpp\n mAssimpMatrixComputeShader.use();\n        mShaderTRSMatrixBuffer.bind(0);\n        modelType.second.at(0)->getModel()\n          ->bindBoneParentBuffer(1);\n        modelType.second.at(0)->getModel()\n          ->bindBoneMatrixOffsetBuffer(2);\n        mShaderBoneMatrixBuffer.bind(3); \n```", "```cpp\n#version 460 core\nlayout(local_size_x = 1, local_size_y = 32,\n  local_size_z = 1) in; \n```", "```cpp\nlayout (std430, binding = 0) readonly restrict\n    buffer TRSMatrix {\n  mat4 trsMat[];\n};\nlayout (std430, binding = 1) readonly restrict\n    buffer ParentMatrixIndices {\n  int parentIndex[];\n};\nlayout (std430, binding = 2) readonly restrict\n    buffer BoneOffsets {\n  mat4 boneOffset[]\n};\nlayout (std430, binding = 3) writeonly restrict\n    buffer BoneMatrices {\n  mat4 boneMat[];\n}; \n```", "```cpp\nvoid main() {\n  uint node = gl_GlobalInvocationID.x;\n  uint instance = gl_GlobalInvocationID.y;\n  uint numberOfBones = gl_NumWorkGroups.x;\n  uint index = node + numberOfBones * instance; \n```", "```cpp\n mat4 nodeMatrix = trsMat[index]; \n```", "```cpp\n uint parent = 0; \n```", "```cpp\n int parentNode = parentIndex[node]; \n```", "```cpp\n while (parentNode >= 0) {\n    parent = parentNode + numberOfBones * instance;\n    nodeMatrix = trsMat[parent] * nodeMatrix;\n    parentNode = parentIndex[parentNode];\n  } \n```", "```cpp\n if (parentNode == -1) {\n    nodeMat[index] = nodeMatrix * boneOff[node];\n  }\n} \n```", "```cpp\n glDispatchCompute(numberOfBones,\n      std::ceil(numberOfInstances / 32.0f), 1);\n    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT); \n```", "```cpp\n vkCmdDispatch(commandBuffer, numberOfBones,\n      std::ceil(numberOfInstances / 32.0f), 1); \n```", "```cpp\n mWorldPosMatrices.resize(numberOfInstances);\n    for (unsigned int i = 0; i < numberOfInstances; ++i) {\n      ...\n      **mWorldPosMatrices.****at****(i) =**\n      **  modelType.second.****at****(i)->****getWorldTransformMatrix****();**\n    } \n```", "```cpp\n mAssimpSkinningShader.use();\n        mAssimpSkinningShader.setUniformValue(\n          numberOfBones);\n        mShaderBoneMatrixBuffer.bind(1);\n        **mShaderModelRootMatrixBuffer.****uploadSsboData****(**\n          **mWorldPosMatrices,** **2****);** \n```", "```cpp\nlayout (std430, binding = 2) readonly restrict\n    buffer WorldPosMatrices {\n  mat4 worldPos[];\n}; \n```", "```cpp\n **mat4** **worldPosSkinMat = worldPos[****gl_InstanceID****] * skinMat;**\n  gl_Position = projection * view * **worldPosSkinMat** *\n    vec4(aPos.x, aPos.y, aPos.z, 1.0);\n  ...\n  normal = transpose(inverse(**worldPosSkinMat**)) *\n    vec4(aNormal.x, aNormal.y, aNormal.z, 1.0); \n```", "```cpp\n glm::quat rotation =\n    glm::normalize(glm::slerp(mRotations.at(timeIndex),\n    mRotations.at(timeIndex + 1), interpolatedTime)); \n```", "```cpp\n glBindBuffer(GL_SHADER_STORAGE_BUFFER, buffer);\n  glGetBufferSubData(GL_SHADER_STORAGE_BUFFER, 0,\n    buffer, bufferVector.data());\n  glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0) \n```"]