<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Audio in Your Game</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Audio is an often-overlooked component of games that is often only noticed when it is done poorly. While not as prominent as graphics and gameplay tend to be, given how it can ruin an experience or enhance it, it's definitely best to aim for the latter.  Think about an action or horror film with the volume muted, and you get a feel for how important of an impact audio can have!  In this chapter we'll cover:</p>
<ul>
<li>Fundamental components of UE4 audio</li>
<li>Triggering audio from an animation</li>
<li>Material-based audio (including unique impact sounds for projectiles and various player foot-falls)</li>
<li>Environmental FX (reverb by a volume)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter will extensively use the audio resources from the countess character assets added back in Chapter 5, <em>Adding Enemies!</em>, but with similar assets the lessons can be followed without these specifically.</p>
<p>The GitHub chapter will begin here:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-7">https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-7</a></p>
<p><span>Engine version used: 4.19.2.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic sounds and triggering by animation</h1>
                </header>
            
            <article>
                
<p>We already have, as is obvious to dedicated followers of the book, exactly one sound in our game, it's found here and has been there since Chapter 1, <em>Making a C++ Project for a First-Person Shooter</em>, with our FPS template (though it was moved from <kbd>AMasteringCharacter</kbd> to <kbd>AMasteringWeapon</kbd> in Chapter 2, <em>Inventory and Weapons for the Player:</em></p>
<pre><span>// try and play the sound if specified</span>
<span>if</span> <span>(</span><span>FireSound</span> <span>!=</span> <span>nullptr</span><span>)</span>
<span>{</span>
        <span>UGameplayStatics</span><span>::</span><span>PlaySoundAtLocation</span><span>(</span><span>this</span><span>,</span> <span>FireSound</span><span>,</span> <span>GetActorLocation</span><span>());</span>
<span>}</span></pre>
<p>That is a great example of the most basic way to play a sound, and from C++ no less, but we'll try to branch out in a few new areas in this section and add material-based sounds in the one that follows. We'll also be adding a professional-looking level from Epic to demonstrate some of these concepts. You can find it from Epic here (<span class="packt_screen">Infinity Blade: Ice Lands</span>; we'll use the <span class="packt_screen">Ice Cove</span> in its pack):</p>
<p><img src="assets/70671b45-4996-416e-8aac-9b046531a28a.png"/></p>
<p>It's a similar size (close to 2 GB) as the countess content was, so if you're keeping up with the GitHub project, it might be best to start downloading it now.</p>
<div class="packt_infobox">An important note here for GitHub users! The project as of this map being uploaded sets maps to use GitHub LFS (large file system), and if you're unfamiliar, you will now need to not just do a pull from GitHub going forward, but then also a <kbd>pull lfs content</kbd>. You'll notice the problem if Unreal says the map files are in the wrong format on startup. More information on Git LFS is in additional reading.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sounds, cues, channels, dialog, FX volumes, and more!</h1>
                </header>
            
            <article>
                
<p>UE4 offers a huge array of audio-based classes that can be as simple as <kbd>USoundBase</kbd>, or incredibly complex combinations of branching dialog and specially applied FX.</p>
<p>Let's first just walk through the major classes to make sure it's clear what capabilities already exist. If you just right-click to add an asset and hover on the sound fly-out, you'll see a list like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/94d6b6ba-4045-465d-9740-7e7bd4ea5ed6.png" style="width:34.33em;height:26.50em;"/></div>
<p>This by itself can be intimidating, so let's just make a quick overview of each of them and their purpose before we start some more practical examples.</p>
<p class="mce-root"/>
<p><span class="packt_screen">Sound Wave</span>: This is the most basic level of a sound in the game. While it is not in the Sounds drop-down menu, this is how sounds are brought into the game from the <span class="packt_screen">Import</span> button rather than Sounds. You take a raw sound (a .wav file, for example), import it into your project, and have a <span class="packt_screen">Sound Wave</span>. These can take various properties, or be used to make Sound Cues and take further properties. A summary of all the items to follow can be made like this: all further sound design or audio engineering is really dependent on your game's complexity and needs. <span class="packt_screen">Sound Waves</span>, though, are your most basic starting point and are required for any audio to be played in UE4.</p>
<p><span class="packt_screen">Dialog Voice</span>: These simply specify a speaker type and a speaker gender. Think of the voice as its name: who is speaking, and what type of voice do they use?</p>
<p><span class="packt_screen">Dialog Wave</span>: These are basically an indicator of how one speaker should interact with another speaker, defined through <span class="packt_screen">DialogContext</span> objects that you can add from one speaker to another, as well as add on-screen spoken text and subtitle overrides (as well as flagging the content as mature). A quick version of this will be demonstrated with our countess performing a taunt in combat in the next section. The dialog system is great for simple dialog between a couple of interactable characters (the player being one or several), but this really only works well for basic interactions. If that is all that is needed by the design of your game, this is a perfectly good option and should be utilized. <span>More general information on the dialog system is linked in the <em>Further reading</em> section.</span></p>
<p><span class="packt_screen">Reverb Effect</span>: Reverb effects really should be utilized by sound designers, but their function is to add effects based on the environment to the sounds played and heard. They can be used to make a bit of an echo in a cave environment, for example, or the interior of a vehicle, to add a professional and realistic audio effect to your sounds. These are attached to audio volumes in your world that tell the environment how your sound should be heard.</p>
<p><span class="packt_screen">Sound Attenuation</span>: Similar to the Reverb Effect, you can define various attenuation settings. Environmental sounds (which we will address further) can reference one of these objects, or typically be specified individually. Attenuation is really the drop-off properties of a sound: spatially based on the listener's location, how does the sound drop off? For example, in an area with winding corridors, you'll want sound to drop off more quickly the further away it is to reflect the loss of amplitude as the sound travels to the listener. Once again, audio engineers and sound designers are typically very familiar with the concepts here and can apply them to great effect to make atmospheric effects on the sounds being played (a creepy noise from a distance away may play very quietly, but when near the player, is much louder).</p>
<p><span class="packt_screen">Sound Class</span>: This is another nice way to organize your sound types based on how they are meant to be heard and are applied on top of all other properties. Sounds can be set, for example, to ignore reverb, ignore attenuation (set them as a <span class="packt_screen">UISound</span>!), or otherwise alter properties such as their stereo (left/right channel) output, and be applied in a hierarchy through other sound classes.</p>
<p><span class="packt_screen">Sound Concurrency</span>: Before this object was added, it was possible to limit a sound by Max Count and other properties that will be found as we work. So, for example, you don't have 20 footstep sounds from NPCs playing at the same time, you limit it to 6 even if 20 NPCs are simultaneously walking. <span class="packt_screen">Sound Concurrency</span> objects give finer control over this based on the sound's player. So, for the previous example, perhaps you want all attack sounds from a certain type of enemy to be played, but you only want a limited set from another type of enemy to be heard at any given time. As with many previous descriptions, this is a great tool for audio designers to have available, but it is really only needed in games or areas of games where sounds can become overwhelming to the player and some should have definite priority over others. These can then be specified like other properties to a <span class="packt_screen">Sound Wave</span> object.</p>
<p><span class="packt_screen">Sound Cue</span>: These are a bit like a blueprint for playing sounds. You can combine effects and local modifiers to an output. Think of these like taking an actual sound input (a gunshot, a bit of spoken dialog, and so on) and specifying in great detail how it should be combined for the final output. Many of these options at this point surely seem like they have a lot of overlap, but consider many of them as <em>ways to modify any sound</em>, and this one as <em>ways we modify a specific sound</em>. Sound Cues can often be quite simple and just take your input and put it to an output, though of course, that output itself can still be modified by global environmental FX set (or, again, set for just this sound).</p>
<p><span class="packt_screen">Sound Mix</span>: <span>Sound mixes can be pushed and popped and applied on top of each other as well, but control more global settings such as  pitch, EQ (high-end to low-end filtering), and how volume should be applied to, for example, the center-channel in 5.1 or other surround sound options for advanced mixing.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Triggering sounds from animation</h1>
                </header>
            
            <article>
                
<p>By far the most common usage case in games is audio triggered as animations are played. We'll set up several events like this for our countess NPC and, in the next section, some footsetps based on materials for our player (even though our player character model has no feet!). To get started, let's open our <span class="packt_screen">ABP_Countess</span> animation blueprint and look again at her attack state:</p>
<p><img src="assets/69010545-250e-42d8-852d-573c8e9204d0.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We'll now work on <span class="packt_screen">Primary_Attack_A_Normal</span> with an event to make her attack not so eerily silent. Double-click the attack anim. node and, like we did earlier for the try-to-hit event, we'll add another event to her animation a bit earlier:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/43834613-483b-482e-be03-754eae19946f.png"/></p>
<p>At the bottom on the timeline, we can scrub the little red bar to where we want, then up in the <span class="packt_screen">Notifies</span> timeline, right-click and add a Play Sound notify. Then over on the right, filter to and pick a <span class="packt_screen">Countess_Effort_Attack</span> sound that we like. Now, two notes: the sound cues set up for her are invalid because the project doesn't have the whole set of characters from the game, and they rely on dialog players mentioned in the previous section. So they won't play any sound. Second note: the sound wave objects all work individually, of course, but if we wanted to mix them up, we could make a normal animation notify like we did for the attack-hit previously, set up some blueprint logic to pick a sound wave at random, and play that. For now, we've picked attack_01, so we now have her making noise in the game and can test it in our levels.</p>
<div class="packt_infobox">For those following along, there is some cleanup in the project at this point: renaming to better reflect our assets' current state of things and bringing some of our other classes up to date. If you're syncing at this point, you may also notice the Infinity Blade weapons now have their own projectiles that look like their actual weapons and gives them a bit more of a thrown weapon feel and helps differentiate each further for future work.</div>
<div class="packt_tip">If you're curious how the static meshes for the projectiles were made, open the skeletal mesh actor for the mesh of any of these weapons we've made, and at the top is a <span class="packt_screen">Make Static Mesh</span> button on the main toolbar. It's very convenient when you don't want to import a separate model or don't have access to the original assets but need a static mesh version, like here.</div>
<p>If you play the game at this point, you'll notice our countess' attack noise gets very repetitive and it all still feels a bit basic. Given the huge number of awesome assets this character contains, we'll now randomize her attacks, give each attack its own sound (we could also just randomize the sound each time the same attack is played, however), and give her an occasional taunt piece of dialog directed at our player. Let's start by opening up our <span class="packt_screen">ABP_Countess</span> animation blueprint. In here, in the Attacking state, we'll change from playing a single animation to playing via a random sequence player. As you can see on the right, you can then add as many animation sequences as you like, weight their relative chance to be picked, turn on shuffle mode, set looping, all kinds of great stuff:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/41741f3e-a8a2-420a-9ff5-c0634fcec7ac.png"/></div>
<p>However, once we do this, we can't count on the play time of a given animation as our exit transition anymore and need a new way to transition out of this state. We need a new variable on the bottom-left: <span class="packt_screen">TargetOutOfRange</span>. This is used here to get us out of this continuing attacking sequence and into moving to chase the player (or run back home if we take too long), like normal:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4fa5e7d8-ddbb-490f-af13-d030f5816c96.png"/></div>
<p class="mce-root"/>
<p>Setting that requires us to modify the attack behavior tree task, adding this function at the end when our MoveTo succeeds:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/433de898-50af-4402-b3db-9971edef03c9.png"/></div>
<p>The function called there is rather simple and so is omitted here. It just does all of our casing from pawn, getting the animation blueprint, and then setting its out of range variable to whatever was passed in. And as can be seen in the GitHub project, that variable is marked true every time we enter our move to behavior task, so it is only set to false on each pass through the function where our AI MoveTo succeeds (which is every pass unless the player moves out of the acceptance radius). As an added bonus, you can see in the last of the three animation sequences used that the sound cue chosen here has three dialog entries and picks one randomly. So we have three random attacks, and the third one set up here picks from three random sounds each time it is used. A perfect example of our options.</p>
<p>And lastly, we'll make a quick taunt that plays some percentage of the time. Note that it can play multiple times in a row as-is, but there are plenty of tools available to prevent this. To get her to play a taunt 10% of the time, this dialog setup is added at the end of the attack behavior task (and note that a DialogVoice with default settings was added for our stealth character):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4e4ccab0-bbec-425c-87c6-b8e2430d92ab.png"/></div>
<p class="mce-root"/>
<p>Note that whichever dialog wave is chosen (in this case <span class="packt_screen">Countess_Emote_Taunt_010_Dialogue</span>) you need to open it and ensure that the speaker is set to the right type (I am using the not Vamp versions) and add the stealth character (specified in the array in the bottom-left) as a listener. And there we have it: random attacks, new sounds, random dialog, and a random taunt!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Environments and sound</h1>
                </header>
            
            <article>
                
<p>Our sounds to this point are indifferent to where or why they are played. We'll quickly now add a sound for a couple of types of things our projectile can hit, as well as some footstep sounds for the player just to prove our physics material approach is working. Unlike some of the amazing visual assets made freely available in the Unreal Marketplace, it's a bit tougher to find similarly freely shared libraries of common sounds, but we'll use what we have to make the most of it and realize that in a full-production game, many sounds will be built by dedicated sound designers, or hopefully some budget is at least set aside to purchase existing commercial libraries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hitting different surfaces</h1>
                </header>
            
            <article>
                
<p><span>Hitting objects with our projectiles is the easiest sound to quickly set up, but then, we need new functionality on our projectile class to make sure each one knows what sound to play as they hit each type of surface. This can be quite a bit of work to maintain as the number of surface types (physical materials) and projectiles with unique sounds begin to multiply, but this is also the kind of detail-oriented work that sets apart a commercially successful game from the less professional demos or indie titles that don't take the time to add these touches.</span></p>
<p>We'll start with the absolute basics that we need to address in the project: setting up material types. For the work here, we're just going to set up two types, but of course, you could then follow this pattern and create as many as desired for every type. First, open up the project settings, and under <span class="packt_screen">Engine/Physics</span>, we'll add snow and stone like so:</p>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/980b9d6c-1cfa-4e7a-bc71-71e1f80088cb.png"/></div>
<p>In the <span class="packt_screen">FirstPerson/Audio</span> section, I added several sound cues, but they're just FX-modified versions of sounds already in the project since, as noted, there are no specific obvious free downloads in the Unreal Marketplace:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/140c78be-40fb-4b71-bcac-33aa1d051cd9.png"/></div>
<div class="packt_infobox">Important note! If at this stage (or any point going forward) these sounds are bothersome (they became so to me!), please go to GitHub and cherry-pick commit 7ff24f7 from this chapter (which will be used going forward in all subsequent versions) for some relatively good percussion sounds for all the impacts in this chapter. Having a synthesizer and pulling in some .wav samples is a big advantage, but remember: in any case where you're not 100% sure, you must check any licensing on any assets like this. Even hardware you own generating sounds can have some set of licensing in commercial products if used directly!</div>
<p>Next, for projectiles we will need a way of matching material types and a surface that was hit. For now, we'll make a struct in our projectile header. We'll add these two properties:</p>
<pre><span>USTRUCT</span><span>(</span><span>BlueprintType</span><span>)</span>
<span>struct</span> <span>FPhysSound</span>
<span>{</span>
        <span>GENERATED_USTRUCT_BODY</span><span>()</span>
 
        <span>UPROPERTY</span><span>(</span><span>EditAnywhere</span><span>,</span> <span>BlueprintReadWrite</span><span>)</span>
        <span>TEnumAsByte</span><span>&lt;</span><span>EPhysicalSurface</span><span>&gt;</span> <span>SurfaceType</span><span>;</span>
 
        <span>UPROPERTY</span><span>(</span><span>EditAnywhere</span><span>,</span> <span>BlueprintReadWrite</span><span>)</span>
        <span>class</span> <span>USoundCue</span><span>*</span> <span>SoundCue</span><span>;</span>
<span>};</span></pre>
<p>And, of course, our projectiles will need an array of these:</p>
<pre><span>UPROPERTY</span><span>(</span><span>EditAnywhere</span><span>,</span> <span>BlueprintReadWrite</span><span>)</span>
<span>TArray</span><span>&lt;FPhysSound</span><span>&gt;</span> <span>ImpactSounds</span><span>;</span></pre>
<p class="mce-root"/>
<p>As noted, when the complexity of physics surface types and projectiles gets greater and greater, maintaining a system such as this can get out of hand. And with even the small set here, if decisions made early can mean building in changes as you progress, instead of retro-fitting changes onto a huge number of individual assets, you're always better off making these decisions as early as possible. The level of complexity currently is manageable, but if it were multiplied to a significantly larger number, the work about to be done would be pretty miserable, and the chances for mistakes multiplies. In such a case, I'd recommend perhaps making a DataTable in Unreal and tracking large changes in a .csv spreadsheet or the like. More information on that is provided in the <em>Further reading</em> section. For now, though, let's go to each of our projectiles and begin setting default surfaces to default impact noise, thrown projectiles' snow to thrown-snow impacts, and so on:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ef8fe372-77e1-4c50-b5b2-99e6d8a858db.png"/></div>
<p class="mce-root"/>
<p>Once all of this is set up, then it's just a matter of a bit of code in the <kbd>OnHit</kbd> function for projectiles:</p>
<pre><span>#include</span> <span>"Sound/SoundCue.h"<br/></span><span>EPhysicalSurface</span> <span>surfType</span> <span>=</span> <span>SurfaceType_Default</span><span>;</span>
<span>if</span> <span>(</span><span>OtherComp</span><span>-&gt;</span><span>GetBodyInstance</span><span>()</span> <span>!=</span> <span>nullptr</span> <span>&amp;&amp;</span> <span>OtherComp</span><span>-&gt;</span><span>GetBodyInstance</span><span>()-&gt;</span><span>GetSimplePhysicalMaterial</span><span>()</span> <span>!=</span> <span>nullptr</span><span>)</span>
<span>{</span>
        <span>surfType</span> <span>=</span> <span>OtherComp</span><span>-&gt;</span><span>GetBodyInstance</span><span>()-&gt;</span><span>GetSimplePhysicalMaterial</span><span>()-&gt;</span><span>SurfaceType</span><span>;</span>
<span>}</span>
 
<span>USoundCue</span><span>*</span> <span>cueToPlay</span> <span>=</span> <span>nullptr</span><span>;</span>
<span>for</span> <span>(</span><span>auto</span> <span>physSound</span> <span>:</span> <span>Impac</span><span>tSounds</span><span>)</span>
<span>{</span>
        <span>if</span> <span>(</span><span>physSound</span><span>.</span><span>SurfaceType</span> <span>==</span> <span>surfType</span><span>)</span>
        <span>{</span>
                <span>cueToPlay</span> <span>=</span> <span>physSound</span><span>.</span><span>SoundCue</span><span>;</span>
                <span>break</span><span>;</span>
        <span>}</span>
<span>}</span>
 
<span>const</span> <span>float</span> <span>minVelocity</span> <span>=</span> <span>400.0f</span><span>;</span>
<span>if</span> <span>(</span><span>cueToPlay</span> <span>!=</span> <span>nullptr</span> <span>&amp;&amp;</span> <span>GetVelocity</span><span>().</span><span>Size</span><span>()</span> <span>&gt;</span> <span>minVelocity</span><span>)</span>
<span>{</span>
        <span>UGameplayStatics</span><span>::</span><span>PlaySoundAtLocation</span><span>(</span><span>this</span><span>,</span> <span>cueToPlay</span><span>,</span> <span>Hit</span><span>.</span><span>Location</span><span>);</span>
<span>}</span></pre>
<p>Unfortunately, our <kbd>FHitResult</kbd> is for us the projectile in this case. Also note the hardcoded minimum velocity: this is to prevent spamming the game with a huge number of very small bounces towards the end of the projectile's velocity/lifetime, but you could of course handle this in a number of other or more flexible ways. If you are in the future looking to play a sound from that perspective, there is a great accessor to make getting the surface type trivial here:</p>
<pre><span>UGameplayStatics</span><span>::</span><span>GetSurfaceType</span><span>(</span><span>Hit</span><span>);</span></pre>
<p>The most obvious facing surface in the default map has been set to a stone type, for testing, and now the different surfaces and different projectiles can be shown, changing their impact sounds! The next section will work briefly in our new (finally visual high quality) map for footfalls and setting reverb based on a sound volume.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Player footfalls and environment FX</h1>
                </header>
            
            <article>
                
<p>Now our player finally gets some footstep sounds of their own. Again, we'll work with what we've got, but we can hopefully find a few types to at least prove out the system so helping teammates in future work should come easily. The footfall work can be done almost identically to the projectile hits, but we'll trigger it from specific moments in the player's (albeit very limited) moving animation. These will simply trigger a ray-cast, we'll get the material, and once we have it, the work will make footsteps work everywhere we go.</p>
<p>First, MasteringCharacter needs the same struct as our projectile just got. In general, assuming more things will use this shared functionality, I'd move the struct and some of this behavior into an actor component but as it's not super informative for our lesson here, we'll just forgive ourselves a little bit of copy/paste for now, first from the top of our .h file:</p>
<pre><span>USTRUCT</span><span>(</span><span>BlueprintType</span><span>)</span>
<span>struct</span> <span>FFootstepSounds</span>
<span>{</span>
        <span>GENERATED_USTRUCT_BODY</span><span>()</span>
 
        <span>UPROPERTY</span><span>(</span><span>EditAnywhere</span><span>,</span> <span>BlueprintReadWrite</span><span>)</span>
        <span>TEnumAsByte</span><span>&lt;</span><span>EPhysicalSurface</span><span>&gt;</span> <span>SurfaceType</span><span>;</span>
 
        <span>UPROPERTY</span><span>(</span><span>EditAnywhere</span><span>,</span> <span>BlueprintReadWrite</span><span>)</span>
        <span>class</span> <span>USoundCue</span><span>*</span> <span>SoundCue</span><span>;</span>
<span>};</span></pre>
<pre><span>UPROPERTY</span><span>(</span><span>EditAnywhere</span><span>,</span> <span>BlueprintReadWrite</span><span>)</span>
<span>TArray</span><span>&lt;</span><span>FFootstepSounds</span><span>&gt;</span> <span>FootstepSounds</span><span>;</span></pre>
<pre><span>UFUNCTION</span><span>(</span><span>BlueprintCallable</span><span>)</span>
<span>void</span> <span>PlayFootstepSound</span><span>();</span></pre>
<p>Next, we'll do this in our .cpp file:</p>
<pre><span>#include</span> <span>"Sound/SoundCue.h"</span>
<span>#include</span> <span>"PhysicalMaterials/PhysicalMaterial.h"</span></pre>
<p>Snippet</p>
<pre><span>void</span> <span>AMasteringCharacter</span><span>::</span><span>PlayFootstepSound</span><span>()</span>
<span>{</span>
        <span>FVector</span> <span>startPos</span> <span>=</span> <span>GetActorLocation</span><span>();</span>
        <span>FVector</span> <span>endPos</span> <span>=</span> <span>startPos</span> <span>-</span> <span>FVector</span><span>(</span><span>0.0f</span><span>,</span> <span>0.0f</span><span>,</span> <span>200.0f</span><span>);</span> <span>// 2m down</span>
 
        <span>FCollisionQueryParams</span> <span>queryParams</span><span>;</span>
        <span>queryParams</span><span>.</span><span>AddIgnoredActor</span><span>(</span><span>this</span><span>);</span>
        <span>queryParams</span><span>.</span><span>bTraceComplex</span> <span>=</span> <span>true</span><span>;</span>
        <span>queryParams</span><span>.</span><span>bReturnPhysicalMaterial</span> <span>=</span> <span>true</span><span>;</span>
        <span>FHitResult</span> <span>hitOut</span><span>;</span>
 
        <span>bool</span> <span>bHit</span> <span>=</span> <span>GetWorld</span><span>()-&gt;</span><span>LineTraceSingleByProfile</span><span>(</span><span>hitOut</span><span>,</span> <span>startPos</span><span>,</span> <span>endPos</span><span>,</span> <span>TEXT</span><span>(</span><span>"IgnoreOnlyPawn"</span><span>));</span>
 
        <span>if</span> <span>(</span><span>bHit</span><span>)</span>
        <span>{</span>
                <span>EPhysicalSurface</span> <span>surfHit</span> <span>=</span> <span>SurfaceType_Default</span><span>;</span>
 
                <span>if</span> <span>(</span><span>hitOut</span><span>.</span><span>Component</span><span>-&gt;</span><span>GetBodyInstance</span><span>()</span> <span>!=</span> <span>nullptr</span> <span>&amp;&amp;</span> <span>hitOut</span><span>.</span><span>Component</span><span>-&gt;</span><span>GetBodyInstance</span><span>()-&gt;</span><span>GetSimplePhysicalMaterial</span><span>()</span> <span>!=</span> <span>nullptr</span><span>)</span>
                <span>{</span>
                        <span>surfHit</span> <span>=</span> <span>hitOut</span><span>.</span><span>Component</span><span>-&gt;</span><span>GetBodyInstance</span><span>()-&gt;</span><span>GetSimplePhysicalMaterial</span><span>()-&gt;</span><span>SurfaceType</span><span>;</span>
                <span>}</span>
 
                <span>if</span> <span>(</span><span>hitOut</span><span>.</span><span>PhysMaterial</span> <span>!=</span> <span>nullptr</span><span>)</span>
                <span>{</span>
                        <span>surfHit</span> <span>=</span> <span>hitOut</span><span>.</span><span>PhysMaterial</span><span>-&gt;</span><span>SurfaceType</span><span>;</span>
                <span>}</span>
                <span>USoundCue</span><span>*</span> <span>cueToPlay</span> <span>=</span> <span>nullptr</span><span>;</span>
                <span>for</span> <span>(</span><span>auto</span> <span>physSound</span> <span>:</span> <span>Foots</span><span>tepSounds</span><span>)</span>
                <span>{</span>
                        <span>if</span> <span>(</span><span>physSound</span><span>.</span><span>SurfaceType</span> <span>==</span> <span>surfHit</span><span>)</span>
                        <span>{</span>
                                <span>cueToPlay</span> <span>=</span> <span>physSound</span><span>.</span><span>SoundCue</span><span>;</span>
                                <span>break</span><span>;</span>
                        <span>}</span>
                <span>}</span>
 
                <span>if</span> <span>(</span><span>cueToPlay</span> <span>!=</span> <span>nullptr</span><span>)</span>
                <span>{</span>
                        <span>UGameplayStatics</span><span>::</span><span>PlaySoundAtLocation</span><span>(</span><span>this</span><span>,</span> <span>cueToPlay</span><span>,</span> <span>hitOut</span><span>.</span><span>Location</span><span>);</span>
                <span>}</span>
        <span>}</span>
<span>}</span></pre>
<p>Notice that we'll do our own raytrace to see what's below us and use that for the results of what and where to play. Note also that in my experience, even though we are getting a hit on a static mesh with a physical material, we still have to manually dig it out as even specifying in the query to return a physical material always comes back as <kbd>nullptr</kbd> in the hit result.</p>
<p>To trigger these, we need a new event in the minimalist first-person running animation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bf4d1848-1143-4072-b772-cc7a5c49b5d5.png"/></div>
<p>And we'll add a call to our pawn's new function from <span class="packt_screen">FirstPerson_AnimBP</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3630402e-7f10-45ca-ab3f-6bf3b4aba1bd.png"/></div>
<p>Similarly, new footstep sound cues were added in the editor and added to the array on our stealth character, just like with the weapons. Now we have some weird-sounding footstep noises!</p>
<p>Opening the FrozenCove level finally, we'll select several surfaces that look like stone or ice and you can easily jump to their materials from there. You can also see there is an existing stone physical material from the level as downloaded in <span class="packt_screen">InfinityBladeIceLands/Environments/SurfaceTypes</span>.</p>
<p>Click the materials of those static meshes to open them and we'll set several of their physical materials:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/98978714-5891-4670-a926-881ad342e0a9.png"/></div>
<p>To do this fully, we'll make a new snow physical material duplicating the stone one (which is effectively set to stone as surface type 2, but should be explicitly set to stone now that we added it by name to our project), name it <span class="packt_screen">PhysicalMaterial_Snow</span>, and we'll set the new one to snow surface type of course in its properties. The whole list of materials changed can be seen in GitHub, but some examples are (all under <span class="packt_screen">InfinityBladeIceLands/Environments/Ice</span>) <span class="packt_screen">Ice_Fortress/Materials/M_Ice_FortFloor_1_SnowPaint</span> and <span class="packt_screen">Ice_Castle/Materials/M_IceT3_Fort_Floor_05</span>.</p>
<p>And finally, we right-click and add a new <span class="packt_screen">Sounds/Reverb</span> object in <span class="packt_screen">InfinityBladeIceLands/Effects</span>, named here <span class="packt_screen">WallReverb</span>, and it's been given some pretty extreme parameters to make its presence obvious when used. And how is it used? Simple! In the level, on the left in the basic types, under <span class="packt_screen">Volumes</span> is <span class="packt_screen">AudioVolume</span>, in this case added to the whole corridor on the left from where the player starts:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5e0a549c-ff3f-44ab-9b84-e79069f3c76a.png"/></div>
<p>Set its reverb object to the one we just created, and you can't miss the change when moving in there and making any sounds. There are a huge number of possibilities with this sort of work to explore, and if you're immediately curious, it is definitely possible to allow whole classes of sounds to ignore effects (and some, if set to the UI type, already do by default).</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>While audio is often left as an afterthought to games, the work done here should hopefully show just how much is possible in UE4 and why it's important. Getting sounds right and being able to tell your designers and other team members how to do these things (or even that they're readily possible!) is a huge advantage over many less experienced teams trying to make a similar game. Don't be left out in the cold on this one: your audience will thank you!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the absolutely simplest way to quickly play a sound during gameplay?</li>
<li>What are the major components of the dialog system?</li>
<li>Which situations will the dialog system suffice in, and where will it require a managing system on top of it?</li>
<li>How do we play a simple sound from an animation?</li>
<li>What is the preferred route to play more complex and varied sounds from animations?</li>
<li>How do we find the material hit in a collision, and why is it never as obvious as it appears it should be?</li>
<li>Where are surface types defined, and where are they then applied from in game?</li>
<li>How can a level or sound designer quickly set up areas in a level to differentiate the audio properties there?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Git LFS:</p>
<p><a href="https://help.github.com/articles/installing-git-large-file-storage/">https://help.github.com/articles/installing-git-large-file-storage/</a></p>
<p><span>Unreal Dialog system:</span></p>
<p><a href="https://docs.unrealengine.com/en-us/Engine/Audio/Dialogue">https://docs.unrealengine.com/en-us/Engine/Audio/Dialogue</a></p>
<p>Ambient sounds:</p>
<p><a href="https://docs.unrealengine.com/en-us/Engine/Audio/SoundActors">https://docs.unrealengine.com/en-us/Engine/Audio/SoundActors</a></p>
<p>DataTables driven and maintained via .csv:</p>
<p><a href="https://docs.unrealengine.com/en-us/Gameplay/DataDriven">https://docs.unrealengine.com/en-us/Gameplay/DataDriven</a></p>


            </article>

            
        </section>
    </body></html>