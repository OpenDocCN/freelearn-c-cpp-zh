<html><head></head><body>
<div><h1 class="chapterNumber">12</h1>
<h1 class="chapterTitle" id="_idParaDest-170">Writing C++ HAL</h1>
<p class="normal">A <strong class="keyWord">Hardware Abstraction Layer</strong> (<strong class="keyWord">HAL</strong>) is a core software component in embedded projects. It simplifies interactions with hardware peripherals by providing an easy-to-use interface that abstracts the <a id="_idIndexMarker544"/>hardware details. The HAL manages the reading and writing of memory-mapped peripheral registers, allowing you to use peripherals such as GPIOs, timers, and serial communication interfaces, without dealing directly with low-level hardware specifics. It often supports multiple devices within the same family.</p>
<p class="normal">By using a HAL, firmware becomes more portable across different devices and similar families from the same vendor. It hides the register layouts of memory-mapped peripherals, making it easier to reuse drivers and business logic on various devices. The HAL handles platform-specific details, enabling developers to focus on the application rather than hardware nuances. It also <a id="_idIndexMarker545"/>manages differences among different series of <strong class="keyWord">microcontrollers</strong> (<strong class="keyWord">MCUs</strong>).</p>
<p class="normal">It’s recommended to use vendor-provided HALs, typically delivered as C libraries, because they are well-tested and regularly maintained. Still, in some cases, it may be needed to work directly with memory-mapped peripherals, thus, in this chapter, we will explore C++ techniques that can help you write safer and more expressive HALs. In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Memory-mapped peripherals</li>
<li class="bulletList">Timers</li>
</ul>
<h1 class="heading-1" id="_idParaDest-171">Technical requirements</h1>
<p class="normal">The examples from this chapter are available on GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter12">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter12</a>). To get the most out of this chapter, run the examples in the Renode simulator.</p>
<h1 class="heading-1" id="_idParaDest-172">Memory-mapped peripherals</h1>
<p class="normal"><strong class="keyWord">Memory-mapped peripherals</strong> allow programs to control hardware devices by reading from and writing <a id="_idIndexMarker546"/>to specific memory addresses. Both peripheral registers and RAM are mapped to the same address space, making communication with hardware registers as simple as writing and reading to a pointer that points to those locations.</p>
<p class="normal">In previous <a id="_idIndexMarker547"/>examples in this book, we used an ST-provided HAL written in C, which controls hardware peripherals through <strong class="keyWord">Common Microcontroller Software Interface Standard</strong> (<strong class="keyWord">CMSIS</strong>) headers.</p>
<p class="normal">CMSIS is a vendor-independent HAL and software library collection for Arm Cortex-based microcontrollers. Developed by Arm, it standardizes hardware access and configuration, simplifying software development and improving code portability across different manufacturers. Each microcontroller vendor provides its own CMSIS implementation, adapting the core APIs and drivers to their specific devices. Next, we will explore CMSIS implementation of access to memory-mapped peripherals for the STM32F072 microcontroller.</p>
<h2 class="heading-2" id="_idParaDest-173">CMSIS memory-mapped peripherals</h2>
<p class="normal">Access <a id="_idIndexMarker548"/>to registers in CMSIS is modeled through pointers to structs that describe register layout. CMSIS defines macros <a id="_idIndexMarker549"/>representing pointers to memory-mapped peripherals.</p>
<p class="normal">Structs, according to <a id="_idIndexMarker550"/>CMSIS naming conventions, are named using the peripheral name abbreviation and <code class="inlineCode">_TypeDef</code> postfix. The <strong class="keyWord">reset and clock control</strong> (<strong class="keyWord">RCC</strong>) peripheral struct is named <code class="inlineCode">RCC_TypeDef</code>. It is defined in example projects in the <code class="inlineCode">platform/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h</code> file, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">typedef struct
{
  __IO uint32_t CR;         /* Address offset: 0x00 */
  __IO uint32_t CFGR;      /* Address offset: 0x04 */
  __IO uint32_t CIR;       /* Address offset: 0x08 */
  __IO uint32_t APB2RSTR;  /* Address offset: 0x0C */
  __IO uint32_t APB1RSTR;  /* Address offset: 0x10 */
  __IO uint32_t AHBENR;    /* Address offset: 0x14 */ 
  __IO uint32_t APB2ENR;   /* Address offset: 0x18 */ 
  __IO uint32_t APB1ENR;   /* Address offset: 0x1C */  
  __IO uint32_t BDCR;      /* Address offset: 0x20 */  
  __IO uint32_t CSR;       /* Address offset: 0x24 */   
  __IO uint32_t AHBRSTR;   /* Address offset: 0x28 */  
  __IO uint32_t CFGR2;     /* Address offset: 0x2C */
  __IO uint32_t CFGR3;     /* Address offset: 0x30 */
  __IO uint32_t CR2;       /* Address offset: 0x34 */
} RCC_TypeDef;
</code></pre>
<p class="normal">In the <a id="_idIndexMarker551"/>same header <a id="_idIndexMarker552"/>file, along with the <code class="inlineCode">RCC_TypeDef</code> struct, the following macros are defined:</p>
<pre class="programlisting code"><code class="hljs-code">#define PERIPH_BASE           0x40000000UL
/*!&lt; Peripheral memory map */
#define APBPERIPH_BASE        PERIPH_BASE
#define AHBPERIPH_BASE       (PERIPH_BASE + 0x00020000UL)
/*!&lt; AHB peripherals */
#define RCC_BASE            (AHBPERIPH_BASE + 0x00001000UL)
/*!&lt; Peripheral_declaration */
#define RCC                 ((RCC_TypeDef *) RCC_BASE)
</code>
SystemInit</code> function:</pre>
<pre class="programlisting code"><code class="hljs-code">/* Set HSION bit */
RCC-&gt;CR |= (uint32_t)0x00000001U;
</code></pre>
<p class="normal">In this code, we are setting up the HSION bit of the clock control register (<code class="inlineCode">CR</code>) or the <code class="inlineCode">RCC</code> peripheral, and we know we are doing that because of the comment in the code. Also, nothing is preventing us from setting <code class="inlineCode">CR</code> to any random value. Here is an example of usage of the clock configuration register (<code class="inlineCode">CFGR</code>) from the <code class="inlineCode">RCC</code> peripheral:</p>
<pre class="programlisting code"><code class="hljs-code">/* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
RCC-&gt;CFGR &amp;= (uint32_t)0x08FFB80CU;
</code></pre>
<p class="normal">This code sets PLL division, various prescaler, and clock settings. It’s not quite obvious which settings are applied from the hex value <code class="inlineCode">0x08FFB80CU</code>.</p>
<p class="normal">Even though <a id="_idIndexMarker553"/>this approach <a id="_idIndexMarker554"/>is common, there are several issues with modeling access to peripherals using register structs and a pointer pointing to the peripheral’s base address:</p>
<ul>
<li class="bulletList">The first is reduced readability. We can write <code class="inlineCode">arbitrary uint32_t</code> values in hex format, making the code meaningless and requiring us to refer to reference manuals of microcontrollers.</li>
<li class="bulletList">As we can write any value we want to a register, we can easily write wrong or even random values.</li>
<li class="bulletList">Individual registers of a peripheral in a struct must be ordered according to their memory layout. Members named <code class="inlineCode">RESERVERDn</code> are used to add space into the structure for adjusting the addresses of the peripheral registers and to prevent padding.</li>
<li class="bulletList">CMSIS headers may contain macros defining bit masks for accessing individual settings in a register, which simplifies access to peripheral registers. Still, these macros are not making the code any safer, just easier to work with.</li>
</ul>
<p class="normal">Let’s see how we can utilize C++ to address these concerns, making the code safer and more readable.</p>
<h2 class="heading-2" id="_idParaDest-174">Memory-mapped peripherals in C++</h2>
<p class="normal">We will <a id="_idIndexMarker555"/>use the knowledge we gained in previous chapters to <a id="_idIndexMarker556"/>create an expressive and type-safe interface to access memory-mapped peripherals in C++. We will create an interface with the following qualities:</p>
<ul>
<li class="bulletList">Read and write access control to a hardware register</li>
<li class="bulletList">Type-safe write to a register</li>
<li class="bulletList">Expressive and easy to use</li>
</ul>
<p class="normal">Let us start with a basic implementation of an interface representing a memory-mapped register that will match the CMSIS approach in functionality. The code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">struct read_access{};
struct write_access{};
struct read_write_access : read_access, write_access {};
template&lt;std::uintptr_t Address, typename Access = read_write_access, typename T = std::uint32_t&gt;
struct reg {
template &lt;typename Access_ = Access&gt;
static std::enable_if_t&lt;std::is_base_of_v&lt;read_access, Access_&gt;, T&gt; 
read()
{
    return *reinterpret_cast&lt;volatile T*&gt;(Address);
}
template &lt;typename Access_ = Access&gt;
static std::enable_if_t&lt;std::is_base_of_v&lt;write_access, Access_&gt;, void&gt;
write(T val)
{
    *reinterpret_cast&lt;volatile T*&gt;(Address) = val;
}
};
</code></pre>
<p class="normal">In this <a id="_idIndexMarker557"/>code, the class template <code class="inlineCode">reg</code> models a hardware <a id="_idIndexMarker558"/>register. It has the following template parameters:</p>
<ul>
<li class="bulletList"><code class="inlineCode">uintptr_t Address</code>: The memory address of the hardware register</li>
<li class="bulletList"><code class="inlineCode">typename Access</code>: The access rights for the register (defaults to <code class="inlineCode">read_write_access</code>)</li>
<li class="bulletList"><code class="inlineCode">typename T</code>: The data type matching the size of the register (defaults to <code class="inlineCode">std::uint32_t</code>)</li>
</ul>
<p class="normal">The class template <code class="inlineCode">reg</code> has two static methods: <code class="inlineCode">read</code> and <code class="inlineCode">write</code>. These are used to read from and write to a register, respectively. Both methods are enabled or disabled at compile time using SFINAE, which we covered in <a href="Chapter_08.xhtml"><em class="italic">Chapter 8</em></a>. We are using the following types of access control:</p>
<ul>
<li class="bulletList"><code class="inlineCode">struct read_access</code></li>
<li class="bulletList"><code class="inlineCode">struct write_access</code></li>
<li class="bulletList"><code class="inlineCode">struct read_write_access</code>: This inherits from both <code class="inlineCode">read_access</code> and <code class="inlineCode">write_access</code></li>
</ul>
<p class="normal">To enable and disable <code class="inlineCode">write</code> and <code class="inlineCode">read</code> methods at compile time using SFINAE, we made both methods template functions. This allows us to use the class template <code class="inlineCode">enable_if</code> at the return type of these methods to either enable or disable them, depending on the condition provided to it.</p>
<p class="normal">The template parameter for both <code class="inlineCode">write</code> and <code class="inlineCode">read</code> is <code class="inlineCode">Access_</code>, which defaults to <code class="inlineCode">Access</code>. It ensures that SFINAE works correctly by making the substitution dependent on a template parameter of the function itself.</p>
<p class="normal">We are enabling the <code class="inlineCode">read</code> method using <code class="inlineCode">std::enable_if_t&lt;std::is_base_of_v&lt;read_access, Access_&gt;, T&gt;</code>. This means that if <code class="inlineCode">std::is_base_of_v&lt;read_access, Access_&gt;</code> is true (i.e., if <code class="inlineCode">Access_</code> is derived from or is the same as <code class="inlineCode">read_access</code>), <code class="inlineCode">std::enable_if_t</code> resolves to <code class="inlineCode">T</code>, and the function is enabled. Otherwise, it results in a substitution failure, and the function is not included in the overload set. We are <a id="_idIndexMarker559"/>enabling the <code class="inlineCode">write</code> method in a similar fashion, by checking whether <code class="inlineCode">Access_</code> type is derived from or the same as <code class="inlineCode">write_access</code>.</p>
<p class="normal">We use <code class="inlineCode">reinterpret_cast&lt;volatile T*&gt;</code> to convert the integer template parameter <code class="inlineCode">Address</code> into a <a id="_idIndexMarker560"/>pointer to a volatile variable of type <code class="inlineCode">T</code> (which defaults to <code class="inlineCode">std::uint32_t</code>). The <code class="inlineCode">volatile</code> keyword informs the compiler that the value at this memory location can change at any time outside the program’s control – by hardware. This prevents the compiler from applying certain optimizations that might omit necessary reads or writes to this address.</p>
<p class="normal">Without <code class="inlineCode">volatile</code>, the compiler might assume that multiple reads from the same address yield the same value or that writes to the address can be reordered or even omitted, which can lead to incorrect behavior when interacting with hardware.</p>
<p class="normal">As we discussed in <a href="Chapter_09.xhtml"><em class="italic">Chapter 9</em></a>, casting an integer to a pointer using <code class="inlineCode">reinterpret_cast</code> is considered an implementation-defined behavior in C++. This means the C++ standard doesn’t specify exactly how it should work, and different compilers or platforms might handle it differently. Writing directly to a specific memory location is inherently unsafe and relies on behavior that isn’t guaranteed to be portable across all systems. Therefore, we need to be cautious about the portability of this solution, as some platforms may implement pointer conversions differently.</p>
<p class="normal">Here are a few examples of using the class template <code class="inlineCode">reg</code>:</p>
<pre class="programlisting code"><code class="hljs-code">using rcc = reg&lt;0x40021000&gt;;
auto val = rcc::read(); // ok
rcc::write(0xDEADBEEF); // ok
using rcc_read = reg&lt;0x40021000, read_access&gt;;
auto val = rcc_read::read(); // ok
rcc_read::write(0xDEADBEEF); // compiler-error, no write access
using rcc_write = reg&lt;0x40021000, write_access&gt;;
auto val = rcc_write::read(); // compiler-error, no read access
rcc_write::write(0xDEADBEEF); // ok
</code></pre>
<p class="normal">These examples demonstrate the usage of the implemented interface for accessing memory-mapped peripherals. When defining types using the class template <code class="inlineCode">reg</code>, we provide it with the address of a register and <code class="inlineCode">write</code> access if we are working with write-only or read-only registers. The default access type allows us both read and write privileges.</p>
<p class="normal">The preceding <a id="_idIndexMarker561"/>solution is as effective as the CMSIS approach. You can experiment with the full example and compare binary sizes by running the full <a id="_idIndexMarker562"/>example in Renode. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter12/cpp_hal</code> project as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake -B build -DCMAKE_BUILD_TYPE=Release -DMAIN_CPP_FILE_NAME=main_basic_reg.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Our current solution still allows us to write arbitrary values to registers. To address this, we will use strong types based on <code class="inlineCode">enum</code> classes to model bit fields used to set different settings in registers.</p>
<h2 class="heading-2" id="_idParaDest-175">Type-safe memory-mapped peripherals in C++</h2>
<p class="normal">To prevent arbitrary writings to a register using the class template <code class="inlineCode">reg</code>, we will add a new static <a id="_idIndexMarker563"/>method, <code class="inlineCode">set</code>, which will accept only types meeting certain criteria. We will model these types by <a id="_idIndexMarker564"/>creating a <code class="inlineCode">BitFieldConcept</code>. We covered concepts in <a href="Chapter_08.xhtml"><em class="italic">Chapter 8</em></a>. Also, we will remove public access to the <code class="inlineCode">write</code> method and put it instead in the <code class="inlineCode">private</code> section. The modified code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;typename BitField, typename Reg, typename T&gt;
concept BitFieldConcept =
    std::is_same_v&lt;Reg, typename BitField::reg&gt; &amp;&amp;
    std::is_enum_v&lt;typename BitField::value&gt; &amp;&amp;
    std::is_same_v&lt;std::underlying_type_t&lt;typename
BitField::value&gt;, T&gt;;
template&lt;std::uintptr_t Address, typename Access = read_write_access, typename T = std::uint32_t&gt;
struct reg {
using RegType = T;
     // Type alias for the current instantiation
using ThisReg = reg&lt;Address, Access, T&gt;;
template&lt;typename BitField&gt;
requires <code class="inlineCode">BitFieldConcept</code>&lt;BitField, ThisReg, T&gt;
static void set(BitField::value bits_val)
{
    auto reg_value = read();
    reg_value &amp;= ~BitField::c_mask;
    reg_value |= (static_cast&lt;T&gt;(bits_val) &lt;&lt;
          BitField::c_position) &amp; BitField::c_mask;
    write(reg_value);
}
template &lt;typename Access_ = Access&gt;
static std::enable_if_t&lt;std::is_base_of_v&lt;read_access, Access_&gt;, T&gt; 
read()
{
    return *reinterpret_cast&lt;volatile T*&gt;(Address);
}
private:
   
template &lt;typename Access_ = Access&gt;
static std::enable_if_t&lt;std::is_base_of_v&lt;write_access, Access_&gt;, void&gt; 
write(T val)
{
    *reinterpret_cast&lt;volatile T*&gt;(Address) = val;
}
};
</code></pre>
<p class="normal">The <a id="_idIndexMarker565"/>template method <code class="inlineCode">set</code> has a single template <a id="_idIndexMarker566"/>parameter – type <code class="inlineCode">BitField</code>. We use <code class="inlineCode">BitFieldConcept</code> to impose the following requirements on the <code class="inlineCode">BitField</code>:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Reg</code> must be the same as <code class="inlineCode">BitField::reg</code>. This ensures the bit field is associated with the correct register.</li>
<li class="bulletList"><code class="inlineCode">BitField::value</code> must be an <code class="inlineCode">enum</code>.</li>
<li class="bulletList">The underlying type of the <code class="inlineCode">BitField::value</code> <code class="inlineCode">enum</code> must be <code class="inlineCode">T</code>. This ensures that values represented by the <code class="inlineCode">enum</code> can fit in the registers.</li>
</ul>
<p class="normal">The <code class="inlineCode">set</code> function <a id="_idIndexMarker567"/>parameter is <code class="inlineCode">BitField::value bits_val</code>. The <a id="_idIndexMarker568"/>function itself is simple, and it performs <a id="_idIndexMarker569"/>the following operations:</p>
<ul>
<li class="bulletList">Reads the current register value</li>
<li class="bulletList">Clears the bits specified by <code class="inlineCode">BitField::c_mask</code></li>
<li class="bulletList">Sets the new bits by shifting <code class="inlineCode">bits_val</code> to the correct position (<code class="inlineCode">BitField::c_position</code>) and applying the mask</li>
<li class="bulletList">Writes the modified value back to the register</li>
</ul>
<p class="normal">To use the <code class="inlineCode">set</code> function, we need to define types that describe the register’s bit fields and that meet the requirements imposed by the <code class="inlineCode">BitFieldConcept</code>.</p>
<h3 class="heading-3" id="_idParaDest-176">Modeling HSION and HSITRIM bit fields from the RCC register</h3>
<p class="normal">Let us <a id="_idIndexMarker570"/>examine <a id="_idIndexMarker571"/>bit fields in the RCC CR register defined in the STM32F0x2 reference manual document, as shown in <em class="italic">Figure 12</em><em class="italic">.1</em>:</p>
<figure class="mediaobject"><img alt="Figure 12.1 – RCC CR register" src="img/B22402_12_01.png"/></figure>
<p class="packt_figref">Figure 12.1 – RCC CR register</p>
<p class="normal"><em class="italic">Figure 12</em><em class="italic">.1</em> depicts bit fields in the RCC CR register. Let us define a struct <code class="inlineCode">hsion</code> that describes the HSI clock <code class="inlineCode">enable</code> bit field from the RCC CR register. It has only one bit on position <code class="inlineCode">0</code>, so we can model it as follows:</p>
<pre class="programlisting code"><code class="hljs-code">using rcc = reg&lt;0x40021000&gt;;
struct hsion {
    using reg = rcc;
    using T = reg::RegType;
    static constexpr T c_position = 0U;
    static constexpr T c_mask = (1U &lt;&lt; c_position);
    enum class value : T {
        disable = 0U,
        enable  = 1U,
    };
};
</code></pre>
<p class="normal">In this <a id="_idIndexMarker572"/>code, we declare type <code class="inlineCode">rcc</code> as an instance of the class template <code class="inlineCode">reg</code> by providing it with <a id="_idIndexMarker573"/>the address of the RCC register. Then, we create a struct <code class="inlineCode">hsion</code> with the following properties:</p>
<ul>
<li class="bulletList">A public <code class="inlineCode">typedef</code> member <code class="inlineCode">reg</code>, which we set to <code class="inlineCode">rcc</code>. This “maps” <code class="inlineCode">hsion</code> to the <code class="inlineCode">rcc</code> register thanks to <code class="inlineCode">BitFieldConcept</code>.</li>
<li class="bulletList">The <code class="inlineCode">constexpr</code> variables <code class="inlineCode">c_position</code> and <code class="inlineCode">c_mask</code>, used for bit manipulation by the <code class="inlineCode">set</code> method.</li>
<li class="bulletList">An <code class="inlineCode">enum</code> class <code class="inlineCode">value</code>, defining <code class="inlineCode">enable</code> and <code class="inlineCode">disable</code>.</li>
</ul>
<p class="normal">We can use the <code class="inlineCode">hsion</code> struct to enable or disable the HSI clock using the following code:</p>
<pre class="programlisting code"><code class="hljs-code">rcc::set&lt;hsion&gt;(hsion::value::enable);
rcc::set&lt;hsion&gt;(hsion::value::disable);
</code></pre>
<p class="normal">This code allows us to safely set bits in a register. It is also expressive: the syntax <code class="inlineCode">rcc::set&lt;hsion&gt;(hsion::value::enable);</code> clearly communicates the intent – setting the <code class="inlineCode">hsion</code> bit field to <code class="inlineCode">enable</code> on the <code class="inlineCode">rcc</code> register.</p>
<p class="normal">As we can see in <em class="italic">Figure 12</em><em class="italic">.1</em>, most of the defined bit fields in the <code class="inlineCode">CR</code> register are <code class="inlineCode">enable</code>/<code class="inlineCode">disable</code> bits. Exceptions are:</p>
<ul>
<li class="bulletList"><code class="inlineCode">HSICAL[7:0]: HSI clock calibration</code>: These bits are automatically initialized at startup and can be adjusted by software via the <code class="inlineCode">HSITRIM</code> setting.</li>
<li class="bulletList"><code class="inlineCode">HSITRIM[4:0]: HSI clock trimming</code>: These bits offer an additional user-programmable trimming value added to the <code class="inlineCode">HSICAL[7:0]</code> bits. This setting allows adjustments for voltage and temperature variations that may affect the HSI frequency.</li>
</ul>
<p class="normal"><code class="inlineCode">HSICAL</code> bits are initialized at startup, meaning we shouldn’t modify them. <code class="inlineCode">HSITRIM</code> bits are user-programmable, and they occupy 5 bits. Defining all combinations of 5 bits in the <code class="inlineCode">BitField</code> value <code class="inlineCode">enum</code> wouldn’t be practical, so we will approach this by providing value through a template parameter, as shown in the code here:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;auto Bits&gt;
struct <code class="inlineCode">hsi_trim</code> {
    using reg = rcc;
    using T = reg::RegType;
    <code class="inlineCode">static_assert</code>(std::is_same_v&lt;T, decltype(Bits)&gt;);
    static constexpr T c_position = 3;
    static constexpr T c_mask = (0x1F &lt;&lt; c_position);
    <code class="inlineCode">static_assert</code>(Bits &lt;= 0x1F);
    enum class value : T {
        val = Bits
    };
};
</code></pre>
<p class="normal">In this code, we <a id="_idIndexMarker574"/>defined the class template <code class="inlineCode">hsitrim</code> with the auto template parameter <code class="inlineCode">Bits</code>. The <code class="inlineCode">auto</code> keyword is used to indicate that we are using a non-type template parameter. We <a id="_idIndexMarker575"/>use <code class="inlineCode">static_assert</code> to make sure that the type of provided parameter <code class="inlineCode">Bits</code> (<code class="inlineCode">decltype(Bits)</code>) is the same as the underlying registers type to satisfy requirements imposed by <code class="inlineCode">BitFieldConcept</code>.</p>
<p class="normal">We encode the <code class="inlineCode">enum</code> class value val with the <code class="inlineCode">Bits</code>. This encodes the value in the type itself and makes it possible to use it with the <code class="inlineCode">reg</code> struct <code class="inlineCode">set</code> method. We also utilize <code class="inlineCode">static_assert</code> to make sure that the provided value fits in the allocated number of bits – <code class="inlineCode">static_assert(Bits &lt;= 0x1F)</code>. Again, we are utilizing compile-time operations to ensure type safety. Here is an example of using the <code class="inlineCode">hsitrim</code> struct:</p>
<pre class="programlisting code"><code class="hljs-code">rcc::set&lt;hsi_trim&lt;0xFLU&gt;&gt;(hsi_trim&lt;0xFLU&gt;::value::val);
</code></pre>
<p class="normal">This code sets the <code class="inlineCode">hstrim</code> value in the <code class="inlineCode">rcc</code> register to <code class="inlineCode">0xF</code>. You can experiment with the full example in Renode. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter12/cpp_hal</code> project, as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake -B build -DCMAKE_BUILD_TYPE=Release -DMAIN_CPP_FILE_NAME=main_type_safe_reg.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<h3 class="heading-3" id="_idParaDest-177">Generic versions of hsion and hsi_trim</h3>
<p class="normal">To enable <a id="_idIndexMarker576"/>the reuse <a id="_idIndexMarker577"/>of bit fields that have a single bit (enable/disable) such as <code class="inlineCode">hsion</code>, we will define the class template <code class="inlineCode">reg_bits_enable_disable</code>, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;typename Reg, uint32_t Pos&gt;
struct <code class="inlineCode">reg_bits</code>_enable_disable {
    using reg = Reg;
    using T = reg::RegType;
    static constexpr T c_position = Pos;
    static constexpr T c_mask = (0x1UL &lt;&lt; c_position);
    enum class value : T {
        disable = 0,
        enable = 1
    };
};
</code></pre>
<p class="normal">This defined template type, <code class="inlineCode">reg_bits_enable_disable</code>, could be used to define the <code class="inlineCode">hsion</code> type, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">using hsion = reg_bits_enable_disable&lt;rcc, 0U&gt;;
</code></pre>
<p class="normal">Next, we will create a generic version of the type used to set multiple fields with a value, such as <code class="inlineCode">hsi_trim</code>. We will call it <code class="inlineCode">reg_bits</code>, and the code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;auto Bits, typename Reg, uint32_t Mask, uint32_t Pos = 0&gt;
struct reg_bits {
    using reg = Reg; using T = reg::RegType;
    static_assert(std::is_same_v&lt;T, decltype(Bits)&gt;);
    static constexpr T c_position = Pos;
    static constexpr T c_mask = (Mask &lt;&lt; c_position);
    static_assert(Bits &lt;= Mask);
    enum class value : T {
        val = Bits
    };
};
</code></pre>
<p class="normal">We could <a id="_idIndexMarker578"/>use the <a id="_idIndexMarker579"/>generic type <code class="inlineCode">reg_bits</code> to define the <code class="inlineCode">hsi_trim</code> template type, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;auto Bits&gt;
using hsi_trim = reg_bits&lt;Bits, rcc, 0x1F, 3U&gt;;
</code></pre>
<p class="normal">Next, we will explore how to use C++ to create templates for peripherals that are similar but also have some implementation differences.</p>
<h1 class="heading-1" id="_idParaDest-178">Timers</h1>
<p class="normal"><code class="inlineCode">STM32F072</code> has multiple timers, including TIM2 and TIM3. TIM2 is a 32-bit timer and TIM3 is a 16-bit timer.</p>
<p class="normal">We will <a id="_idIndexMarker580"/>create a template class timer that will depend on timer traits structures containing timer-specific details. Here is the code for timer traits structures:</p>
<pre class="programlisting code"><code class="hljs-code">struct timer2_traits {
    constexpr static std::uintptr_t base_address = 0x40000000;
    constexpr static IRQn_Type irqn = TIM2_IRQn;
    constexpr static std::uint32_t arr_bit_mask = 0xFFFFFFFF;
};
struct timer3_traits {
    constexpr static std::uintptr_t base_address = 0x40000400;
    constexpr static IRQn_Type irqn = TIM3_IRQn;
    constexpr static std::uint32_t arr_bit_mask = 0xFFFF;
};
</code></pre>
<p class="normal">In this code, <code class="inlineCode">timer2_traits</code> and <code class="inlineCode">timer3_traits</code> are traits structures that encapsulate the hardware-specific details of TIM2 and TIM3 timers, respectively. They have the following members:</p>
<ul>
<li class="bulletList"><code class="inlineCode">base_address</code>: The base memory address of the timer’s register map</li>
<li class="bulletList"><code class="inlineCode">irqn</code>: The interrupt request number associated with the timer</li>
<li class="bulletList"><code class="inlineCode">arr_bit_mask</code>: The bit mask for the auto-reload register (ARR):<ul>
<li class="bulletList">For TIM2, it’s <code class="inlineCode">0xFFFFFFFF</code> (32-bit timer).</li>
<li class="bulletList">For TIM3, it’s <code class="inlineCode">0xFFFF </code>(16-bit timer).</li>
</ul>
</li>
</ul>
<p class="normal">Next, let’s <a id="_idIndexMarker581"/>look at the template class timer:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename TimerTraits&gt;
struct timer {
    constexpr static std::uintptr_t base_address =
                                    TimerTraits::base_address;
    using cr1 = reg&lt;base_address + 0x00&gt;;
    using dier = reg&lt;base_address + 0x0C&gt;;
    using sr = reg&lt;base_address + 0x10&gt;;
    using psc = reg&lt;base_address + 0x28&gt;;
    using arr = reg&lt;base_address + 0x2C&gt;;
    
    template&lt;auto Bits&gt;
    using psc_bits = reg_bits&lt;Bits, psc, static_cast&lt;uint32_t&gt;(0xFFFF)&gt;;
    template&lt;auto Bits&gt;
    using arr_bits = reg_bits&lt;Bits, arr, TimerTraits::arr_bit_mask&gt;;
    using uie = reg_bits_enable_disable&lt;dier, 0UL&gt;;
    using cen = reg_bits_enable_disable&lt;cr1, 0UL&gt;;
    using uif = reg_bits_enable_disable&lt;sr, 0UL&gt;;
    template&lt;std::uint32_t Period&gt;
 static void start() {
        // a magic number prescaler value
// for 1ms timer resolution
constexpr std::uint32_t prescaler = 9999;
        constexpr std::uint32_t auto_reload = Period - 1;
        psc::template set&lt;psc_bits&lt;prescaler&gt;&gt;
                    (psc_bits&lt;prescaler&gt;::value::val);
        arr::template set&lt;arr_bits&lt;auto_reload&gt;&gt;
                    (arr_bits&lt;auto_reload&gt;::value::val);
        dier::template set&lt;uie&gt;(uie::value::enable);
        NVIC_SetPriority(TimerTraits::irqn, 1);
        NVIC_EnableIRQ(TimerTraits::irqn);
        cr1::template set&lt;cen&gt;(cen::value::enable);
    }
};
</code></pre>
<p class="normal">In this code, we defined a template class timer with template parameter <code class="inlineCode">TimerTraits</code> – a traits class that <a id="_idIndexMarker582"/>provides hardware-specific constants. The timer class template provides a generic interface to configure and control timers, customized for each specific timer via <code class="inlineCode">TimerTraits</code>.</p>
<p class="normal">Please note that for the sake of simplicity of the example, this is the minimum code needed to set up the STM32 timer peripheral.</p>
<p class="normal">Within the timer class, we define register type aliases, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr static std::uintptr_t base_address = TimerTraits::base_address;
using cr1 = reg&lt;base_address + 0x00&gt;;
using dier = reg&lt;base_address + 0x0C&gt;;
using sr = reg&lt;base_address + 0x10&gt;;
using psc = reg&lt;base_address + 0x28&gt;;
using arr = reg&lt;base_address + 0x2C&gt;;
</code></pre>
<p class="normal">These type aliases represent the timer’s hardware registers, each mapped to a specific memory address. Each register is an instantiation of the <code class="inlineCode">reg</code> class template, which provides read/write access to hardware registers.</p>
<p class="normal">Next, we define type aliases for <code class="inlineCode">BitFields</code>:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;auto Bits&gt;
using psc_bits = reg_bits&lt;Bits, psc, static_cast&lt;uint32_t&gt; (0xFFFF)&gt;;
template&lt;auto Bits&gt;
using arr_bits = reg_bits&lt;Bits, arr, TimerTraits::arr_bit_mask&gt;;
using uie = reg_bits_enable_disable&lt;dier, 0UL&gt;;
using cen = reg_bits_enable_disable&lt;cr1, 0UL&gt;;
using uif = reg_bits_enable_disable&lt;sr, 0UL&gt;;
</code></pre>
<p class="normal">In this code, we instantiate bit fields using the class templates <code class="inlineCode">reg_bits</code> and <code class="inlineCode">reg_bits_enable_disable</code>.</p>
<p class="normal">Finally, we define the template static method <code class="inlineCode">start</code> in the class template timer. This <code class="inlineCode">static</code> function sets up <a id="_idIndexMarker583"/>the timer with the desired period and starts it. The code executes the following steps:</p>
<ol>
<li class="numberedList" value="1">Calculate Prescaler and Auto-Reload values. The function uses the template parameter Period to calculate these values.</li>
<li class="numberedList">Set Prescaler (PSC) and Auto-Reload (ARR) registers.</li>
<li class="numberedList">Enable the update interrupt on the DIER register. It uses the <code class="inlineCode">uie</code> bit field to enable the update interrupt in the DIER register.</li>
<li class="numberedList">Configure NVIC for timer interrupts using CMSIS functions.</li>
<li class="numberedList">Start the timer. It uses the <code class="inlineCode">cen</code> bit field to enable the timer counter in the CR1 register.</li>
</ol>
<p class="normal">Let’s now see how we can use the provided timer template class:</p>
<pre class="programlisting code"><code class="hljs-code">using timer2 = timer&lt;timer2_traits&gt;;
using timer3 = timer&lt;timer3_traits&gt;;
extern "C" void TIM2_IRQHandler(void)
{
    if (timer2::sr::read() &amp; TIM_SR_UIF)
    {
        timer2::sr::set&lt;timer2::uif&gt; (timer2::uif::value::disable);
        printf("TIM2 IRQ..\r\n");
    }
}
extern "C" void TIM3_IRQHandler(void)
{
    if (timer3::sr::read() &amp; TIM_SR_UIF)
    {
        timer3::sr::set&lt;timer3::uif&gt; (timer3::uif::value::disable);
        printf("TIM3 IRQ..\r\n");
    }
}
int main()
{
    timer2::start&lt;1000&gt;();
    timer3::start&lt;500&gt;();
    while(true)
    {
    }
}
</code></pre>
<p class="normal">In this code, we create <a id="_idIndexMarker584"/>the type aliases <code class="inlineCode">timer2</code> and <code class="inlineCode">timer3</code> and implement <strong class="keyWord">Interrupt Request (IRQ)</strong> functions for the <code class="inlineCode">TIM2</code> and <code class="inlineCode">TIM3</code> interrupts. In the IRQs, we clear interrupt flags. We make calls to start functions of types <code class="inlineCode">timer2</code> and <code class="inlineCode">timer3</code> in the <code class="inlineCode">main</code> function.</p>
<p class="normal">You can run the full example in Renode. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter12/cpp_hal</code> project, as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake -B build -DCMAKE_BUILD_TYPE=Release -DMAIN_CPP_FILE_NAME=main_timer_peripheral.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">In this section, we learned <a id="_idIndexMarker585"/>how to create a generic, template-based timer interface by utilizing C++ templates and traits classes. By defining <code class="inlineCode">TimerTraits</code> structures (<code class="inlineCode">timer2_traits</code> and <code class="inlineCode">timer3_traits</code>) that encapsulate hardware-specific details of the TIM2 and TIM3 timers, we can instantiate a flexible <code class="inlineCode">timer</code> class template that abstracts the configuration and control of different timers. This approach offers two main benefits: it increases type safety by using templates to enforce correct usage at compile time, and it results in code that is as efficient as traditional C HAL implementations because the use of templates and constexpr allows the compiler to optimize the code thoroughly.</p>
<h1 class="heading-1" id="_idParaDest-179">Summary</h1>
<p class="normal">In this chapter, we learned techniques that we can apply to create safer HAL code in C++. We covered the implementation of memory-mapped peripherals. The design utilizes templates and advanced techniques such as SFINAE, which we discovered in <a href="Chapter_08.xhtml"><em class="italic">Chapter 8</em></a>. We applied the knowledge from previous chapters in the embedded systems domain.</p>
<p class="normal">We also learned how to design classes that implement generic behavior and depend on traits classes to supply them with specific details. The code we developed is as efficient as a hand-coded (CMSIS-based) solution, thanks to the usage of templates and compile-time computations, enabling compiler optimizations.</p>
<p class="normal">In the next chapter, we will cover working with C libraries in C++.</p>
</div>
</body></html>