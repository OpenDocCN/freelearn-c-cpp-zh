<html><head></head><body>
<div id="_idContainer069">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 class="chapterTitle" id="_idParaDest-170"><span class="koboSpan" id="kobo.2.1">Writing C++ HAL</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">Hardware Abstraction Layer</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">HAL</span></strong><span class="koboSpan" id="kobo.7.1">) is a core software component in embedded projects. </span><span class="koboSpan" id="kobo.7.2">It simplifies interactions with hardware peripherals by providing an easy-to-use interface that abstracts the </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.8.1">hardware details. </span><span class="koboSpan" id="kobo.8.2">The HAL manages the reading and writing of memory-mapped peripheral registers, allowing you to use peripherals such as GPIOs, timers, and serial communication interfaces, without dealing directly with low-level hardware specifics. </span><span class="koboSpan" id="kobo.8.3">It often supports multiple devices within the same family.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">By using a HAL, firmware becomes more portable across different devices and similar families from the same vendor. </span><span class="koboSpan" id="kobo.9.2">It hides the register layouts of memory-mapped peripherals, making it easier to reuse drivers and business logic on various devices. </span><span class="koboSpan" id="kobo.9.3">The HAL handles platform-specific details, enabling developers to focus on the application rather than hardware nuances. </span><span class="koboSpan" id="kobo.9.4">It also </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.10.1">manages differences among different series of </span><strong class="keyWord"><span class="koboSpan" id="kobo.11.1">microcontrollers</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.13.1">MCUs</span></strong><span class="koboSpan" id="kobo.14.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.15.1">It’s recommended to use vendor-provided HALs, typically delivered as C libraries, because they are well-tested and regularly maintained. </span><span class="koboSpan" id="kobo.15.2">Still, in some cases, it may be needed to work directly with memory-mapped peripherals, thus, in this chapter, we will explore C++ techniques that can help you write safer and more expressive HALs. </span><span class="koboSpan" id="kobo.15.3">In this chapter, we will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Memory-mapped peripherals</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Timers</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-171"><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.19.1">The examples from this chapter are available on GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter12"><span class="url"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter12</span></span></a><span class="koboSpan" id="kobo.21.1">). </span><span class="koboSpan" id="kobo.21.2">To get the most out of this chapter, run the examples in the Renode simulator.</span></p>
<h1 class="heading-1" id="_idParaDest-172"><span class="koboSpan" id="kobo.22.1">Memory-mapped peripherals</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.23.1">Memory-mapped peripherals</span></strong><span class="koboSpan" id="kobo.24.1"> allow programs to control hardware devices by reading from and writing </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.25.1">to specific memory addresses. </span><span class="koboSpan" id="kobo.25.2">Both peripheral registers and RAM are mapped to the same address space, making communication with hardware registers as simple as writing and reading to a pointer that points to those locations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.26.1">In previous </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.27.1">examples in this book, we used an ST-provided HAL written in C, which controls hardware peripherals through </span><strong class="keyWord"><span class="koboSpan" id="kobo.28.1">Common Microcontroller Software Interface Standard</span></strong><span class="koboSpan" id="kobo.29.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.30.1">CMSIS</span></strong><span class="koboSpan" id="kobo.31.1">) headers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.32.1">CMSIS is a vendor-independent HAL and software library collection for Arm Cortex-based microcontrollers. </span><span class="koboSpan" id="kobo.32.2">Developed by Arm, it standardizes hardware access and configuration, simplifying software development and improving code portability across different manufacturers. </span><span class="koboSpan" id="kobo.32.3">Each microcontroller vendor provides its own CMSIS implementation, adapting the core APIs and drivers to their specific devices. </span><span class="koboSpan" id="kobo.32.4">Next, we will explore CMSIS implementation of access to memory-mapped peripherals for the STM32F072 microcontroller.</span></p>
<h2 class="heading-2" id="_idParaDest-173"><span class="koboSpan" id="kobo.33.1">CMSIS memory-mapped peripherals</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.34.1">Access </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.35.1">to registers in CMSIS is modeled through pointers to structs that describe register layout. </span><span class="koboSpan" id="kobo.35.2">CMSIS defines macros </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.36.1">representing pointers to memory-mapped peripherals.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.37.1">Structs, according to </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.38.1">CMSIS naming conventions, are named using the peripheral name abbreviation and </span><code class="inlineCode"><span class="koboSpan" id="kobo.39.1">_TypeDef</span></code><span class="koboSpan" id="kobo.40.1"> postfix. </span><span class="koboSpan" id="kobo.40.2">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.41.1">reset and clock control</span></strong><span class="koboSpan" id="kobo.42.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.43.1">RCC</span></strong><span class="koboSpan" id="kobo.44.1">) peripheral struct is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">RCC_TypeDef</span></code><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">It is defined in example projects in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">platform/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h</span></code><span class="koboSpan" id="kobo.48.1"> file, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.49.1">typedef</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.50.1">struct</span></span>
<span class="hljs-class"><span class="koboSpan" id="kobo.51.1">{</span></span><span class="koboSpan" id="kobo.52.1">
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.53.1">uint32_t</span></span><span class="koboSpan" id="kobo.54.1"> CR;         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.55.1">/* Address offset: 0x00 */</span></span><span class="koboSpan" id="kobo.56.1">
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.57.1">uint32_t</span></span><span class="koboSpan" id="kobo.58.1"> CFGR;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.59.1">/* Address offset: 0x04 */</span></span><span class="koboSpan" id="kobo.60.1">
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.61.1">uint32_t</span></span><span class="koboSpan" id="kobo.62.1"> CIR;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.63.1">/* Address offset: 0x08 */</span></span><span class="koboSpan" id="kobo.64.1">
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.65.1">uint32_t</span></span><span class="koboSpan" id="kobo.66.1"> APB2RSTR;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.67.1">/* Address offset: 0x0C */</span></span><span class="koboSpan" id="kobo.68.1">
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.69.1">uint32_t</span></span><span class="koboSpan" id="kobo.70.1"> APB1RSTR;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.71.1">/* Address offset: 0x10 */</span></span><span class="koboSpan" id="kobo.72.1">
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.73.1">uint32_t</span></span><span class="koboSpan" id="kobo.74.1"> AHBENR;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.75.1">/* Address offset: 0x14 */</span></span><span class="koboSpan" id="kobo.76.1"> 
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.77.1">uint32_t</span></span><span class="koboSpan" id="kobo.78.1"> APB2ENR;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.79.1">/* Address offset: 0x18 */</span></span><span class="koboSpan" id="kobo.80.1"> 
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.81.1">uint32_t</span></span><span class="koboSpan" id="kobo.82.1"> APB1ENR;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.83.1">/* Address offset: 0x1C */</span></span><span class="koboSpan" id="kobo.84.1">  
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.85.1">uint32_t</span></span><span class="koboSpan" id="kobo.86.1"> BDCR;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.87.1">/* Address offset: 0x20 */</span></span><span class="koboSpan" id="kobo.88.1">  
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.89.1">uint32_t</span></span><span class="koboSpan" id="kobo.90.1"> CSR;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.91.1">/* Address offset: 0x24 */</span></span><span class="koboSpan" id="kobo.92.1">   
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.93.1">uint32_t</span></span><span class="koboSpan" id="kobo.94.1"> AHBRSTR;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.95.1">/* Address offset: 0x28 */</span></span><span class="koboSpan" id="kobo.96.1">  
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.97.1">uint32_t</span></span><span class="koboSpan" id="kobo.98.1"> CFGR2;     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.99.1">/* Address offset: 0x2C */</span></span><span class="koboSpan" id="kobo.100.1">
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.101.1">uint32_t</span></span><span class="koboSpan" id="kobo.102.1"> CFGR3;     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.103.1">/* Address offset: 0x30 */</span></span><span class="koboSpan" id="kobo.104.1">
  __IO </span><span class="hljs-type"><span class="koboSpan" id="kobo.105.1">uint32_t</span></span><span class="koboSpan" id="kobo.106.1"> CR2;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.107.1">/* Address offset: 0x34 */</span></span><span class="koboSpan" id="kobo.108.1">
} RCC_TypeDef;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.109.1">In the </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.110.1">same header </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.111.1">file, along with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.112.1">RCC_TypeDef</span></code><span class="koboSpan" id="kobo.113.1"> struct, the following macros are defined:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.114.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.115.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.116.1"> PERIPH_BASE           0x40000000UL</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.117.1">/*!&lt; Peripheral memory map */</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.118.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.119.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.120.1"> APBPERIPH_BASE        PERIPH_BASE</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.121.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.122.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.123.1"> AHBPERIPH_BASE       (PERIPH_BASE + 0x00020000UL)</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.124.1">/*!&lt; AHB peripherals */</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.125.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.126.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.127.1"> RCC_BASE            (AHBPERIPH_BASE + 0x00001000UL)</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.128.1">/*!&lt; Peripheral_declaration */</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.129.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.130.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.131.1"> RCC                 ((RCC_TypeDef *) RCC_BASE)</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.132.1">This code is part of the CMSIS header </span><code class="inlineCode"><span class="koboSpan" id="kobo.133.1">stm32f072xb.h</span></code><span class="koboSpan" id="kobo.134.1">, and it’s all we need to configure the RCC register. </span><span class="koboSpan" id="kobo.134.2">We are setting up clock configuration in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.135.1">SystemInit</span></code><span class="koboSpan" id="kobo.136.1"> function, which is called before the </span><code class="inlineCode"><span class="koboSpan" id="kobo.137.1">main</span></code><span class="koboSpan" id="kobo.138.1"> function (as you were able to see in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.139.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.140.1">). </span><span class="koboSpan" id="kobo.140.2">The following code snippet is from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.141.1">SystemInit</span></code><span class="koboSpan" id="kobo.142.1"> function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.143.1">/* Set HSION bit */</span></span><span class="koboSpan" id="kobo.144.1">
RCC-&gt;CR |= (</span><span class="hljs-type"><span class="koboSpan" id="kobo.145.1">uint32_t</span></span><span class="koboSpan" id="kobo.146.1">)</span><span class="hljs-number"><span class="koboSpan" id="kobo.147.1">0x00000001</span></span><span class="koboSpan" id="kobo.148.1">U;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.149.1">In this code, we are setting up the HSION bit of the clock control register (</span><code class="inlineCode"><span class="koboSpan" id="kobo.150.1">CR</span></code><span class="koboSpan" id="kobo.151.1">) or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.152.1">RCC</span></code><span class="koboSpan" id="kobo.153.1"> peripheral, and we know we are doing that because of the comment in the code. </span><span class="koboSpan" id="kobo.153.2">Also, nothing is preventing us from setting </span><code class="inlineCode"><span class="koboSpan" id="kobo.154.1">CR</span></code><span class="koboSpan" id="kobo.155.1"> to any random value. </span><span class="koboSpan" id="kobo.155.2">Here is an example of usage of the clock configuration register (</span><code class="inlineCode"><span class="koboSpan" id="kobo.156.1">CFGR</span></code><span class="koboSpan" id="kobo.157.1">) from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.158.1">RCC</span></code><span class="koboSpan" id="kobo.159.1"> peripheral:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.160.1">/* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */</span></span><span class="koboSpan" id="kobo.161.1">
RCC-&gt;CFGR &amp;= (</span><span class="hljs-type"><span class="koboSpan" id="kobo.162.1">uint32_t</span></span><span class="koboSpan" id="kobo.163.1">)</span><span class="hljs-number"><span class="koboSpan" id="kobo.164.1">0x08FFB80C</span></span><span class="koboSpan" id="kobo.165.1">U;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.166.1">This code sets PLL division, various prescaler, and clock settings. </span><span class="koboSpan" id="kobo.166.2">It’s not quite obvious which settings are applied from the hex value </span><code class="inlineCode"><span class="koboSpan" id="kobo.167.1">0x08FFB80CU</span></code><span class="koboSpan" id="kobo.168.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.169.1">Even though </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.170.1">this approach </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.171.1">is common, there are several issues with modeling access to peripherals using register structs and a pointer pointing to the peripheral’s base address:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.172.1">The first is reduced readability. </span><span class="koboSpan" id="kobo.172.2">We can write </span><code class="inlineCode"><span class="koboSpan" id="kobo.173.1">arbitrary uint32_t</span></code><span class="koboSpan" id="kobo.174.1"> values in hex format, making the code meaningless and requiring us to refer to reference manuals of microcontrollers.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.175.1">As we can write any value we want to a register, we can easily write wrong or even random values.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.176.1">Individual registers of a peripheral in a struct must be ordered according to their memory layout. </span><span class="koboSpan" id="kobo.176.2">Members named </span><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">RESERVERDn</span></code><span class="koboSpan" id="kobo.178.1"> are used to add space into the structure for adjusting the addresses of the peripheral registers and to prevent padding.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.179.1">CMSIS headers may contain macros defining bit masks for accessing individual settings in a register, which simplifies access to peripheral registers. </span><span class="koboSpan" id="kobo.179.2">Still, these macros are not making the code any safer, just easier to work with.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.180.1">Let’s see how we can utilize C++ to address these concerns, making the code safer and more readable.</span></p>
<h2 class="heading-2" id="_idParaDest-174"><span class="koboSpan" id="kobo.181.1">Memory-mapped peripherals in C++</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.182.1">We will </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.183.1">use the knowledge we gained in previous chapters to </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.184.1">create an expressive and type-safe interface to access memory-mapped peripherals in C++. </span><span class="koboSpan" id="kobo.184.2">We will create an interface with the following qualities:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.185.1">Read and write access control to a hardware register</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.186.1">Type-safe write to a register</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.187.1">Expressive and easy to use</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.188.1">Let us start with a basic implementation of an interface representing a memory-mapped register that will match the CMSIS approach in functionality. </span><span class="koboSpan" id="kobo.188.2">The code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.189.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.190.1">read_access</span></span><span class="koboSpan" id="kobo.191.1">{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.192.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.193.1">write_access</span></span><span class="koboSpan" id="kobo.194.1">{};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.195.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.196.1">read_write_access</span></span><span class="koboSpan" id="kobo.197.1"> : read_access, write_access {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.198.1">template</span></span><span class="koboSpan" id="kobo.199.1">&lt;std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.200.1">uintptr_t</span></span><span class="koboSpan" id="kobo.201.1"> Address, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.202.1">typename</span></span><span class="koboSpan" id="kobo.203.1"> Access = read_write_access, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.204.1">typename</span></span><span class="koboSpan" id="kobo.205.1"> T = std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.206.1">uint32_t</span></span><span class="koboSpan" id="kobo.207.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.208.1">struct</span></span><span class="koboSpan" id="kobo.209.1"> reg {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.210.1">template</span></span><span class="koboSpan" id="kobo.211.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.212.1">typename</span></span><span class="koboSpan" id="kobo.213.1"> Access_ = Access&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.214.1">static</span></span><span class="koboSpan" id="kobo.215.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.216.1">enable_if_t</span></span><span class="koboSpan" id="kobo.217.1">&lt;std::is_base_of_v&lt;read_access, Access_&gt;, T&gt; 
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.218.1">read</span></span><span class="koboSpan" id="kobo.219.1">()
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.220.1">return</span></span><span class="koboSpan" id="kobo.221.1"> *</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.222.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.223.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.224.1">volatile</span></span><span class="koboSpan" id="kobo.225.1"> T*&gt;(Address);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.226.1">template</span></span><span class="koboSpan" id="kobo.227.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.228.1">typename</span></span><span class="koboSpan" id="kobo.229.1"> Access_ = Access&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.230.1">static</span></span><span class="koboSpan" id="kobo.231.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.232.1">enable_if_t</span></span><span class="koboSpan" id="kobo.233.1">&lt;std::is_base_of_v&lt;write_access, Access_&gt;, </span><span class="hljs-type"><span class="koboSpan" id="kobo.234.1">void</span></span><span class="koboSpan" id="kobo.235.1">&gt;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.236.1">write</span></span><span class="koboSpan" id="kobo.237.1">(T val)
{
    *</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.238.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.239.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.240.1">volatile</span></span><span class="koboSpan" id="kobo.241.1"> T*&gt;(Address) = val;
}
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.242.1">In this </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.243.1">code, the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">reg</span></code><span class="koboSpan" id="kobo.245.1"> models a hardware </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.246.1">register. </span><span class="koboSpan" id="kobo.246.2">It has the following template parameters:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">uintptr_t Address</span></code><span class="koboSpan" id="kobo.248.1">: The memory address of the hardware register</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">typename Access</span></code><span class="koboSpan" id="kobo.250.1">: The access rights for the register (defaults to </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">read_write_access</span></code><span class="koboSpan" id="kobo.252.1">)</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.253.1">typename T</span></code><span class="koboSpan" id="kobo.254.1">: The data type matching the size of the register (defaults to </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">std::uint32_t</span></code><span class="koboSpan" id="kobo.256.1">)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.257.1">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">reg</span></code><span class="koboSpan" id="kobo.259.1"> has two static methods: </span><code class="inlineCode"><span class="koboSpan" id="kobo.260.1">read</span></code><span class="koboSpan" id="kobo.261.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">write</span></code><span class="koboSpan" id="kobo.263.1">. </span><span class="koboSpan" id="kobo.263.2">These are used to read from and write to a register, respectively. </span><span class="koboSpan" id="kobo.263.3">Both methods are enabled or disabled at compile time using SFINAE, which we covered in </span><a href="Chapter_08.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.264.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.265.1">. </span><span class="koboSpan" id="kobo.265.2">We are using the following types of access control:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.266.1">struct read_access</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">struct write_access</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.268.1">struct read_write_access</span></code><span class="koboSpan" id="kobo.269.1">: This inherits from both </span><code class="inlineCode"><span class="koboSpan" id="kobo.270.1">read_access</span></code><span class="koboSpan" id="kobo.271.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.272.1">write_access</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.273.1">To enable and disable </span><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">write</span></code><span class="koboSpan" id="kobo.275.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.276.1">read</span></code><span class="koboSpan" id="kobo.277.1"> methods at compile time using SFINAE, we made both methods template functions. </span><span class="koboSpan" id="kobo.277.2">This allows us to use the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.278.1">enable_if</span></code><span class="koboSpan" id="kobo.279.1"> at the return type of these methods to either enable or disable them, depending on the condition provided to it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.280.1">The template parameter for both </span><code class="inlineCode"><span class="koboSpan" id="kobo.281.1">write</span></code><span class="koboSpan" id="kobo.282.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">read</span></code><span class="koboSpan" id="kobo.284.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">Access_</span></code><span class="koboSpan" id="kobo.286.1">, which defaults to </span><code class="inlineCode"><span class="koboSpan" id="kobo.287.1">Access</span></code><span class="koboSpan" id="kobo.288.1">. </span><span class="koboSpan" id="kobo.288.2">It ensures that SFINAE works correctly by making the substitution dependent on a template parameter of the function itself.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.289.1">We are enabling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">read</span></code><span class="koboSpan" id="kobo.291.1"> method using </span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">std::enable_if_t&lt;std::is_base_of_v&lt;read_access, Access_&gt;, T&gt;</span></code><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">This means that if </span><code class="inlineCode"><span class="koboSpan" id="kobo.294.1">std::is_base_of_v&lt;read_access, Access_&gt;</span></code><span class="koboSpan" id="kobo.295.1"> is true (i.e., if </span><code class="inlineCode"><span class="koboSpan" id="kobo.296.1">Access_</span></code><span class="koboSpan" id="kobo.297.1"> is derived from or is the same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">read_access</span></code><span class="koboSpan" id="kobo.299.1">), </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">std::enable_if_t</span></code><span class="koboSpan" id="kobo.301.1"> resolves to </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">T</span></code><span class="koboSpan" id="kobo.303.1">, and the function is enabled. </span><span class="koboSpan" id="kobo.303.2">Otherwise, it results in a substitution failure, and the function is not included in the overload set. </span><span class="koboSpan" id="kobo.303.3">We are </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.304.1">enabling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.305.1">write</span></code><span class="koboSpan" id="kobo.306.1"> method in a similar fashion, by checking whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">Access_</span></code><span class="koboSpan" id="kobo.308.1"> type is derived from or the same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.309.1">write_access</span></code><span class="koboSpan" id="kobo.310.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.311.1">We use </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">reinterpret_cast&lt;volatile T*&gt;</span></code><span class="koboSpan" id="kobo.313.1"> to convert the integer template parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">Address</span></code><span class="koboSpan" id="kobo.315.1"> into a </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.316.1">pointer to a volatile variable of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">T</span></code><span class="koboSpan" id="kobo.318.1"> (which defaults to </span><code class="inlineCode"><span class="koboSpan" id="kobo.319.1">std::uint32_t</span></code><span class="koboSpan" id="kobo.320.1">). </span><span class="koboSpan" id="kobo.320.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.321.1">volatile</span></code><span class="koboSpan" id="kobo.322.1"> keyword informs the compiler that the value at this memory location can change at any time outside the program’s control – by hardware. </span><span class="koboSpan" id="kobo.322.2">This prevents the compiler from applying certain optimizations that might omit necessary reads or writes to this address.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.323.1">Without </span><code class="inlineCode"><span class="koboSpan" id="kobo.324.1">volatile</span></code><span class="koboSpan" id="kobo.325.1">, the compiler might assume that multiple reads from the same address yield the same value or that writes to the address can be reordered or even omitted, which can lead to incorrect behavior when interacting with hardware.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.326.1">As we discussed in </span><a href="Chapter_09.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.327.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.328.1">, casting an integer to a pointer using </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.330.1"> is considered an implementation-defined behavior in C++. </span><span class="koboSpan" id="kobo.330.2">This means the C++ standard doesn’t specify exactly how it should work, and different compilers or platforms might handle it differently. </span><span class="koboSpan" id="kobo.330.3">Writing directly to a specific memory location is inherently unsafe and relies on behavior that isn’t guaranteed to be portable across all systems. </span><span class="koboSpan" id="kobo.330.4">Therefore, we need to be cautious about the portability of this solution, as some platforms may implement pointer conversions differently.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.331.1">Here are a few examples of using the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">reg</span></code><span class="koboSpan" id="kobo.333.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.334.1">using</span></span><span class="koboSpan" id="kobo.335.1"> rcc = reg&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.336.1">0x40021000</span></span><span class="koboSpan" id="kobo.337.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.338.1">auto</span></span><span class="koboSpan" id="kobo.339.1"> val = rcc::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.340.1">read</span></span><span class="koboSpan" id="kobo.341.1">(); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.342.1">// ok</span></span><span class="koboSpan" id="kobo.343.1">
rcc::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.344.1">write</span></span><span class="koboSpan" id="kobo.345.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.346.1">0xDEADBEEF</span></span><span class="koboSpan" id="kobo.347.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.348.1">// ok</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.349.1">using</span></span><span class="koboSpan" id="kobo.350.1"> rcc_read = reg&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.351.1">0x40021000</span></span><span class="koboSpan" id="kobo.352.1">, read_access&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.353.1">auto</span></span><span class="koboSpan" id="kobo.354.1"> val = rcc_read::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.355.1">read</span></span><span class="koboSpan" id="kobo.356.1">(); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.357.1">// ok</span></span><span class="koboSpan" id="kobo.358.1">
rcc_read::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.359.1">write</span></span><span class="koboSpan" id="kobo.360.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.361.1">0xDEADBEEF</span></span><span class="koboSpan" id="kobo.362.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.363.1">// compiler-error, no write access</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.364.1">using</span></span><span class="koboSpan" id="kobo.365.1"> rcc_write = reg&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.366.1">0x40021000</span></span><span class="koboSpan" id="kobo.367.1">, write_access&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.368.1">auto</span></span><span class="koboSpan" id="kobo.369.1"> val = rcc_write::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.370.1">read</span></span><span class="koboSpan" id="kobo.371.1">(); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.372.1">// compiler-error, no read access</span></span><span class="koboSpan" id="kobo.373.1">
rcc_write::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.374.1">write</span></span><span class="koboSpan" id="kobo.375.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.376.1">0xDEADBEEF</span></span><span class="koboSpan" id="kobo.377.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.378.1">// ok</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.379.1">These examples demonstrate the usage of the implemented interface for accessing memory-mapped peripherals. </span><span class="koboSpan" id="kobo.379.2">When defining types using the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">reg</span></code><span class="koboSpan" id="kobo.381.1">, we provide it with the address of a register and </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">write</span></code><span class="koboSpan" id="kobo.383.1"> access if we are working with write-only or read-only registers. </span><span class="koboSpan" id="kobo.383.2">The default access type allows us both read and write privileges.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.384.1">The preceding </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.385.1">solution is as effective as the CMSIS approach. </span><span class="koboSpan" id="kobo.385.2">You can experiment with the full example and compare binary sizes by running the full </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.386.1">example in Renode. </span><span class="koboSpan" id="kobo.386.2">Start Visual Studio Code, attach it to the running container, open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">Chapter12/cpp_hal</span></code><span class="koboSpan" id="kobo.388.1"> project as described in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.389.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.390.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.391.1">$ cmake -B build -DCMAKE_BUILD_TYPE=Release -DMAIN_CPP_FILE_NAME=main_basic_reg.cpp
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.392.1">Our current solution still allows us to write arbitrary values to registers. </span><span class="koboSpan" id="kobo.392.2">To address this, we will use strong types based on </span><code class="inlineCode"><span class="koboSpan" id="kobo.393.1">enum</span></code><span class="koboSpan" id="kobo.394.1"> classes to model bit fields used to set different settings in registers.</span></p>
<h2 class="heading-2" id="_idParaDest-175"><span class="koboSpan" id="kobo.395.1">Type-safe memory-mapped peripherals in C++</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.396.1">To prevent arbitrary writings to a register using the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">reg</span></code><span class="koboSpan" id="kobo.398.1">, we will add a new static </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.399.1">method, </span><code class="inlineCode"><span class="koboSpan" id="kobo.400.1">set</span></code><span class="koboSpan" id="kobo.401.1">, which will accept only types meeting certain criteria. </span><span class="koboSpan" id="kobo.401.2">We will model these types by </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.402.1">creating a </span><code class="inlineCode"><span class="koboSpan" id="kobo.403.1">BitFieldConcept</span></code><span class="koboSpan" id="kobo.404.1">. </span><span class="koboSpan" id="kobo.404.2">We covered concepts in </span><a href="Chapter_08.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.405.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.406.1">. </span><span class="koboSpan" id="kobo.406.2">Also, we will remove public access to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.407.1">write</span></code><span class="koboSpan" id="kobo.408.1"> method and put it instead in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.409.1">private</span></code><span class="koboSpan" id="kobo.410.1"> section. </span><span class="koboSpan" id="kobo.410.2">The modified code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.411.1">template</span></span><span class="koboSpan" id="kobo.412.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.413.1">typename</span></span><span class="koboSpan" id="kobo.414.1"> BitField, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.415.1">typename</span></span><span class="koboSpan" id="kobo.416.1"> Reg, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.417.1">typename</span></span><span class="koboSpan" id="kobo.418.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.419.1">concept</span></span><span class="koboSpan" id="kobo.420.1"> BitFieldConcept =
    std::is_same_v&lt;Reg, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.421.1">typename</span></span><span class="koboSpan" id="kobo.422.1"> BitField::reg&gt; &amp;&amp;
    std::is_enum_v&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.423.1">typename</span></span><span class="koboSpan" id="kobo.424.1"> BitField::value&gt; &amp;&amp;
    std::is_same_v&lt;std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.425.1">underlying_type_t</span></span><span class="koboSpan" id="kobo.426.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.427.1">typename</span></span><span class="koboSpan" id="kobo.428.1">
BitField::value&gt;, T&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.429.1">template</span></span><span class="koboSpan" id="kobo.430.1">&lt;std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.431.1">uintptr_t</span></span><span class="koboSpan" id="kobo.432.1"> Address, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.433.1">typename</span></span><span class="koboSpan" id="kobo.434.1"> Access = read_write_access, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.435.1">typename</span></span><span class="koboSpan" id="kobo.436.1"> T = std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.437.1">uint32_t</span></span><span class="koboSpan" id="kobo.438.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.439.1">struct</span></span><span class="koboSpan" id="kobo.440.1"> reg {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.441.1">using</span></span><span class="koboSpan" id="kobo.442.1"> RegType = T;
     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.443.1">// Type alias for the current instantiation</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.444.1">using</span></span><span class="koboSpan" id="kobo.445.1"> ThisReg = reg&lt;Address, Access, T&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.446.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.447.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.448.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.449.1"> BitField&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.450.1">requires</span></span><span class="hljs-function"> </span><code class="inlineCode"><span class="koboSpan" id="kobo.451.1">BitFieldConcept</span></code><span class="hljs-function"><span class="koboSpan" id="kobo.452.1">&lt;BitField, ThisReg, T&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.453.1">static</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.454.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.455.1">set</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.456.1">(BitField::value bits_val)</span></span><span class="koboSpan" id="kobo.457.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.458.1">auto</span></span><span class="koboSpan" id="kobo.459.1"> reg_value = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.460.1">read</span></span><span class="koboSpan" id="kobo.461.1">();
    reg_value &amp;= ~BitField::c_mask;
    reg_value |= (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.462.1">static_cast</span></span><span class="koboSpan" id="kobo.463.1">&lt;T&gt;(bits_val) &lt;&lt;
          BitField::c_position) &amp; BitField::c_mask;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.464.1">write</span></span><span class="koboSpan" id="kobo.465.1">(reg_value);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.466.1">template</span></span><span class="koboSpan" id="kobo.467.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.468.1">typename</span></span><span class="koboSpan" id="kobo.469.1"> Access_ = Access&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.470.1">static</span></span><span class="koboSpan" id="kobo.471.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.472.1">enable_if_t</span></span><span class="koboSpan" id="kobo.473.1">&lt;std::is_base_of_v&lt;read_access, Access_&gt;, T&gt; 
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.474.1">read</span></span><span class="koboSpan" id="kobo.475.1">()
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.476.1">return</span></span><span class="koboSpan" id="kobo.477.1"> *</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.478.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.479.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.480.1">volatile</span></span><span class="koboSpan" id="kobo.481.1"> T*&gt;(Address);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.482.1">private</span></span><span class="koboSpan" id="kobo.483.1">:
   
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.484.1">template</span></span><span class="koboSpan" id="kobo.485.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.486.1">typename</span></span><span class="koboSpan" id="kobo.487.1"> Access_ = Access&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.488.1">static</span></span><span class="koboSpan" id="kobo.489.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.490.1">enable_if_t</span></span><span class="koboSpan" id="kobo.491.1">&lt;std::is_base_of_v&lt;write_access, Access_&gt;, </span><span class="hljs-type"><span class="koboSpan" id="kobo.492.1">void</span></span><span class="koboSpan" id="kobo.493.1">&gt; 
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.494.1">write</span></span><span class="koboSpan" id="kobo.495.1">(T val)
{
    *</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.496.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.497.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.498.1">volatile</span></span><span class="koboSpan" id="kobo.499.1"> T*&gt;(Address) = val;
}
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.500.1">The </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.501.1">template method </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">set</span></code><span class="koboSpan" id="kobo.503.1"> has a single template </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.504.1">parameter – type </span><code class="inlineCode"><span class="koboSpan" id="kobo.505.1">BitField</span></code><span class="koboSpan" id="kobo.506.1">. </span><span class="koboSpan" id="kobo.506.2">We use </span><code class="inlineCode"><span class="koboSpan" id="kobo.507.1">BitFieldConcept</span></code><span class="koboSpan" id="kobo.508.1"> to impose the following requirements on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.509.1">BitField</span></code><span class="koboSpan" id="kobo.510.1">:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.511.1">Reg</span></code><span class="koboSpan" id="kobo.512.1"> must be the same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">BitField::reg</span></code><span class="koboSpan" id="kobo.514.1">. </span><span class="koboSpan" id="kobo.514.2">This ensures the bit field is associated with the correct register.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.515.1">BitField::value</span></code><span class="koboSpan" id="kobo.516.1"> must be an </span><code class="inlineCode"><span class="koboSpan" id="kobo.517.1">enum</span></code><span class="koboSpan" id="kobo.518.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.519.1">The underlying type of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.520.1">BitField::value</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.521.1">enum</span></code><span class="koboSpan" id="kobo.522.1"> must be </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">T</span></code><span class="koboSpan" id="kobo.524.1">. </span><span class="koboSpan" id="kobo.524.2">This ensures that values represented by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">enum</span></code><span class="koboSpan" id="kobo.526.1"> can fit in the registers.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.527.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.528.1">set</span></code><span class="koboSpan" id="kobo.529.1"> function </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.530.1">parameter is </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">BitField::value bits_val</span></code><span class="koboSpan" id="kobo.532.1">. </span><span class="koboSpan" id="kobo.532.2">The </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.533.1">function itself is simple, and it performs </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.534.1">the following operations:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.535.1">Reads the current register value</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.536.1">Clears the bits specified by </span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">BitField::c_mask</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.538.1">Sets the new bits by shifting </span><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">bits_val</span></code><span class="koboSpan" id="kobo.540.1"> to the correct position (</span><code class="inlineCode"><span class="koboSpan" id="kobo.541.1">BitField::c_position</span></code><span class="koboSpan" id="kobo.542.1">) and applying the mask</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.543.1">Writes the modified value back to the register</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.544.1">To use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.545.1">set</span></code><span class="koboSpan" id="kobo.546.1"> function, we need to define types that describe the register’s bit fields and that meet the requirements imposed by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.547.1">BitFieldConcept</span></code><span class="koboSpan" id="kobo.548.1">.</span></p>
<h3 class="heading-3" id="_idParaDest-176"><span class="koboSpan" id="kobo.549.1">Modeling HSION and HSITRIM bit fields from the RCC register</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.550.1">Let us </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.551.1">examine </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.552.1">bit fields in the RCC CR register defined in the STM32F0x2 reference manual document, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.553.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.554.1">.1</span></em><span class="koboSpan" id="kobo.555.1">:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.556.1"><img alt="Figure 12.1 – RCC CR register" src="../Images/B22402_12_01.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.557.1">Figure 12</span></span><span class="koboSpan" id="kobo.558.1">.1 – RCC CR register</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.559.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.560.1">.1</span></em><span class="koboSpan" id="kobo.561.1"> depicts bit fields in the RCC CR register. </span><span class="koboSpan" id="kobo.561.2">Let us define a struct </span><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">hsion</span></code><span class="koboSpan" id="kobo.563.1"> that describes the HSI clock </span><code class="inlineCode"><span class="koboSpan" id="kobo.564.1">enable</span></code><span class="koboSpan" id="kobo.565.1"> bit field from the RCC CR register. </span><span class="koboSpan" id="kobo.565.2">It has only one bit on position </span><code class="inlineCode"><span class="koboSpan" id="kobo.566.1">0</span></code><span class="koboSpan" id="kobo.567.1">, so we can model it as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.568.1">using</span></span><span class="koboSpan" id="kobo.569.1"> rcc = reg&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.570.1">0x40021000</span></span><span class="koboSpan" id="kobo.571.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.572.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.573.1">hsion</span></span><span class="koboSpan" id="kobo.574.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.575.1">using</span></span><span class="koboSpan" id="kobo.576.1"> reg = rcc;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.577.1">using</span></span><span class="koboSpan" id="kobo.578.1"> T = reg::RegType;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.579.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.580.1">constexpr</span></span><span class="koboSpan" id="kobo.581.1"> T c_position = </span><span class="hljs-number"><span class="koboSpan" id="kobo.582.1">0U</span></span><span class="koboSpan" id="kobo.583.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.584.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.585.1">constexpr</span></span><span class="koboSpan" id="kobo.586.1"> T c_mask = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.587.1">1U</span></span><span class="koboSpan" id="kobo.588.1"> &lt;&lt; c_position);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.589.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.590.1">value</span></span><span class="koboSpan" id="kobo.591.1"> : T {
        disable = </span><span class="hljs-number"><span class="koboSpan" id="kobo.592.1">0U</span></span><span class="koboSpan" id="kobo.593.1">,
        enable  = </span><span class="hljs-number"><span class="koboSpan" id="kobo.594.1">1U</span></span><span class="koboSpan" id="kobo.595.1">,
    };
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.596.1">In this </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.597.1">code, we declare type </span><code class="inlineCode"><span class="koboSpan" id="kobo.598.1">rcc</span></code><span class="koboSpan" id="kobo.599.1"> as an instance of the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.600.1">reg</span></code><span class="koboSpan" id="kobo.601.1"> by providing it with </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.602.1">the address of the RCC register. </span><span class="koboSpan" id="kobo.602.2">Then, we create a struct </span><code class="inlineCode"><span class="koboSpan" id="kobo.603.1">hsion</span></code><span class="koboSpan" id="kobo.604.1"> with the following properties:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.605.1">A public </span><code class="inlineCode"><span class="koboSpan" id="kobo.606.1">typedef</span></code><span class="koboSpan" id="kobo.607.1"> member </span><code class="inlineCode"><span class="koboSpan" id="kobo.608.1">reg</span></code><span class="koboSpan" id="kobo.609.1">, which we set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.610.1">rcc</span></code><span class="koboSpan" id="kobo.611.1">. </span><span class="koboSpan" id="kobo.611.2">This “maps” </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">hsion</span></code><span class="koboSpan" id="kobo.613.1"> to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">rcc</span></code><span class="koboSpan" id="kobo.615.1"> register thanks to </span><code class="inlineCode"><span class="koboSpan" id="kobo.616.1">BitFieldConcept</span></code><span class="koboSpan" id="kobo.617.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.618.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.619.1">constexpr</span></code><span class="koboSpan" id="kobo.620.1"> variables </span><code class="inlineCode"><span class="koboSpan" id="kobo.621.1">c_position</span></code><span class="koboSpan" id="kobo.622.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.623.1">c_mask</span></code><span class="koboSpan" id="kobo.624.1">, used for bit manipulation by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.625.1">set</span></code><span class="koboSpan" id="kobo.626.1"> method.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.627.1">An </span><code class="inlineCode"><span class="koboSpan" id="kobo.628.1">enum</span></code><span class="koboSpan" id="kobo.629.1"> class </span><code class="inlineCode"><span class="koboSpan" id="kobo.630.1">value</span></code><span class="koboSpan" id="kobo.631.1">, defining </span><code class="inlineCode"><span class="koboSpan" id="kobo.632.1">enable</span></code><span class="koboSpan" id="kobo.633.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.634.1">disable</span></code><span class="koboSpan" id="kobo.635.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.636.1">We can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.637.1">hsion</span></code><span class="koboSpan" id="kobo.638.1"> struct to enable or disable the HSI clock using the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.639.1">rcc::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.640.1">set</span></span><span class="koboSpan" id="kobo.641.1">&lt;hsion&gt;(hsion::value::enable);
rcc::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.642.1">set</span></span><span class="koboSpan" id="kobo.643.1">&lt;hsion&gt;(hsion::value::disable);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.644.1">This code allows us to safely set bits in a register. </span><span class="koboSpan" id="kobo.644.2">It is also expressive: the syntax </span><code class="inlineCode"><span class="koboSpan" id="kobo.645.1">rcc::set&lt;hsion&gt;(hsion::value::enable);</span></code><span class="koboSpan" id="kobo.646.1"> clearly communicates the intent – setting the </span><code class="inlineCode"><span class="koboSpan" id="kobo.647.1">hsion</span></code><span class="koboSpan" id="kobo.648.1"> bit field to </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">enable</span></code><span class="koboSpan" id="kobo.650.1"> on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.651.1">rcc</span></code><span class="koboSpan" id="kobo.652.1"> register.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.653.1">As we can see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.654.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.655.1">.1</span></em><span class="koboSpan" id="kobo.656.1">, most of the defined bit fields in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.657.1">CR</span></code><span class="koboSpan" id="kobo.658.1"> register are </span><code class="inlineCode"><span class="koboSpan" id="kobo.659.1">enable</span></code><span class="koboSpan" id="kobo.660.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.661.1">disable</span></code><span class="koboSpan" id="kobo.662.1"> bits. </span><span class="koboSpan" id="kobo.662.2">Exceptions are:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.663.1">HSICAL[7:0]: HSI clock calibration</span></code><span class="koboSpan" id="kobo.664.1">: These bits are automatically initialized at startup and can be adjusted by software via the </span><code class="inlineCode"><span class="koboSpan" id="kobo.665.1">HSITRIM</span></code><span class="koboSpan" id="kobo.666.1"> setting.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.667.1">HSITRIM[4:0]: HSI clock trimming</span></code><span class="koboSpan" id="kobo.668.1">: These bits offer an additional user-programmable trimming value added to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.669.1">HSICAL[7:0]</span></code><span class="koboSpan" id="kobo.670.1"> bits. </span><span class="koboSpan" id="kobo.670.2">This setting allows adjustments for voltage and temperature variations that may affect the HSI frequency.</span></li>
</ul>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.671.1">HSICAL</span></code><span class="koboSpan" id="kobo.672.1"> bits are initialized at startup, meaning we shouldn’t modify them. </span><code class="inlineCode"><span class="koboSpan" id="kobo.673.1">HSITRIM</span></code><span class="koboSpan" id="kobo.674.1"> bits are user-programmable, and they occupy 5 bits. </span><span class="koboSpan" id="kobo.674.2">Defining all combinations of 5 bits in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.675.1">BitField</span></code><span class="koboSpan" id="kobo.676.1"> value </span><code class="inlineCode"><span class="koboSpan" id="kobo.677.1">enum</span></code><span class="koboSpan" id="kobo.678.1"> wouldn’t be practical, so we will approach this by providing value through a template parameter, as shown in the code here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.679.1">template</span></span><span class="koboSpan" id="kobo.680.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.681.1">auto</span></span><span class="koboSpan" id="kobo.682.1"> Bits&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.683.1">struct</span></span> <code class="inlineCode"><span class="koboSpan" id="kobo.684.1">hsi_trim</span></code><span class="koboSpan" id="kobo.685.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.686.1">using</span></span><span class="koboSpan" id="kobo.687.1"> reg = rcc;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.688.1">using</span></span><span class="koboSpan" id="kobo.689.1"> T = reg::RegType;
    </span><code class="inlineCode"><span class="koboSpan" id="kobo.690.1">static_assert</span></code><span class="koboSpan" id="kobo.691.1">(std::is_same_v&lt;T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.692.1">decltype</span></span><span class="koboSpan" id="kobo.693.1">(Bits)&gt;);
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.694.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.695.1">constexpr</span></span><span class="koboSpan" id="kobo.696.1"> T c_position = </span><span class="hljs-number"><span class="koboSpan" id="kobo.697.1">3</span></span><span class="koboSpan" id="kobo.698.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.699.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.700.1">constexpr</span></span><span class="koboSpan" id="kobo.701.1"> T c_mask = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.702.1">0x1F</span></span><span class="koboSpan" id="kobo.703.1"> &lt;&lt; c_position);
    </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">static_assert</span></code><span class="koboSpan" id="kobo.705.1">(Bits &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.706.1">0x1F</span></span><span class="koboSpan" id="kobo.707.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.708.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.709.1">value</span></span><span class="koboSpan" id="kobo.710.1"> : T {
        val = Bits
    };
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.711.1">In this code, we </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.712.1">defined the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">hsitrim</span></code><span class="koboSpan" id="kobo.714.1"> with the auto template parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.715.1">Bits</span></code><span class="koboSpan" id="kobo.716.1">. </span><span class="koboSpan" id="kobo.716.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">auto</span></code><span class="koboSpan" id="kobo.718.1"> keyword is used to indicate that we are using a non-type template parameter. </span><span class="koboSpan" id="kobo.718.2">We </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.719.1">use </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">static_assert</span></code><span class="koboSpan" id="kobo.721.1"> to make sure that the type of provided parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">Bits</span></code><span class="koboSpan" id="kobo.723.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.724.1">decltype(Bits)</span></code><span class="koboSpan" id="kobo.725.1">) is the same as the underlying registers type to satisfy requirements imposed by </span><code class="inlineCode"><span class="koboSpan" id="kobo.726.1">BitFieldConcept</span></code><span class="koboSpan" id="kobo.727.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.728.1">We encode the </span><code class="inlineCode"><span class="koboSpan" id="kobo.729.1">enum</span></code><span class="koboSpan" id="kobo.730.1"> class value val with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.731.1">Bits</span></code><span class="koboSpan" id="kobo.732.1">. </span><span class="koboSpan" id="kobo.732.2">This encodes the value in the type itself and makes it possible to use it with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.733.1">reg</span></code><span class="koboSpan" id="kobo.734.1"> struct </span><code class="inlineCode"><span class="koboSpan" id="kobo.735.1">set</span></code><span class="koboSpan" id="kobo.736.1"> method. </span><span class="koboSpan" id="kobo.736.2">We also utilize </span><code class="inlineCode"><span class="koboSpan" id="kobo.737.1">static_assert</span></code><span class="koboSpan" id="kobo.738.1"> to make sure that the provided value fits in the allocated number of bits – </span><code class="inlineCode"><span class="koboSpan" id="kobo.739.1">static_assert(Bits &lt;= 0x1F)</span></code><span class="koboSpan" id="kobo.740.1">. </span><span class="koboSpan" id="kobo.740.2">Again, we are utilizing compile-time operations to ensure type safety. </span><span class="koboSpan" id="kobo.740.3">Here is an example of using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.741.1">hsitrim</span></code><span class="koboSpan" id="kobo.742.1"> struct:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.743.1">rcc::set&lt;hsi_trim&lt;0xFLU&gt;&gt;(hsi_trim&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.744.1">0xFLU</span></span><span class="koboSpan" id="kobo.745.1">&gt;::value::val);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.746.1">This code sets the </span><code class="inlineCode"><span class="koboSpan" id="kobo.747.1">hstrim</span></code><span class="koboSpan" id="kobo.748.1"> value in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.749.1">rcc</span></code><span class="koboSpan" id="kobo.750.1"> register to </span><code class="inlineCode"><span class="koboSpan" id="kobo.751.1">0xF</span></code><span class="koboSpan" id="kobo.752.1">. </span><span class="koboSpan" id="kobo.752.2">You can experiment with the full example in Renode. </span><span class="koboSpan" id="kobo.752.3">Start Visual Studio Code, attach it to the running container, open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.753.1">Chapter12/cpp_hal</span></code><span class="koboSpan" id="kobo.754.1"> project, as described in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.755.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.756.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.757.1">$ cmake -B build -DCMAKE_BUILD_TYPE=Release -DMAIN_CPP_FILE_NAME=main_type_safe_reg.cpp
$ cmake --build build --target run_in_renode
</span></code></pre>
<h3 class="heading-3" id="_idParaDest-177"><span class="koboSpan" id="kobo.758.1">Generic versions of hsion and hsi_trim</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.759.1">To enable </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.760.1">the reuse </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.761.1">of bit fields that have a single bit (enable/disable) such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.762.1">hsion</span></code><span class="koboSpan" id="kobo.763.1">, we will define the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.764.1">reg_bits_enable_disable</span></code><span class="koboSpan" id="kobo.765.1">, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.766.1">template</span></span><span class="koboSpan" id="kobo.767.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.768.1">typename</span></span><span class="koboSpan" id="kobo.769.1"> Reg, </span><span class="hljs-type"><span class="koboSpan" id="kobo.770.1">uint32_t</span></span><span class="koboSpan" id="kobo.771.1"> Pos&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.772.1">struct</span></span> <code class="inlineCode"><span class="koboSpan" id="kobo.773.1">reg_bits</span></code><span class="hljs-title"><span class="koboSpan" id="kobo.774.1">_enable_disable</span></span><span class="koboSpan" id="kobo.775.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.776.1">using</span></span><span class="koboSpan" id="kobo.777.1"> reg = Reg;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.778.1">using</span></span><span class="koboSpan" id="kobo.779.1"> T = reg::RegType;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.780.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.781.1">constexpr</span></span><span class="koboSpan" id="kobo.782.1"> T c_position = Pos;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.783.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.784.1">constexpr</span></span><span class="koboSpan" id="kobo.785.1"> T c_mask = (</span><span class="hljs-number"><span class="koboSpan" id="kobo.786.1">0x1UL</span></span><span class="koboSpan" id="kobo.787.1"> &lt;&lt; c_position);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.788.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.789.1">value</span></span><span class="koboSpan" id="kobo.790.1"> : T {
        disable = </span><span class="hljs-number"><span class="koboSpan" id="kobo.791.1">0</span></span><span class="koboSpan" id="kobo.792.1">,
        enable = </span><span class="hljs-number"><span class="koboSpan" id="kobo.793.1">1</span></span><span class="koboSpan" id="kobo.794.1">
    };
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.795.1">This defined template type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.796.1">reg_bits_enable_disable</span></code><span class="koboSpan" id="kobo.797.1">, could be used to define the </span><code class="inlineCode"><span class="koboSpan" id="kobo.798.1">hsion</span></code><span class="koboSpan" id="kobo.799.1"> type, as shown in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.800.1">using</span></span><span class="koboSpan" id="kobo.801.1"> hsion = reg_bits_enable_disable&lt;rcc, </span><span class="hljs-number"><span class="koboSpan" id="kobo.802.1">0U</span></span><span class="koboSpan" id="kobo.803.1">&gt;;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.804.1">Next, we will create a generic version of the type used to set multiple fields with a value, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.805.1">hsi_trim</span></code><span class="koboSpan" id="kobo.806.1">. </span><span class="koboSpan" id="kobo.806.2">We will call it </span><code class="inlineCode"><span class="koboSpan" id="kobo.807.1">reg_bits</span></code><span class="koboSpan" id="kobo.808.1">, and the code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.809.1">template</span></span><span class="koboSpan" id="kobo.810.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.811.1">auto</span></span><span class="koboSpan" id="kobo.812.1"> Bits, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.813.1">typename</span></span><span class="koboSpan" id="kobo.814.1"> Reg, </span><span class="hljs-type"><span class="koboSpan" id="kobo.815.1">uint32_t</span></span><span class="koboSpan" id="kobo.816.1"> Mask, </span><span class="hljs-type"><span class="koboSpan" id="kobo.817.1">uint32_t</span></span><span class="koboSpan" id="kobo.818.1"> Pos = </span><span class="hljs-number"><span class="koboSpan" id="kobo.819.1">0</span></span><span class="koboSpan" id="kobo.820.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.821.1">struct</span></span><span class="koboSpan" id="kobo.822.1"> reg_bits {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.823.1">using</span></span><span class="koboSpan" id="kobo.824.1"> reg = Reg; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.825.1">using</span></span><span class="koboSpan" id="kobo.826.1"> T = reg::RegType;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.827.1">static_assert</span></span><span class="koboSpan" id="kobo.828.1">(std::is_same_v&lt;T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.829.1">decltype</span></span><span class="koboSpan" id="kobo.830.1">(Bits)&gt;);
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.831.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.832.1">constexpr</span></span><span class="koboSpan" id="kobo.833.1"> T c_position = Pos;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.834.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.835.1">constexpr</span></span><span class="koboSpan" id="kobo.836.1"> T c_mask = (Mask &lt;&lt; c_position);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.837.1">static_assert</span></span><span class="koboSpan" id="kobo.838.1">(Bits &lt;= Mask);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.839.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.840.1">value</span></span><span class="koboSpan" id="kobo.841.1"> : T {
        val = Bits
    };
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.842.1">We could </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.843.1">use the </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.844.1">generic type </span><code class="inlineCode"><span class="koboSpan" id="kobo.845.1">reg_bits</span></code><span class="koboSpan" id="kobo.846.1"> to define the </span><code class="inlineCode"><span class="koboSpan" id="kobo.847.1">hsi_trim</span></code><span class="koboSpan" id="kobo.848.1"> template type, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.849.1">template</span></span><span class="koboSpan" id="kobo.850.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.851.1">auto</span></span><span class="koboSpan" id="kobo.852.1"> Bits&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.853.1">using</span></span><span class="koboSpan" id="kobo.854.1"> hsi_trim = reg_bits&lt;Bits, rcc, </span><span class="hljs-number"><span class="koboSpan" id="kobo.855.1">0x1F</span></span><span class="koboSpan" id="kobo.856.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.857.1">3U</span></span><span class="koboSpan" id="kobo.858.1">&gt;;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.859.1">Next, we will explore how to use C++ to create templates for peripherals that are similar but also have some implementation differences.</span></p>
<h1 class="heading-1" id="_idParaDest-178"><span class="koboSpan" id="kobo.860.1">Timers</span></h1>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.861.1">STM32F072</span></code><span class="koboSpan" id="kobo.862.1"> has multiple timers, including TIM2 and TIM3. </span><span class="koboSpan" id="kobo.862.2">TIM2 is a 32-bit timer and TIM3 is a 16-bit timer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.863.1">We will </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.864.1">create a template class timer that will depend on timer traits structures containing timer-specific details. </span><span class="koboSpan" id="kobo.864.2">Here is the code for timer traits structures:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.865.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.866.1">timer2_traits</span></span><span class="koboSpan" id="kobo.867.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.868.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.869.1">static</span></span><span class="koboSpan" id="kobo.870.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.871.1">uintptr_t</span></span><span class="koboSpan" id="kobo.872.1"> base_address = </span><span class="hljs-number"><span class="koboSpan" id="kobo.873.1">0x40000000</span></span><span class="koboSpan" id="kobo.874.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.875.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.876.1">static</span></span><span class="koboSpan" id="kobo.877.1"> IRQn_Type irqn = TIM2_IRQn;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.878.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.879.1">static</span></span><span class="koboSpan" id="kobo.880.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.881.1">uint32_t</span></span><span class="koboSpan" id="kobo.882.1"> arr_bit_mask = </span><span class="hljs-number"><span class="koboSpan" id="kobo.883.1">0xFFFFFFFF</span></span><span class="koboSpan" id="kobo.884.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.885.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.886.1">timer3_traits</span></span><span class="koboSpan" id="kobo.887.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.888.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.889.1">static</span></span><span class="koboSpan" id="kobo.890.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.891.1">uintptr_t</span></span><span class="koboSpan" id="kobo.892.1"> base_address = </span><span class="hljs-number"><span class="koboSpan" id="kobo.893.1">0x40000400</span></span><span class="koboSpan" id="kobo.894.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.895.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.896.1">static</span></span><span class="koboSpan" id="kobo.897.1"> IRQn_Type irqn = TIM3_IRQn;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.898.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.899.1">static</span></span><span class="koboSpan" id="kobo.900.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.901.1">uint32_t</span></span><span class="koboSpan" id="kobo.902.1"> arr_bit_mask = </span><span class="hljs-number"><span class="koboSpan" id="kobo.903.1">0xFFFF</span></span><span class="koboSpan" id="kobo.904.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.905.1">In this code, </span><code class="inlineCode"><span class="koboSpan" id="kobo.906.1">timer2_traits</span></code><span class="koboSpan" id="kobo.907.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.908.1">timer3_traits</span></code><span class="koboSpan" id="kobo.909.1"> are traits structures that encapsulate the hardware-specific details of TIM2 and TIM3 timers, respectively. </span><span class="koboSpan" id="kobo.909.2">They have the following members:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.910.1">base_address</span></code><span class="koboSpan" id="kobo.911.1">: The base memory address of the timer’s register map</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.912.1">irqn</span></code><span class="koboSpan" id="kobo.913.1">: The interrupt request number associated with the timer</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.914.1">arr_bit_mask</span></code><span class="koboSpan" id="kobo.915.1">: The bit mask for the auto-reload register (ARR):</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.916.1">For TIM2, it’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.917.1">0xFFFFFFFF</span></code><span class="koboSpan" id="kobo.918.1"> (32-bit timer).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.919.1">For TIM3, it’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.920.1">0xFFFF </span></code><span class="koboSpan" id="kobo.921.1">(16-bit timer).</span></li>
</ul>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.922.1">Next, let’s </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.923.1">look at the template class timer:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.924.1">template</span></span><span class="koboSpan" id="kobo.925.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.926.1">typename</span></span><span class="koboSpan" id="kobo.927.1"> TimerTraits&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.928.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.929.1">timer</span></span><span class="koboSpan" id="kobo.930.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.931.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.932.1">static</span></span><span class="koboSpan" id="kobo.933.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.934.1">uintptr_t</span></span><span class="koboSpan" id="kobo.935.1"> base_address =
                                    TimerTraits::base_address;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.936.1">using</span></span><span class="koboSpan" id="kobo.937.1"> cr1 = reg&lt;base_address + </span><span class="hljs-number"><span class="koboSpan" id="kobo.938.1">0x00</span></span><span class="koboSpan" id="kobo.939.1">&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.940.1">using</span></span><span class="koboSpan" id="kobo.941.1"> dier = reg&lt;base_address + </span><span class="hljs-number"><span class="koboSpan" id="kobo.942.1">0x0C</span></span><span class="koboSpan" id="kobo.943.1">&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.944.1">using</span></span><span class="koboSpan" id="kobo.945.1"> sr = reg&lt;base_address + </span><span class="hljs-number"><span class="koboSpan" id="kobo.946.1">0x10</span></span><span class="koboSpan" id="kobo.947.1">&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.948.1">using</span></span><span class="koboSpan" id="kobo.949.1"> psc = reg&lt;base_address + </span><span class="hljs-number"><span class="koboSpan" id="kobo.950.1">0x28</span></span><span class="koboSpan" id="kobo.951.1">&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.952.1">using</span></span><span class="koboSpan" id="kobo.953.1"> arr = reg&lt;base_address + </span><span class="hljs-number"><span class="koboSpan" id="kobo.954.1">0x2C</span></span><span class="koboSpan" id="kobo.955.1">&gt;;
    
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.956.1">template</span></span><span class="koboSpan" id="kobo.957.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.958.1">auto</span></span><span class="koboSpan" id="kobo.959.1"> Bits&gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.960.1">using</span></span><span class="koboSpan" id="kobo.961.1"> psc_bits = reg_bits&lt;Bits, psc, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.962.1">static_cast</span></span><span class="koboSpan" id="kobo.963.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.964.1">uint32_t</span></span><span class="koboSpan" id="kobo.965.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.966.1">0xFFFF</span></span><span class="koboSpan" id="kobo.967.1">)&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.968.1">template</span></span><span class="koboSpan" id="kobo.969.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.970.1">auto</span></span><span class="koboSpan" id="kobo.971.1"> Bits&gt;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.972.1">using</span></span><span class="koboSpan" id="kobo.973.1"> arr_bits = reg_bits&lt;Bits, arr, TimerTraits::arr_bit_mask&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.974.1">using</span></span><span class="koboSpan" id="kobo.975.1"> uie = reg_bits_enable_disable&lt;dier, </span><span class="hljs-number"><span class="koboSpan" id="kobo.976.1">0UL</span></span><span class="koboSpan" id="kobo.977.1">&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.978.1">using</span></span><span class="koboSpan" id="kobo.979.1"> cen = reg_bits_enable_disable&lt;cr1, </span><span class="hljs-number"><span class="koboSpan" id="kobo.980.1">0UL</span></span><span class="koboSpan" id="kobo.981.1">&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.982.1">using</span></span><span class="koboSpan" id="kobo.983.1"> uif = reg_bits_enable_disable&lt;sr, </span><span class="hljs-number"><span class="koboSpan" id="kobo.984.1">0UL</span></span><span class="koboSpan" id="kobo.985.1">&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.986.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.987.1">&lt;std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.988.1">uint32_t</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.989.1"> Period&gt;</span></span>
<span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.990.1">static</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.991.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.992.1">start</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.993.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.994.1">{
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.995.1">// a magic number prescaler value</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.996.1">// for 1ms timer resolution</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.997.1">constexpr</span></span><span class="koboSpan" id="kobo.998.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.999.1">uint32_t</span></span><span class="koboSpan" id="kobo.1000.1"> prescaler = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1001.1">9999</span></span><span class="koboSpan" id="kobo.1002.1">;
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1003.1">constexpr</span></span><span class="koboSpan" id="kobo.1004.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1005.1">uint32_t</span></span><span class="koboSpan" id="kobo.1006.1"> auto_reload = Period - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1007.1">1</span></span><span class="koboSpan" id="kobo.1008.1">;
        psc::</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1009.1">template</span></span><span class="koboSpan" id="kobo.1010.1"> set&lt;psc_bits&lt;prescaler&gt;&gt;
                    (psc_bits&lt;prescaler&gt;::value::val);
        arr::</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1011.1">template</span></span><span class="koboSpan" id="kobo.1012.1"> set&lt;arr_bits&lt;auto_reload&gt;&gt;
                    (arr_bits&lt;auto_reload&gt;::value::val);
        dier::</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1013.1">template</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1014.1">set</span></span><span class="koboSpan" id="kobo.1015.1">&lt;uie&gt;(uie::value::enable);
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1016.1">NVIC_SetPriority</span></span><span class="koboSpan" id="kobo.1017.1">(TimerTraits::irqn, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1018.1">1</span></span><span class="koboSpan" id="kobo.1019.1">);
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1020.1">NVIC_EnableIRQ</span></span><span class="koboSpan" id="kobo.1021.1">(TimerTraits::irqn);
        cr1::</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1022.1">template</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1023.1">set</span></span><span class="koboSpan" id="kobo.1024.1">&lt;cen&gt;(cen::value::enable);
    }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1025.1">In this code, we defined a template class timer with template parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.1026.1">TimerTraits</span></code><span class="koboSpan" id="kobo.1027.1"> – a traits class that </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.1028.1">provides hardware-specific constants. </span><span class="koboSpan" id="kobo.1028.2">The timer class template provides a generic interface to configure and control timers, customized for each specific timer via </span><code class="inlineCode"><span class="koboSpan" id="kobo.1029.1">TimerTraits</span></code><span class="koboSpan" id="kobo.1030.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1031.1">Please note that for the sake of simplicity of the example, this is the minimum code needed to set up the STM32 timer peripheral.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1032.1">Within the timer class, we define register type aliases, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1033.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1034.1">static</span></span><span class="koboSpan" id="kobo.1035.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1036.1">uintptr_t</span></span><span class="koboSpan" id="kobo.1037.1"> base_address = TimerTraits::base_address;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1038.1">using</span></span><span class="koboSpan" id="kobo.1039.1"> cr1 = reg&lt;base_address + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1040.1">0x00</span></span><span class="koboSpan" id="kobo.1041.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1042.1">using</span></span><span class="koboSpan" id="kobo.1043.1"> dier = reg&lt;base_address + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1044.1">0x0C</span></span><span class="koboSpan" id="kobo.1045.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1046.1">using</span></span><span class="koboSpan" id="kobo.1047.1"> sr = reg&lt;base_address + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1048.1">0x10</span></span><span class="koboSpan" id="kobo.1049.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1050.1">using</span></span><span class="koboSpan" id="kobo.1051.1"> psc = reg&lt;base_address + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1052.1">0x28</span></span><span class="koboSpan" id="kobo.1053.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1054.1">using</span></span><span class="koboSpan" id="kobo.1055.1"> arr = reg&lt;base_address + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1056.1">0x2C</span></span><span class="koboSpan" id="kobo.1057.1">&gt;;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1058.1">These type aliases represent the timer’s hardware registers, each mapped to a specific memory address. </span><span class="koboSpan" id="kobo.1058.2">Each register is an instantiation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1059.1">reg</span></code><span class="koboSpan" id="kobo.1060.1"> class template, which provides read/write access to hardware registers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1061.1">Next, we define type aliases for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1062.1">BitFields</span></code><span class="koboSpan" id="kobo.1063.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1064.1">template</span></span><span class="koboSpan" id="kobo.1065.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1066.1">auto</span></span><span class="koboSpan" id="kobo.1067.1"> Bits&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1068.1">using</span></span><span class="koboSpan" id="kobo.1069.1"> psc_bits = reg_bits&lt;Bits, psc, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1070.1">static_cast</span></span><span class="koboSpan" id="kobo.1071.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1072.1">uint32_t</span></span><span class="koboSpan" id="kobo.1073.1">&gt; (</span><span class="hljs-number"><span class="koboSpan" id="kobo.1074.1">0xFFFF</span></span><span class="koboSpan" id="kobo.1075.1">)&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1076.1">template</span></span><span class="koboSpan" id="kobo.1077.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1078.1">auto</span></span><span class="koboSpan" id="kobo.1079.1"> Bits&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1080.1">using</span></span><span class="koboSpan" id="kobo.1081.1"> arr_bits = reg_bits&lt;Bits, arr, TimerTraits::arr_bit_mask&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1082.1">using</span></span><span class="koboSpan" id="kobo.1083.1"> uie = reg_bits_enable_disable&lt;dier, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1084.1">0UL</span></span><span class="koboSpan" id="kobo.1085.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1086.1">using</span></span><span class="koboSpan" id="kobo.1087.1"> cen = reg_bits_enable_disable&lt;cr1, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1088.1">0UL</span></span><span class="koboSpan" id="kobo.1089.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1090.1">using</span></span><span class="koboSpan" id="kobo.1091.1"> uif = reg_bits_enable_disable&lt;sr, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1092.1">0UL</span></span><span class="koboSpan" id="kobo.1093.1">&gt;;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1094.1">In this code, we instantiate bit fields using the class templates </span><code class="inlineCode"><span class="koboSpan" id="kobo.1095.1">reg_bits</span></code><span class="koboSpan" id="kobo.1096.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1097.1">reg_bits_enable_disable</span></code><span class="koboSpan" id="kobo.1098.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1099.1">Finally, we define the template static method </span><code class="inlineCode"><span class="koboSpan" id="kobo.1100.1">start</span></code><span class="koboSpan" id="kobo.1101.1"> in the class template timer. </span><span class="koboSpan" id="kobo.1101.2">This </span><code class="inlineCode"><span class="koboSpan" id="kobo.1102.1">static</span></code><span class="koboSpan" id="kobo.1103.1"> function sets up </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.1104.1">the timer with the desired period and starts it. </span><span class="koboSpan" id="kobo.1104.2">The code executes the following steps:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1105.1">Calculate Prescaler and Auto-Reload values. </span><span class="koboSpan" id="kobo.1105.2">The function uses the template parameter Period to calculate these values.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1106.1">Set Prescaler (PSC) and Auto-Reload (ARR) registers.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1107.1">Enable the update interrupt on the DIER register. </span><span class="koboSpan" id="kobo.1107.2">It uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1108.1">uie</span></code><span class="koboSpan" id="kobo.1109.1"> bit field to enable the update interrupt in the DIER register.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1110.1">Configure NVIC for timer interrupts using CMSIS functions.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1111.1">Start the timer. </span><span class="koboSpan" id="kobo.1111.2">It uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1112.1">cen</span></code><span class="koboSpan" id="kobo.1113.1"> bit field to enable the timer counter in the CR1 register.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1114.1">Let’s now see how we can use the provided timer template class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1115.1">using</span></span><span class="koboSpan" id="kobo.1116.1"> timer2 = timer&lt;timer2_traits&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1117.1">using</span></span><span class="koboSpan" id="kobo.1118.1"> timer3 = timer&lt;timer3_traits&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1119.1">extern</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1120.1">"C"</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1121.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1122.1">TIM2_IRQHandler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1123.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1124.1">void</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1125.1">)</span></span><span class="koboSpan" id="kobo.1126.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1127.1">if</span></span><span class="koboSpan" id="kobo.1128.1"> (timer2::sr::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1129.1">read</span></span><span class="koboSpan" id="kobo.1130.1">() &amp; TIM_SR_UIF)
    {
        timer2::sr::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1131.1">set</span></span><span class="koboSpan" id="kobo.1132.1">&lt;timer2::uif&gt; (timer2::uif::value::disable);
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1133.1">printf</span></span><span class="koboSpan" id="kobo.1134.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1135.1">"TIM2 IRQ..\r\n"</span></span><span class="koboSpan" id="kobo.1136.1">);
    }
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1137.1">extern</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1138.1">"C"</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1139.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1140.1">TIM3_IRQHandler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1141.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1142.1">void</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1143.1">)</span></span><span class="koboSpan" id="kobo.1144.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1145.1">if</span></span><span class="koboSpan" id="kobo.1146.1"> (timer3::sr::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1147.1">read</span></span><span class="koboSpan" id="kobo.1148.1">() &amp; TIM_SR_UIF)
    {
        timer3::sr::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1149.1">set</span></span><span class="koboSpan" id="kobo.1150.1">&lt;timer3::uif&gt; (timer3::uif::value::disable);
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1151.1">printf</span></span><span class="koboSpan" id="kobo.1152.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1153.1">"TIM3 IRQ..\r\n"</span></span><span class="koboSpan" id="kobo.1154.1">);
    }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1155.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1156.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1157.1">()</span></span><span class="koboSpan" id="kobo.1158.1">
{
    timer2::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1159.1">start</span></span><span class="koboSpan" id="kobo.1160.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.1161.1">1000</span></span><span class="koboSpan" id="kobo.1162.1">&gt;();
    timer3::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1163.1">start</span></span><span class="koboSpan" id="kobo.1164.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.1165.1">500</span></span><span class="koboSpan" id="kobo.1166.1">&gt;();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1167.1">while</span></span><span class="koboSpan" id="kobo.1168.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1169.1">true</span></span><span class="koboSpan" id="kobo.1170.1">)
    {
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1171.1">In this code, we create </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.1172.1">the type aliases </span><code class="inlineCode"><span class="koboSpan" id="kobo.1173.1">timer2</span></code><span class="koboSpan" id="kobo.1174.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1175.1">timer3</span></code><span class="koboSpan" id="kobo.1176.1"> and implement </span><strong class="keyWord"><span class="koboSpan" id="kobo.1177.1">Interrupt Request (IRQ)</span></strong><span class="koboSpan" id="kobo.1178.1"> functions for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1179.1">TIM2</span></code><span class="koboSpan" id="kobo.1180.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1181.1">TIM3</span></code><span class="koboSpan" id="kobo.1182.1"> interrupts. </span><span class="koboSpan" id="kobo.1182.2">In the IRQs, we clear interrupt flags. </span><span class="koboSpan" id="kobo.1182.3">We make calls to start functions of types </span><code class="inlineCode"><span class="koboSpan" id="kobo.1183.1">timer2</span></code><span class="koboSpan" id="kobo.1184.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1185.1">timer3</span></code><span class="koboSpan" id="kobo.1186.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1187.1">main</span></code><span class="koboSpan" id="kobo.1188.1"> function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1189.1">You can run the full example in Renode. </span><span class="koboSpan" id="kobo.1189.2">Start Visual Studio Code, attach it to the running container, open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1190.1">Chapter12/cpp_hal</span></code><span class="koboSpan" id="kobo.1191.1"> project, as described in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1192.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.1193.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1194.1">$ cmake -B build -DCMAKE_BUILD_TYPE=Release -DMAIN_CPP_FILE_NAME=main_timer_peripheral.cpp
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1195.1">In this section, we learned </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.1196.1">how to create a generic, template-based timer interface by utilizing C++ templates and traits classes. </span><span class="koboSpan" id="kobo.1196.2">By defining </span><code class="inlineCode"><span class="koboSpan" id="kobo.1197.1">TimerTraits</span></code><span class="koboSpan" id="kobo.1198.1"> structures (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1199.1">timer2_traits</span></code><span class="koboSpan" id="kobo.1200.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1201.1">timer3_traits</span></code><span class="koboSpan" id="kobo.1202.1">) that encapsulate hardware-specific details of the TIM2 and TIM3 timers, we can instantiate a flexible </span><code class="inlineCode"><span class="koboSpan" id="kobo.1203.1">timer</span></code><span class="koboSpan" id="kobo.1204.1"> class template that abstracts the configuration and control of different timers. </span><span class="koboSpan" id="kobo.1204.2">This approach offers two main benefits: it increases type safety by using templates to enforce correct usage at compile time, and it results in code that is as efficient as traditional C HAL implementations because the use of templates and constexpr allows the compiler to optimize the code thoroughly.</span></p>
<h1 class="heading-1" id="_idParaDest-179"><span class="koboSpan" id="kobo.1205.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1206.1">In this chapter, we learned techniques that we can apply to create safer HAL code in C++. </span><span class="koboSpan" id="kobo.1206.2">We covered the implementation of memory-mapped peripherals. </span><span class="koboSpan" id="kobo.1206.3">The design utilizes templates and advanced techniques such as SFINAE, which we discovered in </span><a href="Chapter_08.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1207.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1208.1">. </span><span class="koboSpan" id="kobo.1208.2">We applied the knowledge from previous chapters in the embedded systems domain.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1209.1">We also learned how to design classes that implement generic behavior and depend on traits classes to supply them with specific details. </span><span class="koboSpan" id="kobo.1209.2">The code we developed is as efficient as a hand-coded (CMSIS-based) solution, thanks to the usage of templates and compile-time computations, enabling compiler optimizations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1210.1">In the next chapter, we will cover working with C libraries in C++.</span></p>
</div>
</body></html>