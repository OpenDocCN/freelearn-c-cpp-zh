<html><head></head><body>
		<div id="_idContainer015">
			<h1 id="_idParaDest-70" class="chapter-number" lang="en-GB"><a id="_idTextAnchor074"/>8</h1>
			<h1 id="_idParaDest-71" lang="en-GB"><a id="_idTextAnchor075"/>What Makes a Good Test?</h1>
			<p lang="en-GB">A project developed with TDD will have a lot of tests. But don’t assume that more or longer tests are always better. You need to have good tests. But what makes a <span class="No-Break" lang="">good test?</span></p>
			<p lang="en-GB">We’re not going to be writing more code in this chapter. This chapter is more of a look back at some of the situations we’ve already encountered as well as referring to some tests in upcoming chapters. This is a chance to reflect on what you’ve learned so far and to look forward to <span class="No-Break" lang="">upcoming topics.</span></p>
			<p lang="en-GB">A good test should incorporate the <span class="No-Break" lang="">following elements:</span></p>
			<ul>
				<li lang="en-GB">Be easy to understand – a good<a id="_idIndexMarker264"/> understanding will lead to better ideas for more tests and make tests easier <span class="No-Break" lang="">to maintain.</span></li>
				<li lang="en-GB">Be focused on a specific scenario – don’t try to test everything in one giant test. Doing too much in a test will break the first guidance <span class="No-Break" lang="">of understandability.</span></li>
				<li lang="en-GB">Be repeatable – tests that use random behavior to sometimes catch problems can miss issues at the <span class="No-Break" lang="">worst times.</span></li>
				<li lang="en-GB">Be kept close to the project – make sure that tests belong to the project they <span class="No-Break" lang="">are testing.</span></li>
				<li lang="en-GB">Should test what should happen instead of how it happens – if a test relies too much on internal workings, then it will be brittle and cause more work when the code <span class="No-Break" lang="">is refactored.</span></li>
			</ul>
			<p lang="en-GB">Each of these topics will be explained in this chapter <span class="No-Break" lang="">with examples.</span></p>
			<h1 id="_idParaDest-72" lang="en-GB"><a id="_idTextAnchor076"/>Technical requirements</h1>
			<p lang="en-GB">All code in this chapter comes from other chapters in this book and is used here as example code to reinforce ideas that make <span class="No-Break" lang="">good tests.</span></p>
			<h1 id="_idParaDest-73" lang="en-GB"><a id="_idTextAnchor077"/>Making tests easy to understand</h1>
			<p lang="en-GB">Using descriptive test names is <a id="_idIndexMarker265"/>probably the single best thing you can do to improve your tests. I like to name my tests using simple sentences whenever possible. For example, one of the earliest tests we created is called <strong class="source-inline" lang="">"Test will pass without any confirms"</strong> and looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test will pass without any confirms")
{
}</pre>
			<p lang="en-GB">A good pattern to follow <span class="No-Break" lang="">is this:</span></p>
			<pre class="source-code" lang="en-GB">
&lt;object&gt;&lt;does something&gt;&lt;qualification&gt;</pre>
			<p lang="en-GB">Each of the three sections should be replaced with something specific to what you’re doing. For the example just given, <strong class="source-inline" lang="">&lt;object&gt;</strong> is <strong class="source-inline" lang="">Test</strong>, <strong class="source-inline" lang="">&lt;does something&gt;</strong> is <strong class="source-inline" lang="">will pass</strong>, and <strong class="source-inline" lang="">&lt;qualification&gt;</strong> is <strong class="source-inline" lang="">without </strong><span class="No-Break" lang=""><strong class="source-inline" lang="">any confirms</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">I don’t always follow this pattern, especially when testing an object or a type for several different and related results. For example, a simple test immediately following the previous test looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test bool confirms")
{
    bool result = isNegative(0);
    CONFIRM_FALSE(result);
    result = isNegative(-1);
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">For this simple test, there are only two possibilities. The bool is either false or true. The test is focused on the bool type, and the name fully describes what the test does. My advice is to follow the naming pattern when it <span class="No-Break" lang="">makes sense.</span></p>
			<p lang="en-GB">The following are ways in which descriptive <a id="_idIndexMarker266"/>names help improve <span class="No-Break" lang="">your tests:</span></p>
			<ul>
				<li lang="en-GB">The name is what you see in the summary description and will help anyone understand what is being tested with just <span class="No-Break" lang="">a glance.</span></li>
				<li lang="en-GB">A descriptive name will help you spot holes in your testing because it’s easier to see what’s missing when you can clearly see what is already <span class="No-Break" lang="">being tested.</span></li>
				<li lang="en-GB">A descriptive name that follows the pattern given will help you focus when writing the test. It’s easy to lose track of what a test is supposed to do and start including other things. A descriptive name will help you put related checks in their own tests where they will <a id="_idIndexMarker267"/>no longer clutter what is being tested and will have their own descriptive name, which will help them <span class="No-Break" lang="">stand out.</span></li>
			</ul>
			<p lang="en-GB">Putting all three benefits together, you get a feedback loop that reinforces the need for good naming. You’ll naturally create more tests because each one is focused. This leads to a better understanding of what is being tested, which helps you to find missing tests. And then, when writing the new tests, you’ll stay on track and create yet more tests as new ideas come <span class="No-Break" lang="">to mind.</span></p>
			<p lang="en-GB">Imagine if, instead, we<a id="_idIndexMarker268"/> had taken a different approach and created a test called <strong class="source-inline" lang="">"Confirm"</strong>. What would it do? Does it inspire you to think of more tests? And what code would you write in the test? This is a name that stops the cycle of better tests. No one will know what the test does without reading the code. No one will think of new scenarios because the focus is dragged into the code. And the test code itself will likely be all over the place yet still not cover everything that should <span class="No-Break" lang="">be tested.</span></p>
			<p lang="en-GB">And let’s not forget that using TDD is supposed to help drive our designs, improve the quality of our software, and let us refactor and enhance the code with confidence. Descriptive names help with all <span class="No-Break" lang="">of this.</span></p>
			<p lang="en-GB">You might find that after a major refactoring, certain tests are no longer applicable. That’s fine, and they can be deleted. Descriptive names will help us spot these outdated tests. Sometimes, instead of deleting tests, they can be updated, and tests that are focused will be easier <span class="No-Break" lang="">to update.</span></p>
			<p lang="en-GB">The next step to creating good tests is to keep them simple. A complicated test is usually a symptom of a bad design. TDD helps improve designs. So when you find a complicated test, that’s your signal to simplify the design of the project <span class="No-Break" lang="">being tested.</span></p>
			<p lang="en-GB">If you can make changes that simplify the tests, then that’s usually a double win. You get tests that are easier to understand, which leads to higher quality software that is easier to use. Remember that a test is a consumer of your software, just like any other component. So when you can simplify a test, you’re also simplifying other code that uses the same code <span class="No-Break" lang="">being tested.</span></p>
			<p lang="en-GB">A big part of simplifying tests is to make use of setup and teardown code. This lets the test focus on what it needs to do and lets us read and understand the main point of the test without getting distracted with other code that just gets <span class="No-Break" lang="">things ready.</span></p>
			<p lang="en-GB">For example, in <a href="B18567_14.xhtml#_idTextAnchor139"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 14</em></span></a>, <em class="italic" lang="">How To Test Services</em>, I show you the test that I first created to test a service. The test created a local instance of the service and called <strong class="source-inline" lang="">start</strong>. I realized that other tests would likely need to start a service, so they might as well share the same service that has already been started with some setup code. The new test uses a test suite that <a id="_idIndexMarker269"/>allows multiple tests to share the same setup and teardown code. The test looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST_SUITE("Request can be sent and response received", "Service 1")
{
    std::string user = "123";
    std::string path = "";
    std::string request = "Hello";
    std::string expectedResponse = "Hi, " + user;
    std::string response = gService1.service().handleRequest(
        user, path, request);
    CONFIRM_THAT(response, Equals(expectedResponse));
}</pre>
			<p lang="en-GB">This test has a descriptive name and focuses on what needs to be tested instead of what is needed to create and start the service. The test uses the global <strong class="source-inline" lang="">gService1</strong> instance, which exposes the already running service through the <span class="No-Break" lang=""><strong class="source-inline" lang="">service</strong></span><span class="No-Break" lang=""> method.</span></p>
			<p lang="en-GB">By providing descriptive names and keeping your tests as simple as possible, you’ll find better results with TDD that will lead to better software designs. The next section goes into more detail about how to focus on <span class="No-Break" lang="">specific scenarios.</span></p>
			<h1 id="_idParaDest-74" lang="en-GB">Keeping tests focused on specific scen<a id="_idTextAnchor078"/>arios</h1>
			<p lang="en-GB">The previous section explained that one of the benefits of descriptive names is that they help keep your tests focused. We’re going to <a id="_idIndexMarker270"/>explore in this section various scenarios that will give you ideas for what to <span class="No-Break" lang="">focus on.</span></p>
			<p lang="en-GB">Saying that a test should be focused is great. But if you don’t know how to figure out what to focus on, then it won’t help you. The advice becomes empty <span class="No-Break" lang="">and frustrating.</span></p>
			<p lang="en-GB">These five cases will make the advice more meaningful. Not all of them may apply to all situations. But having these will help you, sort of like a checklist. All you need to do is think about each one and write specific tests that cover the case. The cases are <span class="No-Break" lang="">as follows:</span></p>
			<ol>
				<li lang="en-GB"><strong class="bold" lang="">Happy or normal</strong>: This is a common <span class="No-Break" lang="">use case.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Edge</strong>: This is a case near the transition between normal and <span class="No-Break" lang="">error cases.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Error</strong>: This is a common problem that needs to <span class="No-Break" lang="">be handled.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Not normal</strong>: This is a valid but uncommon <span class="No-Break" lang="">use case.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Deliberate misuse</strong>: This is an error case designed to cause problems <span class="No-Break" lang="">on purpose.</span></li>
			</ol>
			<p lang="en-GB">Let’s start with the happy or normal case first. This one should be easy, but it often gets over-complicated by including some of the other cases in the same test. Or another way it can be over-complicated is by <a id="_idIndexMarker271"/>creating a test that is too vague or not clear that it’s the happy or <span class="No-Break" lang="">normal case.</span></p>
			<p lang="en-GB">The actual name for this should probably be the normal case since that matches the style of the other cases. But I so often think of this as the happy case that I included both names. You might also think of this as a typical case. However you think of it, all you need to do is pick a scenario that best describes a common way that your code will be used. I think of it as a happy case because there should not be any errors. This should represent usage that is expected and typical and should succeed. For example, in <a href="B18567_13.xhtml#_idTextAnchor131"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 13</em></span></a>, <em class="italic" lang="">How to Test Floating Point and Custom Values</em>, there’s a test for float values that covers 1,000 typical values from 0.1 up to 100 in increments of 0.1. The test looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test many float comparisons")
{
    int totalCount {1'000};
    int passCount = performComparisons&lt;float&gt;(totalCount);
    CONFIRM_THAT(passCount, Equals(totalCount));
}</pre>
			<p lang="en-GB">An edge case is right on the borderline between a happy case and a problem or error case. You might often need two edge cases where one represents the most extreme usage that is still within normal bounds, and the other is the beginning of the error conditions. An edge case is a transition between good and bad results. And there can often be multiple <span class="No-Break" lang="">edge cases.</span></p>
			<p lang="en-GB">Edge cases are extremely valuable to include in your testing because they tend to find a lot of bugs, and maybe even more importantly, they make you think about your design. When you consider edge cases, you’ll often either accept the edge case or change your design so that the edge case doesn’t <span class="No-Break" lang="">apply anymore.</span></p>
			<p lang="en-GB">The edge cases for the<a id="_idIndexMarker272"/> previous float comparisons are to test a very small float value and a very large float value. These are two separate tests and look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test small float values")
{
    // Based on float epsilon = 1.1920928955078125e-07
    CONFIRM_THAT(0.000001f, NotEquals(0.000002f));
}
TEST("Test large float values")
{
    // Based on float epsilon = 1.1920928955078125e-07
    CONFIRM_THAT(9'999.0f, Equals(9'999.001f));
}</pre>
			<p lang="en-GB">Edge cases can sometimes be a bit more technical because there’s usually a reason for the test to be an edge case. For float values, the edge cases are based on the <em class="italic" lang="">epsilon</em> value. Epsilon values are explained in <a href="B18567_13.xhtml#_idTextAnchor131"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 13</em></span></a>, <em class="italic" lang="">How to Test Floating Point Values</em>. Adding tests for small and large floating point values will cause us to change the entire way that we compare floating point values in <a href="B18567_13.xhtml#_idTextAnchor131"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 13</em></span></a>. This is why edge cases are so valuable <span class="No-Break" lang="">in testing.</span></p>
			<p lang="en-GB">The error case is like the happy case turned sad. Think of a typical problem that your code might need to handle and write a test for that specific problem. Just like how the happy case can sometimes be over-complicated, this one, too, can be over-complicated. You don’t need to include minor variations of an error case just for the sake of variation alone. Just pick what you think represents the most common or middle case that should result in an error and create a test for just that one case. Of course, you will want to name the test with a descriptive name that explains <span class="No-Break" lang="">the case.</span></p>
			<p lang="en-GB">For example, in <a href="B18567_11.xhtml#_idTextAnchor114"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 11</em></span></a>, <em class="italic" lang="">Managing Dependencies</em>, there’s a normal test to make sure that tags <em class="italic" lang="">can</em> be used to filter messages. An error case is almost the opposite and makes sure that an overridden default tag is <em class="italic" lang="">not</em> used to filter the message. The test might not make sense without first reading <a href="B18567_11.xhtml#_idTextAnchor114"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 11</em></span></a>. I’m including it here as an example of an error case. Notice <strong class="source-inline" lang="">CONFIRM_FALSE</strong> at the end of the test, which is the part that ensures the log message does not appear in the log file. The test looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Overridden default tag not used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(), info);
    std::string message = "message ";
    message += Util::randomString();
    MereMemo::log(debug) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
}</pre>
			<p lang="en-GB">If there are multiple error cases that you think are all important enough to be included, put them in separate tests and ask what makes each one different. This will lead to the insight that might cause you to change your design or might lead to <span class="No-Break" lang="">more tests.</span></p>
			<p lang="en-GB">I like to include a few tests that are just outside of a normal case but not borderline or edge. These are still within valid use that should succeed but might cause your code to do a little extra work. This case can be valuable in helping to catch regressions. A regression is a bug that is new and represents a problem that used to work previously. A regression is most <a id="_idIndexMarker273"/>common after making a large design change. Having some tests that are not normal but still expected to succeed will improve your confidence in your code continuing to work after major changes <span class="No-Break" lang="">are made.</span></p>
			<p lang="en-GB">The last case is deliberate misuse and is important for security reasons. This is not just an error case; it’s an error case crafted to try to cause your code to fail in predictable ways that an attacker can use for their own purposes. For cases like this, instead of creating tests that you know will fail, try to think of what would cause your code to fail spectacularly. Maybe your code treats negative numbers as errors. Then for deliberate misuse, maybe consider using really large <span class="No-Break" lang="">negative numbers.</span></p>
			<p lang="en-GB">In <a href="B18567_14.xhtml#_idTextAnchor139"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 14</em></span></a>, <em class="italic" lang="">How to Test Services</em>, there is mention of a possible test for deliberate misuse. We don’t actually create this test, but I do describe what the test would look like. In the service, there is a string value that represents the request being made. The code handles unrecognized request strings, and I mentioned that a good test would try to call the service with some request that doesn’t exist to make sure that the service properly handles the <span class="No-Break" lang="">ill-formed request.</span></p>
			<p lang="en-GB">For a final piece of advice about focusing on specific scenarios, I’d like to recommend that you avoid retesting. This is not one of the five cases just mentioned because it applies to all <span class="No-Break" lang="">of them.</span></p>
			<p lang="en-GB">Retesting is where you check<a id="_idIndexMarker274"/> the same thing or make the same confirmations over and over in many tests. You don’t need to do this, and it just distracts you from what each test should be <span class="No-Break" lang="">focused on.</span></p>
			<p lang="en-GB">If there’s a property or result that you need to confirm works, then create a test for it. And then you can trust that it will be tested. You don’t need to confirm again and again that the property works as expected each time it’s used. Once you have a test for something, then you don’t need to verify it works in <span class="No-Break" lang="">other tests.</span></p>
			<h1 id="_idParaDest-75" lang="en-GB">Use random behavior only i<a id="_idTextAnchor079"/><a id="_idTextAnchor080"/>n this way</h1>
			<p lang="en-GB">The previous chapter<a id="_idIndexMarker275"/> mentioned using random behavior in tests, and it’s important for you to understand more about this so that your tests are predictable <span class="No-Break" lang="">and repeatable.</span></p>
			<p lang="en-GB">Predictability and randomness are about as opposite as you can get. How should we reconcile these two properties? The first thing to understand is that the tests you write should be predictable. If a test passes, then it should always pass unless something outside of your control fails, such as a hard drive crashing in the middle of your tests. There’s no way to predictably handle accidents like that, and that’s not what I’m talking about. I mean that if a test passes, then it should continue to pass until some code change causes it <span class="No-Break" lang="">to fail.</span></p>
			<p lang="en-GB">And when a test fails, then it should continue to fail until the problem is fixed. The last thing you want is to add random behavior to your tests so that you sometimes do one thing and other times do another. That’s because the first behavior might pass, while the second behavior goes down a different code path <span class="No-Break" lang="">that fails.</span></p>
			<p lang="en-GB">If you get a failure, make a change that you think fixes the problem, and then get a pass, you might think that your change fixed the problem. But what if the second test run just happened to use the random behavior that was always passing? It makes it hard to verify that a code change actually fixed <span class="No-Break" lang="">a problem.</span></p>
			<p lang="en-GB">And worse yet, what happens when some random failure condition never gets run? You think all possible code path combinations are being run, but by chance, one or more conditions are skipped. This can cause you to miss a bug that should have <span class="No-Break" lang="">been caught.</span></p>
			<p lang="en-GB">I hope I’ve convinced you to stay away from random test behavior. If you want to test different scenarios, then write multiple tests so that each scenario is covered by its own test that will reliably <span class="No-Break" lang="">be run.</span></p>
			<p lang="en-GB">Why, then, did I mention<a id="_idIndexMarker276"/> using randomness in the previous chapter? I actually do suggest that you use randomness but not in a way that determines what a test does; rather, in a way that helps prevent collisions between different test runs. The random behavior is mentioned in one of the helper functions to create a temporary table <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
std::string createTestTable ()
{
    // If this was real code, it might open a
    // connection to a database, create a temp
    // table with a random name, and return the
    // table name.
    return "test_data_01";
}</pre>
			<p lang="en-GB">Let’s say that you have a test that needs some data. You create the data in setup and delete it when the test is done in teardown. What happens if the test program crashes during the test and the teardown never gets a chance to delete the data? The next time you run your test, it’s likely that the setup will fail because the data still exists. This is the collision I’m <span class="No-Break" lang="">talking about.</span></p>
			<p lang="en-GB">Maybe you think that you can just enhance the setup to succeed if it finds the data already exists. Well, you can also get collisions in other ways, such as when writing code in a team and two team members happen to run the tests at almost the same time. Both setup steps run, and one of them finds the data already exists and continues. But before the test can begin to use the data, the other team member finished, and the teardown code deletes the data. The team member that is still running tests will now fail because the data no <span class="No-Break" lang="">longer exists.</span></p>
			<p lang="en-GB">You can almost entirely eliminate this problem by generating random data. Not so random that the behavior of the test is affected. But just random enough to avoid conflicts. Maybe the data is identified by a name. As long as the name is not part of what is being tested, the name can be changed slightly so that each time the test is run, the data will have a different name. The <strong class="source-inline" lang="">createTestTable</strong> function returns a hardcoded name, but the comment mentions that a random name might <span class="No-Break" lang="">be better.</span></p>
			<p lang="en-GB">There is a place for using full random behavior in tests, such as when performing random penetration testing, and you need to fuzz or alter the data to simulate scenarios that you otherwise would not be able to write specific test cases for. The number of possible combinations could be too many to handle with specific named test cases. So in these situations, it is a<a id="_idIndexMarker277"/> good idea to write tests that use random data that can change the behavior and outcome of the tests. But these types of tests won’t help you with TDD to improve your designs. They have a place that <span class="No-Break" lang="">supplements TDD.</span></p>
			<p lang="en-GB">When writing tests that use random behavior, such as when handling uncountable combinations, you’ll need to capture the failures because each one will need to be analyzed to find the problem. This is a time-consuming process. It’s valuable, but not what you need when writing a test to help you figure out what design to use or when evaluating the results of a major design change to see if anything <span class="No-Break" lang="">was broken.</span></p>
			<p lang="en-GB">For the types of tests that are most beneficial to TDD, avoid any random behavior that can change the outcome of the tests. This will keep your tests reproducible <span class="No-Break" lang="">and predictable.</span></p>
			<h1 id="_idParaDest-76" lang="en-GB"><a id="_idTextAnchor081"/>Only test your project</h1>
			<p lang="en-GB">Other components and libraries <a id="_idIndexMarker278"/>will be used and might fail. How should you handle these failures in your tests? My advice is to assume that only your code needs to be tested. You should assume that the components and libraries you are using have already been tested and are <span class="No-Break" lang="">working correctly.</span></p>
			<p lang="en-GB">For one thing, remember that we are using TDD to improve our own code. If you were to write a test for some code that you bought or found online, how would this affect your <span class="No-Break" lang="">own code?</span></p>
			<p lang="en-GB">There’s always a possibility that you are using an open source library and you have a good idea for improvement. That’s great! But that improvement belongs in that other project. It has no place in your own project’s tests. Even if you find a bug in a commercial software package, all you can do is report the problem and hope it <span class="No-Break" lang="">gets fixed.</span></p>
			<p lang="en-GB">The last thing you want to do is put a confirmation in your own test project that confirms some other code is working as expected. This not only does not affect your own designs, it actually makes your tests less focused. It takes away from the clarity you should be aiming for by adding distractions that don’t directly benefit your <span class="No-Break" lang="">own project.</span></p>
			<p lang="en-GB">The next chapter of this<a id="_idIndexMarker279"/> book begins <em class="italic" lang="">Part 2</em>, where we’ll build a logging library. The logging library will be a separate project with its own set of tests. The logging library will also use the testing library we’ve been building. Imagine how confusing it would be if we were to add a new feature to the testing library and then test that new feature from the <span class="No-Break" lang="">logging library.</span></p>
			<h1 id="_idParaDest-77" lang="en-GB"><a id="_idTextAnchor082"/>Test what should happen instead of how</h1>
			<p lang="en-GB">A common problem I see is when<a id="_idIndexMarker280"/> a test tries to verify expected results by checking internal steps along the way. The test is checking how something is done. This type of test is fragile and often needs frequent updates <span class="No-Break" lang="">and changes.</span></p>
			<p lang="en-GB">A better approach is to test what happens as a final result. Because then the internal steps can change and adapt as needed. The test remains valid the entire time without <span class="No-Break" lang="">further maintenance.</span></p>
			<p lang="en-GB">If you find yourself going through your tests and frequently updating them, so the tests pass again, then your tests might be testing how something is done instead of what <span class="No-Break" lang="">is done.</span></p>
			<p lang="en-GB">For example, in <a href="B18567_10.xhtml#_idTextAnchor096"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 10</em></span></a>, <em class="italic" lang="">The TDD Process in Depth</em>, there’s a section called <em class="italic" lang="">When is testing too much?</em> that explains the idea of what to test in <span class="No-Break" lang="">greater detail.</span></p>
			<p lang="en-GB">The general idea is this. Let’s say you have a function that adds a filter to a collection. If you write a test that’s focused on how the code works, then you might go through the items in the collection to make sure the filter that was just added really appears in the collection. The problem with this approach is that the collection is an internal step and might change, which will cause the test to fail. A better approach is to first add the filter and then try to perform an operation that would be affected by the filter. Make sure that the filter affects the code as you expect, and leave the internal details of how it works to the code being tested. This is testing what should happen and is a much <span class="No-Break" lang="">better approach.</span></p>
			<h1 id="_idParaDest-78" lang="en-GB"><a id="_idTextAnchor083"/>Summary</h1>
			<p lang="en-GB">This has been more of a reflective chapter where you learned some tips to help you write better tests. Examples from earlier and later chapters were used to help reinforce the ideas and guidance. You’ll write better tests if you make sure to consider the <span class="No-Break" lang="">following items:</span></p>
			<ul>
				<li lang="en-GB">The tests should be easy to understand with <span class="No-Break" lang="">descriptive names.</span></li>
				<li lang="en-GB">Prefer small and focused tests instead of large tests that try to <span class="No-Break" lang="">do everything.</span></li>
				<li lang="en-GB">Make sure that tests are repeatable. If a test fails once, then it should continue to fail until the code <span class="No-Break" lang="">is fixed.</span></li>
				<li lang="en-GB">Once you test something, you don’t need to keep testing the same thing. And if you have some useful code that other tests can share, then consider putting the code in its own project with its own set of tests. Only test the code that is in <span class="No-Break" lang="">your project.</span></li>
				<li lang="en-GB">Test what should happen instead of how it should happen. In other words, focus less on the internal steps and instead verify the results you are most <span class="No-Break" lang="">interested in.</span></li>
			</ul>
			<p lang="en-GB">There are many ways to write better tests. This chapter should not be considered to include the only things you need to consider. Instead, this chapter identifies some common issues that cause problems with tests and gives you tips and advice to improve your tests. In the next chapter, we’re going to use TDD to create something that will use a unit test library just like any other project you’ll be <span class="No-Break" lang="">working on.</span></p>
		</div>
	

		<div id="_idContainer016" class="Content">
			<h1 id="_idParaDest-79" lang="en-GB"><a id="_idTextAnchor084"/>Part 2: Using TDD to Create a Logging Library</h1>
			<p lang="en-GB">This book is divided into three parts. In this second part, we’re going to use the unit test library to design and build a logging library. Along the way, you’ll see how to use TDD in a different project just as you’ll need to do when working on your <span class="No-Break" lang="">own projects.</span></p>
			<p lang="en-GB">The following chapters are covered in <span class="No-Break" lang="">this part:</span></p>
			<ul>
				<li lang="en-GB"><a href="B18567_09.xhtml#_idTextAnchor085"><em class="italic" lang="">Chapter 9</em></a>, <em class="italic" lang="">Using Tests</em></li>
				<li lang="en-GB"><a href="B18567_10.xhtml#_idTextAnchor096"><em class="italic" lang="">Chapter 10</em></a>, <em class="italic" lang="">The TDD Process in Depth</em></li>
				<li lang="en-GB"><a href="B18567_11.xhtml#_idTextAnchor114"><em class="italic" lang="">Chapter 11</em></a>, <em class="italic" lang="">Managing Dependencies</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer017">
			</div>
		</div>
		<div>
			<div id="_idContainer018">
			</div>
		</div>
	</body></html>