<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">U.I. Necessities, Menus, HUD, and Load/Save</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will get to work on another fundamental necessity of any game: our UI, and as a typical example of it, we'll add loading and saving of our game state to our game. Unreal provides some great tools for these two things, especially UMG for creating UIs, which we will explore here. When it comes to loading and saving your game, it is a system almost every game uses in some form, but none in the same way, and the complexity of it will be absolutely driven by your design and desired player experience. We'll first get our inventory showing up in our HUD. In the next section we'll address some strategies for saving based on different game types, and then we'll tackle one of Unreal's most difficult: saving in-map and restoring to an exact point during gameplay.  In this chapter, we'll:</p>
<ul>
<li>Make inventory icons using an automated screen-capture level</li>
<li>Integrate the icons into the player's HUD on screen</li>
<li>Synchronize the inventory with the HUD/U.I.</li>
<li>Save and load the full game state from anywhere</li>
<li>Build the U.I. for loading and saving</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>As usual, it is recommended to simply begin at the point of progress reached in <a href="267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml" target="_blank">Chapter 3</a>, <em>Blueprint Review and When to Use BP Scripting</em>, as the GitHub project does here:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-4">https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-4</a></p>
<p>While the <a href="267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml" target="_blank">Chapter 3</a>, <em>Blueprint Review and When to Use BP Scripting</em><span>,</span> content is not specifically required, <a href="5cc3645d-8420-4178-9897-2c71100caeac.xhtml" target="_blank">Chapter 2</a>, <em>Inventory and Weapons for the Player</em>, will be heavily used and referenced, so those classes should be considered mandatory for the value of this work.</p>
<p>Engine version used: <span>4.19.0</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating UMG into our player's HUD class</h1>
                </header>
            
            <article>
                
<p>In <a href="5cc3645d-8420-4178-9897-2c71100caeac.xhtml" target="_blank">Chapter 2</a>,<span> </span><em>Inventory and Weapons for the Player</em>, we managed to create an inventory system for our player, a means of picking up new weapons, and an input scheme for switching between them. However, other than visually seeing which projectile was fired, we had no real reference for what we had in hand. So now we will give the player a display so they can see what they are using, and as part of that, we will finally add some new art assets from the free Unreal Marketplace.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building icons for the inventory with screen captures</h1>
                </header>
            
            <article>
                
<p>To make this exercise more meaningful and a bit more of a real-world scenario, we need more art. As stated before, however, this is not a book about generating art or most UE4 content. That said, as a technical developer trying to prove what can and can't be done, and without requiring you, the reader, to spend money on Marketplace content or outsourced art studios the way a production game typically would, we will use some stand-in art that's free. So the first thing to do is to get to the Epic Games Launcher. As first noted in <a href="dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml" target="_blank">Chapter 1</a>, <em>Making a C++ Project for a First-Person Shooter</em>, it's usually best to just make a shortcut directly to your UE4 editor executable. In case you forgot, here is that sentence where I recommend "<span><em>creating a shortcut to your UE4 install folder's</em> <kbd>/Engine/Binaries/Win64/UE4Editor.exe</kbd>," or of course you can manually just go and click it to launch it as well.</span></p>
<p><span>This launches the editor with no game, brings up a list of game projects you could open, but also in that Unreal Project Browser in the top-right is a <span class="packt_screen">Marketplace</span> button, so let's head there. At the very top, make sure you select <span class="packt_screen">Unreal Engine</span>, then on the left, click <span class="packt_screen">Marketplace</span>. At the top of the content row, you will find what can be a great friend to teams looking to prototype with cool-looking content or make games based on some amazing Epic released assets, the <span class="packt_screen">Free</span> tab. Scroll down to <span class="packt_screen">Infinity Blade: Weapons</span> and <span class="packt_screen">Add to Cart</span> (and then check out with the little shopping cart in the top-right corner):</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/524d4530-5cbc-4bc5-b550-2488e2a4f428.png"/></p>
<p>These will now appear when you select the <span class="packt_screen">Library</span> item on the left, below <span class="packt_screen">Marketplace</span>. So now, all we need to do is add them to our project to get access to all this great content. Now, glancing at what this package gives you, these are all melee weapons of course, but unfortunately, at the time of writing, there is not a pack of free ranged (gun) weapons, so we'll make do with what we've got. Click <span class="packt_screen">Library</span> and scroll to the <span class="packt_screen">Vault</span> section to where you find Infinity Blade: Weapons add click <span class="packt_screen">Add to Project</span>. From here you will need to click the box for <span class="packt_screen">Show all projects</span> at the top, and select our <span class="packt_screen">Mastering</span> project. It will complain these assets are not compatible with Other engine version, so select 4.19 from the dropdown (or whichever is the newest version at or behind the local engine you have been building) and then <span class="packt_screen">Add to Project</span>. It may then need to download the assets. Wait for this to finish, of course.</p>
<p>Now, opening our project in the editor, <span>if you have your sources panel open,</span><span> </span><span>you will see in the Content Browser a new folder, </span><kbd>/Content/InfinityBladeWeapons</kbd><span>, under which there are several which are characters (note that some are static meshes, but as our original gun and pickups expect, we will stick to some of the character weapons). Feel free to open, for example,</span><span> </span><kbd>/Content/InfinityBladeWeapons/Weapons/Blunt/Blunt_Ravager</kbd> <span>and open the</span> <kbd>SK_Blunt_Ravager</kbd> <span>skeletal mesh to get a look at this interesting spiky hammer weapon. We'll use a few of these to make some new weapons for our game. Since we have already been through this process in <a href="5cc3645d-8420-4178-9897-2c71100caeac.xhtml" target="_blank">Chapter 2</a>, </span><em>Inventory and Weapons for the Player</em><span>, </span><span>I will quickly list the steps I am using here to create a</span> few new items:</p>
<ol>
<li>In our <kbd>/Content/FirstPersonCPP/Blueprints</kbd> folder, I'll right-click <span class="packt_screen">BigBallGun</span> and <span class="packt_screen">Duplicate</span> it.</li>
<li>I'll do the same thing for the pickup (<span class="packt_screen">BigBallGunPickup</span>)<span>.</span></li>
<li>For the ravager weapon, I will now rename these blueprints <span class="packt_screen">RavagerGun</span> (yes, we're making a gun out of a hammer, but again, the art is just what we have available), and <span class="packt_screen">RavagerGunPickup</span>, leaving the other items (such as projectile) the same as the <span class="packt_screen">BigBallGun<span>.</span></span></li>
<li>Opening the <span class="packt_screen">RavagerGun</span> in the full BP editor, and selecting its <span class="packt_screen">WeaponMesh</span> component, I can now set this to the <span class="packt_screen">SK_Blunt_Ravager</span> we just looked at<span>.</span></li>
<li>Similarly, I set the <span class="packt_screen">BallGunPickup</span> mesh component to use the same skeletal mesh, and rename the component to <span class="packt_screen">PickupMesh</span> so that as we duplicate them in the future this has a generic name:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9f2afc5c-eedb-4758-8ca1-f6bdf8bbd6ef.png"/></p>
<p>And lastly, to differentiate it, I <span>set the Weapon Power to 2 in</span> <span>the</span> <span class="packt_screen">RavagerGunPickup(self)</span> <span>details and select the</span> RavagerGun <span>from its</span> Mastering Weapon Pickup <span>fly-out. You can, of course, set the weapon's Projectile to any you'd like, or make a new one, adjust its position in the player's hands, and so on; but for now, we have an axe that shoots!</span></p>
<p>Adding one of the pick-ups to the level and testing it quickly is a good checkpoint to add the project to GitHub.</p>
<div class="packt_infobox">Pulling down the GitHub project from this point will require a bit more time as these assets download (which are larger than the entire rest of the project to this point!), but that delay will only happen the first time they are pulled.</div>
<p>I will repeat this process of adding a weapon and pick-up two more times until there's a total of five weapons at the moment that can be differentiated. For organization purposes now that there are more than a couple of blueprints, I'm moving all of these weapons, projectiles, and pickups to a new <kbd>/Content/FirstPersonCPP/Blueprints/Weapons</kbd> folder. Our next step is to get some icons built from these models. Some projects will have artists that want to draw these by hand; other games may have no artists and use this technique or simply draw the actors directly into a render target texture to display these items. The render target idea is explored further in the additional reading section, but for now, let's focus on generating icons from screenshots in an automated way.</p>
<p>To accomplish great looking, alpha-masked output icons for high-quality UI use, we will need to do a few things in this order:</p>
<ol>
<li>Make a new Camera Actor that automates our process and takes our screenshots. Implementing this camera will have several parts as well, including placement and orientation of our weapon actors, taking depth-masked screenshots, and importing those back to our actors as textures.</li>
<li>Make a new level, add an instance of our new camera to it, and add a SkyLight to it.</li>
<li>Hook the imported texture back into our pick-ups to pass to the UI.</li>
<li>Make an icon widget in UMG that takes a weapon's texture on creation.</li>
<li>Build a list in UMG and add this to the HUD. Hook the inventory class to the list widget and have it update to reflect the player's weapon choice.</li>
</ol>
<p>With most significant game features such as this, there are a number of steps, and each has various levels of complexity; but if you can order them in such a way to implement and test each of them as we go, as the preceding process is designed to do, it's just a matter of time before you go from A to B and have your finished system. So let's get started with the new camera class. In the editor at the <kbd>/Content/Blueprints</kbd> level, I'll add a new C++ class and name it <span class="packt_screen">MasteringIconCamera</span>, and derive it from <span class="packt_screen">CameraActor</span>. This camera's whole job will be to open weapon pickups and place them in a nice way in front of it and then take screenshots, which  we will use as icons.</p>
<p class="mce-root"/>
<p>Here is an opportunity to show where using blueprints can be a real time saver. It's most definitely possible to simply place a camera directly in a level, and with some work, get its viewport to take screenshots. If time permits and someone is determined or is very experienced with these systems in C++, it can be done with effort. Or, you can make a game mode in blueprint, make a new pawn in blueprint, and no C++ native classes are needed. As we have made blueprint classes before, I'll just list the steps taken in this section and, as always, if problems arise, this progress is available in GitHub to check against:</p>
<ol>
<li>In the <span class="packt_screen">Blueprints</span> folder, create an <span class="packt_screen">IconMaker</span> folder, and in it create a new blueprint based off <span class="packt_screen">Pawn</span>, named <span class="packt_screen">IconPawn.</span></li>
<li>Create a game mode based on <span class="packt_screen">GameModeBase</span>. Name it <span class="packt_screen">IconGameMode<span>.</span></span></li>
<li>In the game mode, uncheck <span class="packt_screen">Allow Tick Before Begin Play</span> (set false), set <span class="packt_screen">HUD Class</span> to <span class="packt_screen">None</span>, and set <span class="packt_screen">Default Pawn Class</span> to <span class="packt_screen">IconPawn.</span></li>
<li>In <span class="packt_screen">IconPawn</span>, under its <span class="packt_screen">DefaultSceneRoot</span>, add a <span class="packt_screen">ChildActor</span> component and set its <span class="packt_screen">Child Actor Class</span> to <span class="packt_screen">MasteringIconCamera.</span></li>
<li>In that child camera, uncheck <span class="packt_screen">Constrain Aspect Ratio</span> in <span class="packt_screen">Camera Component's Camera Settings </span>(this avoids a check from often asserting when using custom depth field screenshots).</li>
<li>Optionally set the FOV (for experimental purposes, I set it to 45 as it makes some of the math easier to test later). Any range from very small to 90+ is fine. Normally for this kind of thing I'd want to use an orthographic camera for simplicity, but lighting has had many problems in UE4's orthographic rendering for years. We handle FOV in code, as seen later.</li>
</ol>
<p>This is it for the blueprint classes. Now we need a new level to use them in. So in the editor, be sure to save your blueprints, then go to <span class="packt_screen">File</span> &gt; <span class="packt_screen">New Level</span>, picking the Empty Level template <span>and naming it <kbd>IconScreenshotMap</kbd></span>. Drag an Icon Pawn into the level and in the Details pane with it selected, be sure its location <span>and its rotation </span><span>is set to</span> <kbd>0</kbd>, <kbd>0</kbd>, <kbd>0</kbd><span>. We can also borrow a trick from the FPS template's example map, and under our in-level pawn's</span> <span class="packt_screen">Pawn</span> <span>properties, set</span> <span class="packt_screen">Auto Possess Player</span> <span>to</span> <span class="packt_screen">Player 0</span><span>. This way, when the game starts, it puts the local default player right into this pawn rather than making one from a player spawn. Another tip: you can copy all of the lighting objects (or the whole lighting folder) from</span> <kbd>FirstPersonExampleMap</kbd> <span>and paste them into this map.</span></p>
<p><span>In any case, you will certainly need a Sky Light and probably want a Directional Light as in the GitHub version, but this is a bit subjective for changing the look of the weapons as we screenshot them. Tthe GitHub version may be a bit too bright, making the renders a little washed out; but again, this is subjective and not the focus of this chapter.</span></p>
<p>Now that we have a level and lighting, let's fix up some <span class="packt_screen">World Settings</span> in the main editor tab for the level. Set the <span class="packt_screen">GameMode</span> <span class="packt_screen">Override</span> to <span class="packt_screen">IconGameMode</span>, and down in <span class="packt_screen">Physics</span>, we want to check the <span class="packt_screen">Override World Gravity</span> box and set it to 0.0 (we don't want our pawn immediately, or ever, falling). For completeness, I added a pickup for the default ball gun and put a scale on the big ball gun pickup to differentiate it later. So now our level and picture-grabbing pawn are all set; all we need now is for the camera in it to actually do something!</p>
<p>We'll begin in its <kbd>BeginPlay</kbd> function back in C++. Our header has several member variables and a number of functions that we'll need to automate our screen-grabs:</p>
<pre><span>UCLASS</span><span>()</span>
<span>class</span> <span>MASTERING_API</span> <span>AMasteringIconCamera</span> <span>:</span> <span>public</span> <span>ACameraActor</span>
<span>{</span>
        <span>GENERATED_BODY</span><span>()</span>
        
<span>public</span><span>:</span>
        <span>virtual</span> <span>void</span> <span>BeginPlay</span><span>()</span> <span>override</span><span>;</span>
 
<span>protected</span><span>:</span>
 
        <span>virtual</span> <span>void</span> <span>TakeShot</span><span>();</span>
        <span>virtual</span> <span>void</span> <span>SpawnAndPlaceNextActor</span><span>();</span>
        <span>virtual</span> <span>FVector</span> <span>ComputeActorLocation</span><span>();</span>
        <span>virtual</span> <span>void</span> <span>OnFinishedLoadingAssets</span><span>();</span>
 
        <span>UPROPERTY</span><span>(</span><span>Transient</span><span>)</span>
        <span>TArray</span><span>&lt;</span><span>FSoftObjectPath</span><span>&gt;</span> <span>WeaponBlueprintSoftRefs</span><span>;</span>
        <span>UPROPERTY</span><span>(</span><span>Transient</span><span>)</span>
        <span>TArray</span><span>&lt;</span><span>class</span> <span>UBlueprint</span><span>*&gt;</span> <span>WeaponBlueprints</span><span>;</span>
 
        <span>UPROPERTY</span><span>(</span><span>Transient</span><span>)</span>
        <span>class</span> <span>UBlueprint</span><span>*</span> <span>CurrentWeaponBlueprint</span> <span>=</span> <span>nullptr</span><span>;</span>
        <span>UPROPERTY</span><span>(</span><span>Transient</span><span>)</span>
        <span>class</span> <span>AMasteringWeaponPickup</span><span>*</span> <span>CurrentWeaponPickup</span> <span>=</span> <span>nullptr</span><span>;</span>
        <span>UPROPERTY</span><span>(</span><span>Transient</span><span>)</span>
        <span>class</span> <span>UCameraComponent</span><span>*</span> <span>CameraComp</span><span>;</span>
        <span>UPROPERTY</span><span>(</span><span>Transient</span><span>)</span>
        <span>bool</span> <span>bInitialied</span> <span>=</span> <span>false</span><span>;</span>
 
        <span>UPROPERTY</span><span>(</span><span>EditAnywhere</span><span>,</span> <span>BlueprintReadWrite</span><span>)</span>
        <span>FString</span> <span>WeaponsPath</span> <span>=</span> <span>"FirstPersonCPP/Blueprints/Weapons"</span><span>;</span>
 
        <span>UPROPERTY</span><span>(</span><span>EditAnywhere</span><span>,</span> <span>BlueprintReadWrite</span><span>)</span>
        <span>float</span> <span>ShotDelay</span> <span>=</span> <span>0.4f</span><span>;</span>
        <span>UPROPERTY</span><span>(</span><span>EditAnywhere</span><span>,</span> <span>BlueprintReadWrite</span><span>)</span>
        <span>int</span> <span>ScreenshotResolutionX</span> <span>=</span> <span>256</span><span>;</span>
        <span>UPROPERTY</span><span>(</span><span>EditAnywhere</span><span>,</span> <span>BlueprintReadWrite</span><span>)</span>
        <span>int</span> <span>ScreenshotResolutionY</span> <span>=</span> <span>256</span><span>;</span>
 
        <span>int</span> <span>CurrentWeaponIndex</span> <span>=</span> <span>0</span><span>;</span>
<span>};</span></pre>
<p>In the interest of brevity when posting progress here, I'm leaving out a lot of the normal spacing and comments that might normally accompany these things in a professional environment. Hopefully, the more traditional and formal examples in the previous chapters have given some good overall guidelines there, but if you notice these things missing here, it's to save space as we have a lot to cover, not out of bad habit. As usual, when there are new concepts, they will be discussed along with the code here. In this case, there's a new <kbd>UPROPERTY</kbd> tag, <kbd>Transient</kbd>. This tells the engine that these properties are never to be saved with the object: they're used during its lifetime and can be used as any other <kbd>UPROPERTY</kbd> can, but changes to them do not "dirty" the object to require saving, and the contents are never serialized in and out with an instance of the object. A brief note on the properties near the bottom: <kbd>ShotDelay</kbd> is the amount of time we pause between loading a new weapon pickup in-game and taking its screenshot. This is there primarily to allow some frames for the game to spawn the objects and then update them to be in the proper MIP map level of detail. We will be asynchronously loading in all the blueprints for the weapon pickups, but this delay is still needed because even with assets loaded, objects often still come in at their lowest MIP level and if we take a screenshot right then, the quality is at its worst:</p>
<pre><span>void</span> <span>AMasteringIconCamera</span><span>::</span><span>BeginPlay</span><span>()</span>
<span>{</span>
        <span>if</span> <span>(</span><span>bInitialied</span><span>)</span>
        <span>{</span>
                <span>return</span><span>;</span> <span>// BeginPlay will get called multiple times at <br/>                level start</span>
        <span>}</span>
 
        <span>bInitialied</span> <span>=</span> <span>true</span><span>;</span>
 
        <span>CameraComp</span> <span>=</span> <span>GetCameraComponent</span><span>();</span>
 
        <span>UWorld</span><span>*</span> <span>World</span> <span>=</span> <span>GetWorld</span><span>();</span>
        <span>check</span><span>(</span><span>World</span> <span>!=</span> <span>nullptr</span><span>);</span>
        <span>APlayerController</span><span>*</span> <span>Player</span> <span>=</span> <span>World</span><span>-&gt;</span><span>GetFirstPlayerController</span><span>();</span>
 
        <span>Player</span><span>-&gt;</span><span>SetCinematicMode</span><span>(</span><span>true</span><span>,</span> <span>true</span><span>,</span> <span>true</span><span>,</span> <span>true</span><span>,</span> <span>true</span><span>);</span>
 
        <span>Player</span><span>-&gt;</span><span>SetViewTarget</span><span>(</span><span>this</span><span>);</span>
 
        <span>FString</span> <span>contentPath</span> <span>=</span> <span>FString</span><span>(</span><span>"/Game/"</span><span>)</span> <span>+</span> <span>WeaponsPath</span><span>;</span>
 
        <span>static</span> <span>UObjectLibrary</span><span>*</span> <span>ObjectLibrary</span> <span>=</span> <span>nullptr</span><span>;</span>
        <span>ObjectLibrary</span> <span>=</span> <span>UObjectLibrary</span><span>::</span><span>CreateLibrary</span><span>(</span><span>AMasteringWeaponPickup</span><span>::</span><span>StaticClass</span><span>(),</span> <span>false</span><span>,</span> <span>GIsEditor</span><span>);</span>
        <span>ObjectLibrary</span><span>-&gt;</span><span>AddToRoot</span><span>();</span>
        <span>ObjectLibrary</span><span>-&gt;</span><span>bHasBlueprintClasses</span> <span>=</span> <span>true</span><span>;</span>
 
        <span>ObjectLibrary</span><span>-&gt;</span><span>LoadBlueprintAssetDataFromPath</span><span>(</span><span>contentPath</span><span>);</span>
 
        <span>TArray</span><span>&lt;</span><span>FAssetData</span><span>&gt;</span> <span>AssetDatas</span><span>;</span>
        <span>ObjectLibrary</span><span>-&gt;</span><span>GetAssetDataList</span><span>(</span><span>AssetDatas</span><span>);</span>
 
        <span>for</span> <span>(</span><span>auto</span> <span>itr</span> <span>:</span> <span>Asset</span><span>Datas</span><span>)</span>
        <span>{</span>
                <span>FSoftObjectPath</span> <span>assetPath</span><span>(</span><span>itr</span><span>.</span><span>ObjectPath</span><span>.</span><span>ToString</span><span>());</span>
                <span>WeaponBlueprintSoftRefs</span><span>.</span><span>Add</span><span>(</span><span>assetPath</span><span>);</span>
        <span>}</span>
 
        <span>// Here we stream in the assets found that are weapon pick-ups and when done, will call the OnFinished function</span>
        <span>FStreamableManager</span><span>&amp;</span> <span>Streamable</span> <span>=</span> <span>UAssetManager</span><span>::</span><span>GetStreamableManager</span><span>();</span>
        <span>Streamable</span><span>.</span><span>RequestAsyncLoad</span><span>(</span><span>WeaponBlueprintSoftRefs</span><span>,</span> <span>FStreamableDelegate</span><span>::</span><span>CreateUObject</span><span>(</span><span>this</span><span>,</span> <span>&amp;</span><span>AMasteringIconCamera</span><span>::</span><span>OnFinishedLoadingAssets</span><span>));</span>
<span>}</span></pre>
<p>There are a few interesting things to discuss here. The first is commented at the top that <kbd>BeginPlay</kbd> can be, and will be, called multiple times on a single object (generally two), and we only need to or want to do the work here once. So first, we set the player into cinematic mode, shutting down movement and HUD and anything else that's not really needed with our super basic pawn, but a good idea in areas such as this in general. We set this camera as the view target and get our path, which is defaulted to where the weapon, pickup, and projectile blueprints were moved: <kbd>/Game/FirstPersonCPP/Blueprints/Weapons</kbd>. However, this can be edited on an individual icon camera to point to any specific folder as it's an exposed <kbd>UPROPERTY</kbd> (just like the screenshot resolution and delay mentioned earlier). Next, the <kbd>UObjectLibrary</kbd> class is used to mass-find our pickup objects in the path. We quickly iterate the list of them, making soft references to those objects. This is not strictly required, but like a few other topics in this chapter, it's meant to be instructive and start building good habits when you're thinking about how to reference objects as you go. On a PC, often you can simply load all the necessary assets all the time for a given level and only free them when you finish playing. On mobile and other platforms, memory can be at a premium, so it's good to have the tools in hand to load assets in the background, not stopping the game, and then also to be sure they will be freed by garbage collection later when they're no longer needed. Once the list of pickups is made, we send that to the <kbd>StreamableManager</kbd> to batch stream in our blueprints that we need to use. In that request, we add a callback to ourselves using <kbd>FStreamableDelegate</kbd>'s <kbd>CreateUObject</kbd> (this creates a callback tied to a <kbd>UObject</kbd>, in most cases using the <kbd>this</kbd> pointer). When all these blueprints are loaded into memory, it will call <kbd>OnFinishedLoadingAssets</kbd>, which we'll look at next.</p>
<div class="packt_tip">To speed up testing during work like this (where you simply need to open a level, have it run, and exit), you can right-click the Mastering project in the Solution Explorer and add the map name and <kbd>-game</kbd> to your Command Arguments line so it looks like this: <kbd>"$(SolutionDir)$(ProjectName).uproject" IconScreenshotMap -game -skipcompile -debug</kbd>. This <span>tells the DebugGame Editor build to launch directly into the game, but as an Editor build. It will still use uncooked content. If you built DebugGame, you will get an error on startup if you are not also cooking your content.</span></div>
<p>So, once our blueprints are all loaded, we need to spawn one of each of these as actors into the world, take our shot, and then destroy that one and move to the next. We'll do this with a timer and a lambda function (our first, but certainly not last). Look at what we have so far:</p>
<pre><span>void</span> <span>AMasteringIconCamera</span><span>::</span><span>OnFinishedLoadingAssets</span><span>()</span>
<span>{</span>
        <span>UWorld</span><span>*</span> <span>World</span> <span>=</span> <span>GetWorld</span><span>();</span>
 
        <span>for</span> <span>(</span><span>auto</span> <span>itr</span> <span>=</span> <span>WeaponBlueprintSoftRefs</span><span>.</span><span>CreateIterator</span><span>();</span> <span>itr</span><span>;</span> <br/><span>        ++</span><span>itr</span><span>)</span>
        <span>{</span>
                <span>UBlueprint</span> <span>*</span><span>BPObj</span> <span>=</span> <span>CastChecked</span><span>&lt;</span><span>UBlueprint</span><span>&gt;((</span><span>*</span><span>itr</span><span>).</span><span>ResolveObject</span><span>());</span>
                <span>WeaponBlueprints</span><span>.</span><span>Add</span><span>(</span><span>BPObj</span><span>);</span>
        <span>}</span>
 
        <span>SpawnAndPlaceNextActor</span><span>();</span> <span>// this spawns our first pickup and increments CurrentWeaponIndex to 1</span>
 
        <span>static</span> <span>FTimerHandle</span> <span>ScreenShotTimer</span><span>;</span>
        <span>World</span><span>-&gt;</span><span>GetTimerManager</span><span>().</span><span>SetTimer</span><span>(</span><span>ScreenShotTimer</span><span>,</span> <span>[=]</span> <span>{</span>
                        <span>if</span> <span>(</span><span>CurrentWeaponIndex</span> <span>==</span> <span>0</span><span>)</span> <span>// only way we come in at index 0 is if we're done</span>
                        <span>{</span>
                                <span>World</span><span>-&gt;</span><span>GetTimerManager</span><span>().</span><span>ClearTimer</span><span>(</span><span>ScreenShotTimer</span><span>);</span>
                                                                <span>if</span> <span>(</span><span>APlayerController</span><span>*</span> <span>Player</span> <span>=</span> <span>UGameplayStatics</span><span>::</span><span>GetPlayerController</span><span>(</span><span>World</span><span>,</span> <span>0</span><span>))</span>
                                <span>{</span>
                                        <span>Player</span><span>-&gt;</span><span>ConsoleCommand</span><span>(</span><span>TEXT</span><span>(</span><span>"Exit"</span><span>),</span> <span>true</span><span>);</span>
                                        <span>return</span><span>;</span>
                                <span>}</span>
                        <span>}</span>
 
                        <span>TakeShot</span><span>();</span>
                <span>},</span>
                <span>ShotDelay</span><span>,</span> <span>true</span><span>,</span> <span>ShotDelay</span><span>);</span>
<span>}</span></pre>
<p>Here, we first convert our soft references (the <kbd>TArray</kbd> of <kbd>FSoftObjectPath</kbd> items) to hard references (in this case, a simple <kbd>UPROPERTY</kbd> <kbd>TArray</kbd> of <kbd>UBlueprint</kbd> pointers). If you find yourself having trouble with memory leaks or running out of memory, always remember that a <kbd>UPROPERTY</kbd> pointer in UE4 will count as a hard reference to the object it points to, preventing it from being freed until you null out that pointer (or point it at another object), or the object with the pointer is destroyed upon which it is also released. You can always walk up the chain of <kbd>UObject</kbd> <kbd>Outer</kbd> pointers to find out who ultimately owns any other <kbd>UObject</kbd>, but right now, we want to force all these blueprints to stay loaded in memory, hence why we convert the soft references to hard ones. After this, we cue up our first pickup to be shot by calling <kbd>SpawnAndPlaceNextActor</kbd>, which we will get to shortly.</p>
<p><span>For most programmers learning C++ in the last 5 or so years, lambda functions are pretty common. For those learning C++ in earlier years this could be something new, but they're incredibly useful and supported by many areas of UE4. We use one here in a simple timer from the game's timer manager: we set an initial delay to our <kbd>ShotDelay</kbd> member time, as well as the rate the timer will fire at since we set it to looping, and only break this looping when a special condition is hit. <kbd>CurrentWeaponIndex</kbd> being 0 means we have finished and are out of pickups to capture. The way to stop a looping (or any active non-looping) timer is to have the timer manager clear that timer based on the handle you passed when you set the timer. Now, every <kbd>ShotDelay</kbd> interval, we'll call <kbd>TakeShot</kbd>, which also cues up the next shot when it finishes.</span></p>
<div>As the next thing called is that <kbd>TakeShot</kbd> function, let's look at it next:<br/>
<pre><span>void</span> <span>AMasteringIconCamera</span><span>::</span><span>TakeShot</span><span>()</span>
<span>{</span>
        <span>UWorld</span><span>*</span> <span>World</span> <span>=</span> <span>GetWorld</span><span>();</span>
 
        <span>check</span><span>(</span><span>CurrentWeaponPickup</span> <span>!=</span> <span>nullptr</span><span>);</span>
 
        <span>UMeshComponent</span><span>*</span> <span>Mesh</span> <span>=</span> <span>Cast</span><span>&lt;</span><span>UMeshComponent</span><span>&gt;(</span><span>CurrentWeaponPickup</span><span>-&gt;</span><span>GetComponentByClass</span><span>(</span><span>UMeshComponent</span><span>::</span><span>StaticClass</span><span>()));</span>
        <span>check</span><span>(</span><span>Mesh</span> <span>!=</span> <span>nullptr</span><span>);</span>
 
        <span>Mesh</span><span>-&gt;</span><span>bForceMipStreaming</span> <span>=</span> <span>true</span><span>;</span>
 
        <span>Mesh</span><span>-&gt;</span><span>SetRenderCustomDepth</span><span>(</span><span>true</span><span>);</span>
 
        <span>GScreenshotResolutionX</span> <span>=</span> <span>ScreenshotResolutionX</span><span>;</span>
        <span>GScreenshotResolutionY</span> <span>=</span> <span>ScreenshotResolutionY</span><span>;</span>
 
        <span>GetHighResScreenshotConfig</span><span>().</span><span>SetHDRCapture</span><span>(</span><span>true</span><span>);</span>
        <span>GetHighResScreenshotConfig</span><span>().</span><span>bMaskEnabled</span> <span>=</span> <span>true</span><span>;</span>
        <span>World</span><span>-&gt;</span><span>GetGameViewport</span><span>()-&gt;</span><span>Viewport</span><span>-&gt;</span><span>TakeHighResScreenShot</span><span>();</span>
 
        <span>// this timer is here to wait just one frame (hence the tiny time) and then destroy the current actor</span>
        <span>// and spawn the next one: if you destroy the actor the same frame as the screenshot it may not appear</span>
        <span>FTimerHandle</span> <span>SpawnNextTimer</span><span>;</span>
        <span>World</span><span>-&gt;</span><span>GetTimerManager</span><span>().</span><span>SetTimer</span><span>(</span><span>SpawnNextTimer</span><span>,</span> <span>[</span><span>this</span><span>]</span> <span>{</span>
                <span>if</span> <span>(</span><span>CurrentWeaponIndex</span> <span>&gt;=</span> <span>WeaponBlueprints</span><span>.</span><span>Num</span><span>())</span>
                <span>{</span>
                        <span>CurrentWeaponIndex</span> <span>=</span> <span>0</span><span>;</span> <span>// we have finished, this will break our timer loop on its next trigger</span>
                <span>}</span>
                <span>else</span>
                <span>{</span>
                        <span>SpawnAndPlaceNextActor</span><span>();</span>
                <span>}</span>
        <span>},</span>
        <span>0.001f</span><span>,</span> <span>false</span><span>);</span>
<span>}</span></pre></div>
<p>You'll notice in many of these functions there are <kbd>checks</kbd> before simply calling functions on those items, such as the Mesh pointer. Given how automated this functionality is, if content creators were having trouble building proper pickups, you would be alerted anywhere important here, but if this were a problem you'd likely want to handle those kinds of setup mistakes in a way that doesn't crash the editor for non-programmers (people hooked into Visual Studio or the like can always skip passed check assertions with <span class="packt_screen">Set Next Statement</span> or the like). But again, for brevity, and as a minimal safeguard to alert of a problem before a simple crash, these <kbd>checks</kbd> are at least here. So, getting that Mesh, we then set it up for a proper screenshot, make sure our game's global screenshot resolutions are set to ours, set up our screenshot's properties, and take one using the game viewport. It's by far the easiest one to access, and this is why we take ours from the player pawn's perspective here. We then set an intentionally short timer so the next frame we move to the next actor, or signal to the previous timer that we're done via resetting the weapon index. As noted in the comment, if you destroy an actor (as <kbd>SpawnAndPlaceNextActor</kbd> will) it is likely that it then will not show up at the time the screenshot is resolved, but if you wait one frame for the shot to finish, there's no problems.</p>
<p>So you've seen it a couple of times now; let's look at <kbd>SpawnAndPlaceNextActor</kbd>:</p>
<pre><span>void</span> <span>AMasteringIconCamera</span><span>::</span><span>SpawnAndPlaceNextActor</span><span>()</span>
<span>{</span>
        <span>if</span> <span>(</span><span>CurrentWeaponPickup</span> <span>!=</span> <span>nullptr</span><span>)</span>
                <span>CurrentWeaponPickup</span><span>-&gt;</span><span>Destroy</span><span>();</span>
 
        <span>CurrentWeaponBlueprint</span> <span>=</span> <span>WeaponBlueprints</span><span>[</span><span>CurrentWeaponIndex</span><span>]</span><span>;</span>
        <span>check</span><span>(</span><span>CurrentWeaponBlueprint</span> <span>!=</span> <span>nullptr</span><span>);</span> <span>// anything not a blueprint should never find its way into our list</span>
 
        <span>UWorld</span><span>*</span> <span>World</span> <span>=</span> <span>GetWorld</span><span>();</span>
 
        <span>FRotator</span> <span>Rot</span><span>(</span><span>0.0f</span><span>);</span>
        <span>FVector</span> <span>Trans</span><span>(</span><span>0.0f</span><span>);</span>
 
        <span>FTransform</span> <span>Transform</span><span>(</span><span>Rot</span><span>,</span> <span>Trans</span><span>);</span>
        <span>FActorSpawnParameters</span> <span>ActorSpawnParams</span><span>;</span>
        <span>ActorSpawnParams</span><span>.</span><span>SpawnCollisionHandlingOverride</span> <span>=</span> <span>ESpawnActorCollisionHandlingMethod</span><span>::</span><span>AlwaysSpawn</span><span>;</span>
        <span>CurrentWeaponPickup</span> <span>=</span> <span>World</span><span>-&gt;</span><span>SpawnActor</span><span>&lt;</span><span>AMasteringWeaponPickup</span><span>&gt;(</span><span>CurrentWeaponBlueprint</span><span>-&gt;</span><span>GeneratedClass</span><span>,</span> <span>Transform</span><span>,</span> <span>ActorSpawnParams</span><span>);</span>
        <span>CurrentWeaponPickup</span><span>-&gt;</span><span>RotationSpeed</span> <span>=</span> <span>0.0f</span><span>;</span> <span>// the ones we use for screenshots we don't want spinning!</span>
        <span>check</span><span>(</span><span>CurrentWeaponPickup</span> <span>!=</span> <span>nullptr</span><span>);</span>
 
        <span>FVector</span> <span>Pos</span> <span>=</span> <span>ComputeActorLocation</span><span>();</span>
        <span>CurrentWeaponPickup</span><span>-&gt;</span><span>SetActorLocation</span><span>(</span><span>Pos</span><span>);</span>
 
        <span>CurrentWeaponIndex</span><span>++;</span>
<span>}</span></pre>
<p>Hopefully, this function is much more straightforward and does not require much attention. We destroy any current existing actor, get the one our index is set to as a blueprint, spawn one of those in the world with the blueprint's <kbd>GeneratedClass</kbd>, stop it from spinning, fix its location, and increment our index.</p>
<p>So, how do we fix up that location? By finally using a little bit of basic 3D math:</p>
<pre><span>FVector</span> <span>AMasteringIconCamera</span><span>::</span><span>ComputeActorLocation</span><span>()</span>
<span>{</span>
        <span>check</span><span>(</span><span>CurrentWeaponPickup</span> <span>!=</span> <span>nullptr</span><span>);</span>
        <span>UMeshComponent</span><span>*</span> <span>Mesh</span> <span>=</span> <span>Cast</span><span>&lt;</span><span>UMeshComponent</span><span>&gt;(</span><span>CurrentWeaponPickup</span><span>-&gt;</span><span>GetComponentByClass</span><span>(</span><span>UMeshComponent</span><span>::</span><span>StaticClass</span><span>()));</span>
 
        <span>FVector</span> <span>InPos</span><span>;</span>
        <span>FVector</span> <span>BoxExtent</span><span>;</span>
        <span>CurrentWeaponPickup</span><span>-&gt;</span><span>GetActorBounds</span><span>(</span><span>false</span><span>,</span> <span>InPos</span><span>,</span> <span>BoxExtent</span><span>);</span>
 
        <span>// uncomment these to view the actor bounding generated for our pick-ups</span>
        <span>/*FVector CurrentPosition = CurrentWeaponPickup-&gt;GetActorLocation();</span>
<span>  FColor fcRandom(FMath::RandRange(64, 255), FMath::RandRange(64, 255), FMath::RandRange(64, 255));</span>
<span>  DrawDebugLine(World, CurrentPosition, CurrentPosition + InPos, fcRandom, false, 20.0f);</span>
<span>  DrawDebugBox(World, CurrentPosition + InPos, 0.5f * BoxExtent, FQuat(ForceInitToZero), fcRandom, false, 20.0f);*/</span>
 
        <span>// uncomment these to view the mesh bounding imported with the <br/>assets</span>
        <span>/*FBoxSphereBounds bsMesh = Mesh-&gt;Bounds;</span>
<span>  DrawDebugLine(World, CurrentPosition, bsMesh.Origin, fcRandom, false, 20.0f);</span>
<span>  DrawDebugBox(World, bsMesh.Origin, 0.5f * bsMesh.BoxExtent, FQuat(ForceInitToZero), fcRandom, false, 20.0f);*/</span>
 
        <span>const</span> <span>float</span> <span>fX</span> <span>=</span> <span>BoxExtent</span><span>.</span><span>X</span><span>;</span>
        <span>const</span> <span>float</span> <span>fY</span> <span>=</span> <span>BoxExtent</span><span>.</span><span>Y</span><span>;</span>
        <span>const</span> <span>float</span> <span>fZ</span> <span>=</span> <span>BoxExtent</span><span>.</span><span>Z</span><span>;</span>
 
        <span>if</span> <span>(</span><span>fX</span> <span>&gt;</span> <span>fY</span><span>)</span>
        <span>{</span>
                <span>FRotator</span> <span>YawRot</span><span>(</span><span>0.0f</span><span>,</span> <span>90.0f</span><span>,</span> <span>0.0f</span><span>);</span>
                <span>CurrentWeaponPickup</span><span>-&gt;</span><span>SetActorRotation</span><span>(</span><span>YawRot</span><span>);</span>
        <span>}</span>
 
        <span>const</span> <span>float</span> <span>fLongestBoxSide</span> <span>=</span> <span>FMath</span><span>::</span><span>Max</span><span>(</span><span>fX</span><span>,</span> <span>FMath</span><span>::</span><span>Max</span><span>(</span><span>fY</span><span>,</span> <br/><span>        fZ</span><span>));</span>
 
        <span>// FOV is the whole frustum FOV, to make a right triangle down its middle, we use half this angle</span>
        <span>const</span> <span>float</span> <span>FOVhalf</span> <span>=</span> <span>0.5f</span> <span>*</span> <span>CameraComp</span><span>-&gt;</span><span>FieldOfView</span><span>;</span>
        <span>const</span> <span>float</span> <span>FOVradians</span> <span>=</span> <span>FOVhalf</span> <span>*</span> <span>PI</span> <span>/</span> <span>180.0f</span><span>;</span>
 
        <span>const</span> <span>float</span> <span>FOVtan</span> <span>=</span> <span>FMath</span><span>::</span><span>Tan</span><span>(</span><span>FOVradians</span><span>);</span>
 
        <span>float</span> <span>XDistance</span> <span>=</span> <span>fLongestBoxSide</span> <span>/</span> <span>FOVtan</span><span>;</span>
 
        <span>FVector</span> <span>Positioning</span><span>(</span><span>XDistance</span><span>,</span> <span>0.0f</span><span>,</span> <span>0.0f</span><span>);</span>
 
        <span>return</span> <span>CurrentWeaponPickup</span><span>-&gt;</span><span>GetActorLocation</span><span>()</span> <span>+</span> <span>Positioning</span> <span>-</span> <span>InPos</span><span>;</span>
<span>}</span></pre>
<div class="packt_infobox">If curious about the commented out bounding box/offset drawing chunks, feel free to enable one or both and see what they show you. The reason I used them and left them in was because <kbd>SkeletalMeshActors</kbd> primarily get their bounding information at the time the assets are imported from whatever external tool they were built in (3D Studio MAX, Maya, and so on) set by the artists. As I found some of the Infinity Blade weapons' bounding a bit odd, I used this to make sure it was indeed how the assets were made, and there was not a math or other programming error.</div>
<p>In this function, we get the bounding extents of the actor, find its longest dimension (X, Y, or Z) and push it back until that longest side is just at the edge of our view frustum. If it turns out a weapon is more wide than it is long, we rotate the larger side to face our camera too. Figuring out how far away in X to move our actor to best fill/fit the screen before the shot is then just a bit of simple trigonometry. We can get the field of view of the camera frustum, and if we then consider a top-down sort of view of that frustum split down the middle as two right triangles, we know to get that longest side to fit we then use the tangent of half that frustum angle for one of the triangles. By definition, that tangent being the opposite side's length over the adjacent side's length, we divide the long side of our bounding to know how far to push the object out now. We also subtract out the relative position offset (InPos) of the bounding box itself and should have a reasonably centered location to return.</p>
<p>Running our icon map now should generate a screenshot in the <span class="packt_screen">Saved</span> folder of our project for each pickup. This is a good checkpoint for GitHub, and we'll use those screenshots to finally make some UI elements next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using UMG to display inventory icons on screen</h1>
                </header>
            
            <article>
                
<p>After the previous section's significant amount of code, we'll be back working mostly in blueprints and the editor in this section. One quick aside: when moving assets in the editor, it will leave behind a redirector <kbd>.uasset</kbd> file of the one you moved. All this does is point anything that looks for the old one to the new one. There's a Fix-Up Redirectors commandlet you can run, which searches your content folder for all of these and any objects referencing them, points them properly to the new location, and deletes the redirector. This can also be done manually in the content browser by finding the <span class="packt_screen">Other Filters</span> <span><span>|</span></span><span class="packt_screen"> Show Redirectors </span><span>filter setting</span>, and you can right-click on them in the content browser and select <span class="packt_screen">Fix Up</span> to get rid of them. I did that at this point to keep things tidy.</p>
<p>So now under <span class="packt_screen">FirstPersonCPP</span> I next make a <span class="packt_screen">Textures</span> folder and click the <span class="packt_screen">Import</span> button in the content browser: browsing to where the screenshots were added (<kbd>/Saved/Screenshots/Windows</kbd>). Select the generated <kbd>.png</kbd> files here (five in my case) and let them all import as textures. It's good to have a naming convention for searching blueprints as projects get larger, so for all of these textures I simply name them <kbd>T_</kbd>(weapon name). Of course, with some effort in UE4's C++ using the <kbd>FileManager</kbd> we could cleverly automate renaming the <kbd>.png</kbd> files rather easily, but importing them into game content as textures is a bit more involved—bulk selecting them here and manually renaming is sufficient for us as we get on to the task of drawing them in an inventory UI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Synchronizing your inventory and HUD</h1>
                </header>
            
            <article>
                
<p>Moving to actually draw our icons and cycle them is the first portion of this book where not all steps of implementation will be fully shown. All of the work as always is available on GitHub, and it is recommended to go look at each change in this <kbd>Chapter 4</kbd> branch submission, but for discussion purposes, the focus will be on new concepts going forward and decision making. This is, after all, a Mastering book, so expect the pace and complexity of work to pick up. First, a bit of housekeeping, as this complexity does ramp up: as a project moves into a more mature state, the sheer number of source files tends to increase and it's best early on to start managing these into logical directories. There are really two main schemes for how you group things in your project hierarchy: by function or by system. Functionally grouping source files is along the lines of (in our current reorganization) things such as all UI widget classes, with maybe subfolders for complex specialized types. Grouping by system would be (as I've done here) more like all things related to inventory. While these may seem like trivial decisions, or it may feel OK with modern IDEs to simply leave every class in one flat hierarchy, project size and developer team size should drive your decisions here. The important part is to make architectural decisions like this early and then stick to them throughout a project for the team's consistency.</p>
<p>OK, on to the fun stuff! The main new class we need to create in C++ is <kbd>UUserWidget</kbd>, like so:</p>
<pre><span>UCLASS</span><span>()</span>
<span>class</span> <span>MASTERING_API</span> <span>UMasteringInventoryDisplay</span> <span>:</span> <span>public</span> <span>UUserWidget</span>
<span>{</span>
        <span>GENERATED_BODY</span><span>()</span>
        
<span>public</span><span>:</span>
        <span>virtual</span> <span>void</span> <span>Init</span><span>(</span><span>class</span> <span>UMasteringInventory</span><span>*</span> <span>Inventory</span><span>);</span>
 
        <span>UFUNCTION</span><span>(</span><span>BlueprintImplementableEvent</span><span>,</span> <span>Category</span> <span>=</span> <span>Inventory</span><span>)</span>
        <span>void</span> <span>WeaponSelected</span><span>(</span><span>FWeaponProperties</span> <span>Weapon</span><span>);</span>
 
        <span>UFUNCTION</span><span>(</span><span>BlueprintImplementableEvent</span><span>,</span> <span>Category</span> <span>=</span> <span>Inventory</span><span>)</span>
        <span>void</span> <span>WeaponAdded</span><span>(</span><span>FWeaponProperties</span> <span>Weapon</span><span>);</span>
 
        <span>UFUNCTION</span><span>(</span><span>BlueprintImplementableEvent</span><span>,</span> <span>Category</span> <span>=</span> <span>Inventory</span><span>)</span>
        <span>void</span> <span>WeaponRemoved</span><span>(</span><span>FWeaponProperties</span> <span>Weapon</span><span>);</span>
<span>};</span></pre>
<p>Now, as they're new to this book, note the keyword for <kbd>BlueprintImplementableEvent</kbd>: these functions are actually not implemented in C++, only declared in the header. Their actual functionality comes in the blueprint events they generate. We'll get to those in a bit, but let's now look at how they are used and then we'll trace that to how they are triggered:</p>
<pre><span>void</span> <span>UMasteringInventoryDisplay</span><span>::</span><span>Init</span><span>(</span><span>class</span> <span>UMasteringInventory</span><span>*</span> <span>Inventory</span><span>)</span>
<span>{</span>
        <span>Inventory</span><span>-&gt;</span><span>OnSelectedWeaponChanged</span><span>.</span><span>AddUObject</span><span>(</span><span>this</span><span>,</span> <span>&amp;</span><span>UMasteringInventoryDisplay</span><span>::</span><span>WeaponSelected</span><span>);</span>
        <span>Inventory</span><span>-&gt;</span><span>OnWeaponAdded</span><span>.</span><span>AddUObject</span><span>(</span><span>this</span><span>,</span> <span>&amp;</span><span>UMasteringInventoryDisplay</span><span>::</span><span>WeaponAdded</span><span>);</span>
        <span>Inventory</span><span>-&gt;</span><span>OnWeaponRemoved</span><span>.</span><span>AddUObject</span><span>(</span><span>this</span><span>,</span> <span>&amp;</span><span>UMasteringInventoryDisplay</span><span>::</span><span>WeaponRemoved</span><span>);</span>
<span>}</span></pre>
<p>What's happening here is we are hooking into an event in the <kbd>Inventory</kbd> class that will broadcast to all its listeners (our bindings) when events happen, passing weapon properties into our blueprint implementation. So, how do we do this? First we add these events to our inventory class:</p>
<pre><span>DECLARE_EVENT_OneParam</span><span>(</span><span>UMasteringInventory</span><span>,</span> <span>FSelectedWeaponChanged</span><span>,</span> <span>FWeaponProperties</span><span>);</span>
<span>FSelectedWeaponChanged</span> <span>OnSelectedWeaponChanged</span><span>;</span>
 
<span>DECLARE_EVENT_OneParam</span><span>(</span><span>UMasteringInventory</span><span>,</span> <span>FWeaponAdded</span><span>,</span> <span>FWeaponProperties</span><span>);</span>
<span>FSelectedWeaponChanged</span> <span>OnWeaponAdded</span><span>;</span>
 
<span>DECLARE_EVENT_OneParam</span><span>(</span><span>UMasteringInventory</span><span>,</span> <span>FWeaponRemoved</span><span>,</span> <span>FWeaponProperties</span><span>);</span>
<span>FSelectedWeaponChanged</span> <span>OnWeaponRemoved</span><span>;</span></pre>
<p>And in the <kbd>.cpp</kbd>, after a good amount of refactoring (and a couple of bug fixes I'm not too ashamed to admit), we have lines like these:</p>
<pre><span>void</span> <span>UMasteringInventory</span><span>::</span><span>SelectWeapon</span><span>(</span><span>FWeaponProperties</span> <span>Weapon</span><span>)</span>
<span>{</span>
        <span>OnSelectedWeaponChanged</span><span>.</span><span>Broadcast</span><span>(</span><span>Weapon</span><span>);</span>
 
        <span>MyOwner</span><span>-&gt;</span><span>EquipWeapon</span><span>(</span><span>Weapon</span><span>.</span><span>WeaponClass</span><span>);</span>
        <span>CurrentWeapon</span> <span>=</span> <span>Weapon</span><span>.</span><span>WeaponClass</span><span>;</span>
<span>}</span></pre>
<p>Similarly added for, well, adding a weapon, and the newly implemented removal of weapons as well (this is done when ammo runs out).</p>
<div class="packt_infobox">For a game like this, it's important to have a design in mind for how to show the player their inventory and know whether things such as ammo pickups without being a weapon pickup are possible, of course. In this case, if you're out of ammo, you might as well not have the weapon at all, so we remove it from the display. You could, of course, gray it out or the like, but again, make sure at all times your design drives your implementation decisions.</div>
<p>So we're now communicating to our inventory display object key events when the inventory is changed in C++. Let's take a moment than to see what that looks like on the blueprint side of this concept:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b12ef8d5-0d03-4aa8-98c7-5f393b3cda46.png"/></p>
<p>There are several things to note here, but it will be kept brief: notice the functions and variables on the left. These are blueprint-only things added with the + button to make all of this work. This is where a bit of mystery will remain unless you go to GitHub and look at all of the implementations. Hopefully, <span>the functionality of these functions and variables is clear </span>from the naming. As inventory items are added, widgets are added to a <span class="packt_screen">ScrollBox</span> widget. The layout will follow, but the important concepts are that we'll track weapon classes and icon widgets in parallel arrays so we can map them for selection and removal. That function is demonstrative of why all the functions won't be shown here directly:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/048979b9-3e71-4dc7-a0f9-b4e9aba2911c.png"/></p>
<p class="mce-root"/>
<p>This is not even a particularly complex function, but it's already a bit tight to get into one shot. Notice at the print-string node there's a redirector node. They can be added by dragging from an execution pin (white ones) at any time, and then dragged around to help sometimes with the spaghetti that visual scripting can create. Hopefully, also you're familiar with input and output variables (seen in the bottom left), blueprint functions can be extremely useful for quick implementation, and are all but required when working with UMG widgets. Some UI/UX designers may be comfortable implementing their own functionality, but mostly those roles will be more involved with the <span class="packt_screen">Designer</span> tab, in the top-right. Let's quickly look at that for this scrolling inventory widget that we'll draw, currently, at the top of the screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0d86defb-fe30-4e5a-8456-336718fbe902.png"/></div>
<p>Of note in the top-right is that the <span class="packt_screen">ScrollBox</span> widget, in this case, is checked to be a variable (you can see it referenced in blueprint scripting) and the slightly odd arrangement of <span class="packt_screen">HorizontalBox</span> widgets on the left, which basically sandwich our <span class="packt_screen">ScrollBox</span> into a <span class="packt_screen">Canvas</span> widget in the middle that is the size we want. There are a <strong>lot</strong> of widget settings to get all this correct, including an <span class="packt_screen">Image-</span>based widget named <span class="packt_screen">InventoryItem</span> that can be reviewed in the GitHub project. Looking for what was modified to make things work as they do is always just a search for those little yellow looping arrows (which, as you know if clicked, revert a value to its default) indicating what has been modified.</p>
<p>Now, to make all of this work also requires adding a blueprint for our MasteringGameMode and MasteringHUD so that the former can set the latter as the HUD to use, and World Settings in the main level editing window can be set to use that mode:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3ea8f568-dd31-4371-ade8-afac646e4081.png"/></div>
<p>Notice that I un-hardcoded the crosshair texture, but exposing things like this to blueprint means adding extra code to handle if they are not set up properly.</p>
<p>So the net result of this is that we can now scroll through our weapons, see which is selected (as it is the only full-alpha object in our list), and as we cycle what's in-hand, it cycles our <span class="packt_screen">ScrollBox</span> full of icons, removing any that run out of ammo!</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a54a386a-82cb-4a67-8230-a00dbbb95735.png" style="width:18.08em;height:15.25em;"/></div>
<p class="mce-root"/>
<p>If you find yourself getting errors trying to compile your widgets, be sure to note the change to <kbd>Mastering.Build.cs</kbd>. This is where you can include source modules your game may find itself needing (and to this point, we did not need UMG):</p>
<pre>+ PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay", "UMG" });</pre>
<p>One last note (which will be well known to experienced GitHub users): I submitted my changes, <em>then</em> moved my files to reorganize them. GitHub sees moves as a deletion of the old file and addition of a new file, so you would lose the change history, but that can be seen in the two submissions that go along with this effort.</p>
<p>So now our inventory is synced up and good to go!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using UMG and game save slots</h1>
                </header>
            
            <article>
                
<p>UE 4.19+ gives us a nice class to actually save and load a chunk of data for objects we want to save. In our case, this will be every actor that can change its state or position, which right now is not a lot. But as a game grows, if in-scene saves are desired, it is incredibly important to start this process as early as possible too. Our biggest challenge will be the one class we implemented in <a href="267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml" target="_blank">Chapter 3</a>, <em>Blueprint Review and When to Use BP Scripting</em>, where almost its entire functionality was implemented on the blueprint side. Creating a solution that works with both native C++ classes and blueprints will be our all-inclusive goal for this section. The UMG UI will be a bit lighter than the last section of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a widget for save slots</h1>
                </header>
            
            <article>
                
<p>While the bulk of the work in this section will be actually implementing the loading and saving of various actor classes, we do of course need an interface to display this to players, and that is what we will do first. Our next step then is a UMG widget that we can bring up with buttons to facilitate this. So, back in the editor, we need a widget that has some touch-points back to C++ code so we can do the bulk of the work. To simplify this, we'll make a new C++ class based on <kbd>UUserWidget</kbd>, call it <span class="packt_screen">MainMenuWidget</span>, and add the class to the UI folder. Then, like before, we make a new blueprint asset and <span>we will add 4 buttons </span>to that in its design, like so:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/48fb0584-c9be-45fd-be2e-4e9b648f0f77.png"/></div>
<p>Notice we set its initial visibility to <span class="packt_screen">Hidden</span>, and at the <span class="packt_screen">ButtonBox</span> level, the anchor is set to center screen with X and Y alignments of 0.5. As always, feel free to reference the version in GitHub for all UMG/blueprint issues not specifically discussed here.</p>
<p>Next, we bind the click events for each of those buttons. Click each button, and at <span>the bottom of </span>its <span class="packt_screen">Details</span> tab are the events for input with a big green + button. Click that for each button's <span class="packt_screen">OnClicked</span> event and you'll be taken to the blueprint graph at that event where it's added. We add these functions to the widget class:</p>
<pre><span>UCLASS</span><span>()</span>
<span>class</span> <span>MASTERING_API</span> <span>UMainMenuWidget</span> <span>:</span> <span>public</span> <span>UUserWidget</span>
<span>{</span>
        <span>GENERATED_BODY</span><span>()</span>
        
<span>public</span><span>:</span>
        <span>UFUNCTION</span><span>(</span><span>BlueprintCallable</span><span>)</span>
        <span>void</span> <span>LoadGame</span><span>(</span><span>FName</span> <span>SaveFile</span><span>);</span>
 
        <span>UFUNCTION</span><span>(</span><span>BlueprintCallable</span><span>)</span>
        <span>void</span> <span>SaveGame</span><span>();</span>
 
        <span>UFUNCTION</span><span>(</span><span>BlueprintCallable</span><span>)</span>
        <span>void</span> <span>Open</span><span>();</span>
 
        <span>UFUNCTION</span><span>(</span><span>BlueprintCallable</span><span>)</span>
        <span>void</span> <span>Close</span><span>();</span>
<span>};</span></pre>
<p>Wire the save event to the <kbd>SaveGame</kbd> function, and wire the load event to the <kbd>LoadGame</kbd> function as well, of course. <kbd>Open</kbd> is called by an input: we need to bind one in player settings as we have done in the past. I set mine to <em>F10</em> as this is common in several games, but of course it can be any key, touch, or gesture desired. In <kbd>MasteringCharacter</kbd>, I bind this input to a simple pass-through function that gets the HUD like so and calls a function with the same name on that HUD:</p>
<pre><span>AMasteringHUD</span><span>*</span> <span>HUD</span> <span>=</span> <span>Cast</span><span>&lt;</span><span>AMasteringHUD</span><span>&gt;(</span><span>CastChecked</span><span>&lt;</span><span>APlayerController</span><span>&gt;(</span><span>GetController</span><span>())-&gt;</span><span>GetHUD</span><span>());<br/><br/></span><span>void</span> <span>AMasteringHUD</span><span>::</span><span>ToggleMainMenu</span><span>()</span>
<span>{</span>
        <span>if</span> <span>(</span><span>MainMenu</span> <span>!=</span> <span>nullptr</span><span>)</span>
        <span>{</span>
                <span>if</span> <span>(</span><span>MainMenu</span><span>-&gt;</span><span>GetVisibility</span><span>()</span> <span>==</span> <span>ESlateVisibility</span><span>::</span><span>Visible</span><span>)</span>
                        <span>MainMenu</span><span>-&gt;</span><span>Close</span><span>();</span>
                <span>else</span>
                        <span>MainMenu</span><span>-&gt;</span><span>Open</span><span>();</span>
        <span>}</span>
<span>}</span></pre>
<p>Back in the widget class, the <kbd>Open</kbd> and <kbd>Close</kbd> functions are worth looking at, but only open is listed here as close is essentially the same thing in reverse, setting the input mode to <kbd>FInputModeGameOnly</kbd>:</p>
<pre><span>void</span> <span>UMainMenuWidget</span><span>::</span><span>Open</span><span>()</span>
<span>{</span>
        <span>checkSlow</span><span>(</span><span>GetVisibility</span><span>()</span> <span>==</span> <span>ESlateVisibility</span><span>::</span><span>Hidden</span><span>);</span> <span>// only want to open from closed</span>
        <span>SetVisibility</span><span>(</span><span>ESlateVisibility</span><span>::</span><span>Visible</span><span>);</span>
 
        <span>UWorld</span><span>*</span> <span>World</span> <span>=</span> <span>GetWorld</span><span>();</span>
        <span>if</span> <span>(</span><span>World</span> <span>!=</span> <span>nullptr</span><span>)</span>
        <span>{</span>
                <span>APlayerController</span><span>*</span> <span>playerController</span> <span>=</span> <span>World</span><span>-&gt;</span><span>GetFirstPlayerController</span><span>();</span>
                <span>if</span> <span>(</span><span>playerController</span><span>)</span>
                <span>{</span>
                        <span>playerController</span><span>-&gt;</span><span>bShowMouseCursor</span> <span>=</span> <span>true</span><span>;</span>
                        <span>FInputModeUIOnly</span> <span>InputMode</span><span>;</span>
                        <span>playerController</span><span>-&gt;</span><span>SetInputMode</span><span>(</span><span>InputMode</span><span>);</span>
                        <span>UGameplayStatics</span><span>::</span><span>SetGamePaused</span><span>(</span><span>this</span><span>,</span> <span>true</span><span>);</span>
                <span>}</span>
        <span>}</span>
<span>}</span></pre>
<p>Now with <em>F10</em>, while playing, our main menu comes up, and when the <span class="packt_screen">Return to Game</span> button is clicked, its event just calls close now on the widget, which unpauses the game and returns mouse control to our normal player input. The last special event, the button labeled <span class="packt_screen">Exit Game</span>, has a simple blueprint node call to quit playing (and exit standalone), utilizing the <span class="packt_screen">Execute Console Command </span>node, with the command <kbd>exit</kbd>.</p>
<div class="packt_infobox">Later in the project, this is changed to a <span class="packt_screen">Quit Game</span> node as this works when console commands may be unavailable (release builds, certain platforms, and so on). The <span class="packt_screen">Quit Game</span> node is also nice because on mobile platforms it can simply send your app to the background instead of fully ending its execution. Keep in mind that iOS and Android can effectively end the execution of an app that is in the background if the OS decides it needs its resources; but again, at least the <span class="packt_screen">Quit Game</span> node works across platforms and allows you the choice to try just going to the background.</div>
<p>That's it for the menu side at the moment. Now we need to actually save our game, finally!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a save game file</h1>
                </header>
            
            <article>
                
<p><span>As noted at the top of this section, our actual game and the state of all our dynamic actors is done in three major steps:</span></p>
<ol>
<li>Add an interface to all actors that need to save. This involves a few changes to our moving platform, which we'll try to keep straightforward.</li>
<li>Serialize all our actors' desired variables to an <kbd>FArchive</kbd> by tagging our <kbd>UPROPERTIES</kbd>.</li>
<li>Write this to a file we can then serialize everything back out from<span>.</span></li>
</ol>
<p>For very simple saving (such as player stats and the current level), be sure to check out the <kbd>USaveGame</kbd> document link in the <em>Further reading</em> section at the end of the chapter. Now, on to our relatively complex version.</p>
<p>First we need an interface that we'll add to all of our actors that we care about saving, this is the first time we need to make a C++ class outside the editor.</p>
<div class="packt_tip">When making new C++ from files, it's often just easiest to right-click the tabs at the top of Visual Studio, open Containing Folder, copy paste a <kbd>.h</kbd> and <kbd>.cpp</kbd> file up one folder, rename them as needed, copy them back down to the proper folder, then generate project files by right-clicking the <kbd>.uproject</kbd> or using the batch file style mentioned in <a href="dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml" target="_blank">Chapter 1</a>, <em>Making a C++ Project for a First-Person Shooter.</em> Of course, the body of the files needs to be replaced.</div>
<div>The header of the <kbd>.h</kbd> should look like this:</div>
<div>
<pre><span>// Fill out your copyright notice in the Description page of Project Settings.</span>
 
<span>#pragma</span> <span>once</span>
 
<span>#include</span> <span>"CoreMinimal.h"</span>
<span>#include</span> <span>"Serialization/ObjectAndNameAsStringProxyArchive.h"</span>
<span>#include</span> <span>"Inventory/MasteringInventory.h"</span>
<span>#include</span> <span>"SavedActorInterface.generated.h"</span>
 
<span>/**</span>
<span> * </span>
<span> */</span>
<span>USTRUCT</span><span>()</span>
<span>struct</span> <span>FActorSavedData</span>
<span>{</span>
        <span>GENERATED_USTRUCT_BODY</span><span>()</span>
 
        <span>FString</span> <span>MyClass</span><span>;</span>
        <span>FTransform</span> <span>MyTransform</span><span>;</span>
        <span>FVector</span> <span>MyVelocity</span><span>;</span>
        <span>FName</span> <span>MyName</span><span>;</span>
        <span>TArray</span><span>&lt;</span><span>uint8</span><span>&gt;</span> <span>MyData</span><span>;</span>
 
        <span>friend</span> <span>FArchive</span><span>&amp;</span> <span>operator</span><span>&lt;&lt;</span><span>(</span><span>FArchive</span><span>&amp;</span> <span>Ar</span><span>,</span> <span>FActorSavedData</span><span>&amp;</span> <span>SavedData</span><span>)</span>
        <span>{</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>SavedData</span><span>.</span><span>MyClass</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>SavedData</span><span>.</span><span>MyTransform</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>SavedData</span><span>.</span><span>MyVelocity</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>SavedData</span><span>.</span><span>MyName</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>SavedData</span><span>.</span><span>MyData</span><span>;</span>
                <span>return</span> <span>Ar</span><span>;</span>
        <span>}</span>
<span>};</span>
 
<span>USTRUCT</span><span>()</span>
<span>struct</span> <span>FInventoryItemData</span>
<span>{</span>
        <span>GENERATED_USTRUCT_BODY</span><span>()</span>
 
        <span>FString</span> <span>WeaponClass</span><span>;</span>
        <span>int</span> <span>WeaponPower</span><span>;</span>
        <span>int</span> <span>Ammo</span><span>;</span>
        <span>FString</span> <span>TextureClass</span><span>;</span>
 
        <span>friend</span> <span>FArchive</span><span>&amp;</span> <span>operator</span><span>&lt;&lt;</span><span>(</span><span>FArchive</span><span>&amp;</span> <span>Ar</span><span>,</span> <span>FInventoryItemData</span><span>&amp;</span> <span>InvItemData</span><span>)</span>
        <span>{</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>InvItemData</span><span>.</span><span>WeaponClass</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>InvItemData</span><span>.</span><span>WeaponPower</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>InvItemData</span><span>.</span><span>Ammo</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>InvItemData</span><span>.</span><span>TextureClass</span><span>;</span>
                <span>return</span> <span>Ar</span><span>;</span>
        <span>}</span>
<span>};</span>
 
<span>USTRUCT</span><span>()</span>
<span>struct</span> <span>FInventorySaveData</span>
<span>{</span>
        <span>GENERATED_USTRUCT_BODY</span><span>()</span>
 
        <span>FString</span> <span>CurrentWeapon</span><span>;</span>
        <span>int</span> <span>CurrentWeaponPower</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
        <span>TArray</span><span>&lt;</span><span>FInventoryItemData</span><span>&gt;</span> <span>WeaponsArray</span><span>;</span>
 
        <span>friend</span> <span>FArchive</span><span>&amp;</span> <span>operator</span><span>&lt;&lt;</span><span>(</span><span>FArchive</span><span>&amp;</span> <span>Ar</span><span>,</span> <span>FInventorySaveData</span><span>&amp;</span> <span>InvData</span><span>)</span>
        <span>{</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>InvData</span><span>.</span><span>CurrentWeapon</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>InvData</span><span>.</span><span>CurrentWeaponPower</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>InvData</span><span>.</span><span>WeaponsArray</span><span>;</span>
                <span>return</span> <span>Ar</span><span>;</span>
        <span>}</span>
<span>};</span>
 
<span>USTRUCT</span><span>()</span>
<span>struct</span> <span>FGameSavedData</span>
<span>{</span>
        <span>GENERATED_USTRUCT_BODY</span><span>()</span>
 
        <span>FDateTime</span> <span>Timestamp</span><span>;</span>
        <span>FName</span> <span>MapName</span><span>;</span>
        <span>FInventorySaveData</span> <span>InventoryData</span><span>;</span>
        <span>TArray</span><span>&lt;</span><span>FActorSavedData</span><span>&gt;</span> <span>SavedActors</span><span>;</span>
 
        <span>friend</span> <span>FArchive</span><span>&amp;</span> <span>operator</span><span>&lt;&lt;</span><span>(</span><span>FArchive</span><span>&amp;</span> <span>Ar</span><span>,</span> <span>FGameSavedData</span><span>&amp;</span> <span>GameData</span><span>)</span>
        <span>{</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>GameData</span><span>.</span><span>MapName</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>GameData</span><span>.</span><span>Timestamp</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>GameData</span><span>.</span><span>InventoryData</span><span>;</span>
                <span>Ar</span> <span>&lt;&lt;</span> <span>GameData</span><span>.</span><span>SavedActors</span><span>;</span>
                <span>return</span> <span>Ar</span><span>;</span>
        <span>}</span>
<span>};</span>
 
<span>struct</span> <span>FSaveGameArchive</span> <span>:</span> <span>public</span> <span>FObjectAndNameAsStringProxyArchive</span>
<span>{</span>
        <span>FSaveGameArchive</span><span>(</span><span>FArchive</span><span>&amp;</span> <span>InInnerArchive</span><span>)</span>
                <span>:</span> <span>FObjectAndNameAsStringProxyArchive</span><span>(</span><span>InInnerArchive</span><span>,</span> <span>true</span><span>)</span>
        <span>{</span>
                <span>ArIsSaveGame</span> <span>=</span> <span>true</span><span>;</span>
        <span>}</span>
<span>};</span>
 
<span>UINTERFACE</span><span>(</span><span>BlueprintType</span><span>)</span>
<span>class</span> <span>USavedActorInterface</span> <span>:</span> <span>public</span> <span>UInterface</span>
<span>{</span>
        <span>GENERATED_UINTERFACE_BODY</span><span>()</span>
<span>};</span>
 
<span>class</span> <span>ISavedActorInterface</span>
<span>{</span>
        <span>GENERATED_IINTERFACE_BODY</span><span>()</span>
 
<span>public</span><span>:</span>
        <span>UFUNCTION</span><span>(</span><span>BlueprintNativeEvent</span><span>,</span> <span>BlueprintCallable</span><span>,</span> <span>Category</span> <span>=</span> <span>"Load-Save"</span><span>)</span>
        <span>void</span> <span>ActorLoaded</span><span>();</span>
<span>};</span></pre></div>
<p>And what is nice about <span class="packt_screen">BlueprintNativeEvent</span> is that we can fire these from C++, but have them executed in blueprint. The class we <span>have some new work to do for is our moving platform, which again, exists and is defined solely in blueprint. Making the interface <kbd>BlueprintType</kbd> means we can add this easily to our platform blueprint-only class. So, heading to that class, here are the steps we need to get it saving properly to the archive. Open the moving platform class, click <span class="packt_screen">Class Settings</span> at the top main menu bar, and on the right, you'll see <span class="packt_screen">Implemented Interfaces</span>, and we can click <span class="packt_screen">Add</span> and select <span class="packt_screen">Saved Actor Interface</span> to add this functionality on the blueprint side. Once we compile the blueprint, we can add an event then for when the actor is loaded. To properly set it in the right state, we need to click on its two variables in the <span class="packt_screen">My Blueprint</span> tab on the left, and in their <span class="packt_screen">Details</span> tab, click the down arrow to expose the rest of its options and check the box for <span class="packt_screen">SaveGame</span> for both the <span class="packt_screen">GoingHome</span> and <span class="packt_screen">StartPosition</span> blueprint variables. Now, when we serialize a platform to an archive, these will be saved and loaded and while ideally we would "lasso" select a set of nodes and right-click and select <span class="packt_screen">Collapse to Function</span>, we can't do this here because asynchronous nodes such as <span class="packt_screen">MoveComponentTo</span> have to stay in the <span class="packt_screen">Event Graph</span> layer. But let's add an event for the interface's <span class="packt_screen">Actor Loaded</span> and then just copy paste some of the movement nodes, making sure that if the platform needs to be moving it goes the right way (based on the <span class="packt_screen">Going Home</span> variable). There's no harm telling a platform to go where it already is, so we'll set it on the case it has <span class="packt_screen">Going Home</span> set to move to its <span class="packt_screen">Start Position</span>. Also fixed slightly is the on-actor-overlap event from before. It will go to <span class="packt_screen">Start Position</span> + 300 in Z, rather than its current position. So that fixes arguably our hardest case, the blueprint-only class of the group. Let's add the interface to our other classes, and give them a general save functionality as well as a couple of specific ones (such as our <kbd>MasteringCharacter</kbd>).</span></p>
<p>MyData will consist of all the <kbd>UPROPERTY</kbd> items we tag with <span><kbd>SaveGame</kbd>. Right now, the only one of these we would really need to add is the player's inventory; but because that has class references and an array of structs that also directly reference a texture and class, we'll custom handle inventory.</span></p>
<div class="packt_infobox">Saving class and asset references directly does <em>not</em> work if you tag those <kbd>UPROPERTIES</kbd>. If an object references another object that will be created when the level is loaded, this may work, or to be safe you can look up placed-in-world actors by name in a fix-up pass. Most times, you save the class as a string, then respawn whatever object that is, as we will do extensively here as well as with our inventory special case saving.</div>
<p>If we had other basic types (such as the blueprint variables on our moving platform), simply add <kbd>UPROPERTY(SaveGame)</kbd> to their definition and they automatically serialize in and out with the actor data. To make inventory load and save properly, we need a couple of new structs and its own serialization to and from them, which we will demonstrate in the next section. Since it is not an actor class, it is a little annoying to put its structs in the same place as those actor saving ones, but this still seems at this level of complexity to be the best place. So now, how do we use this menu, some new UI, and a lot of saving and loading code to save everything that can change in our levels at any moment and load right back? Let's dive into that now!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Save and load from our menu</h1>
                </header>
            
            <article>
                
<p>Saving our data is relatively straightforward, but as with all load/save systems, is mirrored with a little more difficulty on the load side. This functionality is almost exclusively implemented in the <kbd>MainMenuWidget</kbd> class, though I can see that the class might grow, moving it to the <kbd>SavedActorInterface</kbd> or the like; but let's now go forward with what is done:</p>
<pre><span>UCLASS</span><span>()</span>
<span>class</span> <span>MASTERING_API</span> <span>UMainMenuWidget</span> <span>:</span> <span>public</span> <span>UUserWidget</span>
<span>{</span>
        <span>GENERATED_BODY</span><span>()</span>
        
<span>public</span><span>:</span>
        <span>UFUNCTION</span><span>(</span><span>BlueprintCallable</span><span>)</span>
        <span>void</span> <span>LoadGame</span><span>(</span><span>FString</span> <span>SaveFile</span><span>);</span>
 
        <span>UFUNCTION</span><span>(</span><span>BlueprintCallable</span><span>)</span>
        <span>void</span> <span>SaveGame</span><span>();</span>
 
        <span>UFUNCTION</span><span>(</span><span>BlueprintCallable</span><span>)</span>
        <span>void</span> <span>Open</span><span>();</span>
 
        <span>UFUNCTION</span><span>(</span><span>BlueprintCallable</span><span>)</span>
        <span>void</span> <span>Close</span><span>();</span>
 
        <span>UFUNCTION</span><span>(</span><span>BlueprintCallable</span><span>)</span>
        <span>void</span> <span>PopulateSaveFiles</span><span>();</span>
 
        <span>void</span> <span>OnGameLoadedFixup</span><span>(</span><span>UWorld</span><span>*</span> <span>World</span><span>);</span>
        <span>static</span> <span>TArray</span><span>&lt;</span><span>uint8</span><span>&gt;</span> <span>BinaryData</span><span>;</span>
 
<span>protected</span><span>:</span>
        <span>UPROPERTY</span><span>(</span><span>BlueprintReadOnly</span><span>)</span>
        <span>TArray</span><span>&lt;</span><span>FString</span><span>&gt;</span> <span>SaveFileNames</span><span>;</span>
<span>};</span></pre>
<p>For saving there is a fair bit going on here, some of which is just basic file I/O, but other parts may be unintuitive and are discussed here:</p>
<pre><span>void</span> <span>UMainMenuWidget</span><span>::</span><span>SaveGame</span><span>()</span>
<span>{</span>
        <span>FGameSavedData</span> <span>SaveGameData</span><span>;</span>
 
        <span>SaveGameData</span><span>.</span><span>Timestamp</span> <span>=</span> <span>FDateTime</span><span>::</span><span>Now</span><span>();</span>
 
        <span>UWorld</span> <span>*</span><span>World</span> <span>=</span> <span>GetWorld</span><span>();</span>
        <span>checkSlow</span><span>(</span><span>World</span> <span>!=</span> <span>nullptr</span><span>);</span>
 
        <span>FString</span> <span>mapName</span> <span>=</span> <span>World</span><span>-&gt;</span><span>GetMapName</span><span>();</span>
 
        <span>mapName</span><span>.</span><span>Split</span><span>(</span><span>"_"</span><span>,</span> <span>nullptr</span><span>,</span> <span>&amp;</span><span>mapName</span><span>,</span> <span>ESearchCase</span><span>::</span><span>IgnoreCase</span><span>,</span> <span>ESearchDir</span><span>::</span><span>FromEnd</span><span>);</span>
 
        <span>SaveGameData</span><span>.</span><span>MapName</span> <span>=</span> <span>*</span><span>mapName</span><span>;</span>
 
        <span>TArray</span><span>&lt;</span><span>AActor</span><span>*&gt;</span> <span>Actors</span><span>;</span>
        <span>UGameplayStatics</span><span>::</span><span>GetAllActorsWithInterface</span><span>(</span><span>GetWorld</span><span>(),</span> <span>USavedActorInterface</span><span>::</span><span>StaticClass</span><span>(),</span> <span>Actors</span><span>);</span>
 
        <span>TArray</span><span>&lt;</span><span>FActorSavedData</span><span>&gt;</span> <span>SavedActors</span><span>;</span>
        <span>for</span> <span>(</span><span>auto</span> <span>Actor</span> <span>:</span> <span>Actor</span><span>s</span><span>)</span>
        <span>{</span>
                <span>FActorSavedData</span> <span>ActorRecord</span><span>;</span>
                <span>ActorRecord</span><span>.</span><span>MyName</span> <span>=</span> <span>FName</span><span>(</span><span>*</span><span>Actor</span><span>-&gt;</span><span>GetName</span><span>());</span>
                <span>ActorRecord</span><span>.</span><span>MyClass</span> <span>=</span> <span>Actor</span><span>-&gt;</span><span>GetClass</span><span>()-&gt;</span><span>GetPathName</span><span>();</span>
                <span>ActorRecord</span><span>.</span><span>MyTransform</span> <span>=</span> <span>Actor</span><span>-&gt;</span><span>GetTransform</span><span>();</span>
                <span>ActorRecord</span><span>.</span><span>MyVelocity</span> <span>=</span> <span>Actor</span><span>-&gt;</span><span>GetVelocity</span><span>();</span>
 
                <span>FMemoryWriter</span> <span>MemoryWriter</span><span>(</span><span>ActorRecord</span><span>.</span><span>MyData</span><span>,</span> <span>true</span><span>);</span>
                <span>FSaveGameArchive</span> <span>Ar</span><span>(</span><span>MemoryWriter</span><span>);</span>
                <span>AMasteringCharacter</span><span>*</span> <span>Mast</span> <span>=</span> <span>Cast</span><span>&lt;</span><span>AMasteringCharacter</span><span>&gt;(</span><span>Actor</span><span>);</span>
 
                <span>Actor</span><span>-&gt;</span><span>Serialize</span><span>(</span><span>Ar</span><span>);</span>
 
                <span>if</span> <span>(</span><span>Mast</span> <span>!=</span> <span>nullptr</span><span>)</span>
                <span>{</span>
                        <span>UMasteringInventory</span><span>*</span> <span>Inv</span> <span>=</span> <span>Mast</span><span>-&gt;</span><span>GetInventory</span><span>();</span>
                        <span>SaveGameData</span><span>.</span><span>InventoryData</span><span>.</span><span>CurrentWeapon</span> <span>=</span> <span>Inv</span><span>-&gt;</span><span>GetCurrentWeapon</span><span>()</span><span>-&gt;</span><span>GetPathName</span><span>();</span>
                        <span>SaveGameData</span><span>.</span><span>InventoryData</span><span>.</span><span>CurrentWeaponPower</span> <span>=</span> <span>Inv</span><span>-&gt;</span><span>GetCurrentWeaponPower</span><span>();</span>
                        <span>for</span> <span>(</span><span>FWeaponProperties</span> <span>weapon</span> <span>:</span> <span>Inv</span><span>-&gt;</span><span>GetWeaponsArray</span><span>())</span>
                        <span>{</span>
                                <span>FInventoryItemData</span> <span>data</span><span>;</span>
                                <span>data</span><span>.</span><span>WeaponClass</span> <span>=</span> <span>weapon</span><span>.</span><span>WeaponClass</span><span>-&gt;</span><span>GetPathName</span><span>();</span>
                                <span>data</span><span>.</span><span>WeaponPower</span> <span>=</span> <span>weapon</span><span>.</span><span>WeaponPower</span><span>;</span>
                                <span>data</span><span>.</span><span>Ammo</span> <span>=</span> <span>weapon</span><span>.</span><span>Ammo</span><span>;</span>
                                <span>data</span><span>.</span><span>TextureClass</span> <span>=</span> <span>weapon</span><span>.</span><span>InventoryIcon</span><span>-&gt;</span><span>GetPathName</span><span>();</span>
 
                                <span>SaveGameData</span><span>.</span><span>InventoryData</span><span>.</span><span>WeaponsArray</span><span>.</span><span>Add</span><span>(</span><span>data</span><span>);</span>
                        <span>}</span>
                <span>}</span>
 
                <span>SavedActors</span><span>.</span><span>Add</span><span>(</span><span>ActorRecord</span><span>);</span>
        <span>}</span>
 
        <span>FBufferArchive</span> <span>BinaryData</span><span>;</span>
 
        <span>SaveGameData</span><span>.</span><span>SavedActors</span> <span>=</span> <span>SavedActors</span><span>;</span>
 
        <span>BinaryData</span> <span>&lt;&lt;</span> <span>SaveGameData</span><span>;</span>
 
        <span>FString</span> <span>outPath</span> <span>=</span> <span>FPaths</span><span>::</span><span>ProjectSavedDir</span><span>()</span> <span>+</span> <span>SaveGameData</span><span>.</span><span>Timestamp</span><span>.</span><span>ToString</span><span>()</span> <span>+</span> <span>TEXT</span><span>(</span><span>".sav"</span><span>);</span>
 
        <span>FFileHelper</span><span>::</span><span>SaveArrayToFile</span><span>(</span><span>BinaryData</span><span>,</span> <span>*</span><span>outPath</span><span>);</span>
 
        <span>BinaryData</span><span>.</span><span>FlushCache</span><span>();</span>
        <span>BinaryData</span><span>.</span><span>Empty</span><span>();</span>
 
        <span>APlayerController</span><span>*</span> <span>playerController</span> <span>=</span> <span>World</span><span>-&gt;</span><span>GetFirstPlayerController</span><span>();</span>
        <span>if</span> <span>(</span><span>playerController</span><span>)</span>
        <span>{</span>
                <span>playerController</span><span>-&gt;</span><span>bShowMouseCursor</span> <span>=</span> <span>false</span><span>;</span>
                <span>FInputModeGameOnly</span> <span>InputMode</span><span>;</span>
                <span>playerController</span><span>-&gt;</span><span>SetInputMode</span><span>(</span><span>InputMode</span><span>);</span>
                <span>UGameplayStatics</span><span>::</span><span>SetGamePaused</span><span>(</span><span>this</span><span>,</span> <span>false</span><span>);</span>
        <span>}</span>
 
        <span>Close</span><span>();</span>
<span>}</span></pre>
<p>We save the timestamp and then split the map name with the <kbd>_</kbd> character. This is a bit of a risk because you'd, of course, want to make it very clear to level designers not to add this character to their map names. In this case, when we're playing and testing in PIE, it appends a couple of things to the left of the map name that end with <kbd>_</kbd> and so splitting from the end gets us, for example, <kbd>FirstPersonExampleMap</kbd> without the PIE prefixes that wind up there when playing in the editor. We then get a list of all actors that implement our save interface and iterate them. We then always save out the relevant actor transient data, but also look to see whether we've found our mastering character to do a bit of inventory work. As noted earlier, our inventory saving (and loading) needs to be done with the <kbd>FInventoryItemData</kbd> struct and not the <kbd>FWeaponProperties</kbd> struct inventory uses directly, because the latter references a class and texture directly (we need them saved by their path/name to properly serialize and then be reloaded from them).</p>
<p>We set all the relevant information, then serialize to a binary for output and save the file, giving it the name of the timestamp we used. You could of course let the user pick the name, or save it otherwise, but this at least shows clearly when loading what time this save was from.</p>
<p>After we have saved, we set the mouse cursor back to hidden, unpause the game, and close the main menu.</p>
<p>When loading, we first have to add some more UI to allow the player to pick the save that they want to load (or cancel):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e333d904-ecd1-451e-b0fc-97d700fc8e9f.png"/></div>
<p>Notice the switcher UMG item. This lets us basically switch (of course) what is shown by the widget from that hierarchy down. We set this from nodes in the main menu blueprint, like when we open the loading portion here in a new function from the load-button's on clicked event:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0366ca45-5235-4ed9-a1e1-871f5162da28.png"/></div>
<p>We then call the native function to get all the save files:</p>
<pre><span>void</span> <span>UMainMenuWidget</span><span>::</span><span>PopulateSaveFiles</span><span>()</span>
<span>{</span>
        <span>FString</span> <span>dir</span> <span>=</span> <span>FPaths</span><span>::</span><span>ProjectSavedDir</span><span>();</span>
        <span>FString</span> <span>fileExt</span> <span>=</span> <span>TEXT</span><span>(</span><span>"sav"</span><span>);</span>
 
        <span>IFileManager</span><span>::</span><span>Get</span><span>().</span><span>FindFiles</span><span>(</span><span>SaveFileNames</span><span>,</span> <span>*</span><span>dir</span><span>,</span> <span>*</span><span>fileExt</span><span>);</span>
<span>}</span></pre>
<p class="mce-root"/>
<p>And then we create and add a button for each of them (with the main menu as a member) to the load game list. We make a quick UserWidget blueprint that has a simple button and text layout like so, that has one job to do when clicked:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b9bae0fb-3fe2-4a61-bdd4-891e057a56ec.png"/></div>
<p>For those looking closely, there are a couple of points that could be handled differently. We will be addressing them later in the book. I would call out that we load (or restart) the map for the save, loading its data, and then, storing it in a static member variable that survives the map re-loading and is then triggered by the HUD's <kbd>BeginPlay</kbd>. We'll be exploring ways to switch from level to level and pass data between them in <a href="978665f4-5638-4a71-9f86-c0349e090ae7.xhtml" target="_blank">Chapter 6</a>, <em>Changing Levels, Streaming, and Retaining Your Data</em>, so fear not if you still have questions there. Also, at the moment, the only way to delete save files is to go to your content folder, but with all the work we've done here, adding a delete to your menus should not be an issue. And one last note: it's also possible in a number of ways to hook one widget to another. In this case, I simply pass the menu to the button when the menu makes it. There's nothing wrong with using clever techniques, just keep in mind that going with the simplest solution sometimes saves time, which every game ends up needing as it gets closer to being ready for the public.</p>
<p>So that's it, we made it! Checking GitHub, there's a new level with some changes in it, but that's really just there for now to prove out load-save from level to level and back again. Have fun testing that out.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter really ramps up the complexity level of work closer to the mastering level. After some warm-up work, it's definitely time to dig into this level of detail and start to really learn the tips and tricks that can make or break a game in development. The work here should give a solid base to a number of levels of UI work: we made a bunch of new weapons, used our pick-ups to generate screenshot icons of them, added these back to the pick-ups and our inventory, utilized that inventory to build and sync up a scroll bar of weapons, and made menus and an entire save-anywhere system for all of our objects, whew! The project is finally starting to look more like a real game compared to the bare-bones template we began with, but one thing is missing: enemies to fight. But fear not, we'll have those by the end of the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Why is it important to commit any changes to files to GitHub before moving them to a new folder location?</li>
<li>What are the steps needed to make a pawn that won't move or fall upon starting an empty level?</li>
<li>What are the two ways of cleaning up redirectors in UE4, and why is it important to do so from time to time?</li>
<li>What UMG child widgets can be used for placing and spacing other widgets within a parent?</li>
<li>What is the advantage of using <kbd>BlueprintImplementableEvents</kbd> in communicating from C++ to UMG?</li>
<li>Which types of <kbd>UPROPERTIES</kbd> must absolutely not be attempted to serialize when saving class variables?</li>
<li>What alternative to saving those properties was used here to save and restore those special types?</li>
<li>Which system was used to implement in only a few lines the building of a list of files matching an extension?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Simple saves with <kbd>USaveGame</kbd>:</p>
<p><a href="https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code">https://docs.unrealengine.com/en-US/Gameplay/SaveGame/Code</a></p>


            </article>

            
        </section>
    </body></html>