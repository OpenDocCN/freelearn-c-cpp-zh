- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructing Peripheral Registers from Memory Addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Bare-metal programming** is all about working directly with the registers
    in the microcontroller without going through a library, allowing us to gain a
    deeper understanding of the microcontroller’s capabilities and limitations. This
    approach enables us to optimize our firmware for speed and efficiency, which are
    two very important parameters in embedded systems where resources are often limited.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, our journey begins with an exploration of various firmware
    development methodologies, highlighting the different levels of abstraction each
    offers. We then proceed to learn how to identify the ports and pins associated
    with key components on our development board. This step is crucial for establishing
    a proper interface with the microcontroller’s peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we delve into defining the addresses of some peripherals using the microcontroller’s
    official documentation. This will allow us to create the addresses of the various
    registers in those peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: In the latter sections of the chapter, our focus shifts to practical application.
    We will use the register addresses that we’ve created to configure PA5 to activate
    the user **light-emitting diode** (**LED**) of the development board.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The different types of firmware development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locating and understanding the development board’s components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and creating registers through documentation insights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register manipulation – from configuration to running your first firmware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid foundation in both navigating
    and programming STM32 microcontrollers at the register level. You will be equipped
    to write your initial bare-metal firmware, relying solely on information gathered
    from the documentation and the **integrated development** **environment** (**IDE**).
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: The different types of firmware development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to develop the firmware for a particular microcontroller
    depending on the resources provided by the microcontroller’s manufacturer. When
    it comes to developing firmware for STM32 microcontrollers from **STMicroelectronics**,
    we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware Abstraction Layer (HAL)**: This is a library provided by STMicroelectronics.
    It simplifies the process by offering high-level APIs for configuring every aspect
    of the microcontroller. What is great about HAL is its portability. We can write
    code for one STM32 microcontroller, and easily adapt it for another, thanks to
    the uniformity of their APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low Layer (LL)**: Also from STMicroelectronics, the LL library is a leaner
    alternative to HAL, offering a faster, more expert-oriented approach that’s closer
    to the hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bare-Metal C programming**: With this approach, we dive right into the hardware,
    accessing the microcontroller’s registers directly using the C language. It’s
    more involved but offers a deeper understanding of the microcontroller’s workings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assembly language**: This is similar to Bare-Metal C, but instead of C, we
    use assembly language to interact directly with the microcontroller’s registers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s compare the four firmware development methods we’ve discussed: HAL, LL,
    Bare-Metal C, and assembly language. Each method has its unique style and level
    of abstraction, impacting how we interact with the microcontroller’s hardware.
    We will use the example of configuring a **general-purpose input/output** (**GPIO**)
    pin as an output to illustrate these differences.'
  prefs: []
  type: TYPE_NORMAL
- en: HAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates how to initialize GPIOA pin 5 as an
    output using HAL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze the snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#include "stm32f4xx_hal.h":` This line includes the HAL library specific to
    the STM32F4 series, providing access to the HAL functions and data structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIO_InitTypeDef GPIO_InitStruct = {0}:` Here, we declare and initialize an
    instance of the `GPIO_InitTypeDef` structure, which is used to configure the GPIO
    pin properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__HAL_RCC_GPIOA_CLK_ENABLE()`: This macro call enables the clock for GPIO
    port A, ensuring that the GPIO peripheral is powered and can function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIO_InitStruct.Pin = GPIO_PIN_5:` This line sets the pin to be configured,
    in this case, pin 5 of port A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP:` Over here, we configure the pin
    as an output pin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HAL_GPIO_Init(GPIOA, &GPIO_InitStruct):` Finally, we initialize the GPIO pin
    (PA5) with the configuration settings specified in `GPIO_InitStruct`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This snippet shows the ease and readability of the HAL approach in performing
    common hardware interfacing tasks. We can summarize the benefits and drawbacks
    of the HAL approach as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Level of** **abstraction**: High'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of use**: Easier for beginners due to its high-level abstraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code verbosity**: More verbose, with several lines of code required for simple
    tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: Excellent across different STM32 devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Slightly slower due to additional abstraction layers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is how we initialize GPIOA pin 5 as an output pin using the LL library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down, line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#include "stm32f4xx_ll_bus.h"` and `#include "stm32f4xx_ll_gpio.h"` include
    the necessary LL library files for handling the bus system and GPIO functionality,
    respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA):` This function call enables
    the clock for GPIO port A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_5, LL_GPIO_MODE_OUTPUT):` Finally, we
    set the mode of GPIOA pin 5 to output mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The LL library provides a more direct and lower-level approach to hardware interaction
    compared to HAL. This is often preferred in scenarios where finer control over
    hardware and performance is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits and drawbacks of the LL approach are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Level of** **abstraction**: Medium'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of use**: Moderate, with a balance between abstraction and direct control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code verbosity**: Less verbose than HAL, offering a more straightforward
    approach to hardware interaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: Good, but slightly less than HAL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Faster than HAL, as it’s closer to the hardware'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bare-Metal C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see how to accomplish the same task using the Bare-Metal C approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the bare-metal c snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#define GPIOA_MODER (*(volatile unsigned long *) (GPIOA_BASE + 0x00))` and
    `#define RCC_AHB1ENR (*(volatile unsigned long *)(RCC_BASE + 0x30))` define pointers
    to specific registers within the microcontroller’s memory. `GPIOA_MODER` points
    to the GPIO port A mode register, and `RCC_AHB1ENR` points to the **reset and
    clock control** (**RCC**) AHB1 peripheral clock **enable register** (**ER**).
    The use of the volatile keyword ensures that the compiler treats these as memory-mapped
    registers, preventing optimization-related issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RCC_AHB1ENR |= (1 << 0)`: This line of code enables the clock for GPIOA. It
    does this by setting the first bit (bit 0) of the `RCC_AHB1ENR` register. The
    bitwise `OR` assignment (`|=`) ensures that only the specified bit is changed
    without altering other bits in the register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOA_MODER |= (1 << 10)`: This line sets PA5 to output mode. In the GPIO
    port mode register (`GPIOA_MODER`), each pin is controlled by two bits. For PA5,
    these are bits 10 and 11 (`MODER5[1:0]`). The code sets bit 10 to `1` (and leaves
    bit 11 as `0`, assuming it was already `0`), configuring PA5 as a general-purpose
    output mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this approach, we can observe the granularity and direct control provided.
    By directly manipulating the microcontroller’s registers, it offers very high
    efficiency and performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Level of** **abstraction**: Low'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of use**: Challenging for beginners, as it requires in-depth hardware
    knowledge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code verbosity**: Less verbose, direct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: Limited, as the code is often specific to a particular hardware
    setup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Very high, as it allows for direct and optimized hardware
    manipulation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembly language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let’s analyze the assembly language implementation for configuring
    PA5 as an output pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EQU GPIOA_MODER`, `0x40020000` and `EQU RCC_AHB1ENR`, `0x40023800` define
    constants for the memory addresses of the GPIOA mode register (`GPIOA_MODER`)
    and the RCC AHB1 peripheral clock ER (`RCC_AHB1ENR`). `''EQU''` is used in assembly
    to equate a label to a value or address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rest of the assembly instructions perform two main tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable the clock for GPIOA:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDR R0, =RCC_AHB1ENR`: Load the address of the `RCC_AHB1ENR` register into
    the `R0` register'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDR R1, [R0]`: Load the value of the `RCC_AHB1ENR` register into the `R1`
    register'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORR R1, R1, #(1 << 0)`: Perform a bitwise `OR` operation to set bit0 of `R1`,
    turning on the clock for GPIOA'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STR R1, [R0]`: Store the updated value back into the `RCC_AHB1ENR` register'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set PA5 as output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDR R0, =GPIOA_MODER`: Load the address of the `GPIOA_MODER` register into
    `R0`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDR R1, [R0]`: Load the current value of the `GPIOA_MODER` register into `R1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORR R1, R1, #(1 << 10)`: Use a bitwise `OR` operation to set bit 10 of `R1`,
    configuring PA5 as an output'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STR R1, [R0]`: Store the updated value back into the `GPIOA_MODER` register'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The assembly language approach allows for extremely detailed and direct control
    over the microcontroller. We often use this in projects where high performance
    is crucial, and every aspect of the hardware needs to be precisely managed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The assembly language approach offers us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Level of** **abstraction**: Lowest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of use**: Most challenging, requiring a thorough understanding of the
    microcontroller’s architecture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code verbosity**: Can be verbose for complex tasks, due to low-level nature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: Very limited, as it is highly specific to the microcontroller’s
    architecture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Highest, as it allows for the most optimized and direct control
    possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows each method and its closeness to the microcontroller’s
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Firmware development methods, arranged in order of proximity  to
    the microcontroller’s architecture](img/B21914_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Firmware development methods, arranged in order of proximity to
    the microcontroller’s architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the diverse approaches to firmware development for
    STM32 microcontrollers, we are ready to delve into the realm of bare-metal C programming.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin our exploration by understanding how the main components of our
    development board are connected to specific pins of the onboard microcontroller.
    This initial step is crucial for gaining insight into the hardware layout and
    preparing us for detailed programming tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Locating and understanding the development board’s components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, our focus is to pinpoint the specific ports and pins on the
    microcontroller to which the user LED, user push button, berg pins, and Arduino-compatible
    headers are connected on the development board. Understanding these connections
    is crucial for our programming tasks. To accurately identify these connections,
    we will consult the *NUCLEO-F411* *User Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Development board showing components of interest](img/B21914_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Development board showing components of interest'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s locate the microcontroller pin connected to the User LED on the development
    board.
  prefs: []
  type: TYPE_NORMAL
- en: Locating the LED connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first step is to navigate through the table of contents to find the section
    dedicated to LEDs. This can be done quickly by locating *Figure 2**.3* in the
    manual, which shows the page number for the *LEDs* section and allows us to jump
    directly to it.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the page number to jump to the LEDs section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: This is the part of the NUCLEO-F411 User Manual’s table of contents
    showing the page number of the LEDs section](img/B21914_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: This is the part of the NUCLEO-F411 User Manual’s table of contents
    showing the page number of the LEDs section'
  prefs: []
  type: TYPE_NORMAL
- en: In the *LEDs* section, we find that the User LED, labeled **User LD2**, is linked
    to the ARDUINO® signal **D13**. This corresponds to either pin PA5 or PB13, depending
    on the specific STM32 target of our board.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note the dual naming convention used in the User Manual due
    to the board’s compatibility with the Arduino IDE. In the Arduino naming scheme,
    pins are categorized as either analog (preceded by “A”) or digital (preceded by
    “D”). For example, digital pin 3 is denoted as D3\. Conversely, the standard STM32
    convention starts with a “P,” followed by a letter indicating the port and then
    the pin number within that port, such as PA5 for the 5th pin of port A.
  prefs: []
  type: TYPE_NORMAL
- en: To determine whether pin D13 of our development board is PA5 or PB13 of the
    onboard microcontroller, we refer to *Tables 11 to 23* in the manual. These tables
    map the ARDUINO® connector pins to standard STM32 pins for each development board
    covered in the document. Specifically, we look at *Figure 2**.5* showing *Table
    16*, which pertains to our development board model.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to *Table 11* by clicking on it as shown in *Figure 2**.4*. This action
    will take you to the initial table in the sequence of tables. Then, scroll down
    until you get to *Table 16*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: This is the part of the NUCLEO-F411 User Manual that shows the
    two possible connections of the User LED](img/B21914_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: This is the part of the NUCLEO-F411 User Manual that shows the
    two possible connections of the User LED'
  prefs: []
  type: TYPE_NORMAL
- en: Upon reviewing *Table 16*, we find that D13 indeed corresponds to PA5\. This
    indicates that the User LED on our NUCLEO-F411RE development board is connected
    to pin PA5 of the onboard microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: Table 16 shows that D13 corresponds to PA5](img/B21914_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Table 16 shows that D13 corresponds to PA5'
  prefs: []
  type: TYPE_NORMAL
- en: Another useful component found on the development board is the User Push button.
    Let’s find the pin connection of this component.
  prefs: []
  type: TYPE_NORMAL
- en: Locating the User Push button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The User Push button on the development board is an important component for
    input handling in many embedded experiments, and understanding its connection
    to the microcontroller is crucial for effective programming and interaction.
  prefs: []
  type: TYPE_NORMAL
- en: To locate the connection details of the User Push button on our board, we will
    navigate through the table of contents to find the section dedicated to *Push-buttons*.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done quickly by locating *Figure 2**.6* in the manual, which shows
    the page number for the *Push-buttons* section and allows us to jump directly
    to it by clicking on the page number.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: This part of the NUCLEO-F411 User Manual provides the page number
    for the Push-buttons section](img/B21914_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: This part of the NUCLEO-F411 User Manual provides the page number
    for the Push-buttons section'
  prefs: []
  type: TYPE_NORMAL
- en: Upon navigating to the *Push-buttons* section of the manual, we locate the relevant
    information about our User Push-button, identified as **B1 User**. The manual
    tells us that this button is connected to pin **PC13** of the onboard microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Locating the berg pins and Arduino-compatible headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *LEDs* sections, we learned that our NUCLEO-F411 development board features
    two primary naming systems for its pins: the Arduino naming system and the standard
    STM32 naming system. While bare-metal programming primarily utilizes the standard
    STM32 naming, the pins on the board itself are labeled according to the Arduino
    system. It is important to know the actual port names and pin numbers of these
    exposed pins so that we can properly connect and program external components such
    as sensors and actuators.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.7* shows our NUCLEO-F411 development board with the columns of
    berg pins highlighted.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: This is the NUCLEO-F411 development board with berg pins highlighted](img/B21914_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: This is the NUCLEO-F411 development board with berg pins highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino header pins of the development board are located at the sides of
    the berg pins columns. This is highlighted in *Figure 2**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: This NUCLEO-F411 development board with Arduino headers highlighted](img/B21914_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: This NUCLEO-F411 development board with Arduino headers highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by finding the microcontroller pin connections of the Arduino header
    pins.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino-compatible headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To identify the standard STM32 names for the pins on the Arduino header, we
    navigate to the section titled *ARDUINO® connectors* using the table of contents.
    This directs us to *Table 11*, which provides the mappings of Arduino pins to
    STM32 pins. For our specific NUCLEO-F411 development board, we focus on *Table
    16*, which offers the relevant mapping for our model.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s locate the connections of the berg pins.
  prefs: []
  type: TYPE_NORMAL
- en: The berg pins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to our approach with other components, to find details about the berg
    pins, we again consult the table of contents in the manual and locate the section
    called *Extension connectors*. This section includes figures illustrating the
    pinouts for various NUCLEO boards. We then scroll to find the pinout corresponding
    to our specific NUCLEO model. Here, the pinout of our development board is presented
    in the standard STM32 naming system.
  prefs: []
  type: TYPE_NORMAL
- en: Over here, we also discover that the manual refers to the columns of male header
    berg pins as the ST morpho connector. This means that whenever the *morpho connector*
    term is used, it is referring to these male header berg pins.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Pinout of the NUCLEO-F411 development board](img/B21914_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Pinout of the NUCLEO-F411 development board'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned that NUCLEO development boards use two naming systems.
    Firstly, the Arduino naming system, which is visibly marked on the board, and
    secondly, the standard STM32 naming system, detailed in the documentation. We
    discovered that the standard STM32 naming system is particularly relevant for
    our purposes, as it directly correlates to the pin names of the onboard microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will guide us on how to access and manipulate the relevant
    memory locations of the onboard microcontroller. Our focus will be on configuring
    pin PA5 as an output pin. This will allow us to control the LED connected to PA5.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and creating registers through documentation insights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we established that the User LED is connected to pin
    PA5\. This means that it is linked to pin number 5 on GPIO PORTA. In other words,
    to get to the LED, we have to go through PORTA and then locate pin number 5 of
    that port.
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in *Figure 2**.10*, the microcontroller has exposed pins on all
    four sides. These pins are organized into distinct groups known as **ports**.
    For instance, pins in PORTA are denoted with the *PA* prefix, while those in PORTB
    start with *PB*, and so forth. This systematic arrangement allows us to easily
    identify and access specific pins for programming and hardware interfacing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: STM32F411 pinout](img/B21914_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: STM32F411 pinout'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go through the steps to locate the precise address
    of GPIO PORTA.
  prefs: []
  type: TYPE_NORMAL
- en: Locating GPIO PORTA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To effectively interact with any part of our microcontroller, it’s essential
    to know the memory address of that specific part. Our next step is to explore
    the memory map of the microcontroller. By doing so, we can locate the address
    of GPIO PORTA in a step-by-step manner.
  prefs: []
  type: TYPE_NORMAL
- en: Since our focus is now on the onboard microcontroller rather than the development
    board, we need to refer to the microcontroller’s datasheet, specifically the `stm32f411re.pdf`
    document.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by navigating to the table of contents of the document. There, we’ll
    find a section entitled *Memory Mapping*. Click on the corresponding page number
    to jump to that section.
  prefs: []
  type: TYPE_NORMAL
- en: Over here, we find a comprehensive diagram that illustrates the entire memory
    map of the microcontroller. A relevant excerpt of this diagram is presented in
    *Figure 2**.11*, which shows the overall memory layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11: Memory map](img/B21914_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Memory map'
  prefs: []
  type: TYPE_NORMAL
- en: The memory map shows that everything inside the microcontroller is addressed
    from `0x0000 0000` to `0xFFFF FFFF`. We’re interested in the part about peripherals
    because that’s where we find GPIOA.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of microcontrollers, a peripheral refers to a hardware component
    that is not part of the **central processing unit** (**CPU**) but is connected
    to the microcontroller to extend its capabilities. Peripherals perform specific
    functions and can include a wide range of components, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GPIO ports**: These are used for interfacing with external devices such as
    LEDs, switches, and sensors. They can be programmed to either receive input signals
    or send output signals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication interfaces**: These include serial communication interfaces
    such as a **universal asynchronous receiver-transmitter** (**UART**), **Serial
    Peripheral Interface** (**SPI**), and **Inter-Integrated Circuit** (**I2C**),
    which enable the microcontroller to communicate with other devices, sensors, or
    even other microcontrollers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timers and counters**: Timers are used for measuring time intervals or generating
    time-based events, while counters can be used to count events or pulses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analog-to-digital converters (ADCs)**: ADCs convert analog signals (such
    as those from a temperature sensor) into digital values that the microcontroller
    can process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peripherals mentioned here represent a selection of the common types found
    in microcontrollers. As we progress through subsequent chapters, we will delve
    deeper into these and other peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 12**.11*, the memory map shows that the address range for all the
    microcontroller’s peripherals spans from `0x40000000` to `0x5FFFFFFF`. This means
    that GPIO PORTA’s address lies within this specified range.
  prefs: []
  type: TYPE_NORMAL
- en: Peripherals base address = 0x40000000
  prefs: []
  type: TYPE_NORMAL
- en: Let’s note down the start of the peripheral address, which we will refer to
    as `PERIPH_BASE`, indicating the base address for the peripherals. We will need
    this for calculating the address of GPIO PORTA. `PERIPH_BASE` = `0x40000000`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.12* shows a zoomed-in view of the peripherals section in the memory
    map. Here, we observe that the peripheral memory is segmented into five distinct
    blocks: APB1, APB2, AHB1, AHB2, and the Cortex-M internal peripherals block, which
    is located at the top.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12: Peripherals memory map](img/B21914_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Peripherals memory map'
  prefs: []
  type: TYPE_NORMAL
- en: 'These blocks, except for the Cortex-M internal peripherals, are named after
    the bus systems they interface with – namely, the **Advanced Peripheral Bus**
    (**APB**) and the **Advanced High-Performance** **Bus** (**AHB**):'
  prefs: []
  type: TYPE_NORMAL
- en: '**APB1 and APB2**: These buses cater to lower bandwidth peripherals, providing
    a more efficient means of communication for devices that do not require high-speed
    data transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AHB1 and AHB2**: These are designed for high-speed data transfer and are
    used to connect high-bandwidth peripherals. They enable faster and more efficient
    data, control, and address communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *pages 54 to 56* of the datasheet, we find a table delineating the boundary
    addresses for each bus and the associated peripherals. A segment of this table
    is shown in *Figure 2**.13*, where we find that GPIOA is allocated a boundary
    address from `0x40020000` to `0x4002 03FF` and is connected to the AHB1 bus. Therefore,
    this indicates that the addresses for all registers related to GPIO PORTA are
    encompassed within this address range.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13: Boundary address and Bus of GPIOA](img/B21914_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Boundary address and Bus of GPIOA'
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA base address = PERIPH_BASE + 0x20000 = 0x40020000
  prefs: []
  type: TYPE_NORMAL
- en: From the table, we find that the starting address for the GPIOA boundary is
    `0x40020000`. This reveals that adding an offset of `0x20000` to the `PERIPH_BASE`
    address (which is 0x40000000) results in the base address of GPIOA, calculated
    as `0x40000000 + 0x20000 = 0x40020000`. The term “offset value” refers to the
    value added to derive a specific address from a base address. In this case, the
    offset value for GPIOA from the `PERIPH_BASE` address is `0x20000`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the concept of offset values is crucial for accurately calculating
    desired addresses in microcontroller programming. This understanding enables precise
    navigation and manipulation within the system’s memory map.
  prefs: []
  type: TYPE_NORMAL
- en: Clock gating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having identified the exact address of GPIOA, our next step is to enable clock
    access to it before configuring its registers. This step is necessary because,
    by default, the clock to all unused peripherals is disabled to conserve power.
  prefs: []
  type: TYPE_NORMAL
- en: Modern microcontrollers use a power-saving technique known as **clock gating**.
    In simple terms, clock gating involves selectively turning off the clock signal
    to certain parts of the microcontroller when they’re not in use. The clock signal
    is an essential part of microcontroller operations, as it drives the sequential
    logic by providing a regular pulse that synchronizes the activities of the microcontroller’s
    circuits. However, when a particular part of the microcontroller, such as a peripheral,
    is not actively being used, the clock signal to that part is disabled. This disabling
    prevents unnecessary power consumption by idle circuits. Therefore, before using
    any peripheral, it’s required to first enable clock access to it.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 2**.14*, there’s a peripheral listed as RCC, which has a
    boundary address range from `0x40023800` to `0x40023BFF`. The functions of this
    peripheral include enabling and disabling clock access to other peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: RCC base Address = PERIPH_BASE + 0x23800 = 0x40023800
  prefs: []
  type: TYPE_NORMAL
- en: From the boundary address information, we can see that the `RCC _Base` address
    is obtained by adding an offset of `0x23800` to `PERIPH_BASE`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21914_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: Boundary address and Bus of RCC'
  prefs: []
  type: TYPE_NORMAL
- en: Having successfully determined the base addresses for the two essential peripherals
    needed to configure GPIOA pin 5 (which controls the connected LED), our next step
    involves using these base addresses to derive the specific register addresses
    necessary for setting the pin as an output and ultimately activating the LED.
  prefs: []
  type: TYPE_NORMAL
- en: To locate the detailed information about these registers, we will refer to the
    reference manual (*RM0383*). This document provides comprehensive insights into
    all registers and their configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The AHB1 ER
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our reference manual, RM0383, is a comprehensive document spanning over 800
    pages, and some STM32 reference manuals even exceed 1,500 pages. The objective
    is not to read the entire manual cover to cover, but rather to develop the skill
    to efficiently locate specific information as needed. Previously, we established
    that GPIOA is connected to the AHB1 bus. We also learned that activating this
    peripheral requires enabling clock access through the RCC peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RCC peripheral in our microcontroller includes a specific register dedicated
    to enabling the clock for each bus. In STM32 microcontrollers, the naming of registers
    follows a straightforward pattern: *peripheral acronym + underscore + register
    acronym*. For example, the register responsible for controlling clock access to
    the AHB1 bus is named `RCC_AHB1ENR`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explain this a bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RCC** stands for **Reset and** **Clock Control**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AHB1** stands for **Advanced High-Performance** **Bus 1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ENR** stands for **Enable Register**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This systematic naming convention simplifies the process of identifying and
    accessing the appropriate registers.
  prefs: []
  type: TYPE_NORMAL
- en: To find the information about the `RCC_AHB1ENR` register, we begin by opening
    the reference manual. Next, we navigate to the table of contents and search for
    the section titled *RCC AHB1 Peripheral Clock Enable Register (RCC_AHB1ENR)*.
    Once located, we click on the page number provided alongside this section title
    to directly jump to the relevant part of the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by examining the details presented at the top of the page, as illustrated
    in *Figure 2**.15*. This section provides key information about the register,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Register name**: The full name of the register is provided along with its
    abbreviation, namely **RCC AHB1 Peripheral Clock Enable** **Register** (**RCC_AHB1ENR**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x30`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x00000000`, indicating the value the register holds upon reset. In other
    words, the default value of the register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access type**: The register supports various access types – it can be accessed
    without wait states and allows word, half-word, and byte access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Register diagram**: A detailed diagram of the register is included, showing
    all 32 bits along with labels for each bit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.15: RCC AHB1 ER](img/B21914_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: RCC AHB1 ER'
  prefs: []
  type: TYPE_NORMAL
- en: RCC_AHB1ENR Address = RCC_BASE + 0x30 = 0x40023830
  prefs: []
  type: TYPE_NORMAL
- en: 'From this information, we can accurately calculate the address of the `RCC_AHB1ENR`
    register. We do this by adding the `RCC_AHB1ENR` offset to the `RCC_BASE address`.
    The formula is as follows: `RCC_BASE + RCC_AHB1ENR Offset = 0x40023800 + 0x30
    =` `0x40023830`.'
  prefs: []
  type: TYPE_NORMAL
- en: The same section of the reference manual also includes a detailed description
    of each bit within the register. We are particularly interested in the bit named
    `'GPIOAEN'`, which stands for `0`. Further down, at the start of the next page
    in the document, we find a precise description of `bit0`, as depicted in *Figure
    2**.16*. This description explains that setting `bit0` to `0` disables the GPIOA
    clock while setting it to `1` enables the GPIOA clock.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16: GPIOAEN bit](img/B21914_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: GPIOAEN bit'
  prefs: []
  type: TYPE_NORMAL
- en: Having understood the steps required to enable clock access to GPIOA, our next
    section will focus on learning how to set and clear bits within a register.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and clearing bits in registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In bare-metal programming, manipulating individual bits within registers is
    a fundamental operation. This manipulation is important for configuring hardware
    settings, controlling peripheral devices, and optimizing the performance of embedded
    systems. Let’s start by understanding bits and registers.
  prefs: []
  type: TYPE_NORMAL
- en: A `0` or `1`. **Registers**, on the other hand, are small-sized storage locations
    within microcontrollers, used to store data temporarily for various operations.
    Registers are typically a collection of bits (such as 8-bit, 16-bit, or 32-bit
    registers), and each bit in a register can be manipulated individually. In bare-metal
    programming, the two most frequently used bit operations are setting a bit and
    clearing a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a bit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting a bit means changing its value to `1`. We will often use this to activate
    or enable a specific function within a microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: '`OR` operation (`|`) is used for setting a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this operation, `1` is shifted left `(<<)` to `bit_position` and then `ORed`
    with the current value of the register. The left shift operation creates a binary
    value where only the target bit is `1`, and all others are `0`. The `OR` operation
    then sets the target bit in the register to `1`, leaving the rest unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume `register` initially holds the `0011` (binary) value and we want
    to set the third bit (bit position 2, 0-indexed). The *bit-shifted value* would
    be `0100` (binary for `1 << 2`). The `OR` operation is then as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the *first*, *second*, and *fourth* bits of the original register
    value retain their value while the value of the third bit is changed to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see the opposite of setting a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing a bit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conversely, clearing a bit means changing its value to `0`, typically to deactivate
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: '`AND` (`&`) and `NOT` (`~`) operations is used for clearing a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, `1` is left-shifted to `bit_position`, and then a bitwise `NOT` operation
    is applied to create a binary number where all bits are `1`, except the target
    bit. The `AND` operation with the register clears the target bit, leaving others
    as they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume `register` initially holds the `0111` (binary) value and we want
    to clear the third bit (bit position 2, 0-indexed). *The bit-shifted value for
    the mask* would be `0100` (binary for `1 << 2`). To clear the bit, we use the
    bitwise `AND` operation with the bitwise `NOT` of the bit-shifted value. The operation
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this operation, the third bit of the register is cleared (changed to `0`),
    while the other bits retain their original values.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s summarize the key points from the last two sections. Firstly, we understood
    that enabling clock access to GPIOA requires setting `bit0` in the `RCC_AHB1ENR`
    register. Secondly, we explored how to set and clear bits in registers using bitwise
    operations. Moving forward, in the next section, we will focus on configuring
    GPIOA pin 5 (PA5) as an output pin. This step is crucial in our progress toward
    activating the LED connected to PA5\. This will take us a step closer to activating
    the LED connected to PA5.
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO port mode register (GPIOx_MODER)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **GPIO port mode register** in STM32 microcontrollers is a specialized register
    used for setting the mode of each GPIO pin. To locate information about this register,
    we navigate to the table of contents of the reference manual and look for the
    section titled *GPIO Port Mode Register (GPIOx_MODER)*. By clicking on the associated
    page number, we are directly taken to the section.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.17* shows the top section of the page. Here, we can observe the
    following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOA_MODER` through `GPIOE_MODER`, as well as `GPIOH_MODER`. This means the
    same register structure and configuration are consistent across these GPIO ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODER` register is located at the very beginning of the port’s memory space.
    Therefore, the GPIOA `MODE` register address is the same as the GPIOA base address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOA_MODER` register is `0xA800 0000`. This value represents the initial
    configuration state of the GPIOA pins upon reset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GPIOB_MODER` register has a default reset value of `0x0000 0280`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODER` registers of all other specified GPIO ports is `0x0000 0000`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPIOA MODE Register Address = GPIOA_BASE =** **0x40020000**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17: GPIO port mode register](img/B21914_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: GPIO port mode register'
  prefs: []
  type: TYPE_NORMAL
- en: We also observe that this is a 32-bit register, with its bits organized in pairs.
    For example, `bit0` and `bit1` together form a pair known as `MODER0`, `bit2`
    and `bit3` form `MODER1`, `bit4` and `bit5` form `MODER2`, and so on. Each of
    these pairs corresponds to a single pin of the GPIO port. Specifically, `MODER0`
    controls the configuration of `PIN0` of the corresponding port, `MODER1` controls
    `PIN1`, and this pattern continues similarly for the other pins.
  prefs: []
  type: TYPE_NORMAL
- en: Given our objective of configuring the mode of `PIN5`, we need to focus on `MODER5`.
    In the register, `MODER5` comprises `bit10` and `bit11`. These two bits are the
    required bits for setting the operational mode of `PIN5`.
  prefs: []
  type: TYPE_NORMAL
- en: The reference manual provides a truth table, illustrated in *Figure 2**.18*,
    which explains the combinations of the two `MODER` bits necessary to configure
    a pin. This table is an invaluable resource for understanding how to set the bits
    for the desired pin configuration, whether it’s as an input, output, or an alternate
    function mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18: The MODER bits configuration](img/B21914_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: The MODER bits configuration'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 2**.18*, the `MODER` register within the GPIO port is composed
    of pairs of bits, designated as `2y:2y+1 MODERy[1:0]`, where *y* ranges from 0
    to 15, representing each of the 16 pins in the port (`PIN0` to `PIN15`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this equation, *y* represents the pin number. For Pin 5, *y = 5*. Plugging
    this value into the equation gives us the bit positions in the `MODER` register
    that correspond to Pin 5:'
  prefs: []
  type: TYPE_NORMAL
- en: The bit positions for `MODER5` are calculated as *2*y* and *(**2*y) +1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Substituting *y = 5*, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*2*5 = 10* and *2*5 + 1 = 11*, which are `10` and `11`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: So, bits `10` and `11` in the MODER register (`MODER5[1:0]`) are the bits that
    control the mode of Pin 5\. By setting these bits to specific values (`00`, `01`,
    `10`, or `11`), we can configure Pin 5 as an input, general-purpose output, alternate
    function, or analog mode, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GPIO `MODER` register supports four distinct bit combinations, each defining
    a different operational mode for the corresponding pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '`00`: When both bits are `0`, the corresponding pin is set as an input pin.
    This is the standard mode for pins to receive data from external sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`01`: Setting the bits to `01` sets the pin function to general-purpose output.
    In this mode, the pin can send data out, for instance, to light up an LED.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10`: The `10` state configures the pin for alternate functions. Each pin can
    serve specific additional purposes (such as PWM output and I2C communication lines),
    and this mode enables those functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`11`: When the bits are set to `11`, the pin operates in analog mode. This
    mode is typically used for ADC, useful in reading values from analog sensors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this, we understand that to configure PA5 as an output, we must set bit
    10 of the `GPIOA_MODER` register to `0` and bit 11 to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s summarize our progress toward activating the LED connected to PA5:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bit0` of the `RCC_AHB1ENR` register to `1`. This step is essential to power
    the GPIOA for operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuring PA5 for output**: We have just learned how to set PA5 as a general-purpose
    output pin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two steps effectively configure PA5 as an output pin. The final task involves
    controlling the output state of the pin – setting it to either `1` or `0`, which
    corresponds to on or off, respectively. This translates to sending either 3.3v
    or 0v to PA5, thus turning the connected LED on or off. To manage the output state
    of a pin, we need to interact with the **Output Data Register** (**ODR**). Locating
    and configuring this register will be the focus of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have the following information for our quest to activate the LED
    connected to PA5:'
  prefs: []
  type: TYPE_NORMAL
- en: We know how to enable clock access to GPIOA through the `RCC_AHB1ENR` register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know how to configure the PIN5 of GPIOA as a general-purpose output pin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two steps make PA5 act as an output pin. The final step is to be able
    to set the output state of the pin. The state can be either `1` or `0` corresponding
    to on or off, corresponding to sending 3.3v or 0v to PA5, and finally corresponding
    to turning on or turning off the LED connected to PA5\. To set the output of a
    pin, we need to access the ODR; this shall be the focus of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO Port Output Data Register (GPIOx_ODR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GPIO Port **ODR** in STM32 microcontrollers is used for controlling the
    output state of each GPIO pin. To find information about this register, we refer
    to the table of contents in the microcontroller’s reference manual and locate
    the section titled *GPIO Port Output Data Register (GPIOx_ODR)*. Clicking on the
    page number corresponding to this section takes us straight to the required information.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.19* displays the top part of the page, where we can observe the
    following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOA_ODR` through `GPIOE_ODR`, as well as `GPIOH_ODR`. This means the same
    register structure and configuration are consistent across these GPIO ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x14` from the base address of its respective GPIO port. This means that,
    for each GPIO port, the ODR register can be found at this offset from the port’s
    base memory address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` upon a reset. This default state ensures that all GPIO pins are initially
    in a low output state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPIOA ODR address = GPIOA_BASE + ODR_OFFSET = 0x40020014
  prefs: []
  type: TYPE_NORMAL
- en: '`ODR_OFFSET =` `0x14`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21914_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.19: GPIO port ODR'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delve into the structure of the bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bits 31:16 (reserved)**: These bits are reserved and should not be used for
    any operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` to `15`, correspond to each of the 16 pins in the GPIO port. They are directly
    programmable and can be both read and written by software. Changing the value
    of these bits alters the output state of the corresponding GPIO pin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s consider our final task of activating the LED connected to PA5:'
  prefs: []
  type: TYPE_NORMAL
- en: '`5`) in the `GPIOA_ODR` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` to bit `5` of the `GPIOA_ODR` register. This can be achieved using a bitwise
    `OR` operation, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this operation, we shift `1` left by 5 positions (resulting in a binary value
    where only the 6th bit is `1`) and then `OR` it with the current value of the
    `GPIOA_ODR` register. This action sets PA5 high without altering the state of
    other pins in the port.
  prefs: []
  type: TYPE_NORMAL
- en: Setting PA5 high will supply voltage to the connected LED, effectively turning
    it on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to set the state of GPIO output pins, in the next
    section, we will combine all the pieces of information we’ve acquired and develop
    our first firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Register manipulation – from configuration to running your first firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will apply the knowledge acquired throughout this chapter
    to develop our first bare-metal firmware.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by creating a new project, a process we covered in [*Chapter 1*](B21914_01.xhtml#_idTextAnchor015).
    Here is a summary of the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start a new project**: Go to **File** | **New** | **STM32 Project** in your
    IDE.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Select the target microcontroller**: A **Target Selection** window will appear,
    prompting you to choose the microcontroller or development board for your project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Use the board selector**: Click on the **Board** **Selector** tab.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NUCLEO-F411` in the **Commercial Part** **Number** field.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Select our board**: From the list of boards that appear, choose **NUCLEO-F411RE**
    and then click **Next**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RegisterManipulation`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Empty` project setup.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Final step**: Click **Finish** to create your project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project is created, open the `main.c` file in your project workspace.
    Clear all pre-existing text in this file to start with a clean slate for our code.
  prefs: []
  type: TYPE_NORMAL
- en: For a clearer understanding, we will structure our code into two distinct sections.
    The first section will be titled `Register Definitions`, and the second will be
    named `Main Function`.
  prefs: []
  type: TYPE_NORMAL
- en: Register Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section of the code defines constants and macros for memory addresses
    and bit masks. Here are all the memory addresses and bit masks required for controlling
    the LED connected to PA5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '// Line 17: Start of main function'
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '//  18: Enable clock access to GPIOA'
  prefs: []
  type: TYPE_NORMAL
- en: RCC_AHB1EN_R |= GPIOAEN;
  prefs: []
  type: TYPE_NORMAL
- en: 'GPIOA_MODE_R |= (1U<<10);  //  19: Set bit 10 to 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'GPIOA_MODE_R &= ~(1U<<11); //  20: Set bit 11 to 0'
  prefs: []
  type: TYPE_NORMAL
- en: '//  21: Start of infinite loop'
  prefs: []
  type: TYPE_NORMAL
- en: while(1)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '// Line 22: Set PA5(LED_PIN) high'
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA_OD_R |= LED_PIN;
  prefs: []
  type: TYPE_NORMAL
- en: '}  //  23: End of infinite loop'
  prefs: []
  type: TYPE_NORMAL
- en: '}  //  24: End of main function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '// Line 17: Start of main function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: int main(void)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '// Line 18: Enable clock access to GPIOA'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RCC_AHB1EN_R |= GPIOAEN;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'GPIOA_MODE_R |= (1U<<10);  // Line 19: Set bit 10 to 1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'GPIOA_MODE_R &= ~(1U<<11); // Line 20: Set bit 11 to 0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '// Line 21: Start of infinite loop'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: while(1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// Line 22: Set PA5(LED_PIN) high'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: GPIOA_OD_R |= LED_PIN;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}  // Line 23: End of infinite loop'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '}  // Line 24: End of main function'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '//  1: Define base address for peripherals'
  prefs: []
  type: TYPE_NORMAL
- en: '#define PERIPH_BASE        (0x40000000UL)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  2: Offset for AHB1 peripheral bus'
  prefs: []
  type: TYPE_NORMAL
- en: '#define AHB1PERIPH_OFFSET  (0x00020000UL)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  3: Base address for AHB1 peripherals'
  prefs: []
  type: TYPE_NORMAL
- en: '#define AHB1PERIPH_BASE    (PERIPH_BASE + AHB1PERIPH_OFFSET)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  4: Offset for GPIOA'
  prefs: []
  type: TYPE_NORMAL
- en: '#define GPIOA_OFFSET       (0x0000UL)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  5: Base address for GPIOA'
  prefs: []
  type: TYPE_NORMAL
- en: '#define GPIOA_BASE         (AHB1PERIPH_BASE + GPIOA_OFFSET)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  6: Offset for RCC'
  prefs: []
  type: TYPE_NORMAL
- en: '#define RCC_OFFSET         (0x3800UL)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  7: Base address for RCC'
  prefs: []
  type: TYPE_NORMAL
- en: '#define RCC_BASE           (AHB1PERIPH_BASE + RCC_OFFSET)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  8: Offset for AHB1EN register'
  prefs: []
  type: TYPE_NORMAL
- en: '#define AHB1EN_R_OFFSET    (0x30UL)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  9: Address of AHB1EN register'
  prefs: []
  type: TYPE_NORMAL
- en: '#define RCC_AHB1EN_R  (*(volatile unsigned int *)(RCC_BASE +  AHB1EN_R_OFFSET))'
  prefs: []
  type: TYPE_NORMAL
- en: '//  10: Offset for mode register'
  prefs: []
  type: TYPE_NORMAL
- en: '#define MODE_R_OFFSET      (0x00UL)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  11: Address of GPIOA mode register'
  prefs: []
  type: TYPE_NORMAL
- en: '#define GPIOA_MODE_R  (*(volatile unsigned int *)(GPIOA_BASE + MODE_R_OFFSET))'
  prefs: []
  type: TYPE_NORMAL
- en: '//  12: Offset for output data register'
  prefs: []
  type: TYPE_NORMAL
- en: '#define OD_R_OFFSET   (0x14UL)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  13: Address of GPIOA output data register'
  prefs: []
  type: TYPE_NORMAL
- en: '#define GPIOA_OD_R    (*(volatile unsigned int *)(GPIOA_BASE +  OD_R_OFFSET))'
  prefs: []
  type: TYPE_NORMAL
- en: '//  14: Bit mask for enabling GPIOA (bit 0)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define GPIOAEN       (1U<<0)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  15: Bit mask for GPIOA pin 5'
  prefs: []
  type: TYPE_NORMAL
- en: '#define PIN5          (1U<<5)'
  prefs: []
  type: TYPE_NORMAL
- en: '//  16: Alias for PIN5 representing LED pin'
  prefs: []
  type: TYPE_NORMAL
- en: '#define LED_PIN       PIN5'
  prefs: []
  type: TYPE_NORMAL
- en: '//  17: Start of main function'
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '//  18: Enable clock access to GPIOA'
  prefs: []
  type: TYPE_NORMAL
- en: RCC_AHB1EN_R |= GPIOAEN;
  prefs: []
  type: TYPE_NORMAL
- en: 'GPIOA_MODE_R |= (1U<<10);  //  19: Set bit 10 to 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'GPIOA_MODE_R &= ~(1U<<11); //  20: Set bit 11 to 0'
  prefs: []
  type: TYPE_NORMAL
- en: '//  21: Start of infinite loop'
  prefs: []
  type: TYPE_NORMAL
- en: while(1)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '//  22: Set PA5(LED_PIN) high'
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA_OD_R |= LED_PIN;
  prefs: []
  type: TYPE_NORMAL
- en: '}  //  23: End of infinite loop'
  prefs: []
  type: TYPE_NORMAL
- en: '}  //  24: End of main function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
