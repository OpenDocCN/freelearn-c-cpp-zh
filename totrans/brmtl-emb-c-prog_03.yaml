- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the Build Process and Exploring the GNU Toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bare-metal programming is a journey of deep understanding and precision, and
    in this chapter, we will navigate the complex realm of the embedded firmware build
    process. Our focus is the GNU Arm Toolchain, an important element in firmware
    development. Through a blend of theory and hands-on programming exercises, you
    will gain insights into how **integrated development environments** (**IDEs**)
    streamline the build process and how these processes can be manually replicated
    using the GNU Arm Toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: As the chapter progresses, we delve into the nuances of the compiler and its
    various options, tailored for Arm Cortex microcontrollers. The programming exercise
    in this chapter is designed to help you understand and effectively utilize the
    GNU tools, from compiling and linking to analyzing the depths of the output object
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The foundations – understanding the embedded build process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tour of GNU binary tools for embedded systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From IDE to command-line – watching the build process unfold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have an understanding of the embedded firmware
    build process and have developed the skills to fluidly switch between IDEs and
    command-line interfaces, enhancing your versatility as a firmware developer.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: The foundations – understanding the embedded build process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The journey from high-level source code in embedded firmware development to
    an executable binary image is intricate and multilayered. This process is commonly
    referred to as the firmware build process and involves several critical stages
    – pre-processing, compilation, assembly, linking, and locating. Each of these
    stages plays an important role in transforming human-readable code into machine-executable
    instructions. *Figure 3**.1* shows the entire build process and the tools involved
    at each stage of the process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: The build process, detailing the input and output files for each
    stage and the specific tools used](img/B21914_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The build process, detailing the input and output files for each
    stage and the specific tools used'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the stages.
  prefs: []
  type: TYPE_NORMAL
- en: The pre-processing stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pre-processing is the initial stage in the firmware build process. In this stage,
    the source code undergoes a series of transformations to prepare it for compilation.
    Typically, source files in embedded systems are written in C (`.c` files) and
    accompanied by header files (`.h` files). The preprocessor is the specialized
    tool in the build process whose task is to handle these input files.
  prefs: []
  type: TYPE_NORMAL
- en: 'During pre-processing, the preprocessor executes several key operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stripping comments**: Comments, which are crucial for human readability but
    irrelevant for machines, are removed from code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#` symbol, known as preprocessor directives, are processed. These directives
    often include macro definitions (`#define`), conditional compilation instructions
    (`#ifdef`, `#ifndef`, `#endif`), and file inclusion commands (`#include`). The
    preprocessor replaces these directives with their defined values or corresponding
    code segments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.i` extension. These files represent the transformed source code, devoid of
    comments and with all directives evaluated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next stage is the compilation stage.
  prefs: []
  type: TYPE_NORMAL
- en: The compilation stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compilation starts immediately after pre-processing. The compiler’s role is
    to take `.i` files and convert them into architecture-specific assembly code.
    This phase is where the high-level constructs of `C` are translated into the lower-level,
    more granular assembly instructions understood by the target processor architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'This stage involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.``i` files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process**: The compiler analyzes the code structure, optimizes it for performance
    and space, and translates it into assembly language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.``s` extension'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next stage makes use of the `.``s` files.
  prefs: []
  type: TYPE_NORMAL
- en: The assembly stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assembly is the stage where the `.s` files containing assembly code are converted
    into machine code, in the form of **object files**. This stage translates the
    human-readable assembly instructions into a binary format.
  prefs: []
  type: TYPE_NORMAL
- en: 'This stage involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.s`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process**: The assembler interprets each assembly instruction and converts
    it into corresponding machine code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.o` extension. These files contain binary code and are ready for the next
    stage of linking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The linking stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linking is the stage where all individual object files are combined to form
    a cohesive program. This stage also integrates any necessary standard library
    files and resolves references between different code modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'This stage involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.o`) and C standard library files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process**: The linker stitches together all object files, resolving symbolic
    references and addresses. It handles tasks such as memory allocation for variables
    and functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**: The linker generates a **relocatable file**, which is comprehensive
    but not yet final executable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A relocatable file is intermediate output in the firmware build process, which
    is created during the linking stage. It’s a comprehensive file that combines all
    individual object files `(.o)` and the necessary library. However, it is not yet
    a final executable. The concept of **relocation** plays an important role here.
    Relocation involves adjusting the symbolic addresses in the relocatable file to
    actual, specific memory locations. This process ensures that when the firmware
    runs on a target device, each part of the code and data is correctly placed in
    memory. The relocatable file contains all the necessary components of the firmware,
    but with addresses that are still “relative” – they need further adjustment during
    the locating stage to fit the unique memory map of the target microcontroller,
    leading to the creation of the final executable.
  prefs: []
  type: TYPE_NORMAL
- en: The next stage is where we finally get our executable code.
  prefs: []
  type: TYPE_NORMAL
- en: The locating stage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the last stage; it involves converting the relocatable file into the
    final executable binary. This stage is guided by a linker script, which provides
    essential information about the memory layout of the target device.
  prefs: []
  type: TYPE_NORMAL
- en: 'This stage involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input**: A relocatable file and a linker script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process**: The locator uses the linker script to place code and data sections
    into their designated memory locations. It adjusts addresses and offsets to fit
    the target’s memory map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**: An executable binary file, typically in formats such as **Executable
    and Linkable Format** (**ELF**) or a plain binary format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this knowledge in hand, we are well-equipped to delve into the GNU Toolchain
    for Arm. Our goal is to effectively utilize specific tools within the toolchain
    to execute the various stages of the build process. This will be the focus of
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: A tour of GNU binary tools for embedded systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll delve into the GNU Bin tools, a suite of tools that come
    with the installation of the GNU Toolchain for Arm. These tools (commands) are
    essential for the various stages of the firmware build process, as well as additional
    tasks such as debugging.
  prefs: []
  type: TYPE_NORMAL
- en: The first command we’ll explore is `arm-none-eabi-gcc`.
  prefs: []
  type: TYPE_NORMAL
- en: arm-none-eabi-gcc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s break down the components of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arm`: This specifies the target architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`none`: This component indicates the operating system for which the code is
    being compiled. Here, `none` signifies that the code is meant for a bare-metal
    environment, meaning it will run directly on the hardware without an underlying
    operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eabi`: This stands for **Embedded Application Binary Interface**. EABI defines
    a standard for the binary layout of system and user programs, libraries, and so
    on. It ensures that the compiled code will work correctly on any Arm processor
    that adheres to the EABI standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcc`: This is short for **GNU** **Compiler Collection**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This single command compiles, assembles, and links our input code in one go.
    To use it, type `arm-none-eabi-gcc` in the command prompt or terminal, followed
    by the source file, then `-o`, and the desired output filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'See *Figure 3**.2* for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: Usage of the arm-none-eabi-gcc command](img/B21914_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Usage of the arm-none-eabi-gcc command'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we specify the source file as `main.c` and the output file
    as `main.o.`
  prefs: []
  type: TYPE_NORMAL
- en: Some common compiler flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we have just introduced the `-o` compiler flag, let’s take this opportunity
    to introduce some of the other commonly used compiler flags. These compiler flags
    are used to modify command behavior as well as add options to commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-c`: This flag is used to compile and assemble but not link. When added to
    the command, it processes the code up to the assembly stage but stops before linking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o file`: As mentioned earlier, this specifies the name of the output file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-g`: Generates debugging information in the executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Wall`: Enables all warning messages, helping us identify potential issues
    in the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Werror`: Treats all warnings as errors, ensuring code quality and stability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-I [DIR]`: Includes a specified directory to search for header files; it’s
    useful for organizing large projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ansi` and `-std=STANDARD`: These flags specify which standard version of
    the c language should be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v`: Provides verbose output from GCC, giving us detailed information about
    the compilation process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Table 3.1* provides a summary of the flags and example usage for each flag.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Purpose** | **Example usage** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-c` | Compile and assemble but don’t link | `arm-none-eabi-gcc -``c source_file`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``o file` | Link to the output file, named file | `arm-none-eabi-gcc source_file
    -``o output_file` |'
  prefs: []
  type: TYPE_TB
- en: '| `-g` | Generate debugging info in the executable | `arm-none-eabi-gcc -``g
    source_file` |'
  prefs: []
  type: TYPE_TB
- en: '| `-``Wall` | Enable all warning messages | `arm-none-eabi-gcc -``Wall source_file`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``Werror` | Treat warnings as errors | `arm-none-eabi-gcc -``Werror source_file`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``I [DIR]` | Include a directory for header files | `arm-none-eabi-gcc
    -I` `directory_path source_file` |'
  prefs: []
  type: TYPE_TB
- en: '| `-``ansi` | Use the **American National Standards Institute** (**ANSI**)
    standard | `arm-none-eabi-gcc -``ansi source_file` |'
  prefs: []
  type: TYPE_TB
- en: '| `-``std` | Specify a standard version (e.g., C11) | `arm-none-eabi-gcc -``std=c11
    source_file` |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | Verbose output from GCC | `arm-none-eabi-gcc -``v source_file` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.1: Some compiler flags and their example usage'
  prefs: []
  type: TYPE_NORMAL
- en: Some architecture-specific flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the general compiler flags, there are several architecture-specific
    flags that enable precise configuration for various processor architectures. These
    flags are integral for tailoring the build process to specific ARM processors
    and their respective architectures. Let’s delve into some of the most frequently
    used architecture-specific flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-mcpu=[NAME]`: Specifies the target ARM processor. Using this option configures
    the compiler to optimize the code for a specific processor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`march=[NAME]`: Specifies the target ARM architecture. It configures the compiler
    for a particular ARM architecture version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mtune=[NAME]`: Similar to `-mcpu`, this specifies the target ARM processor
    for optimization purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-thumb`: Configures the compiler to generate code for the Thumb instruction
    set, which is a compressed version of the standard ARM instruction set, providing
    more code density and efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-marm`: Instructs the compiler to generate code for the ARM instruction set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mlittle-endian`/`-mbig-endian`: These options specify the endianness for
    the generated code. Little-endian is the most common format in ARM processors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see an example involving some of these flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Usage of the arm-none-eabi-gcc command with some architecture-specific
    flags](img/B21914_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Usage of the arm-none-eabi-gcc command with some architecture-specific
    flags'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-c`: Compile and assemble but do not link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mcpu=cortex-m4`: Build for the Cortex-M4 processor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mthumb`: Use the Thumb instruction set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o main.o`: Output the compiled file as `main.o`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Table 3.2* provides a summary of the architecture-specific flags and example
    usage for each flag.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Purpose** | **Example usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `-``mcpu=[NAME]` | Specify the target ARM processor | `-``mcpu=cortex-m4`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``march=[NAME]` | Specify the target ARM architecture | `-``march=armv7-m`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``mtune=[NAME]` | Optimize for a specific ARM processor | `-``mtune=cortex-m4`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``thumb` | Generate code for the Thumb instruction set | `-``mthumb` |'
  prefs: []
  type: TYPE_TB
- en: '| `-``marm` | Generate code for the ARM instruction set | `-``marm` |'
  prefs: []
  type: TYPE_TB
- en: '| `-``mlittle-endian` | Generate code for little-endian mode | `-``mlittle-endian`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-``mbig-endian` | Generate code for big-endian mode | `-``mbig-endian` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.2: Some architecture-specific compiler flags and their example usage'
  prefs: []
  type: TYPE_NORMAL
- en: Other commands in the GNU Toolchain for Arm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the `arm-none-eabi-gcc` command, there are other important commands
    that we will frequently use when building with the GNU toolchain for Arm. Let’s
    examine some of these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arm-none-eabi-nm`: The `arm-none-eabi-nm` command is a handy tool for listing
    the symbols from an object file. Symbols in this context refer to various identifiers
    in a program, such as function names, variable names, and constants. This tool
    is invaluable for examining the contents of compiled files, offering us insights
    into the structure and components of our program. This can be particularly useful
    for debugging purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arm-none-eabi-size`: In embedded firmware development, where memory resources
    are often limited, understanding the memory footprint of different sections of
    our code is crucial. This tool provides valuable insights into how much memory
    the various parts of our code consume, allowing us to make informed decisions
    about optimization and memory management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arm-none-eabi-objdump`: This tool is used to extract and display detailed
    information from object files. It offers an in-depth view of the machine instructions,
    making it an invaluable resource for thorough analysis of object files. This includes
    capabilities such as disassembling code, presenting section headers, and revealing
    symbol tables. Its utility becomes crucial when we need to delve into the intricate
    details of compiled code, providing clarity on a file’s structure, content, and
    operational mechanics. This helps us to both debug and optimize our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disassembling code refers to the process of converting machine code, which is
    a set of binary instructions that a computer’s processor can execute directly,
    back into assembly language. Assembly language is a more human-readable form of
    instructions, although it’s still quite low-level compared to the C language.
    *Figure 3**.4* presents a comparison of C-language code, its corresponding assembly
    language translation, and the resulting machine code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.4: C-language code, its corresponding assembly language code, and
    the resulting machine code](img/B21914_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: C-language code, its corresponding assembly language code, and
    the resulting machine code'
  prefs: []
  type: TYPE_NORMAL
- en: '`arm-none-eabi-readelf`: This tool provides detailed information about the
    output ELF file, including section headers, program headers, and symbol tables.
    It is useful when we work with ELF files, as it offers insights into how an executable
    is structured and prepared to run on a system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`: arm-none-eabi-objcopy`: We use this tool to convert object files from one
    format to another or to make a copy of an object file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Table 3.3* provides a summary of these additional tools and example usage
    for each tool.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool** | **Function** | **Example Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `arm-none-eabi-nm` | Lists symbols from object files | `arm-none-eabi-nm
    [``object file]` |'
  prefs: []
  type: TYPE_TB
- en: '| `arm-none-eabi-size` | Lists section sizes of object/executable files | `arm-none-eabi-size
    [file]` |'
  prefs: []
  type: TYPE_TB
- en: '| `arm-none-eabi-objdump` | Dumps information about object files | `arm-none-eabi-objdump
    [options] [``object file]` |'
  prefs: []
  type: TYPE_TB
- en: '| `arm-none-eabi-readelf` | Displays information about ELF files | `arm-none-eabi-readelf
    [options] [``ELF file]` |'
  prefs: []
  type: TYPE_TB
- en: '| `arm-none-eabi-objcopy` | Converts/copies object files between formats |
    `arm-none-eabi-objcopy [options] [input file] [``output file]` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.3: Some common commands in the GNU toolchain for Arm and their example
    usage'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the GNU Binary Tools that are essential for embedded
    firmware development. These tools, including commands such as `arm-none-eabi-gcc`,
    play important roles in various stages of the firmware build process and are invaluable
    for tasks such as compiling, linking, and debugging. The next section will further
    expand our understanding of these tools; we’ll dive into their practical applications,
    demonstrating their utility in the embedded firmware build process.
  prefs: []
  type: TYPE_NORMAL
- en: From IDE to the command line – watching the build process unfold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, our aim is to understand how the compiler within the IDE handles
    our code when we initiate a build. Additionally, we will delve into the practical
    applications of some of the GNU Binary Tools we discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Observing the build process from the IDE’s perspective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by revisiting the bare-metal GPIO driver we developed in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by launching your STM32CubeIDE. To conduct a proper analysis of the build
    commands that the IDE executes, it’s necessary to first clean the project and
    then build again. The reason for this is straightforward – we’ve already built
    the project, in a previous chapter. Without any modifications to the source code
    since then, a new build attempt would skip the detailed command execution we aim
    to scrutinize, since the source code hasn’t changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s clean the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the project in the **Projects** pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the name of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A menu will appear. From this menu, select the **Clean** **Project** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IDE will now clear any already compiled data from the project. This action
    resets the build state of the project to its initial condition, erasing any previous
    build results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s build it again:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click once more on the same project’s name in the **Projects** pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, a menu will appear. This time, select the **Build** **Project** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By selecting this option, the IDE will start the process of building the project
    from scratch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To observe the build commands in the STM32CubeIDE, we must find the **Console**
    pane, which is usually positioned at the bottom area of the IDE’s interface. The
    **Console** pane is an important component that displays real-time outputs and
    logs for various actions, including the build process. This makes it an invaluable
    tool to monitor the commands and actions undertaken during the compilation of
    our projects.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Console** pane is not readily visible in your current IDE layout, you
    can access it through the menu bar located at the top of the IDE. Simply click
    on the **Window** menu to reveal a drop-down list of options. From there, navigate
    to **Show View**, which will expand to show more choices. Among these, select
    **Console** to bring the pane into view within your workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the `2_RegisterManipulation` bare-metal GPIO driver project.
    *Figure 3**.5* shows some of the content of the `2_RegisterManipulation` bare-metal
    GPIO driver project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: The Console pane after building the 2_RegisterManipulation bare-metal
    GPIO driver project.](img/B21914_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: The Console pane after building the 2_RegisterManipulation bare-metal
    GPIO driver project.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.5* provides a snapshot of the build process steps, although it
    only displays a segment of each step. For a comprehensive view of all the steps,
    including the full lines of commands and responses, you should refer to the **Console**
    pane in your STM32CubeIDE.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze the console pane in *Figure 3**.5*, according to the line numbering..
  prefs: []
  type: TYPE_NORMAL
- en: Compilation of assembly and C files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Line (1)**'
  prefs: []
  type: TYPE_NORMAL
- en: '`make -j8 all`: This is a command to the `make` build automation tool, requesting
    it to execute the build. We shall learn about `make` in the upcoming chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines (2)(3)(4)(5)**'
  prefs: []
  type: TYPE_NORMAL
- en: The following lines are specific `arm-none-eabi-gcc` commands to compile individual
    source files such as `main.c`, `syscalls.c`, and `sysmem.c`. These commands specify
    the target CPU (`-mcpu=cortex-m4`) and other compiler flags. Each source file
    is compiled into an object file (`.o`).
  prefs: []
  type: TYPE_NORMAL
- en: Linking process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Line (6)**'
  prefs: []
  type: TYPE_NORMAL
- en: The `arm-none-eabi-gcc` command with a list of object files (`@"objects.list")`
    and a linker script (`STM32F411RETX_FLASH.ld`) links these object files into an
    executable file (`2_RegisterManipulation.elf`). The linker script guides how different
    sections of the code and data are placed in the final executable. We shall discuss
    linker scripts in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Size calculation:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Line (8)**'
  prefs: []
  type: TYPE_NORMAL
- en: '`arm-none-eabi-size 2_RegisterManipulation.elf:` This command calculates the
    size of the compiled program, breaking it down into text (code), data (initialized
    data), and bss (uninitialized data) sections. The output shows the size of these
    sections in bytes and their total in both decimal (**dec**) and hexadecimal (**hex**)
    formats.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creation of a list file:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Line (9)**'
  prefs: []
  type: TYPE_NORMAL
- en: '`arm-none-eabi-objdump -h -S 2_RegisterManipulation.elf > "2_RegisterManipulation.list"`:
    This command disassembles the executable and outputs a detailed list file. The
    `-h` flag shows the header information, and `-S` intersperses source code with
    disassembly. A list file is a detailed textual representation of compiled code,
    containing both the assembly language instructions and their corresponding machine
    code, often with annotations of the original high-level source code.'
  prefs: []
  type: TYPE_NORMAL
- en: As we can observe from these logs, it is clear that our STM32CubeIDE employs
    the same GNU Binary Tools previously discussed. In our forthcoming section, we
    will manually execute these commands via the command line. This approach will
    teach us how to build our firmware without using an IDE, simply using the source
    text files, the command-line interface, and our suite of GNU Bin Tools.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the GNU bin tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, our focus is to execute some of the GNU Bin Tools directly,
    using our command line. To start I want to show you why I use the words *commands*
    and *tools* interchangeably to describe the GNU Bin Tools.
  prefs: []
  type: TYPE_NORMAL
- en: Locate the installation folder for the GNU Arm Embedded Toolchain on your computer.
    On my computer, this is `C:/Program Files(x86)/GNU Arm` `Embedded Toolchain.`
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve located the GNU Arm Embedded Toolchain folder, the next step involves
    accessing the `bin` folder within it.
  prefs: []
  type: TYPE_NORMAL
- en: Upon opening the `bin` folder, you’ll be greeted with a plethora of tools, each
    represented by an executable file (`.exe`). Looking closely, you will find `arm-none-eabi-gcc.exe`,
    our compiler, along with other tools we previously discussed. When we input a
    command corresponding to these tools in the command line, the associated `.exe`
    file is executed. For instance, entering `arm-none-eabi-gcc` in the command line
    will run the `arm-none-eabi-gcc.exe` executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have clarified that, it’s time to shift our focus toward practical
    testing. However, before diving into this testing phase, a few essential preparatory
    steps are required. Let’s create a backup of our current project, `2_RegisterManipulation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2_RegisterManipulation` project is stored.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2_RegisterManipulation` project folder, select **Copy**, and then **Paste**
    within the same directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2_RegisterManipulation-old`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the backup in place, our next move is to modify the `main.c` file in the
    `2_Register` **Manipulation** project, changing the LED’s behavior from a constant
    *on* state to a blinking one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2_RegisterManipulation/Src` directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`main.c` file and choose to open it in a simple text editor, such as Notepad.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PA5 (LED_PIN)` high. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace this code with the following to toggle the state of `PA5` and create
    a blinking effect:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`main.c` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s go back to our project folder and access the `2_RegisterManipulation/Debug`
    directory through the command prompt. This specific folder is important because
    it’s where STM32CubeIDE automatically places the project’s `makefile`. Understanding
    the role and structure of **makefiles** is crucial in embedded firmware development,
    and we will delve into this topic in more detail in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the folder through the command prompt in multiple ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows users can choose between these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2_RegisterManipulation/Debug` folder in Windows Explorer. Once there, hold
    down the *Shift* key, right-click in an empty space within the folder, and select
    `Debug` folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2_RegisterManipulation/Debug` folder and then copy the folder path. Then,
    open Command Prompt from the `cmd` in the `cd` (note the space after ‘cd’), paste
    the copied path, and press *Enter*. This will change the directory to the `Debug`
    folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Users of other operating systems can choose between these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the folder, and open the terminal specific to your operating system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `cd` (change directory) command, followed by the absolute path to the
    `2_RegisterManipulation/Debug` folder to navigate to it. The exact path may vary,
    based on where the project is located on your system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.6: Accessing the Debug folder through the Windows Command Prompt](img/B21914_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Accessing the Debug folder through the Windows Command Prompt'
  prefs: []
  type: TYPE_NORMAL
- en: In this practical exercise, we’ll replicate the commands used by STM32CubeIDE,
    extracting them directly from its console pane. We’ll execute them one by one,
    as depicted in *Figure 3**.5*, starting with line number 2 (since our current
    focus isn’t on makefiles).
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy line number 2 from the STM32CubeIDE console pane and paste it into the
    command prompt. This line compiles the startup file using `arm-none-eabi-gcc`,
    referencing paths specific to my system setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: syscalls.c and system.c files, respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will proceed to link these files. To do this, copy the linking command,
    which is on line number 6 in the STM32CubeIDE console pane, and paste it into
    the command prompt, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To execute this, copy line number 8 from the STM32CubeIDE console pane and
    paste it into the command prompt. Running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It will display the size details of the `.``elf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: Output produced by executing the arm-none-eabi-size command](img/B21914_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Output produced by executing the arm-none-eabi-size command'
  prefs: []
  type: TYPE_NORMAL
- en: Observing the results, we can confirm that the output matches exactly what is
    displayed in the STM32CubeIDE console pane.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we can choose to convert our `.elf` file into the `.bin` format
    using the `arm-none-eabi-objcopy` tool, with the appropriate flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following in the command prompt and press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-O binary` specifies the output format, which in this case is a binary file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2_RegisterManipulation.elf` is the source ELF file you are converting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2_RegisterManipulation.bin` is the name of the output binary file that will
    be created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This final step marks the completion of our first build process. We have successfully
    compiled and linked all necessary files, resulting in the creation of our final
    executable in two formats. The next process involves uploading the firmware to
    our microcontroller using *OpenOCD*. This will be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading firmware to the microcontroller using OpenOCD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`2_RegisterManipulation` executable file into our microcontroller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by locating the correct OpenOCD script for our development board.
    OpenOCD comes with a variety of scripts, each tailored to different microcontrollers
    and development boards. In our case, the focus is on the **st_nucleo_f4 series**.
    To find the right script, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the OpenOCD installation directory, typically found in the `Program
    Files` folder for Windows users. The OpenOCD folder is usually named `xpack-openocd`.
    Once there, enter the `openocd` subfolder, then the `scripts` subfolder, and finally,
    the `board` subfolder. You will find a file named `st_nucleo_f4.cfg`; this is
    the OpenOCD file we have to execute for our NUCLEO-F4 development board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To launch OpenOCD, connect your development board, open the command prompt
    window, and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a snippet of the output from the command prompt after executing the
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: OpenOCD’s first output](img/B21914_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: OpenOCD’s first output'
  prefs: []
  type: TYPE_NORMAL
- en: 'The information presented here includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`6666` for Tcl connections and port `4444` for Telnet connections. These ports
    are used to send commands to OpenOCD and interact with it during debugging sessions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processor and debug capabilities**: The debugger has identified the Cortex-M4
    r0p1 processor in the STM32F4 series microcontroller. Additionally, it notes that
    the target has six breakpoints and four watchpoints, which are crucial for setting
    breakpoints and watchpoints during debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3333`. This server allows a **GDB** (**GNU Debugger**) client to connect for
    debugging purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With OpenOCD running, the next step involves using the GDB to upload the firmware
    to the microcontroller. Let’s access another command prompt window, still from
    the Debug folder (as OpenOCD should keep running in the first one), and enter
    the following command to start the GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the GDB is open, we establish a connection to the microcontroller by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command connects GDB to the OpenOCD server running on the local machine
    (`localhost`) on port `3333`, which is the default port for OpenOCD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon executing this command, both command prompt windows return outputs telling
    us that debugging has started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: Output from the command prompt window running the GDB](img/B21914_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Output from the command prompt window running the GDB'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the output from the command prompt window running `st_nucleo_f4.cfg`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: Output from the command prompt window running st_nucleo_f4.cfg](img/B21914_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Output from the command prompt window running st_nucleo_f4.cfg'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before loading the firmware, we have to reset and initialize the board using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the command into its components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`monitor`: This prefix is used in the GDB to indicate that the following command
    is not a GDB command but is meant for the debugging server (in this case, OpenOCD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset`: This part of the command instructs OpenOCD to reset the target device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init`: This tells OpenOCD to execute its initialization sequence for the target
    device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we load the firmware onto the microcontroller using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This command erases the existing firmware on the microcontroller and writes
    the new firmware (in this case, `2_RegisterManipulation.elf`) onto it. This command
    erases the existing firmware on the microcontroller and writes the new firmware
    (in this case, `2_RegisterManipulation.elf`) onto it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flash write_image`: This is an OpenOCD command that tells it to write an image
    to the flash memory of the target microcontroller – in effect, programming the
    microcontroller with a new firmware image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`erase`: This option tells OpenOCD to erase the flash memory before writing
    the new image. Erasing the flash is a common requirement in microcontroller programming,
    as it clears any previous program and ensures that the new firmware is written
    to a clean memory space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After successfully loading the firmware, we reset the board again with the same
    `reset` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we resume the execution of the code on the microcontroller with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Voila! The firmware should now be running on the microcontroller. You should
    see the LED on the board blinking, indicating the successful upload and execution
    of the new firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the intricacies of the embedded firmware build
    process, with a specific focus on the GNU Toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: We began by getting to know the embedded build process, exploring its multiple
    stages – pre-processing, compilation, assembly, linking, and locating. Each stage
    was analyzed, clarifying its significance in transforming human-readable source
    code into executable machine instructions. We delved into the roles of pre-processing
    in preparing code, the nuances of compilation and assembly in translating and
    converting code, and the intricate tasks of linking and locating in forming a
    cohesive, executable binary.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to practical application, the chapter introduced the GNU Binary
    Tools for Embedded Systems. By revisiting our previously developed bare-metal
    GPIO driver, we observed the build commands executed by the STM32CubeIDE, replicating
    these steps manually using our command-line interface. This approach gave us a
    deeper appreciation of the underlying processes and commands that IDEs automate.
    In the latter part of the chapter, we went through the step-by-step process of
    uploading our firmware to the microcontroller using OpenOCD, from locating the
    correct OpenOCD script for the development board to executing commands to reset,
    initialize, and run the firmware on the microcontroller. This practical exercise
    demonstrated the successful application of the theoretical knowledge we gained
    earlier, marking a significant milestone in our journey.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we shall learn how to write our own linker scripts and
    startup files. This important step will represent another significant milestone
    in our journey toward mastering the art of developing entirely bare-metal firmware
    from the ground up.
  prefs: []
  type: TYPE_NORMAL
