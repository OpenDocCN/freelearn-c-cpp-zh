- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Basic Libraries and Tools
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础库和工具
- en: LLVM is written in the C++ language and, as of July 2022, it uses the C++17
    version of the C++ standard [[6](B19722_Bib.xhtml#Xllvm_cpp17migration)]. LLVM
    actively utilizes functionality provided by the **Standard Template Library (STL)**.
    On the other hand, LLVM contains numerous internal implementations [[13](B19722_Bib.xhtml#Xllvm_programmer_manual)]
    for fundamental containers, primarily aimed at optimizing performance. For example,
    `llvm``::``SmallVector` has an interface similar to `std``::``vector` but features
    an internally optimized implementation. Hence, familiarity with these extensions
    is essential for anyone wishing to work with LLVM and Clang.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 使用 C++ 语言编写，截至 2022 年 7 月，它使用的是 C++17 版本的 C++ 标准 [[6](B19722_Bib.xhtml#Xllvm_cpp17migration)]。LLVM
    主动利用 **标准模板库 (STL)** 提供的功能。另一方面，LLVM 包含了许多针对基本容器的内部实现 [[13](B19722_Bib.xhtml#Xllvm_programmer_manual)]，主要目的是优化性能。例如，`llvm::SmallVector`
    具有与 `std::vector` 类似的接口，但具有内部优化的实现。因此，熟悉这些扩展对于希望与 LLVM 和 Clang 一起工作的人来说是必不可少的。
- en: 'Additionally, LLVM has introduced other development tools such as **TableGen**,
    a **domain specific language** (**DSL**) designed for structural data processing,
    and **LIT** (LLVM Integrated Tester), the LLVM test framework. More details about
    these tools are discussed later in this chapter. We’ll cover the following topics
    in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，LLVM 还引入了其他开发工具，如 **TableGen**，这是一个用于结构数据处理 **领域特定语言 (DSL**)，以及 **LIT**（LLVM
    集成测试器），LLVM 测试框架。关于这些工具的更多细节将在本章后面讨论。本章将涵盖以下主题：
- en: LLVM coding style
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 编码风格
- en: LLVM basic libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 基础库
- en: Clang basic libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 基础库
- en: LLVM supporting tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 支持工具
- en: Clang plugin project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 插件项目
- en: We plan to use a simple example project to demonstrate these tools. This project
    will be a Clang plugin that estimates the complexity of C++ classes. A class is
    considered complex if the number of methods exceeds a threshold specified as a
    parameter. While this definition of complexity may be considered trivial, we will
    explore more advanced definitions of complexity later in [*Chapter** 6*](B19722_06.xhtml#x1-1170006)*,
    Advanced* *Code Analysis*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划使用一个简单的示例项目来展示这些工具。该项目将是一个 Clang 插件，用于估计 C++ 类的复杂度。如果一个类的函数数量超过作为参数指定的阈值，则认为该类是复杂的。虽然这种复杂性的定义可能被认为是微不足道的，但我们将在
    [*第 6 章*](B19722_06.xhtml#x1-1170006) *高级代码分析* 中探讨更复杂的复杂性定义。
- en: 4.1 Technical requirements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 技术要求
- en: 'The source code for this chapter is located in the `chapter4` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter4](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter4).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于本书 GitHub 仓库的 `chapter4` 文件夹中：[https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter4](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter4)。
- en: 4.2 LLVM coding style
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 LLVM 编码风格
- en: LLVM adheres to specific code-style rules [[11](B19722_Bib.xhtml#Xllvm_coding_standards)].
    The primary objective of these rules is to promote proficient C++ practices with
    a special focus on performance. As previously mentioned, LLVM employs C++17 and
    prefers using data structures and algorithms from the **STL** (short for, **Standard
    Template** **Library**). On the other hand, LLVM offers many optimized versions
    of data structures that mirror those in the STL. For example, `llvm``::``SmallVector``<>`
    can be regarded as an optimized version of `std``::``vector``<>`, especially for
    small sizes of the vector, a common trait for data structures used in compilers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 遵循特定的代码风格规则 [[11](B19722_Bib.xhtml#Xllvm_coding_standards)]。这些规则的主要目标是促进熟练的
    C++ 实践，特别关注性能。如前所述，LLVM 使用 C++17 并倾向于使用 **STL**（即 **标准模板库**）中的数据结构和算法。另一方面，LLVM
    提供了许多与 STL 中类似的数据结构的优化版本。例如，`llvm::SmallVector<>` 可以被视为 `std::vector<>` 的优化版本，尤其是在向量大小较小时，这是编译器中使用的数据结构的一个常见特性。
- en: Given a choice between an STL object/algorithm and its corresponding LLVM version,
    the LLVM coding standard advises favoring the LLVM version.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择 STL 对象/算法及其对应的 LLVM 版本之间，LLVM 编码标准建议优先选择 LLVM 版本。
- en: Additional rules pertain to concerns regarding performance limitations. For
    instance, both **run-time type information (RTTI)** and C++ exceptions are disallowed.
    However, there are situations where RTTI could prove beneficial; thus, LLVM offers
    alternatives such as `llvm``::``isa``<>` and other similar template helper functions.
    More information on this can be found in [*Section** 4.3.1*](#x1-720001)*, RTTI*
    *replacement and cast operators*. Instead of C++ exceptions, LLVM frequently employs
    C-style `assert`s.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其他规则与性能限制相关的问题有关。例如，**运行时类型信息 (RTTI)** 和 C++ 异常都是不允许的。然而，在某些情况下，RTTI 可能会证明是有益的；因此，LLVM
    提供了如 `llvm::isa<>` 和其他类似模板辅助函数的替代方案。更多关于此的信息可以在[*第 4.3.1 节*](#x1-720001)*，RTTI
    替换和转换运算符*中找到。而不是使用 C++ 异常，LLVM 经常使用 C 风格的 `assert`s。
- en: 'Sometimes, asserts are not sufficiently informative. LLVM recommends adding
    textual messages to them to simplify debugging. Here’s a typical example from
    Clang’s code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，断言信息不足。LLVM 建议向它们添加文本消息以简化调试。以下是从 Clang 代码中的一个典型示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Figure 4.1**: Usage of assert() in clang/lib/AST/ASTContext.cpp'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.1**：在 clang/lib/AST/ASTContext.cpp 中的 assert() 使用'
- en: In the code, we check if the second parameter (`RD`) is a union and raise an
    assert with a corresponding message if it’s not.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们检查第二个参数（`RD`）是否为联合类型，如果不是，则抛出一个带有相应信息的断言。
- en: Besides performance considerations, LLVM also introduces some additional requirements.
    One of these requirements concerns comments. Code comments are very important.
    Furthermore, both LLVM and Clang have comprehensive documentation generated from
    the code. They use Doxygen ( [https://www.doxygen.nl/](https://www.doxygen.nl/))
    for this purpose. This tool is the de facto standard for commenting in C/C++ programs,
    and you have most likely encountered it before.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性能考虑之外，LLVM 还引入了一些额外的要求。其中之一是关于注释的要求。代码注释非常重要。此外，LLVM 和 Clang 都有从代码生成的全面文档。他们使用
    Doxygen ([https://www.doxygen.nl/](https://www.doxygen.nl/)) 来实现这一点。这个工具是 C/C++
    程序注释的事实标准，你很可能之前已经遇到过它。
- en: Clang and LLVM are not monolithic pieces of code; instead, they are implemented
    as a set of libraries. This design provides advantages in terms of code and functionality
    reuse, as we will explore in [*Chapter** 8*](B19722_08.xhtml#x1-1520008)*, IDE
    Support and* *Clangd*. These libraries also serve as excellent examples of LLVM
    code style enforcement. Let’s examine these libraries in detail.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 和 LLVM 不是单一的大块代码；相反，它们被实现为一组库。这种设计在代码和功能重用方面提供了优势，我们将在[*第 8 章*](B19722_08.xhtml#x1-1520008)*，IDE
    支持和 Clangd*中探讨这些优势。这些库也是 LLVM 代码风格执行的优秀示例。让我们详细检查这些库。
- en: 4.3 LLVM basic libraries
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 LLVM 基本库
- en: We are going to start with RTTI replacement in the LLVM code and discuss how
    it’s implemented. We will then continue with basic containers and smart pointers.
    We will conclude with some important classes used to represent token locations
    and how diagnostics are realized in Clang. Later, in [*Section** 4.6*](#x1-840006)*,
    Clang plugin project*, we will use some of these classes in our test project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 LLVM 代码中的 RTTI 替换开始，讨论其实现方式。然后，我们将继续讨论基本容器和智能指针。最后，我们将讨论一些用于表示标记位置的重要类以及
    Clang 中诊断的实现方式。稍后，在[*第 4.6 节*](#x1-840006)*，Clang 插件项目*中，我们将在我们的测试项目中使用这些类。
- en: 4.3.1 RTTI replacement and cast operators
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 RTTI 替换和转换运算符
- en: 'As mentioned earlier, LLVM avoids using RTTI due to performance concerns. LLVM
    has introduced several helper functions that replace RTTI counterparts, allowing
    for the casting of an object from one type to another. The fundamental ones are
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，LLVM 由于性能考虑而避免使用 RTTI。LLVM 引入了几种辅助函数来替代 RTTI 对应的函数，允许将对象从一个类型转换为另一个类型。基本的有以下几种：
- en: '`llvm``::``isa``<>` is akin to Java’s `java`instanceof operator. It returns
    `true` or `false` depending on whether the reference to the tested object belongs
    to the tested class or not.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm::isa<>` 类似于 Java 的 `java instanceof` 运算符。它根据测试对象的引用是否属于测试的类返回 `true`
    或 `false`。'
- en: '`llvm``::``cast``<>`: Use this cast operator when you’re certain that the object
    is of the specified derived type. If the cast fails (i.e., the object isn’t of
    the expected type), `llvm``::``cast` will abort the program. Use it only when
    you’re confident the cast won’t fail.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm::cast<>`：当你确定对象是特定派生类型时，使用此转换运算符。如果转换失败（即对象不是预期的类型），`llvm::cast` 将终止程序。仅在确信转换不会失败时使用。'
- en: '`llvm``::``dyn_cast``<>`: This is perhaps the most frequently used casting
    operator in LLVM. `llvm``::``dyn_cast` is employed for safe downcasting when you
    anticipate the cast will usually succeed, but there’s some uncertainty. If the
    object isn’t of the specified derived type, `llvm``::``dyn_cast``<>` returns `nullptr`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm``::``dyn_cast``<>`: 这可能是LLVM中最常用的类型转换运算符。`llvm``::``dyn_cast` 用于在预期转换通常成功但存在一些不确定性的情况下进行安全的向下转换。如果对象不是指定的派生类型，`llvm``::``dyn_cast``<>`
    返回 `nullptr`。'
- en: 'The cast operators do not accept `nullptr` as input. However, there are two
    special cast operators that can handle null pointers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换运算符不接受 `nullptr` 作为输入。然而，有两个特殊的类型转换运算符可以处理空指针：
- en: '`llvm``::``cast_if_present``<>`: A variant of `llvm``::``cast``<>` that accepts
    `nullptr` values'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm``::``cast_if_present``<>`: `llvm``::``cast``<>` 的一个变体，接受 `nullptr` 值'
- en: '`llvm``::``dyn_cast_if_present``<>`: A variant of `llvm``::``dyn_cast``<>`
    that accepts `nullptr` values'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm``::``dyn_cast_if_present``<>`: `llvm``::``dyn_cast``<>` 的一个变体，接受 `nullptr`
    值'
- en: Both operators can handle `nullptr` values. If the input is `nullptr` or if
    the cast fails, they simply return `nullptr`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个运算符都可以处理 `nullptr` 值。如果输入是 `nullptr` 或转换失败，它们将简单地返回 `nullptr`。
- en: Important note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'It’s worth noting that the casting operators `llvm``::``cast_if_present``<>`
    and `llvm``:` `:``dyn_cast_if_present``<>` were introduced recently, specifically
    in 2022\. They serve as replacements for popular ones `llvm``::``cast_or_null``<>`
    and `llvm``::``dyn_cast_or` `_null``<>`, which had been in recent use. The older
    versions are still supported and now redirect calls to the newer cast operators.
    For more information, see the discussion about this change: [https://discourse.llvm.org/t/psa-swapping-out-or-null-with-if-present/65018](https://discourse.llvm.org/t/psa-swapping-out-or-null-with-if-present/65018)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，类型转换运算符 `llvm``::``cast_if_present``<>` 和 `llvm``:` `:``dyn_cast_if_present``<>`
    是最近引入的，具体是在2022年。它们作为流行的 `llvm``::``cast_or_null``<>` 和 `llvm``::``dyn_cast_or`
    `_null``<>` 的替代品，后者最近已被使用。旧版本仍然得到支持，并且现在将调用重定向到新的类型转换运算符。有关更多信息，请参阅关于此更改的讨论：[https://discourse.llvm.org/t/psa-swapping-out-or-null-with-if-present/65018](https://discourse.llvm.org/t/psa-swapping-out-or-null-with-if-present/65018)
- en: .
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: 'The following question might arise: how can the dynamic cast operation be performed
    without RTTI? This can be achieved with certain specific decorations, as illustrated
    in a simple example inspired by *How to set up* *LLVM-style RTTI for your class
    hierarchy* [[14](B19722_Bib.xhtml#Xllvm_rtti_setup)]. We’ll begin with a base
    class, `clangbook``::``Animal`, that has two descendants: `clangbook``::``Horse`
    and `clangbook``::``Sheep`. Each horse can be categorized by its speed (in mph),
    and each sheep by its wool mass. Here’s how it can be used:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会提出以下问题：如何在没有RTTI的情况下执行动态转换操作？这可以通过某些特定的装饰来实现，如下面一个简单的例子所示，该例子受到 *如何为你的类层次结构设置*
    *LLVM风格的RTTI* [[14](B19722_Bib.xhtml#Xllvm_rtti_setup)] 的启发。我们将从一个基类 `clangbook``::``Animal`
    开始，该类有两个派生类：`clangbook``::``Horse` 和 `clangbook``::``Sheep`。每匹马可以通过其速度（英里/小时）进行分类，而每只羊可以通过其羊毛质量进行分类。以下是它的用法：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Figure 4.2**: LLVM `isa``<>` and `dyn_cast``<>` usage example'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.2**: LLVM `isa``<>` 和 `dyn_cast``<>` 使用示例'
- en: 'The code should produce the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应生成以下输出：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Line 48* in [Figure 4.2](#x1-72015r2) demonstrates the use of `llvm``::``isa``<>`,
    while *Line 51* showcases `llvm``::``dyn_cast``<>`. In the latter, we cast the
    base class to `clangbook``::``Horse` and call a method specific to that class.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.2](#x1-72015r2) 中的 *第48行* 展示了 `llvm``::``isa``<>` 的用法，而 *第51行* 展示了 `llvm``::``dyn_cast``<>`
    的用法。在后一个例子中，我们将基类转换为 `clangbook``::``Horse` 并调用该类特定的方法。'
- en: 'Let’s look into the class implementations, which will provide insights into
    how the RTTI replacement works. We will start with the base class `clangbook``::``Animal`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看类实现，这将提供关于RTTI替换如何工作的见解。我们将从基类 `clangbook``::``Animal` 开始：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Figure 4.3**: `clangbook``::``Animal` class'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.3**: `clangbook``::``Animal` 类'
- en: 'The most crucial aspect is *Line 11* in the preceding code. It specifies different
    ”kinds” of animals. One enum value is used for the horse (`AK_Horse`) and another
    for the sheep (`AK_Sheep`). Hence, the base class has some knowledge about its
    descendants. The implementations for the `clangbook``::``Horse` and `clangbook``::``Sheep`
    classes can be found in the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最关键的部分是前面代码中的 *第11行*。它指定了不同的 ”种类” 的动物。一个枚举值用于马 (`AK_Horse`)，另一个用于羊 (`AK_Sheep`)。因此，基类对其派生类有一些了解。`clangbook``::``Horse`
    和 `clangbook``::``Sheep` 类的实现可以在以下代码中找到：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Figure 4.4**: `clangbook``::``Horse` and `clangbook``::``Sheep` classes'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.4**: `clangbook``::``Horse` 和 `clangbook``::``Sheep` 类'
- en: '*Lines 25 and 37* are particularly important as they contain the `classof`
    static method implementation. This method is crucial for the cast operators in
    LLVM. A typical implementation might look like the following (simplified version):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 25 行和第 37 行* 特别重要，因为它们包含了 `classof` 静态方法实现。这个方法对于 LLVM 中的类型转换操作至关重要。一个典型的实现可能看起来像以下（简化版本）：'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Figure 4.5**: Simplified implementation for `llvm``::``isa``<>`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.5**：`llvm::isa<>` 的简化实现'
- en: The same mechanism can be applied to other cast operators.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的机制可以应用于其他类型转换操作。
- en: Our next topic will discuss various types of containers that serve as more powerful
    alternatives to their corresponding STL counterparts.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将讨论各种类型的容器，它们是相应 STL 对应容器的更强大的替代品。
- en: 4.3.2 Containers
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 容器
- en: The LLVM ADT (which stands for Abstract Data Type) library offers a set of containers.
    While some of them are unique to LLVM, others can be considered as replacements
    for containers from the STL. We will explore some of the most popular classes
    provided by the ADT.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM ADT（代表抽象数据类型）库提供了一套容器。虽然其中一些是 LLVM 独有的，但其他一些可以被认为是 STL 容器的替代品。我们将探讨 ADT
    提供的一些最受欢迎的类。
- en: String operations
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串操作
- en: The primary class for working with strings in the standard C++ library is `std``::``string`.
    Although this class was designed to be universal, it has some performance related
    issues. A significant issue concerns the copy operation. Since copying strings
    is a common operation in compilers, LLVM introduced a specialized class, `llvm``::``StringRef`,
    that handles this operation efficiently without using extra memory. This class
    is comparable to `std``::``string_view` from C++17 [[20](B19722_Bib.xhtml#Xstandard_cpp17)]
    and `std``::``span` from C++20 [[21](B19722_Bib.xhtml#Xstandard_cpp20)].
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准 C++ 库中，用于处理字符串的主要类是 `std::string`。尽管这个类被设计成通用的，但它有一些与性能相关的问题。一个重要的问题涉及到复制操作。由于在编译器中复制字符串是一个常见的操作，LLVM
    引入了一个专门的类，`llvm::StringRef`，它以高效的方式处理这个操作，而不使用额外的内存。这个类与 C++17 中的 `std::string_view`
    [[20](B19722_Bib.xhtml#Xstandard_cpp17)] 和 C++20 中的 `std::span` [[21](B19722_Bib.xhtml#Xstandard_cpp20)]
    相当。
- en: 'The `llvm``::``StringRef` class maintains a reference to data, which doesn’t
    need to be null-terminated like traditional C/C++ strings. It essentially holds
    a pointer to a data block and the block’s size, making the object’s effective
    size 16 bytes. Because `llvm``::``StringRef` retains a reference rather than the
    actual data, it must be constructed from an existing data source. This class can
    be instantiated from basic string objects such as `const` `char``*`, `std``::``string`,
    and `std``::``string_view`. The default constructor creates an empty object. Typical
    usage example for `llvm``::``StringRef` is shown in [Figure 4.6](#x1-74011r6):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm::StringRef` 类维护对数据的引用，不需要像传统的 C/C++ 字符串那样以空字符终止。它本质上持有指向数据块的指针和块的大小，使得对象的有效大小为
    16 字节。由于 `llvm::StringRef` 保留的是引用而不是实际数据，它必须从一个现有的数据源构建。这个类可以从基本字符串对象，如 `const
    char*`、`std::string` 和 `std::string_view` 实例化。默认构造函数创建一个空对象。`llvm::StringRef`
    的典型使用示例在 [图 4.6](#x1-74011r6) 中展示：'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Figure 4.6**: `llvm``::``StringRef` usage example'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.6**：`llvm::StringRef` 使用示例'
- en: 'The output for the code is shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another class used for string manipulation in LLVM is `llvm``::``Twine`, which
    is particularly useful when concatenating several objects into one. A typical
    usage example for the class is shown in [Figure 4.7](#x1-74024r7):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 中用于字符串操作的另一类是 `llvm::Twine`，它在将多个对象连接成一个对象时特别有用。该类的典型使用示例在 [图 4.7](#x1-74024r7)
    中展示：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Figure 4.7**: `llvm``::``Twine` usage example'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.7**：`llvm::Twine` 使用示例'
- en: 'The output for the code is shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下所示：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another class that is widely used for string manipulations is `llvm``::``SmallString``<>`.
    It represents a string that is stack-allocated up to a fixed size, but can also
    grow beyond this size, at which point it heap-allocates memory. This is a blend
    between the space efficiency of stack allocation and the flexibility of heap allocation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个广泛用于字符串操作的类是 `llvm::SmallString<>`。它表示一个堆栈分配的字符串，大小固定，但也可以超出这个大小，此时它会堆分配内存。这是堆栈分配的空间效率和堆分配的灵活性之间的结合。
- en: 'The advantage of `llvm``::``SmallString``<>` is that for many scenarios, especially
    in compiler tasks, strings tend to be small and fit within the stack-allocated
    space. This avoids the overhead of dynamic memory allocation. But in situations
    where a larger string is required, `llvm::SmallString` can still accommodate by
    transitioning to heap memory. A typical usage example is show in [Figure 4.8](#x1-74038r8):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm::SmallString<>`的优势在于，在许多场景中，尤其是在编译器任务中，字符串往往很小，可以适应栈分配的空间。这避免了动态内存分配的开销。但在需要更大字符串的情况下，`llvm::SmallString`仍然可以通过切换到堆内存来容纳。一个典型的使用示例显示在[图4.8](#x1-74038r8)中：'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Figure 4.8**: `llvm``::``SmallString``<>` usage example'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.8**：`llvm::SmallString<>`使用示例'
- en: Despite the fact that string manipulation is key in compiler tasks such as text
    parsing, LLVM has many other helper classes. We’ll explore its sequential containers
    next.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管字符串操作在文本解析等编译器任务中至关重要，但LLVM还有许多其他辅助类。我们将接下来探讨其顺序容器。
- en: Sequential containers
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顺序容器
- en: 'LLVM recommends some optimized replacements for arrays and vectors from the
    standard library. The most notable are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM推荐一些针对标准库中的数组和向量的优化替代方案。最显著的是：
- en: '`llvm``::``ArrayRef``<>`: A helper class designed for interfaces that accept
    a sequential list of elements for read-only access. The class is akin to `llvm``::``StringRef``<>`
    in that it does not own the underlying data but merely references it.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm::ArrayRef<>`：一个为接受元素顺序列表进行只读访问的接口设计的辅助类。该类类似于`llvm::StringRef<>`，因为它不拥有底层数据，而只是引用它。'
- en: '`llvm``::``SmallVector``<>`: An optimized vector for cases with a small size.
    It resembles `llvm``::``SmallString`, as discussed in [*Section** 4.3.2*](#x1-740002)*,*
    *String operations*. Notably, the size for the array isn’t fixed, allowing the
    number of stored elements to grow. If the number of elements stays below `N` (the
    template argument), then there is no need for additional memory allocation.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm::SmallVector<>`：一种针对小尺寸情况的优化向量。它类似于在[*第4.3.2节*](#x1-740002)*，*字符串操作*中讨论的`llvm::SmallString`。值得注意的是，数组的大小不是固定的，允许存储的元素数量增长。如果元素数量保持在`N`（模板参数）以下，则不需要额外的内存分配。'
- en: 'Let’s examine the `llvm``::``SmallVector``<>` to better understand these containers,
    as shown in [Figure 4.9](#x1-75010r9):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过[图4.9](#x1-75010r9)来检查`llvm::SmallVector<>`，以更好地理解这些容器：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Figure 4.9**: `llvm``::``SmallVector``<>` usage'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.9**：`llvm::SmallVector<>`使用'
- en: The vector is initialized at *Line 1* with a chosen size of 10 (indicated by
    the second template argument). The container offers an API similar to `std``::``vector``<>`,
    using the familiar `push_back` method to add new elements, as seen in [Figure 4.9](#x1-75010r9),
    *Lines 3 and 5.*
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 向量在*行1*初始化，选择了大小为10（由第二个模板参数指示）。该容器提供了一个类似于`std::vector<>`的API，使用熟悉的`push_back`方法添加新元素，如[图4.9](#x1-75010r9)，*行3和5*所示。
- en: The first 10 elements are added to the vector without any additional memory
    allocation (see [Figure 4.9](#x1-75010r9), *Lines 2-4*). However, when the eleventh
    element is added at *Line 5*, the array’s size surpasses the pre-allocated space
    for 10 elements, triggering additional memory allocation. This container design
    efficiently minimizes memory allocation for small objects
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前十个元素被添加到向量中，而不需要额外的内存分配（参见[图4.9](#x1-75010r9)，*行2-4*）。然而，当第11个元素在*行5*被添加时，数组的大小超过了为10个元素预先分配的空间，从而触发了额外的内存分配。这种容器设计有效地最小化了小对象的内存分配。
- en: while maintaining the flexibility to accommodate larger sizes when necessary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同时保持灵活性，以便在必要时容纳更大的大小。
- en: Map-like containers
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类似于映射的容器
- en: 'The standard library provides several containers for storing key-value data.
    The most common ones are `std``::``map``<>` for general-purpose maps and `std``::``unordered_map``<>`
    for hash maps. LLVM offers additional alternatives to these standard containers:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了几个用于存储键值数据的容器。最常见的是`std::map<>`用于通用映射和`std::unordered_map<>`用于哈希映射。LLVM为这些标准容器提供了额外的替代方案：
- en: '`llvm``::``StringMap``<>`: A map that uses strings as keys. Typically, this
    is more performance optimized than the standard associative container, `std``::``unordered_map``<``std``::``string``,`
    `T``>`. It is frequently used in situations where string keys are dominant and
    performance is critical, as one might expect in a compiler infrastructure like
    LLVM. Unlike many other data structures in LLVM, `llvm``::``StringMap``<>` does
    not store a copy of the string key. Instead, it keeps a reference to the string
    data, so it’s crucial to ensure the string data outlives the map to prevent undefined
    behavior.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm``::``StringMap``<>`: 使用字符串作为键的映射。通常，这比标准的关联容器 `std``::``unordered_map``<``std``::``string``,`
    `T``>` 性能优化得更好。它常用于字符串键占主导地位且性能至关重要的场景，例如在LLVM这样的编译器基础设施中。与LLVM中的许多其他数据结构不同，`llvm``::``StringMap``<>`
    不存储字符串键的副本。相反，它保留对字符串数据的引用，因此确保字符串数据比映射存在的时间长是防止未定义行为的关键。'
- en: '`llvm``::``DenseMap``<>`: This map is designed to be more memory- and time-efficient
    than `std``::``unordered_map``<>` in most situations, though it comes with some
    additional constraints (e.g., keys and values having trivial destructors). It’s
    especially beneficial when you have simple key-value types and require high-performance
    lookups.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm``::``DenseMap``<>`: 这个映射在大多数情况下比 `std``::``unordered_map``<>` 更节省内存和时间，尽管它带来了一些额外的限制（例如，键和值具有平凡的析构函数）。当你有简单的键值类型并且需要高性能的查找时，它特别有益。'
- en: '`llvm``::``SmallDenseMap``<>`: This map is akin to `llvm``::``DenseMap``<>`
    but is optimized for instances where the map size is typically small. It allocates
    from the stack for small maps and only resorts to heap allocation when the map
    exceeds a predefined size.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm``::``SmallDenseMap``<>`: 这个映射类似于 `llvm``::``DenseMap``<>`，但针对映射大小通常较小的情况进行了优化。对于小映射，它从栈上分配，只有当映射超过预定义大小时才回退到堆分配。'
- en: '`llvm``::``MapVector``<>`: This container retains the insertion order, akin
    to Python’s `OrderedDict` . It is implemented as a blend of `std``::``vector`
    and either `llvm``::``DenseMap` or `llvm``::``SmallDenseMap`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llvm``::``MapVector``<>`: 这个容器保留了插入顺序，类似于Python的 `OrderedDict`。它实现为 `std``::``vector`
    和 `llvm``::``DenseMap` 或 `llvm``::``SmallDenseMap` 的混合。'
- en: It’s noteworthy that these containers utilize a quadratically probed hash table
    mechanism. This method is effective for hash collision resolution because the
    cache isn’t recomputed during element lookups. This is crucial for performance-critical
    applications, such as compilers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这些容器使用的是二次探测的哈希表机制。这种方法在解决哈希冲突时非常有效，因为在查找元素时不会重新计算缓存。这对于性能关键的应用程序，如编译器来说至关重要。
- en: 4.3.3 Smart pointers
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 智能指针
- en: 'Different smart pointers can be found in LLVM code. The most popular ones come
    from the standard template library: `std``::``unique_ptr``<>` and `std``::``shared_ptr``<>`.
    In addition, LLVM provides some supplementary classes to work with smart pointers.
    One of the most prominent among them is `llvm``::``IntrusiveRefCntPtr``<>`. This
    smart pointer is designed to work with objects that support intrusive reference
    counting. Unlike `std``::``shared_ptr`, which maintains its own control block
    to manage the reference count, `IntrusiveRefCntPtr` expects the object to maintain
    its own reference count. This design can be more memory efficient. A typical usage
    example is shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM代码中可以找到不同的智能指针。最受欢迎的是来自标准模板库的：`std``::``unique_ptr``<>` 和 `std``::``shared_ptr``<>`。此外，LLVM提供了一些辅助类来与智能指针一起使用。其中最突出的是
    `llvm``::``IntrusiveRefCntPtr``<>`。这个智能指针旨在与支持侵入式引用计数的对象一起使用。与维护自己的控制块以管理引用计数的
    `std``::``shared_ptr` 不同，`IntrusiveRefCntPtr` 预期对象维护自己的引用计数。这种设计可以更节省内存。这里展示了典型的使用示例：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Figure 4.10**: `llvm``::``IntrusiveRefCntPtr``<>` usage example'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.10**: `llvm``::``IntrusiveRefCntPtr``<>` 使用示例'
- en: 'As we can see, the smart pointer prominently employs the CRTP (which stands
    for Curiously Recurring Template Pattern) that was mentioned earlier in [*Section** 3.3*](B19722_03.xhtml#x1-590003)*,
    AST traversal*. The CRTP is essential for the `Release` operation when the reference
    count drops to 0 and the object must be deleted. The implementation is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，智能指针显著地使用了前面在 [*第3.3节*](B19722_03.xhtml#x1-590003) 中提到的 CRTP（Curiously
    Recurring Template Pattern），即 AST 遍历。CRTP 对于当引用计数降至0且对象必须被删除时的 `Release` 操作至关重要。实现如下：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Figure 4.11**: CRTP usage in `llvm``::``RefCountedBase``<>`. The code was
    sourced from the `llvm/ADT/IntrusiveRefCntPtr.h` header'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.11**: 在 `llvm``::``RefCountedBase``<>` 中的 CRTP 使用。代码来源于 `llvm/ADT/IntrusiveRefCntPtr.h`
    头文件'
- en: Since `MyClass` in [Figure 4.10](#x1-77008r10) is derived from `RefCountedBase`,
    we can perform a cast on it in *Line 6* of [Figure 4.11](#x1-77018r11). This cast
    is feasible since the type to cast is known, given that it is provided as a template
    parameter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 [图 4.10](#x1-77008r10) 中的 `MyClass` 是从 `RefCountedBase` 派生的，我们可以在 [图 4.11](#x1-77018r11)
    的 *第 6 行* 上对其执行类型转换。这种转换是可行的，因为已知要转换的类型，它作为模板参数提供。
- en: We’ve just finished with LLVM basic libraries. Now it is time to move on to
    Clang basic libraries. Clang is a compiler frontend, and its most important operations
    are related to diagnostics. Diagnostics require precise information about position
    location in the source code. Let’s explore the basic classes that Clang provides
    for these operations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了 LLVM 基础库。现在是我们转向 Clang 基础库的时候了。Clang 是一个编译器前端，其最重要的操作与诊断相关。诊断需要关于源代码中位置精确的信息。让我们探索
    Clang 为这些操作提供的基本类。
- en: 4.4 Clang basic libraries
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 Clang 基础库
- en: Clang is a compiler frontend, and its most important operations are related
    to diagnostics. Diagnostics require precise information about position location
    in the source code. Let’s explore the basic classes that Clang provides for these
    operations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 是一个编译器前端，其最重要的操作与诊断相关。诊断需要关于源代码中位置精确的信息。让我们探索 Clang 为这些操作提供的基本类。
- en: 4.4.1 SourceManager and SourceLocation
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 SourceManager 和 SourceLocation
- en: 'Clang, as a compiler, operates with text files (programs), and locating a specific
    place in the program is one of the most frequently requested operations. Let’s
    look at a typical Clang error report. Consider a program from [*Chapter** 3*](B19722_03.xhtml#x1-530003)*,
    Clang AST*, as seen in [Figure 3.33](B19722_03.xhtml#x1-65010r33). Clang produces
    the following error message for the program:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 作为编译器，与文本文件（程序）操作，在程序中定位特定位置是请求最频繁的操作之一。让我们看看典型的 Clang 错误报告。考虑来自 [*第 3
    章**](B19722_03.xhtml#x1-530003) 的一个程序，Clang AST，如 [图 3.33](B19722_03.xhtml#x1-65010r33)
    所示。Clang 为该程序生成以下错误消息：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Figure 4.12**: Error reported in maxerr.cpp'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.12**：maxerr.cpp 中报告的错误'
- en: 'As we can see in [Figure 4.12](#x1-79005r12), the following information is
    required to display the message:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [图 4.12](#x1-79005r12) 中所看到的，显示消息需要以下信息：
- en: 'Filename: In our case, it’s `maxerr.cpp`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名：在我们的例子中，它是`maxerr.cpp`
- en: 'Line in the file: In our case, it’s `3`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件中的行：在我们的例子中，它是`3`
- en: 'Column in the file: In our case, it’s `12`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件中的列：在我们的例子中，它是`12`
- en: The data structure that stores this information should be as compact as possible
    because the compiler uses it frequently. Clang stores the required information
    in the `clang``::``SourceLocation` object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 存储这些信息的应该尽可能紧凑，因为编译器会频繁使用它。Clang 将所需信息存储在 `clang::SourceLocation` 对象中。
- en: 'This object is used often, so it should be small in size and quick to copy.
    We can check the size of the object using lldb. For instance, if we run Clang
    under the debugger, we can determine the size as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象经常被使用，因此它应该体积小且复制速度快。我们可以使用 lldb 检查对象的大小。例如，如果我们以调试器运行 Clang，我们可以确定大小如下：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Figure 4.13**: clang::SourceLocation size determination under debugger'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.13**：在调试器下确定 clang::SourceLocation 的大小'
- en: 'That is, the information is encoded using a single `unsigned` `long` number.
    How is this possible? The number merely serves as an identifier for a position
    in the text file. An additional class is required to correctly extract and represent
    this information, which is `clang``::``SourceManager`. The `SourceManager` object
    contains all the details about a specific location. In Clang, managing source
    locations can be challenging due to the presence of macros, includes, and other
    preprocessing directives. Consequently, there are several ways to interpret a
    given source location. The primary ones are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，信息是使用单个 `unsigned` `long` 数字编码的。这是如何可能的？这个数字仅仅作为一个文本文件中位置的标识符。需要一个额外的类来正确提取和表示这些信息，即
    `clang::SourceManager`。`SourceManager` 对象包含有关特定位置的所有详细信息。在 Clang 中，由于宏、包含和其他预处理指令的存在，管理源位置可能具有挑战性。因此，有几种方式来解释给定的源位置。主要方式如下：
- en: '**Spelling location**: Refers to the location where something was actually
    spelled out in the source. If you have a source location pointing inside a macro
    body, the spelling location will give you the location in the source code where
    the contents of the macro are defined.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拼写位置**：指的是在源代码中实际拼写的地方。如果你有一个指向宏体内部的源位置，拼写位置将给出宏内容在源代码中定义的位置。'
- en: '**Expansion location**: Refers to where a macro gets expanded. If you have
    a source location pointing inside a macro body, the expansion location will give
    you the location in the source code where the macro was used (expanded).'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宏展开位置**：指宏展开的位置。如果你有一个指向宏体内部的源位置，展开位置将给出宏在源代码中被使用（展开）的位置。'
- en: 'Let’s look at a specific example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个具体的例子：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Figure 4.14**: Example program to test different types of source locations:
    functions.hpp'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.14**：测试不同类型源位置的示例程序：functions.hpp'
- en: 'In [Figure 4.14](#x1-79023r14), we define two functions: `int` `foo``()` at
    *Line 2* and `void` `bar``()` at *Line 3*. For the first function, both the spelling
    and expansion locations point to *Line 2*. However, for the second function, the
    spelling location is at *Line 1*, while the expansion location is at *Line 3*.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图4.14](#x1-79023r14) 中，我们定义了两个函数：*第2行* 的 `int foo()` 和 *第3行* 的 `void bar()`。对于第一个函数，拼写和展开位置都指向
    *第2行*。然而，对于第二个函数，拼写位置在 *第1行*，而展开位置在 *第3行*。
- en: 'Let’s examine this with a test Clang tool. We will use the test project from
    [*Section** 3.4*](B19722_03.xhtml#x1-620004)*, Recursive AST visitor* and replace
    some parts of the code here. First of all, we have to pass `clang``::``ASTContext`
    to our `Visitor` implementation. This is required because `clang``::``ASTContext`
    provides access to `clang``::``SourceManager`. We will replace *Line 11* in [Figure 3.8](B19722_03.xhtml#x1-60077r8)
    and pass `ASTContext` as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个测试 Clang 工具来检查这个问题。我们将使用 [*第3.4节*](B19722_03.xhtml#x1-620004) 中的测试项目，递归
    AST 访问器，并在此处替换一些代码部分。首先，我们必须将 `clang::ASTContext` 传递给我们的 `Visitor` 实现中。这是必需的，因为
    `clang::ASTContext` 提供了对 `clang::SourceManager` 的访问。我们将替换 [图3.8](B19722_03.xhtml#x1-60077r8)
    中的 *第11行* 并按如下方式传递 `ASTContext`：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Consumer` class (see [Figure 3.9](B19722_03.xhtml#x1-60100r9)) will accept
    the argument and use it as a parameter for `Visitor`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer` 类（参见[图3.9](B19722_03.xhtml#x1-60100r9)）将接受参数并将其用作 `Visitor` 的参数：'
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The main changes are for the `Visitor` class, which is mostly rewritten. First
    of all, we pass `clang``::``ASTContext` to the class constructor as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 主要更改针对 `Visitor` 类，该类大部分已重写。首先，我们将 `clang::ASTContext` 传递给类构造函数，如下所示：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Figure 4.15**: Visitor class implementation: constructor'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.15**：Visitor 类实现：构造函数'
- en: 'The AST Context class is stored as a private member of our class, as shown
    below:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: AST 上下文类存储为我们类的私有成员，如下所示：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Figure 4.16**: Visitor class implementation: private section'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.16**：Visitor 类实现：私有部分'
- en: The main processing logic is in `Visitor``::``VisitFunctionDecl` method, which
    you can see next
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 主要处理逻辑在 `Visitor::VisitFunctionDecl` 方法中，你可以在下面看到：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Figure 4.17**: Visitor class implementation: VisitFunctionDecl method'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.17**：Visitor 类实现：VisitFunctionDecl 方法'
- en: 'If we compile and run the code on the test file from [Figure 4.14](#x1-79023r14),
    the following output will be generated::'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 [图4.14](#x1-79023r14) 中的测试文件上编译并运行代码，将生成以下输出：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Figure 4.18**: Output from the recursivevisitor executable on the functions.hpp
    test file'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.18**：recursivevisitor 可执行程序在 functions.hpp 测试文件上的输出'
- en: '`clang``::``SourceLocation` and `clang``::``SourceManager` are very powerful
    classes. In combination with other classes such as `clang``::``SourceRange` (a
    pair of two source locations that specify the beginning and end of a source range),
    they provide a great foundation for diagnostics used in Clang.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang::SourceLocation` 和 `clang::SourceManager` 是非常强大的类。结合其他类，如 `clang::SourceRange`（指定源范围开始和结束的两个源位置），它们为
    Clang 中使用的诊断提供了一个很好的基础。'
- en: 4.4.2 Diagnostics support
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 诊断支持
- en: 'Clang’s diagnostics subsystem is responsible for generating and reporting warnings,
    errors, and other messages [[8](B19722_Bib.xhtml#Xllvm_clang_cfe_internals_manual)].
    The main classes involved are:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 的诊断子系统负责生成和报告警告、错误和其他消息 [[8](B19722_Bib.xhtml#Xllvm_clang_cfe_internals_manual)]。涉及的主要类包括：
- en: '`DiagnosticsEngine`: Manages diagnostic IDs and options'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DiagnosticsEngine`：管理诊断 ID 和选项'
- en: '`DiagnosticConsumer`: Abstract base class for diagnostic consumers'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DiagnosticConsumer`: 诊断消费者抽象基类'
- en: '`DiagnosticIDs`: Handles the mapping between diagnostic flags and internal
    IDs'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DiagnosticIDs`：处理诊断标志和内部 ID 之间的映射'
- en: '`DiagnosticInfo`: Represents a single diagnostic'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DiagnosticInfo`：表示单个诊断'
- en: 'Here is a simple example illustrating how you might emit a warning in Clang:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，说明了如何在 Clang 中发出警告：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Figure 4.19**: Emit warning with clang::DiagnosticsEngine'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.19**：使用 clang::DiagnosticsEngine 发出警告'
- en: In our example, we will use a simple DiagnosticConsumer, `clang``::``TextDiagnosticPrinter`,
    which formats and prints the processed diagnostic messages.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将使用一个简单的`DiagnosticConsumer`，即`clang::TextDiagnosticPrinter`，它格式化和打印处理过的诊断消息。
- en: 'The full code for the main function of our example is shown in [Figure 4.20](#x1-80027r20):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例的主函数的完整代码显示在[图4.20](#x1-80027r20)中：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Figure 4.20**: Clang diagnostics example'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.20**: Clang诊断示例'
- en: The code will produce the following output
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将产生以下输出
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Figure 4.21**: Printed diagnostics'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.21**: 打印出的诊断信息'
- en: In this example, we first set up `DiagnosticsEngine` with `TextDiagnosticPrinter`
    as its `DiagnosticConsumer`. We then use the `Report` method of `DiagnosticsEngine`
    to emit a custom warning. We will add a more realistic example later when we create
    our test project for the Clang plugin in [*Section** 4.6*](#x1-840006)*, Clang
    plugin* *project*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用`TextDiagnosticPrinter`作为其`DiagnosticConsumer`来设置`DiagnosticsEngine`。然后我们使用`DiagnosticsEngine`的`Report`方法来发出一个自定义警告。我们将在创建Clang插件的测试项目时添加一个更实际的例子，见[*第4.6节*](#x1-840006)*，Clang插件*
    *项目*。
- en: 4.5 LLVM supporting tools
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 LLVM支持工具
- en: The LLVM project has its own tooling support. The most important LLVM tools
    are TableGen and LIT (which stands for LLVM Integrated Tester). We will look into
    them with examples from the Clang code. These examples should help us understand
    the purpose of the tooling and how they can be used.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM项目有自己的工具支持。最重要的LLVM工具是TableGen和LIT（代表LLVM Integrated Tester）。我们将通过Clang代码的例子来探讨它们。这些例子应该有助于我们理解工具的目的以及如何使用它们。
- en: 4.5.1 TableGen
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 TableGen
- en: TableGen is a **domain-specific language (DSL)** and associated tool used in
    the LLVM project for the purpose of describing and generating tables, particularly
    those that describe a target architecture. This is highly useful for compiler
    infrastructure, where one frequently needs to describe things such as instruction
    sets, registers, and various other target-specific attributes in a structured
    manner.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen是一种**领域特定语言 (DSL)**和相关的工具，用于LLVM项目中描述和生成表格，特别是描述目标架构的表格。这对于编译器基础设施非常有用，因为经常需要以结构化的方式描述诸如指令集、寄存器以及各种其他特定于目标属性。
- en: TableGen is employed in various parts of the Clang compiler. It’s primarily
    used where there’s a need to generate large amounts of similar code. For instance,
    it can be used for supporting cast operations that necessitate extensive enum
    declarations in basic classes, or in the diagnostic subsystem where code generation
    is required to handle numerous similar diagnostic messages. We will examine how
    TableGen functions within the diagnostics system as an example.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen被用于Clang编译器的各个部分。它主要用于需要生成大量相似代码的地方。例如，它可以用于支持需要在大类中进行大量枚举声明的类型转换操作，或者在需要生成代码以处理大量相似诊断信息的诊断子系统中。我们将以TableGen在诊断系统中的功能为例进行考察。
- en: 'We will begin with the `Diagnostic.td` file, which describes Clang’s diagnostics.
    This file can be found at `clang/include/clang/Basic/Diagnostic.td`. Let’s examine
    how diagnostic severity is defined:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从描述Clang诊断的`Diagnostic.td`文件开始，该文件位于`clang/include/clang/Basic/Diagnostic.td`。让我们看看诊断严重性是如何定义的：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Figure 4.22**: Severity definition in clang/include/clang/Basic/Diagnostic.td'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.22**: clang/include/clang/Basic/Diagnostic.td中的严重性定义'
- en: 'In [Figure 4.22](#x1-82009r22), we define a class for severities (*Lines 17-19*).
    Each severity is associated with a string, as shown below:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图4.22](#x1-82009r22)中，我们定义了一个严重性的类（*第17-19行*）。每个严重性都与一个字符串相关联，如下所示：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Figure 4.23**: Definitions for different types of severity in clang/include/clang/Basic/Diagnostic.td'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.23**: clang/include/clang/Basic/Diagnostic.td中不同严重类型的定义'
- en: '[Figure 4.23](#x1-82017r23) contains definitions for the different severities;
    for instance, the `Warning` severity is defined on *Line 22*.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.23](#x1-82017r23)包含了不同严重性的定义；例如，`Warning`严重性在*第22行*被定义。'
- en: 'The severity is later used to define the `Diagnostic` class, with the `Warning`
    diagnostic being defined as a descendant of this class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 严重性随后被用来定义`Diagnostic`类，其中`Warning`诊断被定义为这个类的子类：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Figure 4.24**: Diagnostics definition in clang/include/clang/Basic/Diagnostic.td'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.24**: clang/include/clang/Basic/Diagnostic.td中的诊断定义'
- en: 'Using the `Warning` class definition, different instances of the class can
    be defined. For example, the following is an instance that defines an unused parameter
    warning located in `DiagnosticSemaKinds.td`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Warning` 类定义，可以定义类的不同实例。例如，以下是一个定义位于 `DiagnosticSemaKinds.td` 中的未使用参数警告的实例：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Figure 4.25**: The definition of the unused parameter warning in clang/include/clang/Basic/DiagnosticSemaKinds.td'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.25**：在 clang/include/clang/Basic/DiagnosticSemaKinds.td 中未使用参数警告的定义'
- en: 'The `clang-tblgen` tool will generate the corresponding `DiagnosticSemaKinds.inc`
    file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang-tblgen` 工具将生成相应的 `DiagnosticSemaKinds.inc` 文件：'
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Figure 4.26**: The definition of the unused parameter warning in clang/include/clang/Basic/DiagnosticSemaKinds.inc'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.26**：在 clang/include/clang/Basic/DiagnosticSemaKinds.inc 中未使用参数警告的定义'
- en: This file retains all the necessary information about the diagnostic. This information
    can be retrieved from the Clang source code using different definitions of the
    `DIAG` macro.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件保留有关诊断的所有必要信息。这些信息可以通过使用 `DIAG` 宏的不同定义从 Clang 源代码中检索。
- en: 'For instance, the following code leverages the TableGen-generated code to extract
    diagnostic descriptions, as found in `clang/lib/Basic/DiagnosticIDs.cpp`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码利用 TableGen 生成的代码来提取诊断描述，如 `clang/lib/Basic/DiagnosticIDs.cpp` 中所示：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Figure 4.27**: DIAG macro definition'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.27**：DIAG 宏定义'
- en: 'The C++ preprocessor will expand to the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 预处理器将扩展为以下内容：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Figure 4.28**: DIAG macro expansion'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.28**：DIAG 宏展开'
- en: The provided example demonstrates how TableGen can be used to generate code
    in Clang and how it can simplify Clang development. The diagnostic subsystem is
    not the only area where TableGen is utilized; it is also widely used in other
    parts of Clang. For instance, the macros used in various types of AST visitors
    also rely on the code generated by TableGen; see [*Section** 3.3.2*](B19722_03.xhtml#x1-610002)*,
    Visitor* *implementation*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的示例演示了如何使用 TableGen 在 Clang 中生成代码以及它如何简化 Clang 开发。诊断子系统不是 TableGen 被使用的唯一领域；它还在
    Clang 的其他部分被广泛使用。例如，在各种类型的 AST 访问者中使用的宏也依赖于 TableGen 生成的代码；参见 [*第 3.3.2 节*](B19722_03.xhtml#x1-610002)*，访问者*
    *实现*。
- en: 4.5.2 LLVM test framework
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 LLVM 测试框架
- en: 'LLVM uses several testing frameworks for different types of testing. The primary
    ones are **LLVM Integrated Tester (LIT)** and **Google Test (GTest)** [[24](B19722_Bib.xhtml#XGoogleTest)].
    Both LIT and GTest play significant roles in Clang’s testing infrastructure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 使用多个测试框架进行不同类型的测试。主要的是 **LLVM 集成测试器 (LIT)** 和 **Google 测试 (GTest)** [[24](B19722_Bib.xhtml#XGoogleTest)]。LIT
    和 GTest 都在 Clang 的测试基础设施中扮演着重要角色：
- en: LIT is primarily used for testing the behavior of the Clang toolchain as a whole,
    with a focus on its code compilation capabilities and the diagnostics it produces.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LIT 主要用于测试 Clang 工具链的整体行为，重点关注其代码编译能力和产生的诊断信息。
- en: GTest is utilized for unit tests, targeting specific components of the code
    base, primarily utility libraries and internal data structures.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GTest 用于单元测试，针对代码库中的特定组件，主要是实用库和内部数据结构。
- en: These tests are crucial for maintaining the quality and stability of the Clang
    project.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试对于维护 Clang 项目的质量和稳定性至关重要。
- en: Important note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'We will not delve into GTest, as this testing framework is commonly used outside
    LLVM and isn’t part of LLVM itself. For more information about GTest, please visit
    its official page: [https://github.com/google/googletest](https://github.com/google/googletest)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨 GTest，因为这个测试框架在 LLVM 之外被广泛使用，并且不是 LLVM 本身的一部分。有关 GTest 的更多信息，请访问其官方网站：[https://github.com/google/googletest](https://github.com/google/googletest)
- en: Our focus will be on LIT. LIT is LLVM’s own test framework and is heavily used
    for testing the various tools and libraries in LLVM, including the Clang compiler.
    LIT is designed to be lightweight and is tailored for the needs of compiler testing.
    It’s commonly used for running tests that are essentially shell scripts, often
    with checks for specific patterns in the output. A typical LIT test may consist
    of a source code file along with a set of ”RUN” commands that specify how to compile,
    link, or otherwise process the file, and what output to expect.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注 LIT。LIT 是 LLVM 自有的测试框架，被广泛用于测试 LLVM 中的各种工具和库，包括 Clang 编译器。LIT 被设计为轻量级，并针对编译器测试的需求进行了定制。它通常用于运行本质上为
    shell 脚本的测试，通常包含对输出中特定模式的检查。一个典型的 LIT 测试可能包括一个源代码文件以及一组 "RUN" 命令，这些命令指定如何编译、链接或其他方式处理文件，以及预期的输出。
- en: The RUN commands often use FileCheck, another utility in the LLVM project, to
    check the output against expected patterns. In Clang, LIT tests are often used
    to test frontend features such as parsing, semantic analysis, code generation,
    and diagnostics. These tests typically look like source code files with embedded
    comments to indicate how to run the test and what to expect.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: RUN命令通常使用FileCheck，LLVM项目中的另一个实用工具，来检查输出是否符合预期模式。在Clang中，LIT测试通常用于测试前端功能，如解析、语义分析、代码生成和诊断。这些测试通常看起来像源代码文件，其中包含嵌入式注释，指示如何运行测试以及预期结果。
- en: 'Consider the following example from `clang/test/Sema/attr-unknown.c`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下来自`clang/test/Sema/attr-unknown.c`的示例：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Figure 4.29**: LIT test for Clang warnings about unknown attributes'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.29**: 关于未知属性的Clang警告的LIT测试'
- en: 'The example is a typical C source file that can be processed by Clang. LIT’s
    behavior is controlled by comments within the source text. The first comment (on
    *Line 1*) specifies how the test should be executed. As indicated, `clang` should
    be started with some additional arguments: `-fsyntax-only` and `-verify` . There
    are also substitutions that begin with the ’%’ symbol. The most important of these
    is ’%s’, which is replaced by the source file’s name. LIT will also examine comments
    beginning with `expected-warning` and ensure that the warnings produced by Clang’s
    output match the expected values.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 示例是一个典型的C源代码文件，它可以被Clang处理。LIT的行为由源文本中的注释控制。第一个注释（在第*1行*）指定了如何执行测试。如指示，`clang`应使用一些额外的参数启动：`-fsyntax-only`和`-verify`。还有一些以`%`符号开始的替换。其中最重要的是`%s`，它被源文件名替换。LIT还会检查以`expected-warning`开头的注释，并确保Clang输出产生的警告与预期值匹配。
- en: 'The test can be run as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以按以下方式运行：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Figure 4.30**: LIT test run'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.30**: LIT测试运行'
- en: We run `llvm-lit` from the `build` folder because the tool is not included in
    the installation procedure. We can obtain more details about LIT setup and its
    invocation once we create our test clang plugin project and configure LIT tests
    for it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`build`文件夹运行`llvm-lit`，因为该工具不包括在安装过程中。一旦我们创建了我们的测试Clang插件项目并为其配置LIT测试，我们就可以获得有关LIT设置和其调用的更多详细信息。
- en: 4.6 Clang plugin project
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 Clang插件项目
- en: The goal of the test project is to create a clang plugin that will estimate
    class complexity. Specifically, a class is deemed complex if the number of its
    methods exceeds a certain threshold. We will leverage all the knowledge we have
    acquired thus far for this project. This will include the use of a recursive visitor
    and Clang diagnostics. Additionally, we will create a LIT test for our project.
    Developing the plugin will necessitate a unique build configuration for LLVM,
    which will be our initial step.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 测试项目的目标是创建一个Clang插件，该插件将估计类复杂性。具体来说，如果一个类的成员方法数量超过某个阈值，则认为该类是复杂的。我们将利用迄今为止所获得的所有知识来完成此项目。这包括使用递归访问者和Clang诊断。此外，我们还将为我们的项目创建一个LIT测试。开发插件将需要为LLVM创建一个独特的构建配置，这是我们最初的步骤。
- en: 4.6.1 Environment setup
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1 环境设置
- en: 'The plugin will be created as a shared object, and our LLVM installation should
    be built with support for shared libraries (see [*Section** 1.3.1*](B19722_01.xhtml#x1-270001)*,
    Configuration with* *CMake*):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 插件将被创建为一个共享对象，我们的LLVM安装应该支持共享库（参见[*第1.3.1节*](B19722_01.xhtml#x1-270001)*，使用CMake进行配置）：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Figure 4.31**: CMake configuration used for the Clang plugin project'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.31**: Clang插件项目使用的CMake配置'
- en: As can be seen, we use the build configuration from [*Section** 1.4*](B19722_01.xhtml#x1-300004)*,
    Test project –* *syntax check with a Clang tool*, as shown in [Figure 1.12](B19722_01.xhtml#x1-30003r12).
    In the configuration, we set up a folder for installing artifacts into `../install`,
    limit our build targets to the `X86` platform, and enable only the `clang` project.
    Additionally, we enable size optimization for debug symbols and use shared libraries
    instead of static linkage.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，我们使用[*第1.4节*](B19722_01.xhtml#x1-300004)*的构建配置，测试项目 –* *使用Clang工具进行语法检查*，如图[图1.12](B19722_01.xhtml#x1-30003r12)所示。在配置中，我们为安装工件设置了一个文件夹到`../install`，将我们的构建目标限制在`X86`平台，并且只启用`clang`项目。此外，我们为调试符号启用大小优化，并使用共享库而不是静态链接。
- en: 'The next step involves building and installing clang. This can be achieved
    with the following command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步涉及构建和安装clang。这可以通过以下命令实现：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As soon as we are done with the clang build and installation, we can proceed
    with the `CMakeLists.txt` file for our project.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成clang的构建和安装，我们就可以继续处理我们项目的`CMakeLists.txt`文件。
- en: 4.6.2 CMake build configuration for plugin
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.2 插件的CMake构建配置
- en: We will use [Figure 3.20](B19722_03.xhtml#x1-62028r20) as the foundation for
    our plugin build configuration. We will change the project name to `classchecker`
    , and `ClassComplexityChecker.cpp` will serve as our primary source file. The
    main portion of the file is displayed in [Figure 4.32](#x1-86023r32). As can be
    observed, we will construct a shared library (*Lines 18-20*) rather than an executable,
    as in our previous test projects. Another modification is in *Line 12*, where
    we set up a config parameter for the LLVM build folder. This parameter is necessary
    to locate the LIT executable, which is not included in the standard installation
    process, as mentioned earlier in [*Section** 4.5.2*](#x1-830002)*, LLVM test framework*.
    Some additional modifications need to be made to support LIT test invocations,
    but we will discuss the details later in [*Section** 4.6.8*](#x1-920008)*, LIT
    tests for clang plugin* (see [Figure 4.44](#x1-94025r44)).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[图3.20](B19722_03.xhtml#x1-62028r20)作为插件构建配置的基础。我们将项目名称更改为`classchecker`，`ClassComplexityChecker.cpp`将作为我们的主要源文件。文件的主要部分在[图4.32](#x1-86023r32)中展示。如我们所见，我们将构建一个共享库（*第18-20行*），而不是像之前的测试项目那样构建可执行文件。另一个修改是在*第12行*，我们为LLVM构建文件夹设置了一个配置参数。这个参数是必要的，以便定位LIT可执行文件，正如之前在[*第4.5.2节*](#x1-830002)中提到的，它不包括在标准安装过程中。需要做一些额外的修改来支持LIT测试调用，但我们将稍后在[*第4.6.8节*](#x1-920008)中讨论细节，即LIT对clang插件的测试（参见图4.44）。
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Figure 4.32**: CMakeLists.txt file for class complexity plugin'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.32**: 类复杂度插件的CMakeLists.txt文件'
- en: After completing the build configuration, we can start writing the primary code
    for the plugin. The first component we’ll create is a recursive visitor class
    named `ClassVisitor`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 完成构建配置后，我们可以开始编写插件的主体代码。我们将创建的第一个组件是一个名为`ClassVisitor`的递归访问者类。
- en: 4.6.3 Recursive visitor class
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.3 递归访问者类
- en: Our visitor class is located in the `ClassVisitor.hpp` file (see [Figure 4.33](#x1-87040r33)).
    This is a recursive visitor that handles `clang``::``CXXRecordDecl`, which are
    the AST nodes for C++ class declarations. We calculate the number of methods in
    *Lines 13-16* and emit diagnostics in *Lines 19-25* if the threshold is exceeded.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的访问者类位于`ClassVisitor.hpp`文件中（参见图4.33）。这是一个递归访问者，用于处理`clang::CXXRecordDecl`，这是C++类声明的AST节点。我们在*第13-16行*计算方法数，如果超过阈值，则在*第19-25行*发出诊断。
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Figure 4.33**: Source code for ClassVisitor.hpp'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.33**: ClassVisitor.hpp的源代码'
- en: 'It’s worth noting the diagnostic calls. The diagnostic message is constructed
    in *Lines 20-22*. Our diagnostic message accepts two parameters: the class name
    and the number of methods for the class. These parameters are encoded with the
    ’%1’ and ’%2’ placeholders in *Line 22*. The actual values for these parameters
    are passed in *Line 25*, where the diagnostic message is constructed using the
    `DiagBuild` object. This object is an instance of the `clang``::``DiagnosticBuilder`
    class, which implements the **Resource** **Acquisition Is Initialization (RAII)**
    pattern. It emits the actual diagnostics upon its destruction.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是诊断调用。诊断消息在第20-22行构建。我们的诊断消息接受两个参数：类名和类的方法数。这些参数在第22行使用`%1`和`%2`占位符进行编码。这些参数的实际值在第25行传递，在那里使用`DiagBuild`对象构建诊断消息。这个对象是`clang::DiagnosticBuilder`类的实例，它实现了**资源获取即初始化（RAII）**模式。它在销毁时发出实际的诊断。
- en: Important note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In C++, the RAII principle is a common idiom used to manage resource lifetimes
    by tying them to the lifetime of an object. When an object goes out of scope,
    its destructor is automatically called, and this provides an opportunity to release
    the resource that the object holds.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，RAII原则是一个常见的惯用语，用于通过将其与对象的生存期相关联来管理资源生存期。当一个对象超出作用域时，其析构函数会自动调用，这为释放对象持有的资源提供了机会。
- en: '`ClassVisitor` is created within an AST consumer class, which will be our next
    topic.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassVisitor`是在一个AST消费者类内部创建的，这将是我们的下一个主题。'
- en: 4.6.4 Plugin AST consumer class
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.4 插件AST消费者类
- en: The AST consumer class is implemented in `ClassConsumer.hpp` and represents
    the standard AST consumer, as seen in our AST visitor test projects (refer to
    [Figure 3.9](B19722_03.xhtml#x1-60100r9)). The code is presented in [Figure 4.35](#x1-89032r35).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: AST消费者类在`ClassConsumer.hpp`中实现，代表标准的AST消费者，正如我们在AST访问者测试项目中看到的那样（参见图3.9）。代码在[图4.35](#x1-89032r35)中展示。
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Figure 4.34**: Source code for ClassConsumer.hpp'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.34**: ClassConsumer.hpp的源代码'
- en: The code initializes `Visitor` at *Line 10* and utilizes the Visitor class at
    *Line 13* to traverse the declarations, starting with the top one (translation
    unit declaration). The consumer must be created from a special AST action class,
    which we will discuss next.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在第10行初始化`Visitor`，并在第13行使用Visitor类遍历声明，从最顶层开始（翻译单元声明）。消费者必须从一个特殊的AST操作类创建，我们将在下一节讨论。
- en: 4.6.5 Plugin AST action class
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.5 插件AST操作类
- en: 'The code for the AST action is shown in [Figure 4.35](#x1-89032r35). Several
    important parts can be observed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: AST操作的代码如图[图4.35](#x1-89032r35)所示。可以观察到几个重要的部分：
- en: '*Line 7*: We inherit our `ClassAction` from `clang``::``PluginASTAction`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第7行*：我们从`clang::PluginASTAction`继承我们的`ClassAction`'
- en: '*Lines 10-13*: We instantiate `ClassConsumer` and utilize `MethodCountThreshold`,
    which is derived from an optional plugin argument'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第10-13行*：我们实例化`ClassConsumer`并使用`MethodCountThreshold`，它是一个可选插件参数的派生'
- en: '*Lines 15-25*: We process the optional `threshold` argument for our plugin'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第15-25行*：我们处理插件的可选`threshold`参数'
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Figure 4.35**: Source code for ClassAction.hpp'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.35**: ClassAction.hpp的源代码'
- en: We are almost done and ready to initialize our plugin.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了，准备初始化我们的插件。
- en: 4.6.6 Plugin code
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.6 插件代码
- en: Our plugin registration is carried out in the `ClassChecker.cpp` file, shown
    in [Figure 4.36](#x1-90009r36).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的插件注册是在`ClassChecker.cpp`文件中完成的，如图[图4.36](#x1-90009r36)所示。
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Figure 4.36**: Source code for ClassChecker.cpp'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.36**: ClassChecker.cpp的源代码'
- en: As we can observe, the majority of the initialization is hidden by helper classes,
    and we only need to pass our implementation to `lang``::``FrontendPluginRegistry``::``Add`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，大多数初始化都被辅助类隐藏了，我们只需要将我们的实现传递给`lang::FrontendPluginRegistry::Add`。
- en: Now we are ready to build and test our clang plugin.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好构建和测试我们的Clang插件。
- en: 4.6.7 Building and running plugin code
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.7 构建和运行插件代码
- en: 'We need to specify a path to the installation folder for our LLVM project.
    The rest of the procedure is the standard one that we have previously used, see
    [Figure 3.11](B19722_03.xhtml#x1-60132r11):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定我们的LLVM项目的安装文件夹的路径。其余的步骤是标准的，我们之前已经使用过，参见[图3.11](B19722_03.xhtml#x1-60132r11)：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Figure 4.37**: Configure and build commands for the Clang plugin'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.37**: Clang插件的配置和构建命令'
- en: 'The build artifacts will be located in the `build` folder. We can then run
    our plugin on a test file as follows, where `<filepath>` is the file we want to
    compile:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 构建工件将位于`build`文件夹中。然后我们可以按照以下方式在测试文件上运行我们的插件，其中`<filepath>`是我们想要编译的文件：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Figure 4.38**: How to run the Clang plugin on a test file'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.38**: 在测试文件上运行Clang插件的方法'
- en: For example, if we use a test file named `test.cpp` that defines a class with
    three methods (see [Figure 4.39](#x1-91014r39)), we will not receive any warnings.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用一个名为`test.cpp`的测试文件，它定义了一个有三个方法的类（参见[图4.39](#x1-91014r39)），我们将不会收到任何警告。
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Figure 4.39**: Test for the clang plugin: test.cpp'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.39**: Clang插件的测试：test.cpp'
- en: 'However, if we specify a smaller threshold, we will receive a warning for the
    file:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们指定一个较小的阈值，我们将为该文件收到一个警告：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Figure 4.40**: Clang plugin run on test.cpp'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.40**: 在test.cpp上运行的Clang插件'
- en: It’s now time to create a LIT test for our plugin.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为我们的插件创建一个LIT测试了。
- en: 4.6.8 LIT tests for clang plugin
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.8 Clang插件的LIT测试
- en: 'We’ll begin with a description of the project organization. We’ll adopt the
    common pattern used in the clang source code and place our tests in the `test`
    folder. This folder will contain the following files:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个项目组织的描述开始。我们将采用在Clang源代码中使用的常见模式，并将我们的测试放在`test`文件夹中。这个文件夹将包含以下文件：
- en: '`lit.site.cfg.py.in` : This is the main configuration file, a CMake config
    file. It replaces patterns marked as ’@...@’ with corresponding values defined
    during the CMake configuration. Additionally, this file loads `lit.cfg.py` .'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lit.site.cfg.py.in`：这是主要的配置文件，一个CMake配置文件。它将标记为’@...@’的模式替换为CMake配置期间定义的相应值。此外，此文件加载`lit.cfg.py`。'
- en: '`lit.cfg.py` : This serves as the primary configuration file for LIT tests.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lit.cfg.py`：这是LIT测试的主要配置文件。'
- en: '`simple``_test.cpp` : This is our LIT test file.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simple_test.cpp`：这是我们的LIT测试文件。'
- en: 'The basic workflow is as follows: CMake takes `lit.site.cfg.py.in` as a template
    and generates the corresponding `lit.site.cfg.py` in the `build/test` folder.
    This file is then utilized by LIT tests as a seed to execute the tests.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的工作流程如下：CMake将`lit.site.cfg.py.in`作为模板，并在`build/test`文件夹中生成相应的`lit.site.cfg.py`。然后，该文件被LIT测试用作种子来执行测试。
- en: LIT config files
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LIT配置文件
- en: There are two configuration files for LIT tests. The first one is shown in [Figure 4.41](#x1-93011r41).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于LIT测试有两个配置文件。第一个显示在[图4.41](#x1-93011r41)中。
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Figure 4.41**: lit.site.cfg.py.in file'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.41**：lit.site.cfg.py.in文件'
- en: This file is a CMake template that will be converted into a Python script. The
    most crucial part is shown in *Lines 6-7*, where the main LIT config is loaded.
    It is sourced from the main source tree and is not copied to the `build` folder.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是一个CMake模板，它将被转换为Python脚本。最重要的部分显示在*第6-7行*，其中加载了主要的LIT配置。它来自主源树，并且不会被复制到`build`文件夹中。
- en: The subsequent configuration is displayed in [Figure 4.42](#x1-93025r42). It
    is a Python script containing the primary configuration for LIT tests.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 后续配置显示在[图4.42](#x1-93025r42)。这是一个包含LIT测试主要配置的Python脚本。
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Figure 4.42**: lit.cfg.py file'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.42**：lit.cfg.py文件'
- en: '*Lines 4-7* define the fundamental configuration; for example, *Line 6* determines
    which files should be utilized for tests. All files with the ’.cpp’ extension
    in the `test` folder will be employed as LIT tests.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*第4-7行*定义了基本配置；例如，*第6行*确定哪些文件应该用于测试。`test`文件夹中所有扩展名为`.cpp`的文件都将被用作LIT测试。'
- en: '*Lines 9-11* detail the substitutions that will be employed in the LIT tests.
    These include the path to the clang binary (*Line 9*), the path to the shared
    library with the plugin (*Line 10*), and the path to the `FileCheck` utility (*Line*
    *11*).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*第9-11行*详细说明了将在LIT测试中使用的替换。这包括clang二进制文件的路径（*第9行*）、带有插件的共享库的路径（*第10行*）以及`FileCheck`实用程序的路径（*第11行*）。'
- en: We have defined only one basic LIT test, `simple``_test.cpp` , as shown in [Figure 4.43](#x1-93048r43).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只定义了一个基本的LIT测试，`simple_test.cpp`，如[图4.43](#x1-93048r43)所示。
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Figure 4.43**: simple_test.cpp file'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.43**：simple_test.cpp文件'
- en: The use of substitutions can be observed in *Line 1*, where paths to the clang
    binary, the plugin shared library, and the `FileCheck` utility are referenced.
    Special patterns recognized by the utility are used in *Line* *9*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在*第1行*观察到替换的使用，其中引用了clang二进制文件的路径、插件共享库的路径以及`FileCheck`实用程序的路径。在*第9行*使用了该实用程序识别的特殊模式。
- en: The final piece of the puzzle is the CMake configuration. This will set up the
    required variables for substitutions in `lit.site.cfg.py.in` and also define a
    custom target to run the LIT tests.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一块拼图是CMake配置。这将设置在`lit.site.cfg.py.in`中进行替换所需的变量，并定义一个自定义目标来运行LIT测试。
- en: CMake configuration for LIT tests
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LIT测试的CMake配置
- en: The `CMakeLists.txt` file requires some adjustments to support LIT tests. The
    necessary changes are displayed in [Figure 4.44](#x1-94025r44).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`文件需要一些调整以支持LIT测试。必要的更改显示在[图4.44](#x1-94025r44)中。'
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Figure 4.44**: LIT tests configuration at CMakeLists.txt'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.44**：CMakeLists.txt中的LIT测试配置'
- en: In *Lines 31 and 32*, we search for the necessary utilities, `llvm-lit` and
    `FileCheck` . It’s worth noting that they rely on the $`LLVM``_BUILD` environment
    variable, which we also verify in *Line 12* of the config (see [Figure 4.32](#x1-86023r32)).
    The steps in *Lines 41-43* are essential for generating `lit.site.cfg.py` from
    the provided template file, `lit.site.cfg.py.in` . Lastly, we establish a custom
    target to execute the LIT tests in *Lines 46-49*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第31和32行*，我们搜索必要的工具，`llvm-lit`和`FileCheck`。值得注意的是，它们依赖于`$LLVM_BUILD`环境变量，我们在配置的第12行也进行了验证（参见[图4.32](#x1-86023r32)）。*第41-43行*中的步骤对于从提供的模板文件`lit.site.cfg.py.in`生成`lit.site.cfg.py`至关重要。最后，我们在*第46-49行*中建立了一个自定义目标来执行LIT测试。
- en: Now we are ready to start the LIT tests.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始LIT测试。
- en: Running LIT tests
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行LIT测试
- en: 'To initiate the LIT tests, we must set an environment variable that points
    to the build folder, compile the project, and then execute the custom target,
    `check-classchecker`. Here’s how this can be done:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动LIT测试，我们必须设置一个环境变量，使其指向构建文件夹，编译项目，然后执行自定义目标`check-classchecker`。以下是这样做的方法：
- en: '[PRE51]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Figure 4.45**: Configure, build and check commands for the Clang plugin'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.45**：Clang插件的配置、构建和检查命令'
- en: 'Upon executing these commands, you may observe the following output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些命令后，您可能会看到以下输出：
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**Figure 4.46**: LIT test execution'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.46**：LIT测试执行'
- en: With this, we conclude our first comprehensive project, which encompasses a
    practical clang plugin that can be tailored via supplemental plugin arguments.
    Additionally, it includes the respective tests that can be executed to verify
    its functionality.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们完成了我们的第一个综合项目，该项目包含一个可以通过补充插件参数定制的实用clang插件。此外，它还包括可以执行以验证其功能的相应测试。
- en: 4.7 Summary
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 概述
- en: In this chapter, we became familiar with the basic classes from the LLVM ADT
    library. We gained knowledge of Clang diagnostics and the test frameworks used
    in LLVM for various types of testing. Using this knowledge, we created a simple
    Clang plugin that detects complex classes and issues a warning about their complexity.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了 LLVM ADT 库中的基本类。我们了解了 Clang 诊断以及 LLVM 用于各种类型测试的测试框架。利用这些知识，我们创建了一个简单的
    Clang 插件，用于检测复杂类并发出关于其复杂性的警告。
- en: The chapter concludes the first part of the book, where we gained basic knowledge
    of the Clang compiler frontend. We are now prepared to explore various tools built
    on the foundation of Clang libraries. We will begin with Clang-Tidy, a powerful
    linter framework used to detect various issues in C++ code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了本书的第一部分，其中我们获得了 Clang 编译器前端的初步知识。我们现在准备探索建立在 Clang 库基础上的各种工具。我们将从 Clang-Tidy
    开始，这是一个强大的代码检查框架，用于检测 C++ 代码中的各种问题。
- en: 4.8 Further reading
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 进一步阅读
- en: 'LLVM Coding Standards: [https://llvm.org/docs/CodingStandards.html](https://llvm.org/docs/CodingStandards.html)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 编码标准：[https://llvm.org/docs/CodingStandards.html](https://llvm.org/docs/CodingStandards.html)
- en: 'LLVM Programmer’s Manual: [https://llvm.org/docs/ProgrammersManual.html](https://llvm.org/docs/ProgrammersManual.html)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 程序员手册：[https://llvm.org/docs/ProgrammersManual.html](https://llvm.org/docs/ProgrammersManual.html)
- en: '“Clang” CFE Internals Manual: [https://clang.llvm.org/docs/InternalsManual.html](https://clang.llvm.org/docs/InternalsManual.html)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Clang” CFE 内部手册：[https://clang.llvm.org/docs/InternalsManual.html](https://clang.llvm.org/docs/InternalsManual.html)
- en: 'How to set up LLVM-style RTTI for your class hierarchy: [https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html](https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为你的类层次结构设置 LLVM 风格的 RTTI：[https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html](https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html)
- en: 'LIT - LLVM Integrated Tester: [https://llvm.org/docs/CommandGuide/lit.html](https://llvm.org/docs/CommandGuide/lit.html)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LIT - LLVM 集成测试器：[https://llvm.org/docs/CommandGuide/lit.html](https://llvm.org/docs/CommandGuide/lit.html)
