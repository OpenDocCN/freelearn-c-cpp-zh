- en: Actors and Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actors 和组件
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Creating a custom Actor in C++
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++ 中创建自定义 Actor
- en: Instantiating an Actor using SpawnActor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SpawnActor 实例化 Actor
- en: Creating a UFUNCTION
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 UFUNCTION
- en: Destroying an Actor using Destroy and a Timer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Destroy 和计时器销毁 Actor
- en: Destroying an Actor after a delay using SetLifeSpan
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SetLifeSpan 延迟销毁 Actor
- en: Implementing the Actor functionality by composition
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合实现 Actor 功能
- en: Loading assets into components using FObjectFinder
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 FObjectFinder 将资源加载到组件中
- en: Implementing the Actor functionality by inheritance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过继承实现 Actor 功能
- en: Attaching components to create a hierarchy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过附加组件来创建层次结构
- en: Creating a custom Actor Component
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义 Actor 组件
- en: Creating a custom Scene Component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义 Scene 组件
- en: Creating an InventoryComponent for an RPG
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 RPG 创建 InventoryComponent
- en: Creating an OrbitingMovement Component
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 OrbitingMovement 组件
- en: Creating a building that spawns units
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个生成单位的建筑
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Actors are classes that have some presence in the game world. Actors gain their
    specialized functionality by incorporating Components. This chapter deals with
    creating custom Actors and Components, the purpose that they serve, and how they
    work together.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Actors 是在游戏世界中具有存在感的类。通过结合组件，Actors 获得其特殊功能。本章讨论创建自定义 Actors 和组件，它们的作用以及它们是如何协同工作的。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用 Unreal Engine 4，并使用 Visual Studio 2017 作为 IDE。有关如何安装这两款软件及其要求的信息，请参阅本书[第1章](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml)“UE4
    开发工具”。
- en: Creating a custom Actor in C++
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C++ 中创建自定义 Actor
- en: While there are different types of Actors that ship with Unreal as part of the
    default installation, you will find yourself needing to create custom Actors at
    some point during your project's development. This might happen when you need
    to add functionality to an existing class, combine Components in a combination
    that's not present in the default subclasses, or add additional member variables
    to a class. The following two recipes demonstrate how to use either composition
    or inheritance to customize Actors.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unreal默认安装中包含不同类型的Actor，但在项目开发过程中，您可能需要创建自定义Actor。这可能发生在您需要向现有类添加功能、组合不在默认子类中存在的组件，或向类添加额外的成员变量时。以下两个配方演示了如何使用组合或继承来定制Actor。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have installed Visual Studio and Unreal 4 as per the recipe
    in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml), *UE4 Development Tools.*
    You'll also need to have an existing project – if you don't, you can create a
    new one using the Unreal-provided wizard.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已按照[第1章](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml)中“UE4 开发工具”配方安装了 Visual
    Studio 和 Unreal 4。您还需要一个现有项目 - 如果没有，可以使用 Unreal 提供的向导创建一个新项目。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Open up your project within the Unreal Editor and click on the Add New button
    in Content Browser:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unreal 编辑器中打开您的项目，并点击内容浏览器中的“添加新内容”按钮：
- en: '![](img/efd3d84e-10b0-4d49-8ea8-c53f92ce86f7.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/efd3d84e-10b0-4d49-8ea8-c53f92ce86f7.png)'
- en: 'Select New C++ Class...:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“新建 C++ 类...”：
- en: '![](img/1d0f7ab4-9130-465d-8be6-5a5e8bd5a31c.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d0f7ab4-9130-465d-8be6-5a5e8bd5a31c.png)'
- en: 'In the dialog that opens, select Actor from the list:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的对话框中，从列表中选择 Actor：
- en: '![](img/4524f05e-09f3-4fb8-abfb-d0ad23a869e5.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4524f05e-09f3-4fb8-abfb-d0ad23a869e5.png)'
- en: 'Give your Actor a name, such as `MyFirstActor`, and then click on OK to launch
    Visual Studio:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给您的 Actor 起一个名字，例如 `MyFirstActor`，然后点击 OK 以启动 Visual Studio：
- en: By convention, class names for `Actor` subclasses begin with an `A`. When using
    this class creation wizard, make sure you don't prefix your class with `A`, as
    the engine automatically adds the prefix for you.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，`Actor` 子类的类名以字母 `A` 开头。当使用此类创建向导时，请确保不要在您的类名前加上 `A`，因为引擎会自动为您添加前缀。
- en: '![](img/ef31f6fe-8231-49b3-87e0-6c3edc4007a2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef31f6fe-8231-49b3-87e0-6c3edc4007a2.png)'
- en: 'When Visual Studio loads, you should see something very similar to the following
    listing:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Visual Studio 加载时，您应该看到以下列表的类似内容：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In time, you'll become familiar with the standard code, so you will be able
    to just create new classes from Visual Studio without using the Unreal wizard.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你会熟悉标准代码，因此你将能够直接从 Visual Studio 创建新类，而无需使用 Unreal 向导。
- en: 'In `MyFirstActor.h`, we have the following aspects:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MyFirstActor.h` 文件中，我们有以下方面需要注意：
- en: '`#pragma once`: This preprocessor statement, or `pragma`, is Unreal''s expected
    method of implementing include guards pieces of code that prevent an `include`
    file from causing errors by being referenced multiple times.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#pragma once`: 这个预处理语句或 `pragma` 是 Unreal 实现包含保护代码的预期方法，这些代码防止 `include` 文件因多次引用而引起错误。'
- en: '`#include "CoreMinimal.h"`: This file includes a number of definitions of classes
    that are often used, such as `FString`, `TArray`, `Vector`, and so on, and is
    included by default in created script files for that reason, though it could still
    compile at this point without it.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "CoreMinimal.h"`: 此文件包含了许多常用类的定义，例如 `FString`、`TArray`、`Vector` 等，并且由于这个原因，它默认包含在创建的脚本文件中，尽管在没有它的情况下也可以编译。'
- en: '`#include "GameFramework/Actor.h"`: We''re going to create an `Actor` subclass
    so, naturally, we need to include the `header` file for the class we are inheriting
    from so that we know about its contents.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "GameFramework/Actor.h"`: 我们将要创建一个 `Actor` 子类，因此，自然地，我们需要包含我们继承的类的
    `header` 文件，以便了解其内容。'
- en: '`#include "MyFirstActor.generated.h"`: All Actor classes need to include their
    `generated.h` file. This file is automatically created by the **Unreal Header
    Tool** (**UHT**) based on the macros that it detects in your files.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "MyFirstActor.generated.h"`: 所有 Actor 类都需要包含它们的 `generated.h` 文件。此文件由
    **Unreal Header Tool** （**UHT**）根据在您的文件中检测到的宏自动创建。'
- en: '`UCLASS()`: `UCLASS` is one such macro that allows us to indicate that a class
    will be exposed to Unreal''s reflection system. Reflection allows us to inspect
    and iterate object properties during runtime, as well as manage references to
    our objects for garbage collection.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UCLASS()`: `UCLASS` 是这样一个宏，它允许我们指示一个类将被暴露给 Unreal 的反射系统。反射允许我们在运行时检查和迭代对象属性，以及管理我们对象的引用以进行垃圾回收。'
- en: '`class CHAPTER_04_API AMyFirstActor : public AActor`: This is the actual declaration
    of our class. The `CHAPTER_04_API ` macro is created by the UHT, and is necessary
    to help our project compile properly on Windows by ensuring that our project module''s
    classes are exported correctly in the DLL. You will also notice that both `MyFirstActor`
    and `Actor` have the prefix `A` – this is the naming convention that Unreal requires
    for native classes that are inherited from `Actor`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class CHAPTER_04_API AMyFirstActor : public AActor`: 这是我们的类的实际声明。`CHAPTER_04_API`
    宏是由 UHT 创建的，并且对于确保我们的项目模块的类在 DLL 中正确导出是必要的。你还会注意到 `MyFirstActor` 和 `Actor` 都有前缀
    `A` – 这是不从 `Actor` 继承的本地类在 Unreal 中所需的命名约定。'
- en: Note that, in this case, `Chapter_04` is the name of the project, and your project
    may have a different name.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，`Chapter_04` 是项目的名称，而你的项目可能具有不同的名称。
- en: '`GENERATED_BODY()`: `GENERATED_BODY` is another UHT macro that has been expanded
    to include the automatically generated functions that the underlying UE type system
    requires.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GENERATED_BODY()`: `GENERATED_BODY` 是另一个 UHT 宏，它被扩展以包含底层 UE 类型系统所需的自动生成的函数。'
- en: 'Inside the `MyFirstActor.cpp` file, we have the following aspects to note:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MyFirstActor.cpp` 文件中，我们有以下需要注意的方面：
- en: '`PrimaryActorTick.bCanEverTick = true;`: Inside the constructor implementation,
    this line enables ticking for this `Actor`. All Actors have a function called
    `Tick`, and this Boolean variable means that the `Actor` will have that function
    called once per frame, enabling the actor to perform actions in every frame as
    necessary. As a performance optimization, this is disabled by default.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrimaryActorTick.bCanEverTick = true;`: 在构造函数实现中，此行启用了此 `Actor` 的计时。所有 Actor
    都有一个名为 `Tick` 的函数，这个布尔变量意味着 `Actor` 将在每个帧调用该函数一次，使 Actor 能够在每一帧执行必要的操作。作为一个性能优化，这默认是禁用的。'
- en: '`BeginPlay/Tick`: You can also see the implementation of two default methods,
    `BeginPlay` and `Tick`, which are called once an object is spawned and every frame
    it is alive, respectively. Currently, these only call the parent''s version of
    the function via `Super::FunctionName`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeginPlay/Tick`: 你还可以看到两个默认方法的实现，`BeginPlay` 和 `Tick`，分别是在对象被实例化后和每一帧存活时调用的。目前，这些方法仅通过
    `Super::FunctionName` 调用父类的函数版本。'
- en: Instantiating an Actor using SpawnActor
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SpawnActor 实例化 Actor
- en: For this recipe, you'll need to have an `Actor` subclass ready to instantiate.
    You can use a built-in class such as `StaticMeshActor`, but it would help to practice
    with the custom `Actor` you made in the previous recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你需要有一个准备就绪的`Actor`子类以进行实例化。你可以使用内置类，如`StaticMeshActor`，但使用你在上一个配方中创建的自定义`Actor`进行练习会有所帮助。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a new C++ class, like in the previous recipe. This time, select Game
    Mode Base as your base class:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++类，就像之前的配方一样。这次，选择游戏模式基类作为你的基类：
- en: '![](img/f59f3973-6781-406c-be4b-1525e29de708.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f59f3973-6781-406c-be4b-1525e29de708.png)'
- en: Once you have clicked Next, give the new class a name, such as `UE4CookbookGameModeBase`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步后，为新类命名，例如`UE4CookbookGameModeBase`。
- en: 'Declare a function override in the `.h` file of your new `GameModeBase` class:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的新`GameModeBase`类的`.h`文件中声明一个函数覆盖：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the `BeginPlay` function in the `.cpp` file:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中实现`BeginPlay`函数：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compile your code, either through Visual Studio or by clicking on the Compile
    button in Unreal Editor:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Visual Studio或通过单击Unreal编辑器中的编译按钮来编译你的代码：
- en: '![](img/91a0b957-21e2-4d2f-8f52-81d4bacdbee3.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91a0b957-21e2-4d2f-8f52-81d4bacdbee3.png)'
- en: 'Open the World Settings panel for the current level by clicking on the Settings
    toolbar icon, and then pick World Settings from the drop-down menu:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击设置工具栏图标打开当前关卡的“世界设置”面板，然后从下拉菜单中选择“世界设置”：
- en: '![](img/652d3673-3870-48fc-b748-08d665536339.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/652d3673-3870-48fc-b748-08d665536339.png)'
- en: 'In the GameMode Override section, change the game mode to the `GameMode` subclass
    you just created:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏模式覆盖部分，将游戏模式更改为你刚刚创建的`GameMode`子类：
- en: '![](img/e69cfdec-f16a-4902-a53a-e379c485f4e0.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e69cfdec-f16a-4902-a53a-e379c485f4e0.png)'
- en: Setting the GameMode Override property
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 设置游戏模式覆盖属性
- en: 'Start the level and verify that `GameMode` spawns a copy of your `Actor` in
    the world by looking at the World Outliner panel. You can verify that the `BeginPlay`
    function is being run by viewing the Actor Spawning text being displayed on screen.
    If it doesn''t spawn, make sure that there are no obstructions at the world origin
    to prevent the `Actor` from being spawned. You can search the list of objects
    in the world by typing in the search bar at the top of the World Outliner panel.
    This will filter the entities that are shown:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动关卡并验证`GameMode`是否在世界上创建了你`Actor`的副本，可以通过查看世界大纲面板来完成。你可以通过查看屏幕上显示的`Actor`生成文本来验证`BeginPlay`函数是否正在运行。如果没有生成，请确保在世界原点没有阻碍`Actor`生成的障碍物。你可以在世界大纲面板顶部的搜索栏中输入以搜索世界中的对象列表。这将过滤显示的实体：
- en: '![](img/fbbdf8b8-9165-43d8-bf27-706fa64a23af.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fbbdf8b8-9165-43d8-bf27-706fa64a23af.png)'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`GameMode` is a special type of actor that is part of the Unreal Game Framework.
    Your map''s `GameMode` is instantiated by the engine automatically when the game
    starts.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameMode`是Unreal游戏框架的一部分的特殊类型的actor。你的地图的`GameMode`在游戏开始时由引擎自动实例化。'
- en: By placing some code into the `BeginPlay` method of our custom `GameMode`, we
    can run it automatically when the game begins.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将一些代码放入我们自定义的`GameMode`的`BeginPlay`方法中，我们可以在游戏开始时自动运行它。
- en: Inside `BeginPlay`, we create an `FTransform`, which is going to be used by
    the `SpawnActor` function. By default, `FTransform` is constructed to have zero
    rotation and a location at the origin.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BeginPlay`内部，我们创建了一个`FTransform`，它将被`SpawnActor`函数使用。默认情况下，`FTransform`被构造为具有零旋转和位于原点的位置。
- en: We then get a reference to the current level's `UWorld` instance using `GetWorld`,
    and then we call its `SpawnActor` function. We pass in `FTransform`, which we
    created earlier, to specify that the object should be created at its location,
    that is, the origin.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`GetWorld`获取当前级别的`UWorld`实例，然后调用其`SpawnActor`函数。我们传入之前创建的`FTransform`，以指定对象应在其位置创建，即原点。
- en: Creating a UFUNCTION
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个UFUNCTION
- en: '`UFUNCTION()` is useful because it is a C++ function that can be called from
    both your C++ client code as well as Blueprint diagrams. Any C++ function can
    be marked as a `UFUNCTION()`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`UFUNCTION()`非常有用，因为它是一个可以从你的C++客户端代码以及蓝图图中调用的C++函数。任何C++函数都可以标记为`UFUNCTION()`。'
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Construct a `UClass` class or a derived class (such as `AActor`) with a member
    function that you'd like to expose to Blueprints. Decorate that member function
    with `UFUNCTION( BlueprintCallable, Category=SomeCategory)` to make it callable
    from Blueprints.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个`UClass`类或派生类（例如`AActor`），它有一个你希望暴露给蓝图图的成员函数。用`UFUNCTION( BlueprintCallable,
    Category=SomeCategory)`装饰该成员函数，以便可以从蓝图图中调用它。
- en: 'For example, let''s create an `Actor` class called `Warrior` and use the following
    scripts for it:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个名为 `Warrior` 的 `Actor` 类，并为其使用以下脚本：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create an instance of your `Warrior` class by going to the Content Browser and
    opening the `C++ Classes\Chapter_04` folder. Once there, drag the `Warrior` icon
    onto your game world and release the mouse.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过内容浏览器打开 `C++ Classes\Chapter_04` 文件夹，创建你的 `Warrior` 类的实例。一旦到达那里，将 `Warrior`
    图标拖放到你的游戏世界中，然后释放鼠标。
- en: 'You should see the item in the World Outliner tab. By selecting the newly added
    object, you should be able to see the Name property that we added. Go ahead and
    put in a value here, such as `John`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在“世界大纲”选项卡中看到该项目。通过选择新添加的对象，你应该能够看到我们添加的“名称”属性。在这里输入一个值，例如 `John`：
- en: '![](img/4597410e-9600-4936-95cd-1ed87e6ec8ba.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4597410e-9600-4936-95cd-1ed87e6ec8ba.png)'
- en: From Blueprints (Blueprints | Open Level Blueprint), get a reference to your
    `Warrior` object. One way to do this is by dragging and dropping the object from
    the World Outliner into the Level Blueprint's Event Graph and letting go.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从蓝图（蓝图 | 打开水平蓝图）获取你的 `Warrior` 对象的引用。一种方法是将对象从世界大纲中拖放到水平蓝图的事件图中，然后释放。
- en: Click and hold the blue circle handle on the right-hand side of the Warrior1
    node and drag it over a little bit to the right. Once you release the mouse, you'll
    see a number of actions you can pick from.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并按住 Warrior1 节点右侧的蓝色圆圈手柄，将其稍微向右拖动。一旦释放鼠标，你会看到你可以选择的一系列操作。
- en: 'Call the `ToString()` function on that `Warrior` instance by clicking on your `Warrior` instance.
    Then, in a Blueprint diagram, type in `ToString`. It should look as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击你的 `Warrior` 实例来调用该 `Warrior` 实例的 `ToString()` 函数。然后，在蓝图图中输入 `ToString`。它应该看起来如下：
- en: '![](img/c709de65-ff1b-4ce7-af93-4e71d6a6eaf3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c709de65-ff1b-4ce7-af93-4e71d6a6eaf3.png)'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`UFUNCTION()` is really a C++ function, but with additional metadata that makes
    it accessible to Blueprints. This can be incredibly useful in allowing your designers
    to have access to functions that you''ve written.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`UFUNCTION()` 实际上是一个 C++ 函数，但它带有额外的元数据，这使得它可以通过蓝图访问。这可以非常实用，允许你的设计师访问你编写的函数。'
- en: Destroying an Actor using Destroy and a Timer
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `Destroy` 和定时器销毁 Actor
- en: This recipe will reuse the `GameMode` from the previous recipe, *Instantiating
    an Actor using SpawnActor*, so you should complete that recipe first.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将重用上一个菜谱中的 `GameMode`，即使用 `SpawnActor` 实例化 Actor，因此你应该首先完成该菜谱。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Make the following changes to the `GameMode` declaration:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `GameMode` 声明进行以下更改：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add `#include "MyFirstActor.h"` to the implementation file''s include statements.
    Remember, we need to place it above the `.generated` file:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件的包含语句中添加 `#include "MyFirstActor.h"`。记住，我们需要将其放置在 `.generated` 文件之上：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Assign the results of `SpawnActor` to the new `SpawnedActor` variable:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SpawnActor` 的结果分配给新的 `SpawnedActor` 变量：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following to the end of the `BeginPlay` function:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `BeginPlay` 函数的末尾：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lastly, implement `DestroyActorFunction`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，实现 `DestroyActorFunction`:'
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Load the level you created in the previous recipe, which had the game mode set
    to your custom class.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载你在上一个菜谱中创建的水平，并将游戏模式设置为你的自定义类。
- en: 'Play your level and use the World Outliner to verify that your `SpawnedActor`
    is deleted after 10 seconds:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的水平，并使用世界大纲验证你的 `SpawnedActor` 在 10 秒后被删除：
- en: '![](img/c1492b0f-321d-4cb9-8a0b-1f0bfee5bc05.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1492b0f-321d-4cb9-8a0b-1f0bfee5bc05.png)'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We declare a `UPROPERTY` to store our spawned `Actor` instance, and a custom
    function so that we can call `Destroy()` on a timer:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '我们声明一个 `UPROPERTY` 来存储我们生成的 `Actor` 实例，并定义一个自定义函数，以便我们可以定时调用 `Destroy()`:'
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `BeginPlay`, we assign the spawned `Actor` to our new `UPROPERTY`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `BeginPlay` 中，我们将生成的 `Actor` 分配给我们的新 `UPROPERTY`:'
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then declare a `TimerHandle` object and pass it to `GetWorldTimerManager::SetTimer`.
    `SetTimer` calls `DestroyActorFunction` on the object that was pointed to by this
    pointer after 10 seconds. `SetTimer` returns an object – a handle – to allow us
    to cancel the timer if necessary. The `SetTimer` function takes the `TimerHandle`
    object in as a reference parameter, and so we declare it in advance so that we
    can pass it into the function properly, even if we aren''t going to be using it
    again:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后声明一个 `TimerHandle` 对象，并将其传递给 `GetWorldTimerManager::SetTimer`。`SetTimer`
    在 10 秒后调用指向此指针的对象的 `DestroyActorFunction`。`SetTimer` 返回一个对象——一个句柄——允许我们在必要时取消定时器。`SetTimer`
    函数接受 `TimerHandle` 对象作为引用参数，因此我们提前声明它，以便我们可以正确地将它传递到函数中，即使我们不会再次使用它：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`DestroyActorFunction` checks whether we have a valid reference to a spawned
    `Actor`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`DestroyActorFunction`检查我们是否有对已生成`Actor`的有效引用：'
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we do, it calls `Destroy` on the instance so it will be destroyed and, eventually,
    garbage-collected:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有，它将在实例上调用`Destroy`，使其被销毁，并最终被垃圾回收：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Destroying an Actor after a delay using SetLifeSpan
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`SetLifeSpan`延迟销毁`Actor`
- en: Let's look at how we can destroy an `Actor`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何销毁一个`Actor`。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: If you haven't already, create a new C++ class using the wizard. Select `Actor`
    as your base class. In our case, I will reuse the `AWarrior` class we created
    previously in this chapter.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有创建，请使用向导创建一个新的C++类。选择`Actor`作为你的基类。在我们的例子中，我将重用本章先前创建的`AWarrior`类。
- en: 'In the implementation of `Actor`, add the following code to the `BeginPlay`
    function:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Actor`的实现中，将以下代码添加到`BeginPlay`函数中：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Drag a copy of your custom `Actor` into the viewport within the Editor.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的自定义`Actor`的一个副本拖到编辑器中的视图中。
- en: Play your level and look at the Outliner to verify that your `Actor` instance
    disappears after 10 seconds, having destroyed itself.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的关卡，查看大纲以验证你的`Actor`实例在10秒后消失，因为它已经销毁了自己。
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We insert our code into the `BeginPlay` function so that it executes when the
    game starts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码插入到`BeginPlay`函数中，以便在游戏开始时执行。
- en: The `SetLifeSpan` function allows us to specify a duration in seconds, after
    which the `Actor` calls its own `Destroy()` method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetLifeSpan`函数允许我们指定秒数，在此之后`Actor`将调用其自己的`Destroy()`方法。'
- en: Implementing the Actor functionality by composition
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过组合实现`Actor`功能
- en: Custom Actors without components don't have a location, and can't be attached
    to other Actors. Without a root Component, an Actor doesn't have a base transform,
    and so it has no location. Most Actors, therefore, require at least one Component
    to be useful.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 没有组件的自定义`Actor`没有位置，也不能附加到其他`Actor`上。没有根组件，`Actor`没有基础变换，因此它没有位置。因此，大多数`Actor`至少需要一个组件才有用。
- en: We can create custom Actors through composition by adding a number of components
    to our `Actor`, where each component provides some of the functionality that's
    required.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`Actor`添加多个组件来通过组合创建自定义`Actor`，其中每个组件都提供所需的一些功能。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will use the `Actor` class we created in the *Creating a custom
    Actor in C++* recipe.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将使用我们在*在C++中创建自定义`Actor`*配方中创建的`Actor`类。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add a new member to your custom class in C++ by making the following changes
    in the `public` section of the `MyFirstActor.h` file:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`MyFirstActor.h`文件的`public`部分进行以下更改，在C++中向你的自定义类添加一个新成员：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following lines to the constructor inside the `MyFirstActor.cpp` file:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyFirstActor.cpp`文件的构造函数中添加以下行：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once finished, save both files and compile them by using the Compile button
    in the editor, or building the project in Visual Studio.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，保存两个文件，并通过编辑器中的编译按钮或使用Visual Studio构建项目来编译它们。
- en: 'Once you''ve compiled this code, drag an instance of your class from the Content
    Browser out into the game environment. Here, you will be able to verify that it
    now has a transform and other properties, such as a Static Mesh, which comes from
    the `StaticMeshComponent` that we added:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦编译了这段代码，将你的类的一个实例从内容浏览器拖到游戏环境中。在这里，你将能够验证它现在具有变换和其他属性，例如来自我们添加的`StaticMeshComponent`的静态网格：
- en: '![](img/ee1cb6d8-1dc7-4bb1-bdd0-c0e6bebf0324.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee1cb6d8-1dc7-4bb1-bdd0-c0e6bebf0324.png)'
- en: Selecting the instantiated actor
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 选择实例化的`Actor`
- en: You can use the search bar on the top of the Details tab to search for specific
    components, such as the Static Mesh component.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用详情标签页顶部的搜索栏搜索特定组件，例如静态网格组件。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UPROPERTY macro` we added to the class declaration is a pointer to hold
    the component we are using as a subobject of our `Actor`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到类声明的`UPROPERTY宏`是一个指针，用于持有我们用作`Actor`子对象的组件：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the `UPROPERTY()` macro ensures that the object that was declared in the
    pointer is considered to be referenced, and won't be garbage-collected (that is,
    deleted) out from under us, leaving the pointer dangling.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UPROPERTY()`宏确保在指针中声明的对象被视为引用，并且不会被垃圾回收（即删除），从而不会留下悬空指针。
- en: We're using a Static Mesh component, but any of the `Actor` Component subclasses
    would work. Note that the asterisk is connected to the variable type in accordance
    with Epic's style guide.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是静态网格组件，但任何`Actor`组件的子类都可以工作。注意，根据Epic的风格指南，星号与变量类型相连。
- en: In the constructor, we initialize the pointer to a known valid value by using
    a `template` function, `template<class TReturnType> TReturnType* CreateDefaultSubobject(FName
    SubobjectName, bool bTransient = false)`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们通过使用`template`函数`template<class TReturnType> TReturnType* CreateDefaultSubobject(FName
    SubobjectName, bool bTransient = false)`初始化指针到一个已知的有效值。
- en: This function is responsible for calling the engine code to appropriately initialize
    the component, and return a pointer to the newly constructed object so that we
    can give our component pointer a default value. This is important because it ensures
    that the pointer has a valid value at all times, minimizing the risk of dereferencing
    uninitialized memory.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数负责调用引擎代码以适当地初始化组件，并返回新构造的对象的指针，以便我们可以为我们的组件指针提供一个默认值。这很重要，因为它确保指针始终具有有效的值，从而最小化解引用未初始化内存的风险。
- en: The function is templated based on the type of object to create, but also takes
    two parameters – the first one is the name of the subobject, which ideally should
    be human-readable, and the second is whether the object should be transient (that
    is, not saved along with the parent object).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数基于要创建的对象类型进行模板化，但也接受两个参数——第一个是子对象的名称，理想情况下应该是可读的，第二个是对象是否应该是瞬时的（即不与父对象一起保存）。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The following recipe shows you how to reference a mesh asset in your Static
    Mesh Component so that it can be displayed without requiring a user to specify
    a mesh in the Editor
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下配方展示了如何在你的静态网格组件中引用网格资源，以便它可以显示，而无需用户在编辑器中指定网格。
- en: Loading assets into components using FObjectFinder
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FObjectFinder将资源加载到组件中
- en: In the previous recipe, we created a Static Mesh Component, but we didn't try
    to load a mesh for the Component to display. While it's possible to do this in
    the Editor, it is sometimes helpful to specify a default in C++.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们创建了一个静态网格组件，但我们没有尝试为组件加载网格以显示。虽然可以在编辑器中这样做，但有时在C++中指定默认值是有帮助的。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Complete the previous recipe so that you have a custom `Actor` subclass with
    a Static Mesh Component ready.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 完成前面的配方，以便你有一个带有静态网格组件的自定义`Actor`子类。
- en: 'In your Content Browser, click on the View Options button and select Show Engine
    Content:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的内容浏览器中，点击查看选项按钮并选择显示引擎内容：
- en: '![](img/13ca9ea4-400f-4449-9884-8cb62b9519cf.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13ca9ea4-400f-4449-9884-8cb62b9519cf.png)'
- en: 'Click on the Show/Hide Sources panel button or click on the Folder icon to
    view the folders in the Content Browser. From there, browse to Engine Content and
    then to BasicShapes to see the Cube we will be using in this recipe:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 点击显示/隐藏源面板按钮或点击文件夹图标以查看内容浏览器中的文件夹。从那里，浏览到“Engine Content”，然后到“BasicShapes”，以查看我们将在此配方中使用的立方体：
- en: '![](img/e10cc256-1f8a-40fa-98b8-40c5400f401a.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e10cc256-1f8a-40fa-98b8-40c5400f401a.png)'
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Add the following code to the constructor of your class:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的类构造函数中：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Compile and verify in the Editor that an instance of your class now has a mesh
    as its visual representation:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中编译并验证，以确保你的类实例现在有一个网格作为其视觉表示：
- en: '![](img/4b01adda-3262-411f-a5ef-9600ab836b95.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b01adda-3262-411f-a5ef-9600ab836b95.png)'
- en: If the actor was placed in the world before these changes, the mesh may only
    appear after you try moving the actor in the viewport. For whatever reason, it
    doesn't always update automatically.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在更改之前将演员放置在世界中，网格可能只有在你尝试在视口中移动演员之后才会出现。由于某种原因，它并不总是自动更新。
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create an instance of the `FObjectFinder` class, passing in the type of asset
    that we are trying to load as a template parameter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`FObjectFinder`类的实例，将我们要加载的资源类型作为模板参数传递。
- en: '`FObjectFinder` is a class template that helps us load assets. When we construct
    it, we pass in a string that contains a path to the asset that we are trying to
    load.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`FObjectFinder`是一个类模板，帮助我们加载资源。当我们构造它时，我们传递一个包含要加载的资源路径的字符串。'
- en: The string is of the format `"{ObjectType}'/Path/To/Asset.Asset'"`. Note the
    use of single quotes in the string.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的格式为`"{ObjectType}'/Path/To/Asset.Asset'"`。注意字符串中使用了单引号。
- en: 'To get the string for an asset that already exists in the editor, you can right-click
    on the asset in the Content Browser and select Copy Reference. This gives you
    the string so that you can paste it into your code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取编辑器中已存在的资产字符串，你可以在内容浏览器中右键点击该资产并选择复制引用。这将给你一个字符串，以便你可以将其粘贴到你的代码中：
- en: '![](img/a080553c-e009-4413-91f1-1347e6efe2b8.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a080553c-e009-4413-91f1-1347e6efe2b8.png)'
- en: 'We use the `auto` keyword, from C++11, to avoid typing out our whole object
    type in its declaration; the compiler deduces it for us. Without `auto`, we would
    have to use the following code instead:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 C++11 中的 `auto` 关键字来避免在声明中输入整个对象类型；编译器为我们推断它。如果没有 `auto`，我们则必须使用以下代码：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `FObjectFinder` class has a property called `Object` that will either have
    a pointer to the desired asset, or will be `NULL` if the asset cannot be found.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`FObjectFinder` 类有一个名为 `Object` 的属性，它将指向所需的资产，或者在资产找不到时为 `NULL`。'
- en: This means that we can check it against `nullptr`, and if it isn't null, assign
    it to `Mesh` using `SetStaticMesh`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将其与 `nullptr` 进行比较，如果不是空，则可以使用 `SetStaticMesh` 将其分配给 `Mesh`。
- en: Implementing the Actor functionality by inheritance
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过继承实现 Actor 功能
- en: Inheritance is the second way to implement a custom `Actor`. This is commonly
    done to make a new subclass, which adds member variables, functions, or a Component
    to an existing `Actor` class. In this recipe, we are going to add a variable to
    a custom `GameState` subclass.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是实现自定义 `Actor` 的第二种方式。这通常是为了创建一个新的子类，它向现有的 `Actor` 类添加成员变量、函数或组件。在这个配方中，我们将向自定义的
    `GameState` 子类添加一个变量。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the Unreal Editor, click on Add New in the Content Browser. Then, in New
    C++ Class..., select Game State Base as the base class, and give your new class
    a name (I''ll be using the default `MyGameStateBase` by creating the `AMyGameStateBase`
    class):'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unreal 编辑器中，点击内容浏览器中的“添加新内容”。然后，在“新建 C++ 类...”中，选择“游戏状态基”作为基类，并为你的新类命名（我将使用默认的
    `MyGameStateBase` 通过创建 `AMyGameStateBase` 类）：
- en: '![](img/a9707562-42a3-4c40-b578-031460d86dc0.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9707562-42a3-4c40-b578-031460d86dc0.png)'
- en: The `GameState` class is responsible for information that is meant to be shared
    by all players and is specific to the Game Mode, but is not specific to any individual
    player. Let's say we are working on a cooperative game and all players are working
    together for a combined score. It would make sense for this information to be
    included in this class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameState` 类负责所有玩家共享的信息，并且特定于游戏模式，但不特定于任何单个玩家。假设我们正在开发一个合作游戏，所有玩家都在为总分数共同努力。将这些信息包含在这个类中是有意义的。'
- en: 'Add the following code to the new class header:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到新类头文件中：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following code to the `.cpp` file:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `.cpp` 文件中：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Confirm that your code looks like the following listing, and compile it using
    the Compile button in the Unreal Editor:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的代码看起来像以下列表，并使用 Unreal 编辑器中的编译按钮进行编译：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we add the declaration of a default constructor:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加默认构造函数的声明：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This allows us to set our new member variable to a safe default value of `0`
    on object initialization:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在对象初始化时将我们的新成员变量设置为安全的默认值 `0`：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We use the `int32` type when declaring our new variable to ensure portability
    between the various compilers that Unreal Engine supports. This variable is going
    to be responsible for storing the current game score while it is running.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在声明新变量时使用 `int32` 类型，以确保在 Unreal Engine 支持的各种编译器之间具有可移植性。这个变量将负责在运行时存储当前游戏分数。
- en: If you want the value to only be positive, you can use the `uint32` type instead,
    which is for unsigned numbers only.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望值只能是正数，你可以使用 `uint32` 类型，它仅用于无符号数。
- en: 'As always, we will be marking our variable with `UPROPERTY` so that it is garbage-collected
    appropriately. This variable is marked `private` so that the only way to change
    the value is through our functions:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将使用 `UPROPERTY` 标记我们的变量，以便它能够适当地进行垃圾回收。这个变量被标记为 `private`，这样唯一改变值的方法就是通过我们的函数：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `GetScore` function will retrieve the current score and return it to the
    caller. It is implemented as a simple accessor, which simply returns the underlying
    member variable.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetScore` 函数将检索当前分数并将其返回给调用者。它被实现为一个简单的访问器，它简单地返回底层的成员变量。'
- en: The second function, `SetScore`, sets the value of the member variable, allowing
    external objects to request a change to the score. Placing this request as a function
    ensures that the `GameState` can vet such requests, and only allow them when they're
    valid, to prevent cheating. The specifics of such a check are beyond the scope
    of this recipe, but the `SetScore` function is the appropriate place to make them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数`SetScore`设置成员变量的值，允许外部对象请求更改分数。将此请求作为一个函数确保`GameState`可以审查此类请求，并且只有在它们有效时才允许它们，以防止作弊。此类检查的细节超出了本配方的范围，但`SetScore`函数是进行此类检查的适当位置。
- en: 'Cedric ''eXi'' Neukirchen has created an excellent and very extensive document
    on this topic here: [http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen_BW.pdf](http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen_BW.pdf).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Cedric 'eXi' Neukirchen在这里创建了一个关于这个主题的优秀且非常广泛的文档：[http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen_BW.pdf](http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen_BW.pdf)。
- en: Our score functions are declared using the `UFUNCTION` macro for a number of
    reasons. First, `UFUNCTION`, with some additional code, can be called or overridden
    by Blueprints. Second, `UFUNCTION` can be marked as `exec`, which means that they
    can be run as console commands by a player or developer during a play session,
    which enables debugging.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的得分函数使用`UFUNCTION`宏声明，出于多个原因。首先，`UFUNCTION`加上一些额外的代码可以被蓝图调用或覆盖。其次，`UFUNCTION`可以被标记为`exec`，这意味着它们可以在游戏会话期间由玩家或开发者作为控制台命令运行，这有助于调试。
- en: See also
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 9](c73bb4ba-4b7d-4aef-a33e-732f184d261f.xhtml), *Integrating C++ and
    the Unreal Editor: Part II,* has a recipe called *Creating new console commands*,
    which you can refer to for more information regarding `exec` and the console command
    functionality'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第9章](c73bb4ba-4b7d-4aef-a33e-732f184d261f.xhtml)，*整合C++和Unreal编辑器：第二部分*，有一个名为*创建新的控制台命令*的配方，你可以参考它以获取有关`exec`和控制台命令功能的更多信息。'
- en: Attaching components to create a hierarchy
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过附加组件来创建层次结构
- en: When creating custom Actors from components, it is important to consider the
    concept of **attaching**. Attaching components creates a relationship where transformations
    that are applied to the parent component will also affect the components that
    are attached to it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当从组件创建自定义actor时，考虑**附加**的概念非常重要。附加组件创建了一个关系，即应用于父组件的变换也会影响附加到它的组件。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new class derived from the  `Actor` class using the editor and call
    it `HierarchyActor`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器创建一个从`Actor`类派生的新类，并将其命名为`HierarchyActor`。
- en: 'Add the following properties to your new class in the header file (`HierarchyActor.h`):'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件（`HierarchyActor.h`）中添加以下属性到你的新类中：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following code to the class constructor:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类构造函数中：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Compile and launch the editor. Drag a copy of `HierarchyActor` into the scene:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并启动编辑器。将`HierarchyActor`的一个副本拖入场景：
- en: '![](img/f978bc11-df51-42b0-b644-c49f5e52f0fb.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f978bc11-df51-42b0-b644-c49f5e52f0fb.png)'
- en: 'Verify that `Actor` has components in a hierarchy, and that the second box
    is a smaller size:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`Actor`是否具有层次结构中的组件，并且第二个框的大小更小：
- en: '![](img/0b9ec562-6754-455d-b342-43cc0e478f2b.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b9ec562-6754-455d-b342-43cc0e478f2b.png)'
- en: If you do not see the Root (Inherited) section under the Details tab, it is
    possible to drag the mouse above the search bar to extend it out.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在详细信息选项卡下没有看到根（继承）部分，你可以将鼠标拖到搜索栏上方来扩展它。
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As usual, we create some tagged `UPROPERTY` Components for our actor. In this
    case, we added an additional parameter to the tag called `VisibleAnywhere`, so
    that we can see our variables within the Details tab. We create two Scene Components
    and two Static Mesh components.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们为我们的actor创建了一些带标签的`UPROPERTY`组件。在这种情况下，我们向标签添加了一个额外的参数，称为`VisibleAnywhere`，这样我们就可以在详细信息选项卡中看到我们的变量。我们创建了两个场景组件和两个静态网格组件。
- en: In the constructor, we create default subobjects for each component, as usual.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们为每个组件创建了默认的子对象，就像往常一样。
- en: We then load the static mesh, and if loading is successful, assign it to the
    two static mesh components so that they have a visual representation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们加载静态网格，如果加载成功，将其分配给两个静态网格组件，以便它们有视觉表示。
- en: We then construct a hierarchy within our `Actor` by attaching components.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后在我们的`Actor`中通过附加组件来构建一个层次结构。
- en: We set the first Scene Component as the `Actor` root. This component will determine
    the transformations that are applied to all other components in the hierarchy.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将第一个场景组件设置为`Actor`的根组件。此组件将确定应用于层次结构中所有其他组件的变换。
- en: We then attach the first box to our new root component and parent the second
    scene component to the first one.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将第一个盒子附加到我们的新根组件上，并将第二个场景组件作为第一个组件的父组件。
- en: We attach the second box to our child scene component to demonstrate how changing
    the transform on that scene component affects its children, but no other components
    in the object.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将第二个盒子附加到子场景组件上，以演示如何更改该场景组件的变换会影响其子组件，但不会影响对象中的其他组件。
- en: Lastly, we set the relative transform of that scene component so that it moves
    a certain distance away from the origin, and is one-tenth of the scale.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置该场景组件的相对变换，使其从原点移动一定距离，并且缩放为原来的十分之一。
- en: This means that in the Editor, you can see that the `BoxTwo` component has inherited
    the translation and scaling of its parent component, `ChildSceneComponent`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在编辑器中，你可以看到`BoxTwo`组件已经继承了其父组件`ChildSceneComponent`的平移和缩放。
- en: Creating a custom Actor Component
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义演员组件
- en: Actor components are an easy way to implement common functionality that should
    be shared between Actors. Actor components aren't rendered, but can still perform
    actions such as subscribing to events, or communicating with other components
    of the Actor that they are inside.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 演员（Actor）组件是实现应在演员之间共享的常见功能的一种简单方式。演员组件不会被渲染，但仍然可以执行诸如订阅事件或与其所在演员的其他组件通信等操作。
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create an `ActorComponent` named `RandomMovementComponent` using the Editor
    wizard:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器向导创建一个名为`RandomMovementComponent`的`ActorComponent`：
- en: '![](img/7e5e56d7-96ca-45c1-8e46-241ffee79da7.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e5e56d7-96ca-45c1-8e46-241ffee79da7.png)'
- en: 'Add the following `UPROPERTY` to the class header in the public section:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公共部分类头文件中添加以下`UPROPERTY`：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following code to the constructor''s implementation:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到构造函数的实现中：
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lastly, add the following code to the implementation of `TickComponent( )`:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下代码添加到`TickComponent()`的实现中：
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Compile your project. In the editor, create an empty `Actor` and add your Random
    Movement Component to it. For example, from the Modes tab, go to the Basic option
    and drag and drop a Cube into your level.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的项目。在编辑器中，创建一个空的`Actor`，并将你的随机移动组件添加到其中。例如，从模式选项卡转到基本选项，并将一个立方体拖放到你的关卡中。
- en: 'Afterwards, ensure that the Transform component''s Mobility property is set
    to Moveable from the Details tab:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，确保在详情选项卡中将变换组件的移动性属性设置为可移动：
- en: '![](img/637d0947-9dfb-451e-998a-729739f42501.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/637d0947-9dfb-451e-998a-729739f42501.png)'
- en: 'Then, with the object selected, click on Add Component in the Details panel
    and select Random Movement:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择对象后，在详情面板中单击添加组件，并选择随机移动：
- en: '![](img/cd367a36-8adb-4a14-9f4d-a247f43044e8.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd367a36-8adb-4a14-9f4d-a247f43044e8.png)'
- en: 'Play your level and observe the actor randomly moving around as its location
    changes every time the `TickComponent` function is called:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的关卡，并观察演员在每次调用`TickComponent`函数时其位置改变时的随机移动：
- en: '![](img/7befead9-e431-42e6-9f29-882bb5a0e06b.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7befead9-e431-42e6-9f29-882bb5a0e06b.png)'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we add a few specifiers to the `UCLASS` macro that was used in our component''s
    declaration. Adding `BlueprintSpawnableComponent` to the class''s meta values
    means that instances of the component can be added to Blueprint classes in the
    editor. The `ClassGroup` specifier allows us to indicate what category of class
    our Component belongs to in the list of classes:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在组件声明中使用的`UCLASS`宏中添加了一些指定项。将`BlueprintSpawnableComponent`添加到类的元值中意味着该组件的实例可以被添加到编辑器中的蓝图类中。`ClassGroup`指定项允许我们在类列表中指示我们的组件属于哪个类别：
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Adding `MovementRadius` as a property to the new component allows us to specify
    how far the component will be allowed to wander in a single frame:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MovementRadius`作为属性添加到新组件中，允许我们指定组件在单个帧内可以随意游荡的距离：
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the constructor, we initialize this property to a safe default value:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将此属性初始化为安全的默认值：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`TickComponent` is a function that is called every frame by the engine, just
    like `Tick` is for Actors. In its implementation, we retrieve the current location
    of the component''s owner, that is, the `Actor` that contains our component, and
    we generate an offset in the world space:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`TickComponent`是一个由引擎每帧调用的函数，就像`Tick`对于actor一样。在其实现中，我们检索组件拥有者的当前位置，即包含我们的组件的`Actor`，并在世界空间中生成一个偏移量：'
- en: '[PRE34]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We add the random offset to the current location to determine a new location
    and move the owning actor to it. This causes the actor's location to randomly
    change from frame to frame and dance about.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将随机偏移量添加到当前位置以确定新位置，并将拥有者actor移动到那里。这导致actor的位置在帧与帧之间随机变化并舞动。
- en: Creating a custom Scene Component
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义场景组件
- en: '`Scene` Components are a subclass of `Actor` Components that have a transform,
    that is, a relative location, rotation, and scale. Just like `Actor` Components,
    `Scene` Components aren''t rendered themselves, but can use their transform for
    various things, such as spawning other objects at a fixed offset from an `Actor`.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene`组件是具有变换的`Actor`组件的子类，即相对位置、旋转和缩放。就像`Actor`组件一样，`Scene`组件本身不进行渲染，但可以使用其变换进行各种操作，例如在`Actor`的固定偏移量处生成其他对象。'
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a custom `SceneComponent` called `ActorSpawnerComponent`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ActorSpawnerComponent`的自定义`SceneComponent`：
- en: '![](img/83bd074a-030f-46c2-baa9-9a4b1ccfdde6.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83bd074a-030f-46c2-baa9-9a4b1ccfdde6.png)'
- en: 'Make the following changes to the header:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对头文件进行以下更改：
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the following function implementation to the `.cpp` file:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数实现添加到`.cpp`文件中：
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Compile and open your project. Drag an empty `Actor` into the scene and add
    your `ActorSpawnerComponent` to it. Select your new Component in the Details panel
    and assign a value to `ActorToSpawn`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并打开你的项目。将一个空`Actor`拖入场景，并将你的`ActorSpawnerComponent`添加到它上面。在详细信息面板中选择你的新组件，并分配一个值给`ActorToSpawn`。
- en: Now, whenever `Spawn()` is called on an instance of your component, it will
    instantiate a copy of the `Actor` class that's specified in `ActorToSpawn`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当在组件的实例上调用`Spawn()`时，它将实例化`ActorToSpawn`中指定的`Actor`类的副本。
- en: How it works...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We create the `Spawn UFUNCTION` and a variable called `ActorToSpawn`. The `ActorToSpawn``UPROPERTY`
    is of the `TSubclassOf< >` type, a template type that allows us to restrict a
    pointer to either a base class or subclasses thereof. This also means that within
    the editor, we will get a pre-filtered list of classes to pick from, preventing
    us from accidentally assigning an invalid value:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`Spawn UFUNCTION`和一个名为`ActorToSpawn`的变量。`ActorToSpawn``UPROPERTY`是`TSubclassOf<
    >`类型，这是一种模板类型，允许我们将指针限制为基类或其子类。这也意味着在编辑器中，我们将获得一个预先过滤的类列表以供选择，防止我们意外分配无效的值：
- en: '![](img/6b7004ee-a06d-4099-b334-bb0d9433f0aa.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b7004ee-a06d-4099-b334-bb0d9433f0aa.png)'
- en: Inside the `Spawn` function's implementation, we get access to our world. From
    here, we check it for validity.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Spawn`函数的实现内部，我们获取对世界的访问权限。从这里，我们检查其有效性。
- en: '`SpawnActor` wants an `FTransform*` to specify the location to spawn the new
    actor to, so we create a new stack variable to contain a copy of the current component''s
    transform.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpawnActor`需要一个`FTransform*`来指定新actor的生成位置，因此我们创建一个新的栈变量来包含当前组件变换的副本。'
- en: If `TheWorld` is valid, we request it to spawn an instance of the specified `ActorToSpawn` subclass,
    passing in the address of the `FTransform` we just created, which now contains
    the desired location for the new actor.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`TheWorld`有效，我们请求它生成指定的`ActorToSpawn`子类的实例，传入我们刚刚创建的`FTransform`的地址，它现在包含新actor期望的位置。
- en: See also
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '[Chapter 8](bded5c5b-3038-4d12-b03d-39218257492b.xhtml), *Integrating C++ and
    the Unreal Editor,* contains a much more detailed investigation into how you can
    make things Blueprint-accessible'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](bded5c5b-3038-4d12-b03d-39218257492b.xhtml)，*整合C++和虚幻编辑器*，包含了对如何使事物蓝图可访问的更详细的研究'
- en: Creating an InventoryComponent for an RPG
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为RPG创建一个库存组件
- en: An `InventoryComponent` enables its containing `Actor` to store `InventoryActors`
    in its inventory, and place them back into the game world.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`InventoryComponent`使包含它的`Actor`能够将其`InventoryActors`存储在它的库存中，并将它们放回游戏世界。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you've followed the *Axis mappings – keyboard, mouse, and gamepad
    directional input for an FPS character* recipe in [Chapter 6](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml),
    *Input and Collision,* before continuing with this recipe, as it shows you how
    to create a simple character.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续此配方之前，请确保你已经遵循了[第6章](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml)，*输入和碰撞*中的*轴映射
    - 键盘、鼠标和游戏手柄方向输入用于FPS角色*配方，因为它展示了如何创建一个简单的角色。
- en: Also, the *Instantiating an Actor using SpawnActor* recipe in this chapter shows
    you how to create a custom `GameMode`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章中的*使用SpawnActor实例化Actor*配方展示了如何创建自定义`GameMode`。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create an `ActorComponent` subclass using the engine called `InventoryComponent`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用引擎创建一个名为`InventoryComponent`的`ActorComponent`子类：
- en: '![](img/6a88aa60-de6e-48da-9a0b-df939365bc5f.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a88aa60-de6e-48da-9a0b-df939365bc5f.png)'
- en: 'Inside of the `InventoryComponent.h` file, add the following code:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`InventoryComponent.h`文件内部，添加以下代码：
- en: '[PRE37]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following function implementation to the source file:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数实现添加到源文件中：
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, create a new `StaticMeshActor` subclass called `InventoryActor`. Remember
    to check Show All Classes to see the `StaticMeshActor` class:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的`StaticMeshActor`子类，名为`InventoryActor`。记得检查显示所有类以查看`StaticMeshActor`类：
- en: '![](img/253b7cd0-e29a-4bc8-88b5-15fcd7b599ac.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/253b7cd0-e29a-4bc8-88b5-15fcd7b599ac.png)'
- en: 'Now that we have the file, go to the `InventoryComponent.h` file and add the
    following includes:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了文件，前往`InventoryComponent.h`文件并添加以下包含：
- en: '[PRE39]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Return to the `InventoryActor.h` file and add the following to its declaration:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`InventoryActor.h`文件并添加以下到其声明中：
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implement the new functions in the implementation file:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中实现新函数：
- en: '[PRE41]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Also, change the constructor to look like the following:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将构造函数修改如下：
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Afterwards, we need to add the following #includes for `InventoryActor.cpp`:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要为`InventoryActor.cpp`添加以下`#includes`：
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We need to add an `InventoryComponent` to our character so that we have an
    inventory that we can store items in. Create a class that''s derived from the `Character`
    class called `InventoryCharacter`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要向我们的角色添加一个`InventoryComponent`，以便我们可以在其中存储物品的库存。创建一个从`Character`类派生的类，名为`InventoryCharacter`：
- en: '![](img/5a38752a-967c-49e6-a018-7e2316e3a4e4.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a38752a-967c-49e6-a018-7e2316e3a4e4.png)'
- en: 'Add the following to the #includes:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下到`#includes`：
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, add the following to the `InventoryCharacter` class''s declaration:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下添加到`InventoryCharacter`类的声明中：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the following line to the character''s constructor implementation:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到角色的构造函数实现中：
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add the following code to the overridden `SetupPlayerInputComponent`:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到重写的`SetupPlayerInputComponent`：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, add in the `MoveForward`, `MoveRight`, `CameraPitch`, and `CameraYaw`
    axes and `DropItem` action to the `Input` menu. If you do not recall how to do
    this, read [Chapter 6](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml), *Input and
    Collision*, where we go into detail on this. Here are the settings that I used
    for this particular example:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`MoveForward`、`MoveRight`、`CameraPitch`和`CameraYaw`轴以及`DropItem`动作添加到`Input`菜单中。如果你不记得如何做，请阅读[第6章](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml)，*输入和碰撞*，其中我们详细介绍了这一点。以下是我在这个特定示例中使用的设置：
- en: '![](img/8001e2c7-62e2-434b-8865-931916baf3c8.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8001e2c7-62e2-434b-8865-931916baf3c8.png)'
- en: 'Finally, add the following function implementations:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下函数实现：
- en: '[PRE48]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To handle the movement functions, update the `Tick` function to the following:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理移动函数，更新`Tick`函数如下：
- en: '[PRE49]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, add the following #include:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加以下`#include`：
- en: '[PRE50]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Compile your code and test it in the Editor. Create a new level and drag a few
    instances of `InventoryActor` out into your scene.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并在编辑器中测试它。创建一个新的关卡并将几个`InventoryActor`实例拖到场景中。
- en: 'Refer to the *Instantiating an Actor using SpawnActor* recipe if you need a
    reminder of how to override the current game mode. Add the following line to the
    constructor of your Game Mode from that recipe, and then set your level''s `GameMode`
    to the one you created in that recipe:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要提醒如何覆盖当前游戏模式，请参考*使用SpawnActor实例化Actor*配方。将以下行添加到该配方中Game Mode的构造函数中，然后将你的关卡`GameMode`设置为在该配方中创建的那个：
- en: '[PRE51]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Of course, we will also need to update the GameMode''s `.h` file:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，我们还需要更新GameMode的`.h`文件：
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Compile and launch your project. If all went well, you should be able to pick
    up objects by walking on them:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并启动你的项目。如果一切顺利，你应该能够通过在它们上行走来拾取物体：
- en: '![](img/d7b159e0-643e-487e-a0e9-d35608810661.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7b159e0-643e-487e-a0e9-d35608810661.png)'
- en: 'Then, you can drop the items whenever you hit the key that''s assigned for
    `DropItem` in front of you:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以随时按分配给`DropItem`的键丢弃物品：
- en: '![](img/0f75e9f4-9f66-47dd-a18b-e01ec1148af8.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f75e9f4-9f66-47dd-a18b-e01ec1148af8.png)'
- en: How it works...
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our new component contains an array of actors, storing them by pointer as well
    as declaring functions that add or remove items to the array. These functions
    are simple wrappers around the `TArray` add/remove functionality, but allow us
    to optionally do things such as checking whether the array is within a specified
    size limit before going ahead with storing the item.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新组件包含一个演员数组，通过指针存储它们，并声明添加或从数组中删除物品的函数。这些函数是`TArray`添加/删除功能的简单包装，但允许我们选择性地执行诸如在存储物品之前检查数组是否在指定的尺寸限制内等操作。
- en: '`InventoryActor` is a base class that can be used for all of the items that
    can be taken by a player.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryActor`是一个基类，可用于所有可以被玩家取走的物品。'
- en: 'In the `PickUp` function, we need to disable the actor when it is picked up.
    To do that, we have to do the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PickUp`函数中，当演员被拾起时，我们需要禁用该演员。为此，我们必须执行以下操作：
- en: Disable actor ticking
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用演员计时
- en: Hide the actor
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏演员
- en: Disable collision
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用碰撞
- en: We do this with the `SetActorTickEnabled`, `SetActorHiddenInGame`, and `SetActorEnableCollision` functions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`SetActorTickEnabled`、`SetActorHiddenInGame`和`SetActorEnableCollision`函数来完成此操作。
- en: The `PutDown` function is the reverse of this. We enable actor ticking, unhide
    the actor, and then turn its collision back on, and we transport the actor to
    the desired location.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`PutDown`函数是此操作的逆操作。我们启用演员计时，取消隐藏演员，然后将其碰撞重新打开，并将演员传输到所需的位置。'
- en: We add an `InventoryComponent` to our new character as well as a function to
    take items.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的新角色中添加了一个`InventoryComponent`以及一个取物品的函数。
- en: In the constructor for our character, we create a default subobject for our
    `InventoryComponent`. We also add a `NotifyHit` override so that we are notified
    when the character hits other Actors.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们角色的构造函数中，我们为我们的`InventoryComponent`创建一个默认的子对象。我们还添加了一个`NotifyHit`重写，这样当角色击中其他演员时，我们会收到通知。
- en: Inside this function, we cast the other actor to an `InventoryActor`. If the
    cast is successful, then we know our `Actor` was an `InventoryActor`, and so we
    can call the `TakeItem` function to take it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数内部，我们将其他演员强制转换为`InventoryActor`。如果转换成功，那么我们知道我们的`Actor`是一个`InventoryActor`，因此我们可以调用`TakeItem`函数来取它。
- en: In the `TakeItem` function, we notify the Inventory item actor that we want
    to pick it up, and then we add it to our inventory.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TakeItem`函数中，我们通知库存物品演员我们想要拿起它，然后将其添加到我们的库存中。
- en: The last piece of functionality in the `InventoryCharacter` is the `DropItem`
    function. This function checks whether we have any items in our inventory. If
    it has any items, we remove it from our inventory, and then we calculate a safe
    distance in front of our player character to drop the item using the Item Bounds
    to get its maximum bounding box dimension.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCharacter`中的最后一项功能是`DropItem`函数。此函数检查我们库存中是否有任何物品。如果有，我们从库存中移除它，然后使用物品边界计算在我们玩家角色前方的一个安全距离来丢弃物品，以获取其最大边界框尺寸。'
- en: We then inform the item that we are placing it in the world at the desired location.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后通知物品，我们正在将其放置在所需位置的世界中。
- en: See also
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '[Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling Events and
    Delegates,* has a detailed explanation of how events and input handling work together
    within the Engine, as well as a recipe for the `SimpleCharacter` class we mentioned
    in this recipe'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml)，*处理事件和委托*，详细解释了事件和输入处理如何在引擎内部协同工作，以及我们在此配方中提到的`SimpleCharacter`类的配方'
- en: '[Chapter 6](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml), *Input and Collision,*
    also has recipes concerning the binding of input actions and axes'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml)，*输入和碰撞*，也包含有关绑定输入动作和轴的配方'
- en: Creating an OrbitingMovement Component
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个绕轨道运动的组件
- en: This component is similar to `RotatingMovementComponent` in that it is designed
    to make the components parented to it move in a particular way. In this instance,
    it will move any attached components in an orbit around a fixed point at a fixed
    distance.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件与`RotatingMovementComponent`类似，因为它旨在使与之关联的组件以特定方式移动。在这种情况下，它将以固定距离围绕一个固定点移动任何附加的组件。
- en: This could be used, for example, for a shield that orbits around a character
    in an **Action RPG**.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于例如，一个围绕**动作角色扮演游戏**中的角色旋转的护盾。
- en: How to do it...
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new `SceneComponent` subclass called `OrbitingMovementComponent`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的名为 `OrbitingMovementComponent` 的 `SceneComponent` 子类：
- en: '![](img/12609215-3391-497d-9a47-7234f7f59bdf.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12609215-3391-497d-9a47-7234f7f59bdf.png)'
- en: 'Add the following properties to the class declaration:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到类声明中：
- en: '[PRE53]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add the following code to the constructor:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到构造函数中：
- en: '[PRE54]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the following code to the `TickComponent` function:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `TickComponent` 函数中：
- en: '[PRE55]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can test this component by creating a simple `Actor` Blueprint.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过创建一个简单的 `Actor` 蓝图来测试这个组件。
- en: 'Add an `OrbitingMovement` Component to your `Actor`, and then add a few meshes
    using the `Cube` component. Parent them to the `OrbitingMovement` component by
    dragging them onto it in the Components panel. The resulting hierarchy should
    look as follows:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `OrbitingMovement` 组件添加到你的 `Actor` 中，然后使用 `Cube` 组件添加一些网格。通过在组件面板中将它们拖放到它上，将它们设置为
    `OrbitingMovement` 组件的父组件。结果层次结构应如下所示：
- en: '![](img/06f23a38-ca51-46ec-a3b5-c7b2d49502cc.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06f23a38-ca51-46ec-a3b5-c7b2d49502cc.png)'
- en: Refer to the *Creating a custom Actor Component* recipe if you're unsure of
    the process.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你对这个过程不确定，请参考 *创建自定义 Actor 组件* 菜谱。
- en: Hit play to see the meshes moving around in a circular pattern around the center
    of the `Actor`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放以查看网格在 `Actor` 的中心周围以圆形模式移动。
- en: How it works...
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The properties that are added to the component are the basic parameters that
    we use to customize the circular motion of the component.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到组件中的属性是我们用来自定义组件圆周运动的基本参数。
- en: '`RotateToFaceOutwards` specifies whether the component will orient to face
    away from the center of rotation on every update. `RotationSpeed` is the number
    of degrees the component rotates every second.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`RotateToFaceOutwards` 指定组件是否在每次更新时面向旋转中心的外侧。`RotationSpeed` 是组件每秒旋转的度数。'
- en: '`OrbitDistance` indicates the distance that the components that rotate must
    be moved from the origin. `CurrentValue` is the current rotation position in degrees.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrbitDistance` 表示旋转组件必须从原点移动的距离。`CurrentValue` 是当前旋转位置（以度为单位）。'
- en: Inside our constructor, we establish some sane defaults for our new component.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们为我们的新组件设置一些合理的默认值。
- en: In the `TickComponent` function, we calculate the location and rotation of our
    component.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TickComponent` 函数中，我们计算组件的位置和旋转。
- en: The formula in the next step requires our angles to be expressed in radians
    rather than degrees. Radians describe an angle in terms of *π*. First, we use
    the `DegreesToRadians` function to convert our current value in degrees to radians.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步的公式需要我们的角度以弧度而不是度为单位表示。弧度用 *π* 来描述一个角度。首先，我们使用 `DegreesToRadians` 函数将当前值（以度为单位）转换为弧度。
- en: The `SetRelativeLocation` function uses the general equation for circular motion,
    that is, *Pos(θ) = cos(θ in radians), sin(θ in radians)*. We preserve the *Z*
    axis position of each object.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetRelativeLocation` 函数使用圆周运动的通用公式，即，*Pos(θ) = cos(θ in radians), sin(θ in
    radians)*。我们保留每个对象的 *Z* 轴位置。'
- en: The next step is to rotate the object back toward the origin (or directly away
    from it). This is only calculated if `RotateToFaceOutwards` is `true`, and involves
    getting the relative offset of the component to its parent and creating a rotator
    based on a vector pointing from the parent to the current relative offset. We
    then set the relative rotation to the resulting rotator.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将对象旋转回原点（或直接远离它）。这仅在 `RotateToFaceOutwards` 为 `true` 时计算，涉及获取组件相对于其父组件的偏移量，并基于从父组件指向当前相对偏移量的向量创建一个旋转器。然后我们将相对旋转设置为结果旋转器。
- en: Lastly, we increment the current value in degrees so that it moves `RotationSpeed`
    units per second, clamping the resulting value between 0 and 360 to allow the
    rotation to loop.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们增加当前值（以度为单位），使其以每秒 `RotationSpeed` 个单位移动，将结果值限制在 0 到 360 之间，以允许旋转循环。
- en: Creating a building that spawns units
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个生成单位的建筑
- en: For this recipe, we will create a building that spawns units at a fixed time
    interval at a particular location.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将创建一个建筑，在特定位置以固定的时间间隔生成单位。
- en: How to do it...
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new `Actor` subclass in the editor, which we will name `Barracks`:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个新的 `Actor` 子类，我们将它命名为 `Barracks`：
- en: '![](img/7df75b09-439e-41bc-b8e7-a5c519efe1fd.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7df75b09-439e-41bc-b8e7-a5c519efe1fd.png)'
- en: 'Then, add the following implementation to the class:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下实现添加到类中：
- en: '[PRE56]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add the following code to the constructor:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到构造函数中：
- en: '[PRE57]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Currently, we do not have the `BarracksUnit` class created, so you'll see Visual
    Studio complain. We'll implement that as soon as we finish up the `Barracks` class.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还没有创建 `BarracksUnit` 类，所以你会看到 Visual Studio 抱怨。我们将在完成 `Barracks` 类后立即实现它。
- en: 'Add the following code to the `BeginPlay` function:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `BeginPlay` 函数中：
- en: '[PRE58]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create the implementation for the `SpawnUnit` function:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `SpawnUnit` 函数创建实现：
- en: '[PRE59]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Implement the overridden `EndPlay` function:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写的 `EndPlay` 函数：
- en: '[PRE60]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, create a new character subclass, `BarracksUnit`, and add one property:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的角色子类，`BarracksUnit`，并添加一个属性：
- en: '[PRE61]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You''ll need to add the following #include to get access to the `UParticleSystemComponent`
    class:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '你需要添加以下 #include 以获取对 `UParticleSystemComponent` 类的访问权限：'
- en: '[PRE62]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Initialize the component in the constructor implementation:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数实现中初始化组件：
- en: '[PRE63]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Attach the visual representation to the root component:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视觉表示附加到根组件：
- en: '[PRE64]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Lastly, add the following to the `Tick` function to get the spawned actor moving:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下内容添加到 `Tick` 函数中，以使生成的演员开始移动：
- en: '[PRE65]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Compile your project. Place a copy of the barracks actor into the level. You
    can then observe it spawning the character at fixed intervals.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的项目。将营地演员的一个副本放入关卡中。然后你可以观察到它以固定的时间间隔生成角色。
- en: If all went well, you should be able to drag and drop a `Barracks` object into
    the world and play the game. Afterwards, you'll notice objects (`BarracksUnit`
    objects) being spawned from a singular point and continually moving in a direction!
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能够将 `Barracks` 对象拖放到世界中并玩游戏。之后，你会注意到对象（`BarracksUnit` 对象）从一个单一的位置生成，并持续朝一个方向移动！
- en: '![](img/ca986044-837e-4148-a6f0-5c8d32c9bbe3.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca986044-837e-4148-a6f0-5c8d32c9bbe3.png)'
- en: How it works...
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we create the barracks actor. We add a particle system component to indicate
    where the new units will be spawning and a static mesh for the visual representation
    of the building.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建营地演员。我们添加一个粒子系统组件来指示新单位将生成的地方，以及一个静态网格来表示建筑的视觉表示。
- en: In the constructor, we initialize the components and then set their values using
    `FObjectFinder`. We also set the class to spawn using the `StaticClass` function
    to retrieve a `UClass*` instance from a class type.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们初始化组件，然后使用 `FObjectFinder` 设置它们的值。我们还使用 `StaticClass` 函数设置要生成的类，以从类类型检索
    `UClass*` 实例。
- en: In the `BeginPlay` function of the barracks, we create a timer that calls our
    `SpawnUnit` function at fixed intervals. We store the timer handle in a member
    variable in the class so that when our instance is being destroyed, we can halt
    the timer; otherwise, when the timer triggers again, we'll encounter a crash where
    the object pointer is dereferenced.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在营地的 `BeginPlay` 函数中，我们创建一个计时器，以固定的时间间隔调用我们的 `SpawnUnit` 函数。我们将计时器句柄存储在类的成员变量中，这样当我们的实例正在被销毁时，我们可以停止计时器；否则，当计时器再次触发时，我们会遇到对象指针解引用的崩溃。
- en: The `SpawnUnit` function gets the world space location of the `SpawnPoint` object,
    and then asks the world to spawn an instance of our unit class at that location.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpawnUnit` 函数获取 `SpawnPoint` 对象的世界空间位置，然后要求世界在该位置生成我们单位类的实例。'
- en: '`BarracksUnit` has code in its `Tick()` function to move forward by 10 units
    every frame so that each spawned unit will move to make room for the next one.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`BarracksUnit` 在其 `Tick()` 函数中有代码，每帧向前移动10个单位，这样每个生成的单位都会移动以腾出空间给下一个单位。'
- en: The `EndPlay` function override calls the parent class implementation of the
    function, which is important if there are timers to cancel or perform deinitialization
    in the parent class. It then uses the timer handle stored in `BeginPlay` to cancel
    the timer.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`EndPlay` 函数重写调用父类函数的实现，这在父类中有计时器需要取消或执行反初始化时很重要。然后它使用在 `BeginPlay` 中存储的计时器句柄来取消计时器。'
