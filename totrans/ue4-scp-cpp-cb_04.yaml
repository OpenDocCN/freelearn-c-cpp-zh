- en: Actors and Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom Actor in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating an Actor using SpawnActor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a UFUNCTION
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying an Actor using Destroy and a Timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying an Actor after a delay using SetLifeSpan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Actor functionality by composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading assets into components using FObjectFinder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Actor functionality by inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching components to create a hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom Actor Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom Scene Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an InventoryComponent for an RPG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an OrbitingMovement Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a building that spawns units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actors are classes that have some presence in the game world. Actors gain their
    specialized functionality by incorporating Components. This chapter deals with
    creating custom Actors and Components, the purpose that they serve, and how they
    work together.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom Actor in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are different types of Actors that ship with Unreal as part of the
    default installation, you will find yourself needing to create custom Actors at
    some point during your project's development. This might happen when you need
    to add functionality to an existing class, combine Components in a combination
    that's not present in the default subclasses, or add additional member variables
    to a class. The following two recipes demonstrate how to use either composition
    or inheritance to customize Actors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure that you have installed Visual Studio and Unreal 4 as per the recipe
    in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml), *UE4 Development Tools.*
    You'll also need to have an existing project – if you don't, you can create a
    new one using the Unreal-provided wizard.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open up your project within the Unreal Editor and click on the Add New button
    in Content Browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/efd3d84e-10b0-4d49-8ea8-c53f92ce86f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select New C++ Class...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1d0f7ab4-9130-465d-8be6-5a5e8bd5a31c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the dialog that opens, select Actor from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4524f05e-09f3-4fb8-abfb-d0ad23a869e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Give your Actor a name, such as `MyFirstActor`, and then click on OK to launch
    Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By convention, class names for `Actor` subclasses begin with an `A`. When using
    this class creation wizard, make sure you don't prefix your class with `A`, as
    the engine automatically adds the prefix for you.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef31f6fe-8231-49b3-87e0-6c3edc4007a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When Visual Studio loads, you should see something very similar to the following
    listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In time, you'll become familiar with the standard code, so you will be able
    to just create new classes from Visual Studio without using the Unreal wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MyFirstActor.h`, we have the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#pragma once`: This preprocessor statement, or `pragma`, is Unreal''s expected
    method of implementing include guards pieces of code that prevent an `include`
    file from causing errors by being referenced multiple times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#include "CoreMinimal.h"`: This file includes a number of definitions of classes
    that are often used, such as `FString`, `TArray`, `Vector`, and so on, and is
    included by default in created script files for that reason, though it could still
    compile at this point without it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#include "GameFramework/Actor.h"`: We''re going to create an `Actor` subclass
    so, naturally, we need to include the `header` file for the class we are inheriting
    from so that we know about its contents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#include "MyFirstActor.generated.h"`: All Actor classes need to include their
    `generated.h` file. This file is automatically created by the **Unreal Header
    Tool** (**UHT**) based on the macros that it detects in your files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UCLASS()`: `UCLASS` is one such macro that allows us to indicate that a class
    will be exposed to Unreal''s reflection system. Reflection allows us to inspect
    and iterate object properties during runtime, as well as manage references to
    our objects for garbage collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class CHAPTER_04_API AMyFirstActor : public AActor`: This is the actual declaration
    of our class. The `CHAPTER_04_API ` macro is created by the UHT, and is necessary
    to help our project compile properly on Windows by ensuring that our project module''s
    classes are exported correctly in the DLL. You will also notice that both `MyFirstActor`
    and `Actor` have the prefix `A` – this is the naming convention that Unreal requires
    for native classes that are inherited from `Actor`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that, in this case, `Chapter_04` is the name of the project, and your project
    may have a different name.
  prefs: []
  type: TYPE_NORMAL
- en: '`GENERATED_BODY()`: `GENERATED_BODY` is another UHT macro that has been expanded
    to include the automatically generated functions that the underlying UE type system
    requires.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the `MyFirstActor.cpp` file, we have the following aspects to note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PrimaryActorTick.bCanEverTick = true;`: Inside the constructor implementation,
    this line enables ticking for this `Actor`. All Actors have a function called
    `Tick`, and this Boolean variable means that the `Actor` will have that function
    called once per frame, enabling the actor to perform actions in every frame as
    necessary. As a performance optimization, this is disabled by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BeginPlay/Tick`: You can also see the implementation of two default methods,
    `BeginPlay` and `Tick`, which are called once an object is spawned and every frame
    it is alive, respectively. Currently, these only call the parent''s version of
    the function via `Super::FunctionName`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating an Actor using SpawnActor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you'll need to have an `Actor` subclass ready to instantiate.
    You can use a built-in class such as `StaticMeshActor`, but it would help to practice
    with the custom `Actor` you made in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new C++ class, like in the previous recipe. This time, select Game
    Mode Base as your base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f59f3973-6781-406c-be4b-1525e29de708.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you have clicked Next, give the new class a name, such as `UE4CookbookGameModeBase`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a function override in the `.h` file of your new `GameModeBase` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `BeginPlay` function in the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile your code, either through Visual Studio or by clicking on the Compile
    button in Unreal Editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91a0b957-21e2-4d2f-8f52-81d4bacdbee3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the World Settings panel for the current level by clicking on the Settings
    toolbar icon, and then pick World Settings from the drop-down menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/652d3673-3870-48fc-b748-08d665536339.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the GameMode Override section, change the game mode to the `GameMode` subclass
    you just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e69cfdec-f16a-4902-a53a-e379c485f4e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the GameMode Override property
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the level and verify that `GameMode` spawns a copy of your `Actor` in
    the world by looking at the World Outliner panel. You can verify that the `BeginPlay`
    function is being run by viewing the Actor Spawning text being displayed on screen.
    If it doesn''t spawn, make sure that there are no obstructions at the world origin
    to prevent the `Actor` from being spawned. You can search the list of objects
    in the world by typing in the search bar at the top of the World Outliner panel.
    This will filter the entities that are shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fbbdf8b8-9165-43d8-bf27-706fa64a23af.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GameMode` is a special type of actor that is part of the Unreal Game Framework.
    Your map''s `GameMode` is instantiated by the engine automatically when the game
    starts.'
  prefs: []
  type: TYPE_NORMAL
- en: By placing some code into the `BeginPlay` method of our custom `GameMode`, we
    can run it automatically when the game begins.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `BeginPlay`, we create an `FTransform`, which is going to be used by
    the `SpawnActor` function. By default, `FTransform` is constructed to have zero
    rotation and a location at the origin.
  prefs: []
  type: TYPE_NORMAL
- en: We then get a reference to the current level's `UWorld` instance using `GetWorld`,
    and then we call its `SpawnActor` function. We pass in `FTransform`, which we
    created earlier, to specify that the object should be created at its location,
    that is, the origin.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UFUNCTION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UFUNCTION()` is useful because it is a C++ function that can be called from
    both your C++ client code as well as Blueprint diagrams. Any C++ function can
    be marked as a `UFUNCTION()`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Construct a `UClass` class or a derived class (such as `AActor`) with a member
    function that you'd like to expose to Blueprints. Decorate that member function
    with `UFUNCTION( BlueprintCallable, Category=SomeCategory)` to make it callable
    from Blueprints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, let''s create an `Actor` class called `Warrior` and use the following
    scripts for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Create an instance of your `Warrior` class by going to the Content Browser and
    opening the `C++ Classes\Chapter_04` folder. Once there, drag the `Warrior` icon
    onto your game world and release the mouse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the item in the World Outliner tab. By selecting the newly added
    object, you should be able to see the Name property that we added. Go ahead and
    put in a value here, such as `John`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4597410e-9600-4936-95cd-1ed87e6ec8ba.png)'
  prefs: []
  type: TYPE_IMG
- en: From Blueprints (Blueprints | Open Level Blueprint), get a reference to your
    `Warrior` object. One way to do this is by dragging and dropping the object from
    the World Outliner into the Level Blueprint's Event Graph and letting go.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and hold the blue circle handle on the right-hand side of the Warrior1
    node and drag it over a little bit to the right. Once you release the mouse, you'll
    see a number of actions you can pick from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the `ToString()` function on that `Warrior` instance by clicking on your `Warrior` instance.
    Then, in a Blueprint diagram, type in `ToString`. It should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c709de65-ff1b-4ce7-af93-4e71d6a6eaf3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UFUNCTION()` is really a C++ function, but with additional metadata that makes
    it accessible to Blueprints. This can be incredibly useful in allowing your designers
    to have access to functions that you''ve written.'
  prefs: []
  type: TYPE_NORMAL
- en: Destroying an Actor using Destroy and a Timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will reuse the `GameMode` from the previous recipe, *Instantiating
    an Actor using SpawnActor*, so you should complete that recipe first.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make the following changes to the `GameMode` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `#include "MyFirstActor.h"` to the implementation file''s include statements.
    Remember, we need to place it above the `.generated` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign the results of `SpawnActor` to the new `SpawnedActor` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the end of the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, implement `DestroyActorFunction`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Load the level you created in the previous recipe, which had the game mode set
    to your custom class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play your level and use the World Outliner to verify that your `SpawnedActor`
    is deleted after 10 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c1492b0f-321d-4cb9-8a0b-1f0bfee5bc05.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We declare a `UPROPERTY` to store our spawned `Actor` instance, and a custom
    function so that we can call `Destroy()` on a timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In `BeginPlay`, we assign the spawned `Actor` to our new `UPROPERTY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We then declare a `TimerHandle` object and pass it to `GetWorldTimerManager::SetTimer`.
    `SetTimer` calls `DestroyActorFunction` on the object that was pointed to by this
    pointer after 10 seconds. `SetTimer` returns an object – a handle – to allow us
    to cancel the timer if necessary. The `SetTimer` function takes the `TimerHandle`
    object in as a reference parameter, and so we declare it in advance so that we
    can pass it into the function properly, even if we aren''t going to be using it
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`DestroyActorFunction` checks whether we have a valid reference to a spawned
    `Actor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do, it calls `Destroy` on the instance so it will be destroyed and, eventually,
    garbage-collected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Destroying an Actor after a delay using SetLifeSpan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at how we can destroy an `Actor`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't already, create a new C++ class using the wizard. Select `Actor`
    as your base class. In our case, I will reuse the `AWarrior` class we created
    previously in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the implementation of `Actor`, add the following code to the `BeginPlay`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Drag a copy of your custom `Actor` into the viewport within the Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your level and look at the Outliner to verify that your `Actor` instance
    disappears after 10 seconds, having destroyed itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We insert our code into the `BeginPlay` function so that it executes when the
    game starts.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetLifeSpan` function allows us to specify a duration in seconds, after
    which the `Actor` calls its own `Destroy()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Actor functionality by composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom Actors without components don't have a location, and can't be attached
    to other Actors. Without a root Component, an Actor doesn't have a base transform,
    and so it has no location. Most Actors, therefore, require at least one Component
    to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: We can create custom Actors through composition by adding a number of components
    to our `Actor`, where each component provides some of the functionality that's
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will use the `Actor` class we created in the *Creating a custom
    Actor in C++* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new member to your custom class in C++ by making the following changes
    in the `public` section of the `MyFirstActor.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines to the constructor inside the `MyFirstActor.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once finished, save both files and compile them by using the Compile button
    in the editor, or building the project in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you''ve compiled this code, drag an instance of your class from the Content
    Browser out into the game environment. Here, you will be able to verify that it
    now has a transform and other properties, such as a Static Mesh, which comes from
    the `StaticMeshComponent` that we added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee1cb6d8-1dc7-4bb1-bdd0-c0e6bebf0324.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting the instantiated actor
  prefs: []
  type: TYPE_NORMAL
- en: You can use the search bar on the top of the Details tab to search for specific
    components, such as the Static Mesh component.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UPROPERTY macro` we added to the class declaration is a pointer to hold
    the component we are using as a subobject of our `Actor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using the `UPROPERTY()` macro ensures that the object that was declared in the
    pointer is considered to be referenced, and won't be garbage-collected (that is,
    deleted) out from under us, leaving the pointer dangling.
  prefs: []
  type: TYPE_NORMAL
- en: We're using a Static Mesh component, but any of the `Actor` Component subclasses
    would work. Note that the asterisk is connected to the variable type in accordance
    with Epic's style guide.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we initialize the pointer to a known valid value by using
    a `template` function, `template<class TReturnType> TReturnType* CreateDefaultSubobject(FName
    SubobjectName, bool bTransient = false)`.
  prefs: []
  type: TYPE_NORMAL
- en: This function is responsible for calling the engine code to appropriately initialize
    the component, and return a pointer to the newly constructed object so that we
    can give our component pointer a default value. This is important because it ensures
    that the pointer has a valid value at all times, minimizing the risk of dereferencing
    uninitialized memory.
  prefs: []
  type: TYPE_NORMAL
- en: The function is templated based on the type of object to create, but also takes
    two parameters – the first one is the name of the subobject, which ideally should
    be human-readable, and the second is whether the object should be transient (that
    is, not saved along with the parent object).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following recipe shows you how to reference a mesh asset in your Static
    Mesh Component so that it can be displayed without requiring a user to specify
    a mesh in the Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading assets into components using FObjectFinder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we created a Static Mesh Component, but we didn't try
    to load a mesh for the Component to display. While it's possible to do this in
    the Editor, it is sometimes helpful to specify a default in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complete the previous recipe so that you have a custom `Actor` subclass with
    a Static Mesh Component ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Content Browser, click on the View Options button and select Show Engine
    Content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13ca9ea4-400f-4449-9884-8cb62b9519cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Show/Hide Sources panel button or click on the Folder icon to
    view the folders in the Content Browser. From there, browse to Engine Content and
    then to BasicShapes to see the Cube we will be using in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e10cc256-1f8a-40fa-98b8-40c5400f401a.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following code to the constructor of your class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and verify in the Editor that an instance of your class now has a mesh
    as its visual representation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4b01adda-3262-411f-a5ef-9600ab836b95.png)'
  prefs: []
  type: TYPE_IMG
- en: If the actor was placed in the world before these changes, the mesh may only
    appear after you try moving the actor in the viewport. For whatever reason, it
    doesn't always update automatically.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create an instance of the `FObjectFinder` class, passing in the type of asset
    that we are trying to load as a template parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`FObjectFinder` is a class template that helps us load assets. When we construct
    it, we pass in a string that contains a path to the asset that we are trying to
    load.'
  prefs: []
  type: TYPE_NORMAL
- en: The string is of the format `"{ObjectType}'/Path/To/Asset.Asset'"`. Note the
    use of single quotes in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the string for an asset that already exists in the editor, you can right-click
    on the asset in the Content Browser and select Copy Reference. This gives you
    the string so that you can paste it into your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a080553c-e009-4413-91f1-1347e6efe2b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We use the `auto` keyword, from C++11, to avoid typing out our whole object
    type in its declaration; the compiler deduces it for us. Without `auto`, we would
    have to use the following code instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `FObjectFinder` class has a property called `Object` that will either have
    a pointer to the desired asset, or will be `NULL` if the asset cannot be found.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can check it against `nullptr`, and if it isn't null, assign
    it to `Mesh` using `SetStaticMesh`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Actor functionality by inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is the second way to implement a custom `Actor`. This is commonly
    done to make a new subclass, which adds member variables, functions, or a Component
    to an existing `Actor` class. In this recipe, we are going to add a variable to
    a custom `GameState` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Unreal Editor, click on Add New in the Content Browser. Then, in New
    C++ Class..., select Game State Base as the base class, and give your new class
    a name (I''ll be using the default `MyGameStateBase` by creating the `AMyGameStateBase`
    class):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a9707562-42a3-4c40-b578-031460d86dc0.png)'
  prefs: []
  type: TYPE_IMG
- en: The `GameState` class is responsible for information that is meant to be shared
    by all players and is specific to the Game Mode, but is not specific to any individual
    player. Let's say we are working on a cooperative game and all players are working
    together for a combined score. It would make sense for this information to be
    included in this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the new class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that your code looks like the following listing, and compile it using
    the Compile button in the Unreal Editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we add the declaration of a default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to set our new member variable to a safe default value of `0`
    on object initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We use the `int32` type when declaring our new variable to ensure portability
    between the various compilers that Unreal Engine supports. This variable is going
    to be responsible for storing the current game score while it is running.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the value to only be positive, you can use the `uint32` type instead,
    which is for unsigned numbers only.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we will be marking our variable with `UPROPERTY` so that it is garbage-collected
    appropriately. This variable is marked `private` so that the only way to change
    the value is through our functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `GetScore` function will retrieve the current score and return it to the
    caller. It is implemented as a simple accessor, which simply returns the underlying
    member variable.
  prefs: []
  type: TYPE_NORMAL
- en: The second function, `SetScore`, sets the value of the member variable, allowing
    external objects to request a change to the score. Placing this request as a function
    ensures that the `GameState` can vet such requests, and only allow them when they're
    valid, to prevent cheating. The specifics of such a check are beyond the scope
    of this recipe, but the `SetScore` function is the appropriate place to make them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cedric ''eXi'' Neukirchen has created an excellent and very extensive document
    on this topic here: [http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen_BW.pdf](http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen_BW.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Our score functions are declared using the `UFUNCTION` macro for a number of
    reasons. First, `UFUNCTION`, with some additional code, can be called or overridden
    by Blueprints. Second, `UFUNCTION` can be marked as `exec`, which means that they
    can be run as console commands by a player or developer during a play session,
    which enables debugging.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 9](c73bb4ba-4b7d-4aef-a33e-732f184d261f.xhtml), *Integrating C++ and
    the Unreal Editor: Part II,* has a recipe called *Creating new console commands*,
    which you can refer to for more information regarding `exec` and the console command
    functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching components to create a hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating custom Actors from components, it is important to consider the
    concept of **attaching**. Attaching components creates a relationship where transformations
    that are applied to the parent component will also affect the components that
    are attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new class derived from the  `Actor` class using the editor and call
    it `HierarchyActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following properties to your new class in the header file (`HierarchyActor.h`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and launch the editor. Drag a copy of `HierarchyActor` into the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f978bc11-df51-42b0-b644-c49f5e52f0fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify that `Actor` has components in a hierarchy, and that the second box
    is a smaller size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b9ec562-6754-455d-b342-43cc0e478f2b.png)'
  prefs: []
  type: TYPE_IMG
- en: If you do not see the Root (Inherited) section under the Details tab, it is
    possible to drag the mouse above the search bar to extend it out.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, we create some tagged `UPROPERTY` Components for our actor. In this
    case, we added an additional parameter to the tag called `VisibleAnywhere`, so
    that we can see our variables within the Details tab. We create two Scene Components
    and two Static Mesh components.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we create default subobjects for each component, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: We then load the static mesh, and if loading is successful, assign it to the
    two static mesh components so that they have a visual representation.
  prefs: []
  type: TYPE_NORMAL
- en: We then construct a hierarchy within our `Actor` by attaching components.
  prefs: []
  type: TYPE_NORMAL
- en: We set the first Scene Component as the `Actor` root. This component will determine
    the transformations that are applied to all other components in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: We then attach the first box to our new root component and parent the second
    scene component to the first one.
  prefs: []
  type: TYPE_NORMAL
- en: We attach the second box to our child scene component to demonstrate how changing
    the transform on that scene component affects its children, but no other components
    in the object.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we set the relative transform of that scene component so that it moves
    a certain distance away from the origin, and is one-tenth of the scale.
  prefs: []
  type: TYPE_NORMAL
- en: This means that in the Editor, you can see that the `BoxTwo` component has inherited
    the translation and scaling of its parent component, `ChildSceneComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom Actor Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actor components are an easy way to implement common functionality that should
    be shared between Actors. Actor components aren't rendered, but can still perform
    actions such as subscribing to events, or communicating with other components
    of the Actor that they are inside.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an `ActorComponent` named `RandomMovementComponent` using the Editor
    wizard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7e5e56d7-96ca-45c1-8e46-241ffee79da7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following `UPROPERTY` to the class header in the public section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the constructor''s implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add the following code to the implementation of `TickComponent( )`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project. In the editor, create an empty `Actor` and add your Random
    Movement Component to it. For example, from the Modes tab, go to the Basic option
    and drag and drop a Cube into your level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Afterwards, ensure that the Transform component''s Mobility property is set
    to Moveable from the Details tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/637d0947-9dfb-451e-998a-729739f42501.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, with the object selected, click on Add Component in the Details panel
    and select Random Movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd367a36-8adb-4a14-9f4d-a247f43044e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Play your level and observe the actor randomly moving around as its location
    changes every time the `TickComponent` function is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7befead9-e431-42e6-9f29-882bb5a0e06b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we add a few specifiers to the `UCLASS` macro that was used in our component''s
    declaration. Adding `BlueprintSpawnableComponent` to the class''s meta values
    means that instances of the component can be added to Blueprint classes in the
    editor. The `ClassGroup` specifier allows us to indicate what category of class
    our Component belongs to in the list of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `MovementRadius` as a property to the new component allows us to specify
    how far the component will be allowed to wander in a single frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we initialize this property to a safe default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`TickComponent` is a function that is called every frame by the engine, just
    like `Tick` is for Actors. In its implementation, we retrieve the current location
    of the component''s owner, that is, the `Actor` that contains our component, and
    we generate an offset in the world space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We add the random offset to the current location to determine a new location
    and move the owning actor to it. This causes the actor's location to randomly
    change from frame to frame and dance about.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom Scene Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Scene` Components are a subclass of `Actor` Components that have a transform,
    that is, a relative location, rotation, and scale. Just like `Actor` Components,
    `Scene` Components aren''t rendered themselves, but can use their transform for
    various things, such as spawning other objects at a fixed offset from an `Actor`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a custom `SceneComponent` called `ActorSpawnerComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/83bd074a-030f-46c2-baa9-9a4b1ccfdde6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make the following changes to the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function implementation to the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Compile and open your project. Drag an empty `Actor` into the scene and add
    your `ActorSpawnerComponent` to it. Select your new Component in the Details panel
    and assign a value to `ActorToSpawn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, whenever `Spawn()` is called on an instance of your component, it will
    instantiate a copy of the `Actor` class that's specified in `ActorToSpawn`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We create the `Spawn UFUNCTION` and a variable called `ActorToSpawn`. The `ActorToSpawn``UPROPERTY`
    is of the `TSubclassOf< >` type, a template type that allows us to restrict a
    pointer to either a base class or subclasses thereof. This also means that within
    the editor, we will get a pre-filtered list of classes to pick from, preventing
    us from accidentally assigning an invalid value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b7004ee-a06d-4099-b334-bb0d9433f0aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Inside the `Spawn` function's implementation, we get access to our world. From
    here, we check it for validity.
  prefs: []
  type: TYPE_NORMAL
- en: '`SpawnActor` wants an `FTransform*` to specify the location to spawn the new
    actor to, so we create a new stack variable to contain a copy of the current component''s
    transform.'
  prefs: []
  type: TYPE_NORMAL
- en: If `TheWorld` is valid, we request it to spawn an instance of the specified `ActorToSpawn` subclass,
    passing in the address of the `FTransform` we just created, which now contains
    the desired location for the new actor.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 8](bded5c5b-3038-4d12-b03d-39218257492b.xhtml), *Integrating C++ and
    the Unreal Editor,* contains a much more detailed investigation into how you can
    make things Blueprint-accessible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an InventoryComponent for an RPG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `InventoryComponent` enables its containing `Actor` to store `InventoryActors`
    in its inventory, and place them back into the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you've followed the *Axis mappings – keyboard, mouse, and gamepad
    directional input for an FPS character* recipe in [Chapter 6](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml),
    *Input and Collision,* before continuing with this recipe, as it shows you how
    to create a simple character.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the *Instantiating an Actor using SpawnActor* recipe in this chapter shows
    you how to create a custom `GameMode`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an `ActorComponent` subclass using the engine called `InventoryComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6a88aa60-de6e-48da-9a0b-df939365bc5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside of the `InventoryComponent.h` file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function implementation to the source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new `StaticMeshActor` subclass called `InventoryActor`. Remember
    to check Show All Classes to see the `StaticMeshActor` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/253b7cd0-e29a-4bc8-88b5-15fcd7b599ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the file, go to the `InventoryComponent.h` file and add the
    following includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Return to the `InventoryActor.h` file and add the following to its declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the new functions in the implementation file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, change the constructor to look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, we need to add the following #includes for `InventoryActor.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add an `InventoryComponent` to our character so that we have an
    inventory that we can store items in. Create a class that''s derived from the `Character`
    class called `InventoryCharacter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5a38752a-967c-49e6-a018-7e2316e3a4e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following to the #includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following to the `InventoryCharacter` class''s declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line to the character''s constructor implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the overridden `SetupPlayerInputComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add in the `MoveForward`, `MoveRight`, `CameraPitch`, and `CameraYaw`
    axes and `DropItem` action to the `Input` menu. If you do not recall how to do
    this, read [Chapter 6](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml), *Input and
    Collision*, where we go into detail on this. Here are the settings that I used
    for this particular example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8001e2c7-62e2-434b-8865-931916baf3c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, add the following function implementations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle the movement functions, update the `Tick` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following #include:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code and test it in the Editor. Create a new level and drag a few
    instances of `InventoryActor` out into your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the *Instantiating an Actor using SpawnActor* recipe if you need a
    reminder of how to override the current game mode. Add the following line to the
    constructor of your Game Mode from that recipe, and then set your level''s `GameMode`
    to the one you created in that recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we will also need to update the GameMode''s `.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and launch your project. If all went well, you should be able to pick
    up objects by walking on them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d7b159e0-643e-487e-a0e9-d35608810661.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you can drop the items whenever you hit the key that''s assigned for
    `DropItem` in front of you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0f75e9f4-9f66-47dd-a18b-e01ec1148af8.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our new component contains an array of actors, storing them by pointer as well
    as declaring functions that add or remove items to the array. These functions
    are simple wrappers around the `TArray` add/remove functionality, but allow us
    to optionally do things such as checking whether the array is within a specified
    size limit before going ahead with storing the item.
  prefs: []
  type: TYPE_NORMAL
- en: '`InventoryActor` is a base class that can be used for all of the items that
    can be taken by a player.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PickUp` function, we need to disable the actor when it is picked up.
    To do that, we have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Disable actor ticking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide the actor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable collision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do this with the `SetActorTickEnabled`, `SetActorHiddenInGame`, and `SetActorEnableCollision` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `PutDown` function is the reverse of this. We enable actor ticking, unhide
    the actor, and then turn its collision back on, and we transport the actor to
    the desired location.
  prefs: []
  type: TYPE_NORMAL
- en: We add an `InventoryComponent` to our new character as well as a function to
    take items.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor for our character, we create a default subobject for our
    `InventoryComponent`. We also add a `NotifyHit` override so that we are notified
    when the character hits other Actors.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this function, we cast the other actor to an `InventoryActor`. If the
    cast is successful, then we know our `Actor` was an `InventoryActor`, and so we
    can call the `TakeItem` function to take it.
  prefs: []
  type: TYPE_NORMAL
- en: In the `TakeItem` function, we notify the Inventory item actor that we want
    to pick it up, and then we add it to our inventory.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece of functionality in the `InventoryCharacter` is the `DropItem`
    function. This function checks whether we have any items in our inventory. If
    it has any items, we remove it from our inventory, and then we calculate a safe
    distance in front of our player character to drop the item using the Item Bounds
    to get its maximum bounding box dimension.
  prefs: []
  type: TYPE_NORMAL
- en: We then inform the item that we are placing it in the world at the desired location.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling Events and
    Delegates,* has a detailed explanation of how events and input handling work together
    within the Engine, as well as a recipe for the `SimpleCharacter` class we mentioned
    in this recipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 6](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml), *Input and Collision,*
    also has recipes concerning the binding of input actions and axes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an OrbitingMovement Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This component is similar to `RotatingMovementComponent` in that it is designed
    to make the components parented to it move in a particular way. In this instance,
    it will move any attached components in an orbit around a fixed point at a fixed
    distance.
  prefs: []
  type: TYPE_NORMAL
- en: This could be used, for example, for a shield that orbits around a character
    in an **Action RPG**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `SceneComponent` subclass called `OrbitingMovementComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/12609215-3391-497d-9a47-7234f7f59bdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following properties to the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `TickComponent` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You can test this component by creating a simple `Actor` Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `OrbitingMovement` Component to your `Actor`, and then add a few meshes
    using the `Cube` component. Parent them to the `OrbitingMovement` component by
    dragging them onto it in the Components panel. The resulting hierarchy should
    look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06f23a38-ca51-46ec-a3b5-c7b2d49502cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Refer to the *Creating a custom Actor Component* recipe if you're unsure of
    the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit play to see the meshes moving around in a circular pattern around the center
    of the `Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The properties that are added to the component are the basic parameters that
    we use to customize the circular motion of the component.
  prefs: []
  type: TYPE_NORMAL
- en: '`RotateToFaceOutwards` specifies whether the component will orient to face
    away from the center of rotation on every update. `RotationSpeed` is the number
    of degrees the component rotates every second.'
  prefs: []
  type: TYPE_NORMAL
- en: '`OrbitDistance` indicates the distance that the components that rotate must
    be moved from the origin. `CurrentValue` is the current rotation position in degrees.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside our constructor, we establish some sane defaults for our new component.
  prefs: []
  type: TYPE_NORMAL
- en: In the `TickComponent` function, we calculate the location and rotation of our
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The formula in the next step requires our angles to be expressed in radians
    rather than degrees. Radians describe an angle in terms of *π*. First, we use
    the `DegreesToRadians` function to convert our current value in degrees to radians.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetRelativeLocation` function uses the general equation for circular motion,
    that is, *Pos(θ) = cos(θ in radians), sin(θ in radians)*. We preserve the *Z*
    axis position of each object.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to rotate the object back toward the origin (or directly away
    from it). This is only calculated if `RotateToFaceOutwards` is `true`, and involves
    getting the relative offset of the component to its parent and creating a rotator
    based on a vector pointing from the parent to the current relative offset. We
    then set the relative rotation to the resulting rotator.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we increment the current value in degrees so that it moves `RotationSpeed`
    units per second, clamping the resulting value between 0 and 360 to allow the
    rotation to loop.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a building that spawns units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will create a building that spawns units at a fixed time
    interval at a particular location.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `Actor` subclass in the editor, which we will name `Barracks`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7df75b09-439e-41bc-b8e7-a5c519efe1fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, add the following implementation to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Currently, we do not have the `BarracksUnit` class created, so you'll see Visual
    Studio complain. We'll implement that as soon as we finish up the `Barracks` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the implementation for the `SpawnUnit` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the overridden `EndPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new character subclass, `BarracksUnit`, and add one property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll need to add the following #include to get access to the `UParticleSystemComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the component in the constructor implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach the visual representation to the root component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add the following to the `Tick` function to get the spawned actor moving:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project. Place a copy of the barracks actor into the level. You
    can then observe it spawning the character at fixed intervals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all went well, you should be able to drag and drop a `Barracks` object into
    the world and play the game. Afterwards, you'll notice objects (`BarracksUnit`
    objects) being spawned from a singular point and continually moving in a direction!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca986044-837e-4148-a6f0-5c8d32c9bbe3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we create the barracks actor. We add a particle system component to indicate
    where the new units will be spawning and a static mesh for the visual representation
    of the building.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we initialize the components and then set their values using
    `FObjectFinder`. We also set the class to spawn using the `StaticClass` function
    to retrieve a `UClass*` instance from a class type.
  prefs: []
  type: TYPE_NORMAL
- en: In the `BeginPlay` function of the barracks, we create a timer that calls our
    `SpawnUnit` function at fixed intervals. We store the timer handle in a member
    variable in the class so that when our instance is being destroyed, we can halt
    the timer; otherwise, when the timer triggers again, we'll encounter a crash where
    the object pointer is dereferenced.
  prefs: []
  type: TYPE_NORMAL
- en: The `SpawnUnit` function gets the world space location of the `SpawnPoint` object,
    and then asks the world to spawn an instance of our unit class at that location.
  prefs: []
  type: TYPE_NORMAL
- en: '`BarracksUnit` has code in its `Tick()` function to move forward by 10 units
    every frame so that each spawned unit will move to make room for the next one.'
  prefs: []
  type: TYPE_NORMAL
- en: The `EndPlay` function override calls the parent class implementation of the
    function, which is important if there are timers to cancel or perform deinitialization
    in the parent class. It then uses the timer handle stored in `BeginPlay` to cancel
    the timer.
  prefs: []
  type: TYPE_NORMAL
