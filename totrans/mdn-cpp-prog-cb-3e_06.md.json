["```cpp\n    std::chrono::hours        half_day(12);\n    std::chrono::minutes      half_hour(30);\n    std::chrono::seconds      half_minute(30);\n    std::chrono::milliseconds half_second(500);\n    std::chrono::microseconds half_millisecond(500);\n    std::chrono::nanoseconds  half_microsecond(500); \n    ```", "```cpp\n    using namespace std::chrono_literals;\n    auto half_day         = 12h;\n    auto half_hour        = 30min;\n    auto half_minute      = 30s;\n    auto half_second      = 500ms;\n    auto half_millisecond = 500us;\n    auto half_microsecond = 500ns; \n    ```", "```cpp\n    std::chrono::hours half_day_in_h(12);\n    std::chrono::minutes half_day_in_min(half_day_in_h);\n    std::cout << half_day_in_h.count() << \"h\" << '\\n';    //12h\n    std::cout << half_day_in_min.count() << \"min\" << '\\n';//720min \n    ```", "```cpp\n    using namespace std::chrono_literals;\n    auto total_seconds = 12345s;\n    auto hours =\n      std::chrono::duration_cast<std::chrono::hours>(total_seconds);\n    auto minutes =\n      std::chrono::duration_cast<std::chrono::minutes>(total_seconds % 1h);\n    auto seconds =\n      std::chrono::duration_cast<std::chrono::seconds>(total_seconds % 1min);\n    std::cout << hours.count()   << ':'\n              << minutes.count() << ':'\n              << seconds.count() << '\\n'; // 3:25:45 \n    ```", "```cpp\n    using namespace std::chrono_literals;\n    auto total_seconds = 12345s;\n    auto m1 = std::chrono::floor<std::chrono::minutes>(total_seconds); \n    // 205 min\n    auto m2 = std::chrono::round<std::chrono::minutes>(total_seconds); \n    // 206 min\n    auto m3 = std::chrono::ceil<std::chrono::minutes>(total_seconds); \n    // 206 min\n    auto sa = std::chrono::abs(total_seconds); \n    ```", "```cpp\n    using namespace std::chrono_literals;\n    auto d1 = 1h + 23min + 45s; // d1 = 5025s\n    auto d2 = 3h + 12min + 50s; // d2 = 11570s\n    if (d1 < d2) { /* do something */ } \n    ```", "```cpp\nnamespace std {\n  namespace chrono {\n    typedef duration<long long, ratio<1, 1000000000>> nanoseconds;\n    typedef duration<long long, ratio<1, 1000000>> microseconds;\n    typedef duration<long long, ratio<1, 1000>> milliseconds;\n    typedef duration<long long> seconds;\n    typedef duration<int, ratio<60> > minutes;\n    typedef duration<int, ratio<3600> > hours;\n  }\n} \n```", "```cpp\nstd::chrono::duration<double, std::ratio<10>> d(1.2); // 12 sec \n```", "```cpp\n    // format: year / month /day\n    year_month_day d1 = 2024y / 1 / 15;\n    year_month_day d2 = 2024y / January / 15;\n    // format: day / month / year\n    year_month_day d3 = 15d / 1 / 2024;\n    year_month_day d4 = 15d / January / 2024\n    // format: month / day / year\n    year_month_day d5 = 1 / 15d / 2024;\n    year_month_day d6 = January / 15 / 2024; \n    ```", "```cpp\n    // format: year / month / weekday\n    year_month_weekday d1 = 2024y / January / Monday[1];\n    // format: weekday / month / year\n    year_month_weekday d2 = Monday[1] / January / 2024;\n    // format: month / weekday / year\n    year_month_weekday d3 = January / Monday[1] / 2024; \n    ```", "```cpp\n    auto today = floor<days>(std::chrono::system_clock::now());\n    auto tomorrow = today + days{ 1 };\n    auto yesterday = today - days{ 1 }; \n    ```", "```cpp\n    year_month_day today = floor<days>(std::chrono::system_clock::now());\n    year_month_day first_day_this_month = today.year() / today.month() / 1;\n    year_month_day last_day_this_month = today.year() / today.month() / last; // std::chrono::last\n    year_month_day last_day_feb_2024 = 2024y / February / last;\n    year_month_day_last ymdl {today.year(), month_day_last{ month{ 2 } }};\n    year_month_day last_day_feb { ymdl }; \n    ```", "```cpp\n    inline int number_of_days(std::chrono::sys_days const& first,\n                              std::chrono::sys_days const& last)\n    {\n      return (last - first).count();\n    }\n    auto days = number_of_days(2024y / April / 1,\n      2024y / December / 25); \n    ```", "```cpp\n    auto day = 2024y / January / 33;\n    auto is_valid = day.ok(); \n    ```", "```cpp\n    chrono::hh_mm_ss<chrono::seconds> td(13h+12min+11s);\n    std::cout << td << '\\n';  // 13:12:11 \n    ```", "```cpp\n    auto tp = chrono::sys_days{ 2024y / April / 1 } + 12h + 30min + 45s;\n    std::cout << tp << '\\n';  // 2024-04-01 12:30:45 \n    ```", "```cpp\n    auto tp = std::chrono::system_clock::now();\n    auto dp = floor<days>(tp);\n    chrono::hh_mm_ss<chrono::milliseconds> time1 {\n      chrono::duration_cast<chrono::milliseconds>(tp - dp) };\n    std::cout << time1 << '\\n';  // 13:12:11.625\n    chrono::hh_mm_ss<chrono::minutes> time2 {\n      chrono::duration_cast<chrono::minutes>(tp - dp) };\n    std::cout << time2 << '\\n';  // 13:12 \n    ```", "```cpp\n    std::cout << is_am(0h)  << '\\n'; // true\n    std::cout << is_am(1h)  << '\\n'; // true\n    std::cout << is_am(12h) << '\\n'; // false\n    std::cout << is_pm(0h)  << '\\n'; // false\n    std::cout << is_pm(12h) << '\\n'; // true\n    std::cout << is_pm(23h) << '\\n'; // true\n    std::cout << is_pm(24h) << '\\n'; // false \n    ```", "```cpp\n    for (auto h : { 0h, 1h, 12h, 23h, 24h })\n    {\n       std::cout << make12(h).count() << '\\n';\n       // prints 12, 1, 12, 11, 12\n    }\n    for (auto [h, pm] : { \n       std::pair<hours, bool>{ 0h, false},\n       std::pair<hours, bool>{ 1h, false}, \n       std::pair<hours, bool>{ 1h, true}, \n       std::pair<hours, bool>{12h, false}, \n       std::pair<hours, bool>{12h, true}, })\n    {\n       std::cout << make24(h, pm).count() << '\\n';\n       // prints 0, 1, 13, 0, 12\n    } \n    ```", "```cpp\n    auto time = zoned_time{ current_zone(), system_clock::now() };\n    std::cout << time << '\\n'; // 2024-01-16 22:10:30.9274320 EET \n    ```", "```cpp\n    auto time = zoned_time{ locate_zone(\"Europe/Rome\"),\n                            system_clock::now() };\n    std::cout << time << '\\n'; // 2024-01-16 21:10:30.9291091 CET \n    ```", "```cpp\n    auto time = zoned_time{ current_zone(), system_clock::now() };\n    std::cout << std::format(std::locale{\"ro_RO\"}, \"%c\", time)\n              << '\\n'; // 16.01.2024 22:12:57 \n    ```", "```cpp\n    auto time = local_days{ 2024y / June / 1 } + 12h + 30min + 45s + 256ms;\n    auto ny_time = zoned_time<std::chrono::milliseconds>{\n                      locate_zone(\"America/New_York\"), time};\n    std::cout << ny_time << '\\n';\n    // 2024-06-01 12:30:45.256 EDT \n    ```", "```cpp\n    auto la_time = zoned_time<std::chrono::milliseconds>(\n                      locate_zone(\"America/Los_Angeles\"),\n                      ny_time);\n    std::cout << la_time << '\\n'; // 2024-06-01 09:30:45.256 PDT \n    ```", "```cpp\nauto zst = zoned_time<std::chrono::seconds>(\n  current_zone(),\n  sys_days{ 2024y / May / 10 } +14h + 20min + 30s);\nstd::cout << zst << '\\n'; // 2024-05-10 17:20:30 EEST (or GMT+3)\nauto zlt = zoned_time<std::chrono::seconds>(\n  current_zone(),\n  local_days{ 2024y / May / 10 } +14h + 20min + 30s);\nstd::cout << zlt << '\\n'; // 2024-05-10 14:20:30 EEST (or GMT+3)\nauto zpt = zoned_time<std::chrono::seconds>(\n  locate_zone(\"Europe/Paris\"),\n  zlt);\nstd::cout << zpt << '\\n'; //2024-05-10 13:20:30 CEST (or GMT+2) \n```", "```cpp\nvoid func(int const interval = 1000)\n{\n  std::this_thread::sleep_for(std::chrono::milliseconds(interval));\n} \n```", "```cpp\n    auto start = std::chrono::high_resolution_clock::now(); \n    ```", "```cpp\n    func(); \n    ```", "```cpp\n    auto diff = std::chrono::high_resolution_clock::now() - start; \n    ```", "```cpp\n    std::cout\n      << std::chrono::duration<double, std::milli>(diff).count()\n      << \"ms\" << '\\n';\n    std::cout\n      << std::chrono::duration<double, std::nano>(diff).count()\n      << \"ns\" << '\\n'; \n    ```", "```cpp\ntemplate <typename Time = std::chrono::microseconds,\n          typename Clock = std::chrono::high_resolution_clock>\nstruct perf_timer\n{\n  template <typename F, typename... Args>\n  static Time duration(F&& f, Args... args)\n  {\n    auto start = Clock::now();\n    std::invoke(std::forward<F>(f), std::forward<Args>(args)...);\n    auto end = Clock::now();\n    return std::chrono::duration_cast<Time>(end - start);\n  }\n}; \n```", "```cpp\ntemplate <typename T>\nvoid print_clock()\n{\n  std::cout << \"precision: \"\n            << (1000000.0 * double(T::period::num)) / \n               (T::period::den)\n            << '\\n';\n  std::cout << \"steady: \" << T::is_steady << '\\n';\n}\nprint_clock<std::chrono::system_clock>();\nprint_clock<std::chrono::high_resolution_clock>();\nprint_clock<std::chrono::steady_clock>(); \n```", "```cpp\nprecision: 0.1\nsteady: 0\nprecision: 0.001\nsteady: 1\nprecision: 0.001\nsteady: 1 \n```", "```cpp\nauto t = perf_timer<>::duration(func, 1500);\nstd::cout << std::chrono::duration<double, std::milli>(t).count()\n          << \"ms\" << '\\n';\nstd::cout << std::chrono::duration<double, std::nano>(t).count()\n          << \"ns\" << '\\n'; \n```", "```cpp\nauto t1 = perf_timer<std::chrono::nanoseconds>::duration(func, 150);\nauto t2 = perf_timer<std::chrono::microseconds>::duration(func, 150);\nauto t3 = perf_timer<std::chrono::milliseconds>::duration(func, 150);\nstd::cout\n  << std::chrono::duration<double, std::micro>(t1 + t2 + t3).count()\n  << \"us\" << '\\n'; \n```", "```cpp\nstruct Item\n{\n  int         id;\n  std::string name;\n  double      value;\n  Item(int const id, std::string const & name, double const value)\n    :id(id), name(name), value(value)\n  {}\n  bool operator==(Item const & other) const\n  {\n    return id == other.id && name == other.name &&\n           value == other.value;\n  }\n}; \n```", "```cpp\n    hashValue = hashValue * prime + hashFunc(field); \n    ```", "```cpp\nnamespace std\n{\n  template<>\n  struct hash<Item>\n  {\n    typedef Item argument_type;\n    typedef size_t result_type;\n    result_type operator()(argument_type const & item) const\n {\n      result_type hashValue = 17;\n      hashValue = 31 * hashValue + std::hash<int>{}(item.id);\n      hashValue = 31 * hashValue + std::hash<std::string>{}(item.name);\n      hashValue = 31 * hashValue + std::hash<double>{}(item.value);\n      return hashValue;\n    }\n  };\n} \n```", "```cpp\nstd::unordered_set<Item> set2\n{\n  { 1, \"one\"s, 1.0 },\n  { 2, \"two\"s, 2.0 },\n  { 3, \"three\"s, 3.0 },\n}; \n```", "```cpp\n    std::any value(42); // integer 42\n    value = 42.0;       // double 42.0\n    value = \"42\"s;      // std::string \"42\" \n    ```", "```cpp\n    std::any value = 42.0;\n    try\n    {\n      auto d = std::any_cast<double>(value);\n      std::cout << d << '\\n'; // prints 42\n    }\n    catch (std::bad_any_cast const & e)\n    {\n      std::cout << e.what() << '\\n';\n    } \n    ```", "```cpp\n    inline bool is_integer(std::any const & a)\n    {\n      return a.type() == typeid(int);\n    } \n    ```", "```cpp\n    auto ltest = [](std::any const & a) {\n      if (a.has_value())\n        std::cout << \"has value\" << '\\n';\n      else\n        std::cout << \"no value\" << '\\n';\n    };\n    std::any value;\n    ltest(value); // no value\n    value = 42;\n    ltest(value); // has value \n    ```", "```cpp\n    std::any value = 42;\n    ltest(value); // has value\n    value.reset();\n    ltest(value); // no value \n    ```", "```cpp\nvoid log(std::any const & value)\n{\n  if (value.has_value())\n  {\n    auto const & tv = value.type();\n    if (tv == typeid(int))\n    {\n      std::cout << std::any_cast<int>(value) << '\\n';\n    }\n    else if (tv == typeid(std::string))\n    {\n      std::cout << std::any_cast<std::string>(value) << '\\n';\n    }\n    else if (tv == typeid(\n      std::chrono::time_point<std::chrono::system_clock>))\n    {\n      auto t = std::any_cast<std::chrono::time_point<\n        std::chrono::system_clock>>(value);\n      auto now = std::chrono::system_clock::to_time_t(t);\n      std::cout << std::put_time(std::localtime(&now), \"%F %T\")\n                << '\\n';\n    }\n    else\n    {\n      std::cout << \"unexpected value type\" << '\\n';\n    }\n  }\n  else\n  {\n    std::cout << \"(empty)\" << '\\n';\n  }\n}\nlog(std::any{});                       // (empty)\nlog(42);                               // 42\nlog(\"42\"s);                            // 42\nlog(42.0);                             // unexpected value type\nlog(std::chrono::system_clock::now()); // 2016-10-30 22:42:57 \n```", "```cpp\nstd::vector<std::any> values;\nvalues.push_back(std::any{});\nvalues.push_back(42);\nvalues.push_back(\"42\"s);\nvalues.push_back(42.0);\nvalues.push_back(std::chrono::system_clock::now());\nfor (auto const & v : values)\n  log(v); \nvalues contains elements of the std::any type, which, in turn, contains an int, std::string, double, and std::chrono::time_point value.\n```", "```cpp\nstruct foo\n{\n  int    a;\n  double b;\n}; \n```", "```cpp\n    std::optional<int> v1;      // v1 is empty\n    std::optional<int> v2(42);  // v2 contains 42\n    v1 = 42;                    // v1 contains 42\n    std::optional<int> v3 = v2; // v3 contains 42 \n    ```", "```cpp\n    std::optional<int> v1{ 42 };\n    std::cout << *v1 << '\\n';   // 42\n    std::optional<foo> v2{ foo{ 42, 10.5 } };\n    std::cout << v2->a << \", \"\n              << v2->b << '\\n'; // 42, 10.5 \n    ```", "```cpp\n    std::optional<std::string> v1{ \"text\"s };\n    std::cout << v1.value() << '\\n'; // text\n    std::optional<std::string> v2;\n    std::cout << v2.value_or(\"default\"s) << '\\n'; // default \n    ```", "```cpp\n    std::optional<int> v1{ 42 };\n    if (v1) std::cout << *v1 << '\\n';\n    std::optional<foo> v2{ foo{ 42, 10.5 } };\n    if (v2.has_value())\n      std::cout << v2->a << \", \" << v2->b << '\\n'; \n    ```", "```cpp\n    std::optional<int> v{ 42 }; // v contains 42\n    v.reset();                  // v is empty \n    ```", "```cpp\n    template <typename K, typename V>\n    std::optional<V> find(K const key,\n                          std::map<K, V> const & m)\n    {\n      auto pos = m.find(key);\n      if (pos != m.end())\n        return pos->second;\n      return {};\n    }\n    std::map<int, std::string> m{\n      { 1, \"one\"s },{ 2, \"two\"s },{ 3, \"three\"s } };\n    auto value = find(2, m);\n    if (value) std::cout << *value << '\\n'; // two\n    value = find(4, m);\n    if (value) std::cout << *value << '\\n'; \n    ```", "```cpp\n    std::string extract(std::string const & text,\n                        std::optional<int> start,\n                        std::optional<int> end)\n    {\n      auto s = start.value_or(0);\n      auto e = end.value_or(text.length());\n      return text.substr(s, e - s);\n    }\n    auto v1 = extract(\"sample\"s, {}, {});\n    std::cout << v1 << '\\n'; // sample\n    auto v2 = extract(\"sample\"s, 1, {});\n    std::cout << v2 << '\\n'; // ample\n    auto v3 = extract(\"sample\"s, 1, 4);\n    std::cout << v3 << '\\n'; // amp \n    ```", "```cpp\n    struct book\n    {\n      std::string                title;\n      std::optional<std::string> subtitle;\n      std::vector<std::string>   authors;\n      std::string                publisher;\n      std::string                isbn;\n      std::optional<int>         pages;\n      std::optional<int>         year;\n    }; \n    ```", "```cpp\ntemplate <typename T>\nclass optional\n{\n  bool _initialized;\n  std::aligned_storage_t<sizeof(t), alignof(T)> _storage;\n}; \n```", "```cpp\nstruct bar { /* details */ };\nvoid process(std::optional<bar> const & arg)\n{\n  /* do something with arg */\n}\nstd::optional<bar> b1{ bar{} };\nbar b2{};\nprocess(b1); // no copy\nprocess(b2); // copy construction \n```", "```cpp\nstruct booking\n{\n   int                        id;\n   int                        nights;\n   double                     rate;\n   std::string                description;\n   std::vector<std::string>   extras;\n};\nstd::optional<booking> make_booking(std::string_view description, \n int nights, double rate);\nstd::optional<booking> add_rental(std::optional<booking> b);\nstd::optional<booking> add_insurance(std::optional<booking> b);\ndouble calculate_price(std::optional<booking> b);\ndouble apply_discount(std::optional<double> p); \n```", "```cpp\n    auto b = make_booking(\"Hotel California\", 3, 300);\n    auto p = b.transform(calculate_price); \n    ```", "```cpp\n    auto b = make_booking(\"Hotel California\", 3, 300);\n         b = b.and_then(add_insurance);\n    auto p = b.transform(calculate_price); \n    ```", "```cpp\n    auto b = make_booking(\"Hotel California\", 3, 300)\n             .or_else([]() -> std::optional<booking> {\n                std::cout << \"creating the booking failed!\\n\";  \n                return std::nullopt; \n             }); \n    ```", "```cpp\nauto p =\n    make_booking(\"Hotel California\", 3, 300)\n   .and_then(add_rental)\n   .and_then(add_insurance)\n   .or_else([]() -> std::optional<booking> {\n      std::cout << \"creating the booking failed!\\n\";  \n      return std::nullopt; })\n   .transform(calculate_price)\n   .transform(apply_discount)\n   .or_else([]() -> std::optional<double> {\n      std::cout << \"computing price failed!\\n\"; return -1; }); \n```", "```cpp\ndouble calculate_price(std::optional<booking> b); \n```", "```cpp\nauto b = make_booking(\"Hotel California\", 3, 300);\nauto p = b.transform(calculate_price); \n```", "```cpp\nstd::optional<double> calculate_price(std::optional<booking> b); \n```", "```cpp\nenum VARTAG {VT_int, VT_double, VT_pint, TP_pdouble /* more */ };\nstruct variant_t\n{\n  VARTAG tag;\n  union Value \n  {\n    int     i;\n    int*    pi;\n    double  d;\n    double* pd;\n    /* more */\n  } value;\n}; \n```", "```cpp\n    struct foo\n    {\n      int value;\n      explicit foo(int const i) : value(i) {}\n    };\n    std::variant<int, std::string, foo> v = 42; // holds int\n    v.emplace<foo>(42);                         // holds foo \n    ```", "```cpp\n    std::variant<int, double, std::string> v = 42;\n    auto i1 = std::get<int>(v);\n    auto i2 = std::get<0>(v);\n    try\n    {\n      auto f = std::get<double>(v);\n    }\n    catch (std::bad_variant_access const & e)\n    {\n      std::cout << e.what() << '\\n'; // Unexpected index\n    } \n    ```", "```cpp\n    std::variant<int, double, std::string> v;\n    v = 42;   // v contains int 42\n    v = 42.0; // v contains double 42.0\n    v = \"42\"; // v contains string \"42\" \n    ```", "```cpp\n    std::variant<int, double, std::string> v = 42;\n    static_assert(std::variant_size_v<decltype(v)> == 3);\n    std::cout << \"index = \" << v.index() << '\\n';\n    v = 42.0;\n    std::cout << \"index = \" << v.index() << '\\n';\n    v = \"42\";\n    std::cout << \"index = \" << v.index() << '\\n'; \n    ```", "```cpp\n    std::variant<int, double, std::string> v = 42;\n    std::cout << \"int? \" << std::boolalpha\n              << std::holds_alternative<int>(v)\n              << '\\n'; // int? true\n    v = \"42\";\n    std::cout << \"int? \" << std::boolalpha\n              << std::holds_alternative<int>(v)\n              << '\\n'; // int? false \n    ```", "```cpp\n    std::variant<std::monostate, foo, int> v;\n    v = 42;        // v contains int 42\n    std::cout << std::get<int>(v) << '\\n';\n    v = foo{ 42 }; // v contains foo{42}\n    std::cout << std::get<foo>(v).value << '\\n'; \n    ```", "```cpp\n    std::variant<int, double, std::string> v = 42;\n    std::visit(\n      [](auto&& arg) {std::cout << arg << '\\n'; },\n      v); \n    ```", "```cpp\nstd::variant<int, int, double> v = 33.0;\nv = 42;                               // error\nv.emplace<1>(42);                     // OK\nstd::cout << std::get<1>(v) << '\\n';  // prints 42\nstd::holds_alternative<int>(v);       // error \n```", "```cpp\nenum class Genre { Drama, Action, SF, Comedy };\nstruct Movie\n{\n  std::string title;\n  std::chrono::minutes length;\n  std::vector<Genre> genre;\n};\nstruct Track\n{\n  std::string title;\n  std::chrono::seconds length;\n};\nstruct Music\n{\n  std::string title;\n  std::string artist;\n  std::vector<Track> tracks;\n};\nstruct Software\n{\n  std::string title;\n  std::string vendor;\n};\nusing dvd = std::variant<Movie, Music, Software>;\nstd::vector<dvd> dvds\n{\n  Movie{ \"The Matrix\"s, 2h + 16min,{ Genre::Action, Genre::SF } },\n  Music{ \"The Wall\"s, \"Pink Floyd\"s,\n       { { \"Mother\"s, 5min + 32s },\n         { \"Another Brick in the Wall\"s, 9min + 8s } } },\n  Software{ \"Windows\"s, \"Microsoft\"s },\n}; \n```", "```cpp\ntemplate <typename CharT>\nusing tstring = std::basic_string<CharT, std::char_traits<CharT>, \n                                         std::allocator<CharT>>;\ntemplate<typename CharT>\ninline tstring<CharT> to_upper(tstring<CharT> text)\n{\n   std::transform(std::begin(text), std::end(text), \n                  std::begin(text), toupper);\n   return text;\n} \n```", "```cpp\n    for (auto const & d : dvds)\n    {\n      std::visit([](auto&& arg) {\n                   std::cout << arg.title << '\\n'; },\n                 d);\n    } \n    ```", "```cpp\n    for (auto const & d : dvds)\n    {\n      dvd result = std::visit(\n        [](auto&& arg) -> dvd\n        {\n          auto cpy { arg };\n          cpy.title = to_upper(cpy.title);\n          return cpy;\n        },\n      d);\n      std::visit(\n        [](auto&& arg) {\n          std::cout << arg.title << '\\n'; },\n        result);\n    } \n    ```", "```cpp\n    struct visitor_functor\n    {\n      void operator()(Movie const & arg) const\n     {\n        std::cout << \"Movie\" << '\\n';\n        std::cout << \" Title: \" << arg.title << '\\n';\n        std::cout << \" Length: \" << arg.length.count()\n                  << \"min\" << '\\n';\n      }\n      void operator()(Music const & arg) const\n     {\n        std::cout << \"Music\" << '\\n';\n        std::cout << \" Title: \" << arg.title << '\\n';\n        std::cout << \" Artist: \" << arg.artist << '\\n';\n        for (auto const & t : arg.tracks)\n          std::cout << \" Track: \" << t.title\n                    << \", \" << t.length.count()\n                    << \"sec\" << '\\n';\n      }\n      void operator()(Software const & arg) const\n     {\n        std::cout << \"Software\" << '\\n';\n        std::cout << \" Title: \" << arg.title << '\\n';\n        std::cout << \" Vendor: \" << arg.vendor << '\\n';\n      }\n    };\n    for (auto const & d : dvds)\n    {\n      std::visit(visitor_functor(), d);\n    } \n    ```", "```cpp\n    for (auto const & d : dvds)\n    {\n      std::visit([](auto&& arg) {\n        using T = std::decay_t<decltype(arg)>;\n        if constexpr (std::is_same_v<T, Movie>)\n        {\n          std::cout << \"Movie\" << '\\n';\n          std::cout << \" Title: \" << arg.title << '\\n';\n          std::cout << \" Length: \" << arg.length.count()\n                    << \"min\" << '\\n';\n        }\n        else if constexpr (std::is_same_v<T, Music>)\n        {\n          std::cout << \"Music\" << '\\n';\n          std::cout << \" Title: \" << arg.title << '\\n';\n          std::cout << \" Artist: \" << arg.artist << '\\n';\n          for (auto const & t : arg.tracks)\n            std::cout << \" Track: \" << t.title\n                      << \", \" << t.length.count()\n                      << \"sec\" << '\\n';\n        }\n        else if constexpr (std::is_same_v<T, Software>)\n        {\n          std::cout << \"Software\" << '\\n';\n          std::cout << \" Title: \" << arg.title << '\\n';\n          std::cout << \" Vendor: \" << arg.vendor << '\\n';\n        }\n      },\n      d);\n    } \n    ```", "```cpp\nenum class Status\n{\n   Success, InvalidFormat, InvalidLength, FilterError,\n};\nenum class Filter\n{\n   Pixelize, Sepia, Blur\n};\nusing Image = std::vector<char>; \n```", "```cpp\n    bool IsValidFormat(Image const& img) { return true; }\n    bool IsValidLength(Image const& img) { return true; }\n    bool Transform(Image& img, Filter const filter)\n    { \n       switch(filter)\n       {\n       case Filter::Pixelize:\n          img.push_back('P');\n          std::cout << \"Applying pixelize\\n\";\n       break;\n       case Filter::Sepia:\n          img.push_back('S');\n          std::cout << \"Applying sepia\\n\";\n       break;\n       case Filter::Blur:\n          img.push_back('B');\n          std::cout << \"Applying blur\\n\";\n       break;\n       }\n       return true; \n    }\n    std::expected<Image, Status> ApplyFilter(Image img, \n                                             Filter const filter)\n    {\n       if (!IsValidFormat(img))\n          return std::unexpected<Status> {Status::InvalidFormat};\n       if (!IsValidLength(img))\n          return std::unexpected<Status> {Status::InvalidLength};\n       if (!Transform(img, filter))\n          return std::unexpected<Status> {Status::FilterError};\n       return img;\n    }\n    std::expected<Image, Status> FlipHorizontally(Image img)\n    {\n        return Image{img.rbegin(), img.rend()};\n    } \n    ```", "```cpp\n    void ShowImage(Image const& img)\n    {\n       std::cout << \"[img]:\";\n       for(auto const & e : img) std::cout << e;\n       std::cout << '\\n';\n    }\n    void ShowError(Status const status)\n    {\n       std::cout << \"Error code: \" \n                 << static_cast<int>(status) << '\\n'; \n    }\n    int main()\n    {\n       Image img{'I','M','G'};\n\n       auto result = ApplyFilter(img, Filter::Sepia);\n       if (result)\n       {\n          ShowImage(result.value());\n       }\n       else\n       {\n          ShowError(result.error());\n       }\n    } \n    ```", "```cpp\n    int main()\n    {\n       Image img{'I','M','G'};\n\n       ApplyFilter(img, Filter::Sepia)                \n          .and_then([](Image result){\n              return ApplyFilter(result, Filter::Pixelize);\n          })\n          .and_then([](Image result){\n              return ApplyFilter(result, Filter::Blur);\n          })\n          .and_then([](Image result){\n              ShowImage(result);\n              return std::expected<Image, Status>{result};\n          })\n          .or_else([](Status status){\n              ShowError(status);\n              return std::expected<Image, Status>{std::unexpect, \n                                                  status};\n          });\n    } \n    ```", "```cpp\nint main()\n{\n   Image img{'I','M','G'};\n\n   auto result = ApplyFilter(img, Filter::Sepia);\n   result = ApplyFilter(result.value(), Filter::Pixelize);\n   result = ApplyFilter(result.value(), Filter::Blur);\n   result = FlipHorizontally(result.value());\n   if (result)\n   {\n      ShowImage(result.value());\n   }\n   else\n   {\n      ShowError(result.error());\n   }\n} \n```", "```cpp\nApplying sepia\nApplying pixelize\nApplying blur\n[img]:BPSGMI \n```", "```cpp\nint main()\n{\n   Image img{'I','M','G'};\n\n   ApplyFilter(img, Filter::Sepia)                \n      .and_then([](Image result){\n          return ApplyFilter(result, Filter::Pixelize);\n      })\n      .and_then([](Image result){\n          return ApplyFilter(result, Filter::Blur);\n      })\n      .and_then(FlipHorizontally)       \n      .and_then([](Image result){\n          ShowImage(result);\n          return std::expected<Image, Status>{result};\n      })\n      .or_else([](Status status){\n          ShowError(status);\n          return std::expected<Image, Status>{std::unexpect, status};\n      });\n} \n```", "```cpp\nApplying sepia\nError code: 3 \n```", "```cpp\nint main()\n{\n   Image img{'I','M','G'};\n\n   auto obj = ApplyFilter(img, Filter::Sepia)                \n      .and_then([](Image result){\n          return ApplyFilter(result, Filter::Pixelize);\n      })\n      .and_then([](Image result){\n          return ApplyFilter(result, Filter::Blur);\n      })\n      .and_then(FlipHorizontally)       \n      .and_then([](Image result){\n          ShowImage(result);\n          return std::expected<Image, Status>{result};\n      })\n      .or_else([](Status status){\n          ShowError(status);\n          return std::expected<Image, Status>{std::unexpect, status};\n      })       \n      .transform([](Image result){\n          std::stringstream s;\n          s << std::quoted(std::string(result.begin(), \n                                       result.end()));\n          return s.str();\n      })\n      .transform_error([](Status status){\n          return status == Status::Success ? \"success\" : \"fail\";\n      });\n    if(obj)\n       std::cout << obj.value() << '\\n';\n    else\n       std::cout << obj.error() << '\\n';\n} \n```", "```cpp\nApplying sepia\nApplying pixelize\nApplying blur\n[img]:BPSGMI\n\"BPSGMI\" \n```", "```cpp\nApplying sepia\nError code: 3\nfail \n```", "```cpp\nvoid func(int* buffer, size_t length) { /* ... */ } \n```", "```cpp\nvoid func(std::span<int> buffer) { /* ... */ } \n```", "```cpp\n    int arr[] = {1, 1, 2, 3, 5, 8, 13};\n    std::span<int, 7> s {arr}; \n    ```", "```cpp\n    int arr[] = {1, 1, 2, 3, 5, 8, 13};\n    std::span<int> s {arr}; \n    ```", "```cpp\n    void func(std::span<int> buffer)\n    {\n       for(auto const e : buffer)\n          std::cout << e << ' ';\n       std::cout << '\\n';\n    } \n    ```", "```cpp\n    int arr[] = {1, 1, 2, 3, 5, 8, 13};\n    std::span<int, 7> s {arr};\n    std::cout << s.front() << \" == \" << s[0] << '\\n';    \n    // prints 1 == 1\n    std::cout << s.back() << \" == \" << s[s.size() - 1] << '\\n'; \n    // prints 13 == 13\n    std::cout << *s.data() << '\\n';\n    // prints 1 \n    ```", "```cpp\n    std::span<int> first_3 = s.first(3);\n    func(first_3);  // 1 1 2.\n    std::span<int> last_3 = s.last(3);\n    func(last_3);   // 5 8 13\n    std::span<int> mid_3 = s.subspan(2, 3);\n    func(mid_3);    // 2 3 5 \n    ```", "```cpp\ntemplate <typename T, std::size_t ROWS, std::size_t COLS>\nstruct matrix\n{\n   T& \n#ifdef __cpp_multidimensional_subscript\noperator[] // C++23\n#else\noperator() // previously\n#endif\n   (std::size_t const r, std::size_t const c)\n   {\n      if (r >= ROWS || c >= COLS)\n         throw std::runtime_error(\"Invalid index\");\n      return data[r * COLS + c];\n   }\n   T const & \n#ifdef __cpp_multidimensional_subscript\noperator[] // C++23\n#else\noperator() // previously\n#endif\n   (std::size_t const r, std::size_t const c) const\n   {\n      if (r >= ROWS || c >= COLS)\n         throw std::runtime_error(\"Invalid index\");\n      return data[r * COLS + c];\n   }\n   std::size_t size() const { return data.size(); }\n   std::size_t empty() const { return data.empty(); }\n   template <std::size_t dimension>\n   std::size_t extent() const\n {\n      static_assert(dimension <= 1, \n                    \"The matrix only has two dimensions.\");\n      if constexpr (dimension == 0) return ROWS;\n      else if constexpr(dimension == 1) return COLS;\n   }\nprivate:\n   std::array<T, ROWS* COLS> data;\n}; \n```", "```cpp\nvoid f(int data[2][3]) { /* … */ }\nvoid g(int** data, size_t row, size_t cols) { /* … */ }\nvoid h(std::vector<std::vector<int>> dat, size_t row, size_t cols)\n{ /* … */ } \n```", "```cpp\nvoid f(std::mdspan<int,std::extents<size_t, 2, 3>> data) \n{ /* … */ } \n```", "```cpp\n    int* data = get_data();\n    std::mdspan<int, std::extents<size_t, 2, 3>> m(data); \n    ```", "```cpp\n    int* data = get_data();\n    std::mdspan<int, std::extents<size_t, \n                                  2, \n                                  std::dynamic_extent>> mv{v.data(), 3}; \n    ```", "```cpp\n    int* data = get_data();\n    std::mdspan<int, std::extents<size_t, \n                                  std::dynamic_extent,\n                                  std::dynamic_extent>> \n    m(data, 2, 3); \n    ```", "```cpp\n    int* data = get_data();\n    std::mdspan m(data, 2, 3); \n    ```", "```cpp\n    std::mdspan<int, \n                std::extents<size_t, 2, 3>,\n                std::layout_right> mv{ data }; \n    ```", "```cpp\n    std::mdspan<int, \n                std::extents<size_t, 2, 3>,\n                std::layout_left> mv{ data }; \n    ```", "```cpp\n    std::mdspan<int, \n                std::extents<size_t, 2, 3>,\n                std::layout_stride> mv{ data }; \n    ```", "```cpp\nmatrix<int, 2, 3> m;\nfor (std::size_t r = 0; r < m.extent<0>(); r++)\n{\n   for (std::size_t c = 0; c < m.extent<1>(); c++)\n   {\n      m[r, c] = r * m.extent<1>() + c + 1; // m[r,c] in C++23\n// m(r, c) previously\n   }\n} \n```", "```cpp\n1 2 3\n4 5 6 \n```", "```cpp\nstd::array<int, 6> arr;\nstd::mdspan m{arr.data(), std::extents{2, 3}};\nfor (std::size_t r = 0; r < m.extent(0); r++)\n{\n   for (std::size_t c = 0; c < m.extent(1); c++)\n   {\n      m[r, c] = r * m.extent(1) + c + 1;\n   }\n} \n```", "```cpp\ntemplate <typename T, std::size_t ROWS, std::size_t COLS>\nusing matrix = std::mdspan<T, std::extents<std::size_t, ROWS, COLS>>;\nstd::array<int, 6> arr;\nmatrix<int, 2, 3> ma {arr.data()}; \n```", "```cpp\ntemplate<class T,\n         class Extents,\n         class LayoutPolicy = std::layout_right,\n         class AccessorPolicy = std::default_accessor<T>>\nclass mdspan; \n```", "```cpp\nstd::vector v {1,2,3,4,5,6,7,8,9};\nstd::mdspan<int, \n            std::extents<size_t, 2, 3>,\n            std::layout_right> mv{v.data()}; \n```", "```cpp\n1 2 3\n4 5 6 \n```", "```cpp\n1 3 5\n2 4 6 \ndefines a stride equivalent to the std::layout_right, for the 2x3 matrix we have seen so far:\n```", "```cpp\nstd::mdspan<int, \n            std::extents<size_t, \n                         std::dynamic_extent, \n                         std::dynamic_extent>, \n            std::layout_stride> \nmv{ v.data(), { std::dextents<size_t,2>{2, 3}, \n                std::array<std::size_t, 2>{3, 1}}}; \n```", "```cpp\n    void exit_handler_1()\n    {\n      std::cout << \"exit handler 1\" << '\\n';\n    }\n    void exit_handler_2()\n    {\n      std::cout << \"exit handler 2\" << '\\n';\n    }\n    std::atexit(exit_handler_1);\n    std::atexit(exit_handler_2);\n    std::atexit([]() {std::cout << \"exit handler 3\" << '\\n'; }); \n    ```", "```cpp\n    void quick_exit_handler_1()\n    {\n      std::cout << \"quick exit handler 1\" << '\\n';\n    }\n    void quick_exit_handler_2()\n    {\n      std::cout << \"quick exit handler 2\" << '\\n';\n    }\n    std::at_quick_exit(quick_exit_handler_1);\n    std::at_quick_exit(quick_exit_handler_2);\n    std::at_quick_exit([]() {\n      std::cout << \"quick exit handler 3\" << '\\n'; }); \n    ```", "```cpp\nexit handler 3\nexit handler 2\nexit handler 1 \n```", "```cpp\nquick exit handler 3\nquick exit handler 2\nquick exit handler 1 \n```", "```cpp\nstruct static_foo\n{\n  ~static_foo() { std::cout << \"static foo destroyed!\" << '\\n'; }\n  static static_foo* instance()\n {\n    static static_foo obj;\n    return &obj;\n  }\n}; \n```", "```cpp\nstd::atexit(exit_handler_1);\nstatic_foo::instance();\nstd::atexit(exit_handler_2);\nstd::atexit([]() {std::cout << \"exit handler 3\" << '\\n'; });\nstd::exit(42); \nexit_handler_1 is registered before the creation of the static object static_foo. On the other hand, exit_handler_2 and the lambda expression are both registered, in that order, after the static object was constructed. As a result, the order of calls at normal termination is as follows:\n```", "```cpp\nexit handler 3\nexit handler 2\nstatic foo destroyed!\nexit handler 1 \n```", "```cpp\n    template <typename T,\n              typename = typename std::enable_if_t<\n                    std::is_arithmetic_v<T> > >\n    T multiply(T const t1, T const t2)\n    {\n      return t1 * t2;\n    }\n    auto v1 = multiply(42.0, 1.5);     // OK\n    auto v2 = multiply(\"42\"s, \"1.5\"s); // error \n    ```", "```cpp\n    template <typename T>\n    struct pod_wrapper\n    {\n      static_assert(std::is_standard_layout_v<T> &&\n                    std::is_trivial_v<T>,\n                    \"Type is not a POD!\");\n      T value;\n    };\n    pod_wrapper<int> i{ 42 };            // OK\n    pod_wrapper<std::string> s{ \"42\"s }; // error \n    ```", "```cpp\n    template <typename T>\n    struct const_wrapper\n    {\n      typedef typename std::conditional_t<\n                std::is_const_v<T>,\n                T,\n                typename std::add_const_t<T>> const_type;\n    };\n    static_assert(\n      std::is_const_v<const_wrapper<int>::const_type>);\n    static_assert(\n      std::is_const_v<const_wrapper<int const>::const_type>); \n    ```", "```cpp\n    template <typename T>\n    auto process(T arg)\n    {\n      if constexpr (std::is_same_v<T, bool>)\n     return !arg;\n      else if constexpr (std::is_integral_v<T>)\n        return -arg;\n      else if constexpr (std::is_floating_point_v<T>)\n        return std::abs(arg);\n      else\n    return arg;\n    }\n    auto v1 = process(false); // v1 = true\n    auto v2 = process(42);    // v2 = -42\n    auto v3 = process(-42.0); // v3 = 42.0\n    auto v4 = process(\"42\"s); // v4 = \"42\" \n    ```", "```cpp\n    int process(int arg)\n    {\n      return -arg;\n    } \n    ```", "```cpp\n    template <typename T>\n    struct is_void\n    { static const bool value = false; };\n    template <>\n    struct is_void<void>\n    { static const bool value = true; }; \n    ```", "```cpp\n    template <typename T>\n    struct is_pointer\n    { static const bool value = false; };\n    template <typename T>\n    struct is_pointer<T*>\n    { static const bool value = true; }; \n    ```", "```cpp\n    template<bool B, typename T = void>\n    struct enable_if {};\n    template<typename T>\n    struct enable_if<true, T> { using type = T; }; \n    ```", "```cpp\n    template <typename T>\n    inline constexpr bool is_integral_v = is_integral<T>::value; \n    ```", "```cpp\n    template <bool B, typename T = void>\n    using enable_if_t = typename enable_if<B,T>::type; \n    ```", "```cpp\nstruct foo\n{\n  std::string serialize()\n {\n    return \"plain\"s;\n  }\n};\nstruct bar\n{\n  std::string serialize_with_encoding()\n {\n    return \"encoded\"s;\n  }\n}; \n```", "```cpp\n    template <typename T>\n    struct is_serializable_with_encoding\n    {\n      static const bool value = false;\n    }; \n    ```", "```cpp\n    template <>\n    struct is_serializable_with_encoding<bar>\n    {\n      static const bool value = true;\n    }; \n    ```", "```cpp\n    template <bool b>\n    struct serializer\n    {\n      template <typename T>\n      static auto serialize(T& v)\n     {\n        return v.serialize();\n      }\n    }; \n    ```", "```cpp\n    template <>\n    struct serializer<true>\n    {\n      template <typename T>\n      static auto serialize(T& v)\n     {\n        return v.serialize_with_encoding();\n      }\n    }; \n    ```", "```cpp\n    template <typename T>\n    auto serialize(T& v)\n    {\n      return serializer<is_serializable_with_encoding<T>::value>::\n        serialize(v);\n    } \n    ```", "```cpp\nstd::cout << std::boolalpha;\nstd::cout <<\n  is_serializable_with_encoding<foo>::value << '\\n';        // false\nstd::cout <<\n  is_serializable_with_encoding<bar>::value << '\\n';        // true\nstd::cout <<\n  is_serializable_with_encoding<int>::value << '\\n';        // false\nstd::cout <<\n  is_serializable_with_encoding<std::string>::value << '\\n';// false\nstd::cout << std::boolalpha; \n```", "```cpp\nfoo f;\nbar b;\nstd::cout << serialize(f) << '\\n'; // plain\nstd::cout << serialize(b) << '\\n'; // encoded \nserialize() with a foo argument will return the string *plain*, while calling serialize() with a bar argument will return the string *encoded*.\n```", "```cpp\n    using long_type = std::conditional_t<\n        sizeof(void*) <= 4, long, long long>;\n    auto n = long_type{ 42 }; \n    ```", "```cpp\n    template <int size>\n    using number_type =\n      typename std::conditional_t<\n        size<=1,\n        std::int8_t,\n        typename std::conditional_t<\n          size<=2,\n          std::int16_t,\n          typename std::conditional_t<\n            size<=4,\n            std::int32_t,\n            std::int64_t\n          >\n        >\n      >;\n    auto n = number_type<2>{ 42 };\n    static_assert(sizeof(number_type<1>) == 1);\n    static_assert(sizeof(number_type<2>) == 2);\n    static_assert(sizeof(number_type<3>) == 4);\n    static_assert(sizeof(number_type<4>) == 4);\n    static_assert(sizeof(number_type<5>) == 8);\n    static_assert(sizeof(number_type<6>) == 8);\n    static_assert(sizeof(number_type<7>) == 8);\n    static_assert(sizeof(number_type<8>) == 8);\n    static_assert(sizeof(number_type<9>) == 8); \n    ```", "```cpp\n    template <typename T,\n              typename D = std::conditional_t<\n                             std::is_integral_v<T>,\n                             std::uniform_int_distribution<T>,\n                             std::uniform_real_distribution<T>>,\n              typename = typename std::enable_if_t<\n                             std::is_arithmetic_v<T>>>\n    std::vector<T> GenerateRandom(T const min, T const max,\n                                  size_t const size)\n    {\n      std::vector<T> v(size);\n      std::random_device rd{};\n      std::mt19937 mt{ rd() };\n      D dist{ min, max };\n      std::generate(std::begin(v), std::end(v),\n        [&dist, &mt] {return dist(mt); });\n      return v;\n    }\n    auto v1 = GenerateRandom(1, 10, 10);     // integers\n    auto v2 = GenerateRandom(1.0, 10.0, 10); // doubles \n    ```", "```cpp\ntemplate<bool Test, class T1, class T2>\nstruct conditional\n{\n  typedef T2 type;\n};\ntemplate<class T1, class T2>\nstruct conditional<true, T1, T2>\n{\n  typedef T1 type;\n}; \n```", "```cpp\ntemplate<bool Test, class T1, class T2>\nusing conditional_t = typename conditional_t<Test,T1,T2>; \n```", "```cpp\nvoid log(std::string_view message, \n         std::source_location const location = std::source_location::current())\n{\n   std::cout   << location.file_name() << '('\n               << location.line() << ':'\n               << location.column() << \") '\"\n               << location.function_name() << \"': \"\n               << message << '\\n';\n} \n```", "```cpp\nvoid log(std::string_view message, \n         std::string_view file, \n int line, \n         std::string_view function)\n{\n   std::cout << file << '('\n             << line << \") '\"\n             << function << \"': \"\n             << message << '\\n';\n} \n```", "```cpp\nint main()\n{\n   log(\"This is a log entry!\", __FILE__, __LINE__, __FUNCTION__);\n} \n```", "```cpp\n[...]\\source.cpp(23) 'main': This is a log entry! \n```", "```cpp\nint main()\n{\n   log(\"This is a log entry!\");\n} \n```", "```cpp\n[...]\\source.cpp(23:4) 'int __cdecl main(void)': This is a log entry! \n```", "```cpp\n    std::cout << std::stacktrace::current() << '\\n'; \n    ```", "```cpp\n    for (auto const & frame : std::stacktrace::current())\n    {\n       std::cout << frame << '\\n';\n    } \n    ```", "```cpp\n    for (auto const& frame : std::stacktrace::current())\n    {\n       std::cout << frame.source_file()\n                 << \"(\"<< frame.source_line() << \")\"\n                 << \": \" << frame.description()\n                 << '\\n';\n    } \n    ```", "```cpp\nstd::stacktrace trace = std::stacktrace::current(); \n```", "```cpp\n    std::cout << std::stacktrace::current() << '\\n'; \n    ```", "```cpp\n    std::cout << std::to_string(std::stacktrace::current()) \n              << '\\n'; \n    ```", "```cpp\n    auto str = std::format(\"{}\\n\", std::stacktrace::current());\n    std::cout << str; \n    ```", "```cpp\nint plus_one(int n)\n{\n   std::cout << std::stacktrace::current() << '\\n';\n   return n + 1;\n}\nint double_n_plus_one(int n)\n{\n   return plus_one(2 * n);\n}\nint main()\n{\n   std::cout << double_n_plus_one(42) << '\\n';\n} \n```", "```cpp\n0> [...]\\main.cpp(24): chapter06!plus_one+0x4F\n1> [...]\\main.cpp(37): chapter06!double_n_plus_one+0xE\n2> [...]\\main.cpp(61): chapter06!main+0x5F\n3> D:\\a\\_work\\1\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl(78): chapter06!invoke_main+0x33\n4> D:\\a\\_work\\1\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl(288): chapter06!__scrt_common_main_seh+0x157\n5> D:\\a\\_work\\1\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl(331): chapter06!__scrt_common_main+0xD\n6> D:\\a\\_work\\1\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_main.cpp(17): chapter06!mainCRTStartup+0x8\n7> KERNEL32+0x17D59\n8> ntdll!RtlInitializeExceptionChain+0x6B\n9> ntdll!RtlClearBits+0xBF \n```", "```cpp\n[...]\\main.cpp(24): chapter06!main+0x5F\n-------------- --   -------------------\nsource         line description \n```"]