["```cpp\n    VkPipelineRenderingCreateInfoKHR pipeline_rendering_create_info{\n    ```", "```cpp\n      VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR };\n    ```", "```cpp\n    pipeline_rendering_create_info.viewMask = 0;\n    ```", "```cpp\n    pipeline_rendering_create_info.colorAttachmentCount =\n    ```", "```cpp\n        creation.render_pass.num_color_formats;\n    ```", "```cpp\n    pipeline_rendering_create_info.pColorAttachmentFormats\n    ```", "```cpp\n        = creation.render_pass.num_color_formats > 0 ?\n    ```", "```cpp\n            creation.render_pass.color_formats : nullptr;\n    ```", "```cpp\n    pipeline_rendering_create_info.depthAttachmentFormat =\n    ```", "```cpp\n        creation.render_pass.depth_stencil_format;\n    ```", "```cpp\n    pipeline_rendering_create_info.stencilAttachmentFormat\n    ```", "```cpp\n        = VK_FORMAT_UNDEFINED;\n    ```", "```cpp\n    pipeline_info.pNext = &pipeline_rendering_create_info;\n    ```", "```cpp\n    Array<VkRenderingAttachmentInfoKHR> color_attachments_info;\n    ```", "```cpp\n    color_attachments_info.init( device->allocator,\n    ```", "```cpp\n        framebuffer->num_color_attachments,\n    ```", "```cpp\n            framebuffer->num_color_attachments );\n    ```", "```cpp\n    for ( u32 a = 0; a < framebuffer->\n    ```", "```cpp\n        num_color_attachments; ++a ) {\n    ```", "```cpp\n            Texture* texture = device->\n    ```", "```cpp\n                access_texture( framebuffer->\n    ```", "```cpp\n                    color_attachments[a] );\n    ```", "```cpp\n        VkAttachmentLoadOp color_op = ...;\n    ```", "```cpp\n    VkRenderingAttachmentInfoKHR&\n    ```", "```cpp\n    color_attachment_info = color_attachments_info[ a ];\n    ```", "```cpp\n    color_attachment_info.sType =\n    ```", "```cpp\n        VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR;\n    ```", "```cpp\n    color_attachment_info.imageView = texture->\n    ```", "```cpp\n        vk_image_view;\n    ```", "```cpp\n    color_attachment_info.imageLayout =\n    ```", "```cpp\n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;\n    ```", "```cpp\n    color_attachment_info.resolveMode =\n    ```", "```cpp\n        VK_RESOLVE_MODE_NONE;\n    ```", "```cpp\n    color_attachment_info.loadOp = color_op;\n    ```", "```cpp\n    color_attachment_info.storeOp =\n    ```", "```cpp\n        VK_ATTACHMENT_STORE_OP_STORE;\n    ```", "```cpp\n    color_attachment_info.clearValue = render_pass->\n    ```", "```cpp\n        output.color_operations[ a ] ==\n    ```", "```cpp\n            RenderPassOperation::Enum::Clear ? clears[ 0 ]\n    ```", "```cpp\n                : VkClearValue{ };\n    ```", "```cpp\n    }\n    ```", "```cpp\n    VkRenderingAttachmentInfoKHR depth_attachment_info{\n    ```", "```cpp\n        VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR };\n    ```", "```cpp\n    bool has_depth_attachment = framebuffer->\n    ```", "```cpp\n        depth_stencil_attachment.index != k_invalid_index;\n    ```", "```cpp\n    if ( has_depth_attachment ) {\n    ```", "```cpp\n        Texture* texture = device->access_texture(\n    ```", "```cpp\n            framebuffer->depth_stencil_attachment );\n    ```", "```cpp\n        VkAttachmentLoadOp depth_op = ...;\n    ```", "```cpp\n    depth_attachment_info.imageView = texture->\n    ```", "```cpp\n        vk_image_view;\n    ```", "```cpp\n    depth_attachment_info.imageLayout =\n    ```", "```cpp\n        VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;\n    ```", "```cpp\n    depth_attachment_info.resolveMode =\n    ```", "```cpp\n        VK_RESOLVE_MODE_NONE;\n    ```", "```cpp\n    depth_attachment_info.loadOp = depth_op;\n    ```", "```cpp\n    depth_attachment_info.storeOp =\n    ```", "```cpp\n        VK_ATTACHMENT_STORE_OP_STORE;\n    ```", "```cpp\n    depth_attachment_info.clearValue = render_pass->\n    ```", "```cpp\n        output.depth_operation ==\n    ```", "```cpp\n            RenderPassOperation::Enum::Clear ? clears[ 1 ]\n    ```", "```cpp\n                : VkClearValue{ };\n    ```", "```cpp\n    }\n    ```", "```cpp\n    VkRenderingInfoKHR rendering_info{\n    ```", "```cpp\n        VK_STRUCTURE_TYPE_RENDERING_INFO_KHR };\n    ```", "```cpp\n    rendering_info.flags = use_secondary ?\n    ```", "```cpp\n        VK_RENDERING_CONTENTS_SECONDARY_COMMAND\n    ```", "```cpp\n            _BUFFERS_BIT_KHR : 0;\n    ```", "```cpp\n    rendering_info.renderArea = { 0, 0, framebuffer->\n    ```", "```cpp\n        width, framebuffer->height };\n    ```", "```cpp\n    rendering_info.layerCount = 1;\n    ```", "```cpp\n    rendering_info.viewMask = 0;\n    ```", "```cpp\n    rendering_info.colorAttachmentCount = framebuffer->\n    ```", "```cpp\n        num_color_attachments;\n    ```", "```cpp\n    rendering_info.pColorAttachments = framebuffer->\n    ```", "```cpp\n        num_color_attachments > 0 ?\n    ```", "```cpp\n            color_attachments_info.data : nullptr;\n    ```", "```cpp\n    rendering_info.pDepthAttachment =\n    ```", "```cpp\n        has_depth_attachment ? &depth_attachment_info :\n    ```", "```cpp\n            nullptr;\n    ```", "```cpp\n    rendering_info.pStencilAttachment = nullptr;\n    ```", "```cpp\nlayout (location = 0) out vec4 color_out;\nlayout (location = 1) out vec2 normal_out;\nlayout (location = 2) out vec4\n    occlusion_roughness_metalness_out;\nlayout (location = 3) out vec4 emissive_out;\n```", "```cpp\ncolour_out = texture(global_textures[nonuniformEXT\n    (albedo_texture)], uv);\n```", "```cpp\nvec2 octahedral_encode(vec3 n) {\n    // Project the sphere onto the octahedron, and then\n       onto the xy plane\n    vec2 p = n.xy * (1.0f / (abs(n.x) + abs(n.y) +\n        abs(n.z)));\n    // Reflect the folds of the lower hemisphere over the\n       diagonals\n    return (n.z < 0.0f) ? ((1.0 - abs(p.yx)) *\n        sign_not_zero(p)) : p;\n}\n```", "```cpp\nvec3 octahedral_decode(vec2 f) {\n    vec3 n = vec3(f.x, f.y, 1.0 - abs(f.x) - abs(f.y));\n    float t = max(-n.z, 0.0);\n    n.x += n.x >= 0.0 ? -t : t;\n    n.y += n.y >= 0.0 ? -t : t;\n    return normalize(n);\n}\n```", "```cpp\n    float z_far = 100.0f;\n    ```", "```cpp\n    for ( u32 i = 0; i < k_num_lights; ++i ) {\n    ```", "```cpp\n        Light& light = lights[ i ];\n    ```", "```cpp\n        vec4s p{ light.world_position.x,\n    ```", "```cpp\n            light.world_position.y,\n    ```", "```cpp\n                light.world_position.z, 1.0f };\n    ```", "```cpp\n        vec3s p_min = glms_vec3_add( light.world_position,\n    ```", "```cpp\n            glms_vec3_scale(\n    ```", "```cpp\n                light_camera_dir,\n    ```", "```cpp\n                    -light.radius ) );\n    ```", "```cpp\n        vec3s p_max = glms_vec3_add( light.world_position,\n    ```", "```cpp\n            glms_vec3_scale(\n    ```", "```cpp\n                light_camera_dir,\n    ```", "```cpp\n                    light.radius ) );\n    ```", "```cpp\n        vec4s projected_p = glms_mat4_mulv(\n    ```", "```cpp\n            world_to_camera, p );\n    ```", "```cpp\n        vec4s projected_p_min = glms_mat4_mulv(\n    ```", "```cpp\n            world_to_camera, p_min4 );\n    ```", "```cpp\n        vec4s projected_p_max = glms_mat4_mulv(\n    ```", "```cpp\n            world_to_camera, p_max4 );\n    ```", "```cpp\n       SortedLight& sorted_light = sorted_lights[ i ];\n    ```", "```cpp\n        sorted_light.light_index = i;\n    ```", "```cpp\n        sorted_light.projected_z = ( -projected_p.z –\n    ```", "```cpp\n            scene_data.z_near ) / ( z_far –\n    ```", "```cpp\n                scene_data.z_near );\n    ```", "```cpp\n        sorted_light.projected_z_min = ( -\n    ```", "```cpp\n            projected_p_min.z - scene_data.z_near ) / (\n    ```", "```cpp\n                z_far - scene_data.z_near );\n    ```", "```cpp\n        sorted_light.projected_z_max = ( -\n    ```", "```cpp\n            projected_p_max.z - scene_data.z_near ) / (\n    ```", "```cpp\n                z_far - scene_data.z_near );\n    ```", "```cpp\n    }\n    ```", "```cpp\n    qsort( sorted_lights.data, k_num_lights, sizeof(\n    ```", "```cpp\n        SortedLight ), sorting_light_fn );\n    ```", "```cpp\n    u32* gpu_light_indices = ( u32* )gpu.map_buffer(\n    ```", "```cpp\n        cb_map );\n    ```", "```cpp\n    if ( gpu_light_indices ) {\n    ```", "```cpp\n        for ( u32 i = 0; i < k_num_lights; ++i ) {\n    ```", "```cpp\n            gpu_light_indices[ i ] = sorted_lights[ i ]\n    ```", "```cpp\n                .light_index;\n    ```", "```cpp\n        }\n    ```", "```cpp\n        gpu.unmap_buffer( cb_map );\n    ```", "```cpp\n    }\n    ```", "```cpp\n    Array<u32> light_tiles_bits;\n    ```", "```cpp\n    light_tiles_bits.init( context.scratch_allocator,\n    ```", "```cpp\n        tiles_entry_count, tiles_entry_count );\n    ```", "```cpp\n    float near_z = scene_data.z_near;\n    ```", "```cpp\n    float tile_size_inv = 1.0f / k_tile_size;\n    ```", "```cpp\n    u32 tile_stride = tile_x_count * k_num_words;\n    ```", "```cpp\n    for ( u32 i = 0; i < k_num_lights; ++i ) {\n    ```", "```cpp\n        const u32 light_index = sorted_lights[ i ]\n    ```", "```cpp\n            .light_index;\n    ```", "```cpp\n        Light& light = lights[ light_index ];\n    ```", "```cpp\n        vec4s pos{ light.world_position.x,\n    ```", "```cpp\n            light.world_position.y,\n    ```", "```cpp\n                light.world_position.z, 1.0f };\n    ```", "```cpp\n        float radius = light.radius;\n    ```", "```cpp\n        vec4s view_space_pos = glms_mat4_mulv(\n    ```", "```cpp\n            game_camera.camera.view, pos );\n    ```", "```cpp\n        bool camera_visible = view_space_pos.z - radius <\n    ```", "```cpp\n            game_camera.camera.near_plane;\n    ```", "```cpp\n        if ( !camera_visible &&\n    ```", "```cpp\n            context.skip_invisible_lights ) {\n    ```", "```cpp\n            continue;\n    ```", "```cpp\n        }\n    ```", "```cpp\n    for ( u32 c = 0; c < 8; ++c ) {\n    ```", "```cpp\n        vec3s corner{ ( c % 2 ) ? 1.f : -1.f, ( c & 2 ) ?\n    ```", "```cpp\n            1.f : -1.f, ( c & 4 ) ? 1.f : -1.f };\n    ```", "```cpp\n        corner = glms_vec3_scale( corner, radius );\n    ```", "```cpp\n        corner = glms_vec3_add( corner, glms_vec3( pos ) );\n    ```", "```cpp\n        vec4s corner_vs = glms_mat4_mulv(\n    ```", "```cpp\n            game_camera.camera.view,\n    ```", "```cpp\n                glms_vec4( corner, 1.f ) );\n    ```", "```cpp\n        corner_vs.z = -glm_max(\n    ```", "```cpp\n            game_camera.camera.near_plane, -corner_vs.z );\n    ```", "```cpp\n        vec4s corner_ndc = glms_mat4_mulv(\n    ```", "```cpp\n            game_camera.camera.projection, corner_vs );\n    ```", "```cpp\n        corner_ndc = glms_vec4_divs( corner_ndc,\n    ```", "```cpp\n            corner_ndc.w );\n    ```", "```cpp\n        aabb_min.x = glm_min( aabb_min.x, corner_ndc.x );\n    ```", "```cpp\n        aabb_min.y = glm_min( aabb_min.y, corner_ndc.y );\n    ```", "```cpp\n        aabb_max.x = glm_max( aabb_max.x, corner_ndc.x );\n    ```", "```cpp\n        aabb_max.y = glm_max( aabb_max.y, corner_ndc.y );\n    ```", "```cpp\n    }\n    ```", "```cpp\n    aabb.x = aabb_min.x;\n    ```", "```cpp\n    aabb.z = aabb_max.x;\n    ```", "```cpp\n    aabb.w = -1 * aabb_min.y;\n    ```", "```cpp\n    aabb.y = -1 * aabb_max.y;\n    ```", "```cpp\n    vec4s aabb_screen{ ( aabb.x * 0.5f + 0.5f ) * (\n    ```", "```cpp\n        gpu.swapchain_width - 1 ),\n    ```", "```cpp\n        ( aabb.y * 0.5f + 0.5f ) * (\n    ```", "```cpp\n        gpu.swapchain_height - 1 ),\n    ```", "```cpp\n        ( aabb.z * 0.5f + 0.5f ) * (\n    ```", "```cpp\n        gpu.swapchain_width - 1 ),\n    ```", "```cpp\n        ( aabb.w * 0.5f + 0.5f ) *\n    ```", "```cpp\n        ( gpu.swapchain_height - 1 ) };\n    ```", "```cpp\n    f32 width = aabb_screen.z - aabb_screen.x;\n    ```", "```cpp\n    f32 height = aabb_screen.w - aabb_screen.y;\n    ```", "```cpp\n    if ( width < 0.0001f || height < 0.0001f ) {\n    ```", "```cpp\n        continue;\n    ```", "```cpp\n    }\n    ```", "```cpp\n    float min_x = aabb_screen.x;\n    ```", "```cpp\n    float min_y = aabb_screen.y;\n    ```", "```cpp\n    float max_x = min_x + width;\n    ```", "```cpp\n    float max_y = min_y + height;\n    ```", "```cpp\n    if ( min_x > gpu.swapchain_width || min_y >\n    ```", "```cpp\n        gpu.swapchain_height ) {\n    ```", "```cpp\n        continue;\n    ```", "```cpp\n    }\n    ```", "```cpp\n    if ( max_x < 0.0f || max_y < 0.0f ) {\n    ```", "```cpp\n        continue;\n    ```", "```cpp\n    }\n    ```", "```cpp\n    min_x = max( min_x, 0.0f );\n    ```", "```cpp\n    min_y = max( min_y, 0.0f );\n    ```", "```cpp\n    max_x = min( max_x, ( float )gpu.swapchain_width );\n    ```", "```cpp\n    max_y = min( max_y, ( float )gpu.swapchain_height );\n    ```", "```cpp\n    u32 first_tile_x = ( u32 )( min_x * tile_size_inv );\n    ```", "```cpp\n    u32 last_tile_x = min( tile_x_count - 1, ( u32 )(\n    ```", "```cpp\n        max_x * tile_size_inv ) );\n    ```", "```cpp\n    u32 first_tile_y = ( u32 )( min_y * tile_size_inv );\n    ```", "```cpp\n    u32 last_tile_y = min( tile_y_count - 1, ( u32 )(\n    ```", "```cpp\n        max_y * tile_size_inv ) );\n    ```", "```cpp\n    for ( u32 y = first_tile_y; y <= last_tile_y; ++y ) {\n    ```", "```cpp\n        for ( u32 x = first_tile_x; x <= last_tile_x; ++x\n    ```", "```cpp\n            ) {\n    ```", "```cpp\n                  u32 array_index = y * tile_stride + x;\n    ```", "```cpp\n                      u32 word_index = i / 32;\n    ```", "```cpp\n                          u32 bit_index = i % 32;\n    ```", "```cpp\n        light_tiles_bits[ array_index + word_index ] |= (\n    ```", "```cpp\n            1 << bit_index );\n    ```", "```cpp\n        }\n    ```", "```cpp\n    }\n    ```", "```cpp\n    vec4 pos_camera_space = world_to_camera * vec4(\n    ```", "```cpp\n        world_position, 1.0 );\n    ```", "```cpp\n    float z_light_far = 100.0f;\n    ```", "```cpp\n    float linear_d = ( -pos_camera_space.z - z_near ) / (\n    ```", "```cpp\n        z_light_far - z_near );\n    ```", "```cpp\n    int bin_index = int( linear_d / BIN_WIDTH );\n    ```", "```cpp\n    uint bin_value = bins[ bin_index ];\n    ```", "```cpp\n    uint min_light_id = bin_value & 0xFFFF;\n    ```", "```cpp\n    uint max_light_id = ( bin_value >> 16 ) & 0xFFFF;\n    ```", "```cpp\n    uvec2 position = gl_GlobalInvocationID.xy;\n    ```", "```cpp\n    uvec2 tile = position / uint( TILE_SIZE );\n    ```", "```cpp\n    uint stride = uint( NUM_WORDS ) *\n    ```", "```cpp\n        ( uint( resolution.x ) / uint( TILE_SIZE ) );\n    ```", "```cpp\n    uint address = tile.y * stride + tile.x;\n    ```", "```cpp\n    if ( max_light_id != 0 ) {\n    ```", "```cpp\n        min_light_id -= 1;\n    ```", "```cpp\n        max_light_id -= 1;\n    ```", "```cpp\n        for ( uint light_id = min_light_id; light_id <=\n    ```", "```cpp\n            max_light_id; ++light_id ) {\n    ```", "```cpp\n                uint word_id = light_id / 32;\n    ```", "```cpp\n                uint bit_id = light_id % 32;\n    ```", "```cpp\n            if ( ( tiles[ address + word_id ] &\n    ```", "```cpp\n                ( 1 << bit_id ) ) != 0 ) {\n    ```", "```cpp\n                    uint global_light_index =\n    ```", "```cpp\n                        light_indices[ light_id ];\n    ```", "```cpp\n                    Light point_light = lights[\n    ```", "```cpp\n                        global_light_index ];\n    ```", "```cpp\n                    final_color.rgb +=\n    ```", "```cpp\n                        calculate_point_light_contribution\n    ```", "```cpp\n                          ( albedo, orm, normal, emissive,\n    ```", "```cpp\n                              world_position, V, F0, NoV,\n    ```", "```cpp\n                                  point_light );\n    ```", "```cpp\n            }\n    ```", "```cpp\n        }\n    ```", "```cpp\n    }\n    ```"]