["```cpp\n#include <iostream>\n#include <unordered_set>\n#include <vector>\nvoid displaySet(const std::unordered_set<int> &set) {\n  for (const int &num : set) { std::cout << num << \" \"; }\n  std::cout << '\\n';\n}\nint main() {\n  std::unordered_set<int> numbers;\n  for (int i = 0; i < 10; ++i) { numbers.insert(i); }\n  displaySet(numbers);\n  int searchValue = 5;\n  if (numbers.find(searchValue) != numbers.end()) {\n    std::cout << searchValue << \" found in the set.\"\n              << '\\n';\n  } else {\n    std::cout << searchValue << \" not found in the set.\"\n              << '\\n';\n  }\n  numbers.erase(5);\n  displaySet(numbers);\n  std::cout << \"Size: \" << numbers.size() << '\\n';\n  std::cout << \"Load factor: \" << numbers.load_factor()\n            << '\\n';\n  numbers.rehash(50);\n  std::cout << \"Number of buckets after rehash: \"\n            << numbers.bucket_count() << '\\n';\n  std::vector<int> moreNumbers = {100, 101, 102, 103};\n  numbers.insert(moreNumbers.begin(), moreNumbers.end());\n  displaySet(numbers);\n  return 0;\n}\n```", "```cpp\n9 8 7 6 5 4 3 2 1 0\n5 found in the set.\n9 8 7 6 4 3 2 1 0\nSize: 9\nLoad factor: 0.818182\nNumber of buckets after rehash: 53\n103 102 101 100 9 8 7 6 4 3 2 1 0\n```", "```cpp\n#include <iostream>\n#include <unordered_map>\nvoid displayMap(\n    const std::unordered_map<std::string, int> &map) {\n  for (const auto &[key, value] : map) {\n    std::cout << key << \": \" << value << '\\n';\n  }\n}\nint main() {\n  std::unordered_map<std::string, int> ageMap;\n  ageMap[„Lisa\"] = 28;\n  ageMap[„Corbin\"] = 25;\n  ageMap[„Aaron\"] = 30;\n  std::cout << \"Corbin's age: \" << ageMap[\"Corbin\"]\n            << '\\n';\n  if (ageMap.find(\"Daisy\") == ageMap.end()) {\n    std::cout << \"Daisy not found in the map.\" << '\\n';\n  } else {\n    std::cout << \"Daisy's age: \" << ageMap[\"Daisy\"]\n              << '\\n';\n  }\n  ageMap[\"Lisa\"] = 29;\n  std::cout << \"Lisa's updated age: \" << ageMap[\"Lisa\"]\n            << '\\n';\n  displayMap(ageMap);\n  std::cout << \"Load factor: \" << ageMap.load_factor()\n            << '\\n';\n  std::cout << \"Bucket count: \" << ageMap.bucket_count()\n            << '\\n';\n  ageMap.rehash(50);\n  std::cout << \"Bucket count after rehash:\"\n            << ageMap.bucket_count() << '\\n';\n  // Remove an entry\n  ageMap.erase(\"Aaron\");\n  displayMap(ageMap);\n  return 0;\n}\n```", "```cpp\nCorbin's age: 25\nDaisy not found in the map.\nLisa's updated age: 29\nAaron: 30\nCorbin: 25\nLisa: 29\nLoad factor: 0.6\nBucket count: 5\nBucket count after rehash:53\nCorbin: 25\nLisa: 29\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <unordered_set>\nint main() {\n  std::unordered_multiset<std::string> fruits;\n  fruits.insert(\"apple\");\n  fruits.insert(\"banana\");\n  fruits.insert(\"apple\");\n  fruits.insert(\"orange\");\n  fruits.insert(\"apple\");\n  fruits.insert(\"mango\");\n  fruits.insert(\"banana\");\n  const auto appleCount = fruits.count(\"apple\");\n  std::cout << \"Number of apples: \" << appleCount << '\\n';\n  auto found = fruits.find(\"orange\");\n  if (found != fruits.end()) {\n    std::cout << \"Found: \" << *found << '\\n';\n  } else {\n    std::cout << \"Orange not found!\" << '\\n';\n  }\n  auto range = fruits.equal_range(\"banana\");\n  for (auto itr = range.first; itr != range.second;\n       ++itr) {\n    std::cout << *itr << \" \";\n  }\n  std::cout << '\\n';\n  fruits.erase(\"apple\");\n  std::cout << \"Number of apples after erase:\"\n            << fruits.count(\"apple\") << '\\n';\n  std::cout << \"Load factor: \" << fruits.load_factor()\n            << '\\n';\n  std::cout << \"Bucket count: \" << fruits.bucket_count()\n            << '\\n';\n  fruits.rehash(50);\n  std::cout << \"Bucket count after rehashing: \"\n            << fruits.bucket_count() << '\\n';\n  for (const auto &fruit : fruits) {\n    std::cout << fruit << \" \";\n  }\n  std::cout << '\\n';\n  return 0;\n}\n```", "```cpp\nNumber of apples: 3\nFound: orange\nbanana banana\nNumber of apples after erase:0\nLoad factor: 0.363636\nBucket count: 11\nBucket count after rehashing: 53\nmango banana banana orange\n```", "```cpp\n#include <iostream>\n#include <string>\n#include <unordered_map>\nint main() {\n  std::unordered_multimap<std::string, int> grades;\n  grades.insert({\"Lisa\", 85});\n  grades.insert({\"Corbin\", 92});\n  grades.insert({\"Lisa\", 89});\n  grades.insert({\"Aaron\", 76});\n  grades.insert({\"Corbin\", 88});\n  grades.insert({\"Regan\", 91});\n  size_t lisaCount = grades.count(\"Lisa\");\n  std::cout << \"Number of grade entries for Lisa: \"\n            << lisaCount << '\\n';\n  auto range = grades.equal_range(\"Lisa\");\n  for (auto it = range.first; it != range.second; ++it) {\n    std::cout << it->first << \" has grade: \" << it->second\n              << '\\n';\n  }\n  auto lisaGrade = grades.find(\"Lisa\");\n  if (lisaGrade != grades.end()) {\n    lisaGrade->second = 90; // Updating the grade\n  }\n  grades.erase(\"Corbin\"); // This will erase all grade\n                          // entries for Corbin\n  std::cout\n      << \"Number of grade entries for Corbin after erase: \"\n      << grades.count(\"Corbin\") << '\\n';\n  std::cout << \"Load factor: \" << grades.load_factor()\n            << '\\n';\n  std::cout << \"Bucket count: \" << grades.bucket_count()\n            << '\\n';\n  grades.rehash(50);\n  std::cout << \"Bucket count after rehashing: \"\n            << grades.bucket_count() << '\\n';\n  for (const auto &entry : grades) {\n    std::cout << entry.first\n              << \" received grade: \" << entry.second\n              << '\\n';\n  }\n  return 0;\n}\n```", "```cpp\nNumber of grade entries for Lisa: 2\nLisa has grade: 85\nLisa has grade: 89\nNumber of grade entries for Corbin after erase: 0\nLoad factor: 0.363636\nBucket count: 11\nBucket count after rehashing: 53\nRegan received grade: 91\nAaron received grade: 76\nLisa received grade: 90\nLisa received grade: 89\n```"]