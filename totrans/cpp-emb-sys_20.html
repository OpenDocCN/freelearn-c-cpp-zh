<html><head></head><body>
<div><h1 class="chapterNumber">16</h1>
<h1 class="chapterTitle" id="_idParaDest-208">Designing Scalable Finite State Machines</h1>
<p class="normal">A <strong class="keyWord">Finite State Machine</strong> (<code class="inlineCode">FSM</code>) is an abstract computational module used to represent a system that can be in exactly one of a finite number <a id="_idIndexMarker663"/>of states at any given time. An <code class="inlineCode">FSM</code> can transition from one state to another on a given input, and it can perform an action during the transition.</p>
<p class="normal">In control theory, there is a classification of Moore and Mealy machines. Moore’s <code class="inlineCode">FSM</code> output depends only on a state, that is, the <code class="inlineCode">FSM</code> uses only entry actions. Mealy’s <code class="inlineCode">FSM</code> output depends on the input and current state, that is, the action it performs is determined by both the current state and the input.</p>
<p class="normal">The <code class="inlineCode">FSM</code>s that we will cover in this chapter are a combination of both Moore and Mealy <code class="inlineCode">FSM</code>s as they support both actions performed during transitions and entry and exit actions that depend only on a current state. <code class="inlineCode">FSM</code>s are also <a id="_idIndexMarker664"/>called <strong class="keyWord">Unified Modeling Language</strong> (<strong class="keyWord">UML</strong>) state machines and are used in real-life applications in embedded systems to describe and control machines. For example, <code class="inlineCode">FSM</code>s are commonly used to control washing machines, elevator systems, or communication protocols in networking devices, for managing complex sequences of operations based on various inputs. Understanding <code class="inlineCode">FSM</code>s will help you design more predictable and maintainable embedded systems.</p>
<p class="normal">In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li class="bulletList"><code class="inlineCode">FSM</code> – a simple implementation</li>
<li class="bulletList"><code class="inlineCode">FSM</code> – implementation using the State pattern</li>
<li class="bulletList">State pattern implementation using tag dispatching</li>
<li class="bulletList">Boost SML (State Machine Language)</li>
</ul>
<h1 class="heading-1" id="_idParaDest-209">Technical requirements</h1>
<p class="normal">To get the most out of this chapter, I strongly recommend using Compiler Explorer (<a href="https://godbolt.org/">https://godbolt.org/</a>) as you read through the examples. Select GCC as your compiler and target x86 architecture. This will allow you to see standard output (<code class="inlineCode">stdio</code>) results and better observe the code’s behavior. As we are using a lot of modern C++ features, make sure to select the C++23 standard, by adding <code class="inlineCode">-std=c++23 </code>in the compiler options box.</p>
<p class="normal">Compiler Explorer makes it easy to try out the code, tweak it, and immediately see how it affects the output and generated assembly. Most of the examples can also be run in a Renode simulator on an ARM Cortex M0 target and are available on GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter16">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter16</a>).</p>
<h1 class="heading-1" id="_idParaDest-210">FSM – a simple implementation</h1>
<p class="normal">We will jump straight into an <a id="_idIndexMarker665"/>example of an <code class="inlineCode">FSM</code> handling <strong class="keyWord">Bluetooth Low Energy </strong>(<strong class="keyWord">BLE</strong>) device <a id="_idIndexMarker666"/>connection states, analyze its shortcomings, and see how we can improve it using the State design pattern.</p>
<p class="normal">The example <code class="inlineCode">FSM</code> will be simplified for the purpose of clarity and easier understanding. We will have three states – <code class="inlineCode">idle</code>, <code class="inlineCode">advertising</code>, and <code class="inlineCode">connected</code>. Here is a state diagram of the example <code class="inlineCode">FSM</code>:</p>
<figure class="mediaobject"><img alt="Figure 16.1 – BLE device connection state diagram" src="img/B22402_16_1.png"/></figure>
<p class="packt_figref">Figure 16.1 – BLE device connection state diagram</p>
<p class="normal"><em class="italic">Figure 16</em><em class="italic">.1</em> depicts the state diagram of the BLE device connection <code class="inlineCode">FSM</code>. The diagram depicts transitions between states and <a id="_idIndexMarker667"/>actions described as follows:</p>
<ul>
<li class="bulletList">The default state is <code class="inlineCode">idle</code>. It transitions to the <code class="inlineCode">advertising</code> state on a <code class="inlineCode">ble_button_pressed</code> event. During the transition, the <code class="inlineCode">start_advertising</code> action is executed. In simple words, this means that if the device is in an <code class="inlineCode">idle</code> state and a user presses a designated button, it will start advertising and change state.</li>
<li class="bulletList">From the <code class="inlineCode">advertising</code> state, the <code class="inlineCode">FSM</code> can transition to <code class="inlineCode">connected</code> on a <code class="inlineCode">connection_request</code> event or go back to <code class="inlineCode">idle</code> on the <code class="inlineCode">timer_expired</code> state while stopping the advertising by executing the <code class="inlineCode">stop_advertising</code> action.</li>
<li class="bulletList">When in the <code class="inlineCode">connected</code> state, the <code class="inlineCode">FSM</code> can go only to <code class="inlineCode">idle</code> on the <code class="inlineCode">ble_button_pressed</code> event while executing the <code class="inlineCode">disconnect</code> action.</li>
</ul>
<p class="normal">Keep in mind that this is an extremely simplified <code class="inlineCode">FSM</code> we are using for the purpose of an example, and a real-life <code class="inlineCode">FSM</code> would<a id="_idIndexMarker668"/> include more states and events to properly describe the connecting behavior of a BLE device.</p>
<p class="normal">An <code class="inlineCode">FSM</code> can also be described using state transition tables. This table shows the state to which the <code class="inlineCode">FSM</code> moves based on the current state and input (received event), as well as the action it performs during the transition. Here is the transition table for the BLE device <code class="inlineCode">FSM</code> we are analyzing in this chapter: </p>
<table class="table-container" id="table001-1">
<thead>
<tr>
<th class="table-head">
<p class="normal"><strong class="keyWord">Current State</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">Event</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">Next State</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">Action</strong></p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">idle</strong></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">ble_button_pressed</code></p>
</td>
<td class="table-cell">
<p class="normal">advertising</p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">start_advertising</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">advertising</strong></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">timer_expired</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">idle</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">stop_advertising</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">advertising</strong></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">connection_request</code></p>
</td>
<td class="table-cell">
<p class="normal">connected</p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">connected</strong></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">ble_button_pressed</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">idle</code></p>
</td>
<td class="table-cell">
<p class="normal">disconnect</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 16.1 – BLE device state transition table</p>
<p class="normal"><em class="italic">Table 16.1</em> describes the BLE device <code class="inlineCode">FSM</code> by listing transitions in rows. It serves as an alternative to the state diagram for describing <code class="inlineCode">FSM</code> behavior. We will start with the implementation of this <code class="inlineCode">FSM</code> first by defining states and events.</p>
<h2 class="heading-2" id="_idParaDest-211">Describing states and events</h2>
<p class="normal">We will model states and <a id="_idIndexMarker669"/>events as <code class="inlineCode">enum</code>erators, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code"><code class="inlineCode">enum</code> class ble_state {
    idle,
    advertising,
    connected
};
<code class="inlineCode">enum</code> class ble_event {
    ble_button_pressed,
    connection_request,
    timer_expired
};
</code></pre>
<p class="normal">The preceding <code class="inlineCode">enum</code>erators describe states and events for our BLE device <code class="inlineCode">FSM</code>.</p>
<h2 class="heading-2" id="_idParaDest-212">Tracking current state and handling events – the FSM class</h2>
<p class="normal">Next, we will define a class <code class="inlineCode">ble_fsm</code> that will keep <a id="_idIndexMarker670"/>track of the current state and <a id="_idIndexMarker671"/>provide a public method, <code class="inlineCode">handle_event</code>, which we will use to feed the <code class="inlineCode">FSM</code> with events. The code is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">class ble_fsm {
public:
    void handle_event(ble_event event);
    ble_state get_state() const {
        return current_state_;
    }
private:
    ble_state current_state_ = ble_state::idle;
    void start_advertising() {
        printf("Action: start_advertising()\n");
    }
    void stop_advertising() {
        printf("Action: stop_advertising()\n");
    }
    void disconnect() {
        printf("Action: disconnect()\n");
    }
};
</code></pre>
<p class="normal">In the code above, we define<a id="_idIndexMarker672"/> the class ble_fsm with the following members:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ble_state current_state_</code> – A private member with the default value <code class="inlineCode">ble_state::idle</code>. We use it to track the current state, and the initial value is set to <code class="inlineCode">idle</code>.</li>
<li class="bulletList"><code class="inlineCode">void start_advertising()</code> – A private<a id="_idIndexMarker673"/> method used to implement an action.</li>
<li class="bulletList"><code class="inlineCode">void stop_advertising()</code> – A private method used to implement an action.</li>
<li class="bulletList"><code class="inlineCode">void disconnect()</code> – A private method used to implement an action.</li>
<li class="bulletList"><code class="inlineCode">ble_state get_state() const</code> – A private method used to retrieve the current state.</li>
<li class="bulletList"><code class="inlineCode">void handle_event(ble_event event)</code> – A public method used to respond to events by executing actions and changing the current state depending on the <code class="inlineCode">current_event_</code>.</li>
</ul>
<p class="normal">The <code class="inlineCode">handle_event</code> method implements the actual behavior of the <code class="inlineCode">FSM</code>, and the code for it is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">void ble_fsm::handle_event(ble_event event) {
switch (current_state_) {
    case ble_state::idle:
    if (event == ble_event::ble_button_pressed)
    {
        start_advertising();
        current_state_ = ble_state::advertising;
    }
    break;
    case ble_state::advertising:
    if (event == ble_event::connection_request)
    {
        current_state_ = ble_state::connected;
    }
    else if (event == ble_event::timer_expired)
    {
        stop_advertising();
        current_state_ = ble_state::idle;
    }
    break;
    
    case ble_state::connected:
    if (event ==ble_event::ble_button_pressed)
    {
        disconnect();
        current_state_ = ble_state::idle;
    }
    break;
    
    default:
    break;
}
}
</code></pre>
<p class="normal">The preceding code shows the implementation of the <code class="inlineCode">handle_event</code> method for the <code class="inlineCode">ble_fsm</code> class. It uses a <code class="inlineCode">switch</code> statement <a id="_idIndexMarker674"/>on <code class="inlineCode">current_state_</code> to handle the event according to it and receive the event. The event is<a id="_idIndexMarker675"/> handled by calling an appropriate action and changing the state as described by the <code class="inlineCode">FSM</code>.</p>
<p class="normal">Next, we will see how to use the <code class="inlineCode">ble_fsm</code> class.</p>
<h2 class="heading-2" id="_idParaDest-213">Using the ble_fsm class</h2>
<p class="normal">We will first define a helper<a id="_idIndexMarker676"/> function, <code class="inlineCode">state_to_string</code>, used to debug our <code class="inlineCode">FSM</code>. The <a id="_idIndexMarker677"/>code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">static const char* state_to_string(ble_state state) {
    switch (state) {
        case ble_state::idle:        return "<code class="inlineCode">idle</code>";
        case ble_state::advertising: return "advertising";
        case ble_state::connected:   return "connected";
        default:                     return "unknown";
    }
}
</code></pre>
<p class="normal">The <code class="inlineCode">state_to_string</code> function returns a string literal for a given state <code class="inlineCode">enum</code>.</p>
<p class="normal">Next, let us see how to use the <code class="inlineCode">ble_fsm</code> class, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">int main() {
    ble_fsm my_ble_fsm;
    const auto print_current_state = [&amp;]() {
        printf("Current State: %s\n",
            state_to_string(my_ble_fsm.get_state()));
    };
    print_current_state();
    my_ble_fsm.handle_event(ble_event::ble_button_pressed);
    print_current_state();
    my_ble_fsm.handle_event(ble_event::connection_request);
    print_current_state();
    my_ble_fsm.handle_event(ble_event::ble_button_pressed);
    print_current_state();
   
    return 0;
}
</code></pre>
<p class="normal">The preceding code in the <code class="inlineCode">main</code> function <a id="_idIndexMarker678"/>creates an object, <code class="inlineCode">my_ble_fsm</code>, of the <code class="inlineCode">ble_fsm</code> type, and it feeds it with events in<a id="_idIndexMarker679"/> the following order:</p>
<ol>
<li class="numberedList" value="1">It first passes <code class="inlineCode">ble_event::ble_button_pressed</code> to the <code class="inlineCode">FSM</code> handle_event method. The initial state of the <code class="inlineCode">FSM</code> is <code class="inlineCode">idle</code>, and after this event, it will transition to <code class="inlineCode">advertising</code>.</li>
<li class="numberedList">Next, it passes the <code class="inlineCode">ble_event::connection_request</code> event to the <code class="inlineCode">FSM</code>, which will make it transition to the <code class="inlineCode">connected</code> state.</li>
<li class="numberedList">Finally, it passes the <code class="inlineCode">ble_event::ble_button_pressed</code> event to the <code class="inlineCode">FSM</code> for the second time, making it transition back to the <code class="inlineCode">idle</code> state.</li>
</ol>
<p class="normal">The code above uses the <code class="inlineCode">state_to_string</code> function to get the string literal from the state <code class="inlineCode">enum</code>, and it uses it to print the current state of the <code class="inlineCode">FSM</code> after it feeds it with an event.</p>
<h2 class="heading-2" id="_idParaDest-214">Analyzing the output</h2>
<p class="normal">Running the full example will <a id="_idIndexMarker680"/>provide the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Current State: idle
Action: start_advertising()
Current State: advertising
Current State: connected
Action: disconnect()
Current State: idle
</code></pre>
<p class="normal">The preceding output shows <code class="inlineCode">FSM</code> states and the executed actions.</p>
<p class="normal">You can run the full example in the <a id="_idIndexMarker681"/>Renode simulator from the book’s GitHub repo. It is placed under <code class="inlineCode">Chapter16/fsm</code>, and you can build and run it using the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake –B build
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">The approach for implementing an <code class="inlineCode">FSM</code> we just went through works well for simple <code class="inlineCode">FSM</code>s. In real-life applications, <code class="inlineCode">FSM</code>s are more complex – they have more states, actions, and events. The <code class="inlineCode">handle_event</code> method in <code class="inlineCode">ble_fsm</code> doesn’t scale well as it is implemented using <code class="inlineCode">switch-case</code> and <code class="inlineCode">if-else</code> logic. Adding more states, and handling more events and actions, makes it less readable and harder to maintain.</p>
<p class="normal">Next, we will see how we can utilize the State design pattern to mitigate these issues.</p>
<h1 class="heading-1" id="_idParaDest-215">FSM – implementation using the State pattern</h1>
<p class="normal">Building on our switch-based <a id="_idIndexMarker682"/>approach, we will now refactor the BLE device connection <code class="inlineCode">FSM</code> using the State design pattern. This pattern is “state-centric,” meaning each state is encapsulated as its own class. A common base class interface<a id="_idIndexMarker683"/> will allow the <code class="inlineCode">FSM</code> to store pointers to these concrete state classes in a container.</p>
<p class="normal">In a typical <code class="inlineCode">FSM</code>, states change dynamically at runtime in response to external interrupts and timers. In our example, we will continue using an <code class="inlineCode">enum</code> to differentiate states and store the current one in a private member variable. This <code class="inlineCode">enum</code>-based approach still works well with the State pattern, since it lets us quickly locate and switch between the concrete state objects that the <code class="inlineCode">FSM</code> manages. We will start the implementation with the state class interface.</p>
<h2 class="heading-2" id="_idParaDest-216">Understanding state class interfaces</h2>
<p class="normal">The <code class="inlineCode">state</code> class interface is <a id="_idIndexMarker684"/>shown in the <a id="_idIndexMarker685"/>following code:</p>
<pre class="programlisting code"><code class="hljs-code">class state {
public:
    virtual ble_state handle_event(ble_event event) = 0;
    virtual ble_state get_state_<code class="inlineCode">enum</code>() = 0;
};
</code></pre>
<p class="normal">In the preceding code, we see that the state interface is simple and has two pure virtual methods:</p>
<ul>
<li class="bulletList"><code class="inlineCode">virtual ble_state handle_event(ble_event event)</code> – A method intended to be implemented by a derived class to handle an actual event. It returns a <code class="inlineCode">ble_state</code> <code class="inlineCode">enum</code> to signal a new state to an <code class="inlineCode">FSM</code>. If handling an event doesn’t cause transition, it should return the <code class="inlineCode">enum</code> that corresponds to the current state.</li>
<li class="bulletList"><code class="inlineCode">virtual ble_state get_state_enum()</code> – A method used to return a <code class="inlineCode">ble_state</code> <code class="inlineCode">enum</code> corresponding to an actual state.</li>
</ul>
<p class="normal">Next, we will go over the implementation of concrete state classes: <code class="inlineCode">idle</code>, <code class="inlineCode">advertising</code>, and <code class="inlineCode">connected</code>. We will start with the <code class="inlineCode">idle</code> class, as shown in this code:</p>
<pre class="programlisting code"><code class="hljs-code">class idle : public state{
public:
    ble_state handle_event(ble_event event) {
        if (event == ble_event::ble_button_pressed) {
            start_advertising();
            return ble_state::advertising;
        }
        return get_state_enum();
    }
    ble_state get_state_enum() {
       return ble_state::idle;
    }
private:
    void start_advertising() {
        printf("Action: start_advertising()\n");
    }
};
</code></pre>
<p class="normal">In the preceding code, we see<a id="_idIndexMarker686"/> that the <code class="inlineCode">idle</code> class implements<a id="_idIndexMarker687"/> pure virtual methods defined in the <code class="inlineCode">state</code> interface class:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ble_state handle_event(ble_event event)</code> – The <code class="inlineCode">idle</code> class checks whether the received event is <code class="inlineCode">ble_event::ble_button_pressed</code> and calls <code class="inlineCode">start_advertising</code> if it is and returns the <code class="inlineCode">ble_state::advertising</code> <code class="inlineCode">enum</code>. In the case that it receives any other event, it returns the state provided with <code class="inlineCode">get_state_enum</code>.</li>
<li class="bulletList"><code class="inlineCode">ble_state get_state_enum()</code> – This returns the <code class="inlineCode">ble_state</code> <code class="inlineCode">enum</code> corresponding to the <code class="inlineCode">idle</code> class, which is <code class="inlineCode">ble_state::idle</code>.</li>
</ul>
<p class="normal">Next, we will go through the derived class <code class="inlineCode">advertising</code>, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">class advertising : public state{
public:
    ble_state handle_event(ble_event event) {
        if (event == ble_event::connection_request) {
            return ble_state::connected;
        }
        if (event == ble_event::timer_expired) {
            stop_advertising();
            return ble_state::idle;
        }
        return get_state_enum();
    }
    ble_state get_state_enum() {
       return ble_state::advertising;
    }
private:
    void stop_advertising() {
        printf("Action: stop_advertising()\n");
    }
};
</code></pre>
<p class="normal">In this code, the <code class="inlineCode">advertising</code> class implements pure virtual methods defined in the <code class="inlineCode">state</code> interface class by handling the <a id="_idIndexMarker688"/>events appropriately.</p>
<p class="normal">Next, we will go over the <code class="inlineCode">connected</code> concrete <a id="_idIndexMarker689"/>class:</p>
<pre class="programlisting code"><code class="hljs-code">class connected : public state{
public:
    ble_state handle_event(ble_event event) {
        if (event == ble_event::ble_button_pressed) {
            disconnect();
            return ble_state::idle;
        }
        return get_state_enum();
    }
    ble_state get_state_enum() {
       return ble_state::connected;
    }
private:
    void disconnect() {
        printf("Action: disconnect()\n");
    }
};
</code></pre>
<p class="normal">As we can see in the preceding code, the <code class="inlineCode">connected</code> class implements a state interface and implements the virtual methods <code class="inlineCode">handle_event</code> and <code class="inlineCode">get_state_enum</code> appropriately.</p>
<p class="normal">Next, we will refactor the <code class="inlineCode">ble_fsm</code> class to use the state class interface to store pointers to concrete class objects in a <a id="_idIndexMarker690"/>container.</p>
<h2 class="heading-2" id="_idParaDest-217">Refactoring the ble_fsm class</h2>
<p class="normal">We will start with<a id="_idIndexMarker691"/> refactoring the <code class="inlineCode">ble_fsm</code> class, as shown<a id="_idIndexMarker692"/> in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">class ble_fsm {
public:
    void handle_event(ble_event event) {
        if(auto the_state = get_the_state(current_state_)) { 
            current_state_ = the_state-&gt;handle_event(event);
        }
    }
    ble_state get_state() const {
        return current_state_;
    }
    void add_state(state *the_state) {
        states_.push_back(the_state);
    }
private:
    ble_state current_state_ = ble_state::idle;
    etl::vector&lt;state*, 3&gt; states_;
    state* get_the_state(ble_state state_enum); };
</code></pre>
<p class="normal">Let us break down the implementation of the <code class="inlineCode">ble_fsm</code> class:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ble_state current_state_</code> – A private member with the default value <code class="inlineCode">ble_state::idle</code>. We use it to track the current state, as we did previously.</li>
<li class="bulletList"><code class="inlineCode">etl::vector&lt;state*, 3&gt; states_</code> – A container used to hold pointers to the state interface. If you are following this example using Compiler Explorer, you can replace it with <code class="inlineCode">std::vector</code> (and include a <code class="inlineCode">&lt;vector&gt;</code> header).</li>
<li class="bulletList"><code class="inlineCode">state* get_the_state(ble_state state_enum)</code> – A private method used to get an actual state using the <code class="inlineCode">ble_state</code> <code class="inlineCode">enum</code>.</li>
<li class="bulletList"><code class="inlineCode">void handle_event(ble_event event)</code> – A public method used to handle events. It calls the <code class="inlineCode">get_the_state</code> method provided with <code class="inlineCode">current_state_</code> to get a pointer to the actual <a id="_idIndexMarker693"/>state object. If the pointer is valid, it calls <code class="inlineCode">handle_event</code> on the state object and <a id="_idIndexMarker694"/>stores the return value in <code class="inlineCode">current_state_</code>.</li>
</ul>
<p class="normal">Next, let us go through the <code class="inlineCode">get_the_state</code> method implementation, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">state* ble_fsm::get_the_state(ble_state state_enum) {
const auto is_state_enum = [&amp;](state* the_state) {
        return the_state-&gt;get_state_enum() == state_enum;
};
auto it = std::find_if(states_.begin(), states_.end(), is_state_enum);
if (it != states_.end()) {
    return *it;
}
return nullptr;
}
</code></pre>
<p class="normal">In the <code class="inlineCode">get_the_state</code> method, we use the <code class="inlineCode">std::find_if</code> function (from the <code class="inlineCode">&lt;algorithm&gt;</code> header) to search for a pointer to a <code class="inlineCode">state</code> object that matches the given <code class="inlineCode">state_enum</code>. The search uses the <code class="inlineCode">is_state_enum</code> lambda as a predicate, which compares each state’s <code class="inlineCode">enum</code> value. If a matching state is found, the method returns a pointer to it; otherwise, the <code class="inlineCode">nullptr</code>.</p>
<p class="normal">Next, let us see how to use the<a id="_idIndexMarker695"/> refactored <code class="inlineCode">ble_fsm</code> class, the <code class="inlineCode">state</code> interface, and the<a id="_idIndexMarker696"/> concrete classes <code class="inlineCode">idle</code>, <code class="inlineCode">advertising</code>, and <code class="inlineCode">connected</code> to implement the <code class="inlineCode">FSM</code>.</p>
<h2 class="heading-2" id="_idParaDest-218">Implementing the State pattern</h2>
<p class="normal">Next, we will see how to use the above implementation <a id="_idIndexMarker697"/>of the State pattern in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">int main() {
    ble_fsm my_ble_fsm;
    idle idle_s;
    advertising advertising_s;
    connected connected_s;
    my_ble_fsm.add_state(&amp;idle_s);
    my_ble_fsm.add_state(&amp;advertising_s);
    my_ble_fsm.add_state(&amp;connected_s);
    const auto print_current_state = [&amp;]() {
        printf("Current State: %s\n",
            state_to_string(my_ble_fsm.get_state()));
    };
    print_current_state();
    my_ble_fsm.handle_event(ble_event::ble_button_pressed);
    print_current_state();
    my_ble_fsm.handle_event(ble_event::connection_request);
    print_current_state();
    my_ble_fsm.handle_event(ble_event::ble_button_pressed);
    print_current_state();
   
    return 0;
}
</code></pre>
<p class="normal">In this code, we see that after creating an object <code class="inlineCode">my_ble_fsm</code> of the <code class="inlineCode">ble_fsm</code> type, we create instances of concrete states: <code class="inlineCode">idle</code>, <code class="inlineCode">advertising</code>, and <code class="inlineCode">connected</code>. Then, we add pointers to the concrete states to the <code class="inlineCode">my_ble_fsm</code> object using the <code class="inlineCode">add_state</code> method. Next, we use the <code class="inlineCode">FSM</code> as we did in the initial implementation and feed it with events.</p>
<p class="normal">You can run the full example<a id="_idIndexMarker698"/> in the Renode simulator from the book’s GitHub repo. It is placed under <code class="inlineCode">Chapter16/fsm</code>, and you can build and run it using the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake –B build -DMAIN_CPP_FILE_NAME=main_fsm_state_pattern.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">The example we just went through is using the State design pattern. Next, we will go through the generic form of the State design pattern.</p>
<h2 class="heading-2" id="_idParaDest-219">State design pattern</h2>
<p class="normal">Let us go over the UML diagram of<a id="_idIndexMarker699"/> the BLE device<a id="_idIndexMarker700"/> connection <code class="inlineCode">FSM</code>, as shown in <em class="italic">Figure 16</em><em class="italic">.2</em>:</p>
<figure class="mediaobject"><img alt="Figure 16.2 – BLE device connection FSM – UML diagram" src="img/B22402_16_2.png"/></figure>
<p class="packt_figref">Figure 16.2 – BLE device connection FSM – UML diagram</p>
<p class="normal"><em class="italic">Figure 16</em><em class="italic">.2</em> depicts a UML diagram of the BLE device connection <code class="inlineCode">FSM</code>. We already went through applying the State design<a id="_idIndexMarker701"/> pattern to the <code class="inlineCode">FSM</code> implementation. Let us summarize it:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">FSM</code> class holds <a id="_idIndexMarker702"/>pointers to the state class interface in a container.</li>
<li class="bulletList">The <code class="inlineCode">FSM</code> keeps track of the current state.</li>
<li class="bulletList">The <code class="inlineCode">FSM</code> delegates <code class="inlineCode">handle_event</code> calls to a current concrete state.</li>
<li class="bulletList">Concrete states implement the state interface.</li>
<li class="bulletList">Concrete states implement actions and call them appropriately when handling events.</li>
<li class="bulletList">Concrete states return a new state from the <code class="inlineCode">handle_event</code> method. This allows the <code class="inlineCode">FSM</code> to update the current state.</li>
</ul>
<p class="normal">The state design pattern is a simple <a id="_idIndexMarker703"/>yet effective pattern that allows us to break down complex switch statements into more manageable code. Still, as we were able to see in the previous example, concrete states handle<a id="_idIndexMarker704"/> events using <code class="inlineCode">if-else</code> logic. With the increasing complexity of an <code class="inlineCode">FSM</code>, the handle functions can also clutter. To mitigate this, we can apply the tag-dispatching technique.</p>
<h1 class="heading-1" id="_idParaDest-220">State pattern implementation using tag dispatching</h1>
<p class="normal">In the previous example (in the previous sections), the <a id="_idIndexMarker705"/>program flow in event handlers was determined at runtime using <code class="inlineCode">if-else</code> logic. Next, we will use the tag-dispatching <a id="_idIndexMarker706"/>technique to decouple event handling of different events in separate methods. We will rely no longer on the <code class="inlineCode">ble_event</code> <code class="inlineCode">enum</code>, and will create empty types as events instead, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">struct ble_button_pressed{};
struct connection_request{};
struct timer_expired{};
</code></pre>
<p class="normal">Now, the class <code class="inlineCode">state</code> will overload <code class="inlineCode">handle_event</code> virtual methods for every defined event, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">class state {
public:
    virtual ble_state handle_event(ble_button_pressed) {
        return get_state_enum();
    }
    virtual ble_state handle_event(connection_request) {
        return get_state_enum();
    }
    virtual ble_state handle_event(timer_expired) {
        return get_state_enum();
    }
    virtual ble_state get_state_enum() = 0;
};
</code></pre>
<p class="normal">In this code, we see that the class <code class="inlineCode">state</code> is no longer an interface but an abstract class (as not all virtual methods are pure). It overloads the <code class="inlineCode">handle_event</code> function for types <code class="inlineCode">ble_button_pressed</code>, <code class="inlineCode">connection_request</code>, and <code class="inlineCode">timer_expired</code>. It implements all overloads by returning the value <a id="_idIndexMarker707"/>generated by <code class="inlineCode">get_state_enum</code> – a pure virtual<a id="_idIndexMarker708"/> method that will be implemented by derived classes, that is, concrete states.</p>
<p class="normal">Next, let us see the implementation of the <code class="inlineCode">advertising</code> class:</p>
<pre class="programlisting code"><code class="hljs-code">class advertising : public state{
public:
    ble_state handle_event(connection_request cr){
        return ble_state::connected;
    }
    ble_state handle_event(timer_expired te){
        stop_advertising();
        return ble_state::idle;
    }
    ble_state get_state_enum() {
       return ble_state::advertising;
    }
private:
    void stop_advertising() {
        printf("Action: stop_advertising()\n");
    }
};
</code></pre>
<p class="normal">In this code, we see that the <code class="inlineCode">advertising</code> class implements the following overloads of the virtual method <code class="inlineCode">handle_event</code>:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ble_state handle_event(connection_request cr)</code> returns <code class="inlineCode">ble_state::connected</code>.</li>
<li class="bulletList"><code class="inlineCode">ble_state handle_event(timer_expired te)</code> calls <code class="inlineCode">stop_advertising</code> and returns <code class="inlineCode">ble_state::idle</code>.</li>
</ul>
<p class="normal">By using overloaded functions, we can<a id="_idIndexMarker709"/> implement the handling of different events in separate methods and easily dispatch calls<a id="_idIndexMarker710"/> to them by calling <code class="inlineCode">handle_event</code> with different types. To complete the implementation, we also need to overload the <code class="inlineCode">handle_event</code> method in the <code class="inlineCode">FSM</code> for all possible events. We can do this easily by making it a template method, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">class ble_fsm {
public:
    template&lt;typename E&gt;
 void handle_event(E event) {
        if(auto the_state = get_the_state(current_state_))
        {
            current_state_= the_state-&gt;handle_event(event);
        }
    }
//...
};
</code></pre>
<p class="normal">The preceding code shows the template method <code class="inlineCode">handle_event</code> from the <code class="inlineCode">ble_fsm</code> class, which makes our tag-dispatching technique application complete.</p>
<p class="normal">You can run the full example in the Renode simulator from the book’s GitHub repo. It is placed under <code class="inlineCode">Chapter16/fsm</code>, and you can build and run it using the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake –B build
-DMAIN_CPP_FILE_NAME=main_fsm_state_pattern_tag_dispatch.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Until this point, we saw three approaches in this chapter to implement an <code class="inlineCode">FSM</code> in C++. We started with a simple switch and if-else-based approach, applied the State design pattern, and then utilized tag dispatching. Each <a id="_idIndexMarker711"/>step provided us with more flexibility in the design – making code more readable <a id="_idIndexMarker712"/>and easier to manage, which is important when working with complex <code class="inlineCode">FSM</code>s.</p>
<p class="normal">There are other approaches to implementing an <code class="inlineCode">FSM</code>, based on a state transition table, which describes transitions in a single place. Boost <strong class="keyWord">State Machine Language</strong> (<strong class="keyWord">SML</strong>) uses a table-based approach to describe an <code class="inlineCode">FSM</code> using<a id="_idIndexMarker713"/> descriptive syntax.</p>
<h1 class="heading-1" id="_idParaDest-221">Boost SML</h1>
<p class="normal">Boost SML is a highly expressive C++14 single <a id="_idIndexMarker714"/>header library used to implement <code class="inlineCode">FSM</code>s. We will jump straight ahead in using it by implementing the same BLE device connection <code class="inlineCode">FSM</code>. Here is the code:</p>
<pre class="programlisting code"><code class="hljs-code">#include "sml.hpp"
namespace sml = boost::sml;
struct ble_button_pressed{};
struct connection_request{};
struct timer_expired{};
constexpr auto start_advertising = [](){
    printf("Action: start_advertising()\n");
};
constexpr auto stop_advertising = [](){
    printf("Action: stop_advertising()\n");
};
constexpr auto disconnect = [](){
    printf("Action: disconnect()\n");
};
struct ble_fsm {
  auto operator()() const {
    using namespace sml;
        return make_transition_table(
        *"idle"_s + event&lt;ble_button_pressed&gt;
        / start_advertising                          = "advertising"_s,
        "advertising"_s  + event&lt;connection_request&gt; = "connected"_s,
        "advertising"_s  + event&lt;timer_expired&gt;     
        / stop_advertising                           = "idle"_s,
        "connected"_s + event&lt;ble_button_pressed&gt;
        / disconnect                                 = "idle"_s
    );
  }
};
</code></pre>
<p class="normal">Let us break down this example:</p>
<ul>
<li class="bulletList">The events are modeled <a id="_idIndexMarker715"/>as structs, the same as in our tag-dispatching implementation.</li>
<li class="bulletList">Actions are defined as <code class="inlineCode">constexpr</code> lambdas.</li>
<li class="bulletList">We define the type <code class="inlineCode">ble_fsm</code> as a struct with an overloaded <code class="inlineCode">operator()</code>, which returns the result of a call to <code class="inlineCode">make_transition_table</code> from the namespace <code class="inlineCode">sml</code>.</li>
</ul>
<p class="normal">The code in <code class="inlineCode">make_transition_table</code> allows SML to extract transition definitions, and within it, we are using the following syntax: <code class="inlineCode">src_state + event [ guard ] / action = dst_state</code>. Here is a breakdown of the syntax:</p>
<ul>
<li class="bulletList"> <code class="inlineCode">src_state</code> – This is the state from which the transition starts.</li>
<li class="bulletList"><code class="inlineCode">+ event</code> – This is the event that triggers checking for a possible transition. If the event arrives and the guard is satisfied, then the transition proceeds.</li>
<li class="bulletList"><code class="inlineCode">[ guard ]</code> – The guard is an optional bool predicate that must evaluate to true for the transition to occur. If omitted, the transition happens unconditionally at the specified event.</li>
<li class="bulletList"><code class="inlineCode">/ action</code> – The action is an optional lambda to execute whenever the transition takes place.</li>
<li class="bulletList"><code class="inlineCode">= dst_state</code> – The destination state is where the <code class="inlineCode">FSM</code> will go if the transition occurs.</li>
</ul>
<p class="normal">The transition syntax is the essence of SML. By writing <a id="_idIndexMarker716"/>multiple lines of these rules inside the <code class="inlineCode">operator()</code>, we fully describe the <code class="inlineCode">FSM</code>'s behavior in a declarative, human-readable way.</p>
<p class="normal">Let us now see how to use the <code class="inlineCode">FSM</code> we discussed using Boost SML:</p>
<pre class="programlisting code"><code class="hljs-code">    sm&lt;ble_fsm&gt; my_ble_fsm{};
    const auto print_current_state = [&amp;]() {
        printf("Current State: ");
        if(my_ble_fsm.is("idle"_s)) {
            printf("idle\n");
        }
        if(my_ble_fsm.is("advertising"_s)) {
            printf("advertising\n");
        }
        if(my_ble_fsm.is("connected"_s)) {
            printf("connected\n");
        }
    };
    print_current_state();
    my_ble_fsm.process_event(ble_button_pressed{});
    print_current_state();
    my_ble_fsm.process_event(connection_request{});
    print_current_state();
    my_ble_fsm.process_event(ble_button_pressed{});
    print_current_state();
</code></pre>
<p class="normal">In this code, we create an object <code class="inlineCode">my_ble_fsm</code> of the type <code class="inlineCode">sm&lt;ble_fsm&gt;</code>. Then, we use the <code class="inlineCode">process_event</code> method to send an<a id="_idIndexMarker717"/> event to it. You can run the full example in the Renode simulator from the book’s GitHub repo. It is placed under <code class="inlineCode">Chapter16/fsm</code>, and you can build and run it using the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake –B build -DMAIN_CPP_FILE_NAME=main_fsm_boost_sml.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Boost SML is a highly expressive library that reduces boilerplate code from the previous implementations of an <code class="inlineCode">FSM</code>. It also offers features such as guard variables and composite states. Here is a project link where you can explore more: <a href="https://github.com/boost-ext/sml">https://github.com/boost-ext/sml</a>.</p>
<p class="normal">Boost SML is not only an expressive library but also highly performant, thanks to its use of compile-time template metaprogramming to aggressively optimize code. Event dispatching relies on tag dispatching (resolved at compile time) paired with minimal runtime lookups, avoiding costly branching or indirection. This approach typically outperforms both manual switch-<code class="inlineCode">enum</code>-based solutions and State pattern-based implementations (which incur virtual call overhead). For concrete performance comparisons, see the benchmark at the following link: <a href="https://github.com/boost-ext/sml?tab=readme-ov-file#benchmark">https://github.com/boost-ext/sml?tab=readme-ov-file#benchmark</a>.</p>
<p class="normal">Summary</p>
<p class="normal">In this chapter, we went through <code class="inlineCode">FSM</code> implementation starting from the simple switch-case-based approach, to the State pattern, tag dispatching, and using the Boost SML library for highly expressive code.</p>
<p class="normal">The most basic, switch-based implementation is suitable for small <code class="inlineCode">FSM</code>s with a limited number of states and transitions. When the complexity of an <code class="inlineCode">FSM</code> increases, it gets hard to read and manage. Moving to a State pattern-based solution increases code readability and makes changes easier. Boost SML offers ultimate expressiveness, providing us with a human-readable syntax that allows us to write very complex <code class="inlineCode">FSM</code>s in a concise manner.</p>
<p class="normal">In the next chapter, we will go through an overview of libraries and frameworks in C++ usable for embedded systems development.</p>
</div>
</body></html>