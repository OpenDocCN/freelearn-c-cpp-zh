["```cpp\n#pragma once\n#include <sstream>\n#include \"common/types.h\"\nusing namespace Common;\nnamespace Exchange {\n  enum class MarketUpdateType : uint8_t {\n    INVALID = 0,\n    CLEAR = 1,\n    ADD = 2,\n    MODIFY = 3,\n    CANCEL = 4,\n    TRADE = 5,\n    SNAPSHOT_START = 6,\n    SNAPSHOT_END = 7\n  };\n}\n```", "```cpp\n#pragma pack(push, 1)\n  struct MEMarketUpdate {\n    MarketUpdateType type_ = MarketUpdateType::INVALID;\n    OrderId order_id_ = OrderId_INVALID;\n    TickerId ticker_id_ = TickerId_INVALID;\n    Side side_ = Side::INVALID;\n    Price price_ = Price_INVALID;\n    Qty qty_ = Qty_INVALID;\n    Priority priority_ = Priority_INVALID;\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"MEMarketUpdate\"\n         << \" [\"\n         << \" type:\" << marketUpdateTypeToString(type_)\n         << \" ticker:\" << tickerIdToString(ticker_id_)\n         << \" oid:\" << orderIdToString(order_id_)\n         << \" side:\" << sideToString(side_)\n         << \" qty:\" << qtyToString(qty_)\n         << \" price:\" << priceToString(price_)\n         << \" priority:\" << priorityToString(priority_)\n         << \"]\";\n      return ss.str();\n    }\n  };\n  struct MDPMarketUpdate {\n    size_t seq_num_ = 0;\n    MEMarketUpdate me_market_update_;\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"MDPMarketUpdate\"\n         << \" [\"\n         << \" seq:\" << seq_num_\n         << \" \" << me_market_update_.toString()\n         << \"]\";\n      return ss.str();\n    }\n  };\n#pragma pack(pop)\n```", "```cpp\n  typedef Common::LFQueue<Exchange::MEMarketUpdate>\n    MEMarketUpdateLFQueue;\n  typedef Common::LFQueue<Exchange::MDPMarketUpdate>\n    MDPMarketUpdateLFQueue;\n```", "```cpp\n#pragma once\n#include <sstream>\n#include \"common/types.h\"\n#include \"common/lf_queue.h\"\nusing namespace Common;\nnamespace Exchange {\n#pragma pack(push, 1)\n  struct OMClientRequest {\n    size_t seq_num_ = 0;\n    MEClientRequest me_client_request_;\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"OMClientRequest\"\n         << \" [\"\n         << \"seq:\" << seq_num_\n         << \" \" << me_client_request_.toString()\n         << \"]\";\n      return ss.str();\n    }\n  };\n#pragma pack(pop)\n}\n```", "```cpp\n#pragma once\n#include <sstream>\n#include \"common/types.h\"\n#include \"common/lf_queue.h\"\nusing namespace Common;\nnamespace Exchange {\n#pragma pack(push, 1)\n  struct OMClientResponse {\n    size_t seq_num_ = 0;\n    MEClientResponse me_client_response_;\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"OMClientResponse\"\n         << \" [\"\n         << \"seq:\" << seq_num_\n         << \" \" << me_client_response_.toString()\n         << \"]\";\n      return ss.str();\n    }\n  };\n#pragma pack(pop)\n}\n```", "```cpp\n    #pragma once\n    ```", "```cpp\n    #include <functional>\n    ```", "```cpp\n    #include \"common/thread_utils.h\"\n    ```", "```cpp\n    #include \"common/macros.h\"\n    ```", "```cpp\n    #include \"common/tcp_server.h\"\n    ```", "```cpp\n    #include \"order_server/client_request.h\"\n    ```", "```cpp\n    #include \"order_server/client_response.h\"\n    ```", "```cpp\n    #include \"order_server/fifo_sequencer.h\"\n    ```", "```cpp\n    namespace Exchange {\n    ```", "```cpp\n      class OrderServer {\n    ```", "```cpp\n      private:\n    ```", "```cpp\n        const std::string iface_;\n    ```", "```cpp\n        const int port_ = 0;\n    ```", "```cpp\n        ClientResponseLFQueue *outgoing_responses_ = nullptr;\n    ```", "```cpp\n        volatile bool run_ = false;\n    ```", "```cpp\n        std::string time_str_;\n    ```", "```cpp\n        Logger logger_;\n    ```", "```cpp\n        std::array<size_t, ME_MAX_NUM_CLIENTS> cid_next_outgoing_\n    ```", "```cpp\n        seq_num_;\n    ```", "```cpp\n        std::array<size_t, ME_MAX_NUM_CLIENTS> cid_next_exp_seq_\n    ```", "```cpp\n        num_;\n    ```", "```cpp\n        std::array<Common::TCPSocket *, ME_MAX_NUM_CLIENTS> cid_tcp_\n    ```", "```cpp\n        socket_;\n    ```", "```cpp\n        Common::TCPServer tcp_server_;\n    ```", "```cpp\n        FIFOSequencer fifo_sequencer_;\n    ```", "```cpp\n      };\n    ```", "```cpp\n    }\n    ```", "```cpp\n    OrderServer(ClientRequestLFQueue *client_requests,\n    ClientResponseLFQueue *client_responses, const std::string &iface,\n    int port);\n    ~OrderServer();\n    auto start() -> void;\n    auto stop() -> void;\n```", "```cpp\n#include \"order_server.h\"\nnamespace Exchange {\n  OrderServer::OrderServer(ClientRequestLFQueue *client_requests,\n    ClientResponseLFQueue *client_responses, const std::string &iface,\n    int port)\n      : iface_(iface), port_(port), outgoing_responses_(client_\n    responses), logger_(\"exchange_order_server.log\"),\n        tcp_server_(logger_), fifo_sequencer_(client_requests, \n    &logger_) {\n    cid_next_outgoing_seq_num_.fill(1);\n    cid_next_exp_seq_num_.fill(1);\n    cid_tcp_socket_.fill(nullptr);\n    tcp_server_.recv_callback_ = [this](auto socket, auto rx_time) { \n    recvCallback(socket, rx_time); };\n    tcp_server_.recv_finished_callback_ = [this]() {\n    recvFinishedCallback(); };\n  }\n}\n```", "```cpp\n  auto OrderServer::start() -> void {\n    run_ = true;\n    tcp_server_.listen(iface_, port_);\n    ASSERT(Common::createAndStartThread(-1, \"Exchange/OrderServer\",\n    [this]() { run(); }) != nullptr, \"Failed to start OrderServer\n    thread.\");\n  }\n```", "```cpp\n  auto OrderServer::stop() -> void {\n    run_ = false;\n  }\n```", "```cpp\n  OrderServer::~OrderServer() {\n    stop();\n    using namespace std::literals::chrono_literals;\n    std::this_thread::sleep_for(1s);\n  }\n```", "```cpp\n    auto recvCallback(TCPSocket *socket, Nanos rx_time) noexcept {\n      logger_.log(\"%:% %() % Received socket:% len:% rx:%\\n\", __FILE__,\n    __LINE__, __FUNCTION__, Common::getCurrentTimeStr(&time_str_),\n                  socket->fd_, socket->next_rcv_valid_index_, rx_\n    time);\n      if (socket->next_rcv_valid_index_ >= sizeof(OMClientRequest)) {\n        size_t i = 0;\n        for (; i + sizeof(OMClientRequest) <= socket->next_rcv_valid_\n        index_; i += sizeof(OMClientRequest)) {\n        auto request = reinterpret_cast<const OMClientRequest         *>(socket->rcv_buffer_ + i);\n          logger_.log(\"%:% %() % Received %\\n\", __FILE__, __LINE__,\n          __FUNCTION__, Common::getCurrentTimeStr(&time_str_),\n          request->toString());\n```", "```cpp\n          if (UNLIKELY(cid_tcp_socket_[request->me_client_request_.\n          client_id_] == nullptr)) {\n            cid_tcp_socket_[request->me_client_request_.client_id_] =\n            socket;\n          }\n```", "```cpp\n          if (cid_tcp_socket_[request->me_client_request_.client_id_]\n          != socket) {\n            logger_.log(\"%:% %() % Received ClientRequest from\n            ClientId:% on different socket:% expected:%\\n\", __FILE__,\n            __LINE__, __FUNCTION__,\n                        Common::getCurrentTimeStr(&time_str_),\n                        request->me_client_request_.client_id_,\n                        socket->fd_,\n                        cid_tcp_socket_[request->me_client_request_.\n                        client_id_]->fd_);\n            continue;\n          }\n```", "```cpp\n          auto &next_exp_seq_num = cid_next_exp_seq_num_[request->me_\n          client_request_.client_id_];\n          if (request->seq_num_ != next_exp_seq_num) {\n            logger_.log(\"%:% %() % Incorrect sequence number.\n            ClientId:% SeqNum expected:% received:%\\n\", __FILE__,\n            __LINE__, __FUNCTION__,\n                        Common::getCurrentTimeStr(&time_str_),\n                        request->me_client_request_.client_id_, next_\n                        exp_seq_num, request->seq_num_);\n            continue;\n          }\n```", "```cpp\n          ++next_exp_seq_num;\n          fifo_sequencer_.addClientRequest(rx_time, request->me_\n          client_request_);\n        }\n        memcpy(socket->rcv_buffer_, socket->rcv_buffer_ + i, socket-\n        >next_rcv_valid_index_ - i);\n        socket->next_rcv_valid_index_ -= i;\n      }\n    }\n```", "```cpp\n    auto recvFinishedCallback() noexcept {\n      fifo_sequencer_.sequenceAndPublish();\n    }\n```", "```cpp\n#pragma once\n#include \"common/thread_utils.h\"\n#include \"common/macros.h\"\n#include \"order_server/client_request.h\"\nnamespace Exchange {\n  constexpr size_t ME_MAX_PENDING_REQUESTS = 1024;\n  class FIFOSequencer {\n  private:\n    ClientRequestLFQueue *incoming_requests_ = nullptr;\n    std::string time_str_;\n    Logger *logger_ = nullptr;\n    struct RecvTimeClientRequest {\n      Nanos recv_time_ = 0;\n      MEClientRequest request_;\n      auto operator<(const RecvTimeClientRequest &rhs) const {\n        return (recv_time_ < rhs.recv_time_);\n      }\n    };\n    std::array<RecvTimeClientRequest, ME_MAX_PENDING_REQUESTS>\n    pending_client_requests_;\n    size_t pending_size_ = 0;\n  };\n}\n```", "```cpp\n  class FIFOSequencer {\n  public:\n    FIFOSequencer(ClientRequestLFQueue *client_requests, Logger \n    *logger)\n        : incoming_requests_(client_requests), logger_(logger) {\n    }\n```", "```cpp\n    auto addClientRequest(Nanos rx_time, const MEClientRequest\n    &request) {\n      if (pending_size_ >= pending_client_requests_.size()) {\n        FATAL(\"Too many pending requests\");\n      }\n      pending_client_requests_.at(pending_size_++) =\n      std::move(RecvTimeClientRequest{rx_time, request});\n    }\n```", "```cpp\n        auto sequenceAndPublish() {\n    ```", "```cpp\n          if (UNLIKELY(!pending_size_))\n    ```", "```cpp\n            return;\n    ```", "```cpp\n          logger_->log(\"%:% %() % Processing % requests.\\n\", __\n    ```", "```cpp\n          FILE__, __LINE__, __FUNCTION__, Common::getCurrentTimeStr\n    ```", "```cpp\n          (&time_str_), pending_size_);\n    ```", "```cpp\n          std::sort(pending_client_requests_.begin(), pending_\n    ```", "```cpp\n          client_requests_.begin() + pending_size_);\n    ```", "```cpp\n          for (size_t i = 0; i < pending_size_; ++i) {\n    ```", "```cpp\n            const auto &client_request = pending_client_requests_.\n    ```", "```cpp\n            at(i);\n    ```", "```cpp\n            logger_->log(\"%:% %() % Writing RX:% Req:%\n    ```", "```cpp\n            to FIFO.\\n\", __FILE__, __LINE__, __FUNCTION__,\n    ```", "```cpp\n            Common::getCurrentTimeStr(&time_str_),\n    ```", "```cpp\n                         client_request.recv_time_, client_request.\n    ```", "```cpp\n                         request_.toString());\n    ```", "```cpp\n            auto next_write = incoming_requests_->getNextToWriteTo();\n    ```", "```cpp\n            *next_write = std::move(client_request.request_);\n    ```", "```cpp\n            incoming_requests_->updateWriteIndex();\n    ```", "```cpp\n          }\n    ```", "```cpp\n          pending_size_ = 0;\n    ```", "```cpp\n        }\n    ```", "```cpp\n        auto run() noexcept {\n    ```", "```cpp\n          logger_.log(\"%:% %() %\\n\", __FILE__, __LINE__, __\n    ```", "```cpp\n          FUNCTION__, Common::getCurrentTimeStr(&time_str_));\n    ```", "```cpp\n          while (run_) {\n    ```", "```cpp\n            tcp_server_.poll();\n    ```", "```cpp\n            tcp_server_.sendAndRecv();\n    ```", "```cpp\n            for (auto client_response = outgoing_responses_-\n    ```", "```cpp\n            >getNextToRead(); outgoing_responses_->size() &&\n    ```", "```cpp\n            client_response; client_response = outgoing_responses_-\n    ```", "```cpp\n            >getNextToRead()) {\n    ```", "```cpp\n              auto &next_outgoing_seq_num = cid_next_outgoing_seq_\n    ```", "```cpp\n              num_[client_response->client_id_];\n    ```", "```cpp\n              logger_.log(\"%:% %() % Processing cid:% seq:% %\\n\", __\n    ```", "```cpp\n              FILE__, __LINE__, __FUNCTION__,\n    ```", "```cpp\n              Common::getCurrentTimeStr(&time_str_),\n    ```", "```cpp\n              client_response->client_id_, next_\n    ```", "```cpp\n              outgoing_seq_num, client_response-\n    ```", "```cpp\n              >toString());\n    ```", "```cpp\n              ASSERT(cid_tcp_socket_[client_response->client_id_] !=\n    ```", "```cpp\n              nullptr,\n    ```", "```cpp\n                     \"Dont have a TCPSocket for ClientId:\" + \n    ```", "```cpp\n                     std::to_string(client_response->client_id_));\n    ```", "```cpp\n              cid_tcp_socket_[client_response->client_id_]-\n    ```", "```cpp\n              >send(&next_outgoing_seq_num, sizeof(next_outgoing_\n    ```", "```cpp\n              seq_num));\n    ```", "```cpp\n              cid_tcp_socket_[client_response->client_id_]-\n    ```", "```cpp\n              >send(client_response, sizeof(MEClientResponse));\n    ```", "```cpp\n              outgoing_responses_->updateReadIndex();\n    ```", "```cpp\n              ++next_outgoing_seq_num;\n    ```", "```cpp\n            }\n    ```", "```cpp\n          }\n    ```", "```cpp\n        }\n    ```", "```cpp\n    #pragma once\n    ```", "```cpp\n    #include <functional>\n    ```", "```cpp\n    #include \"market_data/snapshot_synthesizer.h\"\n    ```", "```cpp\n    namespace Exchange {\n    ```", "```cpp\n      class MarketDataPublisher {\n    ```", "```cpp\n      private:\n    ```", "```cpp\n        size_t next_inc_seq_num_ = 1;\n    ```", "```cpp\n        MEMarketUpdateLFQueue *outgoing_md_updates_ = nullptr;\n    ```", "```cpp\n        MDPMarketUpdateLFQueue snapshot_md_updates_;\n    ```", "```cpp\n        volatile bool run_ = false;\n    ```", "```cpp\n        std::string time_str_;\n    ```", "```cpp\n        Logger logger_;\n    ```", "```cpp\n        Common::McastSocket incremental_socket_;\n    ```", "```cpp\n        SnapshotSynthesizer *snapshot_synthesizer_ = nullptr;\n    ```", "```cpp\n      };\n    ```", "```cpp\n    }\n    ```", "```cpp\n#include \"market_data_publisher.h\"\nnamespace Exchange {  MarketDataPublisher::MarketDataPublisher(MEMarketUpdateLFQueue\n   *market_updates, const std::string &iface,\n                                           const std::string \n                                           &snapshot_ip, int snapshot_\n                                           port,\n                                           const std::string\n                                           &incremental_ip, int \n                                           incremental_port)\n      : outgoing_md_updates_(market_updates), snapshot_md_updates_(ME_\n      MAX_MARKET_UPDATES),\n        run_(false), logger_(\"exchange_market_data_publisher.log\"),\n        incremental_socket_(logger_) {\n    ASSERT(incremental_socket_.init(incremental_ip, iface,\n    incremental_port, /*is_listening*/ false) >= 0,\n           \"Unable to create incremental mcast socket. error:\" +\n           std::string(std::strerror(errno)));\n    snapshot_synthesizer_ = new SnapshotSynthesizer(&snapshot_md_\n    updates_, iface, snapshot_ip, snapshot_port);\n  }\n```", "```cpp\n    auto start() {\n      run_ = true;\n      ASSERT(Common::createAndStartThread(-1, \"Exchange/\n      MarketDataPublisher\", [this]() { run(); }) != nullptr, \"Failed\n      to start MarketData thread.\");\n      snapshot_synthesizer_->start();\n    }\n```", "```cpp\n    ~MarketDataPublisher() {\n      stop();\n      using namespace std::literals::chrono_literals;\n      std::this_thread::sleep_for(5s);\n      delete snapshot_synthesizer_;\n      snapshot_synthesizer_ = nullptr;\n    }\n```", "```cpp\n    auto stop() -> void {\n      run_ = false;\n      snapshot_synthesizer_->stop();\n    }\n```", "```cpp\n  auto MarketDataPublisher::run() noexcept -> void {\n    logger_.log(\"%:% %() %\\n\", __FILE__, __LINE__, __FUNCTION__,\n    Common::getCurrentTimeStr(&time_str_));\n    while (run_) {\n      for (auto market_update = outgoing_md_updates_->getNextToRead();\n           outgoing_md_updates_->size() && market_update; market_\n           update = outgoing_md_updates_->getNextToRead()) {\n        logger_.log(\"%:% %() % Sending seq:% %\\n\", __FILE__, __LINE__,\n        __FUNCTION__, Common::getCurrentTimeStr(&time_str_), next_inc_\n        seq_num_,\n                    market_update->toString().c_str());\n```", "```cpp\n        incremental_socket_.send(&next_inc_seq_num_, sizeof(next_inc_\n        seq_num_));\n        incremental_socket_.send(market_update,\n        sizeof(MEMarketUpdate));\n        outgoing_md_updates_->updateReadIndex();\n```", "```cpp\n        auto next_write = snapshot_md_updates_.getNextToWriteTo();\n        next_write->seq_num_ = next_inc_seq_num_;\n        next_write->me_market_update_ = *market_update;\n        snapshot_md_updates_.updateWriteIndex();\n```", "```cpp\n        ++next_inc_seq_num_;\n      }\n      incremental_socket_.sendAndRecv();\n    }\n  }\n}\n```", "```cpp\n    #pragma once\n    ```", "```cpp\n    #include \"common/types.h\"\n    ```", "```cpp\n    #include \"common/thread_utils.h\"\n    ```", "```cpp\n    #include \"common/lf_queue.h\"\n    ```", "```cpp\n    #include \"common/macros.h\"\n    ```", "```cpp\n    #include \"common/mcast_socket.h\"\n    ```", "```cpp\n    #include \"common/mem_pool.h\"\n    ```", "```cpp\n    #include \"common/logging.h\"\n    ```", "```cpp\n    #include \"market_data/market_update.h\"\n    ```", "```cpp\n    #include \"matcher/me_order.h\"\n    ```", "```cpp\n    using namespace Common;\n    ```", "```cpp\n    namespace Exchange {\n    ```", "```cpp\n      class SnapshotSynthesizer {\n    ```", "```cpp\n      private:\n    ```", "```cpp\n        MDPMarketUpdateLFQueue *snapshot_md_updates_ = nullptr;\n    ```", "```cpp\n        Logger logger_;\n    ```", "```cpp\n        volatile bool run_ = false;\n    ```", "```cpp\n        std::string time_str_;\n    ```", "```cpp\n        McastSocket snapshot_socket_;\n    ```", "```cpp\n        std::array<std::array<MEMarketUpdate *, ME_MAX_ORDER_IDS>,\n    ```", "```cpp\n        ME_MAX_TICKERS> ticker_orders_;\n    ```", "```cpp\n        size_t last_inc_seq_num_ = 0;\n    ```", "```cpp\n        Nanos last_snapshot_time_ = 0;\n    ```", "```cpp\n        MemPool<MEMarketUpdate> order_pool_;\n    ```", "```cpp\n      };\n    ```", "```cpp\n    }\n    ```", "```cpp\n#include \"snapshot_synthesizer.h\"\nnamespace Exchange {\n  SnapshotSynthesizer::SnapshotSynthesizer(MDPMarketUpdateLFQueue\n  *market_updates, const std::string &iface,\n                                           const std::string &snapshot_\n                                           ip, int snapshot_port)\n      : snapshot_md_updates_(market_updates), logger_(\"exchange_\n      snapshot_synthesizer.log\"), snapshot_socket_(logger_), order_\n      pool_(ME_MAX_ORDER_IDS) {\n    ASSERT(snapshot_socket_.init(snapshot_ip, iface, snapshot_port,\n    /*is_listening*/ false) >= 0,\n           \"Unable to create snapshot mcast socket. error:\" +\n           std::string(std::strerror(errno)));\n  }\n```", "```cpp\n  void SnapshotSynthesizer::start() {\n    run_ = true;\n    ASSERT(Common::createAndStartThread(-1, \"Exchange/\n    SnapshotSynthesizer\", [this]() { run(); }) != nullptr,\n           \"Failed to start SnapshotSynthesizer thread.\");\n  }\n```", "```cpp\n  SnapshotSynthesizer::~SnapshotSynthesizer() {\n    stop();\n  }\n  void SnapshotSynthesizer::stop() {\n    run_ = false;\n  }\n```", "```cpp\n  auto SnapshotSynthesizer::addToSnapshot(const MDPMarketUpdate\n  *market_update) {\n    const auto &me_market_update = market_update->me_market_update_;\n    auto *orders = &ticker_orders_.at(me_market_update.ticker_id_);\n    switch (me_market_update.type_) {\n```", "```cpp\n      case MarketUpdateType::ADD: {\n        auto order = orders->at(me_market_update.order_id_);\n        ASSERT(order == nullptr, \"Received:\" + me_market_update.\n        toString() + \" but order already exists:\" + (order ? order-\n        >toString() : \"\"));\n        orders->at(me_market_update.order_id_) = order_pool_.\n        allocate(me_market_update);\n      }\n        break;\n```", "```cpp\n      case MarketUpdateType::MODIFY: {\n        auto order = orders->at(me_market_update.order_id_);\n        ASSERT(order != nullptr, \"Received:\" + me_market_update.\n        toString() + \" but order does not exist.\");\n        ASSERT(order->order_id_ == me_market_update.order_id_,\n        \"Expecting existing order to match new one.\");\n        ASSERT(order->side_ == me_market_update.side_, \"Expecting\n        existing order to match new one.\");\n        order->qty_ = me_market_update.qty_;\n        order->price_ = me_market_update.price_;\n      }\n        break;\n```", "```cpp\n      case MarketUpdateType::CANCEL: {\n        auto order = orders->at(me_market_update.order_id_);\n        ASSERT(order != nullptr, \"Received:\" + me_market_update.\n        toString() + \" but order does not exist.\");\n        ASSERT(order->order_id_ == me_market_update.order_id_,\n        \"Expecting existing order to match new one.\");\n        ASSERT(order->side_ == me_market_update.side_, \"Expecting\n        existing order to match new one.\");\n        order_pool_.deallocate(order);\n        orders->at(me_market_update.order_id_) = nullptr;\n      }\n        break;\n```", "```cpp\n      case MarketUpdateType::SNAPSHOT_START:\n      case MarketUpdateType::CLEAR:\n      case MarketUpdateType::SNAPSHOT_END:\n      case MarketUpdateType::TRADE:\n      case MarketUpdateType::INVALID:\n        break;\n    }\n    ASSERT(market_update->seq_num_ == last_inc_seq_num_ + 1, \"Expected\n    incremental seq_nums to increase.\");\n    last_inc_seq_num_ = market_update->seq_num_;\n  }\n```", "```cpp\n  auto SnapshotSynthesizer::publishSnapshot() {\n    size_t snapshot_size = 0;\n    const MDPMarketUpdate start_market_update{snapshot_size++,\n    {MarketUpdateType::SNAPSHOT_START, last_inc_seq_num_}};\n    logger_.log(\"%:% %() % %\\n\", __FILE__, __LINE__, __FUNCTION__,\n    getCurrentTimeStr(&time_str_), start_market_update.toString());\n    snapshot_socket_.send(&start_market_update,\n    sizeof(MDPMarketUpdate));\n```", "```cpp\n    for (size_t ticker_id = 0; ticker_id < ticker_orders_.size();\n    ++ticker_id) {\n      const auto &orders = ticker_orders_.at(ticker_id);\n      MEMarketUpdate me_market_update;\n      me_market_update.type_ = MarketUpdateType::CLEAR;\n      me_market_update.ticker_id_ = ticker_id;\n      const MDPMarketUpdate clear_market_update{snapshot_size++, me_\n      market_update};\n      logger_.log(\"%:% %() % %\\n\", __FILE__, __LINE__, __FUNCTION__,\n      getCurrentTimeStr(&time_str_), clear_market_update.toString());\n      snapshot_socket_.send(&clear_market_update,\n      sizeof(MDPMarketUpdate));\n```", "```cpp\n      for (const auto order: orders) {\n        if (order) {\n          const MDPMarketUpdate market_update{snapshot_size++, *order};\n          logger_.log(\"%:% %() % %\\n\", __FILE__, __LINE__, __\n          FUNCTION__, getCurrentTimeStr(&time_str_), market_update.\n          toString());\n          snapshot_socket_.send(&market_update, sizeof(MDPMarketUpdate));\n          snapshot_socket_.sendAndRecv();\n        }\n      }\n    }\n```", "```cpp\n    const MDPMarketUpdate end_market_update{snapshot_size++, {MarketUpdateType::SNAPSHOT_END, last_inc_seq_num_}};\n    logger_.log(\"%:% %() % %\\n\", __FILE__, __LINE__, __FUNCTION__,\n    getCurrentTimeStr(&time_str_), end_market_update.toString());\n    snapshot_socket_.send(&end_market_update,\n    sizeof(MDPMarketUpdate));\n    snapshot_socket_.sendAndRecv();\n    logger_.log(\"%:% %() % Published snapshot of % orders.\\n\",\n    __FILE__, __LINE__, __FUNCTION__, getCurrentTimeStr(&time_str_),\n    snapshot_size - 1);\n  }\n```", "```cpp\n  void SnapshotSynthesizer::run() {\n    logger_.log(\"%:% %() %\\n\", __FILE__, __LINE__, __FUNCTION__,\n    getCurrentTimeStr(&time_str_));\n    while (run_) {\n      for (auto market_update = snapshot_md_updates_->getNextToRead();\n      snapshot_md_updates_->size() && market_update; market_update =\n      snapshot_md_updates_->getNextToRead()) {\n        logger_.log(\"%:% %() % Processing %\\n\", __FILE__, __LINE__,\n        __FUNCTION__, getCurrentTimeStr(&time_str_),\n                    market_update->toString().c_str());\n        addToSnapshot(market_update);\n        snapshot_md_updates_->updateReadIndex();\n      }\n      if (getCurrentNanos() - last_snapshot_time_ > 60 * NANOS_TO_\n      SECS) {\n        last_snapshot_time_ = getCurrentNanos();\n        publishSnapshot();\n      }\n    }\n  }\n}\n```", "```cpp\n#include <csignal>\n#include \"matcher/matching_engine.h\"\n#include \"market_data/market_data_publisher.h\"\n#include \"order_server/order_server.h\"\nCommon::Logger *logger = nullptr;\nExchange::MatchingEngine *matching_engine = nullptr;\nExchange::MarketDataPublisher *market_data_publisher = nullptr;\nExchange::OrderServer *order_server = nullptr;\nvoid signal_handler(int) {\n  using namespace std::literals::chrono_literals;\n  std::this_thread::sleep_for(10s);\n  delete logger;\n  logger = nullptr;\n  delete matching_engine;\n  matching_engine = nullptr;\n  delete market_data_publisher;\n  market_data_publisher = nullptr;\n  delete order_server;\n  order_server = nullptr;\n  std::this_thread::sleep_for(10s);\n  exit(EXIT_SUCCESS);\n}\n```", "```cpp\nint main(int, char **) {\n  logger = new Common::Logger(\"exchange_main.log\");\n  std::signal(SIGINT, signal_handler);\n  const int sleep_time = 100 * 1000;\n  Exchange::ClientRequestLFQueue client_requests(ME_MAX_CLIENT_\n  UPDATES);\n  Exchange::ClientResponseLFQueue client_responses(ME_MAX_CLIENT_\n  UPDATES);\n  Exchange::MEMarketUpdateLFQueue market_updates(ME_MAX_MARKET_\n  UPDATES);\n```", "```cpp\n  std::string time_str;\n  logger->log(\"%:% %() % Starting Matching Engine...\\n\", __FILE__, __\n  LINE__, __FUNCTION__, Common::getCurrentTimeStr(&time_str));\n  matching_engine = new Exchange::MatchingEngine(&client_requests,\n  &client_responses, &market_updates);\n  matching_engine->start();\n```", "```cpp\n  const std::string mkt_pub_iface = \"lo\";\n  const std::string snap_pub_ip = \"233.252.14.1\", inc_pub_ip =\n  \"233.252.14.3\";\n  const int snap_pub_port = 20000, inc_pub_port = 20001;\n  logger->log(\"%:% %() % Starting Market Data Publisher...\\n\", __\n  FILE__, __LINE__, __FUNCTION__, Common::getCurrentTimeStr(&time_\n  str));\n  market_data_publisher = new Exchange::MarketDataPublisher(&market_\n  updates, mkt_pub_iface, snap_pub_ip, snap_pub_port, inc_pub_ip, inc_\n  pub_port);\n  market_data_publisher->start();\n```", "```cpp\n  const std::string order_gw_iface = \"lo\";\n  const int order_gw_port = 12345;\n  logger->log(\"%:% %() % Starting Order Server...\\n\", __FILE__, __\n  LINE__, __FUNCTION__, Common::getCurrentTimeStr(&time_str));\n  order_server = new Exchange::OrderServer(&client_requests, &client_\n  responses, order_gw_iface, order_gw_port);\n  order_server->start();\n```", "```cpp\n  while (true) {\n    logger->log(\"%:% %() % Sleeping for a few milliseconds..\\n\", __\n    FILE__, __LINE__, __FUNCTION__, Common::getCurrentTimeStr(&time_\n    str));\n    usleep(sleep_time * 1000);\n  }\n}\n```", "```cpp\n(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter7$ ./cmake-build-release/exchange_main\nSet core affinity for Common/Logger exchange_main.log 140329423955712 to -1\nSet core affinity for Common/Logger exchange_matching_engine.log 140329253541632 to -1\nSet core affinity for Exchange/MatchingEngine 140329245148928 to –1\n...\nSun Mar 26 13:58:04 2023 Flushing and closing Logger for exchange_order_server.log\nSun Mar 26 13:58:04 2023 Logger for exchange_order_server.log exiting.\n```", "```cpp\n(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter7$ tail -n 10 *.log\n```", "```cpp\n==> exchange_main.log <==\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/exchange_main.cpp:43 main() Sun Mar 26 09:13:49 2023 Starting Matching Engine...\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/exchange_main.cpp:51 main() Sun Mar 26 09:13:51 2023 Starting Market Data Publisher...\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/exchange_main.cpp:58 main() Sun Mar 26 09:13:56 2023 Starting Order Server...\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/exchange_main.cpp:63 main() Sun Mar 26 09:13:58 2023 Sleeping for a few milliseconds..\n```", "```cpp\n==> exchange_market_data_publisher.log <==\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/common/socket_utils.cpp:68 createSocket() Sun Mar 26 09:13:52 2023 ip:233.252.14.3 iface:lo port:20001 is_udp:1 is_blocking:0 is_listening:0 ttl:32 SO_time:0\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/market_data/market_data_publisher.cpp:15 run() Sun Mar 26 09:13:54 2023\n```", "```cpp\n==> exchange_matching_engine.log <==\n                          X\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/matcher/me_order_book.cpp:12 ~MEOrderBook() Sun Mar 26 09:15:00 2023 OrderBook\nTicker:7\n                          X\n```", "```cpp\n==> exchange_order_server.log <==\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/common/socket_utils.cpp:68 createSocket() Sun Mar 26 09:13:57 2023 ip:127.0.0.1 iface:lo port:12345 is_udp:0 is_blocking:0 is_listening:1 ttl:0 SO_time:1\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/order_server/order_server.h:25 run() Sun Mar 26 09:13:57 2023\n```", "```cpp\n==> exchange_snapshot_synthesizer.log <==\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/market_data/snapshot_synthesizer.cpp:82 publishSnapshot() Sun Mar 26 09:14:55 2023 MDPMarketUpdate [ seq:2 MEMarketUpdate [ type:CLEAR ticker:1 oid:INVALID side:INVALID qty:INVALID price:INVALID priority:INVALID]]\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/market_data/snapshot_synthesizer.cpp:82 publishSnapshot() Sun Mar 26 09:14:55 2023 MDPMarketUpdate [ seq:3 MEMarketUpdate [ type:CLEAR ticker:2 oid:INVALID side:INVALID qty:INVALID price:INVALID priority:INVALID]]\n...\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/market_data/snapshot_synthesizer.cpp:96 publishSnapshot() Sun Mar 26 09:14:55 2023 MDPMarketUpdate [ seq:9 MEMarketUpdate [ type:SNAPSHOT_END ticker:INVALID oid:0 side:INVALID qty:INVALID price:INVALID priority:INVALID]]\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter7/exchange/market_data/snapshot_synthesizer.cpp:100 publishSnapshot() Sun Mar 26 09:14:55 2023 Published snapshot of 9 orders.\n```"]