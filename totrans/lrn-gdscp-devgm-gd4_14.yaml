- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Programming Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although computer science as a scientific field is pretty new, being less than
    80 years old, many smart people have studied it. This means that most programming
    problems have already been encountered in one way or another. These are problems
    such as how to connect parts of a program without them being hardwired or how
    to create and destroy thousands of objects, such as bullets for example, without
    slowing down a game.
  prefs: []
  type: TYPE_NORMAL
- en: These smart people, often called software architects, came up with smart solutions
    that solve these problems in an elegant manner. Then, they realized that they
    could generalize these solutions into a sort of recipe, a template that others
    could use too. This is what we call a programming pattern. In this chapter, we’ll
    learn what programming patterns are exactly and have a look at the three most
    used patterns in game development.
  prefs: []
  type: TYPE_NORMAL
- en: The bigger your vocabulary of programming patterns, the easier it will be for
    you to solve your own problems and communicate your ideas to others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of programming patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Event Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object Pooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State Machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with every chapter, you can find the final code on the GitHub repository
    in the subfolder for this chapter: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code required for implementing Object Pooling in our game
    here: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14-objectpool](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14-objectpool).'
  prefs: []
  type: TYPE_NORMAL
- en: What are programming patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ll be honest – we are not the first people to create games, or to write software
    for that matter. But this is actually a good thing; it means that many others
    before us encountered the same problems that we might have too. They thought up
    solutions to these problems in one way or another, and we can now make use of
    these solutions in our own games and software.
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming patterns**, or software design patterns, are descriptions or
    templates that tell us how we can solve certain problems while programming. They
    are not completely implemented solutions; they just give us directions on how
    we could tackle whatever we are trying to solve. A programming pattern tells us
    how we can organize our code for different outcomes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To express these patterns, there are different parts that are important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The name**: How the pattern is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The problem**: What the pattern is trying to solve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The solution**: How the pattern will work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than just providing a solution, programming patterns also give us a means
    to talk about our software. Communicating what we did can be hard when, as in
    software development, every problem can be tackled in a multitude of different
    ways. Design patterns give us a way of talking about the solution without going
    too deep into the actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if we structure our code according to one or multiple patterns, we know
    what to expect. We know how the code will react to new changes and communicate
    to other parts of a program. This helps us to understand how we can make changes,
    be it solving a bug, adding new functionality, or rewriting old code.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting old code
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will find that the way you solved a problem is not fast, extensible,
    or sufficient enough. At this point, you can choose to rewrite some code. We call
    this refactoring code.
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, anything can be a pattern, and you could have been using
    an existing pattern, even if you didn’t realize it.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is not as simple as picking any pattern and forcing it into our
    game’s code. We should carefully consider whether to use one pattern or another.
    When we use a certain pattern that is ill-fitting for the problem we are trying
    to solve and actually makes our software worse, we call that an **anti-pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: In the interest of not overextending this chapter, the code examples will function
    more as an introduction and demonstration of how a pattern can be used. We will
    not implement all the patterns in our game as this would require too much text
    for some. The real goal of this chapter is to make you aware of the most useful
    programming patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started with our first pattern – the Event Bus.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Event Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first programming pattern we’ll look at is the **Event Bus**. It will help
    us to decouple code, meaning that two pieces of code don’t need to rely on each
    other too much while still being able to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at what problem the Event Bus pattern tries to solve.
  prefs: []
  type: TYPE_NORMAL
- en: The problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we decouple different classes and parts of our code, they are easier to reuse
    later on. We did this earlier, in [*Chapter 9*](B19358_09.xhtml#_idTextAnchor590)
    for example, with the signals that we can connect provided by Godot Engine. The
    piece of code that publishes the signal does not care about who is listening or
    wants to receive that signal.
  prefs: []
  type: TYPE_NORMAL
- en: But signals only work very locally, and using them globally can turn out to
    be a challenge. The classic example is an achievement system. Achievements are
    little rewards that a player gets when accomplishing certain tasks within a game.
    These could even be linked to external achievement systems like the ones from
    Steam or PlayStation Network. The tasks necessary to unlock these achievements
    are often bound to very different systems within the game – “*defeat the end boss,*”
    “*jump 250 times,*” “*play backwards for 2 minutes,*” and so on. Because of this
    variation in different achievements, the achievement system needs to get information
    from many different parts of the code. However, we don’t want to access the achievement
    system directly from within the code of each system or vice versa, as this would
    create a hard dependency for the achievement system to be present at all times.
    On the Nintendo Switch, for example, there is no achievement system, so all of
    this achievement code would be useless.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what kind of problem we are trying to solve, let’s dive into
    the solution that is the Event Bus.
  prefs: []
  type: TYPE_NORMAL
- en: The solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is where the Event Bus pattern comes in. It’s a class we autoload, where
    other pieces of code can subscribe to or publish events. The basic structure looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The basic structure of how the Event Bus works](img/B19358_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – The basic structure of how the Event Bus works
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very similar to signals, but this time on a global scale. Let’s look
    at a very simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Add this previous script to the project’s autoloads, as we did for the highscore
    manager in [*Chapter 10*](B19358_10.xhtml#_idTextAnchor632), so that we can access
    it globally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume a very simplistic example of a boss fight, where we have one node
    that has a script that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: extends Node
  prefs: []
  type: TYPE_NORMAL
- en: 'func _ready():'
  prefs: []
  type: TYPE_NORMAL
- en: EventBus.subscribe("killed_boss", on_boss_killed)
  prefs: []
  type: TYPE_NORMAL
- en: 'func on_boss_killed():'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Achievement Unlocked: Kill the Boss")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You're fighting the boss!
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: You're fighting the boss!
  prefs: []
  type: TYPE_NORMAL
- en: The boss dies x.x
  prefs: []
  type: TYPE_NORMAL
- en: 'Achievement Unlocked: Kill the Boss'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: class_name ObjectPool extends Object
  prefs: []
  type: TYPE_NORMAL
- en: 'var _pool: Array'
  prefs: []
  type: TYPE_NORMAL
- en: 'func _init(scene: PackedScene, pool_size: int, root_node: Node):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for _i in pool_size:'
  prefs: []
  type: TYPE_NORMAL
- en: 'var new_node: Node = scene.instantiate()'
  prefs: []
  type: TYPE_NORMAL
- en: _pool.append(new_node)
  prefs: []
  type: TYPE_NORMAL
- en: new_node.died.connect(kill_node.bind(new_node))
  prefs: []
  type: TYPE_NORMAL
- en: root_node.add_child(new_node)
  prefs: []
  type: TYPE_NORMAL
- en: 'func kill_node(node: Node):'
  prefs: []
  type: TYPE_NORMAL
- en: node.set_dead()
  prefs: []
  type: TYPE_NORMAL
- en: _pool.append(node)
  prefs: []
  type: TYPE_NORMAL
- en: 'func get_dead_node() -> Node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if _pool.is_empty():'
  prefs: []
  type: TYPE_NORMAL
- en: return null
  prefs: []
  type: TYPE_NORMAL
- en: 'var node: Node = _pool.pop_back()'
  prefs: []
  type: TYPE_NORMAL
- en: node.set_alive()
  prefs: []
  type: TYPE_NORMAL
- en: return node
  prefs: []
  type: TYPE_NORMAL
- en: 'func free_nodes():'
  prefs: []
  type: TYPE_NORMAL
- en: 'for node in _pool:'
  prefs: []
  type: TYPE_NORMAL
- en: node.queue_free()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: signal died
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func set_alive():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if multiplayer.is_server():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set_physics_process(true)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _enemy_detection_area.monitoring = true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: show()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'func set_dead():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set_physics_process(false)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _enemy_detection_area.set_deferred("monitoring", false)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hide()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _ready():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set_dead()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _physics_process(delta: float):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not is_instance_valid(target):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: died.emit()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# Rest of _physics_process'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'func _on_enemy_detection_area_body_entered(body: Node2D) -> void:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: body.get_hit()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'main.gd script to have an Object Pool of projectiles.At the top, add a `projectile_pool`
    variable and preload the `projectile.tscn` scene:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Func _ready():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# ...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if multiplayer.is_server():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# Code for server setup'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '_exit_tree() function of the main script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _on_shoot_timer_timeout():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# Shooting code to select a target enemy'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var new_projectile: Projectile = get_parent().projectile_pool.get_dead_node()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if new_ projectile:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: new_projectile.target = closest_enemy
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: new_projectile.position = global_position
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: class_name StateMachine extends Node
  prefs: []
  type: TYPE_NORMAL
- en: '@export var starting_state: String'
  prefs: []
  type: TYPE_NORMAL
- en: 'var states: Dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: 'var current_state: State'
  prefs: []
  type: TYPE_NORMAL
- en: 'func _ready():'
  prefs: []
  type: TYPE_NORMAL
- en: 'for child in get_children():'
  prefs: []
  type: TYPE_NORMAL
- en: states[child.name] = child
  prefs: []
  type: TYPE_NORMAL
- en: child.state_machine = self
  prefs: []
  type: TYPE_NORMAL
- en: 'if not starting_state.is_empty:'
  prefs: []
  type: TYPE_NORMAL
- en: transition_to(starting_state)
  prefs: []
  type: TYPE_NORMAL
- en: 'func transition(state_name: String):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if current_state:'
  prefs: []
  type: TYPE_NORMAL
- en: current_state.exit()
  prefs: []
  type: TYPE_NORMAL
- en: current_state = states[state_name]
  prefs: []
  type: TYPE_NORMAL
- en: current_state.enter()
  prefs: []
  type: TYPE_NORMAL
- en: 'func _physics_process(delta: float):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not current_state: return'
  prefs: []
  type: TYPE_NORMAL
- en: current_state.process(delta)
  prefs: []
  type: TYPE_NORMAL
- en: 'func _input(event: InputEvent):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not current_state: return'
  prefs: []
  type: TYPE_NORMAL
- en: current_state.input(event)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: class_name State extends Node
  prefs: []
  type: TYPE_NORMAL
- en: 'var _state_machine: StateMachine'
  prefs: []
  type: TYPE_NORMAL
- en: 'func enter():'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: 'func exit():'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: 'func process(delta: float):'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: 'func input(event: InputEvent):'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: extends State
  prefs: []
  type: TYPE_NORMAL
- en: 'var _player: Player = owner'
  prefs: []
  type: TYPE_NORMAL
- en: '@export var max_speed: float = 500.0'
  prefs: []
  type: TYPE_NORMAL
- en: '@export var acceleration: float = 2500.0'
  prefs: []
  type: TYPE_NORMAL
- en: '@export var deceleration: float = 1500.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'func process(delta: float):'
  prefs: []
  type: TYPE_NORMAL
- en: 'var input_direction: Vector2 = Input.get_vector("move_left", "move_right",
    "move_up", "move_down")'
  prefs: []
  type: TYPE_NORMAL
- en: 'if input_direction != Vector2.ZERO:'
  prefs: []
  type: TYPE_NORMAL
- en: _player.velocity = _player.velocity.move_toward(input_direction * max_speed,
    acceleration * delta)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: _player.velocity = _player.velocity.move_toward(Vector2.ZERO, deceleration *
    delta)
  prefs: []
  type: TYPE_NORMAL
- en: _player.move_and_slide()
  prefs: []
  type: TYPE_NORMAL
- en: 'func input(event: InputEvent):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.is_action_pressed("jump"):'
  prefs: []
  type: TYPE_NORMAL
- en: _state_machine.transition("Jump")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'func unsubscribe(event_name: String, callback: Callable):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# Your code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
