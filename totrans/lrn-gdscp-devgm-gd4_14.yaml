- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Advanced Programming Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级编程模式
- en: Although computer science as a scientific field is pretty new, being less than
    80 years old, many smart people have studied it. This means that most programming
    problems have already been encountered in one way or another. These are problems
    such as how to connect parts of a program without them being hardwired or how
    to create and destroy thousands of objects, such as bullets for example, without
    slowing down a game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然计算机科学作为一个科学领域相对较新，不到80年历史，但许多聪明的人已经研究过它。这意味着大多数编程问题已经在某种程度上被遇到。这些问题包括如何在不硬编码的情况下连接程序的一部分，或者如何创建和销毁成千上万的对象，例如子弹，而不会减慢游戏速度。
- en: These smart people, often called software architects, came up with smart solutions
    that solve these problems in an elegant manner. Then, they realized that they
    could generalize these solutions into a sort of recipe, a template that others
    could use too. This is what we call a programming pattern. In this chapter, we’ll
    learn what programming patterns are exactly and have a look at the three most
    used patterns in game development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些聪明人，通常被称为软件架构师，提出了聪明的解决方案，以优雅的方式解决了这些问题。然后，他们意识到他们可以将这些解决方案概括成一种食谱，一种模板，其他人也可以使用。这就是我们所说的编程模式。在本章中，我们将学习编程模式究竟是什么，并查看游戏开发中最常用的三种模式。
- en: The bigger your vocabulary of programming patterns, the easier it will be for
    you to solve your own problems and communicate your ideas to others.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编程模式词汇量越大，你解决自己问题的能力就越强，向他人传达你的想法也就越容易。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: The basics of programming patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程模式的基础
- en: The Event Bus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件总线
- en: Object Pooling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象池
- en: State Machines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态机
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with every chapter, you can find the final code on the GitHub repository
    in the subfolder for this chapter: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与每一章一样，您可以在GitHub仓库的子文件夹中找到本章的最终代码：[https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14).
- en: 'You can find the code required for implementing Object Pooling in our game
    here: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14-objectpool](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14-objectpool).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们游戏中实现对象池所需的代码在这里找到：[https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14-objectpool](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14-objectpool).
- en: What are programming patterns?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是编程模式？
- en: I’ll be honest – we are not the first people to create games, or to write software
    for that matter. But this is actually a good thing; it means that many others
    before us encountered the same problems that we might have too. They thought up
    solutions to these problems in one way or another, and we can now make use of
    these solutions in our own games and software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我得坦白——我们并不是第一个创造游戏的人，或者更确切地说，并不是第一个编写软件的人。但事实上，这是一个好事；这意味着在我们之前，许多人已经遇到了我们可能遇到的问题。他们以某种方式想出了这些问题的解决方案，现在我们可以将这些解决方案用于我们自己的游戏和软件中。
- en: '**Programming patterns**, or software design patterns, are descriptions or
    templates that tell us how we can solve certain problems while programming. They
    are not completely implemented solutions; they just give us directions on how
    we could tackle whatever we are trying to solve. A programming pattern tells us
    how we can organize our code for different outcomes.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**编程模式**，或软件设计模式，是描述或模板，告诉我们如何在编程时解决某些问题。它们不是完全实现的解决方案；它们只是给我们提供了如何应对我们试图解决的问题的指导。编程模式告诉我们如何组织我们的代码以实现不同的结果。'
- en: 'To express these patterns, there are different parts that are important:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表达这些模式，有一些重要的部分：
- en: '**The name**: How the pattern is called.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：这个模式是如何被称呼的。'
- en: '**The problem**: What the pattern is trying to solve.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：这个模式试图解决什么。'
- en: '**The solution**: How the pattern will work.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：这个模式将如何工作。'
- en: Other than just providing a solution, programming patterns also give us a means
    to talk about our software. Communicating what we did can be hard when, as in
    software development, every problem can be tackled in a multitude of different
    ways. Design patterns give us a way of talking about the solution without going
    too deep into the actual implementation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供解决方案之外，编程模式还给我们提供了谈论我们软件的手段。当像软件开发一样，每个问题都可以用多种不同的方式解决时，沟通我们所做的工作可能会很困难。设计模式给我们提供了一种谈论解决方案的方式，而无需深入到实际的实现中。
- en: Lastly, if we structure our code according to one or multiple patterns, we know
    what to expect. We know how the code will react to new changes and communicate
    to other parts of a program. This helps us to understand how we can make changes,
    be it solving a bug, adding new functionality, or rewriting old code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们根据一个或多个模式来组织我们的代码，我们就知道可以期待什么。我们知道代码将如何对新变化做出反应，以及如何与其他程序的各个部分进行通信。这有助于我们理解我们如何进行更改，无论是解决一个错误、添加新功能还是重构旧代码。
- en: Rewriting old code
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重构旧代码
- en: Sometimes, you will find that the way you solved a problem is not fast, extensible,
    or sufficient enough. At this point, you can choose to rewrite some code. We call
    this refactoring code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你会发现你解决问题的方法可能不够快，不够可扩展，或者不足以满足需求。在这种情况下，你可以选择重写一些代码。我们称之为重构代码。
- en: Believe it or not, anything can be a pattern, and you could have been using
    an existing pattern, even if you didn’t realize it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，任何事物都可以是一个模式，即使你没有意识到，你可能已经在使用现有的模式了。
- en: However, it is not as simple as picking any pattern and forcing it into our
    game’s code. We should carefully consider whether to use one pattern or another.
    When we use a certain pattern that is ill-fitting for the problem we are trying
    to solve and actually makes our software worse, we call that an **anti-pattern**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不像挑选任何模式并将其强制应用到我们的游戏代码中那么简单。我们应该仔细考虑是否使用某种模式。当我们使用某种不适合我们试图解决的问题的模式，并且实际上使我们的软件变得更差时，我们称之为**反模式**。
- en: In the interest of not overextending this chapter, the code examples will function
    more as an introduction and demonstration of how a pattern can be used. We will
    not implement all the patterns in our game as this would require too much text
    for some. The real goal of this chapter is to make you aware of the most useful
    programming patterns.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不使本章内容过于冗长，代码示例将更多地作为介绍和演示如何使用模式。我们不会在我们的游戏中实现所有模式，因为这需要太多的文字。本章的真正目标是让你意识到最有用的编程模式。
- en: Let’s get started with our first pattern – the Event Bus.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的第一个模式——事件总线。
- en: Exploring the Event Bus
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索事件总线
- en: The first programming pattern we’ll look at is the **Event Bus**. It will help
    us to decouple code, meaning that two pieces of code don’t need to rely on each
    other too much while still being able to communicate.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的第一个编程模式是**事件总线**。它将帮助我们解耦代码，这意味着两段代码不需要过度依赖对方，同时仍然能够进行通信。
- en: Let’s take a look at what problem the Event Bus pattern tries to solve.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看事件总线模式试图解决的问题是什么。
- en: The problem
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: If we decouple different classes and parts of our code, they are easier to reuse
    later on. We did this earlier, in [*Chapter 9*](B19358_09.xhtml#_idTextAnchor590)
    for example, with the signals that we can connect provided by Godot Engine. The
    piece of code that publishes the signal does not care about who is listening or
    wants to receive that signal.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将代码的不同类和部分解耦，它们在以后重用时会更容易。例如，我们在[*第9章*](B19358_09.xhtml#_idTextAnchor590)中就做了这件事，使用了Godot引擎提供的可连接的信号。发布信号的代码并不关心谁在监听或者谁想要接收这个信号。
- en: But signals only work very locally, and using them globally can turn out to
    be a challenge. The classic example is an achievement system. Achievements are
    little rewards that a player gets when accomplishing certain tasks within a game.
    These could even be linked to external achievement systems like the ones from
    Steam or PlayStation Network. The tasks necessary to unlock these achievements
    are often bound to very different systems within the game – “*defeat the end boss,*”
    “*jump 250 times,*” “*play backwards for 2 minutes,*” and so on. Because of this
    variation in different achievements, the achievement system needs to get information
    from many different parts of the code. However, we don’t want to access the achievement
    system directly from within the code of each system or vice versa, as this would
    create a hard dependency for the achievement system to be present at all times.
    On the Nintendo Switch, for example, there is no achievement system, so all of
    this achievement code would be useless.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但信号只能在非常局部的地方工作，而全球范围内使用它们可能会成为一个挑战。一个经典的例子是成就系统。成就是一些玩家在游戏中完成某些任务后获得的微小奖励。这些甚至可以与Steam或PlayStation
    Network等外部成就系统相链接。解锁这些成就所需的任务通常与游戏中的非常不同的系统相关联——“*击败最终Boss,*” “*跳250次,*” “*倒放2分钟,*”等等。由于不同成就的这种变化，成就系统需要从代码的许多不同部分获取信息。然而，我们不想直接从每个系统的代码中访问成就系统，反之亦然，因为这会为成就系统创建一个硬依赖，使得成就系统必须始终存在。例如，在Nintendo
    Switch上，就没有成就系统，所以所有这些成就代码都将毫无用处。
- en: Now that we know what kind of problem we are trying to solve, let’s dive into
    the solution that is the Event Bus.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了我们正在试图解决的问题类型，让我们深入探讨解决方案，即事件总线。
- en: The solution
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is where the Event Bus pattern comes in. It’s a class we autoload, where
    other pieces of code can subscribe to or publish events. The basic structure looks
    like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事件总线模式发挥作用的地方。它是一个我们自动加载的类，其他代码片段可以订阅或发布事件。基本结构看起来像这样：
- en: '![Figure 14.1 – The basic structure of how the Event Bus works](img/B19358_14_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 事件总线的基本结构](img/B19358_14_01.jpg)'
- en: Figure 14.1 – The basic structure of how the Event Bus works
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 事件总线的基本结构
- en: 'It is very similar to signals, but this time on a global scale. Let’s look
    at a very simple example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这与信号非常相似，但这次是在全球范围内。让我们看看一个非常简单的例子：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Add this previous script to the project’s autoloads, as we did for the highscore
    manager in [*Chapter 10*](B19358_10.xhtml#_idTextAnchor632), so that we can access
    it globally.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本添加到项目的自动加载中，就像我们在[*第10章*](B19358_10.xhtml#_idTextAnchor632)中为高分管理器所做的那样，这样我们就可以全局访问它。
- en: 'Let’s assume a very simplistic example of a boss fight, where we have one node
    that has a script that looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个非常简单的Boss战例子，其中我们有一个节点，它的脚本看起来像这样：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: extends Node
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: extends Node
- en: 'func _ready():'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: EventBus.subscribe("killed_boss", on_boss_killed)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: EventBus.subscribe("killed_boss", on_boss_killed)
- en: 'func on_boss_killed():'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'func on_boss_killed():'
- en: 'print("Achievement Unlocked: Kill the Boss")'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: print("成就解锁：击败Boss")
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You're fighting the boss!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在与Boss战斗！
- en: '...'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: You're fighting the boss!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在与Boss战斗！
- en: The boss dies x.x
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 老大已死 x.x
- en: 'Achievement Unlocked: Kill the Boss'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 成就解锁：击败Boss
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: class_name ObjectPool extends Object
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: class_name ObjectPool extends Object
- en: 'var _pool: Array'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'var _pool: Array'
- en: 'func _init(scene: PackedScene, pool_size: int, root_node: Node):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'func _init(scene: PackedScene, pool_size: int, root_node: Node):'
- en: 'for _i in pool_size:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'for _i in pool_size:'
- en: 'var new_node: Node = scene.instantiate()'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'var new_node: Node = scene.instantiate()'
- en: _pool.append(new_node)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: _pool.append(new_node)
- en: new_node.died.connect(kill_node.bind(new_node))
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: new_node.died.connect(kill_node.bind(new_node))
- en: root_node.add_child(new_node)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: root_node.add_child(new_node)
- en: 'func kill_node(node: Node):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'func kill_node(node: Node):'
- en: node.set_dead()
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: node.set_dead()
- en: _pool.append(node)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: _pool.append(node)
- en: 'func get_dead_node() -> Node:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'func get_dead_node() -> Node:'
- en: 'if _pool.is_empty():'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'if _pool.is_empty():'
- en: return null
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: return null
- en: 'var node: Node = _pool.pop_back()'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'var node: Node = _pool.pop_back()'
- en: node.set_alive()
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: node.set_alive()
- en: return node
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: return node
- en: 'func free_nodes():'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'func free_nodes():'
- en: 'for node in _pool:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'for node in _pool:'
- en: node.queue_free()
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: node.queue_free()
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: signal died
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信号已消失
- en: '[PRE5]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'func set_alive():'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func set_alive():'
- en: 'if multiplayer.is_server():'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if multiplayer.is_server():'
- en: set_physics_process(true)
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set_physics_process(true)
- en: _enemy_detection_area.monitoring = true
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _enemy_detection_area.monitoring = true
- en: show()
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: show()
- en: 'func set_dead():'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func set_dead():'
- en: set_physics_process(false)
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set_physics_process(false)
- en: _enemy_detection_area.set_deferred("monitoring", false)
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _enemy_detection_area.set_deferred("monitoring", false)
- en: hide()
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: hide()
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'func _ready():'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: set_dead()
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set_dead()
- en: '[PRE7]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'func _physics_process(delta: float):'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _physics_process(delta: float):'
- en: 'if not is_instance_valid(target):'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if not is_instance_valid(target):'
- en: died.emit()
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: died.emit()
- en: return
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return
- en: '# Rest of _physics_process'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# Rest of _physics_process'
- en: 'func _on_enemy_detection_area_body_entered(body: Node2D) -> void:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _on_enemy_detection_area_body_entered(body: Node2D) -> void:'
- en: body.get_hit()
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: body.get_hit()
- en: 'main.gd script to have an Object Pool of projectiles.At the top, add a `projectile_pool`
    variable and preload the `projectile.tscn` scene:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'main.gd script to have an Object Pool of projectiles.At the top, add a `projectile_pool`
    variable and preload the `projectile.tscn` scene:'
- en: '[PRE8]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Func _ready():'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Func _ready():'
- en: '# ...'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# ...'
- en: 'if multiplayer.is_server():'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if multiplayer.is_server():'
- en: '# Code for server setup'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# Code for server setup'
- en: '_exit_tree() function of the main script:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '_exit_tree() function of the main script:'
- en: '[PRE10]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'func _on_shoot_timer_timeout():'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _on_shoot_timer_timeout():'
- en: '# Shooting code to select a target enemy'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# Shooting code to select a target enemy'
- en: 'var new_projectile: Projectile = get_parent().projectile_pool.get_dead_node()'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var new_projectile: Projectile = get_parent().projectile_pool.get_dead_node()'
- en: 'if new_ projectile:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if new_ projectile:'
- en: new_projectile.target = closest_enemy
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: new_projectile.target = closest_enemy
- en: new_projectile.position = global_position
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: new_projectile.position = global_position
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: class_name StateMachine extends Node
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: class_name StateMachine extends Node
- en: '@export var starting_state: String'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '@export var starting_state: String'
- en: 'var states: Dictionary'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'var states: Dictionary'
- en: 'var current_state: State'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'var current_state: State'
- en: 'func _ready():'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: 'for child in get_children():'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 'for child in get_children():'
- en: states[child.name] = child
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: states[child.name] = child
- en: child.state_machine = self
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: child.state_machine = self
- en: 'if not starting_state.is_empty:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not starting_state.is_empty:'
- en: transition_to(starting_state)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: transition_to(starting_state)
- en: 'func transition(state_name: String):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 'func transition(state_name: String):'
- en: 'if current_state:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'if current_state:'
- en: current_state.exit()
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: current_state.exit()
- en: current_state = states[state_name]
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: current_state = states[state_name]
- en: current_state.enter()
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: current_state.enter()
- en: 'func _physics_process(delta: float):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'func _physics_process(delta: float):'
- en: 'if not current_state: return'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not current_state: return'
- en: current_state.process(delta)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: current_state.process(delta)
- en: 'func _input(event: InputEvent):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'func _input(event: InputEvent):'
- en: 'if not current_state: return'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not current_state: return'
- en: current_state.input(event)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: current_state.input(event)
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: class_name State extends Node
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: class_name State extends Node
- en: 'var _state_machine: StateMachine'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'var _state_machine: StateMachine'
- en: 'func enter():'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'func enter():'
- en: pass
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'func exit():'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'func exit():'
- en: pass
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'func process(delta: float):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'func process(delta: float):'
- en: pass
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'func input(event: InputEvent):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'func input(event: InputEvent):'
- en: pass
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: extends State
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: extends State
- en: 'var _player: Player = owner'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'var _player: Player = owner'
- en: '@export var max_speed: float = 500.0'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '@export var max_speed: float = 500.0'
- en: '@export var acceleration: float = 2500.0'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '@export var acceleration: float = 2500.0'
- en: '@export var deceleration: float = 1500.0'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '@export var deceleration: float = 1500.0'
- en: 'func process(delta: float):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'func process(delta: float):'
- en: 'var input_direction: Vector2 = Input.get_vector("move_left", "move_right",
    "move_up", "move_down")'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 'var input_direction: Vector2 = Input.get_vector("move_left", "move_right",
    "move_up", "move_down")'
- en: 'if input_direction != Vector2.ZERO:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'if input_direction != Vector2.ZERO:'
- en: _player.velocity = _player.velocity.move_toward(input_direction * max_speed,
    acceleration * delta)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: _player.velocity = _player.velocity.move_toward(input_direction * max_speed,
    acceleration * delta)
- en: 'else:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: _player.velocity = _player.velocity.move_toward(Vector2.ZERO, deceleration *
    delta)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: _player.velocity = _player.velocity.move_toward(Vector2.ZERO, deceleration *
    delta)
- en: _player.move_and_slide()
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: _player.move_and_slide()
- en: 'func input(event: InputEvent):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'func input(event: InputEvent):'
- en: 'if event.is_action_pressed("jump"):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.is_action_pressed("jump"):'
- en: _state_machine.transition("Jump")
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: _state_machine.transition("Jump")
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'func unsubscribe(event_name: String, callback: Callable):'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func unsubscribe(event_name: String, callback: Callable):'
- en: '# Your code'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# Your code'
- en: '[PRE16]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
