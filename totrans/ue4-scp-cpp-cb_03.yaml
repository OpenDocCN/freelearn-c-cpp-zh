- en: Memory Management, Smart Pointers, and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Unmanaged memory – using malloc()/free()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unmanaged memory – using new/delete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed memory – using NewObject< > and ConstructObject< >
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed memory – de-allocating memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed memory – using smart pointers (TSharedPtr, TWeakPtr, TAutoPtr) to track
    an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TScopedPointer to track an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unreal's garbage collection system and UPROPERTY()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breakpoints and stepping through code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding bugs and using call stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the profiler to identify hot spots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory management is always one of the most important things to get right in
    your computer program to ensure stability and good, bug-free operation of your
    code. A dangling pointer (*pointer* referring to something that has been removed
    from memory) is an example of a bug that is hard to track if it occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In any computer program, memory management is extremely important. UE4's `UObject`
    reference-counting system is the default way that memory is managed for actors
    and classes derived from the `UObject` class. This is the default way that your
    memory will be managed within your UE4 program.
  prefs: []
  type: TYPE_NORMAL
- en: If you write custom C++ classes of your own, which do not derive from `UObject`,
    you may find the `TSharedPtr` / `TWeakPtr` reference-counted classes useful to
    use. These classes provide reference counting and automatic deletion for objects
    when they have no more references.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides recipes for memory management within UE4\. It also provides
    information on debugging your code through some of the useful features that Visual
    Studio includes for us, including breakpoints and the profiler.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Unmanaged memory – using malloc( ) / free( )
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic way to allocate memory to your computer program in C (which is still
    possible to use in C++) is by using the `malloc()` function. This function designates
    a block of the computer system's memory for your program's use. Once your program
    is using a segment of memory, no other program can use or access that segment
    of memory. An attempt to access a segment of memory not allocated to your program
    will generate a **segmentation fault**, and represents an illegal operation on
    most systems.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at some example code that allocates a pointer variable, `i`, then
    assigns memory to it using `malloc()`. We allocate a single integer behind an
    `int*` pointer. After allocation, we store a value inside `int`, using the dereferencing
    operator `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding code does what is shown in the diagram that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line creates an `int *` pointer variable, `i`, which starts as a dangling
    pointer referring to a segment of memory that probably won't be valid for your
    program to reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second step of the diagram, we use a `malloc()` call to initialize the
    variable `i` to point to a segment of memory precisely the size of an `int` variable,
    which will be valid for your program to refer to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then initialize the contents of that memory segment to the value `0` using
    the command `*i = 0;`. Refer to the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00340e70-51a4-4f85-916c-9e0a483211bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the difference between the assignment to a pointer variable (`i =`), which
    tells the pointer which memory address to refer to, and the assignment to what
    it is inside the memory address that the pointer variable refers to (`*i =`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the memory in the variable `i` needs to be released back to the system,
    we do so using a `free()` de-allocation call, as shown in the following diagram.
    `i` is then assigned to point to the memory address, `0`, shown in this diagram
    by the **electrical grounding** symbol reference, ![](img/97df6b03-e489-4edc-b53e-53668ce93f7f.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aeff3a49-d8d6-43af-965c-fda71b7d0499.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason we set the variable `i` to point to the `NULL` reference is to make
    it clear that the variable `i` does not refer to a valid segment of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Unmanaged memory – using new/delete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `new` operator is almost the same as a `malloc` call, except that it invokes
    a constructor call on the object created immediately after the memory is allocated.
    Objects allocated with the `new` operator should be de-allocated with the `delete` operator
    (and not `free()`).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++, use of `malloc()` was replaced as a best practice by use of the `new` operator.
    The main difference between the functionality of `malloc()` and the `new` operator
    is that `new` will call the constructor on object types after memory allocation.
    Refer to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `malloc` | Allocates a zone of contiguous space for use |'
  prefs: []
  type: TYPE_TB
- en: '| `new` | Allocates a zone of contiguous space for useCalls constructor as
    an object type used as an argument to the `new` operator. |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we declare a simple `Object` class, then construct an
    instance of it using the `new` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `new` operator works by allocating space just as `malloc()` does. If the
    type used with the `new` operator is an object type, the constructor is invoked
    automatically with the use of the `new` keyword, whereas the constructor is never
    invoked with the use of `malloc()`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should avoid using naked heap allocations with the `new` keyword (or `malloc`
    for that matter). Managed memory is preferred within the engine so that all memory
    use is tracked and clean. If you allocate a `UObject` derivative, you definitely
    need to use `NewObject< >` or `ConstructObject< >` (outlined in subsequent recipes).
  prefs: []
  type: TYPE_NORMAL
- en: Managed memory – using NewObject< > and ConstructObject< >
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Managed memory** refers to memory that is <indexentry content="managed memory:allocating,
    NewObject used">allocated and de-allocated by some programmed subsystem above
    the `new`, `delete`, `malloc,`, and `free` calls in C++. These subsystems are
    commonly created so that the programmer does not forget to release memory after
    allocating it. Unreleased, occupied, but unused memory chunks are called **memory
    leaks**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the memory allocated is not referenceable by any variable!
    So, you can neither use the allocated memory after the `for` loop, nor free it.
    If your program allocates all available system memory, then what will happen is
    that your system will run out of memory entirely, and your OS will flag your program
    and close it for using up too much memory.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management prevents forgetting to release memory. In memory-managed programs,
    it is commonly remembered by objects that are dynamically <indexentry content="managed
    memory:allocating, ConstructObject used">allocated the number of pointers referencing
    the object. When there are zero pointers referencing the object, it is either
    automatically deleted immediately, or flagged for deletion on the next run of
    the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: Use of managed memory is automatic within UE4\. Any allocation of an object
    to be
  prefs: []
  type: TYPE_NORMAL
- en: used within the engine must be done using the `NewObject< >()` or `SpawnActor<
    >()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The release of objects is done by removing the reference to the object and then
    occasionally calling the garbage cleanup routine (listed further in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to construct any `UObject` derivative that is not a derivative
    of the `Actor` class, you should always use the `NewObject< >` function. `SpawnActor<
    >` should be used only when the object is an `Actor` or its derivative.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we are trying to construct an object of a `UAction` type that itself
    derives from `UObject`—for example, the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To construct an instance of the `UAction` class, we''d do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, `UAction::StaticClass()` gets you a base `UClass *` for the `UAction`
    object. The first argument to `NewObject< >` is `GetTransientPackage()`, which
    simply retrieves the transient package for the game. A package (`UPackage`) in
    UE4 is just a data conglomerate. Here we use the **Transient Package** to store
    our heap-allocated data. You could also use `UPROPERTY() TSubclassOf<AActor>`
    from Blueprints to select a `UClass` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument (optional) is a combination of parameters that indicate how
    `UObject` is treated by the memory management system.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another function very similar to `NewObject< >` called `ConstructObject<
    >`. `ConstructObject< >` provides more parameters in construction, and you may
    find it useful if you need to initialize certain properties. Otherwise, `NewObject`
    works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about the ConstructObject function here: [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation#constructobject](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation#constructobject).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may also want to see the documentation for the `RF_*` flags at [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Objects/Creation/index.html#objectflags](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Objects/Creation/index.html#objectflags%20).
  prefs: []
  type: TYPE_NORMAL
- en: Managed memory – de-allocating memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UObject` instances are reference-counted and garbage-collected when there
    are no more references to the `UObject` instance. Memory allocated on a `UObject`
    class derivative using `ConstructObject<>` or `NewObject< >` can also be de-allocated
    manually (before the reference count drops to 0) by calling the `UObject::ConditionalBeginDestroy()`
    member function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'd only do this if you were sure you no longer wanted `UObject` or the `UObject`
    class derivative instance in memory. Use the `ConditionalBeginDestroy()` function
    to release memory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code demonstrates the de-allocation of an instance of the `UObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This concept also works with any class derived from the `UObject` class. So,
    for instance, if we wanted to do this with the `UAction` object we created in
    the previous recipe, we would add the bold text in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ConditionalBeginDestroy()` command begins the de-allocation process, calling
    the `BeginDestroy()` and `FinishDestroy()` overrideable functions.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to call `UObject::ConditionalBeginDestroy()` on any object still
    being referenced in memory by other objects' pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Managed memory – smart pointers (TSharedPtr, TWeakPtr, TAutoPtr) to track an
    object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When people are afraid that they''ll forget the `delete` call for standard
    C++ objects they create, they often use smart pointers to prevent memory leaks.
    `TSharedPtr` is a very useful C++ class that will make any custom C++ object reference-counted—with
    the exception of `UObject` derivatives, which are already reference-counted. An
    alternate class, `TWeakPtr`, is also provided for pointing to a reference-counted
    object with the strange property of being unable to prevent deletion (hence, *weak*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66139d96-b541-46d5-a16e-093e46d853fd.png)'
  prefs: []
  type: TYPE_IMG
- en: '`UObject` and its derivative classes (anything created with `NewObject` or `ConstructObject`)
    cannot use `TSharedPtr`!'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you don''t want to use raw pointers and manually track deletes into your
    C++ code that do not use `UObject` derivatives, then that code is a good candidate
    for using smart pointers such as `TSharedPtr`, `TSharedRef`, and the like. When
    you use a dynamically allocated object (created using the `new` keyword), you
    can wrap it up in a reference-counted pointer so that de-allocation happens automatically.
    The different types of smart pointers determine the smart pointer behavior and
    deletion call time. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TSharedPtr`: A thread-safe (provided you supplied `ESPMode::ThreadSafe` as
    the second argument to the template) reference-counted pointer type that indicates
    a shared object. The shared object will be de-allocated when there are no more
    references to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TAutoPtr`: A non-thread-safe shared pointer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can demonstrate the use of the four types of smart pointers referred to previously
    using a short code segment. In all of this code, the starting pointer can either
    be a raw pointer, or a copy of another smart pointer. All you have to do is take
    the C++ raw pointer and wrap it in a constructor call to any of the following: `TSharedPtr`,
    `TSharedRef`, `TWeakPtr,`, or `TAutoPtr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some differences between weak pointers and shared pointers. Weak pointers
    do not have the capability to keep the object in memory when the reference count
    drops to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using a weak pointer (over a raw pointer) is that, when the
    object underneath the weak pointer is manually deleted (using `ConditionalBeginDestroy()`),
    the weak pointer''s reference becomes a `NULL` reference. This enables you to
    check whether the resource underneath the pointer is still allocated properly
    by checking a statement of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shared pointers are thread-safe. This means that the underlying object can safely
    be manipulated on separate threads.
  prefs: []
  type: TYPE_NORMAL
- en: Always remember that you cannot use `TSharedRef` with `UObject`s or `UObject`
    derivatives; you can only use them on your custom C++ classes. Your `FStructures`
    can use the `TSharedPtr`, `TSharedRef`, and `TWeakPtr` classes to wrap up a raw
    pointer.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use smart pointers to point to an object, you must use `TWeakObjectPointer`
    or `UPROPERTY()`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `TAutoPtr` if you do not need the thread-safety guarantee of `TSharedPtr`.
    `TAutoPtr` will automatically delete an object when the number of references to
    it drops to 0.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in learning more about Unreal's smart pointers, check
    out [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/SmartPointerLibrary](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/SmartPointerLibrary).
  prefs: []
  type: TYPE_NORMAL
- en: Using TScopedPointer to track an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **scoped** pointer is a pointer that is auto-deleted at the end of the block
    in which it was declared. Recall that a scope is just a section of code during
    which a variable is *alive*. A scope will last until the first closing brace,
    `}`, that appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following block, we have two scopes. The outer scope declares
    an integer variable `x` (valid for the entire outer block), while the inner scope
    declares an integer variable `y` (valid for the inner block, after the line on
    which it is declared):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scoped pointers are useful when it is important that a reference-counted object
    (that is in danger of going out of scope) is retained for the duration of the
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To declare a scoped pointer, we simply use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This declares a scoped pointer referencing an object of the type declared within
    the angle brackets: `< AWarrior >`.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TScopedPointer` variable type automatically adds a reference count to the
    variable pointed to. This prevents the de-allocation of the underlying object
    for at least the life of the scoped pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal's garbage collection system and UPROPERTY( )
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have an object (such as `TArray< >`) as a `UPROPERTY()` member of `UCLASS()`,
    you need to declare that member as `UPROPERTY()` (even if you won't edit it in
    Blueprints); otherwise, `TArray` will not stay allocated properly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say we have a `UCLASS()` macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You'd have to list the `TArray` member as `UPROPERTY()` for it to be properly
    reference-counted. If you don't do so, you'll get an unexpected memory error-type
    bug sitting about in the code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UPROPERTY()` declaration tells UE4 that `TArray` must be properly memory-managed.
    Without the `UPROPERTY()` declaration, your `TArray` won't work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When memory fills up, and you want to free some of it, garbage collection can
    be forced. You seldom need to do this, but you can do it in the case of having
    a very large texture (or set of textures) that are reference-counted and that
    you need to clear.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply call `ConditionalBeginDestroy()` on all `UObject`s that you want de-allocated
    from memory, or set their reference counts to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Garbage collection is performed by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Breakpoints and stepping through code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Breakpoints** are how you pause your C++ program to temporarily stop the
    code from running, and have a chance to analyze and inspect your program''s operation.
    You can peer at variables, step through code, and change variable values.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Breakpoints are easy to set in Visual Studio. All you have to do is press *F9*
    on the line of code where you want the operation to pause, or click in the gray
    margin to the left of the line of code where you want the operation to pause.
    The code will pause when the operation reaches the line indicated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Press *F9* on the line where you want the execution to pause. This will add
    a breakpoint to the code, indicated by a red dot, as shown in the following screenshot.
    Clicking on the red dot toggles it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/491cbfc5-5a48-4baf-9391-1023a104c953.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set the Build Configuration to any of the configurations with Debug in the
    title (DebugGame Editor or simply DebugGame if you launch it without the editor):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7fb56b04-3359-4b04-bf33-f48dfb485aaa.png)'
  prefs: []
  type: TYPE_IMG
- en: Launch your code by pressing *F5* (without holding *Ctrl*), or select the Debug
    | Start Debugging menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the code reaches the red dot, the code's execution will pause.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The paused view will take you to the code editor in **Debug mode**. In this
    mode, the windows may appear re arranged, with Solution Explorer possibly moved
    to the right, and new windows appearing at the bottom, including Locals, Watch
    1, and Call Stack. If these windows do not appear, find them under the Debug |
    Windows submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check out your variables under the Locals window (Debug | Windows | Locals).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F10* to step over a line of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F11* to step into a line of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debuggers are powerful tools that allow you to see everything about your code
    as it is running, including variable states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stepping over a line of code (*F10*) executes the line of code in its entirety,
    and then pauses the program again, immediately, at the next line. If the line
    of code is a function call, then the function is executed without pausing at the
    first line of code of the function call, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Stepping into a line of code (*F11*) will pause execution at the very next line
    of code run.
  prefs: []
  type: TYPE_NORMAL
- en: Finding bugs and using call stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have a bug in your code that causes a crash, a thrown exception, and
    so on, Visual Studio will attempt to halt execution of code and will allow you
    to inspect the code. The place at which Visual Studio halts won't always be the
    exact location of the bug, but it can be close. It will at least be at a line
    of code that doesn't execute properly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll describe the **Call Stack**, and how to trace where you
    think an error may come from. Try adding a bug to your code, or adding a breakpoint
    somewhere interesting where you'd like to pause for inspection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the code to a point where a bug occurs by pressing *F5*, or selecting the
    Debug | Start Debugging menu option. For example, add these lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The code will pause at the second line (`o->GetName()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this code will only execute (and thus crash) when the game is played
    in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: When the code pauses, navigate to the Call Stack window (Debug | Windows | Call
    Stack).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Call Stack is a list of function calls that were executed. When a bug occurs,
    the line on which it occurred is listed at the top of the Call Stack. Refer to
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84f61f30-4a18-4bea-b9fc-5472d2ad68fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the profiler to identify hot spots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ profiler is extremely useful for finding sections of code that require
    a high amount of processing time. Using the profiler can help you find sections
    of code to focus on during optimization. If you suspect that a region of code
    runs slowly, then you can actually confirm that it isn't slow if it doesn't appear
    highlighted in the profiler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to Debug | Performance Profiler...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/69e22bc5-0985-4574-ab72-93fee172f5af.png)'
  prefs: []
  type: TYPE_IMG
- en: In the dialog shown in the preceding screenshot, select the type of analysis
    you'd like displayed. You can choose to analyze CPU Usage, GPU Usage, Memory Usage,
    or step through a Performance Wizard to assist you in selecting what you want
    to see.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to run the game without the editor and then click on the Start button
    at the bottom of the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the code after a brief time (less than a minute or two) to halt sample
    collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not collect too many samples or the profiler, as then it will take a really
    long time to start up.
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the results that appear in the `.diagsession` file. Be sure to browse
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: all the available tabs that open up. Available tabs will vary depending on the
    type of analysis performed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ profiler samples and analyzes the running code, and presents you with
    a series of diagrams and images about how the code is performed.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the performance profiler by going to [https://docs.microsoft.com/en-us/visualstudio/profiling/?view=vs-2017](https://docs.microsoft.com/en-us/visualstudio/profiling/?view=vs-2017).
  prefs: []
  type: TYPE_NORMAL
