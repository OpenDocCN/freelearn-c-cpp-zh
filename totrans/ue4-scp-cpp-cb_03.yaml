- en: Memory Management, Smart Pointers, and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理、智能指针和调试
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Unmanaged memory – using malloc()/free()
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未管理内存 – 使用 malloc()/free()
- en: Unmanaged memory – using new/delete
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未管理内存 – 使用 new/delete
- en: Managed memory – using NewObject< > and ConstructObject< >
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理内存 – 使用 NewObject< > 和 ConstructObject< >
- en: Managed memory – de-allocating memory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理内存 – 释放内存
- en: Managed memory – using smart pointers (TSharedPtr, TWeakPtr, TAutoPtr) to track
    an object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理内存 – 使用智能指针（TSharedPtr, TWeakPtr, TAutoPtr）来跟踪对象
- en: Using TScopedPointer to track an object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TScopedPointer 来跟踪对象
- en: Unreal's garbage collection system and UPROPERTY()
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unreal 的垃圾回收系统和 UPROPERTY()
- en: Forcing garbage collection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制垃圾回收
- en: Breakpoints and stepping through code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断点和单步执行代码
- en: Finding bugs and using call stacks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找错误和使用调用栈
- en: Using the profiler to identify hot spots
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用性能分析器来识别热点
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Memory management is always one of the most important things to get right in
    your computer program to ensure stability and good, bug-free operation of your
    code. A dangling pointer (*pointer* referring to something that has been removed
    from memory) is an example of a bug that is hard to track if it occurs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理始终是确保您的计算机程序稳定性和代码良好、无错误运行的最重要的事情之一。悬垂指针（*指向已被从内存中移除的指针*）是如果发生则难以追踪的故障示例。
- en: In any computer program, memory management is extremely important. UE4's `UObject`
    reference-counting system is the default way that memory is managed for actors
    and classes derived from the `UObject` class. This is the default way that your
    memory will be managed within your UE4 program.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何计算机程序中，内存管理都极其重要。UE4 的 `UObject` 引用计数系统是管理从 `UObject` 类派生的演员和类的默认方式。这是您在
    UE4 程序中管理内存的默认方式。
- en: If you write custom C++ classes of your own, which do not derive from `UObject`,
    you may find the `TSharedPtr` / `TWeakPtr` reference-counted classes useful to
    use. These classes provide reference counting and automatic deletion for objects
    when they have no more references.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写自己的自定义 C++ 类，这些类不派生自 `UObject`，您可能会发现 `TSharedPtr` / `TWeakPtr` 引用计数类很有用。这些类提供了对象引用计数和自动删除，当它们没有更多引用时。
- en: This chapter provides recipes for memory management within UE4\. It also provides
    information on debugging your code through some of the useful features that Visual
    Studio includes for us, including breakpoints and the profiler.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了在 UE4 中进行内存管理的配方。它还提供了有关通过 Visual Studio 为我们提供的一些有用功能来调试代码的信息，包括断点和性能分析器。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用 Unreal Engine 4，并使用 Visual Studio 2017 作为 IDE。有关如何安装这两款软件及其要求的信息，请参阅本书的[第
    1 章](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml)，*UE4 开发工具*。
- en: Unmanaged memory – using malloc( ) / free( )
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未管理内存 – 使用 malloc( ) / free( )
- en: The basic way to allocate memory to your computer program in C (which is still
    possible to use in C++) is by using the `malloc()` function. This function designates
    a block of the computer system's memory for your program's use. Once your program
    is using a segment of memory, no other program can use or access that segment
    of memory. An attempt to access a segment of memory not allocated to your program
    will generate a **segmentation fault**, and represents an illegal operation on
    most systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言（在 C++ 中仍然可以使用）中为您的计算机程序分配内存的基本方法是使用 `malloc()` 函数。此函数为您的程序指定计算机系统内存中的一块。一旦您的程序正在使用内存的一个段，则没有其他程序可以使用或访问该内存段。尝试访问未分配给您的程序的内存段将生成一个
    **段错误**，并在大多数系统中表示非法操作。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s look at some example code that allocates a pointer variable, `i`, then
    assigns memory to it using `malloc()`. We allocate a single integer behind an
    `int*` pointer. After allocation, we store a value inside `int`, using the dereferencing
    operator `*`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例代码，它分配一个指针变量 `i`，然后使用 `malloc()` 为它分配内存。我们在 `int*` 指针后面分配一个整数。分配后，我们使用解引用运算符
    `*` 在 `int` 中存储一个值：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The preceding code does what is shown in the diagram that follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行的是后续图中所示的操作：
- en: The first line creates an `int *` pointer variable, `i`, which starts as a dangling
    pointer referring to a segment of memory that probably won't be valid for your
    program to reference.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行创建了一个`int *`指针变量`i`，它最初是一个悬空指针，指向一个可能对程序无效的内存段。
- en: In the second step of the diagram, we use a `malloc()` call to initialize the
    variable `i` to point to a segment of memory precisely the size of an `int` variable,
    which will be valid for your program to refer to.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图示的第二步中，我们使用`malloc()`调用初始化变量`i`，使其指向一个恰好为`int`变量大小的内存段，这将使程序能够引用。
- en: 'We then initialize the contents of that memory segment to the value `0` using
    the command `*i = 0;`. Refer to the following diagram:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用命令`*i = 0;`初始化该内存段的值为`0`。请参考以下图示：
- en: '![](img/00340e70-51a4-4f85-916c-9e0a483211bf.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00340e70-51a4-4f85-916c-9e0a483211bf.png)'
- en: Note the difference between the assignment to a pointer variable (`i =`), which
    tells the pointer which memory address to refer to, and the assignment to what
    it is inside the memory address that the pointer variable refers to (`*i =`).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意指针变量赋值（`i =`）与指向指针变量所指向内存地址内内容的赋值（`*i =`）之间的区别，前者告诉指针要引用哪个内存地址，而后者则是指向指针变量所指向的内存地址内的内容。
- en: 'When the memory in the variable `i` needs to be released back to the system,
    we do so using a `free()` de-allocation call, as shown in the following diagram.
    `i` is then assigned to point to the memory address, `0`, shown in this diagram
    by the **electrical grounding** symbol reference, ![](img/97df6b03-e489-4edc-b53e-53668ce93f7f.png):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量`i`中的内存需要释放回系统时，我们使用`free()`解分配调用来实现，如下面的图所示。`i`随后被分配给指向图中由**电气接地**符号引用的内存地址`0`：![](img/97df6b03-e489-4edc-b53e-53668ce93f7f.png)
- en: '![](img/aeff3a49-d8d6-43af-965c-fda71b7d0499.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aeff3a49-d8d6-43af-965c-fda71b7d0499.png)'
- en: The reason we set the variable `i` to point to the `NULL` reference is to make
    it clear that the variable `i` does not refer to a valid segment of memory.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量`i`设置为指向`NULL`引用的原因是为了清楚地表明变量`i`不指向有效的内存段。
- en: Unmanaged memory – using new/delete
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未托管内存 – 使用new/delete
- en: The `new` operator is almost the same as a `malloc` call, except that it invokes
    a constructor call on the object created immediately after the memory is allocated.
    Objects allocated with the `new` operator should be de-allocated with the `delete` operator
    (and not `free()`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符几乎与`malloc`调用相同，不同之处在于它会在内存分配后立即调用对象的构造函数。使用`new`运算符分配的对象应该使用`delete`运算符（而不是`free()`）进行解分配。'
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In C++, use of `malloc()` was replaced as a best practice by use of the `new` operator.
    The main difference between the functionality of `malloc()` and the `new` operator
    is that `new` will call the constructor on object types after memory allocation.
    Refer to the following table:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，`malloc()`的使用已被`new`运算符作为最佳实践所取代。`malloc()`和`new`运算符功能的主要区别在于`new`会在内存分配后在对象类型上调用构造函数。请参考以下表格：
- en: '| `malloc` | Allocates a zone of contiguous space for use |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `malloc` | 为使用分配一个连续的空间区域 |'
- en: '| `new` | Allocates a zone of contiguous space for useCalls constructor as
    an object type used as an argument to the `new` operator. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `new` | 为使用分配一个连续的空间区域调用构造函数，作为`new`运算符参数的对象类型。 |'
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following code, we declare a simple `Object` class, then construct an
    instance of it using the `new` operator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们声明一个简单的`Object`类，然后使用`new`运算符构造它的一个实例：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `new` operator works by allocating space just as `malloc()` does. If the
    type used with the `new` operator is an object type, the constructor is invoked
    automatically with the use of the `new` keyword, whereas the constructor is never
    invoked with the use of `malloc()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符的工作原理与`malloc()`类似。如果与`new`运算符一起使用的类型是对象类型，则构造函数会自动使用`new`关键字调用，而使用`malloc()`时则不会调用构造函数。'
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You should avoid using naked heap allocations with the `new` keyword (or `malloc`
    for that matter). Managed memory is preferred within the engine so that all memory
    use is tracked and clean. If you allocate a `UObject` derivative, you definitely
    need to use `NewObject< >` or `ConstructObject< >` (outlined in subsequent recipes).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应该避免使用带有`new`关键字（或者说是`malloc`）的裸堆分配。在引擎内部，首选使用托管内存，以便跟踪和清理所有内存使用。如果你分配了一个`UObject`派生类，你绝对需要使用`NewObject<
    >`或`ConstructObject< >`（在后续的菜谱中概述）。
- en: Managed memory – using NewObject< > and ConstructObject< >
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管内存 – 使用NewObject< >和ConstructObject< >
- en: '**Managed memory** refers to memory that is <indexentry content="managed memory:allocating,
    NewObject used">allocated and de-allocated by some programmed subsystem above
    the `new`, `delete`, `malloc,`, and `free` calls in C++. These subsystems are
    commonly created so that the programmer does not forget to release memory after
    allocating it. Unreleased, occupied, but unused memory chunks are called **memory
    leaks**, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**托管内存**指的是由位于 `new`、`delete`、`malloc` 和 `free` 调用之上的某些程序子系统分配和释放的内存。这些子系统通常被创建，以便程序员在分配内存后不会忘记释放它。未释放、占用但未使用的内存块被称为**内存泄漏**，如下所示：'
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, the memory allocated is not referenceable by any variable!
    So, you can neither use the allocated memory after the `for` loop, nor free it.
    If your program allocates all available system memory, then what will happen is
    that your system will run out of memory entirely, and your OS will flag your program
    and close it for using up too much memory.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，分配的内存不能被任何变量引用！因此，你既不能在 `for` 循环之后使用分配的内存，也不能释放它。如果你的程序分配了所有可用的系统内存，那么会发生的情况是，你的系统将完全耗尽内存，你的操作系统将标记你的程序，并因为它使用了过多的内存而关闭它。
- en: Memory management prevents forgetting to release memory. In memory-managed programs,
    it is commonly remembered by objects that are dynamically <indexentry content="managed
    memory:allocating, ConstructObject used">allocated the number of pointers referencing
    the object. When there are zero pointers referencing the object, it is either
    automatically deleted immediately, or flagged for deletion on the next run of
    the garbage collector.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理可以防止忘记释放内存。在内存管理的程序中，通常通过动态分配的、引用对象指针数量的对象来记住。当没有指针引用对象时，它要么在垃圾收集器下一次运行时自动立即删除，要么被标记为删除。
- en: Use of managed memory is automatic within UE4\. Any allocation of an object
    to be
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE4 中使用托管内存是自动的。任何对象的分配都必须使用 `NewObject< >()` 或 `SpawnActor< >()` 函数。
- en: used within the engine must be done using the `NewObject< >()` or `SpawnActor<
    >()` function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎中使用时必须使用 `NewObject< >()` 或 `SpawnActor< >()` 函数。
- en: The release of objects is done by removing the reference to the object and then
    occasionally calling the garbage cleanup routine (listed further in this chapter).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的释放是通过删除对对象的引用，然后偶尔调用垃圾清理例程（在本章中进一步列出）来完成的。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: When you need to construct any `UObject` derivative that is not a derivative
    of the `Actor` class, you should always use the `NewObject< >` function. `SpawnActor<
    >` should be used only when the object is an `Actor` or its derivative.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要构造任何不是 `Actor` 类派生类的 `UObject` 派生类时，你应该始终使用 `NewObject< >` 函数。只有当对象是 `Actor`
    或其派生类时，才应使用 `SpawnActor< >`。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s say we are trying to construct an object of a `UAction` type that itself
    derives from `UObject`—for example, the following class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在尝试构造一个 `UAction` 类型的对象，该对象本身是从 `UObject` 继承的——例如，以下类：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To construct an instance of the `UAction` class, we''d do the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造 `UAction` 类的实例，我们会这样做：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, `UAction::StaticClass()` gets you a base `UClass *` for the `UAction`
    object. The first argument to `NewObject< >` is `GetTransientPackage()`, which
    simply retrieves the transient package for the game. A package (`UPackage`) in
    UE4 is just a data conglomerate. Here we use the **Transient Package** to store
    our heap-allocated data. You could also use `UPROPERTY() TSubclassOf<AActor>`
    from Blueprints to select a `UClass` instance.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`UAction::StaticClass()` 为 `UAction` 对象提供了一个基 `UClass *`。`NewObject< >`
    的第一个参数是 `GetTransientPackage()`，它只是检索游戏的临时包。在 UE4 中，包（`UPackage`）只是一个数据集合。我们在这里使用**临时包**来存储我们的堆分配数据。你也可以使用来自
    Blueprints 的 `UPROPERTY() TSubclassOf<AActor>` 来选择 `UClass` 实例。
- en: The third argument (optional) is a combination of parameters that indicate how
    `UObject` is treated by the memory management system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数（可选）是参数的组合，它指示内存管理系统如何处理 `UObject`。
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: There is another function very similar to `NewObject< >` called `ConstructObject<
    >`. `ConstructObject< >` provides more parameters in construction, and you may
    find it useful if you need to initialize certain properties. Otherwise, `NewObject`
    works just fine.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一个与 `NewObject< >` 非常相似的功能，称为 `ConstructObject< >`。`ConstructObject< >` 在构造时提供了更多的参数，如果你需要初始化某些属性，可能会发现它很有用。否则，`NewObject`
    就足够好了。
- en: You can find out more about the ConstructObject function here: [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation#constructobject](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation#constructobject).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于 ConstructObject 函数的信息：[https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation#constructobject](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation#constructobject)。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You may also want to see the documentation for the `RF_*` flags at [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Objects/Creation/index.html#objectflags](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Objects/Creation/index.html#objectflags%20).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想查看 [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Objects/Creation/index.html#objectflags](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Objects/Creation/index.html#objectflags)
    上的 `RF_*` 标志的文档。
- en: Managed memory – de-allocating memory
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理内存 - 释放内存
- en: The `UObject` instances are reference-counted and garbage-collected when there
    are no more references to the `UObject` instance. Memory allocated on a `UObject`
    class derivative using `ConstructObject<>` or `NewObject< >` can also be de-allocated
    manually (before the reference count drops to 0) by calling the `UObject::ConditionalBeginDestroy()`
    member function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多引用指向 `UObject` 实例时，`UObject` 实例会被引用计数和垃圾回收。使用 `ConstructObject<>` 或 `NewObject<
    >` 在 `UObject` 类派生上分配的内存也可以通过调用 `UObject::ConditionalBeginDestroy()` 成员函数手动（在引用计数降至
    0 之前）释放。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'd only do this if you were sure you no longer wanted `UObject` or the `UObject`
    class derivative instance in memory. Use the `ConditionalBeginDestroy()` function
    to release memory.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你确定你不再需要在内存中保留 `UObject` 或 `UObject` 类派生实例时，你才会这样做。使用 `ConditionalBeginDestroy()`
    函数来释放内存。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following code demonstrates the de-allocation of an instance of the `UObject` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了 `UObject` 类实例的释放：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This concept also works with any class derived from the `UObject` class. So,
    for instance, if we wanted to do this with the `UAction` object we created in
    the previous recipe, we would add the bold text in the following snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念也适用于从 `UObject` 类派生的任何类。例如，如果我们想在上一道菜谱中创建的 `UAction` 对象上做这件事，我们会在以下片段中添加粗体文本：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用原理...
- en: The `ConditionalBeginDestroy()` command begins the de-allocation process, calling
    the `BeginDestroy()` and `FinishDestroy()` overrideable functions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConditionalBeginDestroy()` 命令开始释放过程，调用可重写的 `BeginDestroy()` 和 `FinishDestroy()`
    函数。'
- en: Be careful not to call `UObject::ConditionalBeginDestroy()` on any object still
    being referenced in memory by other objects' pointers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意不要在仍被其他对象的指针引用的任何对象上调用 `UObject::ConditionalBeginDestroy()`。
- en: Managed memory – smart pointers (TSharedPtr, TWeakPtr, TAutoPtr) to track an
    object
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理内存 - 使用智能指针（TSharedPtr、TWeakPtr、TAutoPtr）跟踪对象
- en: 'When people are afraid that they''ll forget the `delete` call for standard
    C++ objects they create, they often use smart pointers to prevent memory leaks.
    `TSharedPtr` is a very useful C++ class that will make any custom C++ object reference-counted—with
    the exception of `UObject` derivatives, which are already reference-counted. An
    alternate class, `TWeakPtr`, is also provided for pointing to a reference-counted
    object with the strange property of being unable to prevent deletion (hence, *weak*):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们担心他们会忘记他们为标准 C++ 对象创建的 `delete` 调用时，他们通常会使用智能指针来防止内存泄漏。`TSharedPtr` 是一个非常有用的
    C++ 类，它将使任何自定义 C++ 对象具有引用计数功能——除了 `UObject` 派生类，它们已经具有引用计数。还提供了一个替代类 `TWeakPtr`，用于指向具有无法阻止删除（因此称为
    *弱*）奇怪属性的引用计数对象：
- en: '![](img/66139d96-b541-46d5-a16e-093e46d853fd.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66139d96-b541-46d5-a16e-093e46d853fd.png)'
- en: '`UObject` and its derivative classes (anything created with `NewObject` or `ConstructObject`)
    cannot use `TSharedPtr`!'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`UObject` 及其派生类（使用 `NewObject` 或 `ConstructObject` 创建的任何内容）不能使用 `TSharedPtr`！'
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'If you don''t want to use raw pointers and manually track deletes into your
    C++ code that do not use `UObject` derivatives, then that code is a good candidate
    for using smart pointers such as `TSharedPtr`, `TSharedRef`, and the like. When
    you use a dynamically allocated object (created using the `new` keyword), you
    can wrap it up in a reference-counted pointer so that de-allocation happens automatically.
    The different types of smart pointers determine the smart pointer behavior and
    deletion call time. They are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在你的C++代码中使用原始指针并手动跟踪删除（不使用`UObject`派生类），那么这段代码是使用智能指针（如`TSharedPtr`、`TSharedRef`等）的好候选。当你使用动态分配的对象（使用`new`关键字创建）时，你可以将其包装在一个引用计数指针中，以便自动释放。不同类型的智能指针决定了智能指针的行为和删除调用时间。它们如下：
- en: '`TSharedPtr`: A thread-safe (provided you supplied `ESPMode::ThreadSafe` as
    the second argument to the template) reference-counted pointer type that indicates
    a shared object. The shared object will be de-allocated when there are no more
    references to it.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TSharedPtr`：一个线程安全的（只要你将`ESPMode::ThreadSafe`作为模板的第二个参数提供）引用计数指针类型，表示一个共享对象。当没有更多引用指向它时，共享对象将被释放。'
- en: '`TAutoPtr`: A non-thread-safe shared pointer.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TAutoPtr`：一个非线程安全的共享指针。'
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We can demonstrate the use of the four types of smart pointers referred to previously
    using a short code segment. In all of this code, the starting pointer can either
    be a raw pointer, or a copy of another smart pointer. All you have to do is take
    the C++ raw pointer and wrap it in a constructor call to any of the following: `TSharedPtr`,
    `TSharedRef`, `TWeakPtr,`, or `TAutoPtr`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个简短的代码段来演示之前提到的四种智能指针的使用。在这段代码中，起始指针可以是原始指针，也可以是另一个智能指针的副本。你所要做的就是将C++原始指针包装在任何以下构造函数调用中：`TSharedPtr`、`TSharedRef`、`TWeakPtr`或`TAutoPtr`。
- en: 'For example, take a look at the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下代码片段：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are some differences between weak pointers and shared pointers. Weak pointers
    do not have the capability to keep the object in memory when the reference count
    drops to 0.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 弱指针和共享指针之间有一些区别。弱指针没有在引用计数降到0时保持对象在内存中的能力。
- en: 'The advantage of using a weak pointer (over a raw pointer) is that, when the
    object underneath the weak pointer is manually deleted (using `ConditionalBeginDestroy()`),
    the weak pointer''s reference becomes a `NULL` reference. This enables you to
    check whether the resource underneath the pointer is still allocated properly
    by checking a statement of the following form:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用弱指针（相对于原始指针）的优势在于，当弱指针下的对象被手动删除（使用`ConditionalBeginDestroy()`）时，弱指针的引用变为`NULL`引用。这使你可以通过检查以下形式的语句来检查指针下的资源是否仍然被正确分配：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Shared pointers are thread-safe. This means that the underlying object can safely
    be manipulated on separate threads.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 共享指针是线程安全的。这意味着可以在不同的线程上安全地操作底层对象。
- en: Always remember that you cannot use `TSharedRef` with `UObject`s or `UObject`
    derivatives; you can only use them on your custom C++ classes. Your `FStructures`
    can use the `TSharedPtr`, `TSharedRef`, and `TWeakPtr` classes to wrap up a raw
    pointer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住，你不能在`UObject`或`UObject`派生类中使用`TSharedRef`；你只能在你自定义的C++类中使用它们。你的`FStructures`可以使用`TSharedPtr`、`TSharedRef`和`TWeakPtr`类来包装原始指针。
- en: If you want to use smart pointers to point to an object, you must use `TWeakObjectPointer`
    or `UPROPERTY()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用智能指针指向一个对象，你必须使用`TWeakObjectPointer`或`UPROPERTY()`。
- en: You can use `TAutoPtr` if you do not need the thread-safety guarantee of `TSharedPtr`.
    `TAutoPtr` will automatically delete an object when the number of references to
    it drops to 0.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要`TSharedPtr`的线程安全保证，可以使用`TAutoPtr`。`TAutoPtr`将在引用数降到0时自动删除对象。
- en: If you are interested in learning more about Unreal's smart pointers, check
    out [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/SmartPointerLibrary](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/SmartPointerLibrary).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于Unreal智能指针的信息，请查看[https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/SmartPointerLibrary](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/SmartPointerLibrary)。
- en: Using TScopedPointer to track an object
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TScopedPointer跟踪对象
- en: A **scoped** pointer is a pointer that is auto-deleted at the end of the block
    in which it was declared. Recall that a scope is just a section of code during
    which a variable is *alive*. A scope will last until the first closing brace,
    `}`, that appears.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**作用域**指针是一种在声明它的代码块结束时自动删除的指针。回想一下，作用域只是变量存在的一段代码。作用域将持续到第一个出现的闭合括号 `}`。'
- en: 'For example, in the following block, we have two scopes. The outer scope declares
    an integer variable `x` (valid for the entire outer block), while the inner scope
    declares an integer variable `y` (valid for the inner block, after the line on
    which it is declared):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码块中，我们有两个作用域。外部作用域声明了一个整数变量 `x`（在整个外部块中有效），而内部作用域声明了一个整数变量 `y`（在声明它的行之后的内部块中有效）：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Scoped pointers are useful when it is important that a reference-counted object
    (that is in danger of going out of scope) is retained for the duration of the
    usage.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要保留引用计数的对象（即有越界风险的）在使用的整个过程中保持存在时，作用域指针非常有用。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To declare a scoped pointer, we simply use the following syntax:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明作用域指针，我们只需使用以下语法：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This declares a scoped pointer referencing an object of the type declared within
    the angle brackets: `< AWarrior >`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个引用类型为尖括号内声明的类型的范围指针：`< AWarrior >`。
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `TScopedPointer` variable type automatically adds a reference count to the
    variable pointed to. This prevents the de-allocation of the underlying object
    for at least the life of the scoped pointer.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`TScopedPointer` 变量类型会自动为指向的变量添加引用计数。这可以防止在作用域指针的生命周期内对底层对象进行解分配。'
- en: Unreal's garbage collection system and UPROPERTY( )
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unreal 的垃圾回收系统和 UPROPERTY( )
- en: When you have an object (such as `TArray< >`) as a `UPROPERTY()` member of `UCLASS()`,
    you need to declare that member as `UPROPERTY()` (even if you won't edit it in
    Blueprints); otherwise, `TArray` will not stay allocated properly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个对象（如 `TArray< >`）作为 `UCLASS()` 的 `UPROPERTY()` 成员时，您需要将该成员声明为 `UPROPERTY()`（即使您不会在蓝图中进行编辑）；否则，`TArray`
    将无法正确分配。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Say we have a `UCLASS()` macro as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个如下所示的 `UCLASS()` 宏：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You'd have to list the `TArray` member as `UPROPERTY()` for it to be properly
    reference-counted. If you don't do so, you'll get an unexpected memory error-type
    bug sitting about in the code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须将 `TArray` 成员列为 `UPROPERTY()` 才能正确地进行引用计数。如果您不这样做，您将在代码中遇到意外的内存错误类型错误。
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UPROPERTY()` declaration tells UE4 that `TArray` must be properly memory-managed.
    Without the `UPROPERTY()` declaration, your `TArray` won't work properly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPROPERTY()` 声明告诉 UE4 `TArray` 必须正确地管理内存。没有 `UPROPERTY()` 声明，您的 `TArray` 将无法正常工作。'
- en: Forcing garbage collection
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制垃圾回收
- en: When memory fills up, and you want to free some of it, garbage collection can
    be forced. You seldom need to do this, but you can do it in the case of having
    a very large texture (or set of textures) that are reference-counted and that
    you need to clear.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当内存填满，您想要释放其中一些时，可以强制进行垃圾回收。您很少需要这样做，但在您有一个非常大的纹理（或纹理集）需要清除，并且这些纹理是引用计数的这种情况下，您可以这样做。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Simply call `ConditionalBeginDestroy()` on all `UObject`s that you want de-allocated
    from memory, or set their reference counts to `0`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需在所有想要从内存中解分配的 `UObject` 上调用 `ConditionalBeginDestroy()`，或将它们的引用计数设置为 `0`。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Garbage collection is performed by calling the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用以下方法执行垃圾回收：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Breakpoints and stepping through code
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断点和逐行执行代码
- en: '**Breakpoints** are how you pause your C++ program to temporarily stop the
    code from running, and have a chance to analyze and inspect your program''s operation.
    You can peer at variables, step through code, and change variable values.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**断点**是您暂停 C++ 程序以暂时停止代码运行的方法，并有机会分析和检查程序的操作。您可以查看变量、逐行执行代码，并更改变量值。'
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Breakpoints are easy to set in Visual Studio. All you have to do is press *F9*
    on the line of code where you want the operation to pause, or click in the gray
    margin to the left of the line of code where you want the operation to pause.
    The code will pause when the operation reaches the line indicated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中设置断点很容易。您只需在想要操作暂停的代码行上按 *F9* 键，或者单击想要操作暂停的代码行左侧的灰色边缘。当操作达到指示的行时，代码将暂停。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Press *F9* on the line where you want the execution to pause. This will add
    a breakpoint to the code, indicated by a red dot, as shown in the following screenshot.
    Clicking on the red dot toggles it:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你想暂停执行的那一行按 *F9*。这将向代码添加一个断点，由红色圆点表示，如下所示。单击红色圆点可以切换它：
- en: '![](img/491cbfc5-5a48-4baf-9391-1023a104c953.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/491cbfc5-5a48-4baf-9391-1023a104c953.png)'
- en: 'Set the Build Configuration to any of the configurations with Debug in the
    title (DebugGame Editor or simply DebugGame if you launch it without the editor):'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构建配置设置为任何标题中包含Debug的配置（DebugGame编辑器或如果没有使用编辑器启动，则为简单DebugGame）：
- en: '![](img/7fb56b04-3359-4b04-bf33-f48dfb485aaa.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7fb56b04-3359-4b04-bf33-f48dfb485aaa.png)'
- en: Launch your code by pressing *F5* (without holding *Ctrl*), or select the Debug
    | Start Debugging menu option.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 *F5*（不按 *Ctrl*）或选择调试 | 开始调试菜单选项来启动你的代码。
- en: When the code reaches the red dot, the code's execution will pause.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码到达红色圆点时，代码的执行将暂停。
- en: The paused view will take you to the code editor in **Debug mode**. In this
    mode, the windows may appear re arranged, with Solution Explorer possibly moved
    to the right, and new windows appearing at the bottom, including Locals, Watch
    1, and Call Stack. If these windows do not appear, find them under the Debug |
    Windows submenu.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停视图将带您进入**调试模式**下的代码编辑器。在此模式下，窗口可能会重新排列，解决方案资源管理器可能移动到右侧，底部可能出现新的窗口，包括局部变量、监视1和调用栈。如果这些窗口没有出现，请在调试
    | 窗口子菜单下查找它们。
- en: Check out your variables under the Locals window (Debug | Windows | Locals).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在局部变量窗口（调试 | 窗口 | 局部变量）下检查你的变量。
- en: Press *F10* to step over a line of code.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *F10* 跳过一行代码。
- en: Press *F11* to step into a line of code.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *F11* 进入一行代码。
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Debuggers are powerful tools that allow you to see everything about your code
    as it is running, including variable states.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器是强大的工具，允许你在代码运行时查看有关代码的任何信息，包括变量状态。
- en: 'Stepping over a line of code (*F10*) executes the line of code in its entirety,
    and then pauses the program again, immediately, at the next line. If the line
    of code is a function call, then the function is executed without pausing at the
    first line of code of the function call, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过一行代码（*F10*）将执行该行代码的整个内容，然后立即在下一行暂停程序。如果该行代码是一个函数调用，那么函数将在函数调用的第一行代码处不暂停执行，如下所示：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Stepping into a line of code (*F11*) will pause execution at the very next line
    of code run.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 跳入一行代码（*F11*）将在运行的下一行代码处暂停执行。
- en: Finding bugs and using call stacks
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找错误和使用调用栈
- en: When you have a bug in your code that causes a crash, a thrown exception, and
    so on, Visual Studio will attempt to halt execution of code and will allow you
    to inspect the code. The place at which Visual Studio halts won't always be the
    exact location of the bug, but it can be close. It will at least be at a line
    of code that doesn't execute properly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码中存在导致崩溃的错误、抛出异常等情况时，Visual Studio 将尝试停止代码执行，并允许你检查代码。Visual Studio 停止的地方不一定是错误的精确位置，但它可以非常接近。至少它会在一行代码上，该代码无法正确执行。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll describe the **Call Stack**, and how to trace where you
    think an error may come from. Try adding a bug to your code, or adding a breakpoint
    somewhere interesting where you'd like to pause for inspection.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将描述**调用栈**以及如何追踪你认为错误可能来自的地方。尝试向你的代码中添加一个错误，或者添加一个你想要暂停检查的有趣位置的断点。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Run the code to a point where a bug occurs by pressing *F5*, or selecting the
    Debug | Start Debugging menu option. For example, add these lines of code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 *F5* 或选择调试 | 开始调试菜单选项将代码运行到发生错误的位置。例如，添加以下代码行：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code will pause at the second line (`o->GetName()`).
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将在第二行（`o->GetName()`）暂停。
- en: Note that this code will only execute (and thus crash) when the game is played
    in the editor.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码仅在游戏中在编辑器中播放时才会执行（并因此崩溃）。
- en: When the code pauses, navigate to the Call Stack window (Debug | Windows | Call
    Stack).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码暂停时，导航到调用栈窗口（调试 | 窗口 | 调用栈）。
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Call Stack is a list of function calls that were executed. When a bug occurs,
    the line on which it occurred is listed at the top of the Call Stack. Refer to
    the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 调用栈是已执行函数调用的列表。当发生错误时，它发生的行将列在调用栈的顶部。参考以下截图：
- en: '![](img/84f61f30-4a18-4bea-b9fc-5472d2ad68fd.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84f61f30-4a18-4bea-b9fc-5472d2ad68fd.png)'
- en: Using the profiler to identify hot spots
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用性能分析器识别热点
- en: The C++ profiler is extremely useful for finding sections of code that require
    a high amount of processing time. Using the profiler can help you find sections
    of code to focus on during optimization. If you suspect that a region of code
    runs slowly, then you can actually confirm that it isn't slow if it doesn't appear
    highlighted in the profiler.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 分析器对于查找需要大量处理时间的代码部分非常有用。使用分析器可以帮助您在优化过程中关注代码的特定部分。如果您怀疑某个代码区域运行缓慢，那么实际上如果它在分析器中没有高亮显示，您就可以确认它并不慢。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Go to Debug | Performance Profiler...:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '前往调试 | 性能分析器...:'
- en: '![](img/69e22bc5-0985-4574-ab72-93fee172f5af.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69e22bc5-0985-4574-ab72-93fee172f5af.png)'
- en: In the dialog shown in the preceding screenshot, select the type of analysis
    you'd like displayed. You can choose to analyze CPU Usage, GPU Usage, Memory Usage,
    or step through a Performance Wizard to assist you in selecting what you want
    to see.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面截图所示的对话框中，选择您想要显示的分析类型。您可以选择分析CPU使用率、GPU使用率、内存使用率，或者通过性能向导逐步选择您想要查看的内容。
- en: Make sure to run the game without the editor and then click on the Start button
    at the bottom of the dialog.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在没有编辑器的情况下运行游戏，然后点击对话框底部的开始按钮。
- en: Stop the code after a brief time (less than a minute or two) to halt sample
    collection.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在短时间内（不到一分钟或两分钟）停止代码以停止样本收集。
- en: Do not collect too many samples or the profiler, as then it will take a really
    long time to start up.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不要收集过多的样本或分析器，因为那样启动将需要非常长的时间。
- en: Inspect the results that appear in the `.diagsession` file. Be sure to browse
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查出现在 `.diagsession` 文件中的结果。务必浏览
- en: all the available tabs that open up. Available tabs will vary depending on the
    type of analysis performed.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有的可用选项卡。可用的选项卡将根据执行的分析类型而有所不同。
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The C++ profiler samples and analyzes the running code, and presents you with
    a series of diagrams and images about how the code is performed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 分析器对运行中的代码进行采样和分析，并向您展示一系列关于代码执行情况的图表和图像。
- en: You can find more information about the performance profiler by going to [https://docs.microsoft.com/en-us/visualstudio/profiling/?view=vs-2017](https://docs.microsoft.com/en-us/visualstudio/profiling/?view=vs-2017).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问[https://docs.microsoft.com/en-us/visualstudio/profiling/?view=vs-2017](https://docs.microsoft.com/en-us/visualstudio/profiling/?view=vs-2017)来获取更多关于性能分析器的信息。
