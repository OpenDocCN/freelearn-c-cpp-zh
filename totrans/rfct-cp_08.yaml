- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing and Developing APIs in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of software development, the design of **application programming
    interfaces** (**APIs**) is of paramount importance. Good APIs serve as the backbone
    of software libraries, facilitating interaction between different software components
    and enabling developers to leverage functionality efficiently and effectively.
    Well-designed APIs are intuitive, easy to use, and maintainable, playing a crucial
    role in the success and longevity of software projects. In this chapter, we will
    delve into principles and practices for designing maintainable APIs for libraries
    developed in C++. We will explore key aspects of API design, including clarity,
    consistency, and extensibility, and provide concrete examples to illustrate best
    practices. By understanding and applying these principles, you will be able to
    create APIs that not only meet the immediate needs of users but also remain robust
    and adaptable over time, ensuring that your libraries are both powerful and user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Principles of minimalistic API design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Minimalistic APIs are designed to provide only the essential functionalities
    required to perform specific tasks, avoiding unnecessary features and complexity.
    The primary goal is to offer a clean, efficient, and user-friendly interface that
    facilitates easy integration and usage. Key benefits of minimalistic APIs include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of use**: Users can quickly understand and utilize the API without extensive
    learning or documentation, promoting faster development cycles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Simplified APIs are easier to maintain, allowing for straightforward
    updates and bug fixes without introducing new complexities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Leaner APIs tend to have better performance due to reduced
    overhead and more efficient execution paths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliability**: With fewer components and interactions, the likelihood of
    bugs and unexpected issues is minimized, leading to more reliable and stable software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simplicity and clarity are fundamental principles in the design of minimalistic
    APIs. These principles ensure that the API remains accessible and user-friendly,
    enhancing the overall developer experience. Key aspects of simplicity and clarity
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Straightforward interfaces**: Designing simple and clear interfaces helps
    developers quickly grasp the available functionalities, making it easier to integrate
    and use the API effectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced cognitive load**: By minimizing the mental effort required to understand
    and use the API, developers are less likely to make mistakes, leading to more
    efficient development processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intuitive design**: An API that adheres to simplicity and clarity aligns
    closely with common usage patterns and developer expectations, making it more
    intuitive and easier to adopt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overengineering and unnecessary complexity can severely undermine the effectiveness
    of an API. To avoid these pitfalls, consider the following strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus on core functionality**: Concentrate on delivering essential features
    that address the primary use cases. Avoid adding extraneous features that are
    not directly aligned with the core purpose of the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterative design**: Begin with a **minimum viable product** (**MVP**) and
    incrementally add features based on user feedback and actual needs rather than
    speculative requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear documentation**: Provide comprehensive yet concise documentation that
    focuses on core functionality and common use cases. This helps prevent confusion
    and misuse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent naming conventions**: Use consistent and descriptive names for
    functions, classes, and parameters to enhance clarity and predictability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimal dependencies**: Reduce the number of external dependencies to simplify
    the integration process and minimize potential compatibility issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for achieving minimalism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional decomposition is the process of breaking down complex functionalities
    into smaller, more manageable units. This technique is crucial for creating minimalistic
    APIs as it promotes simplicity and modularity. By decomposing functions, you ensure
    that each part of the API has a clear, well-defined purpose, which enhances maintainability
    and usability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key aspects of functional decomposition include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modular design**: Design the API such that each module or function handles
    a specific aspect of the overall functionality. This **separation of concerns**
    (**SoC**) ensures that each part of the API has a clear, well-defined purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle (SRP)**: Each function or class should have
    one, and only one, reason to change. This principle helps in keeping the API simple
    and focused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusable components**: By decomposing functions into smaller units, you can
    create reusable components that can be combined in different ways to achieve various
    tasks, enhancing the flexibility and reusability of the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation aims to keep interfaces lean and focused on specific tasks,
    avoiding the design of monolithic interfaces that try to cover too many use cases.
    This principle ensures that clients only need to know about the methods that are
    relevant to them, making the API easier to use and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key aspects of interface segregation include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specific interfaces**: Instead of one large, general-purpose interface, design
    multiple smaller, specific interfaces. Each interface should cater to a specific
    aspect of the functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-centric design**: Consider the needs of the end users of your API. Design
    interfaces that are intuitive and provide only methods they need for their tasks,
    avoiding unnecessary complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced client impact**: Smaller, focused interfaces minimize the impact
    on clients when changes are necessary. Clients using a specific interface are
    less likely to be affected by changes in unrelated functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us consider an example where a complex API class is responsible for various
    features, such as loading, processing, and saving data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The major issue is that the class has too many responsibilities, mixing different
    data sources and sinks, leading to complexity and lack of focus. Let us start
    with extracting the loading and processing functionalities into separate classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to extract the saving functionalities into separate classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Minimizing the number of dependencies required by the API is crucial for achieving
    minimalism. Fewer dependencies lead to a more stable, reliable, and maintainable
    API. Dependencies can complicate integration, increase the risk of compatibility
    issues, and make the API harder to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key strategies for reducing dependencies include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core functionality focus**: Concentrate on implementing core functionalities
    within the API itself, avoiding reliance on external libraries or components unless
    absolutely necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selective use of libraries**: When external libraries are required, choose
    those that are stable, well maintained, and widely used. Ensure that they align
    closely with the needs of your API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decoupled design**: Design the API in a way that it can function independently
    of external components as much as possible. Use **dependency injection** (**DI**)
    or other design patterns to decouple the implementation from specific dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version management**: Carefully manage and specify versions of any dependencies
    to avoid compatibility issues. Ensure that updates to dependencies do not break
    the API or introduce instability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world examples of minimalistic API design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To solidify our understanding of these concepts, we will examine a few real-world
    examples of API design in C++. These examples will highlight common challenges
    and effective solutions, demonstrating how to apply the principles of good API
    design in practical scenarios. Through these examples, we aim to provide clear,
    actionable insights that you can apply to your own projects, ensuring that your
    APIs are not only functional but also elegant and maintainable. Let’s dive into
    the intricacies of real-world API design and see how these principles come to
    life in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON for Modern C++ (nlohmann/json)**: This library is an excellent example
    of minimalistic API design. It provides intuitive and straightforward methods
    for parsing, serializing, and manipulating JSON data in C++ and has the following
    benefits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Clear and concise interface that is easy to use.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional decomposition**: Each function handles a specific task related
    to JSON processing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimal dependencies**: Designed to work with the C++ Standard Library, avoiding
    unnecessary external dependencies:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**SQLite C++ Interface (SQLiteCpp)**: This library offers a minimalistic interface
    for interacting with SQLite databases in C++. It has the following benefits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Provides a straightforward and clear API for database operations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface segregation**: Separate classes for different database operations
    such as queries and transactions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimal dependencies**: Built to use SQLite and the C++ Standard Library:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Common pitfalls and how to avoid them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Overcomplication occurs when the API design includes unnecessary features or
    complexity, making it difficult to use and maintain. Here’s how to mitigate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance strategy**: Focus on core functionalities required by the end users.
    Regularly review the API design to eliminate any unnecessary features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Feature creep happens when additional features are continually added to the
    API, leading to increased complexity and reduced usability. Here’s how you can
    avoid this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance strategy**: Implement a strict feature prioritization process.
    Ensure that new features are aligned with the core purpose of the API and are
    necessary for the target users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important caveats of developing shared libraries in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing shared libraries in C++ requires careful consideration to ensure
    compatibility, stability, and usability. Originally, shared libraries were intended
    to promote code reuse, modularity, and efficient memory usage, allowing multiple
    programs to use the same library code simultaneously. This approach was expected
    to reduce redundancy, save system resources, and provide the ability to replace
    only parts of applications. While this approach worked well for widely used libraries,
    such as `libc`, `libstdc++`, OpenSSL, and others, it proved to be less efficient
    for applications. Shared libraries provided with an application can rarely be
    spotlessly replaced with a newer version. Usually, it is required to replace the
    whole installation kit, which includes the application and all its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, shared libraries are often used to enable interoperability between
    different programming languages. For instance, a C++ library might be used in
    applications written in Java or Python. This cross-language functionality extends
    the usability and reach of the library but introduces certain complexities and
    caveats that developers must consider.
  prefs: []
  type: TYPE_NORMAL
- en: Shared libraries within a single project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the shared library is designed to be used within a single project and loaded
    by an executable compiled with the same compiler, then shared objects (or DLLs)
    with C++ interfaces are generally acceptable. However, this approach comes with
    caveats, such as the use of singletons, which can lead to issues with multithreading
    and unexpected initialization order. When singletons are used, managing their
    initialization and destruction in a multithreaded environment can be challenging,
    leading to potential race conditions and unpredictable behavior. Additionally,
    ensuring the correct order of initialization and destruction of global state is
    complex, which can result in subtle and hard-to-diagnose bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Shared libraries for wider distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the shared library is expected to be distributed more widely, where the developers
    cannot predict the compiler used by the end users or if the library might be used
    from other programming languages, then C++ shared libraries are not an ideal choice.
    This is primarily because the C++ `libc` or operating system syscalls, which are
    also in C. A common solution to this problem is to develop a C wrapper around
    the C++ code and ship the C interface.
  prefs: []
  type: TYPE_NORMAL
- en: Example – MessageSender class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next is an example demonstrating this approach, where we create a C++ `MessageSender`
    class and provide a C wrapper for it. The class has a constructor that initializes
    a `MessageSender` instance with a specified receiver and two overloaded `send`
    methods that allow sending messages either as a `std::vector<uint8_t>` instance
    or as a raw pointer with a specified length. The implementation prints messages
    to the console to demonstrate functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the C++ library implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the C wrapper implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the C++ `MessageSender` class is defined in the `MessageSender.hpp`
    and `MessageSender.cpp` files. The class has a constructor that initializes a
    `MessageSender` instance with a specified receiver and two overloaded `send` methods
    that allow sending messages either as a `std::vector<uint8_t>` instance or as
    a raw pointer with a specified length. The implementation prints messages to the
    console to demonstrate functionality.
  prefs: []
  type: TYPE_NORMAL
- en: To make this C++ class usable from other programming languages or with different
    compilers, we create a C wrapper. The C wrapper is defined in the `MessageSender.h`
    and `MessageSenderC.cpp` files. The header file uses an `extern "C"` block to
    ensure that the C++ functions are callable from C, preventing name mangling. The
    C wrapper uses an opaque handle, `void*` (typedef as `MessageSenderHandle`), to
    represent the `MessageSender` instance in C, abstracting the actual C++ class.
  prefs: []
  type: TYPE_NORMAL
- en: The `create_message_sender` function allocates and initializes a `MessageSender`
    instance and returns a handle to it. Note that it uses `new(std::nothrow)` to
    avoid throwing exceptions in case of memory allocation failure. C or any other
    programming language that does not support exceptions can still use this function
    without issues.
  prefs: []
  type: TYPE_NORMAL
- en: The `destroy_message_sender` function deallocates the `MessageSender` instance
    to ensure proper cleanup. The `send_message` function calls the corresponding
    `send` method on the `MessageSender` instance using the handle, facilitating message
    sending.
  prefs: []
  type: TYPE_NORMAL
- en: By handling memory allocation and deallocation within the same binary, this
    approach avoids issues related to different memory allocators being used by the
    end user, which can lead to memory corruption or leaks. The C wrapper provides
    a stable and consistent interface that can be used across different compilers
    and languages, ensuring greater compatibility and stability. This method addresses
    the complexities of developing shared libraries and ensures their broad usability
    and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the C++ library is expected to throw exceptions, it is important to handle
    them properly in C wrapper functions to prevent exceptions from propagating to
    the caller. For example, we can have the following exception types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the C wrapper functions can catch these exceptions and return appropriate
    error codes or messages to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use `std::abort` in case of an unknown exception, as it is not
    safe to propagate unknown exceptions across language boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: This example illustrates how to create a C wrapper around a C++ library to ensure
    compatibility and stability when developing shared libraries. By following these
    guidelines, developers can create robust, maintainable, and widely compatible
    shared libraries, ensuring their usability across various platforms and programming
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored critical aspects of designing and developing shared
    libraries in C++. Shared libraries were initially conceived to promote code reuse,
    modularity, and efficient memory usage by allowing multiple programs to utilize
    the same library code simultaneously. This approach reduces redundancy and conserves
    system resources.
  prefs: []
  type: TYPE_NORMAL
- en: We delved into the nuances of developing shared libraries for different contexts.
    When the shared library is intended for use within a single project and compiled
    with the same compiler, shared objects (or DLLs) with C++ interfaces can be suitable,
    albeit with caution around singletons and global state to avoid multithreading
    issues and unpredictable initialization order.
  prefs: []
  type: TYPE_NORMAL
- en: However, for wider distribution where the end user’s compiler or programming
    language might differ, using C++ shared libraries directly is less advisable due
    to the instability of the C++ ABI across different compilers and versions. To
    overcome this, we discussed creating a C wrapper around the C++ code, leveraging
    the stable C ABI for broader compatibility and cross-language functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We provided a comprehensive example using a `MessageSender` class, illustrating
    how to create a C++ library and its corresponding C wrapper. The example emphasized
    safe memory management by ensuring allocation and deallocation within the same
    binary and handling exceptions gracefully by representing them with an enumerated
    status in the C interface.
  prefs: []
  type: TYPE_NORMAL
- en: By following these guidelines, developers can create robust, maintainable, and
    widely compatible shared libraries, ensuring their usability across various platforms
    and programming environments. This chapter equips developers with the necessary
    knowledge to address common caveats and implement best practices in shared library
    development, fostering effective and reliable software solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift our focus to code formatting, exploring best
    practices for creating clear, consistent, and readable code, which is essential
    for collaboration and long-term maintenance.
  prefs: []
  type: TYPE_NORMAL
