- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing and Developing APIs in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of software development, the design of **application programming
    interfaces** (**APIs**) is of paramount importance. Good APIs serve as the backbone
    of software libraries, facilitating interaction between different software components
    and enabling developers to leverage functionality efficiently and effectively.
    Well-designed APIs are intuitive, easy to use, and maintainable, playing a crucial
    role in the success and longevity of software projects. In this chapter, we will
    delve into principles and practices for designing maintainable APIs for libraries
    developed in C++. We will explore key aspects of API design, including clarity,
    consistency, and extensibility, and provide concrete examples to illustrate best
    practices. By understanding and applying these principles, you will be able to
    create APIs that not only meet the immediate needs of users but also remain robust
    and adaptable over time, ensuring that your libraries are both powerful and user-friendly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Principles of minimalistic API design
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Minimalistic APIs are designed to provide only the essential functionalities
    required to perform specific tasks, avoiding unnecessary features and complexity.
    The primary goal is to offer a clean, efficient, and user-friendly interface that
    facilitates easy integration and usage. Key benefits of minimalistic APIs include
    the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of use**: Users can quickly understand and utilize the API without extensive
    learning or documentation, promoting faster development cycles'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Simplified APIs are easier to maintain, allowing for straightforward
    updates and bug fixes without introducing new complexities'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Leaner APIs tend to have better performance due to reduced
    overhead and more efficient execution paths'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliability**: With fewer components and interactions, the likelihood of
    bugs and unexpected issues is minimized, leading to more reliable and stable software'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simplicity and clarity are fundamental principles in the design of minimalistic
    APIs. These principles ensure that the API remains accessible and user-friendly,
    enhancing the overall developer experience. Key aspects of simplicity and clarity
    include the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Straightforward interfaces**: Designing simple and clear interfaces helps
    developers quickly grasp the available functionalities, making it easier to integrate
    and use the API effectively'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced cognitive load**: By minimizing the mental effort required to understand
    and use the API, developers are less likely to make mistakes, leading to more
    efficient development processes'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intuitive design**: An API that adheres to simplicity and clarity aligns
    closely with common usage patterns and developer expectations, making it more
    intuitive and easier to adopt'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overengineering and unnecessary complexity can severely undermine the effectiveness
    of an API. To avoid these pitfalls, consider the following strategies:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus on core functionality**: Concentrate on delivering essential features
    that address the primary use cases. Avoid adding extraneous features that are
    not directly aligned with the core purpose of the API.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterative design**: Begin with a **minimum viable product** (**MVP**) and
    incrementally add features based on user feedback and actual needs rather than
    speculative requirements.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear documentation**: Provide comprehensive yet concise documentation that
    focuses on core functionality and common use cases. This helps prevent confusion
    and misuse.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent naming conventions**: Use consistent and descriptive names for
    functions, classes, and parameters to enhance clarity and predictability.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimal dependencies**: Reduce the number of external dependencies to simplify
    the integration process and minimize potential compatibility issues.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for achieving minimalism
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional decomposition is the process of breaking down complex functionalities
    into smaller, more manageable units. This technique is crucial for creating minimalistic
    APIs as it promotes simplicity and modularity. By decomposing functions, you ensure
    that each part of the API has a clear, well-defined purpose, which enhances maintainability
    and usability.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Key aspects of functional decomposition include the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '**Modular design**: Design the API such that each module or function handles
    a specific aspect of the overall functionality. This **separation of concerns**
    (**SoC**) ensures that each part of the API has a clear, well-defined purpose.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle (SRP)**: Each function or class should have
    one, and only one, reason to change. This principle helps in keeping the API simple
    and focused.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusable components**: By decomposing functions into smaller units, you can
    create reusable components that can be combined in different ways to achieve various
    tasks, enhancing the flexibility and reusability of the API.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation aims to keep interfaces lean and focused on specific tasks,
    avoiding the design of monolithic interfaces that try to cover too many use cases.
    This principle ensures that clients only need to know about the methods that are
    relevant to them, making the API easier to use and understand.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Key aspects of interface segregation include the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '**Specific interfaces**: Instead of one large, general-purpose interface, design
    multiple smaller, specific interfaces. Each interface should cater to a specific
    aspect of the functionality.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-centric design**: Consider the needs of the end users of your API. Design
    interfaces that are intuitive and provide only methods they need for their tasks,
    avoiding unnecessary complexity.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced client impact**: Smaller, focused interfaces minimize the impact
    on clients when changes are necessary. Clients using a specific interface are
    less likely to be affected by changes in unrelated functionality.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us consider an example where a complex API class is responsible for various
    features, such as loading, processing, and saving data:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The major issue is that the class has too many responsibilities, mixing different
    data sources and sinks, leading to complexity and lack of focus. Let us start
    with extracting the loading and processing functionalities into separate classes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is to extract the saving functionalities into separate classes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Minimizing the number of dependencies required by the API is crucial for achieving
    minimalism. Fewer dependencies lead to a more stable, reliable, and maintainable
    API. Dependencies can complicate integration, increase the risk of compatibility
    issues, and make the API harder to understand.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Key strategies for reducing dependencies include the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**Core functionality focus**: Concentrate on implementing core functionalities
    within the API itself, avoiding reliance on external libraries or components unless
    absolutely necessary.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selective use of libraries**: When external libraries are required, choose
    those that are stable, well maintained, and widely used. Ensure that they align
    closely with the needs of your API.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decoupled design**: Design the API in a way that it can function independently
    of external components as much as possible. Use **dependency injection** (**DI**)
    or other design patterns to decouple the implementation from specific dependencies.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version management**: Carefully manage and specify versions of any dependencies
    to avoid compatibility issues. Ensure that updates to dependencies do not break
    the API or introduce instability.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world examples of minimalistic API design
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To solidify our understanding of these concepts, we will examine a few real-world
    examples of API design in C++. These examples will highlight common challenges
    and effective solutions, demonstrating how to apply the principles of good API
    design in practical scenarios. Through these examples, we aim to provide clear,
    actionable insights that you can apply to your own projects, ensuring that your
    APIs are not only functional but also elegant and maintainable. Let’s dive into
    the intricacies of real-world API design and see how these principles come to
    life in practice:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON for Modern C++ (nlohmann/json)**: This library is an excellent example
    of minimalistic API design. It provides intuitive and straightforward methods
    for parsing, serializing, and manipulating JSON data in C++ and has the following
    benefits:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Clear and concise interface that is easy to use.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional decomposition**: Each function handles a specific task related
    to JSON processing.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimal dependencies**: Designed to work with the C++ Standard Library, avoiding
    unnecessary external dependencies:'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**SQLite C++ Interface (SQLiteCpp)**: This library offers a minimalistic interface
    for interacting with SQLite databases in C++. It has the following benefits:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Provides a straightforward and clear API for database operations.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：提供直观且清晰的数据库操作 API。'
- en: '**Interface segregation**: Separate classes for different database operations
    such as queries and transactions.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离**：为不同的数据库操作（如查询和事务）创建不同的类。'
- en: '**Minimal dependencies**: Built to use SQLite and the C++ Standard Library:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小依赖性**：构建用于 SQLite 和 C++ 标准库：'
- en: '[PRE18]'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Common pitfalls and how to avoid them
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见陷阱及其避免方法
- en: 'Overcomplication occurs when the API design includes unnecessary features or
    complexity, making it difficult to use and maintain. Here’s how to mitigate this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当 API 设计包含不必要的功能或复杂性时，会发生过度复杂化，使其难以使用和维护。以下是减轻这种情况的方法：
- en: '**Avoidance strategy**: Focus on core functionalities required by the end users.
    Regularly review the API design to eliminate any unnecessary features.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免策略**：关注最终用户所需的核心功能。定期审查 API 设计，以消除任何不必要的功能。'
- en: 'Feature creep happens when additional features are continually added to the
    API, leading to increased complexity and reduced usability. Here’s how you can
    avoid this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 功能蔓延发生在不断向 API 添加额外功能时，导致复杂性增加和可用性降低。以下是您可以避免这种情况的方法：
- en: '**Avoidance strategy**: Implement a strict feature prioritization process.
    Ensure that new features are aligned with the core purpose of the API and are
    necessary for the target users.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免策略**：实施严格的特性优先级排序流程。确保新特性与 API 的核心目的相一致，并且对于目标用户来说是必要的。'
- en: Important caveats of developing shared libraries in C++
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C++ 中开发共享库的重要注意事项
- en: Developing shared libraries in C++ requires careful consideration to ensure
    compatibility, stability, and usability. Originally, shared libraries were intended
    to promote code reuse, modularity, and efficient memory usage, allowing multiple
    programs to use the same library code simultaneously. This approach was expected
    to reduce redundancy, save system resources, and provide the ability to replace
    only parts of applications. While this approach worked well for widely used libraries,
    such as `libc`, `libstdc++`, OpenSSL, and others, it proved to be less efficient
    for applications. Shared libraries provided with an application can rarely be
    spotlessly replaced with a newer version. Usually, it is required to replace the
    whole installation kit, which includes the application and all its dependencies.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中开发共享库需要仔细考虑以确保兼容性、稳定性和可用性。最初，共享库旨在促进代码重用、模块化和高效内存使用，允许多个程序同时使用相同的库代码。这种方法预计可以减少冗余、节省系统资源，并能够仅替换应用程序的部分。虽然这种方法对于广泛使用的库（如
    `libc`、`libstdc++`、OpenSSL 等）效果良好，但它对于应用程序来说效率较低。与应用程序一起提供的共享库很少能够完美地替换为较新版本。通常，需要替换整个安装套件，包括应用程序及其所有依赖项。
- en: Nowadays, shared libraries are often used to enable interoperability between
    different programming languages. For instance, a C++ library might be used in
    applications written in Java or Python. This cross-language functionality extends
    the usability and reach of the library but introduces certain complexities and
    caveats that developers must consider.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，共享库通常用于实现不同编程语言之间的互操作性。例如，C++ 库可能被用于用 Java 或 Python 编写的应用程序中。这种跨语言功能扩展了库的可用性和范围，但同时也引入了某些复杂性和注意事项，开发者必须考虑。
- en: Shared libraries within a single project
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个项目内的共享库
- en: If the shared library is designed to be used within a single project and loaded
    by an executable compiled with the same compiler, then shared objects (or DLLs)
    with C++ interfaces are generally acceptable. However, this approach comes with
    caveats, such as the use of singletons, which can lead to issues with multithreading
    and unexpected initialization order. When singletons are used, managing their
    initialization and destruction in a multithreaded environment can be challenging,
    leading to potential race conditions and unpredictable behavior. Additionally,
    ensuring the correct order of initialization and destruction of global state is
    complex, which can result in subtle and hard-to-diagnose bugs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果共享库设计为在单个项目中使用，并且由使用相同编译器编译的可执行文件加载，那么具有 C++ 接口的共享对象（或 DLL）通常是可接受的。然而，这种方法存在一些注意事项，例如单例的使用，这可能导致多线程问题和意外的初始化顺序。当使用单例时，在多线程环境中管理它们的初始化和销毁可能具有挑战性，可能导致潜在的竞争条件和不可预测的行为。此外，确保全局状态初始化和销毁的正确顺序很复杂，这可能导致微妙且难以诊断的错误。
- en: Shared libraries for wider distribution
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于更广泛分发的共享库
- en: If the shared library is expected to be distributed more widely, where the developers
    cannot predict the compiler used by the end users or if the library might be used
    from other programming languages, then C++ shared libraries are not an ideal choice.
    This is primarily because the C++ `libc` or operating system syscalls, which are
    also in C. A common solution to this problem is to develop a C wrapper around
    the C++ code and ship the C interface.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Example – MessageSender class
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next is an example demonstrating this approach, where we create a C++ `MessageSender`
    class and provide a C wrapper for it. The class has a constructor that initializes
    a `MessageSender` instance with a specified receiver and two overloaded `send`
    methods that allow sending messages either as a `std::vector<uint8_t>` instance
    or as a raw pointer with a specified length. The implementation prints messages
    to the console to demonstrate functionality.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the C++ library implementation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s the C wrapper implementation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, the C++ `MessageSender` class is defined in the `MessageSender.hpp`
    and `MessageSender.cpp` files. The class has a constructor that initializes a
    `MessageSender` instance with a specified receiver and two overloaded `send` methods
    that allow sending messages either as a `std::vector<uint8_t>` instance or as
    a raw pointer with a specified length. The implementation prints messages to the
    console to demonstrate functionality.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: To make this C++ class usable from other programming languages or with different
    compilers, we create a C wrapper. The C wrapper is defined in the `MessageSender.h`
    and `MessageSenderC.cpp` files. The header file uses an `extern "C"` block to
    ensure that the C++ functions are callable from C, preventing name mangling. The
    C wrapper uses an opaque handle, `void*` (typedef as `MessageSenderHandle`), to
    represent the `MessageSender` instance in C, abstracting the actual C++ class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The `create_message_sender` function allocates and initializes a `MessageSender`
    instance and returns a handle to it. Note that it uses `new(std::nothrow)` to
    avoid throwing exceptions in case of memory allocation failure. C or any other
    programming language that does not support exceptions can still use this function
    without issues.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The `destroy_message_sender` function deallocates the `MessageSender` instance
    to ensure proper cleanup. The `send_message` function calls the corresponding
    `send` method on the `MessageSender` instance using the handle, facilitating message
    sending.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: By handling memory allocation and deallocation within the same binary, this
    approach avoids issues related to different memory allocators being used by the
    end user, which can lead to memory corruption or leaks. The C wrapper provides
    a stable and consistent interface that can be used across different compilers
    and languages, ensuring greater compatibility and stability. This method addresses
    the complexities of developing shared libraries and ensures their broad usability
    and reliability.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'If the C++ library is expected to throw exceptions, it is important to handle
    them properly in C wrapper functions to prevent exceptions from propagating to
    the caller. For example, we can have the following exception types:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, the C wrapper functions can catch these exceptions and return appropriate
    error codes or messages to the caller:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we use `std::abort` in case of an unknown exception, as it is not
    safe to propagate unknown exceptions across language boundaries.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: This example illustrates how to create a C wrapper around a C++ library to ensure
    compatibility and stability when developing shared libraries. By following these
    guidelines, developers can create robust, maintainable, and widely compatible
    shared libraries, ensuring their usability across various platforms and programming
    environments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored critical aspects of designing and developing shared
    libraries in C++. Shared libraries were initially conceived to promote code reuse,
    modularity, and efficient memory usage by allowing multiple programs to utilize
    the same library code simultaneously. This approach reduces redundancy and conserves
    system resources.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: We delved into the nuances of developing shared libraries for different contexts.
    When the shared library is intended for use within a single project and compiled
    with the same compiler, shared objects (or DLLs) with C++ interfaces can be suitable,
    albeit with caution around singletons and global state to avoid multithreading
    issues and unpredictable initialization order.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: However, for wider distribution where the end user’s compiler or programming
    language might differ, using C++ shared libraries directly is less advisable due
    to the instability of the C++ ABI across different compilers and versions. To
    overcome this, we discussed creating a C wrapper around the C++ code, leveraging
    the stable C ABI for broader compatibility and cross-language functionality.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: We provided a comprehensive example using a `MessageSender` class, illustrating
    how to create a C++ library and its corresponding C wrapper. The example emphasized
    safe memory management by ensuring allocation and deallocation within the same
    binary and handling exceptions gracefully by representing them with an enumerated
    status in the C interface.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: By following these guidelines, developers can create robust, maintainable, and
    widely compatible shared libraries, ensuring their usability across various platforms
    and programming environments. This chapter equips developers with the necessary
    knowledge to address common caveats and implement best practices in shared library
    development, fostering effective and reliable software solutions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些指南，开发者可以创建健壮、可维护且广泛兼容的共享库，确保它们在各种平台和编程环境中的可用性。本章为开发者提供了解决常见问题并在共享库开发中实施最佳实践所需的知识，从而培养出有效且可靠的软件解决方案。
- en: In the next chapter, we will shift our focus to code formatting, exploring best
    practices for creating clear, consistent, and readable code, which is essential
    for collaboration and long-term maintenance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们的重点转向代码格式化，探讨创建清晰、一致和可读代码的最佳实践，这对于协作和长期维护至关重要。
