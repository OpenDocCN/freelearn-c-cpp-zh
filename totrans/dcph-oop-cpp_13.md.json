["```cpp\nclass ArrayInt\n{\nprivate: \n    int numElements = 0;     // in-class initialization\n    int *contents = nullptr; // dynamically allocated array\npublic:\n    ArrayInt(int size): numElements(size) \n    { \n        contents = new int [size];\n    }\n    ~ArrayInt() { delete [] contents; }       \n    int &operator[](int index) // returns a referenceable\n    {                // memory location or throws exception\n        if (index < numElements) \n            return contents[index];\n        else         // index selected is out of bounds\n            throw std::out_of_range(std::to_string(index));\n    }                                \n};\nint main()\n{\n    ArrayInt a1(5); // Create an ArrayInt of 5 elements\n    try    // operator[] could throw an exception\n    {\n        a1[4] = 7;      // a1.operator[](4) = 7;\n    }\n    catch (const std::out_of_range &e)\n    {\n        cout << \"Out of range: element \" << e.what();\n        cout << endl;\n    }\n}   \n```", "```cpp\n// template function prototype\ntemplate <class Type1, class Type2>   // template preamble\nType2 ChooseFirst(Type1, Type2);\n// template function definition\ntemplate <class Type1, class Type2>  // template preamble\nType2 ChooseFirst(Type1 x, Type2 y)\n{\n    if (x < y) \n        return static_cast<Type2>(x);\n    else \n        return y; \n}   \nint main()\n{\n    int value1 = 4, value2 = 7;\n    float value3 = 5.67f;\n    cout << \"First: \" << ChooseFirst(value1, value3); \n    cout << endl;\n    cout << \"First: \" << ChooseFirst(value2, value1); \n    cout << endl;\n}\n```", "```cpp\nFirst: 4\nFirst: 4\n```", "```cpp\ntemplate <class Type>   // template class preamble\nclass Array\n{\nprivate:\n    int numElements = 0;   // in-class initialization\n    Type *contents = nullptr;// dynamically allocated array\npublic:\n    // Constructor and destructor will allocate, deallocate\n    // heap memory to allow Array to be fluid in its size.\n    // Later, you can use a smart pointer – or use the STL\n    // vector class (we're building a similar class here!)\n    Array(int size): numElements(size), \n                     contents(new Type [size])\n    { // note: allocation is handled in member init. list\n    }\n    ~Array() { delete [] contents; }  \n    void Print() const;     \n    Type &operator[](int index) // returns a referenceable\n    {               // memory location or throws exception\n        if (index < numElements) \n            return contents[index];\n        else   // index is out of bounds\n            throw std::out_of_range\n                             (std::to_string (index));    \n    }                                \n    void operator+(Type);   // prototype only\n};\ntemplate <class Type>\nvoid Array<Type>::operator+(Type item)  \n{\n    // resize array as necessary, add new data element and\n    // increment numElements\n}\ntemplate <class Type>\nvoid Array<Type>::Print() const\n{\n    for (int i = 0; i < numElements; i++)\n        cout << contents[i] << \" \";\n    cout << endl;\n}\nint main()\n{                    \n    // Creation of int Array will trigger template\n    // expansion by the preprocessor.\n    Array<int> a1(3); // Create an int Array of 3 elements\n    try    // operator[] could throw an exception\n    {\n        a1[2] = 12;      \n        a1[1] = 70;       // a1.operator[](1) = 70;\n        a1[0] = 2;\n        a1[100] = 10;// this assignment throws an exception\n    }\n    catch (const std::out_of_range &e)\n    {\n        cout << \"Out of range: index \" << e.what() << endl;\n    } \n    a1.Print();\n}   \n```", "```cpp\n2 70 12\n```", "```cpp\n#include <iostream>\nusing std::cout;   // preferred to: using namespace std;\nusing std::endl;\n// forward declaration with template preamble\ntemplate <class Type> class LinkList;  \ntemplate <class Type>   // template preamble for class def.\nclass LinkListElement\n{\nprivate:\n    Type *data = nullptr;\n    LinkListElement *next = nullptr;\n    // private access methods to be used in scope of friend\n    Type *GetData() const { return data; } \n    LinkListElement *GetNext() const { return next; }\n    void SetNext(LinkListElement *e) { next = e; }\npublic:\n    friend class LinkList<Type>;   \n    LinkListElement() = default;\n    LinkListElement(Type *i): data(i), next(nullptr) { }\n    ~LinkListElement(){ delete data; next = nullptr; }\n};\n// LinkList should only be extended as a protected/private\n// base class; it does not contain a virtual destructor. It\n// can be used as-is, or as implementation for another ADT.\ntemplate <class Type>\nclass LinkList\n{\nprivate:\n    LinkListElement<Type> *head = nullptr, *tail = nullptr,\n                                 *current = nullptr;\npublic:\n    LinkList() = default;\n    LinkList(LinkListElement<Type> *e) \n        { head = tail = current = e; }\n    void InsertAtFront(Type *);\n    LinkListElement<Type> *RemoveAtFront();  \n    void DeleteAtFront()  { delete RemoveAtFront(); }\n    bool IsEmpty() const { return head == nullptr; } \n    void Print() const;    \n    ~LinkList(){ while (!IsEmpty()) DeleteAtFront(); }\n};\n```", "```cpp\ntemplate <class Type>     // template preamble\nvoid LinkList<Type>::InsertAtFront(Type *theItem)\n{\n    LinkListElement<Type> *newHead = nullptr;\n    newHead = new LinkListElement<Type>(theItem);\n    newHead->SetNext(head);  // newHead->next = head;\n    head = newHead;\n}\ntemplate <class Type>    // template preamble\nLinkListElement<Type> *LinkList<Type>::RemoveAtFront()\n{\n    LinkListElement<Type> *remove = head;\n    head = head->GetNext();  // head = head->next;\n    current = head;    // reset current for usage elsewhere\n    return remove;\n}\n\ntemplate <class Type>    // template preamble\nvoid LinkList<Type>::Print() const\n{\n    if (!head)\n        cout << \"<EMPTY>\" << endl;\n    LinkListElement<Type> *traverse = head;\n    while (traverse)\n    {\n        Type output = *(traverse->GetData());\n        cout << output << ' ';\n        traverse = traverse->GetNext();\n    }\n    cout << endl;\n}\n```", "```cpp\nint main()\n{\n    LinkList<int> list1;  // create a LinkList of integers\n    list1.InsertAtFront(new int (3000));\n    list1.InsertAtFront(new int (600));\n    list1.InsertAtFront(new int (475));\n    cout << \"List 1: \";\n    list1.Print();\n    // delete elements from list, one by one\n    while (!(list1.IsEmpty()))\n    {\n       list1.DeleteAtFront();\n       cout << \"List 1 after removing an item: \";\n       list1.Print();\n    }\n    LinkList<float> list2;  // create a LinkList of floats\n    list2.InsertAtFront(new float(30.50));\n    list2.InsertAtFront(new float (60.89));\n    list2.InsertAtFront(new float (45.93));\n    cout << \"List 2: \";\n    list2.Print();\n}\n```", "```cpp\nList 1: 475 600 3000\nList 1 after removing an item: 600 3000\nList 1 after removing an item: 3000\nList 1 after removing an item: <EMPTY>\nList 2: 45.93 60.89 30.5\n```", "```cpp\ntemplate <class Type>\nvoid LinkList<Type>::OrderedInsert(Type *theItem)\n{\n    current = head;    \n    if (*theItem < *(head->GetData()))  \n        InsertAtFront(theItem);  // add theItem before head\n    else\n        // Traverse list, add theItem in proper location\n}\n```", "```cpp\n// overload operator < As a member function of Student\nbool Student::operator<(const Student &s)\n{   // if this->gpa < s.gpa return true, else return false\n    return this->gpa < s.gpa;\n}\n// OR, overload operator < as a non-member function\nbool operator<(const Student &s1, const Student &s2)\n{   // if s1.gpa < s2.gpa return true, else return false\n    return s1.gpa < s2.gpa;\n}\n```"]