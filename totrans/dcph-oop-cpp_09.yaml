- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Exploring Multiple Inheritance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索多重继承
- en: This chapter will continue broadening our knowledge of object-oriented programming
    in C++. We will begin by examining a controversial OO concept, **multiple inheritance**
    (**MI**), understanding why it is controversial, how it can reasonably be used
    to support OO designs, as well as when alternative designs may be more appropriate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续扩展我们对C++面向对象编程的知识。我们将从检查一个有争议的面向对象概念——**多重继承**（**MI**）开始，理解为什么它是有争议的，以及它如何合理地支持面向对象设计，以及何时替代设计可能更为合适。
- en: Multiple inheritance can be implemented in C++ with *direct language support*.
    In doing so, we will be faced with several OO design issues. We will be asked
    to critically evaluate an inheritance hierarchy, asking ourselves whether we are
    using the best design possible to represent a potential set of object relationships.
    Multiple inheritance can be a powerful OOP tool; using it wisely is paramount.
    We will learn when to use MI to sensibly extend our hierarchies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，可以通过直接的语言支持来实现多重继承。在这样做的时候，我们将面临几个面向对象设计的问题。我们将被要求批判性地评估继承层次结构，问自己我们是否正在使用可能的最优设计来表示一组潜在的对象关系。多重继承可以是一个强大的面向对象工具；明智地使用它是至关重要的。我们将学习何时使用多重继承来合理地扩展我们的层次结构。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding multiple inheritance mechanics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多重继承的机制
- en: Examining reasonable uses for multiple inheritance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查多重继承的合理用途
- en: Creating diamond-shaped hierarchies and exploring issues arising from their
    usage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建菱形层次结构并探讨其使用中产生的问题
- en: Using virtual base classes to resolve diamond-shaped hierarchy duplication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟基类来解决菱形层次结构的重复问题
- en: Applying discriminators to evaluate the worthiness of a diamond-shaped hierarchy
    and MI in a design, as well as considering design alternatives
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将判别器应用于评估菱形层次结构和设计中的MI的价值，以及考虑设计替代方案
- en: By the end of this chapter, you will understand the OO concept of multiple inheritance,
    and how to implement this idea in C++. You will understand not only the simple
    mechanics of MI but the reasons for its usage (mix-in, Is-A or controversially,
    Has-A).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解面向对象的多个继承概念，以及如何在C++中实现这一想法。你将不仅理解MI的简单机制，还将理解其使用的理由（混入、Is-A或具有争议的Has-A）。
- en: You will see why MI is controversial in OOP. Having more than one base class
    can lead to oddly shaped hierarchies, such as diamond-shaped; these types of hierarchies
    come with potential implementation issues. We will see how C++ incorporates a
    language feature (virtual base classes) to solve these conundrums, but the solution
    is not always ideal.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到为什么多重继承在面向对象编程中是有争议的。拥有多个基类可能导致形状奇特的层次结构，如菱形；这类层次结构可能带来潜在的实现问题。我们将看到C++如何通过语言特性（虚拟基类）来解决这些难题，但解决方案并不总是理想的。
- en: Once we understand the complexities caused by multiple inheritance, we will
    use OO design metrics, such as discriminators, to evaluate whether a design using
    MI is the best solution to represent a set of object relationships. We’ll look
    at alternative designs, and you will then be better equipped to understand not
    only what multiple inheritance is, but when it’s best utilized. Let us expand
    our understanding of C++ as a *“you can do anything”* OOP language by moving forward
    with MI.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了由多重继承引起的复杂性，我们将使用面向对象设计的度量标准，例如判别器，来评估使用多重继承的设计是否是表示一组对象关系的最佳解决方案。我们将探讨替代设计，这样你将更好地理解多重继承是什么，以及在何时使用它最为合适。让我们通过前进使用多重继承来扩展我们对C++作为“你可以做任何事情”的面向对象语言的了解。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter09](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter09).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter09`
    in a file named `Chp9-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL中找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter09](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter09)。每个完整程序示例都可以在GitHub的相应章节标题（子目录）下找到，对应于章节编号，后面跟着一个连字符，然后是当前章节中的示例编号。例如，本章的第一个完整程序可以在上述GitHub目录下的`Chapter09`子目录中找到一个名为`Chp9-Ex1.cpp`的文件。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3Cbqt7y](https://bit.ly/3Cbqt7y).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下链接查看：[https://bit.ly/3Cbqt7y](https://bit.ly/3Cbqt7y)。
- en: Understanding multiple inheritance mechanics
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多重继承机制
- en: In C++, a class can have more than one immediate base class. This is known as
    **multiple inheritance**, and is a very controversial topic in both OO designs
    and OOP. Let’s begin with the simple mechanics; we will then move forward to the
    design issues and programming logistics surrounding MI during the progression
    of this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，一个类可以有一个以上的直接基类。这被称为**多重继承**，在面向对象设计和面向对象编程中都是一个非常有争议的话题。让我们从简单的机制开始；然后我们将在本章的进展过程中讨论MI的设计问题和编程逻辑。
- en: With multiple inheritance, the derived class specifies who each of its immediate
    ancestors or base classes are, using the base class list in its class definition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重继承中，派生类通过其类定义中的基类列表指定了其每个直接祖先或基类是谁。
- en: 'In a similar fashion to single inheritance, the constructors and destructors
    are invoked all the way up the hierarchy as objects of the derived class type
    are instantiated and destroyed. Reviewing and expanding upon the subtleties of
    construction and destruction for MI, we are reminded of the following logistics:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与单继承类似，当派生类类型的对象被实例化和销毁时，构造函数和析构函数会一直向上遍历层次结构。回顾和扩展MI的构造和析构的细微差别，我们会想起以下逻辑：
- en: The calling sequence for a constructor starts with the derived class, but immediately
    passes control to a base constructor, and so on up the hierarchy. Once the calling
    sequence passes control to the top of the hierarchy, the execution sequence begins.
    All the highest-level base class constructors at the same level are first executed,
    and so on down the hierarchy until we arrive at the derived class constructor,
    whose body is executed last in the construction chain.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数的调用序列从派生类开始，但立即将控制权传递给基类构造函数，依此类推向上传递。一旦调用序列将控制权传递到层次结构的顶部，执行序列开始。在同一级别的所有最高级基类构造函数首先执行，依此类推向下遍历层次结构，直到我们到达派生类构造函数，其主体在构造链中最后执行。
- en: The derived class destructor is invoked and executed first, followed by all
    the immediate base class destructors and so on, as we progress up the inheritance
    hierarchy.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类的析构函数首先被调用并执行，然后是所有直接基类的析构函数，依此类推，随着我们向上遍历继承层次结构。
- en: The member initialization list in the derived class constructor may be used
    to specify which constructor for each immediate base class should be invoked.
    In the absence of this specification, the default constructor will be used for
    that base class’ constructor.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类构造函数中的成员初始化列表可以用来指定每个直接基类应该调用哪个构造函数。如果没有指定，将使用该基类的默认构造函数。
- en: 'Let’s take a look at a typical multiple inheritance example to implement a
    quintessential application of MI from an OO design, as well as to understand basic
    MI syntax in C++. This example will be broken into many segments; the full program
    can be found in the following GitHub location:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个典型的多重继承示例，以实现从面向对象设计角度的一个典型的MI应用，以及理解C++中的基本MI语法。这个例子将被分成多个部分；完整的程序可以在以下GitHub位置找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex1.cpp)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code segment, we have an expected class definition for `Person`,
    containing the class elements that we are accustomed to defining.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们有一个预期的 `Person` 类定义，其中包含我们习惯于定义的类元素。
- en: 'Next, let’s see the accompanying member functions for this class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这个类的伴随成员函数：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous segment of code, the member function definitions for `Person`
    are as expected. Nonetheless, it is useful to see the `Person` class defined,
    as this class will serve as a building block, and portions of it will be directly
    accessed in upcoming code segments.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，`Person` 类的成员函数定义正如预期的那样。然而，查看 `Person` 类的定义是有用的，因为这个类将作为构建块，其部分内容将在接下来的代码段中直接访问。
- en: 'Now, let’s define a new class, `BillableEntity`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个新的类，`BillableEntity`：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous `BillableEntity` class, we define a class containing simple
    functionality to encapsulate a billing structure. That is, we have an invoice
    amount and methods such as `Pay()` and `GetBalance()`. Notice that the copy constructor
    indicates `= delete` in its prototype; this will prohibit copies, which seems
    appropriate given the nature of this class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 `BillableEntity` 类中，我们定义了一个包含简单功能以封装计费结构的类。也就是说，我们有一个发票金额和 `Pay()` 和 `GetBalance()`
    等方法。注意，复制构造函数在其原型中指示 `= delete`；这将会禁止复制，考虑到这个类的性质，这似乎是合适的。
- en: 'Next, let’s combine the two aforementioned base classes, `Person` and `BillableEntity`,
    to serve as base classes for our `Student` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将上述两个基类 `Person` 和 `BillableEntity` 结合起来，作为 `Student` 类的基类：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding class definition for `Student`, two public base classes, `Person`
    and `BillableEntity`, are specified in the base class list for `Student`. These
    two base classes are merely comma-separated in the `Student` base class list.
    We have also included the inline function definitions with the class definition,
    as these are usually bundled together in a header file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Student` 的先前类定义中，在 `Student` 的基类列表中指定了两个公共基类，`Person` 和 `BillableEntity`。这两个基类在
    `Student` 的基类列表中仅以逗号分隔。我们还在类定义中包含了内联函数定义，因为这些通常与头文件一起打包。
- en: 'Let’s further see what accommodations must be made in the remainder of the
    `Student` class by examining its member functions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步看看通过检查其成员函数，`Student` 类剩余部分需要做出哪些调整：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s consider the previous code segment. In the default constructor for `Student`,
    due to the lack of base class constructor specification in the member initialization
    list, the default constructors will be called for both the `Person` and `BillableEntity`
    base classes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑之前的代码段。在 `Student` 的默认构造函数中，由于成员初始化列表中缺少基类构造函数的指定，将调用 `Person` 和 `BillableEntity`
    基类的默认构造函数。
- en: However, notice that in the alternate `Student` constructor, we merely comma-separate
    our two base class constructor choices in the member initialization list – that
    is, `Person(const string &, const string &, char, const string &)` and `BillableEntity(float)`
    – and then pass various parameters from the `Student` constructor to the base
    class constructors using this list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在 `Student` 的替代构造函数中，我们只是在成员初始化列表中用逗号分隔我们的两个基类构造函数选择——即 `Person(const
    string &, const string &, char, const string &)` 和 `BillableEntity(float)`——然后使用此列表将各种参数从
    `Student` 构造函数传递到基类构造函数。
- en: 'Finally, let’s take a look at our `main()` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看我们的 `main()` 函数：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In our `main()` function in the previous code, we instantiate several `Student`
    instances. Notice that `Student` instances can utilize any methods in the public
    interface of `Student`, `Person`, or `BillableEntity`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中的 `main()` 函数中，我们创建了几个 `Student` 实例。注意，`Student` 实例可以利用 `Student`、`Person`
    或 `BillableEntity` 的公共接口中的任何方法。
- en: 'Let’s look at the output for the aforementioned program:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上述程序的输出：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice the destruction sequence in the aforementioned output. We can see each
    `Student` instance invokes the `Student` destructor, as well as the destructors
    for each base class (`BillableEntity` and `Person`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上述输出中的销毁顺序。我们可以看到每个 `Student` 实例调用了 `Student` 析构函数，以及每个基类（`BillableEntity`
    和 `Person`）的析构函数。
- en: We have now seen the language mechanics for MI with a typically implemented
    OO design. Now, let’s move forward by looking at the typical reasons for employing
    multiple inheritance in OO designs, some of which are more widely accepted than
    others.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了使用典型实现的面向对象（OO）设计进行MI的语言机制。现在，让我们通过查看在OO设计中采用多重继承的典型原因来继续前进，其中一些原因比其他原因更广泛地被接受。
- en: Examining reasonable uses for multiple inheritance
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查多重继承的合理用途
- en: Multiple inheritance is a controversial concept that arises when creating OO
    designs. Many OO designs avoid MI; other designs embrace it with strict usage.
    Some OOP languages, such as Java, do not explicitly provide direct language support
    for multiple inheritance. Instead, they offer interfaces, such as we’ve modeled
    in C++ by creating interface classes using abstract classes (restricted to containing
    only pure virtual functions) in [*Chapter 8*](B19087_08.xhtml#_idTextAnchor399),
    *Mastering Abstract Classes*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承是一个在创建OO设计时出现的有争议的概念。许多OO设计避免使用MI；其他设计则严格地接受它。一些面向对象编程语言，如Java，不提供直接的语言支持来明确支持多重继承。相反，它们提供接口，例如我们在C++中通过创建使用抽象类（仅包含纯虚拟函数）的接口类来模拟（见[*第8章*](B19087_08.xhtml#_idTextAnchor399)，*掌握抽象类*）。
- en: Of course, in C++, inheriting from two interface classes is still a use of multiple
    inheritance. Though C++ does not include interface classes within the language,
    this concept can be simulated by employing a more restrictive use of MI. For example,
    we can programmatically streamline abstract classes to include only pure virtual
    functions (no data members, and no member functions with definitions) to mimic
    the OO design idea of an interface class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在C++中，从两个接口类继承仍然是多重继承的一种用法。尽管C++语言本身不包含接口类，但可以通过更限制性的MI使用来模拟这个概念。例如，我们可以通过编程简化抽象类，只包含纯虚拟函数（没有数据成员，也没有带定义的成员函数），以模仿接口类的面向对象设计理念。
- en: Typical MI conundrums form the basis of why MI is contentious in OOP. Classic
    MI quandaries will be detailed in this chapter and can be avoided by restricting
    MI to the usage of interface classes only, or through a redesign. This is why
    some OOP languages only support interface classes versus allowing unrestricted
    MI. In C++, you can carefully consider each OO design and choose when to utilize
    MI, when to utilize a restrictive form of MI (interface classes), or when to employ
    a redesign eliminating MI.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的MI难题是为什么MI在面向对象编程（OOP）中存在争议的基础。本章将详细阐述经典的MI难题，并通过仅限制MI用于接口类或通过重新设计来避免这些问题。这就是为什么一些面向对象编程语言只支持接口类，而不是允许无限制的MI。在C++中，你可以仔细考虑每个OO设计，并选择何时利用MI，何时利用限制性MI（接口类），或何时采用消除MI的重新设计。
- en: C++ is a *“you can do anything”* programming language. As such, C++ allows multiple
    inheritance without restrictions or reservations. As an OO programmer, we will
    look more closely at typical reasons to embrace MI. As we move further into this
    chapter, we will evaluate issues that arise by using MI and see how C++ solves
    these issues with additional language features. These MI issues will allow us
    to then apply metrics to understand more reasonably when we should use MI and
    when a redesign may be more appropriate.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种*“你可以做任何事情”*的编程语言。因此，C++允许无限制地使用多重继承。作为一个面向对象程序员，我们将更仔细地研究接受MI的典型原因。随着我们进一步进入本章，我们将评估使用MI时出现的问题，并了解C++如何通过额外的语言特性来解决这些问题。这些MI问题将使我们能够应用度量标准，以更合理地了解何时应该使用MI，何时重新设计可能更合适。
- en: Let’s begin our pursuit of reasonable uses of MI by considering Is-A and mix-in
    relationships, and then move to examining the controversial use of MI to implement
    Has-A relationships.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑Is-A和mix-in关系来开始我们对MI合理使用的追求，然后转向检查MI在实现Has-A关系方面的有争议的使用。
- en: Supporting Is-A and mix-in relationships
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持Is-A和mix-in关系
- en: As we have learned with single inheritance, an Is-A relationship is most often
    used to describe the relationship between two inherited classes. For example,
    a `Student` *Is-A* `Person`. The same desired ideal continues with MI; Is-A relationships
    are the primary motivations to specify inheritance. In pure OO designs and programming,
    inheritance should be used only to support Is-A relationships.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们通过单继承所学习的，Is-A关系最常用来描述两个继承类之间的关系。例如，一个`Student`是`Person`的子类。在MI中，这种理想继续存在；Is-A关系是指定继承的主要动机。在纯面向对象设计和编程中，继承应该仅用于支持Is-A关系。
- en: Nonetheless, as we have learned when we looked at interface classes (a concept
    modeled in C++ using abstract classes with the restriction of containing only
    pure virtual functions), mix-in relationships often apply when we inherit from
    an interface. Recall that a mix-in relationship is when we use inheritance to
    mix-in the functionality of another class, simply because that functionality is
    useful or meaningful for the derived class to have. The base class need not be
    an abstract or interface class, but employing an ideal OO design, it would be
    as such.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，正如我们在查看接口类（在C++中使用具有仅包含纯虚函数的限制的抽象类来建模的概念）时所学到的那样，当我们从接口继承时，混入关系通常适用。回想一下，混入关系是我们使用继承来混入另一个类的功能，仅仅因为这种功能对派生类来说是有用或有意义的。基类不必是抽象类或接口类，但采用理想的面向对象设计，它应该是这样的。
- en: The mix-in base class represents a class in which an Is-A relationship does
    not apply. Mix-ins exist more so with multiple inheritance, at least as the reason
    supporting the necessity of one of the (many) base classes. Since C++ has direct
    language support for multiple inheritance, MI can be used to support implementing
    mix-ins (whereas languages such as Java may only use interface classes). In practice,
    MI is often used to inherit from one class to support an Is-A relationship and
    to also inherit from another class to support a mix-in relationship. In our last
    example, we saw that a `Student` *Is-A* `Person`, and a `Student` chooses to *mix-in*
    `BillableEntity` capabilities.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 混入基类代表了一个其中不适用“是”关系的类。混入在多重继承中更为常见，至少作为支持（许多）基类之一的必要性的原因。由于C++直接支持多重继承，MI可以用来支持实现混入（而像Java这样的语言可能只能使用接口类）。在实践中，MI通常用于从一个类继承以支持“是”关系，并从另一个类继承以支持混入关系。在我们最后的例子中，我们看到一个`Student`是`Person`，并且`Student`选择混入`BillableEntity`的能力。
- en: Reasonable uses of MI in C++ include supporting both Is-A and mix-in relationships;
    however, our discussion would not be complete without next considering an unusual
    use of MI – implementing Has-A relationships.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C++中MI的合理用途包括支持“是”和混入关系；然而，如果没有接下来考虑MI的非常规用途——实现“拥有”关系，我们的讨论就不会完整。
- en: Supporting Has-A relationships
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持“拥有”关系
- en: Less commonly, and much more controversially, MI can be used to implement a
    Has-A relationship, that is, to model containment, or a whole versus part relationship.
    We will see in [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454), *Implementing
    Association, Aggregation, and Composition*, a more widely accepted implementation
    for Has-A relationships; however, MI provides a very simple implementation. Here,
    the parts serve as the base classes. The whole inherits from the parts, automatically
    including the parts in its memory layout (and also automatically inheriting the
    parts’ members and functionality).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不太常见且更具争议性的是，MI可以用来实现“拥有”关系，即建模包含或整体与部分的关系。我们将在[*第10章*](B19087_10.xhtml#_idTextAnchor454)，“实现关联、聚合和组合”中看到，对于“拥有”关系有一个更广泛接受的实现；然而，如果没有接下来考虑MI的非常规用途——实现“拥有”关系，我们的讨论就不会完整。
- en: For example, a `Student` *Is-A* `Person` and a `Student` *Has-A(n)* `Id`; the
    usage of the second base class (`Id`) is for containment. `Id` will serve as a
    base class and `Student` will be derived from `Id` to factor in all that an `Id`
    offers. The `Id` public interface is immediately usable to `Student`. In fact,
    any class that inherits from `Id` will inherit a uniform interface when utilizing
    its `Id` parts. This simplicity is a driving reason why inheritance is sometimes
    used to model containment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个`Student`是`Person`的实例，并且一个`Student`拥有一个`Id`；第二个基类（`Id`）的使用是为了包含。`Id`将作为基类，`Student`将从`Id`派生出来，以利用`Id`提供的一切。`Id`的公共接口可以直接用于`Student`。实际上，任何从`Id`继承的类在利用其`Id`部分时都会继承一个统一接口。这种简单性是继承有时被用来建模包含的一个驱动因素。
- en: However, using inheritance to implement Has-A relationships can cause unnecessary
    usage of MI, which can then complicate an inheritance hierarchy. Unnecessary usage
    of MI is the primary reason why using inheritance to model Has-A relationships
    is very controversial and is quite frankly frowned upon in pure OO designs. Nonetheless,
    we mention it because you will see some C++ applications using MI for Has-A implementation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用继承来实现Has-A关系可能会导致不必要的MI（多继承）使用，这可能会使继承层次结构复杂化。使用继承来模拟Has-A关系之所以非常具有争议，并且坦率地说在纯面向对象设计中不受欢迎，主要是因为这种不必要的MI使用。尽管如此，我们还是要提到这一点，因为你会看到一些C++应用程序使用MI来实现Has-A。
- en: Let’s move forward to explore other controversial designs employing MI, namely
    that of a diamond-shaped hierarchy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索使用MI的其他具有争议的设计，即菱形层次结构。
- en: Creating a diamond-shaped hierarchy
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建菱形层次结构
- en: When using multiple inheritance, sometimes it is tempting to utilize sibling
    (or cousin) classes as base classes for a new derived class. When this happens,
    the hierarchy is no longer a tree in shape, but rather, a graph containing a *diamond*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多继承时，有时会诱使人们使用兄弟（或堂兄弟）类作为新派生类的基类。当这种情况发生时，层次结构就不再是树形，而是一个包含*菱形*的图。
- en: Whenever an object of the derived class type is instantiated in such a situation,
    two copies of the common base class will be present in the instance of the derived
    class. Duplication of this sort obviously wastes space. Additional time is also
    wasted by calling duplicate constructors and destructors for this repeated subobject
    and by maintaining two parallel copies of a subobject (most likely unnecessarily).
    Ambiguities also result when trying to access members from this common base class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每当派生类类型的对象被实例化时，派生类实例中都将存在两个公共基类的副本。这种类型的复制显然会浪费空间。此外，调用重复子对象的重复构造函数和析构函数，以及维护子对象的两个并行副本（很可能是不必要的），也会浪费额外的时间。尝试从该公共基类访问成员时，也会产生歧义。
- en: 'Let’s see an example detailing this issue, starting with abbreviated (and simplified)
    class definitions of `LifeForm`, `Horse`, and `Person`. Though only portions of
    the full program example are shown, the program in its entirety can be found in
    our GitHub as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例详细说明这个问题，从`LifeForm`、`Horse`和`Person`的简化和（故意）不完整的类定义开始。尽管只显示了完整程序示例的部分，但整个程序可以在我们的GitHub上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex2.cpp)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex2.cpp)'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous fragment of code shows skeleton class definitions for `LifeForm`,
    `Person`, and `Horse`. Each class shows a default constructor, which merely serves
    as an example to show how `lifeExpectancy` is set for each class. In the default
    constructors for `Person` and `Horse`, the member initialization list is used
    to pass a value of `35` (`HORSE_LIFE`) or `80` (`PERSON_LIFE`) to the `LifeForm`
    constructor to set this value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段显示了`LifeForm`、`Person`和`Horse`的骨架类定义。每个类都显示了一个默认构造函数，它仅作为示例，展示如何为每个类设置`lifeExpectancy`。在`Person`和`Horse`的默认构造函数中，使用成员初始化列表将`35`（`HORSE_LIFE`）或`80`（`PERSON_LIFE`）的值传递给`LifeForm`构造函数，以设置此值。
- en: Though the previous class definitions are abbreviated (that is, purposely incomplete)
    to save space, let’s assume that each class has appropriate additional constructors
    defined, an appropriate destructor, and other necessary member functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然之前的类定义被简略了（也就是说，故意不完整）以节省空间，但让我们假设每个类都有适当的额外构造函数定义、适当的析构函数和其他必要的成员函数。
- en: 'We notice that `LifeForm` is an abstract class, in that it offers pure virtual
    functions: `Print()`, `IsA()`, and `Speak()`. Both `Horse` and `Person` are concrete
    classes and will be instantiable because they override these pure virtual functions
    with virtual functions. These virtual functions are shown inline, only to make
    the code compact for viewing (virtual functions will almost never be inlined by
    the compiler as their methods are nearly always determined at runtime).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到`LifeForm`是一个抽象类，因为它提供了纯虚函数：`Print()`、`IsA()`和`Speak()`。`Horse`和`Person`都是具体类，并且因为它们用虚函数覆盖了这些纯虚函数，所以将是可实例化的。这些虚函数仅内联显示，目的是为了使代码在查看时更紧凑（编译器几乎永远不会内联虚函数，因为它们的函数方法几乎总是在运行时确定）。
- en: 'Next, let’s look at a new derived class that will introduce the graph, or diamond
    shape, in our hierarchy:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个将引入图中或菱形形状的新派生类：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous fragment, we define a new class, `Centaur`, using multiple inheritance.
    At first glance, we truly do mean to assert the Is-A relationship between `Centaur`
    and `Person`, and also between `Centaur` and `Horse`. However, we’ll soon challenge
    our assertion to test whether it is more of a combination than a true Is-A relationship.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们使用多重继承定义了一个新的类 `Centaur`。乍一看，我们确实意味着要断言 `Centaur` 和 `Person` 之间，以及
    `Centaur` 和 `Horse` 之间的 Is-A 关系。然而，我们很快就会挑战我们的断言，以测试它是否更多的是一种组合而不是真正的 Is-A 关系。
- en: We will assume that all of the necessary constructors, the destructor, and member
    functions exist to make `Centaur` a well-defined class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设所有必要的构造函数、析构函数和成员函数都存在，以便使 `Centaur` 成为一个定义良好的类。
- en: 'Now, let’s move forward to look at a potential `main()` function we might utilize:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续前进，看看我们可能使用的潜在 `main()` 函数：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, in `main()`, we instantiate a `Centaur` and we name the instance `beast`.
    We easily call two polymorphic operations on `beast`, namely `Speak()` and `IsA()`.
    Then we try to call the public inherited `GetLifeExpectancy()`, which is defined
    in `LifeForm`. Its implementation is included in `Lifeform` so that `Person`,
    `Horse`, or `Centaur` do not need to provide a definition (nor should they – it’s
    not a virtual function meant to be redefined).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在 `main()` 中，我们实例化了一个 `Centaur` 并将其命名为 `beast`。我们很容易在 `beast` 上调用两个多态操作，即
    `Speak()` 和 `IsA()`。然后我们尝试调用从 `LifeForm` 继承的公共 `GetLifeExpectancy()`，它在 `LifeForm`
    中定义。其实现包含在 `Lifeform` 中，这样 `Person`、`Horse` 或 `Centaur` 就不需要提供定义（也不应该提供定义——它不是一个虚拟函数，意味着要被重定义）。
- en: Unfortunately, calls to `GetLifeExpectancy()` via `Centaur` instances are ambiguous.
    This is because there are two `LifeForm` subobjects in the `beast` instance. Remember,
    `Centaur` is derived from `Horse`, which is derived from `LifeForm`, providing
    the memory layout for all the aforementioned base class data members (`Horse`
    and `LifeForm`). And `Centaur` is also derived from `Person`, which is derived
    from `Lifeform`, which contributes the memory layout for `Person` and `LifeForm`
    within `Centaur`. The `LifeForm` piece is duplicated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，通过 `Centaur` 实例调用 `GetLifeExpectancy()` 是有歧义的。这是因为 `beast` 实例中有两个 `LifeForm`
    子对象。记住，`Centaur` 是从 `Horse` 继承的，而 `Horse` 是从 `LifeForm` 继承的，为所有上述基类数据成员（`Horse`
    和 `LifeForm`）提供了内存布局。而 `Centaur` 也从 `Person` 继承，而 `Person` 是从 `Lifeform` 继承的，这为
    `Centaur` 中的 `Person` 和 `LifeForm` 提供了内存布局。`LifeForm` 部分是重复的。
- en: There are two copies of the inherited data member `int lifeExpectancy;`. There
    are two subobjects of `LifeForm` within the `Centaur` instance. Therefore, when
    we try to call `GetLifeExpectancy()` through the `Centaur` instance, the method
    call is ambiguous. Which `lifeExpectancy` are we trying to initialize? Which `LifeForm`
    subobject will serve as the `this` pointer when `GetLifeExpectancy()` is called?
    It is simply not clear, so the compiler will not choose for us.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个 `int lifeExpectancy;` 继承数据成员的副本。在 `Centaur` 实例中有两个 `LifeForm` 子对象。因此，当我们尝试通过
    `Centaur` 实例调用 `GetLifeExpectancy()` 时，方法调用是有歧义的。我们试图初始化哪个 `lifeExpectancy`？当调用
    `GetLifeExpectancy()` 时，哪个 `LifeForm` 子对象将作为 `this` 指针？这很简单，所以编译器不会为我们选择。
- en: To disambiguate the `GetLifeExpectancy()` function call, we must use the scope
    resolution operator. We precede the `::` operator with the intermediate base class
    from which we want the `LifeForm` subobject. Notice that we call, for example,
    `beast.Horse::GetLifeExpectancy()` to choose the `lifeExpectancy` from the `Horse`
    subobject’s path, which will include `LifeForm`. This is awkward, as neither `Horse`
    nor `Person` includes the ambiguous member; `lifeExpectancy` is found in `LifeForm`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除对 `GetLifeExpectancy()` 函数调用的歧义，我们必须使用作用域解析运算符。我们在 `::` 运算符之前加上我们想要从中获取
    `LifeForm` 子对象的中间基类。请注意，例如，我们调用 `beast.Horse::GetLifeExpectancy()` 来选择来自 `Horse`
    子对象路径的 `lifeExpectancy`，这将包括 `LifeForm`。这是尴尬的，因为 `Horse` 和 `Person` 都不包括这个有歧义的成员；`lifeExpectancy`
    在 `LifeForm` 中。
- en: 'Let’s consider the output for the aforementioned program:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑上述程序的结果：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that designing a hierarchy that includes a diamond shape has drawbacks.
    These conundrums include programming ambiguities that need to be resolved in an
    awkward fashion, duplication in memory of repeated subobjects, plus time to construct
    and destruct these duplicate subobjects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，设计包含菱形形状的层次结构有缺点。这些难题包括需要以尴尬方式解决的编程歧义，重复子对象的内存重复，以及构建和销毁这些重复子对象的时间。
- en: Luckily, C++ has a language feature to alleviate these hardships with diamond-shaped
    hierarchies. After all, C++  is a language that will allow us to do anything.
    Knowing when and whether we should utilize these features is another concern.
    Let’s first take a look at the C++ language solution to deal with diamond-shaped
    hierarchies and their inherent problems by looking at virtual base classes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C++有一个语言特性可以减轻这些困难，特别是对于具有菱形层次结构的情况。毕竟，C++是一种允许我们做任何事的强大语言。知道何时以及是否应该利用这些特性是另一个问题。让我们首先看看C++语言如何通过查看虚拟基类来处理菱形层次结构和它们固有的问题。
- en: Utilizing virtual base classes to eliminate duplication
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用虚拟基类消除重复
- en: We have just seen the MI implementation issues that quickly arise when a diamond
    shape is included in an OO design – duplication in memory for a repeated subobject,
    ambiguity accessing that subobject (even through inherited member functions),
    and the duplication of construction and destruction. For these reasons, pure OO
    designs will not include graphs in a hierarchy (that is, no diamond shapes). Yet,
    we know C++ is a powerhouse of a language and anything is possible. As such, C++
    will provide us with a solution to these issues.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了在OO设计中包含菱形时迅速出现的MI实现问题——重复子对象在内存中的重复、访问该子对象的歧义（甚至通过继承的成员函数），以及构造和析构的重复。出于这些原因，纯OO设计不会在层次结构中包含图（即，没有菱形）。然而，我们知道C++是一种强大的语言，任何事都是可能的。因此，C++将为我们提供解决这些问题的解决方案。
- en: '`virtual` is placed in the base class list between the access label and the
    base class name of the sibling or cousin class that may *later* be used as a base
    class for the same derived class. Note that knowing two sibling classes may later
    be combined as common base classes for a new derived class can be difficult. It
    is important to note that sibling classes that do not specify a virtual base class
    will demand their own copy of the (otherwise) shared base class.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual`被放置在基类列表中，位于可能*后来*用作相同派生类基类的兄弟或堂兄弟类的访问标签和基类名称之间。请注意，知道两个兄弟类可能后来被组合为新的派生类的共同基类可能很困难。重要的是要注意，没有指定虚拟基类的兄弟类将要求其自己的（否则）共享基类副本。'
- en: 'Virtual base classes should be used sparingly in implementation because they
    place restrictions and overhead on instances that have such a class as an ancestor
    class. Restrictions to be aware of include the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应该谨慎地在实现中使用虚拟基类，因为它们对具有此类作为祖先类的实例施加限制和开销。需要注意的限制包括以下内容：
- en: An instance having a virtual base class can use more memory than its non-virtual
    counterpart (the instance contains a pointer to the potentially shared base class
    component).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有虚拟基类的实例可能比其非虚拟对应实例使用更多的内存（该实例包含一个指向可能共享的基类组件的指针）。
- en: Casting from an object of a base class type to a derived class type is prohibited
    when a virtual base class is in the ancestor hierarchy.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当虚拟基类在祖先层次结构中时，从基类类型的对象到派生类类型的转换是被禁止的。
- en: The member initialization list of the most derived class must be used to specify
    which constructor of the shared object type should be used for initialization.
    If this specification is ignored, the default constructor will be used to initialize
    this subobject.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最派生类的成员初始化列表必须用来指定应该使用共享对象类型的哪个构造函数进行初始化。如果忽略此指定，将使用默认构造函数来初始化此子对象。
- en: 'Let us now look at a full program example that employs virtual base classes.
    As usual, the full program can be found in our GitHub as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用虚拟基类的完整程序示例。像往常一样，完整的程序可以在我们的GitHub上找到，如下所示：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex3.cpp)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex3.cpp)'
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous segment of code, we see the full class definition of `LifeForm`.
    Notice that the member functions with bodies are inlined in the class definition.
    Of course, the compiler will not actually make inline substitutions for constructors
    or the virtual destructor; knowing this, it is convenient to write the methods
    as inline to make the class compact for reviewing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们看到`LifeForm`类的完整类定义。请注意，具有主体的成员函数在类定义中被内联。当然，编译器实际上不会对构造函数或虚析构函数进行内联替换；了解这一点，将方法写成内联形式方便进行类定义的审查。
- en: 'Next, let’s see the class definition for `Horse`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`Horse`类的定义：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous segment of code, we have the full class definition for `Horse`.
    Keep in mind that though certain methods are written as inline for compactness,
    the compiler will never actually inline a constructor or destructor. Nor can a
    virtual function be inlined, as its whole point is to have the appropriate method
    determined at runtime (except rare scenarios involving devirtualization).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们有`Horse`类的完整类定义。请注意，尽管某些方法为了紧凑性而写成内联形式，但编译器永远不会实际内联构造函数或析构函数。同样，虚函数也不能内联，因为它的整个目的是在运行时确定适当的方法（除了涉及去虚化的罕见场景）。
- en: Here, `LifeForm` is a virtual base class of `Horse`. This means that if `Horse`
    ever has a sibling (or cousin) that also inherits from `LifeForm` using a virtual
    base class, and those siblings serve as base classes for a derived class, then
    those siblings will *share* their copy of `LifeForm`. The virtual base class will
    reduce storage, reduce extra constructor and destructor calls, and eliminate ambiguity.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`LifeForm`是`Horse`的虚基类。这意味着如果`Horse`有一个兄弟（或堂兄弟）也使用虚基类从`LifeForm`继承，并且这些兄弟作为派生类的基类，那么这些兄弟将*共享*他们的`LifeForm`副本。虚基类将减少存储空间，减少额外的构造函数和析构函数调用，并消除歧义。
- en: Notice the `Horse` constructors that specify a constructor specification of
    `LifeForm(HORSE_LIFE)` in their member initialization lists. This base class initialization
    will be ignored if `LifeForm` actually is a shared virtual base class, though
    these constructor specifications are certainly valid for instances of `Horse`
    or for instances of descendants of `Horse` in which the diamond shape hierarchy
    does not apply. In hierarchies where `Horse` is combined with a sibling class
    to truly serve as a virtual base class, the `LifeForm(HORSE_LIFE)` specification
    will be ignored and, instead, either the default `LifeForm` constructor will be
    called, or another will be selected at a lower (and unusual) level in the hierarchy.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Horse`构造函数在其成员初始化列表中指定了`LifeForm(HORSE_LIFE)`构造函数指定。如果`LifeForm`实际上是一个共享的虚基类，则此基类初始化将被忽略，尽管这些构造函数指定对于`Horse`的实例或对于在菱形继承结构不适用的情况下`Horse`的派生类的实例是有效的。在`Horse`与兄弟类结合以真正作为虚基类的情况下，`LifeForm(HORSE_LIFE)`指定将被忽略，取而代之的是，将调用默认的`LifeForm`构造函数，或者在层次结构的较低（且不寻常）级别选择另一个构造函数。
- en: 'Next, let’s see more of this program by looking at additional class definitions,
    beginning with `Person`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过查看更多的类定义来更深入地了解这个程序，从`Person`类开始：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the prior segment of code, we see that `Person` has a public virtual base
    class of `LifeForm`. Should `Person` and a sibling of `Person` ever be combined
    using multiple inheritance to be base classes for a new derived class, those siblings
    that have indicated a virtual base class of `LifeForm` will agree to share a single
    subobject of `LifeForm`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们看到`Person`有一个公共虚基类`LifeForm`。如果`Person`和`Person`的兄弟类通过多重继承结合成一个新的派生类的基类，那些表明了`LifeForm`虚基类的兄弟类将同意共享一个`LifeForm`的子对象。
- en: 'Moving onward, let’s review the member functions of `Person`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，让我们回顾`Person`的成员函数：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the aforementioned methods of `Person`, we see few details that surprise
    us; the methods are largely as expected. However, as a reminder, note that the
    `LifeForm(PERSON_LIFE)` specifications in the member initialization lists of the
    `Person` constructor will be ignored if `Person` is combined in a diamond-shaped
    hierarchy where the `LifeForm` subobject becomes shared, rather than duplicated.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的`Person`方法中，我们看到很少的细节会让我们感到惊讶；这些方法基本上符合预期。然而，作为提醒，请注意，如果`Person`在一个菱形继承结构中被组合，其中`LifeForm`子对象变为共享而不是复制，那么`Person`构造函数成员初始化列表中的`LifeForm(PERSON_LIFE)`指定将被忽略。
- en: 'Next, let’s take a look at where multiple inheritance comes into play, with
    the definition of the `Centaur` class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看多重继承如何发挥作用，通过`Centaur`类的定义来了解：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the aforementioned `Centaur` class definition, we can see that `Centaur`
    has public base classes of `Horse` and `Person`. We are implying that a `Centaur`
    *Is-A* `Horse` and `Centaur` *Is-A* `Person`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述`Centaur`类定义中，我们可以看到`Centaur`有公共基类`Horse`和`Person`。我们暗示`Centaur`是`Horse`和`Person`的实例。
- en: Notice, however, that the keyword `virtual` is not used in the base class list
    with the `Centaur` class definition. Yet, `Centaur` is the level in the hierarchy
    where the diamond shape is introduced. This means that we must plan ahead in our
    design stage to know to utilize the `virtual` keyword in the base class list for
    our `Horse` and `Person` class definitions. This is an example of why a proper
    design session is critical versus just jumping into implementation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在`Centaur`类定义的基类列表中没有使用`virtual`关键字。但是，`Centaur`是在层次结构中引入菱形形状的级别。这意味着我们必须在设计阶段提前规划，知道在`Horse`和`Person`类定义的基类列表中使用`virtual`关键字。这是一个为什么适当的设计会议至关重要，而不仅仅是跳入实现的例子。
- en: Also, quite unusually, notice the base class list of `Person(fn, ln, mi, title),
    Horse(fn), LifeForm(CENTAUR_LIFE)` in the `Centaur` alternate constructor. Here,
    we not only specify the preferred constructor of our immediate base classes of
    `Person` and `Horse`, but also the preferred constructor for *their* common base
    class of `LifeForm`. This is highly unusual. Without `LifeForm` as a virtual base
    class for `Horse` and `Person`, `Centaur` would not be able to specify how to
    construct the shared `LifeForm` piece (that is, by choosing a constructor for
    other than its immediate base classes). You also will notice the base class constructor
    specification of `:LifeForm(CENTAUR_LIFE)` in the member initialization list of
    the default as well as copy constructors for the same purposes. The virtual base
    class usage makes the `Person` and `Horse` classes less reusable for other applications,
    for reasons outlined at the beginning of this subsection.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，非常不寻常的是，注意在`Centaur`的替代构造函数中，基类列表`Person(fn, ln, mi, title), Horse(fn), LifeForm(CENTAUR_LIFE)`。在这里，我们不仅指定了`Person`和`Horse`的直接基类的首选构造函数，而且还指定了它们共同的基类`LifeForm`的首选构造函数。这是非常不寻常的。如果没有将`LifeForm`作为`Horse`和`Person`的虚基类，`Centaur`将无法指定如何构造共享的`LifeForm`部分（即通过为除其直接基类之外的其他选择构造函数）。你也会注意到，为了同样的目的，在默认构造函数以及复制构造函数的成员初始化列表中，对基类构造函数的指定。虚基类的使用使得`Person`和`Horse`类在其他应用中更难以重用，原因在本小节开头已概述。
- en: 'Let’s take a look at what our `main()` function entails:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`main()`函数包含什么：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Similar to the `main()` function in our non-virtual base class example, we can
    see that `Centaur` is likewise instantiated and that virtual functions such as
    `Speak()`, `IsA()`, and `Print()` are easily called. Now, however, when we call
    `GetLifeExpectancy()` through our `beast` instance, the call is no longer ambiguous.
    There is only one subobject of `LifeForm`, whose `lifeExpectancy` (an integer)
    has been initialized to `1000` (`CENTAUR_LIFE`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们非虚基类示例中的`main()`函数类似，我们可以看到`Centaur`同样被实例化，并且虚拟函数如`Speak()`、`IsA()`和`Print()`可以轻松调用。然而，现在当我们通过`beast`实例调用`GetLifeExpectancy()`时，调用不再模糊。只有一个`LifeForm`的子对象，其`lifeExpectancy`（一个整数）已被初始化为`1000`（`CENTAUR_LIFE`）。
- en: 'Here is the output for the full program example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是完整程序示例的输出：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Virtual base classes have solved a difficult MI conundrum. But we have also
    seen that the code required to do so is less flexible for future expansion and
    reuse. As such, virtual base classes should be carefully and sparingly used only
    when the design truly supports a diamond-shaped hierarchy. With that in mind,
    let’s consider an OO concept of a discriminator, and consider when alternate designs
    may be more appropriate.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虚基类解决了困难的MI难题。但我们也已经看到，实现这一目标所需的代码在未来的扩展和重用方面不太灵活。因此，只有在设计真正支持菱形层次结构时，才应谨慎和少量地使用虚基类。考虑到这一点，让我们考虑一个面向对象的判别器概念，并考虑何时其他设计可能更合适。
- en: Considering discriminators and alternate designs
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑判别器和替代设计
- en: A **discriminator** is an object-oriented concept that helps outline the reasons
    why a given class is derived from its base class. **Discriminators** tend to characterize
    the types of groupings of specializations that exist for a given base class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**判别器**是一个面向对象的概念，有助于概述为什么一个给定的类是从其基类派生出来的。**判别器**倾向于描述给定基类存在的特殊化分组类型。'
- en: 'For example, in the aforementioned program examples with diamond-shaped hierarchies,
    we have the following discriminators (shown in parentheses), outlining our purpose
    for specializing a new class from a given base class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上面的菱形层次结构的程序示例中，我们有以下判别器（括号中显示），概述了我们从给定的基类中特化新类的原因：
- en: '![Figure 9.1 – Multiple inheritance diamond-shaped design shown with discriminators
    ](img/Figure_9.01_B19087.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 使用判别器展示的多重继承菱形设计](img/Figure_9.01_B19087.jpg)'
- en: Figure 9.1 – Multiple inheritance diamond-shaped design shown with discriminators
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 使用判别器展示的多重继承菱形设计
- en: 'Whenever temptation leads to the creation of a diamond-shaped hierarchy, examining
    the discriminators can help us decide whether the design is reasonable, or whether
    perhaps an alternate design would prove better. Here are some good design metrics
    to consider:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时，诱惑导致创建菱形层次结构时，检查判别器可以帮助我们决定设计是否合理，或者是否可能有一个更好的替代设计。以下是一些值得考虑的良好设计指标：
- en: If the discriminators for the sibling classes that are being brought back together
    are the same, then the diamond-shaped hierarchy is better off redesigned.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果正在合并的兄弟类之间的判别器相同，那么最好重新设计菱形层次结构。
- en: When the sibling classes do not have unique discriminators, the attributes and
    behaviors they will introduce will consist of duplications stemming from having
    a *like-discriminator*. Consider making the discriminator a class to house those
    commonalities.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当兄弟类没有唯一的判别器时，它们将引入的属性和行为将包括由具有*类似判别器*而产生的重复。考虑将判别器作为一个类来存放这些共同点。
- en: If the discriminators for the sibling classes are unique, then the diamond-shaped
    hierarchy may be warranted. In this case, virtual base classes will prove helpful
    and should be added to the appropriate locations in the hierarchy.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果兄弟类的判别器是唯一的，那么菱形层次结构可能是合理的。在这种情况下，虚拟基类将非常有用，并且应该添加到层次结构的适当位置。
- en: In the previous example, the discriminator detailing why `Horse` specializes
    `LifeForm` is `Equine`. That is, we are specializing `LifeForm` with equine characteristics
    and behaviors (hooves, galloping, neighing, etcetera). Had we derived classes
    such as `Donkey` or `Zebra` from `LifeForm`, the discriminator for these classes
    would also be `Equine`. Considering the same aforementioned example, the `Person`
    class would have a `Humanoid` discriminator when specializing `LifeForm`. Had
    we derived classes such as `Martian` or `Romulan` from `LifeForm`, these classes
    would also have `Humanoid` as a discriminator.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，详细说明`Horse`如何特化`LifeForm`的判别器是`Equine`。也就是说，我们通过马的特征和行为（蹄子、奔跑、嘶鸣等）来特化`LifeForm`。如果我们从`LifeForm`派生出像`Donkey`或`Zebra`这样的类，这些类的判别器也将是`Equine`。考虑到上述相同的例子，`Person`类在特化`LifeForm`时将有一个`Humanoid`判别器。如果我们从`LifeForm`派生出像`Martian`或`Romulan`这样的类，这些类也将有`Humanoid`作为判别器。
- en: Bringing `Horse` and `Person` together as base classes for `Centaur` is combining
    two base classes with different discriminators, `Equine` and `Humanoid`. As such,
    wholly different types of characteristics and behaviors are factored in by each
    base class. Though an alternate design may be possible, this design is acceptable
    (except to OO design purists), and virtual base classes may be used in C++ to
    eliminate duplication of the otherwise-replicated `LifeForm` piece. Bringing two
    classes together that share a common base class and that each specializes the
    base class using distinct discriminators is an example of how MI and virtual base
    classes are reasonable in C++.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Horse`和`Person`作为`Centaur`的基类结合起来，是合并具有不同判别器（`Equine`和`Humanoid`）的两个基类。因此，每个基类都考虑了完全不同类型的特点和行为。尽管可能存在其他设计，但这种设计是可以接受的（除了面向对象设计的纯粹主义者），并且可以使用C++中的虚拟基类来消除其他情况下复制的`LifeForm`部分。将具有共同基类且每个类都使用不同的判别器特化基类的两个类结合起来，是C++中MI和虚拟基类合理性的一个例子。
- en: 'However, bringing together two classes such as `Horse` and `Donkey` (both derived
    from `LifeForm`) together in a derived class such as `Mule` also creates a diamond-shaped
    hierarchy. Examining the discriminators for `Horse` and `Donkey` reveals that
    both have the discriminator of `Equine`. In this case, bringing together these
    two classes using a diamond-shaped design is not the optimal design choice. Another
    design choice is possible and preferred. In this case, a preferred solution would
    be to make the discriminator, `Equine`, its own class, and then derive `Horse`,
    `Donkey`, and `Mule` from `Equine`. This would avoid MI and a diamond-shaped hierarchy.
    Let’s take a look at the two design options:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将`Horse`和`Donkey`（两者都从`LifeForm`派生）这样的两个类在派生类`Mule`中结合起来，也会创建一个菱形层次结构。检查`Horse`和`Donkey`的判别器可以发现，两者都有`Equine`的判别器。在这种情况下，使用菱形设计将这些两个类结合起来并不是最佳的设计选择。另一个设计选择是可能的，也是首选的。在这种情况下，一个首选的解决方案是将判别器`Equine`作为其自己的类，然后从`Equine`派生`Horse`、`Donkey`和`Mule`。这将避免MI和菱形层次结构。让我们看看两种设计选项：
- en: '![Figure 9.2 – Diamond-shaped multiple inheritance redesigned without MI ](img/Figure_9.02_B19087.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 无MI重新设计的菱形多重继承](img/Figure_9.02_B19087.jpg)'
- en: Figure 9.2 – Diamond-shaped multiple inheritance redesigned without MI
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 无MI重新设计的菱形多重继承
- en: Reminder
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: In a diamond-shaped hierarchy, if the discriminators for the *combined* classes
    are the same, a better design is possible (by making the discriminator its own
    class). However, if the discriminators are different, consider keeping the diamond-shaped
    MI hierarchy and then use virtual base classes to avoid duplication of the common
    base class subobject.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在菱形层次结构中，如果**结合**类的判别器相同，则可以进行更好的设计（通过将判别器作为其自己的类）。然而，如果判别器不同，考虑保留菱形MI层次结构，然后使用虚拟基类来避免重复公共基类子对象。
- en: We have now thoroughly examined the OO concept of a discriminator and have seen
    how discriminators can be used to help evaluate the reasonableness of a design.
    In many cases, designs using diamond-shaped hierarchies can be redesigned to not
    only eliminate the diamond shape but to eliminate multiple inheritance altogether.
    Let’s briefly recap the MI issues and OO concepts we’ve covered in this chapter
    before moving onward to our next chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经彻底研究了判别器的OO概念，并看到了判别器如何被用来帮助评估设计的合理性。在许多情况下，使用菱形层次结构的设计可以被重新设计，不仅消除菱形形状，而且完全消除多重继承。在我们继续下一章之前，让我们简要回顾一下本章中涵盖的MI问题和OO概念。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have marched onward with our quest for understanding object-oriented
    programming by exploring a controversial OOP topic, that of multiple inheritance.
    First, in this chapter, we have understood the simple mechanics of multiple inheritance.
    Equally important, we have reviewed reasons for building inheritance hierarchies
    and possible reasons for using MI (that is, specifying Is-A, mix-in, and Has-A
    relationships). We have been reminded that using inheritance to specify Is-A relationships
    supports pure OO designs. We have also seen the utility of using MI to implement
    mix-in relationships. We have also taken a look at the controversial use of MI
    to quickly implement a Has-A relationship; we’ll see in [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454),
    *Implementing Association, Aggregation, and Composition*, a preferred implementation
    for Has-A.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续我们的探索，以理解面向对象编程，我们探索了一个有争议的OOP主题，即多重继承。首先，在本章中，我们理解了多重继承的简单机制。同样重要的是，我们回顾了构建继承层次结构的原因以及使用MI（即指定Is-A、mix-in和Has-A关系）的可能原因。我们被提醒，使用继承来指定Is-A关系支持纯OO设计。我们还看到了使用MI实现mix-in关系的实用性。我们还审视了MI的争议性使用，以快速实现Has-A关系；我们将在[*第10章*](B19087_10.xhtml#_idTextAnchor454)中看到，*实现关联、聚合和组合*，一个首选的Has-A实现方法。
- en: We have seen how having multiple inheritance in our OO design toolkit can lead
    to diamond-shaped hierarchies. We have seen the inevitable issues arising from
    diamond-shaped hierarchies, such as duplication in memory, duplication in construction/destruction,
    and ambiguity in accessing a replicated subobject. We have also seen that C++
    provides a language-supported mechanism to correct these issues, using virtual
    base classes. We know that virtual base classes solve a tedious problem, yet they
    themselves are not perfect solutions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在我们的面向对象设计工具包中拥有多重继承如何导致菱形层次结构。我们也看到了菱形层次结构不可避免的问题，例如内存中的重复、构造/析构中的重复以及访问复制的子对象时的歧义。我们还看到，C++提供了一种语言支持的机制来纠正这些问题，即使用虚基类。我们知道虚基类解决了繁琐的问题，但它们本身并不是完美的解决方案。
- en: In an effort to critique diamond-shaped hierarchies, we have looked at an OO
    concept of a discriminator to help us weigh the validity of an OO design using
    MI in a diamond shape. This has also led us to understand that alternate designs
    can apply to a set of objects; sometimes a redesign is a more elegant approach
    in which the solution will yield easier, long-term use.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了批评菱形层次结构，我们研究了面向对象中的一个判别器概念，以帮助我们权衡在菱形中使用多重继承的面向对象设计的有效性。这也使我们理解到，替代设计可以适用于一组对象；有时，重新设计是一种更优雅的方法，其中解决方案将产生更简单、长期的使用。
- en: C++ is a *“you can do anything”* OOP language, and multiple inheritance is a
    controversial OO concept. Knowing when certain MI designs may be warranted and
    understanding language features to help with those MI issues will make you a better
    programmer. Knowing when a redesign is in order is also critical.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种*“你可以做任何事情”*的面向对象编程语言，多重继承是一个有争议的面向对象概念。了解何时某些多重继承设计可能是合理的，以及理解语言特性以帮助解决这些多重继承问题，将使你成为一个更好的程序员。了解何时需要重新设计也是至关重要的。
- en: We are now ready to continue to [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454),
    *Implementing Association, Aggregation, and Composition*, to further enhance our
    OOP skills by next learning how to represent association, aggregation, and composition
    with programming techniques. These upcoming concepts will *not* have direct language
    support, but the concepts are instrumental in our OO arsenal of skills. Let’s
    move onward!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续到[*第10章*](B19087_10.xhtml#_idTextAnchor454)，*实现关联、聚合和组合*，通过学习如何使用编程技术表示关联、聚合和组合来进一步提高我们的面向对象技能。这些即将到来的概念将*不会*有直接的语言支持，但这些概念在我们的面向对象技能库中是至关重要的。让我们继续前进！
- en: Questions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Type in (or use the online code) for the diamond-shaped hierarchy example in
    this chapter that uses virtual base classes. Run it as is. Hint: you may want
    to add explicit destructors with `cout` statements to trace the destruction sequence:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中输入（或使用在线代码）使用虚基类的菱形层次结构示例。按原样运行它。提示：你可能想在显式析构函数中添加`cout`语句以跟踪销毁顺序：
- en: How many `LifeForm` subobjects exist for the instance of `Centaur`?
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Centaur`实例，存在多少个`LifeForm`子对象？
- en: 'How many times is the `LifeForm` constructor (and destructor) invoked? Hint:
    you may want to place trace statements using `cout` in each of your constructors
    and destructor.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LifeForm`构造函数（和析构函数）被调用了多少次？提示：你可能想在每个构造函数和析构函数中使用`cout`放置跟踪语句。'
- en: Which `LifeForm` constructor would be invoked if the constructor selections
    for `LifeForm` in the member initialization list of the `Centaur` constructors
    were omitted?
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果省略了`Centaur`构造函数中`LifeForm`的构造函数选择，将调用哪个`LifeForm`构造函数？
- en: 'Now, remove the keyword `virtual` from the base class list of `Person` and
    `Horse` (that is, `LifeForm` will no longer be a virtual base class of `Person`
    and `Horse`. `LifeForm` will just be a typical base class of `Person` and `Horse`.)
    Also, remove the `LifeForm` constructor selection from the member initialization
    list of the `Centaur` constructors. Now, instantiate `Centaur`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`Person`和`Horse`（即`LifeForm`将不再是`Person`和`Horse`的虚基类。`LifeForm`将只是`Person`和`Horse`的典型基类）的基类列表中移除关键字`virtual`。同时，从`Centaur`构造函数的成员初始化列表中移除`LifeForm`构造函数的选择。现在，实例化`Centaur`：
- en: How many `LifeForm` subobjects exist for the instance of `Centaur`?
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Centaur`实例，存在多少个`LifeForm`子对象？
- en: 'Now, how many times is the `LifeForm` constructor (and destructor) invoked?
    Hint: you may want to add trace statements to your constructors and destructor.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`LifeForm`构造函数（和析构函数）被调用了多少次？提示：你可能想在构造函数和析构函数中添加跟踪语句。
