- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Multiple Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue broadening our knowledge of object-oriented programming
    in C++. We will begin by examining a controversial OO concept, **multiple inheritance**
    (**MI**), understanding why it is controversial, how it can reasonably be used
    to support OO designs, as well as when alternative designs may be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance can be implemented in C++ with *direct language support*.
    In doing so, we will be faced with several OO design issues. We will be asked
    to critically evaluate an inheritance hierarchy, asking ourselves whether we are
    using the best design possible to represent a potential set of object relationships.
    Multiple inheritance can be a powerful OOP tool; using it wisely is paramount.
    We will learn when to use MI to sensibly extend our hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding multiple inheritance mechanics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining reasonable uses for multiple inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating diamond-shaped hierarchies and exploring issues arising from their
    usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual base classes to resolve diamond-shaped hierarchy duplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying discriminators to evaluate the worthiness of a diamond-shaped hierarchy
    and MI in a design, as well as considering design alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the OO concept of multiple inheritance,
    and how to implement this idea in C++. You will understand not only the simple
    mechanics of MI but the reasons for its usage (mix-in, Is-A or controversially,
    Has-A).
  prefs: []
  type: TYPE_NORMAL
- en: You will see why MI is controversial in OOP. Having more than one base class
    can lead to oddly shaped hierarchies, such as diamond-shaped; these types of hierarchies
    come with potential implementation issues. We will see how C++ incorporates a
    language feature (virtual base classes) to solve these conundrums, but the solution
    is not always ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Once we understand the complexities caused by multiple inheritance, we will
    use OO design metrics, such as discriminators, to evaluate whether a design using
    MI is the best solution to represent a set of object relationships. We’ll look
    at alternative designs, and you will then be better equipped to understand not
    only what multiple inheritance is, but when it’s best utilized. Let us expand
    our understanding of C++ as a *“you can do anything”* OOP language by moving forward
    with MI.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter09](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter09).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter09`
    in a file named `Chp9-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3Cbqt7y](https://bit.ly/3Cbqt7y).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding multiple inheritance mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, a class can have more than one immediate base class. This is known as
    **multiple inheritance**, and is a very controversial topic in both OO designs
    and OOP. Let’s begin with the simple mechanics; we will then move forward to the
    design issues and programming logistics surrounding MI during the progression
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With multiple inheritance, the derived class specifies who each of its immediate
    ancestors or base classes are, using the base class list in its class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar fashion to single inheritance, the constructors and destructors
    are invoked all the way up the hierarchy as objects of the derived class type
    are instantiated and destroyed. Reviewing and expanding upon the subtleties of
    construction and destruction for MI, we are reminded of the following logistics:'
  prefs: []
  type: TYPE_NORMAL
- en: The calling sequence for a constructor starts with the derived class, but immediately
    passes control to a base constructor, and so on up the hierarchy. Once the calling
    sequence passes control to the top of the hierarchy, the execution sequence begins.
    All the highest-level base class constructors at the same level are first executed,
    and so on down the hierarchy until we arrive at the derived class constructor,
    whose body is executed last in the construction chain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The derived class destructor is invoked and executed first, followed by all
    the immediate base class destructors and so on, as we progress up the inheritance
    hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The member initialization list in the derived class constructor may be used
    to specify which constructor for each immediate base class should be invoked.
    In the absence of this specification, the default constructor will be used for
    that base class’ constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a typical multiple inheritance example to implement a
    quintessential application of MI from an OO design, as well as to understand basic
    MI syntax in C++. This example will be broken into many segments; the full program
    can be found in the following GitHub location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code segment, we have an expected class definition for `Person`,
    containing the class elements that we are accustomed to defining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s see the accompanying member functions for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, the member function definitions for `Person`
    are as expected. Nonetheless, it is useful to see the `Person` class defined,
    as this class will serve as a building block, and portions of it will be directly
    accessed in upcoming code segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define a new class, `BillableEntity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous `BillableEntity` class, we define a class containing simple
    functionality to encapsulate a billing structure. That is, we have an invoice
    amount and methods such as `Pay()` and `GetBalance()`. Notice that the copy constructor
    indicates `= delete` in its prototype; this will prohibit copies, which seems
    appropriate given the nature of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s combine the two aforementioned base classes, `Person` and `BillableEntity`,
    to serve as base classes for our `Student` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding class definition for `Student`, two public base classes, `Person`
    and `BillableEntity`, are specified in the base class list for `Student`. These
    two base classes are merely comma-separated in the `Student` base class list.
    We have also included the inline function definitions with the class definition,
    as these are usually bundled together in a header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s further see what accommodations must be made in the remainder of the
    `Student` class by examining its member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s consider the previous code segment. In the default constructor for `Student`,
    due to the lack of base class constructor specification in the member initialization
    list, the default constructors will be called for both the `Person` and `BillableEntity`
    base classes.
  prefs: []
  type: TYPE_NORMAL
- en: However, notice that in the alternate `Student` constructor, we merely comma-separate
    our two base class constructor choices in the member initialization list – that
    is, `Person(const string &, const string &, char, const string &)` and `BillableEntity(float)`
    – and then pass various parameters from the `Student` constructor to the base
    class constructors using this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s take a look at our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In our `main()` function in the previous code, we instantiate several `Student`
    instances. Notice that `Student` instances can utilize any methods in the public
    interface of `Student`, `Person`, or `BillableEntity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice the destruction sequence in the aforementioned output. We can see each
    `Student` instance invokes the `Student` destructor, as well as the destructors
    for each base class (`BillableEntity` and `Person`).
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen the language mechanics for MI with a typically implemented
    OO design. Now, let’s move forward by looking at the typical reasons for employing
    multiple inheritance in OO designs, some of which are more widely accepted than
    others.
  prefs: []
  type: TYPE_NORMAL
- en: Examining reasonable uses for multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple inheritance is a controversial concept that arises when creating OO
    designs. Many OO designs avoid MI; other designs embrace it with strict usage.
    Some OOP languages, such as Java, do not explicitly provide direct language support
    for multiple inheritance. Instead, they offer interfaces, such as we’ve modeled
    in C++ by creating interface classes using abstract classes (restricted to containing
    only pure virtual functions) in [*Chapter 8*](B19087_08.xhtml#_idTextAnchor399),
    *Mastering Abstract Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in C++, inheriting from two interface classes is still a use of multiple
    inheritance. Though C++ does not include interface classes within the language,
    this concept can be simulated by employing a more restrictive use of MI. For example,
    we can programmatically streamline abstract classes to include only pure virtual
    functions (no data members, and no member functions with definitions) to mimic
    the OO design idea of an interface class.
  prefs: []
  type: TYPE_NORMAL
- en: Typical MI conundrums form the basis of why MI is contentious in OOP. Classic
    MI quandaries will be detailed in this chapter and can be avoided by restricting
    MI to the usage of interface classes only, or through a redesign. This is why
    some OOP languages only support interface classes versus allowing unrestricted
    MI. In C++, you can carefully consider each OO design and choose when to utilize
    MI, when to utilize a restrictive form of MI (interface classes), or when to employ
    a redesign eliminating MI.
  prefs: []
  type: TYPE_NORMAL
- en: C++ is a *“you can do anything”* programming language. As such, C++ allows multiple
    inheritance without restrictions or reservations. As an OO programmer, we will
    look more closely at typical reasons to embrace MI. As we move further into this
    chapter, we will evaluate issues that arise by using MI and see how C++ solves
    these issues with additional language features. These MI issues will allow us
    to then apply metrics to understand more reasonably when we should use MI and
    when a redesign may be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin our pursuit of reasonable uses of MI by considering Is-A and mix-in
    relationships, and then move to examining the controversial use of MI to implement
    Has-A relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting Is-A and mix-in relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have learned with single inheritance, an Is-A relationship is most often
    used to describe the relationship between two inherited classes. For example,
    a `Student` *Is-A* `Person`. The same desired ideal continues with MI; Is-A relationships
    are the primary motivations to specify inheritance. In pure OO designs and programming,
    inheritance should be used only to support Is-A relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, as we have learned when we looked at interface classes (a concept
    modeled in C++ using abstract classes with the restriction of containing only
    pure virtual functions), mix-in relationships often apply when we inherit from
    an interface. Recall that a mix-in relationship is when we use inheritance to
    mix-in the functionality of another class, simply because that functionality is
    useful or meaningful for the derived class to have. The base class need not be
    an abstract or interface class, but employing an ideal OO design, it would be
    as such.
  prefs: []
  type: TYPE_NORMAL
- en: The mix-in base class represents a class in which an Is-A relationship does
    not apply. Mix-ins exist more so with multiple inheritance, at least as the reason
    supporting the necessity of one of the (many) base classes. Since C++ has direct
    language support for multiple inheritance, MI can be used to support implementing
    mix-ins (whereas languages such as Java may only use interface classes). In practice,
    MI is often used to inherit from one class to support an Is-A relationship and
    to also inherit from another class to support a mix-in relationship. In our last
    example, we saw that a `Student` *Is-A* `Person`, and a `Student` chooses to *mix-in*
    `BillableEntity` capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Reasonable uses of MI in C++ include supporting both Is-A and mix-in relationships;
    however, our discussion would not be complete without next considering an unusual
    use of MI – implementing Has-A relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting Has-A relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Less commonly, and much more controversially, MI can be used to implement a
    Has-A relationship, that is, to model containment, or a whole versus part relationship.
    We will see in [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454), *Implementing
    Association, Aggregation, and Composition*, a more widely accepted implementation
    for Has-A relationships; however, MI provides a very simple implementation. Here,
    the parts serve as the base classes. The whole inherits from the parts, automatically
    including the parts in its memory layout (and also automatically inheriting the
    parts’ members and functionality).
  prefs: []
  type: TYPE_NORMAL
- en: For example, a `Student` *Is-A* `Person` and a `Student` *Has-A(n)* `Id`; the
    usage of the second base class (`Id`) is for containment. `Id` will serve as a
    base class and `Student` will be derived from `Id` to factor in all that an `Id`
    offers. The `Id` public interface is immediately usable to `Student`. In fact,
    any class that inherits from `Id` will inherit a uniform interface when utilizing
    its `Id` parts. This simplicity is a driving reason why inheritance is sometimes
    used to model containment.
  prefs: []
  type: TYPE_NORMAL
- en: However, using inheritance to implement Has-A relationships can cause unnecessary
    usage of MI, which can then complicate an inheritance hierarchy. Unnecessary usage
    of MI is the primary reason why using inheritance to model Has-A relationships
    is very controversial and is quite frankly frowned upon in pure OO designs. Nonetheless,
    we mention it because you will see some C++ applications using MI for Has-A implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to explore other controversial designs employing MI, namely
    that of a diamond-shaped hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a diamond-shaped hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using multiple inheritance, sometimes it is tempting to utilize sibling
    (or cousin) classes as base classes for a new derived class. When this happens,
    the hierarchy is no longer a tree in shape, but rather, a graph containing a *diamond*.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever an object of the derived class type is instantiated in such a situation,
    two copies of the common base class will be present in the instance of the derived
    class. Duplication of this sort obviously wastes space. Additional time is also
    wasted by calling duplicate constructors and destructors for this repeated subobject
    and by maintaining two parallel copies of a subobject (most likely unnecessarily).
    Ambiguities also result when trying to access members from this common base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example detailing this issue, starting with abbreviated (and simplified)
    class definitions of `LifeForm`, `Horse`, and `Person`. Though only portions of
    the full program example are shown, the program in its entirety can be found in
    our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The previous fragment of code shows skeleton class definitions for `LifeForm`,
    `Person`, and `Horse`. Each class shows a default constructor, which merely serves
    as an example to show how `lifeExpectancy` is set for each class. In the default
    constructors for `Person` and `Horse`, the member initialization list is used
    to pass a value of `35` (`HORSE_LIFE`) or `80` (`PERSON_LIFE`) to the `LifeForm`
    constructor to set this value.
  prefs: []
  type: TYPE_NORMAL
- en: Though the previous class definitions are abbreviated (that is, purposely incomplete)
    to save space, let’s assume that each class has appropriate additional constructors
    defined, an appropriate destructor, and other necessary member functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We notice that `LifeForm` is an abstract class, in that it offers pure virtual
    functions: `Print()`, `IsA()`, and `Speak()`. Both `Horse` and `Person` are concrete
    classes and will be instantiable because they override these pure virtual functions
    with virtual functions. These virtual functions are shown inline, only to make
    the code compact for viewing (virtual functions will almost never be inlined by
    the compiler as their methods are nearly always determined at runtime).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at a new derived class that will introduce the graph, or diamond
    shape, in our hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous fragment, we define a new class, `Centaur`, using multiple inheritance.
    At first glance, we truly do mean to assert the Is-A relationship between `Centaur`
    and `Person`, and also between `Centaur` and `Horse`. However, we’ll soon challenge
    our assertion to test whether it is more of a combination than a true Is-A relationship.
  prefs: []
  type: TYPE_NORMAL
- en: We will assume that all of the necessary constructors, the destructor, and member
    functions exist to make `Centaur` a well-defined class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s move forward to look at a potential `main()` function we might utilize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, in `main()`, we instantiate a `Centaur` and we name the instance `beast`.
    We easily call two polymorphic operations on `beast`, namely `Speak()` and `IsA()`.
    Then we try to call the public inherited `GetLifeExpectancy()`, which is defined
    in `LifeForm`. Its implementation is included in `Lifeform` so that `Person`,
    `Horse`, or `Centaur` do not need to provide a definition (nor should they – it’s
    not a virtual function meant to be redefined).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, calls to `GetLifeExpectancy()` via `Centaur` instances are ambiguous.
    This is because there are two `LifeForm` subobjects in the `beast` instance. Remember,
    `Centaur` is derived from `Horse`, which is derived from `LifeForm`, providing
    the memory layout for all the aforementioned base class data members (`Horse`
    and `LifeForm`). And `Centaur` is also derived from `Person`, which is derived
    from `Lifeform`, which contributes the memory layout for `Person` and `LifeForm`
    within `Centaur`. The `LifeForm` piece is duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: There are two copies of the inherited data member `int lifeExpectancy;`. There
    are two subobjects of `LifeForm` within the `Centaur` instance. Therefore, when
    we try to call `GetLifeExpectancy()` through the `Centaur` instance, the method
    call is ambiguous. Which `lifeExpectancy` are we trying to initialize? Which `LifeForm`
    subobject will serve as the `this` pointer when `GetLifeExpectancy()` is called?
    It is simply not clear, so the compiler will not choose for us.
  prefs: []
  type: TYPE_NORMAL
- en: To disambiguate the `GetLifeExpectancy()` function call, we must use the scope
    resolution operator. We precede the `::` operator with the intermediate base class
    from which we want the `LifeForm` subobject. Notice that we call, for example,
    `beast.Horse::GetLifeExpectancy()` to choose the `lifeExpectancy` from the `Horse`
    subobject’s path, which will include `LifeForm`. This is awkward, as neither `Horse`
    nor `Person` includes the ambiguous member; `lifeExpectancy` is found in `LifeForm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see that designing a hierarchy that includes a diamond shape has drawbacks.
    These conundrums include programming ambiguities that need to be resolved in an
    awkward fashion, duplication in memory of repeated subobjects, plus time to construct
    and destruct these duplicate subobjects.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, C++ has a language feature to alleviate these hardships with diamond-shaped
    hierarchies. After all, C++  is a language that will allow us to do anything.
    Knowing when and whether we should utilize these features is another concern.
    Let’s first take a look at the C++ language solution to deal with diamond-shaped
    hierarchies and their inherent problems by looking at virtual base classes.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing virtual base classes to eliminate duplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just seen the MI implementation issues that quickly arise when a diamond
    shape is included in an OO design – duplication in memory for a repeated subobject,
    ambiguity accessing that subobject (even through inherited member functions),
    and the duplication of construction and destruction. For these reasons, pure OO
    designs will not include graphs in a hierarchy (that is, no diamond shapes). Yet,
    we know C++ is a powerhouse of a language and anything is possible. As such, C++
    will provide us with a solution to these issues.
  prefs: []
  type: TYPE_NORMAL
- en: '`virtual` is placed in the base class list between the access label and the
    base class name of the sibling or cousin class that may *later* be used as a base
    class for the same derived class. Note that knowing two sibling classes may later
    be combined as common base classes for a new derived class can be difficult. It
    is important to note that sibling classes that do not specify a virtual base class
    will demand their own copy of the (otherwise) shared base class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual base classes should be used sparingly in implementation because they
    place restrictions and overhead on instances that have such a class as an ancestor
    class. Restrictions to be aware of include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An instance having a virtual base class can use more memory than its non-virtual
    counterpart (the instance contains a pointer to the potentially shared base class
    component).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting from an object of a base class type to a derived class type is prohibited
    when a virtual base class is in the ancestor hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The member initialization list of the most derived class must be used to specify
    which constructor of the shared object type should be used for initialization.
    If this specification is ignored, the default constructor will be used to initialize
    this subobject.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us now look at a full program example that employs virtual base classes.
    As usual, the full program can be found in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter09/Chp9-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we see the full class definition of `LifeForm`.
    Notice that the member functions with bodies are inlined in the class definition.
    Of course, the compiler will not actually make inline substitutions for constructors
    or the virtual destructor; knowing this, it is convenient to write the methods
    as inline to make the class compact for reviewing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s see the class definition for `Horse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we have the full class definition for `Horse`.
    Keep in mind that though certain methods are written as inline for compactness,
    the compiler will never actually inline a constructor or destructor. Nor can a
    virtual function be inlined, as its whole point is to have the appropriate method
    determined at runtime (except rare scenarios involving devirtualization).
  prefs: []
  type: TYPE_NORMAL
- en: Here, `LifeForm` is a virtual base class of `Horse`. This means that if `Horse`
    ever has a sibling (or cousin) that also inherits from `LifeForm` using a virtual
    base class, and those siblings serve as base classes for a derived class, then
    those siblings will *share* their copy of `LifeForm`. The virtual base class will
    reduce storage, reduce extra constructor and destructor calls, and eliminate ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `Horse` constructors that specify a constructor specification of
    `LifeForm(HORSE_LIFE)` in their member initialization lists. This base class initialization
    will be ignored if `LifeForm` actually is a shared virtual base class, though
    these constructor specifications are certainly valid for instances of `Horse`
    or for instances of descendants of `Horse` in which the diamond shape hierarchy
    does not apply. In hierarchies where `Horse` is combined with a sibling class
    to truly serve as a virtual base class, the `LifeForm(HORSE_LIFE)` specification
    will be ignored and, instead, either the default `LifeForm` constructor will be
    called, or another will be selected at a lower (and unusual) level in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s see more of this program by looking at additional class definitions,
    beginning with `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the prior segment of code, we see that `Person` has a public virtual base
    class of `LifeForm`. Should `Person` and a sibling of `Person` ever be combined
    using multiple inheritance to be base classes for a new derived class, those siblings
    that have indicated a virtual base class of `LifeForm` will agree to share a single
    subobject of `LifeForm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving onward, let’s review the member functions of `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned methods of `Person`, we see few details that surprise
    us; the methods are largely as expected. However, as a reminder, note that the
    `LifeForm(PERSON_LIFE)` specifications in the member initialization lists of the
    `Person` constructor will be ignored if `Person` is combined in a diamond-shaped
    hierarchy where the `LifeForm` subobject becomes shared, rather than duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at where multiple inheritance comes into play, with
    the definition of the `Centaur` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `Centaur` class definition, we can see that `Centaur`
    has public base classes of `Horse` and `Person`. We are implying that a `Centaur`
    *Is-A* `Horse` and `Centaur` *Is-A* `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, however, that the keyword `virtual` is not used in the base class list
    with the `Centaur` class definition. Yet, `Centaur` is the level in the hierarchy
    where the diamond shape is introduced. This means that we must plan ahead in our
    design stage to know to utilize the `virtual` keyword in the base class list for
    our `Horse` and `Person` class definitions. This is an example of why a proper
    design session is critical versus just jumping into implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Also, quite unusually, notice the base class list of `Person(fn, ln, mi, title),
    Horse(fn), LifeForm(CENTAUR_LIFE)` in the `Centaur` alternate constructor. Here,
    we not only specify the preferred constructor of our immediate base classes of
    `Person` and `Horse`, but also the preferred constructor for *their* common base
    class of `LifeForm`. This is highly unusual. Without `LifeForm` as a virtual base
    class for `Horse` and `Person`, `Centaur` would not be able to specify how to
    construct the shared `LifeForm` piece (that is, by choosing a constructor for
    other than its immediate base classes). You also will notice the base class constructor
    specification of `:LifeForm(CENTAUR_LIFE)` in the member initialization list of
    the default as well as copy constructors for the same purposes. The virtual base
    class usage makes the `Person` and `Horse` classes less reusable for other applications,
    for reasons outlined at the beginning of this subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at what our `main()` function entails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `main()` function in our non-virtual base class example, we can
    see that `Centaur` is likewise instantiated and that virtual functions such as
    `Speak()`, `IsA()`, and `Print()` are easily called. Now, however, when we call
    `GetLifeExpectancy()` through our `beast` instance, the call is no longer ambiguous.
    There is only one subobject of `LifeForm`, whose `lifeExpectancy` (an integer)
    has been initialized to `1000` (`CENTAUR_LIFE`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Virtual base classes have solved a difficult MI conundrum. But we have also
    seen that the code required to do so is less flexible for future expansion and
    reuse. As such, virtual base classes should be carefully and sparingly used only
    when the design truly supports a diamond-shaped hierarchy. With that in mind,
    let’s consider an OO concept of a discriminator, and consider when alternate designs
    may be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Considering discriminators and alternate designs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **discriminator** is an object-oriented concept that helps outline the reasons
    why a given class is derived from its base class. **Discriminators** tend to characterize
    the types of groupings of specializations that exist for a given base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the aforementioned program examples with diamond-shaped hierarchies,
    we have the following discriminators (shown in parentheses), outlining our purpose
    for specializing a new class from a given base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Multiple inheritance diamond-shaped design shown with discriminators
    ](img/Figure_9.01_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Multiple inheritance diamond-shaped design shown with discriminators
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever temptation leads to the creation of a diamond-shaped hierarchy, examining
    the discriminators can help us decide whether the design is reasonable, or whether
    perhaps an alternate design would prove better. Here are some good design metrics
    to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: If the discriminators for the sibling classes that are being brought back together
    are the same, then the diamond-shaped hierarchy is better off redesigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the sibling classes do not have unique discriminators, the attributes and
    behaviors they will introduce will consist of duplications stemming from having
    a *like-discriminator*. Consider making the discriminator a class to house those
    commonalities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the discriminators for the sibling classes are unique, then the diamond-shaped
    hierarchy may be warranted. In this case, virtual base classes will prove helpful
    and should be added to the appropriate locations in the hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous example, the discriminator detailing why `Horse` specializes
    `LifeForm` is `Equine`. That is, we are specializing `LifeForm` with equine characteristics
    and behaviors (hooves, galloping, neighing, etcetera). Had we derived classes
    such as `Donkey` or `Zebra` from `LifeForm`, the discriminator for these classes
    would also be `Equine`. Considering the same aforementioned example, the `Person`
    class would have a `Humanoid` discriminator when specializing `LifeForm`. Had
    we derived classes such as `Martian` or `Romulan` from `LifeForm`, these classes
    would also have `Humanoid` as a discriminator.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing `Horse` and `Person` together as base classes for `Centaur` is combining
    two base classes with different discriminators, `Equine` and `Humanoid`. As such,
    wholly different types of characteristics and behaviors are factored in by each
    base class. Though an alternate design may be possible, this design is acceptable
    (except to OO design purists), and virtual base classes may be used in C++ to
    eliminate duplication of the otherwise-replicated `LifeForm` piece. Bringing two
    classes together that share a common base class and that each specializes the
    base class using distinct discriminators is an example of how MI and virtual base
    classes are reasonable in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, bringing together two classes such as `Horse` and `Donkey` (both derived
    from `LifeForm`) together in a derived class such as `Mule` also creates a diamond-shaped
    hierarchy. Examining the discriminators for `Horse` and `Donkey` reveals that
    both have the discriminator of `Equine`. In this case, bringing together these
    two classes using a diamond-shaped design is not the optimal design choice. Another
    design choice is possible and preferred. In this case, a preferred solution would
    be to make the discriminator, `Equine`, its own class, and then derive `Horse`,
    `Donkey`, and `Mule` from `Equine`. This would avoid MI and a diamond-shaped hierarchy.
    Let’s take a look at the two design options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Diamond-shaped multiple inheritance redesigned without MI ](img/Figure_9.02_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Diamond-shaped multiple inheritance redesigned without MI
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: In a diamond-shaped hierarchy, if the discriminators for the *combined* classes
    are the same, a better design is possible (by making the discriminator its own
    class). However, if the discriminators are different, consider keeping the diamond-shaped
    MI hierarchy and then use virtual base classes to avoid duplication of the common
    base class subobject.
  prefs: []
  type: TYPE_NORMAL
- en: We have now thoroughly examined the OO concept of a discriminator and have seen
    how discriminators can be used to help evaluate the reasonableness of a design.
    In many cases, designs using diamond-shaped hierarchies can be redesigned to not
    only eliminate the diamond shape but to eliminate multiple inheritance altogether.
    Let’s briefly recap the MI issues and OO concepts we’ve covered in this chapter
    before moving onward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have marched onward with our quest for understanding object-oriented
    programming by exploring a controversial OOP topic, that of multiple inheritance.
    First, in this chapter, we have understood the simple mechanics of multiple inheritance.
    Equally important, we have reviewed reasons for building inheritance hierarchies
    and possible reasons for using MI (that is, specifying Is-A, mix-in, and Has-A
    relationships). We have been reminded that using inheritance to specify Is-A relationships
    supports pure OO designs. We have also seen the utility of using MI to implement
    mix-in relationships. We have also taken a look at the controversial use of MI
    to quickly implement a Has-A relationship; we’ll see in [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454),
    *Implementing Association, Aggregation, and Composition*, a preferred implementation
    for Has-A.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how having multiple inheritance in our OO design toolkit can lead
    to diamond-shaped hierarchies. We have seen the inevitable issues arising from
    diamond-shaped hierarchies, such as duplication in memory, duplication in construction/destruction,
    and ambiguity in accessing a replicated subobject. We have also seen that C++
    provides a language-supported mechanism to correct these issues, using virtual
    base classes. We know that virtual base classes solve a tedious problem, yet they
    themselves are not perfect solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to critique diamond-shaped hierarchies, we have looked at an OO
    concept of a discriminator to help us weigh the validity of an OO design using
    MI in a diamond shape. This has also led us to understand that alternate designs
    can apply to a set of objects; sometimes a redesign is a more elegant approach
    in which the solution will yield easier, long-term use.
  prefs: []
  type: TYPE_NORMAL
- en: C++ is a *“you can do anything”* OOP language, and multiple inheritance is a
    controversial OO concept. Knowing when certain MI designs may be warranted and
    understanding language features to help with those MI issues will make you a better
    programmer. Knowing when a redesign is in order is also critical.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue to [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454),
    *Implementing Association, Aggregation, and Composition*, to further enhance our
    OOP skills by next learning how to represent association, aggregation, and composition
    with programming techniques. These upcoming concepts will *not* have direct language
    support, but the concepts are instrumental in our OO arsenal of skills. Let’s
    move onward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type in (or use the online code) for the diamond-shaped hierarchy example in
    this chapter that uses virtual base classes. Run it as is. Hint: you may want
    to add explicit destructors with `cout` statements to trace the destruction sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many `LifeForm` subobjects exist for the instance of `Centaur`?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How many times is the `LifeForm` constructor (and destructor) invoked? Hint:
    you may want to place trace statements using `cout` in each of your constructors
    and destructor.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `LifeForm` constructor would be invoked if the constructor selections
    for `LifeForm` in the member initialization list of the `Centaur` constructors
    were omitted?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, remove the keyword `virtual` from the base class list of `Person` and
    `Horse` (that is, `LifeForm` will no longer be a virtual base class of `Person`
    and `Horse`. `LifeForm` will just be a typical base class of `Person` and `Horse`.)
    Also, remove the `LifeForm` constructor selection from the member initialization
    list of the `Centaur` constructors. Now, instantiate `Centaur`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many `LifeForm` subobjects exist for the instance of `Centaur`?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, how many times is the `LifeForm` constructor (and destructor) invoked?
    Hint: you may want to add trace statements to your constructors and destructor.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
