<html><head></head><body>
		<div id="_idContainer075">
			<h1 class="chapter-number" id="_idParaDest-99"><a id="_idTextAnchor146"/>7</h1>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor147"/>Developing an Online Pong Game</h1>
			<p>It’s time to slowly get into some more complex aspects of making online multiplayer games. In <a href="B18527_06.xhtml#_idTextAnchor131"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Building an Online Checkers Game</em>, we saw how two players can share the same game world and see their actions have repercussions in the other players’ game states. This happened with players taking turns, so we didn’t have one of the most troublesome aspects of online multiplayer games <span class="No-Break">involved: time.</span></p>
			<p>In this chapter, we are going to start working with action games, which have hand-eye coordination and response time as their core features. We’ll start with making a replica of one of the simplest physics-based games out there: Pong. Using the base project as a starting point, we will then turn it into an online multiplayer Pong game where each player controls one paddle and the Godot Engine high-level networking features will be responsible for keeping players in sync within the same <span class="No-Break">game world.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Introducing the <span class="No-Break">Pong project</span></li>
				<li>Setting up online <span class="No-Break">multiplayer paddles</span></li>
				<li>Syncing <span class="No-Break">remote objects</span></li>
			</ul>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor148"/>Technical requirements</h1>
			<p>For this chapter, we are going to use our repository of online projects, which can be found through the <span class="No-Break">following link:</span></p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0"><span class="No-Break">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</span></a></p>
			<p>With the project opened in Godot Engine, open the <strong class="source-inline">res://07.developing-online-pong</strong> folder; everything we need for this chapter is there. That said, let’s start by understanding how our Pong project works and what we need to do to turn it into an online multiplayer game. As stated throughout the previous chapter, we will also use Godot Engine version 4.0, so if you have other versions of the engine, please make sure you are using the <span class="No-Break">correct one.</span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor149"/>Introducing the Pong project</h1>
			<p>Welcome <a id="_idIndexMarker224"/>to yet another project for our fake indie game development studio, network engineer! This time, we need to make the onboarding of our <span class="No-Break">next project.</span></p>
			<p>We have a Pong game that we think we can turn into a competitive online multiplayer game with some leaderboards and all this cool stuff. Your core task here is to make its core features playable by two players through a network. Let’s understand what we have currently so we can point out what you going <span class="No-Break">to modify.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor150"/>How the player paddles work</h2>
			<p>The players’ paddles are the<a id="_idIndexMarker225"/> most important thing in our project. They are the only thing players actually control and, as such, they are the main way players interact with the game. By moving them, the players can bounce the ball off to the <span class="No-Break">other player.</span></p>
			<p>Let’s take a brief look at the <strong class="bold">Paddle</strong> scene. For that, open the <strong class="source-inline">res://07.developing-online-pong/Paddle.tscn</strong> scene. Its scene tree structure looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer062">
					<img alt="Figure 7.1 – The Paddle scene’s node hierarchy" src="image/Figure_07.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The Paddle scene’s node hierarchy</p>
			<p>Note that the paddle itself is a <strong class="source-inline">Node2D</strong> node, whereas the actual physical body is its child. This is a good way to abstract game entities. They have a physical body, but they aren’t a physical body. This allows us to make more sense of them in more levels of abstraction. Now, let’s take a look at <span class="No-Break">its script:</span></p>
			<pre class="source-code">
extends Node2D
@export var speed = 500.0
@export var up_action = "move_up"
@export var down_action = "move_down"
@onready var body = $CharacterBody2D
func _physics_process(delta):
     body.move_and_slide()
func _unhandled_input(event):
     if event.is_action_pressed(up_action):
          body.velocity.y = -speed
     elif event.is_action_released(up_action):
          if Input.is_action_pressed(down_action):
               body.velocity.y = speed
          else:
               body.velocity.y = 0.0
     if event.is_action_pressed(down_action):
          body.velocity.y = speed
     elif event.is_action_released(down_action):
          if Input.is_action_pressed(up_action):
               body.velocity.y = -speed
          else:
               body.velocity.y = 0.0</pre>			<p>This code allows the<a id="_idIndexMarker226"/> paddle to move up and down based on user input. The <strong class="source-inline">speed</strong> variable determines the movement speed, and the <strong class="source-inline">up_action</strong> and <strong class="source-inline">down_action</strong> variables represent the input actions for moving the paddle. The script handles input events and adjusts the character’s velocity accordingly. The paddle moves at a constant speed or it stops if no key <span class="No-Break">is pressed.</span></p>
			<p>In the next section, let’s see how the ball works. It’s another core object in our game that we will need to do some work on in order to turn it into an online <span class="No-Break">multiplayer game.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor151"/>Understanding the Ball scene</h2>
			<p>The<a id="_idIndexMarker227"/> ball is the passive element of the game and it essentially bounces around when it hits another physical body – either the paddles, the ceiling, or the floor. The latter two are <strong class="source-inline">StaticBody2D</strong>, which use <strong class="source-inline">WorldBoundaryShape2D</strong> in <span class="No-Break">their </span><span class="No-Break"><strong class="source-inline">CollisionShape2D</strong></span><span class="No-Break">.</span></p>
			<p>Let’s take a look at the <strong class="bold">Ball</strong> scene. Open the <strong class="source-inline">res://07.developing-online-pong/Ball.tscn</strong> scene. The scene <span class="No-Break">structure follows:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer063">
					<img alt="Figure 7.2 – The Ball scene’s node hierarchy" src="image/Figure_07.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The Ball scene’s node hierarchy</p>
			<p>Before we open the <strong class="source-inline">Ball</strong> script, notice that the <strong class="source-inline">CollisionShape2D</strong> Resource has a built-in tool script attached to it. It’s a very simple script that draws the <strong class="source-inline">CircleShape2D</strong> Resource using the <strong class="source-inline">CanvasItem.draw_circle()</strong> method. This is the logic <span class="No-Break">behind it:</span></p>
			<pre class="source-code">
@tool
extends CollisionShape2D
@export var color = Color.WHITE
func _draw():
     draw_circle(Vector2.ZERO, shape.radius, color)</pre>			<p>That said, let’s <a id="_idIndexMarker228"/>open the <strong class="source-inline">Ball</strong> script and see how it works, pay attention especially to the bouncing logic because it uses some interesting <span class="No-Break"><strong class="source-inline">Vector2</strong></span><span class="No-Break"> methods:</span></p>
			<pre class="source-code">
extends Node2D
@export var speed = 600.0
@onready var body = $CharacterBody2D
func move():
     body.velocity.x = [-speed, speed][randi()%2]
     body.velocity.y = [-speed, speed][randi()%2]
func reset():
     body.global_position = global_position
     move()
func _physics_process(delta):
     var collision = body.move_and_collide
         (body.velocity  delta)
     if collision:
          body.velocity = body.velocity.bounce
              (collision.get_normal())</pre>			<p>This code moves<a id="_idIndexMarker229"/> the ball’s <strong class="source-inline">CharacterBody2D</strong> node at a specified speed, randomizes its motion direction, detects collisions with other objects, and makes the character bounce off surfaces upon collision. By using this script, the ball performs a dynamic and responsive movement with <span class="No-Break">collision detection.</span></p>
			<p>In the next section, we will understand how we detect when a player scores against <span class="No-Break">the other.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor152"/>Managing players’ scores</h2>
			<p>When the ball reaches<a id="_idIndexMarker230"/> the left or right of the screen, the player on the opposite side should score. To detect this condition, we make use of a <strong class="source-inline">ScoreArea</strong> node, which, in essence, is an <span class="No-Break"><strong class="source-inline">Area2D</strong></span><span class="No-Break"> node.</span></p>
			<p>Open the <strong class="source-inline">res://07.developing-online-pong/ScoreArea.tscn</strong> scene and we’ll take a look at its scene <span class="No-Break">tree structure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer064">
					<img alt="Figure 7.3 – The ScoreArea scene’s node hierarchy" src="image/Figure_07.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The ScoreArea scene’s node hierarchy</p>
			<p>As mentioned <a id="_idIndexMarker231"/>previously, it’s just an <strong class="source-inline">Area2D</strong> node; it doesn’t even have a <strong class="source-inline">CollisionShape2D</strong> Resource because, in this case, it’s more friendly to add it in the final scene so we can choose a specific <strong class="source-inline">Shape2D</strong> Resource for each <strong class="source-inline">ScoreArea</strong> node. Now, let’s take a look at <span class="No-Break">its code:</span></p>
			<pre class="source-code">
extends Area2D
signal scored(score)
@export var score = 0
func _on_body_entered(body):
     score += 1
     scored.emit(score)</pre>			<p>This code provides a simple way to keep track of a score in a game using an <strong class="source-inline">Area2D</strong> node. It emits a scored signal whenever another physical body (in this case, the ball) enters the area, incrementing the score by one. By connecting to this signal, other game objects can respond to score updates and perform related actions. We use this signal later on in the <span class="No-Break"><strong class="source-inline">PongGame</strong></span><span class="No-Break"> class.</span></p>
			<p>To ensure<a id="_idIndexMarker232"/> the <strong class="source-inline">ScoreArea</strong> node only detects the ball, we make use <a id="_idIndexMarker233"/>of <strong class="bold">Collision Layers</strong> and <strong class="bold">Collision Masks</strong>. On the ball, here’s how these <span class="No-Break">properties look:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer065">
					<img alt="Figure 7.4 – The Ball Collision Layer and Collision Mask properties" src="image/Figure_07.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The Ball Collision Layer and Collision Mask properties</p>
			<p>The ball is in the <a id="_idIndexMarker234"/>second physics layer, but it masks the first one. This is so it detects collisions with the paddle, the floor, and the ceiling. It needs to be only on the second physics layer because the <strong class="source-inline">ScoreArea</strong> node only masks the second layer. We do that to prevent the <strong class="source-inline">ScoreArea</strong> node from detecting any other physics body, for instance, the floor <span class="No-Break">or ceiling:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer066">
					<img alt="Figure 7.5 – The ScoreArea Collision Layer and Collision Mask properties" src="image/Figure_07.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – The ScoreArea Collision Layer and Collision Mask properties</p>
			<p>And that’s how we ensure<a id="_idIndexMarker235"/> that the <strong class="source-inline">ScoreArea</strong> node will only interact with the ball. In the next section, we are going to see how we use this signal emitted by the <strong class="source-inline">ScoreArea</strong> node to actually update the displayed score, along with the overall logic behind the <span class="No-Break"><strong class="source-inline">PongGame</strong></span><span class="No-Break"> class.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor153"/>Tying everything together</h2>
			<p>You may have<a id="_idIndexMarker236"/> noticed that these classes operate independently without any coupling, which means that they cannot form a cohesive system on their own. The responsibility of integrating everything into a coherent system falls on the <span class="No-Break"><strong class="source-inline">PongGame</strong></span><span class="No-Break"> class.</span></p>
			<p>Let’s first take a look at its scene tree structure so we can understand how everything will interact. Open the <strong class="source-inline">res://07.developing-online-pong/PongGame.tscn</strong> scene and pay attention to the <span class="No-Break"><strong class="bold">Scene</strong></span><span class="No-Break"> dock:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer067">
					<img alt="Figure 7.6 – The PongGame scene’s node hierarchy" src="image/Figure_07.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – The PongGame scene’s node hierarchy</p>
			<p>At this point, you <a id="_idIndexMarker237"/>already have a sense of most of these nodes. Let’s just take a moment to understand what <strong class="source-inline">ScoreLabel</strong> nodes does. It’s essentially just a text on the screen that displays each player’s score. For that, it uses a method that changes its text property based on the casting of the score received by the <strong class="source-inline">ScoreArea.scored</strong> signal (which is an integer) into a string. The whole <strong class="source-inline">ScoreLabel</strong> node’s code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
extends Label
func update_score(new_score):
     text = "%s" % new_score</pre>			<p>With that in mind, let’s jump into the <span class="No-Break"><strong class="source-inline">PongGame</strong></span><span class="No-Break"> code:</span></p>
			<pre class="source-code">
extends Node2D
@export var speed = 600.0
@onready var body = $CharacterBody2D
func move():
     body.velocity.x = [-speed, speed][randi()%2]
     body.velocity.y = [-speed, speed][randi()%2]
func reset():
     body.global_position = global_position
     move()
func _physics_process(delta):
     var collision = body.move_and_collide
         (body.velocity  delta)
     if collision:
          body.velocity = body.velocity.bounce
              (collision.get_normal())</pre>			<p>This code keeps<a id="_idIndexMarker238"/> track of scores, displays a winner when a player reaches the target score, and allows the game to be restarted when one of the players presses the <strong class="bold">Rematch</strong> button, part of the <strong class="source-inline">WinnerDisplay</strong> Node interface. For visual reference, this is how <strong class="source-inline">WinnerDisplay</strong> node looks when <span class="No-Break">toggled on:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer068">
					<img alt="Figure 7.7 – The WinnerDisplay overlay showing the match’s winner" src="image/Figure_07.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – The WinnerDisplay overlay showing the match’s winner</p>
			<p>It also initializes the<a id="_idIndexMarker239"/> game by randomizing the ball’s movement and starting its initial motion. Also, when a player scores, it resets the ball by recentering it and starting its <span class="No-Break">movement again.</span></p>
			<p>In this section, we went through all the core classes in our Pong game. They are currently meant for local multiplayer, so we need to modify them to support <span class="No-Break">online multiplayer.</span></p>
			<p>In the next section, we are going to do the necessary work to turn our game into a remotely playable Pong game where two players interact with each other, each with one paddle so they can <span class="No-Break">compete together!</span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor154"/>Setting up online multiplayer paddles</h1>
			<p>It’s time to start your<a id="_idIndexMarker240"/> actual work. After understanding the whole project, let’s do the necessary work to allow players to play <span class="No-Break">it online!</span></p>
			<p>In <a href="B18527_06.xhtml#_idTextAnchor131"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Building an Online Checkers Game</em>, we saw that changing the multiplayer authority of a <strong class="source-inline">SceneTree</strong> branch allows the new peer to take over control of the changes made to that branch of nodes. This was how we made it so that the player playing on the white team couldn’t move the black team’s pieces, and <span class="No-Break">vice versa.</span></p>
			<p>Being able to dynamically change the multiplayer authority is a core skill that we need to develop to maintain a coherent shared world for our players. In the situation we mentioned, players took turns in which each of them performed a single move and then the opposite player took control of their pieces. In this chapter, on the other hand, players must move<a id="_idIndexMarker241"/> simultaneously as this is an <span class="No-Break">action game.</span></p>
			<p>In the upcoming sections, we are going to implement a simple approach to give each player a paddle to <span class="No-Break">play with.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor155"/>Changing the paddle’s owner</h2>
			<p>In our paddle <a id="_idIndexMarker242"/>implementation, we have a small issue to address. Both paddles call <strong class="source-inline">CharacterBody2D.move_and_slide()</strong> inside the <strong class="source-inline">_physics_process()</strong> callback, on top of checking for <strong class="source-inline">InputEvent</strong> in the <strong class="source-inline">_unhandled_input()</strong> callback. This makes it so that if the other player moves their paddle, the movement may be overwritten in the opponent’s game. So, on top of re-assigning the paddles’ multiplayer authority, we also need to disable the opponent’s paddle callbacks. Open <strong class="source-inline">res://07.developing-online-pong/Paddle.gd</strong> and let’s do it! Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Create a method called <strong class="source-inline">setup_multiplayer()</strong> and include the <strong class="source-inline">player_id</strong> argument, which represents the network identifier of <span class="No-Break">the player:</span><pre class="source-code">
func setup_multiplayer(player_id):</pre></li>				<li>Decorate the <strong class="source-inline">setup_multiplayer()</strong> function with the <strong class="source-inline">@rpc</strong> annotation and use the <strong class="source-inline">call_local</strong> option. This will ensure that only the server can call this method, and it will also call it locally on the <span class="No-Break">server’s endpoint:</span><pre class="source-code">
@rpc("call_local")
func setup_multiplayer(player_id):</pre></li>				<li>Inside the function, call the <strong class="source-inline">set_multiplayer_authority()</strong> method and pass it the <strong class="source-inline">player_id</strong> argument. With that, we have set up the paddle’s new multiplayer authority. Now, we need to prevent its movement if the <strong class="source-inline">player_id</strong> argument doesn’t match its multiplayer authority ID. We do that because this RPC function will be called on all peers, so the opponent’s paddle is supposed to run the following <span class="No-Break">code block:</span><pre class="source-code">
@rpc("call_local")
func setup_multiplayer(player_id):
     set_multiplayer_authority(player_id)</pre></li>				<li>Use the <strong class="source-inline">is_multiplayer_authority()</strong> method to check that the current paddle’s peer ID doesn’t match the multiplayer authority’s <span class="No-Break">peer ID:</span><pre class="source-code">
     if not is_multiplayer_authority():</pre></li>				<li>If this is the case, call the <strong class="source-inline">set_physics_process()</strong> function and pass it the <strong class="source-inline">false</strong> argument to disable <span class="No-Break">physics processing:</span><pre class="source-code">
     if not is_multiplayer_authority():
          set_physics_process(false)</pre></li>				<li>Likewise, call the <strong class="source-inline">set_process_unhandled_input()</strong> function and pass <strong class="source-inline">false</strong> to<a id="_idIndexMarker243"/> disable handling unhandled input events on <span class="No-Break">this paddle:</span><pre class="source-code">
if not is_multiplayer_authority():
          set_physics_process(false)
          set_process_unhandled_input(false)</pre></li>				<li>At the end, the whole <strong class="source-inline">setup_multiplayer()</strong> method should look <span class="No-Break">like this:</span><pre class="source-code">
@rpc("call_local")
func setup_multiplayer(player_id):
     set_multiplayer_authority(player_id)
     if not is_multiplayer_authority():
          set_physics_process(false)
          set_process_unhandled_input(false)</pre></li>			</ol>
			<p>This code sets up<a id="_idIndexMarker244"/> multiplayer functionality by assigning the paddle’s multiplayer authority to a specified player. It then adjusts the behavior of the script based on whether the current instance is the authoritative peer. If the instance is not the authoritative peer, it disables physics and unhandled input processing to ensure that only the authoritative player performs those actions in <span class="No-Break">this instance.</span></p>
			<p>In the next section, let’s understand how we gather and assign the player’s ID to each <span class="No-Break">respective paddle.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor156"/>Assigning the players’ paddles</h2>
			<p>Now that each <a id="_idIndexMarker245"/>paddle can have its own multiplayer authority and have independent physics and input handling processes for each player, it’s time to understand how we are going to assign each player to their respective paddle. To do that, let’s open the <strong class="source-inline">res://07.developing-online-pong/PongGame.gd</strong> script and, right in its <strong class="source-inline">_ready()</strong> function, let’s create the <span class="No-Break">necessary logic:</span></p>
			<ol>
				<li>First of all, include the <strong class="source-inline">await</strong> keyword followed by the <strong class="source-inline">get_tree().create_timer(0.1).timeout</strong> expression. This creates a delay of 0.1 seconds and waits for its <strong class="source-inline">timeout</strong> signal to emit. This is important because we are going to use RPCs to call functions on remote nodes, and these nodes may not be ready by the time the game executes this code, so instead it waits a brief moment before executing <span class="No-Break">its behavior:</span><pre class="source-code">
func _ready():
     randomize()
     await(get_tree().create_timer(0.1).timeout)
     ball.move()</pre></li>				<li>Then, check whether the size of the connected peers is greater than <strong class="source-inline">0</strong> by using the <strong class="source-inline">multiplayer.get_peers().size()</strong> method. This will ensure the following behavior only happens if there are peers connected; otherwise, the game runs as it <span class="No-Break">should locally:</span><pre class="source-code">
     await(get_tree().create_timer(0.1).timeout)
     if multiplayer.get_peers().size() &gt; 0:</pre></li>				<li>If this is the case, check whether the current instance is the current multiplayer authority by using <strong class="source-inline">is_multiplayer_authority()</strong>. This ensures that only the server will perform the <span class="No-Break">player assignment:</span><pre class="source-code">
     await(get_tree().create_timer(0.1).timeout)
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():</pre></li>				<li>Inside this <a id="_idIndexMarker246"/>condition, assign the first connected peer to the <strong class="source-inline">player_1</strong> variable. This will store the first player’s ID in <span class="No-Break">this variable:</span><pre class="source-code">
     await(get_tree().create_timer(0.1).timeout)
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               var player_1 = multiplayer.get_peers
                   ()[0]</pre></li>				<li>Then, assign the second connected peer to the <strong class="source-inline">player_2</strong> variable. This will store the second player’s ID in <span class="No-Break">this variable:</span><pre class="source-code">
     await(get_tree().create_timer(0.1).timeout)
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               var player_1 = multiplayer.get_peers
                   ()[0]
               var player_2 = multiplayer.get_peers()
                   [1]</pre></li>				<li>Then, let’s<a id="_idIndexMarker247"/> use the <strong class="source-inline">rpc()</strong> method to call the <strong class="source-inline">setup_multiplayer</strong> method remotely on the <strong class="source-inline">player_1_paddle</strong> and <strong class="source-inline">player_2_paddle</strong> nodes, passing their respective <span class="No-Break"><strong class="source-inline">player</strong></span><span class="No-Break"> variables:</span><pre class="source-code">
if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               var player_1 = multiplayer.get_peers()
                   [0]
               var player_2 = multiplayer.get_peers()
                   [1]
               player_1_paddle.rpc
                   ("setup_multiplayer", player_1)
               player_2_paddle.rpc
                   ("setup_multiplayer", player_2)</pre></li>				<li>The whole <strong class="source-inline">PongGame._ready()</strong> callback should look like this after <span class="No-Break">these changes:</span><pre class="source-code">
func _ready():
     randomize()
     await(get_tree().create_timer(0.1).timeout)
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               var player_1 = multiplayer.get_peers()
                   [0]
               var player_2 = multiplayer.get_peers()
                   [1]
               player_1_paddle.rpc
                   ("setup_multiplayer", player_1)
               player_2_paddle.rpc
                   ("setup_multiplayer", player_2)
     ball.move()</pre></li>			</ol>
			<p>This code <a id="_idIndexMarker248"/>demonstrates asynchronous programming and multiplayer setup. It starts by randomizing the random number generator and then introduces a delay of 0.1 seconds. It checks whether there are connected peers and whether the current instance is the multiplayer authority – in other words, the server. If these conditions are met, it assigns the connected peers to variables and uses RPCs to call the <strong class="source-inline">Paddle.setup_multiplayer()</strong> method with the respective peer information. Finally, it moves the <span class="No-Break"><strong class="source-inline">ball</strong></span><span class="No-Break"> object.</span></p>
			<p>In order to properly set up who controls it, we provide <strong class="source-inline">Paddle.setup_multiplayer()</strong> with the required data – specifically, the player ID. However, a small problem arises when each player can only control their own paddle. How will players update their opponent’s paddle position? Moreover, who should control the ball and how will its position be updated in both players’ game instances? These questions will be addressed in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor157"/>Syncing remote objects</h1>
			<p>With each player<a id="_idIndexMarker249"/> controlling their respective paddle in their own game instance, we have a small problem. The opponent’s paddle will not update its movement because we ensured that both its physics and input processes were disabled after we assigned a new multiplayer authority. Due to that, the ball may also bounce on the opponent’s paddle and create a different movement trajectory in each player’s<a id="_idIndexMarker250"/> game instance. We need to ensure that players are sharing the same game world and, for that, we are going to sync the objects across the network using <strong class="source-inline">MultiplayerSynchronizer</strong>. In the next section, we are going to start the syncing of <span class="No-Break">the ball.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor158"/>Updating the ball’s position</h2>
			<p>The first thing<a id="_idIndexMarker251"/> we are going to do is ensure the ball’s position is synced across all peers. This is because we want to prevent players from dealing with different balls in their game instances, since this may lead them to make decisions based on wrong information. For instance, a player may move toward a ball that, in their game instance, is moving toward the ceiling, while in the server’s game instance, the ball is actually moving toward the floor. Let’s open <strong class="source-inline">res://07.developing-online-pong/Ball.tscn</strong> and start the <span class="No-Break">simple process:</span></p>
			<ol>
				<li>Add <strong class="source-inline">MultiplayerSynchronizer</strong> as the <strong class="source-inline">Ball</strong> node’s child. We are going to use this node’s features to keep all peers up to date with the ball’s <span class="No-Break"><strong class="source-inline">CharacterBody2D</strong></span><span class="No-Break"> position:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer069">
					<img alt="Figure 7.8 – The Ball scene’s node hierarchy with a newly added MultiplayerSynchronizer node" src="image/Figure_07.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – The Ball scene’s node hierarchy with a newly added MultiplayerSynchronizer node</p>
			<ol>
				<li value="2">Then, using the <strong class="bold">Replication</strong> menu, let’s choose the <strong class="source-inline">CharacterBody2D:position</strong> property to replicate across the <span class="No-Break">connected peers:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer070">
					<img alt="Figure 7.9 – The ball’s CharacterBody2D position property in the MultiplayerSynchronizer Replication menu" src="image/Figure_07.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – The ball’s CharacterBody2D position property in the MultiplayerSynchronizer Replication menu</p>
			<ol>
				<li value="3">Finally, since <a id="_idIndexMarker252"/>we are working with physics bodies here, we need to ensure that the <strong class="bold">Visibility Update</strong> property is set to update during the <strong class="bold">Physics</strong> process. This will sync the <strong class="source-inline">MultiplayerSynchronizer</strong> updates to the local <strong class="source-inline">Physics</strong> update, ensuring that the game will take into account any collisions and other physics simulations when it updates the <span class="No-Break"><strong class="source-inline">Paddle</strong></span><span class="No-Break"> instances:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer071">
					<img alt="Figure 7.10 – The ball’s MultiplayerSynchronizer’s Visibility Update property set to Physics" src="image/Figure_7.10_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – The ball’s MultiplayerSynchronizer’s Visibility Update property set to Physics</p>
			<ol>
				<li value="4">To prevent any<a id="_idIndexMarker253"/> overwriting of the ball’s position in any player’s instance of the game, let’s open the ball’s script and add a code snippet at its <strong class="source-inline">_ready()</strong> callback stating that if this peer isn’t the multiplayer authority, it will disable the ball’s <strong class="source-inline">_physics_process()</strong>callback. This will make it so that only the server has the authority to actually calculate the ball’s movement and, ultimately, its position, while players only replicate this in their <span class="No-Break">game instances:</span><pre class="source-code">
func _ready():
     if not is_multiplayer_authority():
          set_physics_process(false)</pre></li>			</ol>
			<p>With that, the ball’s movement should be the same across all connected peers, preventing them from making decisions based on an object that the other peers are seeing differently. This would break the game experience because, ultimately, the players would be playing in a different game world making movements that don’t make sense to their peers. In the next section, let’s do the same process for the <strong class="source-inline">Paddle</strong> object; of course, in this one, we won’t need to disable <strong class="source-inline">_physics_process()</strong> because we do that when we set up its <span class="No-Break">multiplayer authority.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor159"/>Coordinating the paddle’s position</h2>
			<p>Finally, it’s time to <a id="_idIndexMarker254"/>sync the players’ paddle positions to each other so they see their opponent’s moves and can be on the same page. Let’s open the <strong class="source-inline">res://07.developing-online-pong/Paddle.tscn</strong> scene and start <span class="No-Break">the work:</span></p>
			<ol>
				<li>Add a new <strong class="source-inline">MultiplayerSynchronizer</strong> as a <span class="No-Break"><strong class="source-inline">Paddle</strong></span><span class="No-Break"> child:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer072">
					<img alt="Figure 7.11 – The Paddle scene’s node hierarchy with a newly added MultiplayerSynchronizer node" src="image/Figure_07.11_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – The Paddle scene’s node hierarchy with a newly added MultiplayerSynchronizer node</p>
			<ol>
				<li value="2">In the <strong class="bold">Replication</strong> menu, select the <strong class="source-inline">CharacterBody2D:position</strong> property to replicate across the <span class="No-Break">connected peers:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer073">
					<img alt="Figure 7.12 – The Paddle CharacterBody2D position property in the MultiplayerSynchronizer Replication menu" src="image/Figure_07.12_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – The Paddle CharacterBody2D position property in the MultiplayerSynchronizer Replication menu</p>
			<ol>
				<li value="3">Just like in<a id="_idIndexMarker255"/> the <strong class="bold">Ball</strong> scene case, we are also working with a physics body here, so change the <strong class="bold">Visibility Update</strong> property to update during the <span class="No-Break"><strong class="bold">Physics</strong></span><span class="No-Break"> process:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer074">
					<img alt="Figure 7.13 – The Paddle MultiplayerSynchronizer Visibility Update property set to Physics" src="image/Figure_07.13_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – The Paddle MultiplayerSynchronizer Visibility Update property set to Physics</p>
			<p>With this implementation, each<a id="_idIndexMarker256"/> opponent’s paddle will have its <strong class="source-inline">CharacterBody2D</strong> position synchronized across all peers in the game. This results in a shared game world that players can enjoy together while competing in a <span class="No-Break">fair environment.</span></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor160"/>Summary</h1>
			<p>In this chapter, we learned how the Godot Engine High-Level Network API provides quick and easy solutions to assign the correct “owner” of a game object and sync its state across the network. This ensures that players are playing in a shared environment with an actual human opponent on the <span class="No-Break">other side.</span></p>
			<p>We learned how to check whether the current game instance is the multiplayer authority and make it perform the proper behavior accordingly. We also learned how to change the multiplayer authority of a node hierarchy on the <strong class="source-inline">SceneTree</strong>, ensuring that only a given player can make and sync changes regarding this node and its children. To sync the changes, we used <strong class="source-inline">MultiplayerSynchronizer</strong> with the <strong class="bold">Physics</strong> mode of <strong class="bold">Visibility Update</strong> to ensure that the physics interactions of the game objects are synced across all <span class="No-Break">network peers.</span></p>
			<p>In the upcoming chapter, we will strengthen our knowledge of online multiplayer games by creating a platformer game that two or more players can play together and explore the game world as they please. We are confident that this will be an exciting addition to our game <span class="No-Break">development skills.</span></p>
		</div>
	</body></html>