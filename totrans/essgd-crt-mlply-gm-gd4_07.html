<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-99"><a id="_idTextAnchor146"/>7</h1>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor147"/>Developing an Online Pong Game</h1>
			<p>It’s time to slowly get into some more complex aspects of making online multiplayer games. In <a href="B18527_06.xhtml#_idTextAnchor131"><em class="italic">Chapter 6</em></a>, <em class="italic">Building an Online Checkers Game</em>, we saw how two players can share the same game world and see their actions have repercussions in the other players’ game states. This happened with players taking turns, so we didn’t have one of the most troublesome aspects of online multiplayer games involved: time.</p>
			<p>In this chapter, we are going to start working with action games, which have hand-eye coordination and response time as their core features. We’ll start with making a replica of one of the simplest physics-based games out there: Pong. Using the base project as a starting point, we will then turn it into an online multiplayer Pong game where each player controls one paddle and the Godot Engine high-level networking features will be responsible for keeping players in sync within the same game world.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing the Pong project</li>
				<li>Setting up online multiplayer paddles</li>
				<li>Syncing remote objects</li>
			</ul>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor148"/>Technical requirements</h1>
			<p>For this chapter, we are going to use our repository of online projects, which can be found through the following link:</p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</a></p>
			<p>With the project opened in Godot Engine, open the <code>res://07.developing-online-pong</code> folder; everything we need for this chapter is there. That said, let’s start by understanding how our Pong project works and what we need to do to turn it into an online multiplayer game. As stated throughout the previous chapter, we will also use Godot Engine version 4.0, so if you have other versions of the engine, please make sure you are using the correct one.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor149"/>Introducing the Pong project</h1>
			<p>Welcome <a id="_idIndexMarker224"/>to yet another project for our fake indie game development studio, network engineer! This time, we need to make the onboarding of our next project.</p>
			<p>We have a Pong game that we think we can turn into a competitive online multiplayer game with some leaderboards and all this cool stuff. Your core task here is to make its core features playable by two players through a network. Let’s understand what we have currently so we can point out what you going to modify.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor150"/>How the player paddles work</h2>
			<p>The players’ paddles are the<a id="_idIndexMarker225"/> most important thing in our project. They are the only thing players actually control and, as such, they are the main way players interact with the game. By moving them, the players can bounce the ball off to the other player.</p>
			<p>Let’s take a brief look at the <code>res://07.developing-online-pong/Paddle.tscn</code> scene. Its scene tree structure looks like this:</p>
			<div><div><img alt="Figure 7.1 – The Paddle scene’s node hierarchy" src="img/Figure_07.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The Paddle scene’s node hierarchy</p>
			<p>Note that the paddle itself is a <code>Node2D</code> node, whereas the actual physical body is its child. This is a good way to abstract game entities. They have a physical body, but they aren’t a physical body. This allows us to make more sense of them in more levels of abstraction. Now, let’s take a look at its script:</p>
			<pre class="source-code">
extends Node2D
@export var speed = 500.0
@export var up_action = "move_up"
@export var down_action = "move_down"
@onready var body = $CharacterBody2D
func _physics_process(delta):
     body.move_and_slide()
func _unhandled_input(event):
     if event.is_action_pressed(up_action):
          body.velocity.y = -speed
     elif event.is_action_released(up_action):
          if Input.is_action_pressed(down_action):
               body.velocity.y = speed
          else:
               body.velocity.y = 0.0
     if event.is_action_pressed(down_action):
          body.velocity.y = speed
     elif event.is_action_released(down_action):
          if Input.is_action_pressed(up_action):
               body.velocity.y = -speed
          else:
               body.velocity.y = 0.0</pre>			<p>This code allows the<a id="_idIndexMarker226"/> paddle to move up and down based on user input. The <code>speed</code> variable determines the movement speed, and the <code>up_action</code> and <code>down_action</code> variables represent the input actions for moving the paddle. The script handles input events and adjusts the character’s velocity accordingly. The paddle moves at a constant speed or it stops if no key is pressed.</p>
			<p>In the next section, let’s see how the ball works. It’s another core object in our game that we will need to do some work on in order to turn it into an online multiplayer game.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor151"/>Understanding the Ball scene</h2>
			<p>The<a id="_idIndexMarker227"/> ball is the passive element of the game and it essentially bounces around when it hits another physical body – either the paddles, the ceiling, or the floor. The latter two are <code>StaticBody2D</code>, which use <code>WorldBoundaryShape2D</code> in their <code>CollisionShape2D</code>.</p>
			<p>Let’s take a look at the <code>res://07.developing-online-pong/Ball.tscn</code> scene. The scene structure follows:</p>
			<div><div><img alt="Figure 7.2 – The Ball scene’s node hierarchy" src="img/Figure_07.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The Ball scene’s node hierarchy</p>
			<p>Before we open the <code>Ball</code> script, notice that the <code>CollisionShape2D</code> Resource has a built-in tool script attached to it. It’s a very simple script that draws the <code>CircleShape2D</code> Resource using the <code>CanvasItem.draw_circle()</code> method. This is the logic behind it:</p>
			<pre class="source-code">
@tool
extends CollisionShape2D
@export var color = Color.WHITE
func _draw():
     draw_circle(Vector2.ZERO, shape.radius, color)</pre>			<p>That said, let’s <a id="_idIndexMarker228"/>open the <code>Ball</code> script and see how it works, pay attention especially to the bouncing logic because it uses some interesting <code>Vector2</code> methods:</p>
			<pre class="source-code">
extends Node2D
@export var speed = 600.0
@onready var body = $CharacterBody2D
func move():
     body.velocity.x = [-speed, speed][randi()%2]
     body.velocity.y = [-speed, speed][randi()%2]
func reset():
     body.global_position = global_position
     move()
func _physics_process(delta):
     var collision = body.move_and_collide
         (body.velocity  delta)
     if collision:
          body.velocity = body.velocity.bounce
              (collision.get_normal())</pre>			<p>This code moves<a id="_idIndexMarker229"/> the ball’s <code>CharacterBody2D</code> node at a specified speed, randomizes its motion direction, detects collisions with other objects, and makes the character bounce off surfaces upon collision. By using this script, the ball performs a dynamic and responsive movement with collision detection.</p>
			<p>In the next section, we will understand how we detect when a player scores against the other.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor152"/>Managing players’ scores</h2>
			<p>When the ball reaches<a id="_idIndexMarker230"/> the left or right of the screen, the player on the opposite side should score. To detect this condition, we make use of a <code>ScoreArea</code> node, which, in essence, is an <code>Area2D</code> node.</p>
			<p>Open the <code>res://07.developing-online-pong/ScoreArea.tscn</code> scene and we’ll take a look at its scene tree structure:</p>
			<div><div><img alt="Figure 7.3 – The ScoreArea scene’s node hierarchy" src="img/Figure_07.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The ScoreArea scene’s node hierarchy</p>
			<p>As mentioned <a id="_idIndexMarker231"/>previously, it’s just an <code>Area2D</code> node; it doesn’t even have a <code>CollisionShape2D</code> Resource because, in this case, it’s more friendly to add it in the final scene so we can choose a specific <code>Shape2D</code> Resource for each <code>ScoreArea</code> node. Now, let’s take a look at its code:</p>
			<pre class="source-code">
extends Area2D
signal scored(score)
@export var score = 0
func _on_body_entered(body):
     score += 1
     scored.emit(score)</pre>			<p>This code provides a simple way to keep track of a score in a game using an <code>Area2D</code> node. It emits a scored signal whenever another physical body (in this case, the ball) enters the area, incrementing the score by one. By connecting to this signal, other game objects can respond to score updates and perform related actions. We use this signal later on in the <code>PongGame</code> class.</p>
			<p>To ensure<a id="_idIndexMarker232"/> the <code>ScoreArea</code> node only detects the ball, we make use <a id="_idIndexMarker233"/>of <strong class="bold">Collision Layers</strong> and <strong class="bold">Collision Masks</strong>. On the ball, here’s how these properties look:</p>
			<div><div><img alt="Figure 7.4 – The Ball Collision Layer and Collision Mask properties" src="img/Figure_07.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The Ball Collision Layer and Collision Mask properties</p>
			<p>The ball is in the <a id="_idIndexMarker234"/>second physics layer, but it masks the first one. This is so it detects collisions with the paddle, the floor, and the ceiling. It needs to be only on the second physics layer because the <code>ScoreArea</code> node only masks the second layer. We do that to prevent the <code>ScoreArea</code> node from detecting any other physics body, for instance, the floor or ceiling:</p>
			<div><div><img alt="Figure 7.5 – The ScoreArea Collision Layer and Collision Mask properties" src="img/Figure_07.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – The ScoreArea Collision Layer and Collision Mask properties</p>
			<p>And that’s how we ensure<a id="_idIndexMarker235"/> that the <code>ScoreArea</code> node will only interact with the ball. In the next section, we are going to see how we use this signal emitted by the <code>ScoreArea</code> node to actually update the displayed score, along with the overall logic behind the <code>PongGame</code> class.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor153"/>Tying everything together</h2>
			<p>You may have<a id="_idIndexMarker236"/> noticed that these classes operate independently without any coupling, which means that they cannot form a cohesive system on their own. The responsibility of integrating everything into a coherent system falls on the <code>PongGame</code> class.</p>
			<p>Let’s first take a look at its scene tree structure so we can understand how everything will interact. Open the <code>res://07.developing-online-pong/PongGame.tscn</code> scene and pay attention to the <strong class="bold">Scene</strong> dock:</p>
			<div><div><img alt="Figure 7.6 – The PongGame scene’s node hierarchy" src="img/Figure_07.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – The PongGame scene’s node hierarchy</p>
			<p>At this point, you <a id="_idIndexMarker237"/>already have a sense of most of these nodes. Let’s just take a moment to understand what <code>ScoreLabel</code> nodes does. It’s essentially just a text on the screen that displays each player’s score. For that, it uses a method that changes its text property based on the casting of the score received by the <code>ScoreArea.scored</code> signal (which is an integer) into a string. The whole <code>ScoreLabel</code> node’s code is as follows:</p>
			<pre class="source-code">
extends Label
func update_score(new_score):
     text = "%s" % new_score</pre>			<p>With that in mind, let’s jump into the <code>PongGame</code> code:</p>
			<pre class="source-code">
extends Node2D
@export var speed = 600.0
@onready var body = $CharacterBody2D
func move():
     body.velocity.x = [-speed, speed][randi()%2]
     body.velocity.y = [-speed, speed][randi()%2]
func reset():
     body.global_position = global_position
     move()
func _physics_process(delta):
     var collision = body.move_and_collide
         (body.velocity  delta)
     if collision:
          body.velocity = body.velocity.bounce
              (collision.get_normal())</pre>			<p>This code keeps<a id="_idIndexMarker238"/> track of scores, displays a winner when a player reaches the target score, and allows the game to be restarted when one of the players presses the <code>WinnerDisplay</code> Node interface. For visual reference, this is how <code>WinnerDisplay</code> node looks when toggled on:</p>
			<div><div><img alt="Figure 7.7 – The WinnerDisplay overlay showing the match’s winner" src="img/Figure_07.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – The WinnerDisplay overlay showing the match’s winner</p>
			<p>It also initializes the<a id="_idIndexMarker239"/> game by randomizing the ball’s movement and starting its initial motion. Also, when a player scores, it resets the ball by recentering it and starting its movement again.</p>
			<p>In this section, we went through all the core classes in our Pong game. They are currently meant for local multiplayer, so we need to modify them to support online multiplayer.</p>
			<p>In the next section, we are going to do the necessary work to turn our game into a remotely playable Pong game where two players interact with each other, each with one paddle so they can compete together!</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor154"/>Setting up online multiplayer paddles</h1>
			<p>It’s time to start your<a id="_idIndexMarker240"/> actual work. After understanding the whole project, let’s do the necessary work to allow players to play it online!</p>
			<p>In <a href="B18527_06.xhtml#_idTextAnchor131"><em class="italic">Chapter 6</em></a>, <em class="italic">Building an Online Checkers Game</em>, we saw that changing the multiplayer authority of a <code>SceneTree</code> branch allows the new peer to take over control of the changes made to that branch of nodes. This was how we made it so that the player playing on the white team couldn’t move the black team’s pieces, and vice versa.</p>
			<p>Being able to dynamically change the multiplayer authority is a core skill that we need to develop to maintain a coherent shared world for our players. In the situation we mentioned, players took turns in which each of them performed a single move and then the opposite player took control of their pieces. In this chapter, on the other hand, players must move<a id="_idIndexMarker241"/> simultaneously as this is an action game.</p>
			<p>In the upcoming sections, we are going to implement a simple approach to give each player a paddle to play with.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor155"/>Changing the paddle’s owner</h2>
			<p>In our paddle <a id="_idIndexMarker242"/>implementation, we have a small issue to address. Both paddles call <code>CharacterBody2D.move_and_slide()</code> inside the <code>_physics_process()</code> callback, on top of checking for <code>InputEvent</code> in the <code>_unhandled_input()</code> callback. This makes it so that if the other player moves their paddle, the movement may be overwritten in the opponent’s game. So, on top of re-assigning the paddles’ multiplayer authority, we also need to disable the opponent’s paddle callbacks. Open <code>res://07.developing-online-pong/Paddle.gd</code> and let’s do it! Follow these steps:</p>
			<ol>
				<li>Create a method called <code>setup_multiplayer()</code> and include the <code>player_id</code> argument, which represents the network identifier of the player:<pre class="source-code">
func setup_multiplayer(player_id):</pre></li>				<li>Decorate the <code>setup_multiplayer()</code> function with the <code>@rpc</code> annotation and use the <code>call_local</code> option. This will ensure that only the server can call this method, and it will also call it locally on the server’s endpoint:<pre class="source-code">
@rpc("call_local")
func setup_multiplayer(player_id):</pre></li>				<li>Inside the function, call the <code>set_multiplayer_authority()</code> method and pass it the <code>player_id</code> argument. With that, we have set up the paddle’s new multiplayer authority. Now, we need to prevent its movement if the <code>player_id</code> argument doesn’t match its multiplayer authority ID. We do that because this RPC function will be called on all peers, so the opponent’s paddle is supposed to run the following code block:<pre class="source-code">
@rpc("call_local")
func setup_multiplayer(player_id):
     set_multiplayer_authority(player_id)</pre></li>				<li>Use the <code>is_multiplayer_authority()</code> method to check that the current paddle’s peer ID doesn’t match the multiplayer authority’s peer ID:<pre class="source-code">
     if not is_multiplayer_authority():</pre></li>				<li>If this is the case, call the <code>set_physics_process()</code> function and pass it the <code>false</code> argument to disable physics processing:<pre class="source-code">
     if not is_multiplayer_authority():
          set_physics_process(false)</pre></li>				<li>Likewise, call the <code>set_process_unhandled_input()</code> function and pass <code>false</code> to<a id="_idIndexMarker243"/> disable handling unhandled input events on this paddle:<pre class="source-code">
if not is_multiplayer_authority():
          set_physics_process(false)
          set_process_unhandled_input(false)</pre></li>				<li>At the end, the whole <code>setup_multiplayer()</code> method should look like this:<pre class="source-code">
@rpc("call_local")
func setup_multiplayer(player_id):
     set_multiplayer_authority(player_id)
     if not is_multiplayer_authority():
          set_physics_process(false)
          set_process_unhandled_input(false)</pre></li>			</ol>
			<p>This code sets up<a id="_idIndexMarker244"/> multiplayer functionality by assigning the paddle’s multiplayer authority to a specified player. It then adjusts the behavior of the script based on whether the current instance is the authoritative peer. If the instance is not the authoritative peer, it disables physics and unhandled input processing to ensure that only the authoritative player performs those actions in this instance.</p>
			<p>In the next section, let’s understand how we gather and assign the player’s ID to each respective paddle.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor156"/>Assigning the players’ paddles</h2>
			<p>Now that each <a id="_idIndexMarker245"/>paddle can have its own multiplayer authority and have independent physics and input handling processes for each player, it’s time to understand how we are going to assign each player to their respective paddle. To do that, let’s open the <code>res://07.developing-online-pong/PongGame.gd</code> script and, right in its <code>_ready()</code> function, let’s create the necessary logic:</p>
			<ol>
				<li>First of all, include the <code>await</code> keyword followed by the <code>get_tree().create_timer(0.1).timeout</code> expression. This creates a delay of 0.1 seconds and waits for its <code>timeout</code> signal to emit. This is important because we are going to use RPCs to call functions on remote nodes, and these nodes may not be ready by the time the game executes this code, so instead it waits a brief moment before executing its behavior:<pre class="source-code">
func _ready():
     randomize()
     await(get_tree().create_timer(0.1).timeout)
     ball.move()</pre></li>				<li>Then, check whether the size of the connected peers is greater than <code>0</code> by using the <code>multiplayer.get_peers().size()</code> method. This will ensure the following behavior only happens if there are peers connected; otherwise, the game runs as it should locally:<pre class="source-code">
     await(get_tree().create_timer(0.1).timeout)
     if multiplayer.get_peers().size() &gt; 0:</pre></li>				<li>If this is the case, check whether the current instance is the current multiplayer authority by using <code>is_multiplayer_authority()</code>. This ensures that only the server will perform the player assignment:<pre class="source-code">
     await(get_tree().create_timer(0.1).timeout)
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():</pre></li>				<li>Inside this <a id="_idIndexMarker246"/>condition, assign the first connected peer to the <code>player_1</code> variable. This will store the first player’s ID in this variable:<pre class="source-code">
     await(get_tree().create_timer(0.1).timeout)
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               var player_1 = multiplayer.get_peers
                   ()[0]</pre></li>				<li>Then, assign the second connected peer to the <code>player_2</code> variable. This will store the second player’s ID in this variable:<pre class="source-code">
     await(get_tree().create_timer(0.1).timeout)
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               var player_1 = multiplayer.get_peers
                   ()[0]
               var player_2 = multiplayer.get_peers()
                   [1]</pre></li>				<li>Then, let’s<a id="_idIndexMarker247"/> use the <code>rpc()</code> method to call the <code>setup_multiplayer</code> method remotely on the <code>player_1_paddle</code> and <code>player_2_paddle</code> nodes, passing their respective <code>player</code> variables:<pre class="source-code">
if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               var player_1 = multiplayer.get_peers()
                   [0]
               var player_2 = multiplayer.get_peers()
                   [1]
               player_1_paddle.rpc
                   ("setup_multiplayer", player_1)
               player_2_paddle.rpc
                   ("setup_multiplayer", player_2)</pre></li>				<li>The whole <code>PongGame._ready()</code> callback should look like this after these changes:<pre class="source-code">
func _ready():
     randomize()
     await(get_tree().create_timer(0.1).timeout)
     if multiplayer.get_peers().size() &gt; 0:
          if is_multiplayer_authority():
               var player_1 = multiplayer.get_peers()
                   [0]
               var player_2 = multiplayer.get_peers()
                   [1]
               player_1_paddle.rpc
                   ("setup_multiplayer", player_1)
               player_2_paddle.rpc
                   ("setup_multiplayer", player_2)
     ball.move()</pre></li>			</ol>
			<p>This code <a id="_idIndexMarker248"/>demonstrates asynchronous programming and multiplayer setup. It starts by randomizing the random number generator and then introduces a delay of 0.1 seconds. It checks whether there are connected peers and whether the current instance is the multiplayer authority – in other words, the server. If these conditions are met, it assigns the connected peers to variables and uses RPCs to call the <code>Paddle.setup_multiplayer()</code> method with the respective peer information. Finally, it moves the <code>ball</code> object.</p>
			<p>In order to properly set up who controls it, we provide <code>Paddle.setup_multiplayer()</code> with the required data – specifically, the player ID. However, a small problem arises when each player can only control their own paddle. How will players update their opponent’s paddle position? Moreover, who should control the ball and how will its position be updated in both players’ game instances? These questions will be addressed in the next section.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor157"/>Syncing remote objects</h1>
			<p>With each player<a id="_idIndexMarker249"/> controlling their respective paddle in their own game instance, we have a small problem. The opponent’s paddle will not update its movement because we ensured that both its physics and input processes were disabled after we assigned a new multiplayer authority. Due to that, the ball may also bounce on the opponent’s paddle and create a different movement trajectory in each player’s<a id="_idIndexMarker250"/> game instance. We need to ensure that players are sharing the same game world and, for that, we are going to sync the objects across the network using <code>MultiplayerSynchronizer</code>. In the next section, we are going to start the syncing of the ball.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor158"/>Updating the ball’s position</h2>
			<p>The first thing<a id="_idIndexMarker251"/> we are going to do is ensure the ball’s position is synced across all peers. This is because we want to prevent players from dealing with different balls in their game instances, since this may lead them to make decisions based on wrong information. For instance, a player may move toward a ball that, in their game instance, is moving toward the ceiling, while in the server’s game instance, the ball is actually moving toward the floor. Let’s open <code>res://07.developing-online-pong/Ball.tscn</code> and start the simple process:</p>
			<ol>
				<li>Add <code>MultiplayerSynchronizer</code> as the <code>Ball</code> node’s child. We are going to use this node’s features to keep all peers up to date with the ball’s <code>CharacterBody2D</code> position:</li>
			</ol>
			<div><div><img alt="Figure 7.8 – The Ball scene’s node hierarchy with a newly added MultiplayerSynchronizer node" src="img/Figure_07.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – The Ball scene’s node hierarchy with a newly added MultiplayerSynchronizer node</p>
			<ol>
				<li value="2">Then, using the <code>CharacterBody2D:position</code> property to replicate across the connected peers:</li>
			</ol>
			<div><div><img alt="Figure 7.9 – The ball’s CharacterBody2D position property in the MultiplayerSynchronizer Replication menu" src="img/Figure_07.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – The ball’s CharacterBody2D position property in the MultiplayerSynchronizer Replication menu</p>
			<ol>
				<li value="3">Finally, since <a id="_idIndexMarker252"/>we are working with physics bodies here, we need to ensure that the <code>MultiplayerSynchronizer</code> updates to the local <code>Physics</code> update, ensuring that the game will take into account any collisions and other physics simulations when it updates the <code>Paddle</code> instances:</li>
			</ol>
			<div><div><img alt="Figure 7.10 – The ball’s MultiplayerSynchronizer’s Visibility Update property set to Physics" src="img/Figure_7.10_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – The ball’s MultiplayerSynchronizer’s Visibility Update property set to Physics</p>
			<ol>
				<li value="4">To prevent any<a id="_idIndexMarker253"/> overwriting of the ball’s position in any player’s instance of the game, let’s open the ball’s script and add a code snippet at its <code>_ready()</code> callback stating that if this peer isn’t the multiplayer authority, it will disable the ball’s <code>_physics_process()</code>callback. This will make it so that only the server has the authority to actually calculate the ball’s movement and, ultimately, its position, while players only replicate this in their game instances:<pre class="source-code">
func _ready():
     if not is_multiplayer_authority():
          set_physics_process(false)</pre></li>			</ol>
			<p>With that, the ball’s movement should be the same across all connected peers, preventing them from making decisions based on an object that the other peers are seeing differently. This would break the game experience because, ultimately, the players would be playing in a different game world making movements that don’t make sense to their peers. In the next section, let’s do the same process for the <code>Paddle</code> object; of course, in this one, we won’t need to disable <code>_physics_process()</code> because we do that when we set up its multiplayer authority.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor159"/>Coordinating the paddle’s position</h2>
			<p>Finally, it’s time to <a id="_idIndexMarker254"/>sync the players’ paddle positions to each other so they see their opponent’s moves and can be on the same page. Let’s open the <code>res://07.developing-online-pong/Paddle.tscn</code> scene and start the work:</p>
			<ol>
				<li>Add a new <code>MultiplayerSynchronizer</code> as a <code>Paddle</code> child:</li>
			</ol>
			<div><div><img alt="Figure 7.11 – The Paddle scene’s node hierarchy with a newly added MultiplayerSynchronizer node" src="img/Figure_07.11_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – The Paddle scene’s node hierarchy with a newly added MultiplayerSynchronizer node</p>
			<ol>
				<li value="2">In the <code>CharacterBody2D:position</code> property to replicate across the connected peers:</li>
			</ol>
			<div><div><img alt="Figure 7.12 – The Paddle CharacterBody2D position property in the MultiplayerSynchronizer Replication menu" src="img/Figure_07.12_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – The Paddle CharacterBody2D position property in the MultiplayerSynchronizer Replication menu</p>
			<ol>
				<li value="3">Just like in<a id="_idIndexMarker255"/> the <strong class="bold">Ball</strong> scene case, we are also working with a physics body here, so change the <strong class="bold">Visibility Update</strong> property to update during the <strong class="bold">Physics</strong> process:</li>
			</ol>
			<div><div><img alt="Figure 7.13 – The Paddle MultiplayerSynchronizer Visibility Update property set to Physics" src="img/Figure_07.13_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – The Paddle MultiplayerSynchronizer Visibility Update property set to Physics</p>
			<p>With this implementation, each<a id="_idIndexMarker256"/> opponent’s paddle will have its <code>CharacterBody2D</code> position synchronized across all peers in the game. This results in a shared game world that players can enjoy together while competing in a fair environment.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor160"/>Summary</h1>
			<p>In this chapter, we learned how the Godot Engine High-Level Network API provides quick and easy solutions to assign the correct “owner” of a game object and sync its state across the network. This ensures that players are playing in a shared environment with an actual human opponent on the other side.</p>
			<p>We learned how to check whether the current game instance is the multiplayer authority and make it perform the proper behavior accordingly. We also learned how to change the multiplayer authority of a node hierarchy on the <code>SceneTree</code>, ensuring that only a given player can make and sync changes regarding this node and its children. To sync the changes, we used <code>MultiplayerSynchronizer</code> with the <strong class="bold">Physics</strong> mode of <strong class="bold">Visibility Update</strong> to ensure that the physics interactions of the game objects are synced across all network peers.</p>
			<p>In the upcoming chapter, we will strengthen our knowledge of online multiplayer games by creating a platformer game that two or more players can play together and explore the game world as they please. We are confident that this will be an exciting addition to our game development skills.</p>
		</div>
	</body></html>