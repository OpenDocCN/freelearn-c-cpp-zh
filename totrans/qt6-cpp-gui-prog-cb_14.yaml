- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt 6 is known for its optimized performance. However, performance issues may
    still occur if your code is poorly written. There are many ways we can identify
    these issues and fix them before releasing the software to our users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing forms and C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling and optimizing QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering and animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements for this chapter include Qt 6.6.1 MinGW 64 bit, Qt
    Creator 12.0.2, and Windows 11\. All the code used in this chapter can be downloaded
    from the following GitHub repository at [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing forms and C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s very important to learn how to optimize your form-based Qt 6 applications
    that are built with C++. The best way to do that is to learn how to measure and
    compare the different methods that are used and decide which one works the best
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a `mainwindow.cpp`. After that, add the following headers to the
    top of the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `QGridLayout` object and set its parent to `centralWidget`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: QElapsedTimer* time = new QElapsedTimer;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: time->start();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use two loops to add 600 push buttons to our grid layout and connect
    all of them to a lambda function when clicked. We will then measure the elapsed
    time and print out the result, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we build and run the project now, we will see a window filled with lots
    of buttons. When we click on one of them, a message box will pop up on the screen.
    It only took around nine milliseconds on my computer to create and lay out all
    of the 600 buttons on the main window. There is also no performance issue when
    we move the window around or resize it, which is quite impressive. It proves that
    Qt 6 can handle this pretty well. However, please be aware that your users might
    be using older machines, and you might want to be extra careful when designing
    your user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Spawn 600 buttons on a Qt window](img/B20976_14_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Spawn 600 buttons on a Qt window
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a style sheet to each of the buttons, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the program again. This time, it took roughly 75 milliseconds
    to set up the GUI. This means that the style sheet does have some impact on the
    performance of your program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Apply the style sheet to all 600 buttons](img/B20976_14_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Apply the style sheet to all 600 buttons
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are done with that, let’s do some performance tests on different types
    of C++ containers. Open up `main.cpp` and add the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `testArray()` function before the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another function called `testVector()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are done with that, proceed to create yet another function called
    `testQtVector()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main()` function, define a `QElapsedTimer` object and an integer
    variable called `lastElapse`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will call the three functions we created in the previous steps to test their
    performance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the program now; we will see the performance differences between
    these containers. On my computer, the array took 650 milliseconds to execute,
    while the STL vector took roughly 3,830 milliseconds, and the Qt vector took around
    5,400 milliseconds to execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the array is still the container that yields the best performance,
    despite its lack of features compared to the other two. Surprisingly, Qt’s own
    vector class works slightly slower than the vector container provided by the C++
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a **Qt Widgets Application** project, try to do the following
    to improve performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid adding too many pages to a stacked widget and filling them with widgets,
    as Qt needs to find all of them recursively during the rendering process and event
    handling, which will highly impact the program’s performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do note that the `QWidget` class uses the Raster Engine, a software renderer,
    to render the widgets instead of using the GPU. However, it is lightweight enough
    to keep the performance good most of the time. Alternatively, you could consider
    using QML for your program’s GUI instead, since it is fully hardware accelerated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Turn off **mouseTracking**, **tabletTracking**, and other event catching for
    your widgets if they do not need it. This tracking and catchings adds to the CPU
    usage costs of your program:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Disable mouseTracking and tabletTracking for optimization](img/B20976_14_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Disable mouseTracking and tabletTracking for optimization
  prefs: []
  type: TYPE_NORMAL
- en: Keep your style sheets as simple as possible. A large style sheet needs a longer
    time for Qt to parse the information into the rendering system, which will also
    impact performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different C++ containers produce different speeds, as we showed in the preceding
    example. Surprisingly, Qt’s vector container is slightly slower than STL’s (the
    C++ standard library) vector container. Overall, the good old C++ array is still
    the fastest, but does not provide sorting functionality. Use what is best for
    your requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For large operations, use *asynchronous* methods whenever possible as it will
    not stall the main process and will keep your program running smoothly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Multi-threading* is really good for running different operations in parallel
    event loops. However, it can also become quite ugly if not done right, for example,
    creating and destroying threads frequently, or with inter-thread communications
    that are not planned well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to avoid using the web engine unless absolutely necessary. This is because
    embedding a full web browser on your program is really heavy overkill, especially
    for a small application. You can consider using QML instead of making a hybrid
    application if you want to create user interface-centric software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing performance tests as we did in the preceding example project, you can
    easily determine which method is the best choice for your project and how to make
    your program perform better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Qt 5, we can use the `QTime` class to do the test as seen in this section.
    However, functions such as `start()` and `elapsed()` have been deprecated from
    the `QTime` class in Qt 6\. Since Qt 6, the player must use `QElapsedTimer` to
    handle this.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling and optimizing QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The QML engine in Qt 6 took advantage of hardware acceleration to make its rendering
    capability and performance superior to the old widgets user interface. However,
    this does not mean that you do not need to worry about optimization, because small
    performance issues may snowball into bigger problems over time and cause damage
    to your product’s reputation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to start profiling and optimizing a QML application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a **Qt Quick** **Application** project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Create a Qt Quick Application project](img/B20976_14_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Create a Qt Quick Application project
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, go to **Analyze | QML Profiler** and run the **QML** **Profiler** tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Run the QML Profiler to check the QML performance](img/B20976_14_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Run the QML Profiler to check the QML performance
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Qt Quick project will then be run by the QML Profiler. The **QML Profiler**
    window will also appear under the code editor. Click the **Stop** button located
    at the top bar of the **QML Profiler** window after the program has passed the
    test point, which in this case meant successfully creating the empty window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle
    icon](img/B20976_14_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle
    icon
  prefs: []
  type: TYPE_NORMAL
- en: 'After you stop the profiler analysis, a timeline will be displayed in the **Timeline**
    tab under the **QML Profiler** window. There are four tabs that you can switch
    between, namely **Timeline**, **Flame Graph**, **Quick3D Frame**, and **Statistics**,
    at the bottom of the **QML** **Profiler** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.7 – You can look at different data on different tabs](img/B20976_14_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – You can look at different data on different tabs
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check out the **Timeline** tab. We can see six different categories under
    the timeline display: **Scene Graph**, **Memory Usage**, **Input Events**, **Compiling**,
    **Creating**, and **Binding**. These categories give us an overview of the different
    stages and processes of our program throughout its execution. We can also see
    some colorful bars displayed on the timeline. Let’s click on one of the bars under
    the **Creating** category that says **QtQuick/Window**. Once clicked, we will
    see the total duration for this operation and the location of the code displayed
    in a rectangular window located at the top of the QML Profiler window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.8 – The Timeline tab](img/B20976_14_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – The Timeline tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are done with that, let’s move on and open up the **Flame Graph**
    tab instead. Under the **Flame Graph** tab, you will see the visualization of
    the total time, memory, and allocation of your application in the form of percentages.
    You can switch between total time, memory, and allocation by clicking on the selection
    box that’s located at the top-right corner of the **QML** **Profiler** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.9 – The Flame Graph tab](img/B20976_14_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – The Flame Graph tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only that, you will also see the percentage value displayed on your QML
    code editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Percentage values are shown on the right](img/B20976_14_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – Percentage values are shown on the right
  prefs: []
  type: TYPE_NORMAL
- en: Open up the **Quick3D Frame** category under the **QML Profiler** window. This
    tab is where you check the performance of 3D rendering. It is currently empty
    because we are not doing any 3D rendering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let’s open up the **Statistics** category. This tab basically shows us
    information about the processes in table form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.11 – The Statistics tab](img/B20976_14_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.11 – The Statistics tab
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is similar to what we did in the previous example project that used C++
    and widgets except, this time, it is automatically analyzed by the **QML Profiler**
    tool that’s provided by Qt 6.
  prefs: []
  type: TYPE_NORMAL
- en: The QML Profiler not only produces the total time used for running a specific
    process, but also displays the memory allocation, the execution timeline of your
    application, and other information that gives you insight into the performance
    of your software.
  prefs: []
  type: TYPE_NORMAL
- en: By looking at the data that was analyzed by the QML Profiler, you will be able
    to find out which part of your code slows down the program, allowing you to fix
    any problems quickly.
  prefs: []
  type: TYPE_NORMAL
- en: There are some rules that you need to be aware of when writing QML to avoid
    performance bottlenecks. For instance, type conversion can sometimes be expensive,
    especially between types that are not closely matched (string to number, for example).
    Small issues like this will likely snowball into bottlenecks as your project grows
    larger over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than that, try not to use `id` for an item lookup multiple times in blocks
    of code that are run often, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can use a variable to cache the data and avoid multiple look-ups
    on the same item over and over again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides, if you change the property of a binding expression, especially in
    a loop, Qt will be forced to re-evaluate it repeatedly. This will cause some performance
    issues. Instead of doing this, the user should follow the next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can use a temporary variable for storing the data of `myValue`,
    then apply the final result back to `myValue` once the loop has been completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Consider using an anchor to position your UI items instead of using bindings.
    Item positioning with bindings is really slow and inefficient, although it allows
    for maximum flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering and animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to an application that renders graphics and animation, good performance
    is critical. Users can easily notice performance issues when graphics are not
    animated smoothly on screen. In the following example, we will look at how we
    can further optimize a graphics-heavy Qt Quick application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to render animation in QML, follow this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `tux.png` to our project’s resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.12 – Include main.qml and tux.png into your project resources](img/B20976_14_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.12 – Include main.qml and tux.png into your project resources
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `650` x `650`. We will also add `id` to the `window` item and name
    it `window`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code inside the `window` item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right after that, add `Repeater` and `Image` under it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will proceed and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are done with that, add the following code below the previous code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code animates the `x` property of the image. We need another
    `NumberAnimation` property to animate the `y` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we repeat the entire code of `ParallelAnimation`, except this time,
    we swap the `from` and `to` values, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The same goes for `NumberAnimation` for the `y` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we add a `Text` item for displaying the frame rate of our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add `Timer` under `Text` and update the frame rate to display every second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we build and run the program now, we will be able to see several penguins
    moving around the screen with a steady 60 fps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.13 – 10 penguins floating around the window](img/B20976_14_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.13 – 10 penguins floating around the window
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to our code and change the `model` property of the `Repeater`
    item to `10000`. Build and run the program again; you should see that your window
    is full of moving penguins and that the frame rate has significantly dropped to
    roughly 39 fps, which is not too bad, considering the amount of penguins we have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.14 – 10,000 penguins floating around the window](img/B20976_14_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.14 – 10,000 penguins floating around the window
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s go back to our source code and comment out both of the `sourceSize`
    properties. We also set the `smooth` and `antialiasing` properties to `false`,
    while setting the `asynchronous` property to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s build and run the program again. This time, the frame rate dropped slightly
    to 32 fps, but the penguins look smoother and are of better quality, even when
    moving:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.15 – Our penguins look much smoother now without slowing down too
    much](img/B20976_14_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.15 – Our penguins look much smoother now without slowing down too
    much
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The QML engine that powers Qt Quick applications is very optimized and powerful
    when it comes to rendering animated graphics on screen. However, there are still
    some tips that we can follow to make it even faster.
  prefs: []
  type: TYPE_NORMAL
- en: Try and make use of the built-in features provided by Qt 6 instead of implementing
    your own, such as `Repeater`, `NumberAnimation`, and `SequentialAnimation`. This
    is because Qt 6 developers have put great effort into optimizing these features
    so that you don’t have to.
  prefs: []
  type: TYPE_NORMAL
- en: The `sourceSize` properties tell Qt to resize the image before loading it into
    memory so that large images do not use more memory than necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The `smooth` property, when enabled, tells Qt to filter the image to make look
    it smoother when scaled or transformed from its natural size. It will not make
    any difference if the image is rendered at the same as its `sourceSize` value.
    This property will impact the performance of your application on some older hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The `antialiasing` property tells Qt to remove the aliasing artifacts around
    the edge of the image and make it look smoother. This property will also impact
    the performance of your program.
  prefs: []
  type: TYPE_NORMAL
- en: The `asynchronous` property tells Qt to load the image under a low-priority
    thread, which means that your program will not stall when loading huge image files.
  prefs: []
  type: TYPE_NORMAL
- en: We used the frame rate to indicate the performance of our program. Since `onAfterRendering`
    always gets called on every frame, we can then accumulate the frame variable on
    every render. Then, we used `Timer` to reset the frame value every second.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we displayed the value on screen using a `Text` item.
  prefs: []
  type: TYPE_NORMAL
