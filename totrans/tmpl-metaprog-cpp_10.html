<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer043">
			<h1 id="_idParaDest-113"><em class="italic"><a id="_idTextAnchor123"/>Chapter 7</em>: Patterns and Idioms</h1>
			<p>The previous parts of the book were designed to help you learn everything about templates, from the basics to the most advanced features, including the latest concepts and constraints from C++20. Now, it is time for us to put this knowledge to work and learn about various metaprogramming techniques. In this chapter, we will discuss the following topics:</p>
			<ul>
				<li>Dynamic versus static polymorphism</li>
				<li>The <strong class="bold">Curiously Recurring Template Pattern</strong> (<strong class="bold">CRTP</strong>)</li>
				<li>Mixins</li>
				<li>Type erasure</li>
				<li>Tag dispatching</li>
				<li>Expression templates</li>
				<li>Typelists</li>
			</ul>
			<p>By the end of the chapter, you will have a good understanding of various multiprogramming techniques that will help you solve a variety of problems.</p>
			<p>Let’s start the chapter by discussing the two forms of polymorphism: dynamic and static.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor124"/>Dynamic versus static polymorphism</h1>
			<p>When you learn <a id="_idIndexMarker628"/>about object-oriented <a id="_idIndexMarker629"/>programming, you learn <a id="_idIndexMarker630"/>about its <a id="_idIndexMarker631"/>fundamental <a id="_idIndexMarker632"/>principles, which are <strong class="bold">abstraction</strong>, <strong class="bold">encapsulation</strong>, <strong class="bold">inheritance</strong>, and <strong class="bold">polymorphism</strong>. C++ is a multi-paradigm programming language that <a id="_idIndexMarker633"/>supports <a id="_idIndexMarker634"/>object-oriented programming too. Although a broader discussion on the principles of object-oriented programming is beyond the scope of this chapter and this book, it is worth discussing at least some aspects related to polymorphism.</p>
			<p>So, what is polymorphism? The term is <a id="_idIndexMarker635"/>derived from the Greek words for “<em class="italic">ma<a id="_idTextAnchor125"/>ny forms</em>”. In programming, it’s the ability of obj<a id="_idTextAnchor126"/>ects of different types to be treated as if they were of the same type. The C++ standard actually defines a polymorphic class as <a id="_idIndexMarker636"/>follows (see C++20 standard, paragraph <em class="italic">11.7.2</em>, <em class="italic">Virtual functions</em>):</p>
			<p class="author-quote">A class that declares or inherits a virtual function is called a polymorphic class.</p>
			<p>It also defines polymorphic objects based on this definition, as follows (see C++20 standard, paragraph <em class="italic">6.7.2</em>, <em class="italic">Object model</em>):</p>
			<p class="author-quote">Some objects are polymorphic (11.7.2); the implementation generates information associated with each such object that makes it possible to determine that object’s type during program execution.</p>
			<p>However, this actually refers to what is called <strong class="bold">dynamic polymorphism</strong> (or late binding), but there is <a id="_idIndexMarker637"/>yet another form of polymorphism, called <strong class="bold">static polymorphism</strong> (or early binding). Dynamic polymorphism occurs <a id="_idIndexMarker638"/>at runtime with the help of interfaces and virtual functions, while <a id="_idIndexMarker639"/>static polymorphism occurs <a id="_idIndexMarker640"/>at compile-time with the help of overloaded functions and templates. This is described in Bjarne Stroustrup’s glossary of terms for the C++ language (see <a href="https://www.stroustrup.com/glossary.html">https://www.stroustrup.com/glossary.html</a>):</p>
			<p class="author-quote">polymorphism - providing a single interface to<a id="_idTextAnchor127"/> entities of different types. virtual functions provide dynamic (run-time) polymorphism through an interface provided by a base class. Overloaded functions and templates provide static (compile-time) polymorphism.</p>
			<p>Let’s look at an example of dynamic polymorphism. The following is a hierarchy of classes representing different units in a game. These units may attack others, so there is a base class with a pure virtual function called <strong class="source-inline">attack</strong>, and several derived classes implementing specific units that override this virtual function doing different things (of course, for simplicity, here we just print a message to the console). It looks as follows:</p>
			<pre class="source-code">struct game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   virtual void attack() = 0;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct knight : game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack() override</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "draw sword\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct mage : game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack() override</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "spell magic curse\n"; }</pre>
			<pre class="source-code">};</pre>
			<p>Based on this hierarchy of classes (which according to the standard are called <strong class="bold">polymorphic classes</strong>), we can write the function <strong class="source-inline">fight</strong> shown as follows. This takes a sequence of pointers to <a id="_idIndexMarker641"/>objects of the base <strong class="source-inline">game_unit</strong> type and calls the <strong class="source-inline">attack</strong> member function. Here is its implementation:</p>
			<pre class="source-code">void fight(std::vector&lt;game_unit*&gt; const &amp; units)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   for (auto unit : units)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      unit-&gt;attack();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>This function does not need to know the actual type of each object because due to dynamic polymorphism, it can handle them as if they were of the same (base) type. Here is an example of using it:</p>
			<pre class="source-code">knight k;</pre>
			<pre class="source-code">mage m;</pre>
			<pre class="source-code">fight({&amp;k, &amp;m});</pre>
			<p>But now let’s say you could combine a mage and a knight and create a new unit, a knight <a id="_idIndexMarker642"/>mage with special abilities from <a id="_idIndexMarker643"/>both these units. C++ enables us to write code as follows:</p>
			<pre class="source-code">knight_mage km = k + m;</pre>
			<pre class="source-code">km.attack();</pre>
			<p>This does not come out of the box, but the language supports overloading operators, and we could do that for any user-defined types. To make the preceding line possible, we need the following:</p>
			<pre class="source-code">struct knight_mage : game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack() override</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "draw magic sword\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">knight_mage operator+(knight const&amp; k, mage const&amp; m)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return knight_mage{};</pre>
			<pre class="source-code">}</pre>
			<p>Keep in mind these are just some simple snippets without any complex code. But the ability to add a <strong class="source-inline">knight</strong> and a <strong class="source-inline">mage</strong> together to create a <strong class="source-inline">knight_mage</strong> is nothing short of the ability to add two integers together, or a <strong class="source-inline">double</strong> and an <strong class="source-inline">int</strong>, or two <strong class="source-inline">std::string</strong> objects. This happens because there are many overloads of the <strong class="source-inline">+</strong> operator (both for built-in types and user-defined types) and based on the operands, the compiler is selecting the appropriate overload. Therefore, it can be said there are many forms of this operator. This is true for all the operators that can be overloaded; the <strong class="source-inline">+</strong> operator is just a <a id="_idIndexMarker644"/>typical example since it is ubiquitous. And this is the compile-time version of polymorphism, called <strong class="bold">static polymorphism</strong>.</p>
			<p>Operators are <a id="_idIndexMarker645"/>not the only functions that can <a id="_idIndexMarker646"/>be overloaded. Any function can be overloaded. Although we have seen many examples in the book, let’s take another one:</p>
			<pre class="source-code">struct attack  { int value; };</pre>
			<pre class="source-code">struct defense { int value; };</pre>
			<pre class="source-code">void increment(attack&amp; a)  { a.value++; }</pre>
			<pre class="source-code">void increment(defense&amp; d) { d.value++; }</pre>
			<p>In this snippet, the <strong class="source-inline">increment</strong> function is overloaded for both the <strong class="source-inline">attack</strong> and <strong class="source-inline">defense</strong> types, allowing us to write code as follows:</p>
			<pre class="source-code">attack a{ 42 };</pre>
			<pre class="source-code">defense d{ 50 };</pre>
			<pre class="source-code">increment(a);</pre>
			<pre class="source-code">increment(d);</pre>
			<p>We can replace the two overloads of <strong class="source-inline">increment</strong> with a function template. The changes are minimal, as shown in the next snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void increment(T&amp; t) { t.value++; }</pre>
			<p>The previous code continues to work, but there is a significant difference: in the former example, we had two overloads, one for <strong class="source-inline">attack</strong> and one for <strong class="source-inline">defense</strong>, so you could call the function with objects of these types but nothing else. In the latter, we have a template that defines a family of overloaded functions for any possible type <strong class="source-inline">T</strong> that has a data member called <strong class="source-inline">value</strong> whose type supports the post-increment operator. We can define constraints for such a function template, which is something we have seen in the previous two <a id="_idIndexMarker647"/>chapters of the book. However, the <a id="_idIndexMarker648"/>key takeaway is that overloaded functions and templates are the mechanisms to implement static polymorphism in the C++ language.</p>
			<p>Dynamic polymorphism incurs a performance cost because in order to know what functions to call, the compiler needs to build a table of pointers to virtual functions (and also a table of pointers to virtual base classes in case of virtual inheritance). So, there is some level of indirection when calling virtual functions polymorphically. Moreover, the details of virtual functions are not made available to the compiler who cannot optimize them.</p>
			<p>When these things can be validated as performance issues, we could raise the question: can we get the benefits of dynamic polymorphism at compile time? The answer is yes and there is one way to achieve this: the Curiously Recurring Template Pattern, which we will discuss next.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor128"/>The Curiously Recurring Template Pattern</h1>
			<p>This pattern has a rather <a id="_idIndexMarker649"/>curious name: the <strong class="bold">Curiously Recurring Template Pattern</strong>, or <strong class="bold">CRTP</strong> for short. It’s called curious because it is rather odd and unintuitive. The pattern was first described (and its name coined) by James Coplien in a column in the <em class="italic">C++ Report</em> in 1995. This pattern is as follows:</p>
			<ul>
				<li>There is a base class template that defines the (static) interface.</li>
				<li>Derived classes are themselves the template argument for the base class template.</li>
				<li>The member functions of the base class call member functions of its type template parameter (which are the derived classes).</li>
			</ul>
			<p>Let’s see how the pattern implementation looks in practice. We will transform the previous example with game units into a version using the CRTP. The pattern implementation goes as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      static_cast&lt;T*&gt;(this)-&gt;do_attack();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct knight : game_unit&lt;knight&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void do_attack()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "draw sword\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct mage : game_unit&lt;mage&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void do_attack()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "spell magic curse\n"; }</pre>
			<pre class="source-code">};</pre>
			<p>The <strong class="source-inline">game_unit</strong> class is now a template class but contains the same member function, <strong class="source-inline">attack</strong>. Internally, this performs an upcast of the <strong class="source-inline">this</strong> pointer to <strong class="source-inline">T*</strong> and then invokes a <a id="_idIndexMarker650"/>member function called <strong class="source-inline">do_attack</strong>. The <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> classes derive from the <strong class="source-inline">game_unit</strong> class and pass themselves as the argument for the type template parameter <strong class="source-inline">T</strong>. Both provide a member function called <strong class="source-inline">do_attack</strong>. </p>
			<p>Notice that the member function in the base class template and the called member function in the derived classes have different names. Otherwise, if they had the same name, the derived class member functions would hide the member from the base since these are no longer virtual functions.</p>
			<p>The <strong class="source-inline">fight</strong> function that takes a collection of game units and calls the <strong class="source-inline">attack</strong> function needs to change too. It needs to be implemented as a function template, as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void fight(std::vector&lt;game_unit&lt;T&gt;*&gt; const &amp; units)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   for (auto unit : units)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      unit-&gt;attack();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Using this <a id="_idIndexMarker651"/>function is a little different than before. It goes as follows:</p>
			<pre class="source-code">knight k;</pre>
			<pre class="source-code">mage   m;</pre>
			<pre class="source-code">fight&lt;knight&gt;({ &amp;k });</pre>
			<pre class="source-code">fight&lt;mage&gt;({ &amp;m });</pre>
			<p>We have moved the runtime polymorphism to compile-time. Therefore, the <strong class="source-inline">fight</strong> function cannot treat <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> objects polymorphically. Instead, we get two different overloads, one that can handle <strong class="source-inline">knight</strong> objects and one that can handle <strong class="source-inline">mage</strong> objects. This is static polymorphism.</p>
			<p>Although the pattern might not look complicated after all, the question you’re probably asking yourself at this point is: how is this pattern actually useful? There are different problems you can solve using CRT, including the following:</p>
			<ul>
				<li>Limiting the number of times a type can be instantiated</li>
				<li>Adding common functionality and avoiding code duplication</li>
				<li>Implementing the composite design pattern</li>
			</ul>
			<p>In the following <a id="_idIndexMarker652"/>subsections, we will look at each of these problems and see how to solve them with CRTP.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor129"/>Limiting the object count with CRTP</h2>
			<p>Let’s assume that for the game in which we created knights and mages we need some items to be available in <a id="_idIndexMarker653"/>a limited number of instances. For instance, there is a special <a id="_idIndexMarker654"/>sword type called <em class="italic">Excalibur</em> and there should be only one instance of it. On the <a id="_idIndexMarker655"/>other hand, there is a book of magic spells but there cannot be more than three instances of it at a time in the game. How do we solve this? Obviously, the sword problem could be solved with the singleton pattern. But what do we do when we need to limit the number to some higher value but still finite? The singleton pattern wouldn’t be of much help (unless we transform it into a “<em class="italic">multiton</em>”) but the CRTP would.</p>
			<p>First, we start with a base class template. The only thing this class template does is keep a count of how many times it has been instantiated. The counter, which is a static data member, is incremented in the constructor and decremented in the destructor. When that count exceeds a defined limit, an exception is thrown. Here is the implementation:</p>
			<pre class="source-code">template &lt;typename T, size_t N&gt;</pre>
			<pre class="source-code">struct limited_instances </pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static std::atomic&lt;size_t&gt; count;</pre>
			<pre class="source-code">   limited_instances()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      if (count &gt;= N)</pre>
			<pre class="source-code">         throw std::logic_error{ "Too many instances" };</pre>
			<pre class="source-code">      ++count;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   ~limited_instances() { --count; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T, size_t N&gt;</pre>
			<pre class="source-code">std::atomic&lt;size_t&gt; limited_instances&lt;T, N&gt;::count = 0;</pre>
			<p>The second part of the template consists of defining the derived classes. For the mentioned problem, they are as follows:</p>
			<pre class="source-code">struct excalibur : limited_instances&lt;excalibur, 1&gt;</pre>
			<pre class="source-code">{};</pre>
			<pre class="source-code">struct book_of_magic : limited_instances&lt;book_of_magic, 3&gt;</pre>
			<pre class="source-code">{};</pre>
			<p>We can <a id="_idIndexMarker656"/>instantiate <strong class="source-inline">excalibur</strong> once. The second time we try to do the same (while the first instance is still alive) an <a id="_idIndexMarker657"/>exception will be thrown:</p>
			<pre class="source-code">excalibur e1;</pre>
			<pre class="source-code">try</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   excalibur e2;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">catch (std::exception&amp; e)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; e.what() &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>Similarly, we can instantiate <strong class="source-inline">book_of_magic</strong> three times and an exception will be thrown the fourth time we attempt to do that:</p>
			<pre class="source-code">book_of_magic b1;</pre>
			<pre class="source-code">book_of_magic b2;</pre>
			<pre class="source-code">book_of_magic b3;</pre>
			<pre class="source-code">try</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   book_of_magic b4;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">catch (std::exception&amp; e)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; e.what() &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>Next, we look <a id="_idIndexMarker658"/>at a more common <a id="_idIndexMarker659"/>scenario, adding common functionality to types.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor130"/>Adding functionality with CRTP</h2>
			<p>Another case when <a id="_idIndexMarker660"/>the curiously recurring template pattern <a id="_idIndexMarker661"/>can help us is providing common functionalities to derived classes through generic functions in a base class that relies solely on derived class members. Let’s take an example to understand this use case.</p>
			<p>Let’s suppose that some of our game units have member functions such as <strong class="source-inline">step_forth</strong> and <strong class="source-inline">step_back</strong> that move them one position, forward or backward. These classes would look as follows (at a bare minimum):</p>
			<pre class="source-code">struct knight</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void step_forth();</pre>
			<pre class="source-code">   void step_back();</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct mage</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void step_forth();</pre>
			<pre class="source-code">   void step_back();</pre>
			<pre class="source-code">};</pre>
			<p>However, it could be a requirement that everything that can move back and forth one step should <a id="_idIndexMarker662"/>also be able to advance or retreat an arbitrary number of steps. However, this functionality <a id="_idIndexMarker663"/>could be implemented based on the <strong class="source-inline">step_forth</strong> and <strong class="source-inline">step_back</strong> functions, which would help avoid having duplicate code in each of these game unit classes. The CRTP implementation for this problem would, therefore, look as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct movable_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void advance(size_t steps)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      while (steps--)</pre>
			<pre class="source-code">         static_cast&lt;T*&gt;(this)-&gt;step_forth();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   void retreat(size_t steps)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      while (steps--)</pre>
			<pre class="source-code">         static_cast&lt;T*&gt;(this)-&gt;step_back();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct knight : movable_unit&lt;knight&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void step_forth() </pre>
			<pre class="source-code">   { std::cout &lt;&lt; "knight moves forward\n"; }</pre>
			<pre class="source-code">   void step_back()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "knight moves back\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct mage : movable_unit&lt;mage&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void step_forth()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "mage moves forward\n"; }</pre>
			<pre class="source-code">   void step_back()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "mage moves back\n"; }</pre>
			<pre class="source-code">};</pre>
			<p>We can <a id="_idIndexMarker664"/>advance and retreat the units by calling the base <a id="_idIndexMarker665"/>class <strong class="source-inline">advance</strong> and <strong class="source-inline">retreat</strong> member functions as follows:</p>
			<pre class="source-code">knight k;</pre>
			<pre class="source-code">k.advance(3);</pre>
			<pre class="source-code">k.retreat(2);</pre>
			<pre class="source-code">mage m;</pre>
			<pre class="source-code">m.advance(5);</pre>
			<pre class="source-code">m.retreat(3);</pre>
			<p>You could argue that the same result could be achieved using non-member function templates. For the sake of discussion, such a solution is presented as follows:</p>
			<pre class="source-code">struct knight</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void step_forth()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "knight moves forward\n"; }</pre>
			<pre class="source-code">   void step_back()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "knight moves back\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct mage</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void step_forth()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "mage moves forward\n"; }</pre>
			<pre class="source-code">   void step_back()</pre>
			<pre class="source-code">   { std::cout &lt;&lt; "mage moves back\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void advance(T&amp; t, size_t steps)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   while (steps--) t.step_forth();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void retreat(T&amp; t, size_t steps)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   while (steps--) t.step_back();</pre>
			<pre class="source-code">}</pre>
			<p>The client <a id="_idIndexMarker666"/>code would <a id="_idIndexMarker667"/>need to change but the changes are actually small:</p>
			<pre class="source-code">knight k;</pre>
			<pre class="source-code">advance(k, 3);</pre>
			<pre class="source-code">retreat(k, 2);</pre>
			<pre class="source-code">mage m;</pre>
			<pre class="source-code">advance(m, 5);</pre>
			<pre class="source-code">retreat(m, 3);</pre>
			<p>The choice between these two may depend on the nature of the problem and your preferences. However, the CRTP has the advantage that it is describing well the interface of the derived classes (such as <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> in our example). With the non-member functions, you wouldn’t necessarily know about this functionality, which would probably come from a header that you need to include. However, with CRTP, the class interface is well visible to those using it. </p>
			<p>For the last <a id="_idIndexMarker668"/>scenario we discuss here, let’s see how CRTP <a id="_idIndexMarker669"/>helps to implement the composite design pattern.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor131"/>Implementing the composite design pattern</h2>
			<p>In their famous book, <em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em>, the Gang of Four (Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides) describe <a id="_idIndexMarker670"/>a structural pattern called composite that enables us to compose objects into larger structures and treat both individual objects and compositions uniformly. This pattern can be used when you want to represent part-whole hierarchies of objects and you want to ignore the differences between individual objects and compositions of individual objects.</p>
			<p>To put this pattern into practice, let’s consider the game scenario again. We h<a id="_idTextAnchor132"/>ave heroes that have special abilities and can do different actions, one of which is allying with another hero. That can be easily modeled as follows:</p>
			<pre class="source-code">struct hero</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   hero(std::string_view n) : name(n) {}</pre>
			<pre class="source-code">   void ally_with(hero&amp; u)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      connections.insert(&amp;u);</pre>
			<pre class="source-code">      u.connections.insert(this);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   std::string name;</pre>
			<pre class="source-code">   std::set&lt;hero*&gt; connections;</pre>
			<pre class="source-code">   friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, </pre>
			<pre class="source-code">                                   hero const&amp; obj);</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, </pre>
			<pre class="source-code">                         hero const&amp; obj)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   for (hero* u : obj.connections)</pre>
			<pre class="source-code">      os &lt;&lt; obj.name &lt;&lt; " --&gt; [" &lt;&lt; u-&gt;name &lt;&lt; "]" &lt;&lt; '\n';</pre>
			<pre class="source-code">   return os;</pre>
			<pre class="source-code">}</pre>
			<p>These heroes are represented by the <strong class="source-inline">hero</strong> class that contains a name, a list of connections <a id="_idIndexMarker671"/>to other <strong class="source-inline">hero</strong> objects, as well as a member function, <strong class="source-inline">ally_with</strong>, that defines an alliance between two heroes. We can use it as follows:</p>
			<pre class="source-code">hero k1("Arthur");</pre>
			<pre class="source-code">hero k2("Sir Lancelot");</pre>
			<pre class="source-code">hero k3("Sir Gawain");</pre>
			<pre class="source-code">k1.ally_with(k2);</pre>
			<pre class="source-code">k2.ally_with(k3);</pre>
			<pre class="source-code">std::cout &lt;&lt; k1 &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; k2 &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; k3 &lt;&lt; '\n';</pre>
			<p>The output of running this snippet is the following:</p>
			<p class="source-code"><strong class="bold">Arthur --&gt; [Sir Lancelot]</strong></p>
			<p class="source-code"><strong class="bold">Sir Lancelot --&gt; [Arthur]</strong></p>
			<p class="source-code"><strong class="bold">Sir Lancelot --&gt; [Sir Gawain]</strong></p>
			<p class="source-code"><strong class="bold">Sir Gawain --&gt; [Sir Lancelot]</strong></p>
			<p>Everything was simple so far. But the requirement is that heroes could be grouped together <a id="_idIndexMarker672"/>to form parties. It should be possible for a hero to ally with a group, and for a group to ally with either a hero or an entire group. Suddenly, there <a id="_idTextAnchor133"/>is an explosion of functions that we need to provide:</p>
			<pre class="source-code">struct hero_party;</pre>
			<pre class="source-code">struct hero</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void ally_with(hero&amp; u);</pre>
			<pre class="source-code">   void ally_with(hero_party&amp; p);</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct hero_party : std::vector&lt;hero&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void ally_with(hero&amp; u);</pre>
			<pre class="source-code">   void ally_with(hero_party&amp; p);</pre>
			<pre class="source-code">};</pre>
			<p>This is where the composite design pattern helps us treat heroes and parties uniformly and avoid unnecessary duplications of the code. As usual, there are different ways to implement it, but one way is using the curiously recurring template pattern. The implementation requires a base class that defines the common interface. In our case, this will be a class template with a single member function called <strong class="source-inline">ally_with</strong>:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct base_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename U&gt;</pre>
			<pre class="source-code">   void ally_with(U&amp; other);</pre>
			<pre class="source-code">};</pre>
			<p>We will define the <strong class="source-inline">hero</strong> class as a derived class from <strong class="source-inline">base_unit&lt;hero&gt;</strong>. This time, the <strong class="source-inline">hero</strong> class <a id="_idIndexMarker673"/>no longer implements <strong class="source-inline">ally_with</strong> itself. However, it features <strong class="source-inline">begin</strong> and <strong class="source-inline">end</strong> methods that are intended to simulate the behavior of a container:</p>
			<pre class="source-code">struct hero : base_unit&lt;hero&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   hero(std::string_view n) : name(n) {}</pre>
			<pre class="source-code">   hero* begin() { return this; }</pre>
			<pre class="source-code">   hero* end() { return this + 1; }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   std::string name;</pre>
			<pre class="source-code">   std::set&lt;hero*&gt; connections;</pre>
			<pre class="source-code">   template &lt;typename U&gt;</pre>
			<pre class="source-code">   friend struct base_unit;</pre>
			<pre class="source-code">   template &lt;typename U&gt;</pre>
			<pre class="source-code">   friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,</pre>
			<pre class="source-code">                                   base_unit&lt;U&gt;&amp; object);</pre>
			<pre class="source-code">};</pre>
			<p>The class that models a group of heroes is called <strong class="source-inline">hero_party</strong> and derives from both <strong class="source-inline">std::vector&lt;hero&gt;</strong> (to define a container of <strong class="source-inline">hero</strong> objects) and from <strong class="source-inline">base_unit&lt;hero_party&gt;</strong>. This is why the <strong class="source-inline">hero</strong> class has <strong class="source-inline">begin</strong> and <strong class="source-inline">end</strong> functions to help us perform iterating operations on <strong class="source-inline">hero<a id="_idTextAnchor134"/></strong> objects, just as we would do with <strong class="source-inline">hero_party</strong> objects:</p>
			<pre class="source-code">struct hero_party : std::vector&lt;hero&gt;, </pre>
			<pre class="source-code">                    base_unit&lt;hero_party&gt;</pre>
			<pre class="source-code">{};</pre>
			<p>We need to implement the <strong class="source-inline">ally_with</strong> member function of the base class. The code is shown <a id="_idIndexMarker674"/>as follows. What it does is iterate through all the sub-objects of the current object and connect<a id="_idTextAnchor135"/> them with all the sub-objects of the supplied argument:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">template &lt;typename U&gt;</pre>
			<pre class="source-code">void base_unit&lt;T&gt;::ally_with(U&amp; other)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   for (hero&amp; from : *static_cast&lt;T*&gt;(this))</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      for (hero&amp; to : other)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         from.connections.insert(&amp;to);</pre>
			<pre class="source-code">         to.connections.insert(&amp;from);</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">hero</strong> class declared the <strong class="source-inline">base_unit</strong> class template a friend so that it could access the <strong class="source-inline">connections</strong> member. It also declared the <strong class="source-inline">operator&lt;&lt;</strong> as a friend so that this function could access both the <strong class="source-inline">connections</strong> and <strong class="source-inline">name</strong> private members. For more information <a id="_idIndexMarker675"/>about templates and friends, see <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>. The output stream operator implementation is shown here:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,</pre>
			<pre class="source-code">                         base_unit&lt;T&gt;&amp; object)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   for (hero&amp; obj : *static_cast&lt;T*&gt;(&amp;object))</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      for (hero* n : obj.connections)</pre>
			<pre class="source-code">         os &lt;&lt; obj.name &lt;&lt; " --&gt; [" &lt;&lt; n-&gt;name &lt;&lt; "]" </pre>
			<pre class="source-code">            &lt;&lt; '\n';</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return os;</pre>
			<pre class="source-code">}</pre>
			<p>Having all this defined, we can write code as follows:</p>
			<pre class="source-code">hero k1("Arthur");</pre>
			<pre class="source-code">hero k2("Sir Lancelot");</pre>
			<pre class="source-code">hero_party p1;</pre>
			<pre class="source-code">p1.emplace_back("Bors");</pre>
			<pre class="source-code">hero_party p2;</pre>
			<pre class="source-code">p2.emplace_back("Cador");</pre>
			<pre class="source-code">p2.emplace_back("Constantine");</pre>
			<pre class="source-code">k1.ally_with(k2);</pre>
			<pre class="source-code">k1.ally_with(p1);</pre>
			<pre class="source-code">p1.ally_with(k2);</pre>
			<pre class="source-code">p1.ally_with(p2);</pre>
			<pre class="source-code">std::cout &lt;&lt; k1 &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; k2 &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; p1 &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; p2 &lt;&lt; '\n';</pre>
			<p>We can see from this that we are able to ally a <strong class="source-inline">hero</strong> with both another <strong class="source-inline">hero</strong> and a <strong class="source-inline">hero_party</strong>, as well as a <strong class="source-inline">hero_party</strong> with either a <strong class="source-inline">hero</strong> or another <strong class="source-inline">hero_party</strong>. That was the proposed goal, and we were able to do it without duplicating <a id="_idIndexMarker676"/>the code between <strong class="source-inline">hero</strong> and <strong class="source-inline">hero_party</strong>. The output of executing the previous snippet is the following:</p>
			<p class="source-code"><strong class="bold">Arthur --&gt; [Sir Lancelot]</strong></p>
			<p class="source-code"><strong class="bold">Arthur --&gt; [Bors]</strong></p>
			<p class="source-code"><strong class="bold">Sir Lancelot --&gt; [Arthur]</strong></p>
			<p class="source-code"><strong class="bold">Sir Lancelot --&gt; [Bors]</strong></p>
			<p class="source-code"><strong class="bold">Bors --&gt; [Arthur]</strong></p>
			<p class="source-code"><strong class="bold">Bors --&gt; [Sir Lancelot]</strong></p>
			<p class="source-code"><strong class="bold">Bors --&gt; [Cador]</strong></p>
			<p class="source-code"><strong class="bold">Bors --&gt; [Constantine]</strong></p>
			<p class="source-code"><strong class="bold">Cador --&gt; [Bors]</strong></p>
			<p class="source-code"><strong class="bold">Constantine --&gt; [Bors]</strong></p>
			<p>After <a id="_idIndexMarker677"/>seeing how the CRTP helps achieve different goals, let’s look at the use of the CRTP in the C++ standard library.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor136"/>The CRTP in the standard library</h2>
			<p>The standard <a id="_idIndexMarker678"/>library contains <a id="_idIndexMarker679"/>a helper type called <strong class="source-inline">std::enabled_shared_from_this</strong> (in the <strong class="source-inline">&lt;memory&gt;</strong> header) that enables objects managed by a <strong class="source-inline">std::shared_ptr</strong> to generate more <strong class="source-inline">std::shared_ptr</strong> instances in a safe manner. The <strong class="source-inline">std::enabled_shared_from_this</strong> class is the base class in the CRTP pattern. However, the previous description may sound abstract, so let’s try to understand it with examples.</p>
			<p>Let’s suppose we have a class called <strong class="source-inline">building</strong> and we are creating <strong class="source-inline">std::shared_ptr</strong> objects in the following manner:</p>
			<pre class="source-code">struct building {};</pre>
			<pre class="source-code">building* b = new building();</pre>
			<pre class="source-code">std::shared_ptr&lt;building&gt; p1{ b }; // [1]</pre>
			<pre class="source-code">std::shared_ptr&lt;building&gt; p2{ b }; // [2] bad</pre>
			<p>We have a raw pointer and, on line <strong class="source-inline">[1]</strong>, we instantiate a <strong class="source-inline">std::shared_ptr</strong> object to manage its lifetime. However, on line <strong class="source-inline">[2]</strong>, we instantiate a second <strong class="source-inline">std::shared_ptr</strong> object for the same pointer. Unfortunately, the two smart pointers know nothing of each other, so upon getting out of scope, they will both delete the <strong class="source-inline">building</strong> object allocated on the heap. Deleting an object that was already deleted is undefined behavior and will likely result in a crash of the program.</p>
			<p>The <strong class="source-inline">std::enable_shared_from_this</strong> class helps us create more <strong class="source-inline">shared_ptr</strong> objects <a id="_idIndexMarker680"/>from an existing <a id="_idIndexMarker681"/>one in a safe manner. First, we need to implement the CRTP pattern as follows:</p>
			<pre class="source-code">struct building : std::enable_shared_from_this&lt;building&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">};</pre>
			<p>Having this new implementation, we can call the member function <strong class="source-inline">shared_from_this</strong> to create more <strong class="source-inline">std::shared_ptr</strong> instances from a<a id="_idTextAnchor137"/>n object, which all refer to the same instance of the object:</p>
			<pre class="source-code">building* b = new building();</pre>
			<pre class="source-code">std::shared_ptr&lt;building&gt; p1{ b };    // [1]</pre>
			<pre class="source-code">std::shared_ptr&lt;building&gt; p2{ </pre>
			<pre class="source-code">   b-&gt;shared_from_this()};            // [2] OK</pre>
			<p>The interface of the <strong class="source-inline">std::enable_shared_from_this</strong> is as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">class enable_shared_from_this</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">  std::shared_ptr&lt;T&gt;       shared_from_this();</pre>
			<pre class="source-code">  std::shared_ptr&lt;T const&gt; shared_from_this() const;</pre>
			<pre class="source-code">  std::weak_ptr&lt;T&gt;       weak_from_this() noexcept;</pre>
			<pre class="source-code">  std::weak_ptr&lt;T const&gt; weak_from_this() const noexcept;</pre>
			<pre class="source-code">  enable_shared_from_this&lt;T&gt;&amp; operator=(</pre>
			<pre class="source-code">     const enable_shared_from_this&lt;T&gt; &amp;obj ) noexcept;</pre>
			<pre class="source-code">};</pre>
			<p>The previous example shows how <strong class="source-inline">enable_shared_from_this</strong> works but does not help understand when it is appropriate to use it. Therefore, let’s modify the example to show a realistic example.</p>
			<p>Let’s consider that the buildings we have can be upgraded. This is a process that takes some <a id="_idIndexMarker682"/>time and involves several <a id="_idIndexMarker683"/>steps. This task, as well as other tasks in the game, are executed by a designated entity, which we will call <strong class="source-inline">executor</strong>. In its simplest form, this <strong class="source-inline">executor</strong> class has a public member function called <strong class="source-inline">execute</strong> that takes a function object and executes it on a different thread. The following listing is a simple implementation:</p>
			<pre class="source-code">struct executor</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void execute(std::function&lt;void(void)&gt; const&amp; task)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      threads.push_back(std::thread([task]() { </pre>
			<pre class="source-code">         using namespace std::chrono_literals;</pre>
			<pre class="source-code">         std::this_thread::sleep_for(250ms);</pre>
			<pre class="source-code">         task(); </pre>
			<pre class="source-code">      }));</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   ~executor()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      for (auto&amp; t : threads)</pre>
			<pre class="source-code">         t.join();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   std::vector&lt;std::thread&gt; threads;</pre>
			<pre class="source-code">};</pre>
			<p>The <strong class="source-inline">building</strong> class has a pointer to an <strong class="source-inline">executor</strong>, which is passed from the client. It also has a <a id="_idIndexMarker684"/>member function <a id="_idIndexMarker685"/>called <strong class="source-inline">upgrade</strong> that kicks off the execution process. However, the actual upgrade occurs in a different, private, function called <strong class="source-inline">do_upgrade</strong>. This is called from a lambda expression that is passed to the <strong class="source-inline">execute</strong> member function of the <strong class="source-inline">executor</strong>. All these are shown in the following listing:</p>
			<pre class="source-code">struct building</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   building()  { std::cout &lt;&lt; "building created\n"; }</pre>
			<pre class="source-code">   ~building() { std::cout &lt;&lt; "building destroyed\n"; }</pre>
			<pre class="source-code">   void upgrade()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      if (exec)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         exec-&gt;execute([self = this]() {</pre>
			<pre class="source-code">            self-&gt;do_upgrade();</pre>
			<pre class="source-code">         });</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   }      </pre>
			<pre class="source-code">   void set_executor(executor* e) { exec = e; }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   void do_upgrade()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "upgrading\n";</pre>
			<pre class="source-code">      operational = false;</pre>
			<pre class="source-code">      using namespace std::chrono_literals;</pre>
			<pre class="source-code">      std::this_thread::sleep_for(1000ms);</pre>
			<pre class="source-code">      operational = true;</pre>
			<pre class="source-code">      std::cout &lt;&lt; "building is functional\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   bool operational = false;</pre>
			<pre class="source-code">   executor* exec = nullptr;</pre>
			<pre class="source-code">};</pre>
			<p>The client <a id="_idIndexMarker686"/>code is relatively <a id="_idIndexMarker687"/>simple: create an <strong class="source-inline">executor</strong>, create a building managed by a <a id="_idTextAnchor138"/><strong class="source-inline">shared_ptr</strong>, set the <strong class="source-inline">executor</strong> reference, and run the upgrade process:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   executor e;</pre>
			<pre class="source-code">   std::shared_ptr&lt;building&gt; b = </pre>
			<pre class="source-code">      std::make_shared&lt;building&gt;();</pre>
			<pre class="source-code">   b-&gt;set_executor(&amp;e);</pre>
			<pre class="source-code">   b-&gt;upgrade();</pre>
			<pre class="source-code">   std::cout &lt;&lt; "main finished\n";</pre>
			<pre class="source-code">}</pre>
			<p>If you run this program, you get the following output:</p>
			<p class="source-code">building created</p>
			<p class="source-code">main finished</p>
			<p class="source-code">building destroyed</p>
			<p class="source-code">upgrading</p>
			<p class="source-code">building is functional</p>
			<p>What we <a id="_idIndexMarker688"/>can see here is that <a id="_idIndexMarker689"/>the building is destroyed before the upgrade process begins. This incurs undefined behavior and, although this program didn’t crash, a real-world program would certainly crash. </p>
			<p>The culprit for this behavior is this particular line in the upgrading code:</p>
			<pre class="source-code">exec-&gt;execute(<strong class="bold">[self = this]</strong>() {</pre>
			<pre class="source-code">   self-&gt;do_upgrade();</pre>
			<pre class="source-code">});</pre>
			<p>We are creating a lambda expression that captures the <strong class="source-inline">this</strong> pointer. The pointer is<a id="_idTextAnchor139"/> later used after the object it points to has been destroyed. To avoid this, we would need to create and capture a <strong class="source-inline">shared_ptr</strong> object. The safe way to do that is with the help of the <strong class="source-inline">std::enable_shared_from_this</strong> class. There are two changes that need to be done. The first is to actually derive the <strong class="source-inline">building</strong> class from the <strong class="source-inline">std::enable_shared_from_this</strong> class:</p>
			<pre class="source-code">struct building : std::enable_shared_from_this&lt;building&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   /* … */</pre>
			<pre class="source-code">};</pre>
			<p>The second change requires us to call <strong class="source-inline">shared_from_this</strong> in the lambda capture:</p>
			<pre class="source-code">exec-&gt;execute(<strong class="bold">[self = sha<a id="_idTextAnchor140"/>red_from_this()]</strong>() {</pre>
			<pre class="source-code">   self-&gt;do_upgrade();</pre>
			<pre class="source-code">});</pre>
			<p>These are two slight changes to our code but the effect is significant. The building object is no longer destroyed before the lambda expression gets executed on a separate thread (because there is now an extra shared pointer that refers to the same object as the shared pointer created in the main function). As a result, we get the output we expected (without any changes to the client code):</p>
			<p class="source-code">building created</p>
			<p class="source-code">main finished</p>
			<p class="source-code">upgrading</p>
			<p class="source-code">building is functional</p>
			<p class="source-code">building destroyed</p>
			<p>You could argue <a id="_idIndexMarker690"/>that after the <a id="_idIndexMarker691"/>main <strong class="source-inline">function</strong> finishes, we shouldn’t care what happens. Mind that this is just a demo program, and in practice, this happens in some other function and the program continues to run long after that function returns. </p>
			<p>With this, we conclude the discussion around the curiously recurring template pattern. Next, we will look at a technique called <strong class="bold">mixins</strong> that is often mixed with the CRTP pattern.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor141"/>Mixins</h1>
			<p>Mixins are small classes that are designed to add functionality to other classes. If you read about mixins, you <a id="_idIndexMarker692"/>will often find that the curiously recurring template pattern is used to implement mixins in C++. This is an incorrect statement. The CRTP helps achieve a similar goal to mixins, but they are different techniques. The point of mixins is that they are supposed to add functionality to classes without being a base class to them, which is the key to the CRTP pattern. Instead, mixins are supposed to inherit from the classes they add functionality to, which is the CRTP upside down.</p>
			<p>Remember the earlier example with knights and mages that could move forth and back with the <strong class="source-inline">step_forth</strong> and <strong class="source-inline">step_back</strong> member functions? The <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> classes were derived from the <strong class="source-inline">movable_unit</strong> class template that added the functions <strong class="source-inline">advance</strong> and <strong class="source-inline">retreat</strong>, which enabled units to move several steps forth or back. The same example <a id="_idIndexMarker693"/>can be implemented using mixins in a reverse order. Here is how:</p>
			<pre class="source-code">struct knight</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void step_forth()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "knight moves forward\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   void step_back()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "knight moves back\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct mage</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void step_forth()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "mage moves forward\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   void step_back()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "mage moves back\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct movable_unit : T</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void advance(size_t steps)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      while (steps--)</pre>
			<pre class="source-code">         T::step_forth();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   void retreat(size_t steps)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      while (steps--)</pre>
			<pre class="source-code">         T::step_back();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>You will notice that <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> are now classes that don’t have any base class. They both provide the <strong class="source-inline">step_forth</strong> and <strong class="source-inline">step_back</strong> member functions just as they did before, when <a id="_idIndexMarker694"/>we implemented the CRTP pattern. Now, the <strong class="source-inline">movable_unit</strong> class template is derived from one of these classes and defines the <strong class="source-inline">advance</strong> and <strong class="source-inline">retreat</strong> functions, which call <strong class="source-inline">step_forth</strong> and <strong class="source-inline">step_back</strong> in a loop. We can use them as follows:</p>
			<pre class="source-code">movable_unit&lt;knight&gt; k;</pre>
			<pre class="source-code">k.advance(3);</pre>
			<pre class="source-code">k.retreat(2);</pre>
			<pre class="source-code">movable_unit&lt;mage&gt; m;</pre>
			<pre class="source-code">m.advance(5);</pre>
			<pre class="source-code">m.retreat(3);</pre>
			<p>This is very similar to what we had with the CRTP pattern, except that now we create instances of <strong class="source-inline">movable_unit&lt;knight&gt;</strong> and <strong class="source-inline">movable_unit&lt;mage&gt;</strong> instead of <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong>. A comparison of the two patterns is shown in the following diagram (with CRTP on the left and mixins on the right):</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="Images/Figure_7.1_B18367.jpg" alt="Figure 7.1: Comparison of the CRTP and the mixins patterns&#13;&#10;" width="1200" height="577"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1: Comparison of the CRTP and the mixins patterns</p>
			<p>We can combine the static polymorphism achieved with mixins with dynamic polymorphism achieved with interfaces and virtual functions. We’ll demonstrate this with the help of an example concerning game units that fight. We had an earlier example when we discussed the CRTP, where the <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> classes had a member function called <strong class="source-inline">attack</strong>.</p>
			<p>Let’s say we want to define multiple attacking styles. For instance, each game unit can use either an aggressive or a moderate attacking style. So that means four combinations: aggressive and moderate knights, and aggressive and moderate mages. On the other hand, both knights and mages could be lone warriors that are comfortable to fight alone, or are team players that always fight in a group with other units. </p>
			<p>That means we could have lone aggressive knights and lone moderate knights as well as team player aggressive knights and team player moderate knights. The same applies to mages. As you can see, the number of combinations grows a lot and mixins are a good way to provide this a<a id="_idTextAnchor142"/>dded functionality without expanding the <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> classes. Finally, we want to be able to treat all these polymorphically at runtime. Let’s see how we can do this.</p>
			<p>First, we can define <a id="_idIndexMarker695"/>aggressive and moderate fighting styles. These could be as simple as the following:</p>
			<pre class="source-code">struct aggressive_style</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void fight()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "attack! attack attack!\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct moderate_style</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void fight()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "attack then defend\n";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>Next, we define mixins as the requirement of being able to fight alone or in a group. These classes are <a id="_idIndexMarker696"/>templates and are derived from their template argument:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct lone_warrior : T</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void fight()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "fighting alone.";</pre>
			<pre class="source-code">      T::fight();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct team_warrior : T</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void fight()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "fighting with a team.";</pre>
			<pre class="source-code">      T::fight();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>Last, we need to define the <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> classes<a id="_idTextAnchor143"/>. These themselves will be mixins for the fighting styles. However, to be able to treat them polymorphically at runtime, we derive them from <a id="_idIndexMarker697"/>a base <strong class="source-inline">game_unit</strong> class that contains a pure virtual method called <strong class="source-inline">attack</strong> that these classes implement:</p>
			<pre class="source-code">struct game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   virtual void attack() = 0;</pre>
			<pre class="source-code">   virtual ~game_unit() = default;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct knight : T, game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "draw sword.";</pre>
			<pre class="source-code">      T::fight();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct mage : T, game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::cout &lt;&lt; "spell magic curse.";</pre>
			<pre class="source-code">      T::fight();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>The <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> implementation of the <strong class="source-inline">attack</strong> member function makes use of the <strong class="source-inline">T::fight</strong> method. You have probably noticed that both the <strong class="source-inline">aggresive_style</strong> and <strong class="source-inline">moderate_style</strong> classes on one hand and the <strong class="source-inline">lone_warrior</strong> and <strong class="source-inline">team_warrior</strong> mixin <a id="_idIndexMarker698"/>classes on the other hand provide such a member function. This means we can do the following combinations:</p>
			<pre class="source-code">std::vector&lt;std::unique_ptr&lt;game_unit&gt;&gt; units;</pre>
			<pre class="source-code">units.emplace_back(new knight&lt;aggressive_style&gt;());</pre>
			<pre class="source-code">units.emplace_back(new knight&lt;moderate_style&gt;());</pre>
			<pre class="source-code">units.emplace_back(new mage&lt;aggressive_style&gt;());</pre>
			<pre class="source-code">units.emplace_back(new mage&lt;moderate_style&gt;());</pre>
			<pre class="source-code">units.emplace_back(</pre>
			<pre class="source-code">   new knight&lt;lone_warrior&lt;aggressive_style&gt;&gt;());</pre>
			<pre class="source-code">units.emplace_back(</pre>
			<pre class="source-code">   new knight&lt;lone_warrior&lt;moderate_style&gt;&gt;());</pre>
			<pre class="source-code">units.emplace_back(</pre>
			<pre class="source-code">   new knight&lt;team_warrior&lt;aggressive_style&gt;&gt;());</pre>
			<pre class="source-code">units.emplace_back(</pre>
			<pre class="source-code">   new knight&lt;team_warrior&lt;moderate_style&gt;&gt;());</pre>
			<pre class="source-code">units.emplace_back(</pre>
			<pre class="source-code">   new mage&lt;lone_warrior&lt;aggressive_style&gt;&gt;());</pre>
			<pre class="source-code">units.emplace_back(</pre>
			<pre class="source-code">   new mage&lt;lone_warrior&lt;moderate_style&gt;&gt;());</pre>
			<pre class="source-code">units.emplace_back(</pre>
			<pre class="source-code">   new mage&lt;team_warrior&lt;aggressive_style&gt;&gt;());</pre>
			<pre class="source-code">units.emplace_back(</pre>
			<pre class="source-code">   new mage&lt;team_warrior&lt;moderate_style&gt;&gt;());</pre>
			<pre class="source-code">for (auto&amp; u : units)</pre>
			<pre class="source-code">   u-&gt;attack();</pre>
			<p>In total, there are 12 combinations that we defined here. And this was all possible with only six classes. This shows how mixins help us add functionality while keeping the complexity of the code at a reduced level. If we run the code, we get the following output:</p>
			<p class="source-code">draw sword.attack! attack attack!</p>
			<p class="source-code">draw sword.attack then defend</p>
			<p class="source-code">spell magic curse.attack! attack attack!</p>
			<p class="source-code">spell magic curse.attack then defend</p>
			<p class="source-code">draw sword.fighting alone.attack! attack attack!</p>
			<p class="source-code">draw sword.fighting alone.attack then defend</p>
			<p class="source-code">draw sword.fighting with a team.attack! attack attack!</p>
			<p class="source-code">draw sword.fighting with a team.attack then defend</p>
			<p class="source-code">spell magic curse.fighting alone.attack! attack attack!</p>
			<p class="source-code">spell magic curse.fighting alone.attack then defend</p>
			<p class="source-code">spell magic curse.fighting with a team.attack! attack attack!</p>
			<p class="source-code">spell magic curse.fighting with a team.attack then defend</p>
			<p>We have looked here at <a id="_idIndexMarker699"/>two patterns, CRTP and mixins, that are both intended to add additional (common) functionality to other classes. However, although they look similar, they have opposite structures and should not be confused with one another. An alternative <a id="_idIndexMarker700"/>technique to leverage common functionalities from unrelated types is called type erasure, which we will discuss next.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor144"/>Type erasure</h1>
			<p>The term <strong class="bold">type erasure</strong> describes a pattern in which type information is removed, allowing types that are <a id="_idIndexMarker701"/>not necessarily related to be treated in a generic way. This is not something specific to the C++ language. This concept exists in other languages <a id="_idIndexMarker702"/>with better support than in C++ (such as Python and Java). There are different forms <a id="_idIndexMarker703"/>of type erasure such as polymorphism and using <strong class="source-inline">void</strong> pointers (a legacy of the C language, which is to be avoided), but true type erasure is achieved with templates. Before we discuss this, let’s briefly look at the others.</p>
			<p>The most rudimentary form of type erasure is the use of <strong class="source-inline">void</strong> pointers. This is typical of C and although <a id="_idIndexMarker704"/>possible in C++, it is in no way recommended. It is not type-safe and, therefore, error-prone. However, for the sake of the discussion, let’s have a look at such an approach.</p>
			<p>Let’s say we again have <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> types and they both have<a id="_idTextAnchor145"/> an attack function (a behavior), and we want to treat them in a common way to exhibit this behavior. Let’s see the classes first:</p>
			<pre class="source-code">struct knight</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack() { std::cout &lt;&lt; "draw sword\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct mage</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack() { std::cout &lt;&lt; "spell magic curse\n"; }</pre>
			<pre class="source-code">};</pre>
			<p>In a C-like implementation, we could have a function for each of these types, taking a <strong class="source-inline">void*</strong> to an object of the type, cast<a id="_idTextAnchor146"/>ing it to the expected type of pointer, and then invoking the <strong class="source-inline">attack</strong> member function:</p>
			<pre class="source-code">void fight_knight(void* k)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   reinterpret_cast&lt;knight*&gt;(k)-&gt;attack();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">void fight_mage(void* m)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   reinterpret_cast&lt;mage*&gt;(m)-&gt;attack();</pre>
			<pre class="source-code">}</pre>
			<p>These have a similar signature; the only thing that differs is the name. So, we can define a function <a id="_idIndexMarker705"/>pointer and then associate an object (or more precisely a pointer to an object) with a pointer to the right function handling it. Here is how:</p>
			<pre class="source-code">using fight_fn = void(*)(void*);</pre>
			<pre class="source-code">void fight(</pre>
			<pre class="source-code">   std::vector&lt;std::pair&lt;void*, fight_fn&gt;&gt; const&amp; units)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   for (auto&amp; u : units)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      u.second(u.first);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>There <a id="_idTextAnchor147"/>is no information about types in this last snippet. All that has been erased using <strong class="source-inline">void</strong> pointers. The <strong class="source-inline">fight</strong> function can be invoked as follows:</p>
			<pre class="source-code">knight k;</pre>
			<pre class="source-code">mage m;</pre>
			<pre class="source-code">std::vector&lt;std::pair&lt;void*, fight_fn&gt;&gt; units {</pre>
			<pre class="source-code">   {&amp;k, &amp;fight_knight},</pre>
			<pre class="source-code">   {&amp;m, &amp;fight_mage},</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">fight(units);</pre>
			<p>From a C++ perspective, this will probably look odd. It should. In this example, I have combined C techniques with C++ classes. Hopefully, we will not see snippets of code like this in production. Things will go wrong by a simple typing error if you pass a <strong class="source-inline">mage</strong> to the <strong class="source-inline">fight_knight</strong> function or the other way around. Nevertheless, it’s possible and is a form of type erasure.</p>
			<p>An obvious alternative solution in C++ is using polymorphism through inheritance. This is the very first <a id="_idIndexMarker706"/>solution we saw at the beginning of this chapter. For convenience, I’ll reproduce it here again:</p>
			<pre class="source-code">struct game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   virtual void attack() = 0;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct knight : game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack() override </pre>
			<pre class="source-code">   { std::cout &lt;&lt; "draw sword\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct mage : game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack() override </pre>
			<pre class="source-code">   { std::cout &lt;&lt; "spell magic curse\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">void fight(std::vector&lt;game_unit*&gt; const &amp; units)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   for (auto unit : units)</pre>
			<pre class="source-code">      unit-&gt;attack();</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">fight</strong> function can handle <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> objects homogenously. It knows nothing of the actual <a id="_idIndexMarker707"/>objects whose addresses were passed to it (within a <strong class="source-inline">vector</strong>). However, it can be argued that types have not been completely erased. Both <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> are <strong class="source-inline">game_unit</strong> and the <strong class="source-inline">fight</strong> function handles anything that is a <strong class="source-inline">game_unit</strong>. For another type to be handled by this function, it needs to derive from the <strong class="source-inline">game_unit</strong> pure abstract class. </p>
			<p>And sometimes that’s not possible. Perhaps we want to treat unrelated types in a similar matter (a process called <strong class="bold">duck typing</strong>) but we are not able to change those <a id="_idIndexMarker708"/>types. For instance, we do not own the source code. The solution to this problem is true type erasure with templates.</p>
			<p>Before we get to see what this pattern looks like, let’s take it step by step to understand how the pattern developed, starting with the unrelated <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong>, and the premise that we cannot modify them. However, we can write wrappers around t<a id="_idTextAnchor148"/>hem that would provide a uniform interface to the common functionality (behavior):</p>
			<pre class="source-code">struct knight</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack() { std::cout &lt;&lt; "draw sword\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct mage</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void attack() { std::cout &lt;&lt; "spell magic curse\n"; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   virtual void attack() = 0;</pre>
			<pre class="source-code">   virtual ~game_unit() = default;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct knight_unit : game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   knight_unit(knight&amp; u) : k(u) {}</pre>
			<pre class="source-code">   void attack() override { k.attack(); }\</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   knight&amp; k;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct mage_unit : game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   mage_unit(mage&amp; u) : m(u) {}</pre>
			<pre class="source-code">   void attack() override { m.attack(); }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   mage&amp; m;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">void fight(std::vector&lt;game_unit*&gt; const &amp; units)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   for (auto u : u<a id="_idTextAnchor149"/>nits)</pre>
			<pre class="source-code">      u-&gt;attack();</pre>
			<pre class="source-code">}</pre>
			<p>We do not need to call the <strong class="source-inline">attack</strong> member function in <strong class="source-inline">game_unit</strong> the same as it was in <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong>. It can have any name. This choice was purely made on the grounds of <a id="_idIndexMarker709"/>mimicking the original behavior name. The <strong class="source-inline">fight</strong> function takes a collection of pointers to <strong class="source-inline">game_unit</strong>, therefore being able to handle both <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> objects homogenously, as shown next:</p>
			<pre class="source-code">knight k;</pre>
			<pre class="source-code">mage m;</pre>
			<pre class="source-code">knight_unit ku{ k };</pre>
			<pre class="source-code">mage_unit mu{ m };</pre>
			<pre class="source-code">std::vector&lt;game_unit*&gt; v{ &amp;ku, &amp;mu };</pre>
			<pre class="source-code">fight(v);</pre>
			<p>The trouble with this solution is that there is a lot of duplicate code. The <strong class="source-inline">knight_unit</strong> and <strong class="source-inline">mage_unit</strong> classes are mostly the same. And when other classes need to be handled similarly, this <a id="_idTextAnchor150"/>duplication increases more. The solution to code duplication is using templates. We replace <strong class="source-inline">knight_unit</strong> and <strong class="source-inline">mage_unit</strong> with the following class template:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct game_unit_wrapper : public game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   game_unit_wrapper(T&amp; unit) : t(unit) {}</pre>
			<pre class="source-code">   void attack() override { t.attack(); }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   T&amp; t;</pre>
			<pre class="source-code">};</pre>
			<p>There is only one copy of this class in our source code but the compiler will instantiate multiple specializations based on its usage. Any type information has been erased, with the exception of some <a id="_idIndexMarker710"/>type restrictions—the <strong class="source-inline">T</strong> type must have a member function called <strong class="source-inline">attack</strong> that takes no arguments. Notice that the <strong class="source-inline">fight</strong> function didn’t change at all. The client code needs to be slightly changed though:</p>
			<pre class="source-code">knight k;</pre>
			<pre class="source-code">mage m;</pre>
			<pre class="source-code">game_unit_wrapper ku{ k };</pre>
			<pre class="source-code">game_unit_wrapper mu{ m };</pre>
			<pre class="source-code">std::vector&lt;game_unit*&gt; v{ &amp;ku, &amp;mu };</pre>
			<pre class="source-code">fight(v);</pre>
			<p>This leads us to <a id="_idIndexMarker711"/>the form of the type erasure pa<a id="_idTextAnchor151"/>ttern by putting the abstract base class and wrapper class template within another class:</p>
			<pre class="source-code">struct game</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   struct game_unit</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      virtual void attack() = 0;</pre>
			<pre class="source-code">      virtual ~game_unit() = default;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   struct game_unit_wrapper : public game_unit</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      game_unit_wrapper(T&amp; unit) : t(unit) {}</pre>
			<pre class="source-code">      void attack() override { t.attack(); }</pre>
			<pre class="source-code">   private:</pre>
			<pre class="source-code">      T&amp; t;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   void addUnit(T&amp; unit)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      units.push_back(</pre>
			<pre class="source-code">         std::make_unique&lt;game_unit_wrapper&lt;T&gt;&gt;(unit));</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   void fight()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      for (auto&amp; u : units)</pre>
			<pre class="source-code">         u-&gt;attack();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   std::vector&lt;std::unique_ptr&lt;game_unit&gt;&gt; units;</pre>
			<pre class="source-code">};</pre>
			<p>The <strong class="source-inline">game</strong> class contains a collection of <strong class="source-inline">game_unit</strong> objects and has a method for adding new wrappers to any game unit (that has an <strong class="source-inline">attack</strong> member function). It also has a member function, <strong class="source-inline">fight</strong>, to invoke the common behavior. The client code is, this time, the following:</p>
			<pre class="source-code">knight k;</pre>
			<pre class="source-code">mage m;</pre>
			<pre class="source-code">game g;</pre>
			<pre class="source-code">g.addUnit(k);</pre>
			<pre class="source-code">g.addUnit(m);</pre>
			<pre class="source-code">g.fight();</pre>
			<p>In the type erasure pattern, the abstract base class is called a <strong class="bold">concept</strong> and the wrapper that inherits <a id="_idIndexMarker712"/>from it is called a <strong class="bold">model</strong>. If we were to implement the type <a id="_idIndexMarker713"/>erasure pattern <a id="_idIndexMarker714"/>in the established formal manner it would look as follows:</p>
			<pre class="source-code">struct unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   unit(T&amp;&amp; obj) : </pre>
			<pre class="source-code">      unit_(std::make_shared&lt;unit_model&lt;T&gt;&gt;(</pre>
			<pre class="source-code">               std::forward&lt;T&gt;(obj))) </pre>
			<pre class="source-code">   {}</pre>
			<pre class="source-code">   void attack()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      unit_-&gt;attack();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   struct unit_concept</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      virtual void attack() = 0;</pre>
			<pre class="source-code">      virtual ~unit_concept() = default;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;typename T&gt;</pre>
			<pre class="source-code">   struct unit_model : public unit_concept</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      unit_model(T&amp; unit) : t(unit) {}</pre>
			<pre class="source-code">      void attack() override { t.attack(); }</pre>
			<pre class="source-code">   private:</pre>
			<pre class="source-code">      T&amp; t;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   std::shared_ptr&lt;unit_concept&gt; unit_;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">void fight(std::vector&lt;unit&gt;&amp; units)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   for (auto&amp; u : units)</pre>
			<pre class="source-code">      u.attack();</pre>
			<pre class="source-code">}</pre>
			<p>In this snippet, <strong class="source-inline">game_unit</strong> was renamed as <strong class="source-inline">unit_concept</strong> and <strong class="source-inline">game_unit_wrapper</strong> was renamed as <strong class="source-inline">unit_model</strong>. There is no other change to them apart from the name. They are members of a new class called <strong class="source-inline">unit</strong> that stores a pointer to an object that implements <strong class="source-inline">unit_concept</strong>; that could be <strong class="source-inline">unit_model&lt;knight&gt;</strong> or <strong class="source-inline">unit_model&lt;mage&gt;</strong>. The <strong class="source-inline">unit</strong> class has a template constructor that enables us to create such model objects from <strong class="source-inline">knight</strong> and <strong class="source-inline">mage</strong> objects. </p>
			<p>It also <a id="_idIndexMarker715"/>has a public member function, <strong class="source-inline">attack</strong> (again, this can have any name). On the other hand, the <strong class="source-inline">fight</strong> function handles <strong class="source-inline">unit</strong> objects and invokes their <strong class="source-inline">attack</strong> member function. The client code may look as follows:</p>
			<pre class="source-code">knight k;</pre>
			<pre class="source-code">mage m;</pre>
			<pre class="source-code">std::vector&lt;unit&gt; v{ unit(k), unit(m) };</pre>
			<pre class="source-code">fight(v);</pre>
			<p>If you’re wondering <a id="_idIndexMarker716"/>where this pattern is used in real-world code, there are <a id="_idIndexMarker717"/>two examples in the standard library itself:</p>
			<ul>
				<li><strong class="source-inline">std::function</strong>: This is a general-purpose polymorphic function wrapper that enables us to store, copy, and invoke anything that is callable, such as functions, lambda expressions, bind expressions, function objects, pointers to member functions, and pointers to data members. Here is an example of using <strong class="source-inline">std::function</strong>:<p class="source-code">class async_bool</p><p class="source-code">{</p><p class="source-code">   std::function&lt;bool()&gt; check;</p><p class="source-code">public:</p><p class="source-code">   async_bool() = delete;</p><p class="source-code">   async_bool(std::function&lt;bool()&gt; checkIt)</p><p class="source-code">      : check(checkIt)</p><p class="source-code">   { }</p><p class="source-code">   async_bool(bool val)</p><p class="source-code">      : check([val]() {return val; })</p><p class="source-code">   { }</p><p class="source-code">   operator bool() const { return check(); }</p><p class="source-code">};</p><p class="source-code">async_bool b1{ false };</p><p class="source-code">async_bool b2{ true };</p><p class="source-code">async_bool b3{ []() { std::cout &lt;&lt; "Y/N? "; </p><p class="source-code">                      char c; std::cin &gt;&gt; c; </p><p class="source-code">                      return c == 'Y' || c == 'y'; } };</p><p class="source-code">if (b1) { std::cout &lt;&lt; "b1 is true\n"; }</p><p class="source-code">if (b2) { std::cout &lt;&lt; "b2 is true\n"; }</p><p class="source-code">if (b3) { std::cout &lt;&lt; "b3 is true\n"; }</p></li>
				<li><strong class="source-inline">std::any</strong>: This is a <a id="_idIndexMarker718"/>class that represents a container to any value of a type that is copy-constructible. An example is used in the following snippet:<p class="source-code">std::any u;</p><p class="source-code">u = knight{};</p><p class="source-code">if (u.has_value())</p><p class="source-code">   std::any_cast&lt;knight&gt;(u).attack();</p><p class="source-code">u = mage{};</p><p class="source-code">if (u.has_value())</p><p class="source-code">   std::any_cast&lt;mage&gt;(u).attack();</p></li>
			</ul>
			<p>Type erasure is an idiom that com<a id="_idTextAnchor152"/>bines inheritance from object-oriented programming with templates to <a id="_idIndexMarker719"/>create wrappers that can store any type. In this section, we have seen how the pattern looks and how it works, as well as some real-world implementations of the pattern.</p>
			<p>Next in this chapter, we will discuss a technique called tag dispatching.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor153"/>Tag dispatching</h1>
			<p><strong class="bold">Tag dispatching</strong> is a technique that enables us to select one or another function overload at compile <a id="_idIndexMarker720"/>time. It is an alternative to <strong class="source-inline">std::enable_if</strong> and <strong class="bold">SFINAE</strong> and is simple to understand and use. The term <em class="italic">tag</em> describes an empty <a id="_idIndexMarker721"/>class that has no members (data), or functions <a id="_idTextAnchor154"/>(behavior). Such a class is only used to define a parameter (usually the last) of a function to decide whether to select it at compile-time, depending on the supplied arguments. To better understand this, let’s consider an example.</p>
			<p>The standard library contains a utility function called <strong class="source-inline">std::advance</strong> that looks as follows:</p>
			<pre class="source-code">template&lt;typename InputIt, <a id="_idTextAnchor155"/>typename Distance&gt;</pre>
			<pre class="source-code">void advance(InputIt&amp; it, Distance n);</pre>
			<p>Notice that in C++17, this is also <strong class="source-inline">constexpr</strong> (more about this, shortly). This function increments the given iterator by <strong class="source-inline">n</strong> elements. However, there are several categories of iterators (input, output, forward, bidirectional, and random access). That means such an operation can be computed differently:</p>
			<ul>
				<li>For input iterators, it could call <strong class="source-inline">operator++</strong> a number of <strong class="source-inline">n</strong> times.</li>
				<li>For bidirectional iterators, it could call either <strong class="source-inline">operator++</strong> a number of <strong class="source-inline">n</strong> times (if <strong class="source-inline">n</strong> is a positive number) or <strong class="source-inline">operator--</strong> a number of <strong class="source-inline">n</strong> times (if <strong class="source-inline">n</strong> is a negative number).</li>
				<li>For random-access iterators, it can use the <strong class="source-inline">operator+=</strong> to increment it directly with <strong class="source-inline">n</strong> elements.</li>
			</ul>
			<p>This implies there can be three different implementations, but it should be possible to select at compile-time which one is the best match for the category of the iterator it is called for. A solution for this is tag dispatching. And the first thing to do is define the tags. As mentioned earlier, tags are empty classes. Therefore, tags that correspond to the five iterator types can be defined as follows:</p>
			<pre class="source-code">struct input_iterator_tag {};</pre>
			<pre class="source-code">struct output_iterator_tag {};</pre>
			<pre class="source-code">struct forward_iterator_tag : input_iterator_tag {};</pre>
			<pre class="source-code">struct bidirectional_iterator_tag : </pre>
			<pre class="source-code">   forward_ite<a id="_idTextAnchor156"/>rator_tag {};</pre>
			<pre class="source-code">struct random_access_iterator_tag : </pre>
			<pre class="source-code">   bidirectional_iterator_tag {};</pre>
			<p>This is exactly how they are defined in the C++ standard library, in the <strong class="source-inline">std</strong> namespace. These tags will be <a id="_idIndexMarker722"/>used to define an additional parameter for each overload of <strong class="source-inline">std::advance</strong>, as shown next:</p>
			<pre class="source-code">namespace std</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   namespace details </pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      template &lt;typename Iter, typename Distance&gt;</pre>
			<pre class="source-code">      void advance(Iter&amp; it, Distance n, </pre>
			<pre class="source-code">                   std::random_access_iterator_tag)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         it += n;</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      template &lt;typename Iter, typename Distance&gt;</pre>
			<pre class="source-code">      void advance(Iter&amp; it, Distance n, </pre>
			<pre class="source-code">                   std::bidirectional_iterator_tag)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         if (n &gt; 0)</pre>
			<pre class="source-code">         {</pre>
			<pre class="source-code">            while (n--) ++it;</pre>
			<pre class="source-code">         }</pre>
			<pre class="source-code">         else</pre>
			<pre class="source-code">         {</pre>
			<pre class="source-code">            while (n++) --it;</pre>
			<pre class="source-code">         }</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      template &lt;typename Iter, typename Distance&gt;</pre>
			<pre class="source-code">      void advance(Iter&amp; it, Distance n, </pre>
			<pre class="source-code">                   std::input_iterator_tag)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         while (n--)</pre>
			<pre class="source-code">         {</pre>
			<pre class="source-code">            ++it;</pre>
			<pre class="source-code">         }</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>These overloads are defined in a separate (inner) namespace of the <strong class="source-inline">std</strong> namespace so that the standard namespace is not polluted with unnecessary definitions. You can see here that each of these overloads has three parameters: a reference to an iterator, a number of elements to increment (or decrement), and a tag.</p>
			<p>The last thing to do is provide a definition of an <strong class="source-inline">advance</strong> function that is intended for direct use. This function <a id="_idIndexMarker723"/>does not have a third parameter but calls one of these overloads by determining the category of the iterator it is called with. Its implementation may look as follows:</p>
			<pre class="source-code">namespace std</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename Iter, typename Distance&gt;</pre>
			<pre class="source-code">   void advance(Iter&amp; it, Distance n)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      details::advance(it, n,</pre>
			<pre class="source-code">         typename std::iterator_traits&lt;Iter&gt;::</pre>
			<pre class="source-code">                          iterator_category{});</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">std::iterator_traits</strong> class seen here defines a sort of interface for iterator types. For this purpose, it contains several member types, one of them being <strong class="source-inline">iterator_category</strong>. This resolves to one of the iterator tags defined earlier, such as <strong class="source-inline">std::input_iterator_tag</strong> for input iterators or <strong class="source-inline">std::random_access_iterator_tag</strong> for random access iterators. Therefore, based on the category of the supplied iterator, it instantiates one of these tag classes, determining the selection <a id="_idIndexMarker724"/>at compile-time of the appropriate overloaded implementation from the <strong class="source-inline">details</strong> namespace. We can invoke the <strong class="source-inline">std::advance</strong> function as follows:</p>
			<pre class="source-code">std::vector&lt;int&gt; v{ 1,2,3,4,5 };</pre>
			<pre class="source-code">auto sv = std::begin(v);</pre>
			<pre class="source-code">std::advance(sv, 2);</pre>
			<pre class="source-code">std::list&lt;int&gt; l{ 1,2,3,4,5 };</pre>
			<pre class="source-code">auto sl = std::begin(l);</pre>
			<pre class="source-code">std::advance(sl, 2);</pre>
			<p>The category type of the <strong class="source-inline">std::vector</strong>’s iterators is random ac<a id="_idTextAnchor157"/>cess. On the other hand, the iterator category type for <strong class="source-inline">std::list</strong> is bidirectional. However, we can use a single function that relies on different optimized implementations by leveraging the technique of tag dispatching.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor158"/>Alternatives to tag dispatching</h2>
			<p>Prior to C++17, the only alternative to tag dispatching was SFINAE with <strong class="source-inline">enable_if</strong>. We have <a id="_idIndexMarker725"/>discussed this topic in <a href="B18367_05_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Type Traits and Conditional Compilation</em>. This is a rather legacy technique that has better alternatives in modern C++. These alternatives are <strong class="bold">constexpr if</strong> and <strong class="bold">concepts</strong>. Let’s discuss them one at a time.</p>
			<h3>Using constexpr if</h3>
			<p>C++11 introduced the concept of <strong class="source-inline">constexpr</strong> values, which are values known at compile-time but <a id="_idIndexMarker726"/>also <strong class="source-inline">constexpr</strong> functions <a id="_idIndexMarker727"/>that are functions that could be evaluated at compile-time (if all inputs are compile-time values). In C++14, C++17, and C++20, many standard library functions or member functions of standard library classes have been changed to be <strong class="source-inline">constexpr</strong>. One of these is <strong class="source-inline">std::advance</strong>, whose implementation in C++17 is based on the constexpr if feature, also added in C++17 (which was discussed in <a href="B18367_05_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Type Traits and Conditional Compilation</em>). </p>
			<p>The following is a possible implementation in C++17:</p>
			<pre class="source-code">template&lt;typename It, typename Distance&gt;</pre>
			<pre class="source-code">constexpr void advance(It&amp; it, Distance n)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using category = </pre>
			<pre class="source-code">     typename std::iterator_traits&lt;It&gt;::iterator_category;</pre>
			<pre class="source-code">   static_assert(std::is_base_of_v&lt;std::input_iterator_tag,</pre>
			<pre class="source-code">                                   category&gt;);</pre>
			<pre class="source-code">   auto dist = </pre>
			<pre class="source-code">     typename std::iterator_traits&lt;It&gt;::difference_type(n);</pre>
			<pre class="source-code">   if constexpr (std::is_base_of_v&lt;</pre>
			<pre class="source-code">                    std::random_access_iterator_tag, </pre>
			<pre class="source-code">                    category&gt;)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      it += dist;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      while (dist &gt; 0)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         --dist;</pre>
			<pre class="source-code">         ++it;</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      if constexpr (std::is_base_of_v&lt;</pre>
			<pre class="source-code">                       std::bidirectional_iterator_tag, </pre>
			<pre class="source-code">                       category&gt;)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         while (dist &lt; 0)</pre>
			<pre class="source-code">         {</pre>
			<pre class="source-code">            ++dist;</pre>
			<pre class="source-code">            --it;</pre>
			<pre class="source-code">         }</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Although this implementation still uses the iterator tags that we saw earlier, they are no longer <a id="_idIndexMarker728"/>used to invoke different <a id="_idIndexMarker729"/>overloaded functions but to determine the value of some compile-time expressions. The <strong class="source-inline">std::is_base_of</strong> type trait (through the <strong class="source-inline">std::is_base_of_v</strong> variable template) is used to determine the type of the iterator category at compile-time. </p>
			<p>This implementation has several advantages:</p>
			<ul>
				<li>Has a single implementation of the algorithm (in the <strong class="source-inline">std</strong> namespace)</li>
				<li>Does not require multiple overloads with implementation details defined in a separate namespace</li>
			</ul>
			<p>The client code is <a id="_idIndexMarker730"/>unaffected. Therefore, library <a id="_idIndexMarker731"/>implementors were able to replace the previous version based on tag dispatching with the new version based on constexpr if, without affecting any line of code calling <strong class="source-inline">std::advance</strong>.</p>
			<p>However, in C++20 there is an even better alternative. Let’s explore it next.</p>
			<h3>Using concepts</h3>
			<p>The previous chapter was dedicated to constraints and concepts, introduced in C++20. We have seen <a id="_idIndexMarker732"/>not only how these features work but also some of the concepts that the <a id="_idIndexMarker733"/>standard library defines in several headers such as <strong class="source-inline">&lt;concepts&gt;</strong> and <strong class="source-inline">&lt;iterator&gt;</strong>. Some of these concepts specify that a type is some iterator category. For instance, <strong class="source-inline">std::input_iterator</strong> specifies that a type is an input iterator. Similarly, the following concepts are also defined: <strong class="source-inline">std::output_iterator</strong>, <strong class="source-inline">std::forward_iterator</strong>, <strong class="source-inline">std::bidirectional_iterator</strong>, <strong class="source-inline">std::random_access_iterator</strong>, and <strong class="source-inline">std::contiguous_iterator</strong> (the last one indicating that an iterator is a random-access iterator, referring to elements that are stored contiguously in memory).</p>
			<p>The <strong class="source-inline">std::input_iterator</strong> concept is defined as follows:</p>
			<pre class="source-code">template&lt;class I&gt;</pre>
			<pre class="source-code">   concept input_iterator =</pre>
			<pre class="source-code">      std::input_or_output_iterator&lt;I&gt; &amp;&amp;</pre>
			<pre class="source-code">      std::indirectly_readable&lt;I&gt; &amp;&amp;</pre>
			<pre class="source-code">      requires { typename /*ITER_CONCEPT*/&lt;I&gt;; } &amp;&amp;</pre>
			<pre class="source-code">      std::derived_from&lt;/*ITER_CONCEPT*/&lt;I&gt;, </pre>
			<pre class="source-code">                        std::input_iterator_tag&gt;;</pre>
			<p>Without getting into too many details, it is worth noting that this concept is a set of constraints that verify the following:</p>
			<ul>
				<li>The iterator is dereferenceable (supports <strong class="source-inline">*i</strong>) and is incrementable (supports <strong class="source-inline">++i</strong> and <strong class="source-inline">i++</strong>).</li>
				<li>The iterator category is derived from <strong class="source-inline">std::input_iterator_tag</strong>.</li>
			</ul>
			<p>This means that the category check is performed within the constraint. Therefore, these concepts <a id="_idIndexMarker734"/>are still based on the iterator tags, but the <a id="_idIndexMarker735"/>technique is significantly different than tag dispatching. As a result, in C++20, we could have yet another implementation for the <strong class="source-inline">std::advance</strong> algorithm, as follows:</p>
			<pre class="source-code">template &lt;std::random_access_iterator Iter, class Distance&gt;</pre>
			<pre class="source-code">void advance(Iter&amp; it, Distance n)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   it += n;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;std::bidirectional_iterator Iter, class Distance&gt;</pre>
			<pre class="source-code">void advance(Iter&amp; it, Distance n)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (n &gt; 0)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      while (n--) ++it;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      while (n++) --it;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;std::input_iterator Iter, class Distance&gt;</pre>
			<pre class="source-code">void advance(Iter&amp; it, Distance n)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   while (n--)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      ++it;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>There are a couple of things to notice here:</p>
			<ul>
				<li>There are yet again three different overloads of the advanced function. </li>
				<li>These overloads are defined in the <strong class="source-inline">std</strong> namespace and do not require a separate namespace to hide implementation details.</li>
			</ul>
			<p>Although we explicitly wrote several overloads again, this solution is arguably easier to read and <a id="_idIndexMarker736"/>understand than the one based on constexpr if because the code is <a id="_idIndexMarker737"/>nicely separated into different units (functions), making it easier to follow.</p>
			<p>Tag dispatching is an important technique for selecting between overloads at compile-time. It has its trade-offs but also better alternatives if you are using C++17 or C++20. If your compiler supports concepts, you should prefer this alternative for the reasons mentioned earlier.</p>
			<p>The next pattern we will look at in this chapter is expression templates.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor159"/>Expression templates</h1>
			<p><strong class="bold">Expression templates</strong> are a metaprogramming technique that enables lazy evaluation of a <a id="_idIndexMarker738"/>computation at compile-time. This helps to avoid inefficient operations that occur at runtime. However, this does not come for free, as expression templates require more code and can be cumbersome to read or understand. They are often used in the implementation of linear algebra libraries.</p>
			<p>Before seeing how expression templates are implemented, let’s understand what is the problem they solve. For this, let’s suppose we want to do some operations with matrices, for which we implemented the basic operations, addition, subtraction, and multiplication (either of two matrices or of a scalar and a matrix). We can have the following expressions:</p>
			<pre class="source-code">auto r1 = m1 + m2;</pre>
			<pre class="source-code">auto r2 = m1 + m2 + m3;</pre>
			<pre class="source-code">auto r3 = m1 * m2 + m3 * m4;</pre>
			<pre class="source-code">auto r4 = m1 + 5 * m2;</pre>
			<p>In this snippet, <strong class="source-inline">m1</strong>, <strong class="source-inline">m2</strong>, <strong class="source-inline">m3</strong>, and <strong class="source-inline">m4</strong> are matrices; similarly, <strong class="source-inline">r1</strong>, <strong class="source-inline">r2</strong>, <strong class="source-inline">r3</strong>, and <strong class="source-inline">r4</strong> are matrices that result from performing the operations on the right side. The first operation does not pose any problems: <strong class="source-inline">m1</strong> and <strong class="source-inline">m2</strong> are added and the result is assigned to <strong class="source-inline">r1</strong>. However, the second operation is different because there are three matrices that are added. That means <strong class="source-inline">m1</strong> and <strong class="source-inline">m2</strong> are added first and a temporary is created, which is then added to <strong class="source-inline">m3</strong> and the result assigned to <strong class="source-inline">r2</strong>. </p>
			<p>For the third operation, there are two temporaries: one for the result of multiplying <strong class="source-inline">m1</strong> and <strong class="source-inline">m2</strong> and one for the result of multiplying <strong class="source-inline">m3</strong> and <strong class="source-inline">m4</strong>; these two are then added and the result is assigned to <strong class="source-inline">r3</strong>. Finally, the last operation is similar to the second, meaning that a temporary object results from the multiplication between the scalar <strong class="source-inline">5</strong> and the matrix <strong class="source-inline">m2</strong>, and then this temporary is added to <strong class="source-inline">m1</strong> and the result assigned to <strong class="source-inline">r4</strong>.</p>
			<p>The more complex the operation, the more temporaries are generated. This can affect performance <a id="_idIndexMarker739"/>when the objects are large. Expression templates help to avoid this by modeling the computation as a compile-time expression. The entire mathematical expression (such as <strong class="source-inline">m1 + 5 * m2</strong>) becomes a single expression template computed when the assignment is evaluated and without the need for any temporary object.</p>
			<p>To demonstrate this, we will build some examples using vectors not matrices because these are simpler data structures, and the point of the exercise is not to focus on the representation of data but on the creation of expression templates. In the following listing, you can see <a id="_idIndexMarker740"/>a minimal implementation of a vector class that provides several operations:</p>
			<ul>
				<li>Constructing an instance from an initializer list or from a value representing a size (no initializing values)</li>
				<li>Retrieving the number of elements in the vector</li>
				<li>Element access with the subscript operator (<strong class="source-inline">[]</strong>)</li>
			</ul>
			<p>The code goes as follows:</p>
			<pre class="source-code">template&lt;typename T&gt;</pre>
			<pre class="source-code">struct vector</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   vector(std::size_t const n) : data_(n) {}</pre>
			<pre class="source-code">   vector(std::initializer_list&lt;T&gt;&amp;&amp; l) : data_(l) {}</pre>
			<pre class="source-code">   std::size_t size() const noexcept</pre>
			<pre class="source-code">   { </pre>
			<pre class="source-code">      return data_.size();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   T const &amp; operator[](const std::size_t i) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return data_[i];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   T&amp; operator[](const std::size_t i)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return data_[i];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   std::vector&lt;T&gt; data_;</pre>
			<pre class="source-code">};</pre>
			<p>This looks very similar to the <strong class="source-inline">std::vector</strong> standard container, and, in fact, it uses this container internally to hold the data. However, this aspect is irrelevant to the problem we want <a id="_idIndexMarker741"/>to solve. Remember we are using a vector and not a matrix because it’s easier to represent in a few lines of code. Having this class, we can d<a id="_idTextAnchor160"/>efine the necessary operations: addition and multiplication, both between two vectors and between a scalar and a vector:</p>
			<pre class="source-code">template&lt;typename T, typename U&gt;</pre>
			<pre class="source-code">auto operator+ (vector&lt;T&gt; const &amp; a, vector&lt;U&gt; const &amp; b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using result_type = decltype(std::declval&lt;T&gt;() + </pre>
			<pre class="source-code">                                std::declval&lt;U&gt;());</pre>
			<pre class="source-code">   vector&lt;result_type&gt; result(a.size());</pre>
			<pre class="source-code">   for (std::size_t i = 0; i &lt; a.size(); ++i)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      result[i] = a[i] + b[i];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return result;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;typename T, typename U&gt;</pre>
			<pre class="source-code">auto operator* (vector&lt;T&gt; const &amp; a, vector&lt;U&gt; const &amp; b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using result_type = decltype(std::declval&lt;T&gt;() + </pre>
			<pre class="source-code">                                std::declval&lt;U&gt;());</pre>
			<pre class="source-code">   vector&lt;result_type&gt; result(a.size());</pre>
			<pre class="source-code">   for (std::size_t i = 0; i &lt; a.size(); ++i)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      result[i] = a[i] * b[i];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return result;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;typename T, typename S&gt;</pre>
			<pre class="source-code">auto operator* (S const&amp; s, vector&lt;T&gt; const&amp; v)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using result_type = decltype(std::declval&lt;T&gt;() + </pre>
			<pre class="source-code">                                std::declval&lt;S&gt;());</pre>
			<pre class="source-code">   vector&lt;result_type&gt; result(v.size());</pre>
			<pre class="source-code">   for (std::size_t i = 0; i &lt; v.size(); ++i)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      result[i] = s * v[i];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return result;</pre>
			<pre class="source-code">}</pre>
			<p>These implementations are relatively straightforward and should not pose a problem to understand at this point. Both the <strong class="source-inline">+</strong> and <strong class="source-inline">*</strong> operators take two vectors of potentially different types, such as <strong class="source-inline">vector&lt;int&gt;</strong> and <strong class="source-inline">vector&lt;double&gt;</strong>, and return a vector holding elements <a id="_idIndexMarker742"/>of a result type. This is determined by the result of adding two values of the template types <strong class="source-inline">T</strong> and <strong class="source-inline">U</strong>, using <strong class="source-inline">std::declval</strong>. This has been discussed in <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>. A similar implementation is available for multiplying a scalar and a vector. Having these operators available, we can write the following code:</p>
			<pre class="source-code">vector&lt;int&gt; v1{ 1,2,3 };</pre>
			<pre class="source-code">vector&lt;int&gt; v2{ 4,5,6 };</pre>
			<pre class="source-code">double a{ 1.5 };</pre>
			<pre class="source-code">vector&lt;double&gt; v3 = v1 + a * v2;       // {7.0, 9.5, 12.0}</pre>
			<pre class="source-code">vector&lt;int&gt;    v4 = v1 * v2 + v1 + v2; // {9, 17, 27}</pre>
			<p>As previously explained, this will create one temporary object while computing <strong class="source-inline">v3</strong> and two temporaries while computing <strong class="source-inline">v4</strong>. These are exemplified in the following diagrams. The first shows the first computation, <strong class="source-inline">v3 = v1 + a * v2</strong>:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="Images/Figure_7.2_B18367.jpg" alt="Figure 7.2: A conceptual representation of the first expression&#13;&#10;" width="825" height="424"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2: A conceptual representation of the first expression</p>
			<p>The second diagram, shown next, presents a conceptual representation of the computation of the second expression, <strong class="source-inline">v4 = v1 * v2 + v1 + v2</strong>:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="Images/Figure_7.3_B18367.jpg" alt="Figure 7.3: A conceptual representation of the second expression&#13;&#10;" width="1079" height="486"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3: A conceptual representation of the second expression</p>
			<p>In order to avoid these temporaries, we can rewrite the implementation of the <strong class="source-inline">vector</strong> class using the expression templates pattern. This requires several changes:</p>
			<ul>
				<li>Defining class templates to represent an expression between two objects (such as the expression of adding or multiplying two vectors).</li>
				<li>Modifying the <strong class="source-inline">vector</strong> class and parameterize the container for its internal data, which by default would be a <strong class="source-inline">std::vector</strong> as previously but can also be an expression template.</li>
				<li>Changing the implementation of the overloaded <strong class="source-inline">+</strong> and <strong class="source-inline">*</strong> operators.</li>
			</ul>
			<p>Let’s see how <a id="_idIndexMarker743"/>this is done, starting with the vector implementation. Here is the code:</p>
			<pre class="source-code">template&lt;typename T, typename C = std::vector&lt;T&gt;&gt;</pre>
			<pre class="source-code">struct vector</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   vector() = default;</pre>
			<pre class="source-code">   vector(std::size_t const n) : data_(n) {}</pre>
			<pre class="source-code">   vector(std::initializer_list&lt;T&gt;&amp;&amp; l) : data_(l) {}</pre>
			<pre class="source-code">   vector(C const &amp; other) : data_(other) {}</pre>
			<pre class="source-code">   template&lt;typename U, typename X&gt;</pre>
			<pre class="source-code">   vector(vector&lt;U, X&gt; const&amp; other) : data_(other.size()) </pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      for (std::size_t i = 0; i &lt; other.size(); ++i)</pre>
			<pre class="source-code">         data_[i] = static_cast&lt;T&gt;(other[i]);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;typename U, typename X&gt;</pre>
			<pre class="source-code">   vector&amp; operator=(vector&lt;U, X&gt; const &amp; other)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      data_.resize(other.size());</pre>
			<pre class="source-code">      for (std::size_t i = 0; i &lt; other.size(); ++i)</pre>
			<pre class="source-code">         data_[i] = static_cast&lt;T&gt;(other[i]);</pre>
			<pre class="source-code">      return *this;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   std::size_t size() const noexcept</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return data_.size();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   T operator[](const std::size_t i) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return data_[i];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   T&amp; operator[](const std::size_t i)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return data_[i];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   C&amp; data() noexcept { return data_; }</pre>
			<pre class="source-code">   C const &amp; data() const noexcept { return data_; }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   C data_;</pre>
			<pre class="source-code">};</pre>
			<p>In addition <a id="_idIndexMarker744"/>to the operations available in the initial implementation, this time we have also defined the following:</p>
			<ul>
				<li>A default constructor</li>
				<li>A conversion constructor from a container</li>
				<li>A copy constructor from a <strong class="source-inline">vector</strong> containing elements of a potentially different type</li>
				<li>A copy-assignment operator from a <strong class="source-inline">vector</strong> containing elements of a potentially different type</li>
				<li>Member function <strong class="source-inline">data</strong> that provides access to the underlaying container holding the data</li>
			</ul>
			<p>An expression template is a simple class template that stores two operands and provides a way <a id="_idIndexMarker745"/>to perform the evaluation of the operation. In our case, we need to implement expressions for adding two vectors, multiplying two vectors, and multiplying a scalar and a vector. Let’s look at the implementation of the expression template for adding two vectors:</p>
			<pre class="source-code">template&lt;typename L, typename R&gt;</pre>
			<pre class="source-code">struct vector_add </pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   vector_add(L const &amp; a, R const &amp; b) : lhv(a), rhv(b) {}</pre>
			<pre class="source-code">   auto operator[](std::size_t const i) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return lhv[i] + rhv[i];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   std::size_t size() const noexcept</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return lhv.size();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   L const &amp; lhv;</pre>
			<pre class="source-code">   R const &amp; rhv;</pre>
			<pre class="source-code">};</pre>
			<p>This class stores constant references to two vectors (or, in fact, any type that overloads the subscript operator and provides a <strong class="source-inline">size</strong> member function). The evaluation of the expression occurs in the overloaded subscript operator but not for the entire vector; only the elements at the indicated index are added. </p>
			<p>Notice that this implementation does not handle <a id="_idIndexMarker746"/>vectors of different sizes (which you can take as an exercise to change). However, it should be easy to understand the lazy nature of this approach since the addition operation only occurs when invoking the subscript operator.</p>
			<p>The multiplication expression templates for the two operations we need are implemented in a similar fashion. The code is shown in the next listing:</p>
			<pre class="source-code">template&lt;typename L, typename R&gt;</pre>
			<pre class="source-code">struct vector_mul</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   vector_mul(L const&amp; a, R const&amp; b) : lhv(a), rhv(b) {}</pre>
			<pre class="source-code">   auto operator[](std::size_t const i) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return lhv[i] * rhv[i];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   std::size_t size() const noexcept</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return lhv.size();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   L const &amp; lhv;</pre>
			<pre class="source-code">   R const &amp; rhv;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;typename S, typename R&gt;</pre>
			<pre class="source-code">struct vector_scalar_mul</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   vector_scalar_mul(S const&amp; s, R const&amp; b) : </pre>
			<pre class="source-code">      scalar(s), rhv(b) </pre>
			<pre class="source-code">   {}</pre>
			<pre class="source-code">   auto operator[](std::size_t const i) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return scalar * rhv[i];</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   std::size_t size() const noexcept</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return rhv.size();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   S const &amp; scalar;</pre>
			<pre class="source-code">   R const &amp; rhv;</pre>
			<pre class="source-code">};</pre>
			<p>The last <a id="_idIndexMarker747"/>part of the change is to modify the definition of the overloaded <strong class="source-inline">+</strong> and <strong class="source-inline">*</strong> operators, which is as follows:</p>
			<pre class="source-code">template&lt;typename T, typename L, typename U, typename R&gt;</pre>
			<pre class="source-code">auto operator+(vector&lt;T, L&gt; const &amp; a, </pre>
			<pre class="source-code">               vector&lt;U, R&gt; const &amp; b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using result_type = decltype(std::declval&lt;T&gt;() +</pre>
			<pre class="source-code">                                std::declval&lt;U&gt;());</pre>
			<pre class="source-code">   return vector&lt;result_type, vector_add&lt;L, R&gt;&gt;(</pre>
			<pre class="source-code">      vector_add&lt;L, R&gt;(a.data(), b.data()));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;typename T, typename L, typename U, typename R&gt;</pre>
			<pre class="source-code">auto operator*(vector&lt;T, L&gt; const &amp; a, </pre>
			<pre class="source-code">               vector&lt;U, R&gt; const &amp; b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using result_type = decltype(std::declval&lt;T&gt;() + </pre>
			<pre class="source-code">                                std::declval&lt;U&gt;());</pre>
			<pre class="source-code">   return vector&lt;result_type, vector_mul&lt;L, R&gt;&gt;(</pre>
			<pre class="source-code">      vector_mul&lt;L, R&gt;(a.data(), b.data()));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;typename T, typename S, typename E&gt;</pre>
			<pre class="source-code">auto operator*(S const&amp; a, vector&lt;T, E&gt; const&amp; v)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using result_type = decltype(std::declval&lt;T&gt;() + </pre>
			<pre class="source-code">                                std::declval&lt;S&gt;());</pre>
			<pre class="source-code">   return vector&lt;result_type, vector_scalar_mul&lt;S, E&gt;&gt;(</pre>
			<pre class="source-code">      vector_scalar_mul&lt;S, E&gt;(a, v.data()));</pre>
			<pre class="source-code">}</pre>
			<p>Although the code is more complex when implementing this pattern, the client code does not need to change. The snippet showed earlier works without any modifications but in a lazy manner. The evaluation of each element in the result is triggered by the invocation <a id="_idIndexMarker748"/>of the subscript operator that occurs in the copy-constructor and copy-assignment operator of the vector class.</p>
			<p>If this pattern looks cumbersome to you, there is the alternative of something better: the ranges library.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor161"/>Using ranges as an alternative to expression templates</h2>
			<p>One of the major <a id="_idIndexMarker749"/>features of C++20 is the ranges library. A <em class="italic">range</em> is a generalization <a id="_idIndexMarker750"/>of a container - a class <a id="_idIndexMarker751"/>that allows you to iterate over its data (elements). A key element of the range library is the views. These are non-owning wrappers of other ranges that transform the underlying range through some operation.</p>
			<p>Moreover, they are lazy-evaluated and the time to construct, copy, or destroy them does not depend on the size of the underlying range. The lazy evaluation (the fact that transformations are applied to elements at the moment they are requested, not when the view is created) is a key feature of the library. However, that is exactly what the expression templates are also providing. As a result, many uses of the expression templates can be replaced with ranges. Ranges will be discussed in detail in the next chapter.</p>
			<p>The C++ ranges <a id="_idIndexMarker752"/>library is based on the <strong class="bold">range-v3</strong> library created by Eric Niebler. This library is available at <a href="https://github.com/ericniebler/range-v3/">htt<span id="_idTextAnchor162"/>ps://github.com/ericniebler/range-v3/</a>. Using range-v3, we can write the following code to perform the operation <strong class="source-inline">v1 + a * v2</strong>:</p>
			<pre class="source-code">namespace rv = ranges::views;</pre>
			<pre class="source-code">std::vector&lt;int&gt; v1{ 1, 2, 3 };</pre>
			<pre class="source-code">std::vector&lt;int&gt; v2{ 4, 5, 6 };</pre>
			<pre class="source-code">double a { 1.5 };</pre>
			<pre class="source-code">auto sv2 = v2 | </pre>
			<pre class="source-code">           rv::transform([&amp;a](int val) {return a * val; });</pre>
			<pre class="source-code">auto v3 = rv::zip_with(std::plus&lt;&gt;{}, v1, sv2);</pre>
			<p>There is no need for a custom implementation of a vector class; it just works with the <strong class="source-inline">std::vector</strong> container. There is no need to overload any operator also. The code should be easy to follow, at least if you have some familiarity with the ranges library. First, we create a view that transforms the elements of the <strong class="source-inline">v2</strong> vector by multiplying each element with a scalar. Then, a second view is created that applies the plus operator on the elements of the <strong class="source-inline">v1</strong> range and the view resulting from the previous operation.</p>
			<p>Unfortunately, this <a id="_idIndexMarker753"/>code cannot <a id="_idIndexMarker754"/>be written in C++20 using the standard library, because the <strong class="source-inline">zip_with</strong> view has not been included in C++20. However, this view will be available in C++23 under the name <strong class="source-inline">zip_view</strong>. Therefore, in C++23, we will be able to write this code as follows:</p>
			<pre class="source-code">namespace rv = std::ranges::views;</pre>
			<pre class="source-code">std::vector&lt;int&gt; v1{ 1, 2, 3 };</pre>
			<pre class="source-code">std::vector&lt;int&gt; v2{ 4, 5, 6 };</pre>
			<pre class="source-code">double a { 1.5 };</pre>
			<pre class="source-code">auto sv2 = v2 | </pre>
			<pre class="source-code">           rv::transform([&amp;a](int val) {return a * val; });</pre>
			<pre class="source-code">auto v3 = rv::zip_wiew(std::plus&lt;&gt;{}, v1, sv2);</pre>
			<p>To conclude the discussion of the expression templates pattern, you should keep in mind the following takeaways: the pattern is designed to provide lazy evaluation for costly operations, and it does so at the expense of having to write more code (that is also arguably more cumbersome) and <a id="_idIndexMarker755"/>increased compile-times (since heavy template code will have an impact on that). However, as <a id="_idIndexMarker756"/>of C++20, a good alternative to this pattern <a id="_idTextAnchor163"/>is represented by the ranges library. We will learn about this new library in <a href="B18367_09_ePub.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">The Ranges Library</em>.</p>
			<p>For the next and last section of this chapter, we will look at type lists.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor164"/>Typelists</h1>
			<p>A <strong class="bold">type list</strong> (also spelled <em class="italic">typelist</em>) is a compile-time construct that enables us to manage a sequence of types. A typelist is <a id="_idIndexMarker757"/>somehow similar to a tuple but does not store any data. A typelist only carries type information and is used exclusively at compile-time for implementing different metaprogramming algorithms, type switches, or design patterns such as <em class="italic">Abstract Factory</em> or <em class="italic">Visitor</em>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Although both the <em class="italic">type list</em> and <em class="italic">typelist</em> spellings are in use, most of the time you will find the term <em class="italic">typelist</em> in C++ books and articles. Therefore, this will be the form we will use in this book.</p>
			<p>Typelists were popularized by Andrei Alexandrescu in his book, <em class="italic">Modern C++ Design</em>, published a decade before the release of C++11 (and variadic templates). Alexandrescu defined a typelist as follows:</p>
			<pre class="source-code">template &lt;class T, class U&gt;</pre>
			<pre class="source-code">struct Typelist</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  typedef T Head;</pre>
			<pre class="source-code">  typedef U Tail;</pre>
			<pre class="source-code">};</pre>
			<p>In his implementation, a typelist is composed of a head—which is a type, and a tail—which is another typelist. In order to perform various operations on the typelist (which will be discussed shortly) we also need a type to represent the end of the typelist. This can be a simple, empty type that Alexandrescu defined as follows:</p>
			<pre class="source-code">class null_typelist {};</pre>
			<p>Having these two constructs, we can define typelists in the following way:</p>
			<pre class="source-code">typedef Typelist&lt;int, </pre>
			<pre class="source-code">                 Typelist&lt;double, null_typelist&gt;&gt; MyList;</pre>
			<p>Variadic templates make the implementation of typelists simpler, as shown in the next snippet:</p>
			<pre class="source-code">template &lt;typename ... Ts&gt;</pre>
			<pre class="source-code">struct typelist {};</pre>
			<pre class="source-code">using MyList = typelist&lt;int, double&gt;;</pre>
			<p>The implementation of operations of typelists (such as accessing a type at a given index, adding or removing types from the list, and so on) differs significantly depending on the selected approach. In this book, we will only consider the variadic template version. The advantage of this approach is simp<a id="_idTextAnchor165"/>licity at different levels: the definition of the typelist is shorter, there is no need for a type to represent the end of the list, and defining typelist aliases is also shorter and easier to read.</p>
			<p>Today, perhaps many of the problems for which typelists represented the solution can be also solved using variadic templates. However, there are still scenarios where typelists are required. Here <a id="_idIndexMarker758"/>is an example: let’s consider a variadic metafunction (a type trait that performs a transformation of types) that does some transformation (such as adding the <strong class="source-inline">const</strong> qualifier) to the type template arguments. This metafunction defines a member type that represents the input types and one that represents the transformed types. If you try to define it as follows, it will not work:</p>
			<pre class="source-code">template &lt;typename ... Ts&gt;</pre>
			<pre class="source-code">struct transformer</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using input_types  = Ts...;</pre>
			<pre class="source-code">   using output_types = std::add_const_t&lt;Ts&gt;...;</pre>
			<pre class="source-code">};</pre>
			<p>This code produces compiler errors, because the expansion of the parameter pack is not possible in this context. This is a topic we discussed in <a href="B18367_03_ePub.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, <em class="italic">Variadic Templates</em>. The solution to this is to use a typelist, as follows:</p>
			<pre class="source-code">template &lt;typename ... Ts&gt;</pre>
			<pre class="source-code">struct transformer</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using input_types  = typelist&lt;Ts...&gt;;</pre>
			<pre class="source-code">   using output_types = typelist&lt;std::add_const_t&lt;Ts&gt;...&gt;;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;</pre>
			<pre class="source-code">      transformer&lt;int, double&gt;::output_types, </pre>
			<pre class="source-code">      typelist&lt;int const, double const&gt;&gt;);</pre>
			<p>The change is minimal but produces the expected result. Although this is a good example of where <a id="_idIndexMarker759"/>typelists are needed, it’s not a typical example of where typelists are used. We will look at such an example next.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor166"/>Using typelists</h2>
			<p>It’s worth exploring a <a id="_idIndexMarker760"/>more complex example before we look at how to implement operations on typelists. This should give you an understanding of the possible usage of typelists, although you can always search for more online.</p>
			<p>Let’s return to the example of the game units. For simplicity, we’ll only consider the following class:</p>
			<pre class="source-code">struct game_unit</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int attack;</pre>
			<pre class="source-code">   int defense;</pre>
			<pre class="source-code">};</pre>
			<p>A game unit has two data members representing indices (or levels) for attacking and defending. We want to <a id="_idIndexMarker761"/>operate changes on these members with the help of some functors. Two such functions are shown in the following listing:</p>
			<pre class="source-code">struct upgrade_defense</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void operator()(game_unit&amp; u)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      u.defense = static_cast&lt;int&gt;(u.defense * 1.2);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct upgrade_attack</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void operator()(game_unit&amp; u)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      u.attack += 2;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>The first increases the <a id="_idIndexMarker762"/>defense index by 20%, while the second increases the attack index by two units. Although this is a small example meant to demonstrate the use case, you can imagine a larger variety of functors like this that coul<a id="_idTextAnchor167"/>d be applied in some well-defined combinations. In our example, however, we want to apply these two functors on a <strong class="source-inline">game_unit</strong> object. We’d like to have a function as follows:</p>
			<pre class="source-code">void upgrade_unit(game_unit&amp; unit)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using upgrade_types = </pre>
			<pre class="source-code">      typelist&lt;upgrade_defense, upgrade_attack&gt;;</pre>
			<pre class="source-code">   apply_functors&lt;upgrade_types&gt;{}(unit);</pre>
			<pre class="source-code">}</pre>
			<p>This <strong class="source-inline">upgrade_unit</strong> function takes a <strong class="source-inline">game_unit</strong> object and applies the <strong class="source-inline">upgrade_defense</strong> and <strong class="source-inline">upgrade_attack</strong> functors to it. For this, it uses another helper <a id="_idIndexMarker763"/>functor called <strong class="source-inline">apply_functors</strong>. This is a class template that has a single template argument. This template argument is a typelist. A possible implementation for the <strong class="source-inline">apply_functors</strong> functor is shown next:</p>
			<pre class="source-code">template &lt;typename TL&gt;</pre>
			<pre class="source-code">struct apply_functors</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   template &lt;size_t I&gt;</pre>
			<pre class="source-code">   static void apply(game_unit&amp; unit)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using F = at_t&lt;I, TL&gt;;</pre>
			<pre class="source-code">      std::invoke(F{}, unit);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template &lt;size_t... I&gt;</pre>
			<pre class="source-code">   static void apply_all(game_unit&amp; unit, </pre>
			<pre class="source-code">                         std::index_sequence&lt;I...&gt;)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      (apply&lt;I&gt;(unit), ...);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   void operator()(game_unit&amp; unit) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      apply_all(unit, </pre>
			<pre class="source-code">                std::make_index_sequence&lt;length_v&lt;TL&gt;&gt;{});</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>This class template has an <a id="_idIndexMarker764"/>overloaded call operator and two private helper functions:</p>
			<ul>
				<li><strong class="source-inline">apply</strong>, which applies the functor from the <strong class="source-inline">I</strong> index of the typelist to a <strong class="source-inline">game_unit</strong> object.</li>
				<li><strong class="source-inline">apply_all</strong>, which applies all the functors in the typelist to a <strong class="source-inline">game_unit</strong> object by using the <strong class="source-inline">apply</strong> function in a pack expansion.</li>
			</ul>
			<p>We can use the <strong class="source-inline">upgrade_unit</strong> function as follows:</p>
			<pre class="source-code">game_unit u{ 100, 50 };</pre>
			<pre class="source-code">std::cout &lt;&lt; std::format("{},{}\n", u.attack, u.defense);</pre>
			<pre class="source-code">// prints 100,50</pre>
			<pre class="source-code">upgrade_unit(u);</pre>
			<pre class="source-code">std::cout &lt;&lt; std::format("{},{}\n", u.attack, u.defense);</pre>
			<pre class="source-code">// prints 102,60</pre>
			<p>If you paid attention to the implementation of the <strong class="source-inline">apply_functors</strong> class template, you will have noticed the <a id="_idIndexMarker765"/>use of the <strong class="source-inline">at_t</strong> alias template and the <strong class="source-inline">length_v</strong> variable template, which we have not defined yet. We will look at these two and more in the next section.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor168"/>Implementing operations on typelists</h2>
			<p>A typelist is a type that only carries valuable information at compile-time. A typelist acts as a container <a id="_idIndexMarker766"/>for other types. When you work with <a id="_idIndexMarker767"/>typelists, you need to perform various operations, such as counting the types in the list, accessing a type at a given index, adding a type at the beginning or the end of the list, or the reverse operation, removing a type from the beginning or the end of the list, and so on. If you think about it, these are typical operations you’d use with a container such as a vector. Therefore, in this section, we’ll discuss how to implement the following operations:</p>
			<ul>
				<li><strong class="source-inline">size</strong>: Determines the size of the list</li>
				<li><strong class="source-inline">front</strong>: Retrieves the first type in the list</li>
				<li><strong class="source-inline">back</strong>: Retrieves the last type in the list</li>
				<li><strong class="source-inline">at</strong>: Retrieves the type at the specified index in the list</li>
				<li><strong class="source-inline">push_back</strong>: Adds a new type to the end of the list</li>
				<li><strong class="source-inline">push_front</strong>: Adds a new type to the beginning of the list</li>
				<li><strong class="source-inline">pop_back</strong>: Removes the type at the end of the list</li>
				<li><strong class="source-inline">pop_front</strong>: Removes the type at the beginning of the list</li>
			</ul>
			<p>A typelist is a compile-time construct. It is an immutable entity. Therefore, the operations that add or remove a type do not modify a typelist but c<a id="_idTextAnchor169"/>reate a new one. We’ll see that shortly. But first, let’s start with the simplest operation, which is retrieving the size of a typelist.</p>
			<p>To avoid naming confusion with the <strong class="source-inline">size_t</strong> type, we’ll call this operation <strong class="source-inline">lenght_t</strong>, and not <strong class="source-inline">size_t</strong>. We can define this as follows:</p>
			<pre class="source-code">namespace detail</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename TL&gt;</pre>
			<pre class="source-code">   struct length;</pre>
			<pre class="source-code">   template &lt;template &lt;typename...&gt; typename TL, </pre>
			<pre class="source-code">             typename... Ts&gt;</pre>
			<pre class="source-code">   struct length&lt;TL&lt;Ts...&gt;&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = </pre>
			<pre class="source-code">        std::integral_constant&lt;std::size_t, sizeof...(Ts)&gt;;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename TL&gt;</pre>
			<pre class="source-code">using length_t = typename detail::length&lt;TL&gt;::type;</pre>
			<pre class="source-code">template &lt;typename TL&gt;</pre>
			<pre class="source-code">constexpr std::size_t length_v = length_t&lt;TL&gt;::value;</pre>
			<p>In the <strong class="source-inline">detail</strong> namespace, we have a class template called <strong class="source-inline">length</strong>. There is a primary template (without a definition) and a specialization for a typelist. This specialization defines a member type called <strong class="source-inline">type</strong> that is a <strong class="source-inline">std::integral_constant</strong>, with a value of the type <strong class="source-inline">std::size_t</strong> representing the number of arguments in the parameter <a id="_idIndexMarker768"/>pack <strong class="source-inline">Ts</strong>. Furthermore, we have an alias <a id="_idIndexMarker769"/>template, <strong class="source-inline">length_h</strong>, that is an alias for the member called <strong class="source-inline">type</strong> of the <strong class="source-inline">length</strong> class template. Finally, we have a variable template called <strong class="source-inline">length_v</strong> that is initialized from the value of the <strong class="source-inline">std::integral_constant</strong> member, which is also called <strong class="source-inline">value</strong>.</p>
			<p>We can verify the correctness of this implementation with the help of some <strong class="source-inline">static_assert</strong> statements, as follows:</p>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   length_t&lt;typelist&lt;int, double, char&gt;&gt;::value == 3);</pre>
			<pre class="source-code">static_assert(length_v&lt;typelist&lt;int, double, char&gt;&gt; == 3);</pre>
			<pre class="source-code">static_assert(length_v&lt;typelist&lt;int, double&gt;&gt; == 2);</pre>
			<pre class="source-code">static_assert(length_v&lt;typelist&lt;int&gt;&gt; == 1);</pre>
			<p>The approach <a id="_idIndexMarker770"/>used here will be used for defining all the <a id="_idIndexMarker771"/>other operations. Let’s look next at accessing the front type in the list. This is shown in the next listing:</p>
			<pre class="source-code">struct empty_type {};</pre>
			<pre class="source-code">namespace detail</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename TL&gt;</pre>
			<pre class="source-code">   struct front_type;</pre>
			<pre class="source-code">   template &lt;template &lt;typename...&gt; typename TL, </pre>
			<pre class="source-code">             typename T, typename... Ts&gt;</pre>
			<pre class="source-code">   struct front_type&lt;TL&lt;T, Ts...&gt;&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = T;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;template &lt;typename...&gt; typename TL&gt;</pre>
			<pre class="source-code">   struct front_type&lt;TL&lt;&gt;&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = empty_type;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename TL&gt;</pre>
			<pre class="source-code">using front_t = typename detail::front_type&lt;TL&gt;::type;</pre>
			<p>In the <strong class="source-inline">detail</strong> namespace, we have a class template called <strong class="source-inline">front_type</strong>. Again, we declared a <a id="_idIndexMarker772"/>primary template but without a definition. However, we <a id="_idIndexMarker773"/>have two specializations: one for a typelist that contains at least one type and one for an empty typelist. In the former case, the <strong class="source-inline">type</strong> member is aliasing the first type in the typelist. In the latter case, there is no type so the <strong class="source-inline">type</strong> member is aliasing a type called <strong class="source-inline">empty_type</strong>. This is an empty class whose only role is to act as the return type for operations where no type is to be returned. We can verify the implementation as follows:</p>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;front_t&lt;typelist&lt;&gt;&gt;, empty_type&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;front_t&lt;typelist&lt;int&gt;&gt;, int&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;front_t&lt;typelist&lt;int, double, char&gt;&gt;, </pre>
			<pre class="source-code">                  int&gt;);</pre>
			<p>If you expect the implementation of the operation for accessing the back type to be similar, you will not be disappointed. Here is how it looks:</p>
			<pre class="source-code">namespace detail</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename TL&gt;</pre>
			<pre class="source-code">   struct back_type;</pre>
			<pre class="source-code">   template &lt;template &lt;typename...&gt; typename TL, </pre>
			<pre class="source-code">             typename T, typename... Ts&gt;</pre>
			<pre class="source-code">   struct back_type&lt;TL&lt;T, Ts...&gt;&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = back_type&lt;TL&lt;Ts...&gt;&gt;::type;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;template &lt;typename...&gt; typename TL, </pre>
			<pre class="source-code">             typename T&gt;</pre>
			<pre class="source-code">   struct back_type&lt;TL&lt;T&gt;&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = T;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;template &lt;typename...&gt; typename TL&gt;</pre>
			<pre class="source-code">   struct back_type&lt;TL&lt;&gt;&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = empty_type;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename TL&gt;</pre>
			<pre class="source-code">using back_t = typename detail::back_type&lt;TL&gt;::type;</pre>
			<p>The only significant difference with this implementation is that there are three specializations of the <strong class="source-inline">back_type</strong> class template and there is recursion involved. The three <a id="_idIndexMarker774"/>specializations are for an empty typelist, a typelist <a id="_idIndexMarker775"/>with a single type, and a typelist with two or more types. The last one (which is actually the first in the previous listing) is using template recursion in the definition of its <strong class="source-inline">type</strong> member. We have seen how this works in <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>. To ensure we implemented the operation the right way we can do some validation as follows:</p>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;back_t&lt;typelist&lt;&gt;&gt;, empty_type&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;back_t&lt;typelist&lt;int&gt;&gt;, int&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;back_t&lt;typelist&lt;int, double, char&gt;&gt;,</pre>
			<pre class="source-code">                  char&gt;);</pre>
			<p>Apart from accessing the first and last type in a typelist, we are also interested in accessing a type at any given index. However, the implementation of this operation is less trivial. Let’s see it first:</p>
			<pre class="source-code">namespace detail</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;std::size_t I, std::size_t N, typename TL&gt;</pre>
			<pre class="source-code">   struct at_type;</pre>
			<pre class="source-code">   template &lt;std::size_t I, std::size_t N,</pre>
			<pre class="source-code">             template &lt;typename...&gt; typename TL, </pre>
			<pre class="source-code">             typename T, typename... Ts&gt;</pre>
			<pre class="source-code">   struct at_type&lt;I, N, TL&lt;T, Ts...&gt;&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = </pre>
			<pre class="source-code">         std::conditional_t&lt;</pre>
			<pre class="source-code">            I == N, </pre>
			<pre class="source-code">            T, </pre>
			<pre class="source-code">            typename at_type&lt;I, N + 1, TL&lt;Ts...&gt;&gt;::type&gt;;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;std::size_t I, std::size_t N&gt;</pre>
			<pre class="source-code">   struct at_type&lt;I, N, typelist&lt;&gt;&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = empty_type;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;std::size_t I, typename TL&gt;</pre>
			<pre class="source-code">using at_t = typename detail::at_type&lt;I, 0, TL&gt;::type;</pre>
			<p>The <strong class="source-inline">at_t</strong> alias template has two template arguments: an index and a typelist. The <strong class="source-inline">at_t</strong> template is an alias for the member type of the <strong class="source-inline">at_type</strong> class template from the <strong class="source-inline">detail</strong> namespace. The primary template has three template parameters: an index representing the position of the type to retrieve (<strong class="source-inline">I</strong>), another index representing the current position in the iteration of the types in the list (<strong class="source-inline">N</strong>), and a typelist (<strong class="source-inline">TL</strong>).</p>
			<p>There are two specializations of this primary template: one for a typelist that contains at least one type and <a id="_idIndexMarker776"/>one for an empty typelist. In the latter <a id="_idIndexMarker777"/>case, the member <strong class="source-inline">type</strong> is aliasing the <strong class="source-inline">empty_type</strong> type. In the former case, the member <strong class="source-inline">type</strong> is defined with the help of the <strong class="source-inline">std::conditional_t</strong> metafunction. This defines its member <strong class="source-inline">type</strong> as the first type (<strong class="source-inline">T</strong>) when <strong class="source-inline">I == N</strong>, or as the second type (<strong class="source-inline">typename at_type&lt;I, N + 1, TL&lt;Ts...&gt;&gt;::type</strong>) when this condition is false. Here, again, we employ template recursion, incrementing the value of the second index with each iteration. The following <strong class="source-inline">static_assert</strong> statements validate the implementation:</p>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;at_t&lt;0, typelist&lt;&gt;&gt;, empty_type&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;at_t&lt;0, typelist&lt;int&gt;&gt;, int&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;at_t&lt;0, typelist&lt;int, char&gt;&gt;, int&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;at_t&lt;1, typelist&lt;&gt;&gt;, empty_type&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;at_t&lt;1, typelist&lt;int&gt;&gt;, empty_type&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;at_t&lt;1, typelist&lt;int, char&gt;&gt;, char&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;at_t&lt;2, typelist&lt;&gt;&gt;, empty_type&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;at_t&lt;2, typelist&lt;int&gt;&gt;, empty_type&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;at_t&lt;2, typelist&lt;int, char&gt;&gt;, </pre>
			<pre class="source-code">                  empty_type&gt;);</pre>
			<p>The next category <a id="_idIndexMarker778"/>of operations to implement is <a id="_idIndexMarker779"/>adding a type to the beginning and the end of a typelist. We call these <strong class="source-inline">push_back_t</strong> and <strong class="source-inline">push_front_t</strong> and <a id="_idIndexMarker780"/>their <a id="_idIndexMarker781"/>definitions are as follows:</p>
			<pre class="source-code">namespace detail</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename TL, typename T&gt;</pre>
			<pre class="source-code">   struct push_back_type;</pre>
			<pre class="source-code">   template &lt;template &lt;typename...&gt; typename TL, </pre>
			<pre class="source-code">             typename T, typename... Ts&gt;</pre>
			<pre class="source-code">   struct push_back_type&lt;TL&lt;Ts...&gt;, T&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = TL&lt;Ts..., T&gt;;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;typename TL, typename T&gt;</pre>
			<pre class="source-code">   struct push_front_type;</pre>
			<pre class="source-code">   template &lt;template &lt;typename...&gt; typename TL, </pre>
			<pre class="source-code">             typename T, typename... Ts&gt;</pre>
			<pre class="source-code">   struct push_front_type&lt;TL&lt;Ts...&gt;, T&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = TL&lt;T, Ts...&gt;;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename TL, typename T&gt;</pre>
			<pre class="source-code">using push_back_t = </pre>
			<pre class="source-code">   typename detail::push_back_type&lt;TL, T&gt;::type;</pre>
			<pre class="source-code">template &lt;typename TL, typename T&gt;</pre>
			<pre class="source-code">using push_front_t = </pre>
			<pre class="source-code">   typename detail::push_front_type&lt;TL, T&gt;::type;</pre>
			<p>Based on what we have seen so far with the previous operations, these should be straightforward <a id="_idIndexMarker782"/>to understand. The opposite <a id="_idIndexMarker783"/>operations, when we remove the first or last type from a typelist, are more complex though. The first one, <strong class="source-inline">pop_front_t</strong>, looks as follows:</p>
			<pre class="source-code">namespace detail</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename TL&gt;</pre>
			<pre class="source-code">   struct pop_front_type;</pre>
			<pre class="source-code">   template &lt;template &lt;typename...&gt; typename TL, </pre>
			<pre class="source-code">             typename T, typename... Ts&gt;</pre>
			<pre class="source-code">   struct pop_front_type&lt;TL&lt;T, Ts...&gt;&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = TL&lt;Ts...&gt;;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;template &lt;typename...&gt; typename TL&gt;</pre>
			<pre class="source-code">   struct pop_front_type&lt;TL&lt;&gt;&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = TL&lt;&gt;;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename TL&gt;</pre>
			<pre class="source-code">using pop_front_t = </pre>
			<pre class="source-code">   typename detail::pop_front_type&lt;TL&gt;::type;</pre>
			<p>We have the primary template, <strong class="source-inline">pop_front_type</strong>, and two specializations: the first for a typelist <a id="_idIndexMarker784"/>with at least one type, and the second for <a id="_idIndexMarker785"/>an empty typelist. The latter defines the member <strong class="source-inline">type</strong> as an empty list; the former defines the member <strong class="source-inline">type</strong> as a typelist with the tail composed from the typelist argument.</p>
			<p>The last operation, removing the last type in a typelist, called <strong class="source-inline">pop_back_t</strong>, is implemented as follows:</p>
			<pre class="source-code">namespace detail</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;std::ptrdiff_t N, typename R, typename TL&gt;</pre>
			<pre class="source-code">   struct pop_back_type;</pre>
			<pre class="source-code">   template &lt;std::ptrdiff_t N, typename... Ts, </pre>
			<pre class="source-code">             typename U, typename... Us&gt;</pre>
			<pre class="source-code">   struct pop_back_type&lt;N, typelist&lt;Ts...&gt;, </pre>
			<pre class="source-code">                           typelist&lt;U, Us...&gt;&gt; </pre>
			<pre class="source-code">   { </pre>
			<pre class="source-code">      using type = </pre>
			<pre class="source-code">         typename pop_back_type&lt;N - 1, </pre>
			<pre class="source-code">                                typelist&lt;Ts..., U&gt;,</pre>
			<pre class="source-code">                                typelist&lt;Us...&gt;&gt;::type;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;typename... Ts, typename... Us&gt;</pre>
			<pre class="source-code">   struct pop_back_type&lt;0, typelist&lt;Ts...&gt;, </pre>
			<pre class="source-code">                           typelist&lt;Us...&gt;&gt;</pre>
			<pre class="source-code">   { </pre>
			<pre class="source-code">      using type = typelist&lt;Ts...&gt;;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;typename... Ts, typename U, typename... Us&gt;</pre>
			<pre class="source-code">   struct pop_back_type&lt;0, typelist&lt;Ts...&gt;, </pre>
			<pre class="source-code">                           typelist&lt;U, Us...&gt;&gt;</pre>
			<pre class="source-code">   { </pre>
			<pre class="source-code">      using type = typelist&lt;Ts...&gt;;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;&gt;</pre>
			<pre class="source-code">   struct pop_back_type&lt;-1, typelist&lt;&gt;, typelist&lt;&gt;&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      using type = typelist&lt;&gt;;</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename TL&gt;</pre>
			<pre class="source-code">using pop_back_t = typename detail::pop_back_type&lt;</pre>
			<pre class="source-code">   static_cast&lt;std::ptrdiff_t&gt;(length_v&lt;TL&gt;)-1, </pre>
			<pre class="source-code">               typelist&lt;&gt;, TL&gt;::type;</pre>
			<p>For implementing this operation, we need to start with a typelist and recursively construct another typelist, element by element, until we get to the last type in the input typelist, which should be omitted. For this, we use a counter that tells us how many times we iterated the typelist.</p>
			<p>This is initiated with the size of the typelist minus one and we need to stop when we reach zero. For this reason, the <strong class="source-inline">pop_back_type</strong> class template has four specializations, one <a id="_idIndexMarker786"/>for the general case when we are at <a id="_idIndexMarker787"/>some iteration in the typelist, two for the case when the counter reached zero, and one for the case when the counter reached the value minus one. This is the case when the initial typelist was empty (therefore, <strong class="source-inline">length_t&lt;TL&gt; - 1</strong> would evaluate to -1). Here are some asserts that show how to use <strong class="source-inline">pop_back_t</strong> and validate its correctness:</p>
			<pre class="source-code">static_assert(std::is_same_v&lt;pop_back_t&lt;typelist&lt;&gt;&gt;, </pre>
			<pre class="source-code">                             typelist&lt;&gt;&gt;);</pre>
			<pre class="source-code">static_assert(std::is_same_v&lt;pop_back_t&lt;typelist&lt;double&gt;&gt;, </pre>
			<pre class="source-code">                             typelist&lt;&gt;&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;pop_back_t&lt;typelist&lt;double, char&gt;&gt;, </pre>
			<pre class="source-code">                             typelist&lt;double&gt;&gt;);</pre>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_same_v&lt;pop_back_t&lt;typelist&lt;double, char, int&gt;&gt;,</pre>
			<pre class="source-code">                             typelist&lt;double, char&gt;&gt;);</pre>
			<p>With these defined, we have provided a series of operations that are necessary for working with typelists. The <strong class="source-inline">length_t</strong> and <strong class="source-inline">at_t</strong> operations were used in the example shown earlier with the execution of functors on <strong class="source-inline">game_unit</strong> objects. Hopefully, this section provided <a id="_idIndexMarker788"/>a helpful introduction to typelists and enabled <a id="_idIndexMarker789"/>you to understand not only how they are implemented but also how they can be used.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor170"/>Summary</h1>
			<p>This chapter was dedicated to learning various metaprogramming techniques. We started by understanding the differences between dynamic and static polymorphism and then looked at the curiously recurring template pattern for implementing the latter.</p>
			<p>Mixins was another pattern that has a similar purpose as CRTP—adding functionality to classes, but unlike CRTP, without modifying them. The third technique we learned<a id="_idTextAnchor171"/> about was type erasure, which allows similar types that are unrelated to be treated generically. In the second part, we learned about tag disp<a id="_idTextAnchor172"/>atching – which allow us to select between overloads at compile time, and expression templates – which enable lazy evaluation of a computation at compile-time to avoid inefficient operations that occur at runtime. Lastly, we explored typelists and learned how they are used and how we can implement operations with them.</p>
			<p>In the next chapter,<a id="_idTextAnchor173"/> we will look at the core pillars of the standard template<a id="_idTextAnchor174"/> library, containers, iterators, and algori<a id="_idTextAnchor175"/>thms.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor176"/>Questions</h1>
			<ol>
				<li>What are the typica<a id="_idTextAnchor177"/>l problems that can be solved by CRTP?</li>
				<li>What are mixins and what is their purpose?</li>
				<li>What is type erasure?</li>
				<li>What is tag dispatching and what are its alternatives?</li>
				<li>What are expression templates and where are they used?</li>
			</ol>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor178"/>Further reading</h1>
			<ul>
				<li><em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em> – Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, p. 163, Addison-Wesley</li>
				<li><em class="italic">Modern C++ Design: Generic Programming and Design Patterns Applied </em>– Andrei Alexandrescu, Addison-Wesley Professional</li>
				<li><em class="italic">Mixin-Based Programming in C++</em> – Yannis Smaragdakis, Don Batory, <a href="https://yanniss.github.io/practical-fmtd.pdf%0D">https://yanniss.github.io/practical-fmtd.pdf</a></li>
				<li><em class="italic">Curiously Recurring Template Patterns</em> – James Coplien, <a href="http://sites.google.com/a/gertrudandcope.com/info/Publications/InheritedTemplate.pdf%0D">http://sites.google.com/a/gertrudandcope.com/info/Publications/InheritedTemplate.pdf</a></li>
				<li><em class="italic">Mixin Classes: The Yang of the CRTP</em> – Jonathan Boccara, <a href="https://www.fluentcpp.com/2017/12/12/mixin-classes-yang-crtp/%0D">https://www.fluentcpp.com/2017/12/12/mixin-classes-yang-crtp/</a></li>
				<li><em class="italic">What the Curiously Recurring Template Pattern can bring to your code</em> – Jonathan Boccara, <a href="https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/%0D">https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/</a></li>
				<li><em class="italic">Combining Static and Dynamic Polymorphism with C++ Mixin classes</em> – Michael Afanasiev, <a href="https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html%0D">https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html</a></li>
				<li><em class="italic">Why C++ is not just an Object-Oriented Programming Language</em> – Bjarne Stroustrup, <a href="https://www.stroustrup.com/oopsla.pdf%0D">https://www.stroustrup.com/oopsla.pdf</a></li>
				<li><strong class="source-inline">enable_shared_from_this</strong><em class="italic"> - overview, examples, and internals</em> – Hitesh Kumar, <a href="https://www.nextptr.com/tutorial/ta1414193955/enable_shared_from_this-overview-examples-and-internals%0D">https://www.nextptr.com/tutorial/ta1414193955/enable_shared_from_this-overview-examples-and-internals</a></li>
				<li><em class="italic">Tag dispatch versus concept overloading</em> – Arthur O’Dwyer, <a href="https://quuxplusone.github.io/blog/2021/06/07/tag-dispatch-and-concept-overloading/%0D">https://quuxplusone.github.io/blog/2021/06/07/tag-dispatch-and-concept-overloading/</a></li>
				<li><em class="italic">C++ Expression Templates: An Introduction to the Principles of Expression Templates</em> – Klaus Kreft and Angelika Langer, <a href="http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm%0D">http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm</a></li>
				<li><em class="italic">We don’t need no stinking expression templates</em>, <a href="https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/">https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/</a></li>
				<li><em class="italic">Generic Programming: Typelists and Applications</em> – Andrei Alexandrescu, <a href="https://www.drdobbs.com/generic-programmingtypelists-and-applica/184403813%0D">https://www.drdobbs.com/generic-programmingtypelists-and-applica/184403813</a></li>
				<li><em class="italic">Of type lists and type switches</em> – Bastian Rieck, <a href="https://bastian.rieck.me/blog/posts/2015/type_lists_and_switches/">https://bastian.rieck.me/blog/posts/2015/type_lists_and_switches/</a></li>
			</ul>
		</div>
	</div></body></html>