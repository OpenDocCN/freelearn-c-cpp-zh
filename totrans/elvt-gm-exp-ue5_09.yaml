- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Adding Audio-Visual Elements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加音频-视觉元素
- en: In the previous chapter, we learned about the game UI and how to create and
    add a user interface (also known as a widget) to the screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了游戏UI以及如何将用户界面（也称为小部件）创建并添加到屏幕上。
- en: In this chapter, we will learn how to add audio and particle effects to our
    game. Both of these aspects will increase the quality of our game and produce
    a much more immersive experience for the player.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将音频和粒子效果添加到我们的游戏中。这两个方面都将提高我们游戏的质量，并为玩家提供更加沉浸式的体验。
- en: Sound in video games can come in the form of either sound effects (also known
    as SFX) or music. Sound effects make the world around you more believable and
    alive, while the music helps set the tone for your game. Both these aspects are
    very important to your game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏中的声音可以以音效（也称为SFX）或音乐的形式出现。音效使你周围的世界更加逼真和生动，而音乐有助于为你的游戏设定基调。这两个方面对你的游戏都非常重要。
- en: 'In competitive games such as **Counter-Strike: Global Offensive** (**CS: GO**),
    sound is also extremely important because players need to hear the sounds around
    them, such as gunshots and footsteps, and which direction they came from, to gather
    as much information about their surroundings as possible.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '在像**反恐精英：全球攻势**（**CS: GO**）这样的竞技游戏中，声音同样非常重要，因为玩家需要听到他们周围的声音，如枪声和脚步声，以及声音来自哪个方向，以便尽可能多地收集关于周围环境的信息。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Audio in UE5
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UE5中的音频
- en: Sound attenuation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音衰减
- en: Understanding Particle Systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解粒子系统
- en: Exploring level design
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索关卡设计
- en: Extra features
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外功能
- en: 'Particle effects are important for the same reason that sound effects are important:
    they make your game world more believable and immersive.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子效果之所以重要，原因与音效相同：它们使你的游戏世界更加逼真和沉浸。
- en: Let’s start this chapter by learning how audio works in UE5.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个章节开始，学习UE5中音频的工作原理。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The project for this chapter can be found in the Chapter09 folder of the code
    bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的Chapter09文件夹中找到，代码包可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: Audio in UE5
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UE5中的音频
- en: 'One of the essential components of any game is sound. Sounds make your game
    more believable and immersive, which will provide a much better experience for
    your player. Video games usually have two types of sounds:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何游戏的一个基本组成部分是声音。声音使你的游戏更加逼真和沉浸，这将为你的玩家提供更好的体验。视频游戏通常有两种类型的声音：
- en: 2D sounds
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D声音
- en: 3D sounds
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D声音
- en: 2D sounds don’t have any consideration for the listener’s distance and direction,
    while 3D sounds can be higher or lower in volume and pan to the right or left,
    depending on the player’s location. 2D sounds are usually used for music, while
    3D sounds are usually used for sound effects. The main sound file types are `.wav`
    and `.mp3`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 2D声音不考虑听者的距离和方向，而3D声音的音量可以更高或更低，并且可以根据玩家的位置向右或左偏移。2D声音通常用于音乐，而3D声音通常用于音效。主要的声音文件类型是`.wav`和`.mp3`。
- en: 'Here are some of the assets and classes related to audio in UE5:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些与UE5中音频相关的资产和类：
- en: '`Sound Base`: Represents an asset that contains audio. This class is mainly
    used in C++ and Blueprint to reference an audio file that can be played.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`声音基础`：表示包含音频的资产。这个类主要用于C++和蓝图来引用可以播放的音频文件。'
- en: '`Sound Wave`: Represents an audio file that has been imported into UE5\. It
    inherits from `Sound Base`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`声音波`：表示已导入UE5的音频文件。它继承自`声音基础`。'
- en: '`Sound Cue`: An audio asset that can contain logic related to things such as
    attenuation (how the volume changes as the listener’s distance varies), looping,
    sound mixing, and other audio-related functionality. It inherits from `Sound Base`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`声音提示`：一种可以包含与衰减（随着听者距离的变化音量如何变化）、循环、声音混合以及其他音频相关功能的音频资产。它继承自`声音基础`。'
- en: '`Sound Class`: An asset that allows you to separate your audio files into groups
    and manage some of their settings, such as volume and pitch. An example of this
    would be grouping all your sounds related to sound effects in the `SFX` sound
    class, all your character dialog in the Dialog sound class, and so on.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`声音类别`：一个允许你将音频文件分组并管理它们的一些设置（如音量和音调）的资产。例如，将所有与音效相关的声音分组到 `SFX` 声音类别中，所有角色对话分组到
    `Dialog` 声音类别中，等等。'
- en: '`Sound Attenuation`: An asset that allows you to specify how a 3D sound will
    behave; for example, at which distance it will start to lower the volume, at which
    distance it will become inaudible (can’t be heard), whether its volume will change
    linearly or exponentially as the distance increases, and so on.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`声音衰减`：一个允许你指定3D声音如何行为的资产；例如，在哪个距离开始降低音量，在哪个距离变得不可闻（听不到），随着距离的增加，其音量是线性变化还是指数变化，等等。'
- en: '`Audio Component`: An actor component that allows you to manage the playback
    of audio files and their properties. This is useful for setting up continuous
    playback of sounds, such as background music.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`音频组件`：一个允许你管理音频文件及其属性的actor组件。这对于设置连续播放声音（如背景音乐）非常有用。'
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: UE5 has a new audio system called **Meta Sounds**, which allows developers to
    create sounds using **Digital Signal Processing** (**DSP**). Because this topic
    is outside the scope of this book, we will not be covering this system. If you
    want to know more about the system and how it works, you can do so by going to
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: UE5 有一个新的音频系统称为 **元声音**，它允许开发者使用 **数字信号处理**（**DSP**）来创建声音。由于这个主题超出了本书的范围，我们不会介绍这个系统。如果你想了解更多关于这个系统及其工作原理的信息，你可以通过访问
- en: '[https://docs.unrealengine.com/5.0/en-US/AudioFeatures/MetaSounds/](https://docs.unrealengine.com/5.0/en-US/AudioFeatures/MetaSounds/).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/5.0/en-US/AudioFeatures/MetaSounds/](https://docs.unrealengine.com/5.0/en-US/AudioFeatures/MetaSounds/).'
- en: 'In UE5, we can import existing sounds the same way we would any other asset:
    either by dragging a file from Windows File Explorer into the **Content Browser**
    area or by clicking the **Import** button in the **Content Browser** area. We’ll
    do this in the next exercise.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE5 中，我们可以像导入其他任何资产一样导入现有声音：要么通过从 Windows 文件资源管理器拖动文件到 **内容浏览器** 区域，要么通过在
    **内容浏览器** 区域中点击 **导入** 按钮。我们将在下一个练习中这样做。
- en: Exercise 9.01 – Importing an audio file
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.01 – 导入音频文件
- en: In this exercise, you will import an existing sound file from your computer
    into UE5\. This audio file will be played when the dodgeball bounces off a surface.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将从你的计算机中导入一个现有的声音文件到 UE5。当躲避球从表面上弹跳时，将播放此音频文件。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t have an audio file (either a `.mp3` or `.wav` file) available to
    complete this exercise, you can download the `.mp3` or `.wav` file available at
    [https://www.freesoundeffects.com/free-track/bounce-1-468901/](https://www.freesoundeffects.com/free-track/bounce-1-468901/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有可用的音频文件（无论是 `.mp3` 还是 `.wav` 文件）来完成此练习，你可以下载在 [https://www.freesoundeffects.com/free-track/bounce-1-468901/](https://www.freesoundeffects.com/free-track/bounce-1-468901/)
    可用的 `.mp3` 或 `.wav` 文件。
- en: Save this file as `BOUNCE.wav`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 `BOUNCE.wav`。
- en: 'Once you have an audio file, follow these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了音频文件，请按照以下步骤操作：
- en: Open the editor.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器。
- en: 'Go to the `Content` folder inside the `Audio`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `音频` 中的 `内容` 文件夹：
- en: '![Figure 9.1 – The Audio folder in the Content Browser area ](img/Figure_9.01_B18531.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 内容浏览器区域中的音频文件夹](img/Figure_9.01_B18531.jpg)'
- en: Figure 9.1 – The Audio folder in the Content Browser area
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 内容浏览器区域中的音频文件夹
- en: Go to the `Audio` folder you just created.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你刚刚创建的 `音频` 文件夹。
- en: Import your audio file into this folder. You can do this by *dragging* the audio
    file from **Windows File Explorer** into **Content Browser**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的音频文件导入此文件夹。你可以通过 *拖动* 音频文件从 **Windows 文件资源管理器** 到 **内容浏览器** 来完成此操作。
- en: 'Once you’ve done this, a new asset should appear with the same name as your
    audio file, which you can listen to when clicking on it:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，应该会显示一个与你的音频文件同名的新资产，你可以通过点击它来播放：
- en: '![Figure 9.2 – The imported audio file ](img/Figure_9.02_B18531.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 导入的音频文件](img/Figure_9.02_B18531.jpg)'
- en: Figure 9.2 – The imported audio file
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 导入的音频文件
- en: 'Open this asset. You should see many properties available for editing. However,
    we’ll be focusing solely on some of the properties inside the **Sound** category:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开此资产。你应该会看到许多可编辑的属性。然而，我们将专注于 **声音** 类别中的一些属性：
- en: '![Figure 9.3 – The Sound asset’s settings ](img/Figure_9.03_B18531.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 声音资产的设置](img/Figure_9.03_B18531.jpg)'
- en: Figure 9.3 – The Sound asset’s settings
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 声音资产设置
- en: 'The following properties are available in the **Sound** category:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下属性在 **声音** 类别中可用：
- en: '**Looping**: Whether this sound will loop while being played.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环**: 在播放时，这个声音是否会循环。'
- en: '**Volume**: The volume of this sound.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音量**: 这个声音的音量。'
- en: '**Pitch**: The pitch of this sound. The higher the pitch, the higher the frequency,
    and the higher in tone this sound will be.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音调**: 这个声音的音调。音调越高，频率越高，这个声音的音高也会越高。'
- en: '**Class**: The sound class of this sound.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**: 这个声音的声类。'
- en: The only property we’ll be changing is the `Class` property. We could use one
    of the existing `Sound` classes that comes with UE5, but let’s create our own
    for the `Dodgeball` game to create a new group of sounds for our game.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要更改的唯一属性是 `Class` 属性。我们可以使用 UE5 附带的一个现有的 `Sound` 类，但让我们为 `Dodgeball` 游戏创建一个自己的类，以创建一组新的声音供游戏使用。
- en: Go to the `Audio` folder inside the **Content Browser** area.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **内容浏览器** 区域内的 `Audio` 文件夹。
- en: Right-click, go to the `Sound Class` asset. Rename this asset `Dodgeball`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击，转到 `Sound Class` 资产。将此资产重命名为 `Dodgeball`。
- en: 'Open your imported sound asset and set its `Dodgeball`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你导入的声音资产，并设置其 `Dodgeball`：
- en: '![Figure 9.4 – Changing the Class property to the Dodgeball Sound Class ](img/Figure_9.04_B18531.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 将类属性更改为 Dodgeball 声音类](img/Figure_9.04_B18531.jpg)'
- en: Figure 9.4 – Changing the Class property to the Dodgeball Sound Class
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 将类属性更改为 Dodgeball 声音类
- en: Now that this imported sound asset belongs to a specific class, you can group
    other sound effects related to the dodgeball in the same `Sound Class` and edit
    their properties through that `Sound Class`, which includes `Volume`, `Pitch`,
    and many others.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个导入的声音资产属于一个特定的类，你可以在同一个 `Sound Class` 中分组与躲避球相关的其他声音效果，并通过该 `Sound Class`
    编辑它们的属性，包括 `Volume`、`Pitch` 以及许多其他属性。
- en: And with that, we can conclude our exercise. You have learned how to import
    sounds into your project and how to change their basic properties. Now, let’s
    move on to the next exercise, where we’ll be playing a sound whenever a dodgeball
    bounces off a surface in our game.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们可以得出结论。你已经学会了如何将声音导入到你的项目中，以及如何更改它们的基本属性。现在，让我们继续下一个练习，我们将在这个游戏中，每当躲避球从表面上弹跳时播放声音。
- en: Exercise 9.02 – Playing a sound when the dodgeball bounces off a surface
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.02 – 当躲避球从表面上弹跳时播放声音
- en: In this exercise, we will add the necessary functionality to our `DodgeballProjectile`
    class so that a sound will play when the dodgeball bounces off a surface.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向我们的 `DodgeballProjectile` 类添加必要的功能，以便当躲避球从表面上弹跳时播放声音。
- en: 'To do this, follow these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请按照以下步骤操作：
- en: Close the editor and open Visual Studio.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器并打开 Visual Studio。
- en: 'In the header file for the `DodgeballProjectile` class, add a protected `class
    USoundBase*` property called `BounceSound`. This property should be a `UPROPERTY`
    and have the `EditDefaultsOnly` tag so that it can be edited in the Blueprint:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DodgeballProjectile` 类的头文件中，添加一个名为 `BounceSound` 的受保护的 `USoundBase*` 属性。这个属性应该是一个
    `UPROPERTY`，并具有 `EditDefaultsOnly` 标签，以便可以在蓝图中进行编辑：
- en: '[PRE0]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you’ve done this, go to the `DodgeballProjectile` class’s source file
    and add an include for the `GameplayStatics` object:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，转到 `DodgeballProjectile` 类的源文件，并添加对 `GameplayStatics` 对象的包含：
- en: '[PRE1]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, at the beginning of the class’s implementation of the `OnHit` function,
    before the cast to the `DodgeballCharacter` class, check whether our `BounceSound`
    is a valid property (different than `nullptr`) and whether the magnitude of the
    `NormalImpulse` property is greater than `600` units (we can access the magnitude
    by calling its `Size` function).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在类实现的 `OnHit` 函数的开始处，在将 `DodgeballCharacter` 类进行转换之前，检查我们的 `BounceSound`
    是否是一个有效的属性（不同于 `nullptr`）以及 `NormalImpulse` 属性的幅度是否大于 `600` 单位（我们可以通过调用其 `Size`
    函数来访问幅度）。
- en: 'As we saw in [*Chapter 6*](B18531_06.xhtml#_idTextAnchor134)*, Setting Up Collision
    Objects*, the `NormalImpulse` property indicates the direction and magnitude of
    the force that will change the dodgeball’s trajectory after it has been hit. The
    reason why we want to check whether its magnitude is greater than a certain amount
    is that when the dodgeball starts losing momentum and bounces off the floor several
    times per second, we don’t want to play `BounceSound` several times per second;
    otherwise, it will generate a lot of noise. So, we will check whether the impulse
    that the dodgeball is suffering is greater than that amount to make sure this
    doesn’t happen. If both these things are true, we’ll call the `GameplayStatics`
    object’s `PlaySoundAtLocation`. This function is responsible for playing 3D sounds.
    It receives five parameters:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第6章*](B18531_06.xhtml#_idTextAnchor134)*，设置碰撞对象*中看到的，`NormalImpulse`属性表示击中躲避球后改变躲避球轨迹的力的方向和大小。我们想要检查其大小是否大于某个特定值的原因是，当躲避球开始失去动量并在每秒内弹跳几次时，我们不希望每秒播放`BounceSound`几次；否则，它会产生很多噪音。因此，我们将检查躲避球所受的冲量是否大于这个值，以确保这种情况不会发生。如果这两件事都是真的，我们将调用`GameplayStatics`对象的`PlaySoundAtLocation`方法。这个函数负责播放3D声音。它接收五个参数：
- en: A world context object, which we’ll pass as the `this` pointer.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个世界上下文对象，我们将作为`this`指针传递。
- en: A `SoundBase` property, which will be our `HitSound` property.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`SoundBase`属性，它将是我们的`HitSound`属性。
- en: The origin of the sound, which we’ll pass using the `GetActorLocation` function.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音的起点，我们将使用`GetActorLocation`函数传递。
- en: '`VolumeMultiplier`, which we’ll pass with a value of `1`. This value indicates
    how much higher or lower the volume of this sound will be when it’s played. For
    instance, a value of `2` means it will have a volume twice as high.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VolumeMultiplier`，我们将使用值为`1`。这个值表示当播放声音时音量会高多少或低多少。例如，值为`2`意味着它的音量将是原来的两倍。'
- en: '`PitchMultiplier`, which indicates how much higher or lower the pitch of this
    sound will be when it’s played. We’ll be passing this value by using the `FMath`
    object’s `RandRange` function, which receives two numbers as parameters and returns
    a random number between those two. To randomly generate a number between `0.7`
    and `1.3`, we’ll be calling this function with these values as parameters.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PitchMultiplier`，它表示当播放声音时音高会高多少或低多少。我们将通过使用`FMath`对象的`RandRange`函数来传递这个值，该函数接收两个数字作为参数并返回这两个数字之间的随机数。为了随机生成一个介于`0.7`和`1.3`之间的数字，我们将使用这些值作为参数调用这个函数。'
- en: 'Have a look at the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码片段：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The function responsible for playing 2D sounds is also available from the `GameplayStatics`
    object, and it’s called `PlaySound2D`. This function will receive the same parameters
    as the `PlaySoundAtLocation` function, except for the third parameter, which is
    the origin of the sound.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 负责播放2D声音的函数也来自`GameplayStatics`对象，并称为`PlaySound2D`。这个函数将接收与`PlaySoundAtLocation`函数相同的参数，除了第三个参数，即声音的起点。
- en: Compile these changes and open Unreal Editor.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译这些更改并打开Unreal编辑器。
- en: 'Open the `BP_DodgeballProjectile` Blueprint, go to its `BounceSound` property
    to the `Sound` asset you imported:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_DodgeballProjectile`蓝图，进入其`BounceSound`属性，找到你导入的`Sound`资产：
- en: '![Figure 9.5 – Setting the BounceSound property to our imported sound ](img/Figure_9.05_B18531.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 将BounceSound属性设置为导入的声音](img/Figure_9.05_B18531.jpg)'
- en: Figure 9.5 – Setting the BounceSound property to our imported sound
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 将BounceSound属性设置为导入的声音
- en: 'Play the level again and enter the enemy character’s line of sight. You should
    notice a sound playing with different pitch values every time the dodgeball that’s
    thrown by the enemy character hits a wall or the floor (not the player character):'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次播放关卡并进入敌人角色的视线。你应该注意到，每次敌人角色投掷的躲避球击中墙壁或地板（不是玩家角色）时，都会播放不同音高的声音：
- en: '![Figure 9.6 – The player character causing the enemy character to throw dodgeballs
    ](img/Figure_9.06_B18531.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 玩家角色导致敌人角色投掷躲避球](img/Figure_9.06_B18531.jpg)'
- en: Figure 9.6 – The player character causing the enemy character to throw dodgeballs
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 玩家角色导致敌人角色投掷躲避球
- en: If this happens, congratulations – you’ve successfully played a sound using
    UE5! If you can’t hear the sound playing, make sure that it is audible (it has
    a level of volume that you can hear).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，恭喜你 – 你已经成功使用UE5播放了声音！如果你听不到声音播放，请确保它是可听见的（它有一个你能听到的音量级别）。
- en: However, another thing you’ll probably notice is that the sound is always played
    at the same volume, regardless of the distance that the character is from the
    dodgeball that is bouncing; the sound isn’t playing in 3D but rather in 2D. To
    play a sound in 3D using UE5, we’ll have to learn about **Sound Attenuation**
    assets.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能还会注意到，声音始终以相同的音量播放，无论角色与弹跳躲避球的距离如何；声音不是在 3D 中播放，而是在 2D 中播放。要使用 UE5 播放
    3D 声音，我们必须了解**声音衰减**资源。
- en: Sound attenuation
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音衰减
- en: For a sound to be played in 3D inside UE5, you’ll have to create a **Sound Attenuation**
    asset, as we mentioned previously. A **Sound Attenuation** asset will let you
    specify how you want a specific sound to change volume as its distance from the
    listener increases. Have a look at the following example.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 UE5 内部播放 3D 声音，您必须创建一个**声音衰减**资源，正如我们之前提到的。一个**声音衰减**资源将允许您指定特定声音如何随着其与听者的距离增加而改变音量。请看以下示例。
- en: 'Open Unreal Editor, go to the `Audio` folder inside the `BounceAttenuation`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Unreal 编辑器，进入`BounceAttenuation`中的`Audio`文件夹：
- en: '![Figure 9.7 – Creating the Sound Attenuation asset ](img/Figure_9.07_B18531.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 创建声音衰减资源](img/Figure_9.07_B18531.jpg)'
- en: Figure 9.7 – Creating the Sound Attenuation asset
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 创建声音衰减资源
- en: Open this `BounceAttenuation` asset.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 打开这个`BounceAttenuation`资源。
- en: '**Sound Attenuation** assets have many settings; however, we’ll want to focus
    mainly on a couple of settings from the **Attenuation Distance** section:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**声音衰减**资源有许多设置；然而，我们主要想关注**衰减距离**部分的一两个设置：'
- en: '`Inner Radius`: This `float` property allows us to specify at what distance
    the sound will start lowering in volume. If the sound is played at a distance
    less than this value, the volume won’t be affected. Set this property to `200`
    units.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`内半径`：这个`float`属性允许我们指定在什么距离上声音将开始降低音量。如果声音在小于此值的距离上播放，音量将不受影响。将此属性设置为`200`单位。'
- en: '`Falloff Distance`: This `float` property allows us to specify at what distance
    we want the sound to be inaudible. If the sound is played at a distance greater
    than this value, we won’t hear it. The volume of the sound will vary according
    to its distance to the listener and whether it’s closer to `Inner Radius` or `Falloff
    Distance`. Set this property to `1500` units:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`衰减距离`：这个`float`属性允许我们指定在什么距离上我们希望声音变得不可闻。如果声音在大于此值的距离上播放，我们就听不到它。声音的音量将根据其与听者的距离以及它是否更接近`内半径`或`衰减距离`而变化。将此属性设置为`1500`单位：'
- en: '![Figure 9.8 – The Sound Attenuation asset settings ](img/Figure_9.08_B18531.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 声音衰减资源设置](img/Figure_9.08_B18531.jpg)'
- en: Figure 9.8 – The Sound Attenuation asset settings
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 声音衰减资源设置
- en: Think of this as two circles around the player, with the smaller circle being
    the inner circle (with a radius value of `Inner Radius`) and the bigger circle
    being the falloff circle (with a radius value of `Falloff Distance`). If a sound
    originates from inside the inner circle, it is played at full volume, while a
    sound that originates from outside the falloff circle is not played at all.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将其想象为围绕玩家的两个圆圈，较小的圆圈是内圆（半径值为`内半径`），较大的圆圈是衰减圆圈（半径值为`衰减距离`）。如果声音起源于内圆内部，它将以全音量播放，而起源于衰减圆圈之外的声音则完全不播放。
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information on **Sound Attenuation** assets here: [https://docs.unrealengine.com/en-US/Engine/Audio/DistanceModelAttenuation](https://docs.unrealengine.com/en-US/Engine/Audio/DistanceModelAttenuation).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到有关**声音衰减**资源的更多信息：[https://docs.unrealengine.com/en-US/Engine/Audio/DistanceModelAttenuation](https://docs.unrealengine.com/en-US/Engine/Audio/DistanceModelAttenuation).
- en: Now that you know about **Sound Attenuation** assets, let’s move on to the next
    exercise, where we’ll turn the sound that plays when the dodgeball bounces off
    the ground into a 3D sound.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了**声音衰减**资源，让我们继续下一个练习，我们将把躲避球弹跳时播放的声音转换为 3D 声音。
- en: Exercise 9.03 – Turning the bounce sound into a 3D sound
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.03 – 将弹跳声音转换为 3D 声音
- en: In this exercise, we’ll be turning the sound that plays when a dodgeball bounces
    off the ground, which we added in the previous exercise, into a 3D sound. This
    means that when the dodgeball bounces off a surface, the sound it plays will vary
    in volume, depending on its distance from the player. We’re doing this so that
    when the dodgeball is far away, the sound volume will be low, and when it’s close,
    its volume will be high.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将把我们在上一个练习中添加的当手榴弹从地面上弹跳时播放的声音转换成 3D 声音。这意味着当手榴弹从表面弹跳时，它播放的声音的音量将根据其与玩家的距离而变化。我们这样做是为了当手榴弹远离时，声音音量会低，而当它靠近时，音量会高。
- en: 'To use the `BounceAttenuation` asset we created in the previous section, follow
    these steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们在上一节中创建的 `BounceAttenuation` 资产，请按照以下步骤操作：
- en: 'Go to the header file for `DodgeballProjectile` and add a `protected` `class
    USoundAttenuation*` property called `BounceSoundAttenuation`. This property should
    be a `UPROPERTY` and have the `EditDefaultsOnly` tag so that it can be edited
    in the Blueprint:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `DodgeballProjectile` 的头文件，并添加一个名为 `BounceSoundAttenuation` 的 `protected`
    `class USoundAttenuation*` 属性。这个属性应该是一个 `UPROPERTY`，并具有 `EditDefaultsOnly` 标签，以便可以在蓝图中进行编辑：
- en: '[PRE3]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Go to the `DodgeballProjectile` class’s implementation of the `OnHit` function
    in its source file and add the following parameters to the call to the `PlaySoundAtLocation`
    function:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `DodgeballProjectile` 类的源文件中 `OnHit` 函数的实现，并将以下参数添加到对 `PlaySoundAtLocation`
    函数的调用中：
- en: '`StartTime`, which we’ll pass with a value of `0`. This value indicates the
    time that the sound will start playing. If the sound lasts 2 seconds, we can have
    this sound start at its 1-second mark by passing a value of `1`. We pass a value
    of `0` to have the sound play from the start.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartTime`，我们将传递一个值为 `0` 的值。这个值表示声音开始播放的时间。如果声音持续 2 秒，我们可以通过传递一个值为 `1` 的值，让这个声音从
    1 秒处开始播放。我们传递一个值为 `0` 以使声音从开始播放。'
- en: '`SoundAttenuation`, to which we’ll pass our `BounceSoundAttenuation` property:'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SoundAttenuation`，我们将传递我们的 `BounceSoundAttenuation` 属性：'
- en: '[PRE4]'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although we only want to pass the additional `SoundAttenuation` parameter, we
    must pass all the other parameters that come before it as well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只想传递额外的 `SoundAttenuation` 参数，但我们必须传递所有在它之前的其他参数。
- en: Compile these changes and then open the editor.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译这些更改，然后打开编辑器。
- en: 'Open the `BP_DodgeballProjectile` Blueprint, go to its `BounceSoundAttenuation`
    property to our `BounceAttenuation` asset:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `BP_DodgeballProjectile` 蓝图，转到其 `BounceSoundAttenuation` 属性到我们的 `BounceAttenuation`
    资产：
- en: '![Figure 9.9 – Setting the BounceSoundAttenuation property to the BounceAttenuation
    asset ](img/Figure_9.09_B18531.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 将 BounceSoundAttenuation 属性设置为 BounceAttenuation 资产](img/Figure_9.09_B18531.jpg)'
- en: Figure 9.9 – Setting the BounceSoundAttenuation property to the BounceAttenuation
    asset
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 将 BounceSoundAttenuation 属性设置为 BounceAttenuation 资产
- en: 'Play the level again and enter the enemy character’s line of sight. You should
    notice that the sound that plays every time the dodgeball thrown by the enemy
    character hits a wall or the floor will be played at different volumes, depending
    on its distance, and that you won’t hear it if the dodgeball is far away:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次播放关卡并进入敌人角色的视线范围内。你应该会注意到，每次敌人角色扔出的手榴弹击中墙壁或地板时播放的声音，其音量会根据其距离而不同，而且如果手榴弹远离，你将听不到它：
- en: '![Figure 9.10 – The player character causing the enemy character to throw dodgeballs
    ](img/Figure_9.10_B18531.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 玩家角色导致敌人角色扔手榴弹](img/Figure_9.10_B18531.jpg)'
- en: Figure 9.10 – The player character causing the enemy character to throw dodgeballs
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 玩家角色导致敌人角色扔手榴弹
- en: With that, we can conclude this exercise. You now know how to play 3D sounds
    using UE5\. We’ll add background music to our game in the next exercise.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们可以得出这个练习的结论。你现在知道如何使用 UE5 播放 3D 声音。我们将在下一个练习中为我们的游戏添加背景音乐。
- en: Exercise 9.04 – Adding background music to our game
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.04 – 为我们的游戏添加背景音乐
- en: 'In this exercise, we will add game background music to our game. We will do
    this by creating a new Actor with an Audio component, which, as we mentioned earlier,
    is appropriate for playing background music. To achieve this, follow these steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为我们的游戏添加游戏背景音乐。我们将通过创建一个新的具有音频组件的 Actor 来完成此操作，正如我们之前提到的，这对于播放背景音乐是合适的。为了实现这一点，请按照以下步骤操作：
- en: Download the audio file located at [https://packt.live/3pg21sQ](https://packt.live/3pg21sQ)
    and import it into the **Audio** folder of the **Content Browser** area, just
    like we did in *Exercise 9.01 – Importing an audio file*.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载位于 [https://packt.live/3pg21sQ](https://packt.live/3pg21sQ) 的音频文件，并将其导入到 **内容浏览器**
    区域的 **音频** 文件夹中，就像我们在 *练习 9.01 – 导入音频文件* 中所做的那样。
- en: Right-click inside the `Actor` class as its parent class. Name this new class
    `MusicManager`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Actor` 类内部右键单击，作为其父类。将这个新类命名为 `MusicManager`。
- en: When the files for this class are generated and Visual Studio has opened automatically,
    close the editor.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这个类的文件生成并 Visual Studio 自动打开时，关闭编辑器。
- en: 'In the `MusicManager` class’s header file, add a new `protected` property of
    the `class UAudioComponent*` type called `AudioComponent`. Make this a `UPROPERTY`
    and add the `VisibleAnywhere` and `BlueprintReadOnly` tags:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MusicManager` 类的头文件中，添加一个新的 `protected` 属性，类型为 `class UAudioComponent*`，名为
    `AudioComponent`。将其标记为 `UPROPERTY` 并添加 `VisibleAnywhere` 和 `BlueprintReadOnly`
    标签：
- en: '[PRE5]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `MusicManager` class’s source file, add an `#include` for the `AudioComponent`
    class:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MusicManager` 类的源文件中，添加对 `AudioComponent` 类的 `#include`：
- en: '[PRE6]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the constructor for this class, change the `bCanEverTick` property to `false`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类的构造函数中，将 `bCanEverTick` 属性更改为 `false`：
- en: '[PRE7]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After this line, add a new one that creates the `AudioComponent` class by calling
    the `CreateDefaultSubobject` function and passing the `UAudioComponent` class
    as a template parameter and `“Music Component”` as a normal parameter:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此行之后，添加一个新行，通过调用 `CreateDefaultSubobject` 函数创建 `AudioComponent` 类，并将 `UAudioComponent`
    类作为模板参数传递，将 `“音乐组件”` 作为普通参数：
- en: '[PRE8]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After making these changes, compile your code and open the editor.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行这些更改后，编译您的代码并打开编辑器。
- en: Go to the `ThirdPersonCPP` | `Blueprints` folder in the `MusicManager` class.
    Name it `BP_MusicManager`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `MusicManager` 类中的 `ThirdPersonCPP` | `Blueprints` 文件夹。将其命名为 `BP_MusicManager`。
- en: 'Open this asset, select its `Audio` component, and set that component’s `Sound`
    property to your imported sound:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开此资产，选择其 `音频` 组件，并将该组件的 `声音` 属性设置为导入的声音：
- en: '![Figure 9.11 – The Sound property being updated ](img/Figure_9.11_B18531.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 正在更新的声音属性](img/Figure_9.11_B18531.jpg)'
- en: Figure 9.11 – The Sound property being updated
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 正在更新的声音属性
- en: Drag an instance of the `BP_MusicManager` class into the level.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BP_MusicManager` 类的实例拖入关卡中。
- en: Play the level. You should notice the music start playing when the game starts
    and it should also loop automatically when it reaches the end (this is done due
    to the `Audio` component).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放关卡。你应该注意到当游戏开始时音乐开始播放，并且当它到达结束时应该自动循环（这是由于 `音频` 组件造成的）。
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`Sound` asset’s `Looping` property.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`声音` 资产的 `Looping` 属性。'
- en: With that, we’ve completed this exercise. You now know how to add simple background
    music to your game.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经完成了这个练习。你现在知道如何为你的游戏添加简单的背景音乐。
- en: Now, let’s jump into the next topic, which is Particle Systems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳到下一个主题，即粒子系统。
- en: Understanding Particle Systems
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解粒子系统
- en: 'Let’s talk about another very important element of many video games: Particle
    Systems.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈许多视频游戏中的一个非常重要的元素：粒子系统。
- en: 'In video game terms, a particle is essentially a position in a 3D space that
    can be represented with an image. A Particle System is a collection of many particles,
    potentially with different images, shapes, colors, and sizes. The following figure
    shows an example of two Particle Systems made in UE5:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏术语中，粒子本质上是一个可以用图像表示的 3D 空间中的位置。粒子系统是一组许多粒子，可能具有不同的图像、形状、颜色和大小。以下图显示了在 UE5
    中制作的两个粒子系统的示例：
- en: '![Figure 9.12 – Two different Particle Systems in UE5 ](img/Figure_9.12_B18531.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – UE5 中的两种不同的粒子系统](img/Figure_9.12_B18531.jpg)'
- en: Figure 9.12 – Two different Particle Systems in UE5
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – UE5 中的两种不同的粒子系统
- en: The Particle System on the left is supposed to be electrical sparks that could
    come from a cable that has been sliced and is now in short-circuit, while the
    one on the right is supposed to be a fire. Although the particle system on the
    left is relatively simple, you can tell that the one on the right has more than
    one type of particle inside it, which can be combined in the same system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的粒子系统应该是来自被切割并现在处于短路状态的电缆的电火花，而右侧的应该是火焰。尽管左侧的粒子系统相对简单，但你可以看出右侧的粒子系统内部有不止一种粒子，这些粒子可以在同一个系统中组合。
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'UE5 has two different tools for creating Particle Systems: **Cascade and Niagara**.
    Cascade has been present since the beginning of UE5, while Niagara is a system
    that is more recent and sophisticated and has only been production-ready since
    May 2020, as of Unreal Engine version 4.25.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: UE5有两种不同的工具用于创建粒子系统：**Cascade和Niagara**。Cascade自UE5开始以来一直存在，而Niagara是一个更新、更复杂的系统，并且直到2020年5月，在Unreal
    Engine版本4.25中才准备好用于生产。
- en: Creating Particle Systems in UE5 is outside the scope of this book, but it is
    recommended that you use Niagara over Cascade, given that it is a more recent
    addition to the engine.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE5中创建粒子系统超出了本书的范围，但鉴于它是引擎中较新的添加，建议使用Niagara而不是Cascade。
- en: 'In this chapter, we will only be using Particle Systems that are already included
    in UE5, but if you want to create your own, these links will give you more information
    about both Cascade and Niagara:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将仅使用UE5中已经包含的粒子系统，但如果你想要创建自己的，这些链接将提供有关Cascade和Niagara的更多信息：
- en: 'Cascade:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cascade:'
- en: '[https://docs.unrealengine.com/en-US/Engine/Rendering/ParticleSystems/Cascade](https://docs.unrealengine.com/en-US/Engine/Rendering/ParticleSystems/Cascade)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-US/Engine/Rendering/ParticleSystems/Cascade](https://docs.unrealengine.com/en-US/Engine/Rendering/ParticleSystems/Cascade)'
- en: '[https://www.youtube.com/playlist?list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t](https://www.youtube.com/playlist?list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/playlist?list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t](https://www.youtube.com/playlist?list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t)'
- en: 'Niagara:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'Niagara:'
- en: '[https://docs.unrealengine.com/en-US/Engine/Niagara/EmitterEditorReference/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Niagara/EmitterEditorReference/index.xhtml)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-US/Engine/Niagara/EmitterEditorReference/index.xhtml](https://docs.unrealengine.com/en-US/Engine/Niagara/EmitterEditorReference/index.xhtml)'
- en: '[https://docs.unrealengine.com/en-US/Engine/Niagara/QuickStart](https://docs.unrealengine.com/en-US/Engine/Niagara/QuickStart)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-US/Engine/Niagara/QuickStart](https://docs.unrealengine.com/en-US/Engine/Niagara/QuickStart)'
- en: We’ll learn how to add Particle Systems to our game in the next exercise. In
    this chapter, we will simply be using existing Particle Systems that were already
    made by the UE5 team.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节练习中，我们将学习如何将粒子系统添加到我们的游戏中。在本章中，我们只是简单地使用UE5团队已经制作好的现有粒子系统。
- en: Exercise 9.05 – Spawning a Particle System when the dodgeball hits the player
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.05 – 当躲避球击中玩家时生成粒子系统
- en: In this exercise, we will learn how to spawn a Particle System in UE5\. In this
    case, we will be spawning an `explosion` Particle System when a dodgeball thrown
    by the enemy hits the player.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何在UE5中生成粒子系统。在这种情况下，当敌方投掷的躲避球击中玩家时，我们将生成一个 `爆炸` 粒子系统。
- en: 'To achieve this, follow these steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请按照以下步骤操作：
- en: Close the editor and open Visual Studio.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器并打开Visual Studio。
- en: In the `DodgeballProjectile` class’s header file, add a protected `class UParticleSystem*`
    property called `HitParticles`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DodgeballProjectile` 类的头文件中，添加一个受保护的 `class UParticleSystem*` 属性，名为 `HitParticles`。
- en: 'The `UParticleSystem` type is the designation for a Particle System in UE5\.
    Be sure to make this a `UPROPERTY` and give it the `EditDefaultsOnly` tag so that
    it can be edited in the Blueprint class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`UParticleSystem` 类型是UE5中粒子系统的指定名称。请确保将其设置为 `UPROPERTY` 并添加 `EditDefaultsOnly`
    标签，以便在蓝图类中编辑：'
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `DodgeballProjectile` class’s source file, inside its implementation
    of the `OnHit` function, before the call to the `Destroy` function, check whether
    our `HitParticles` property is valid. If it is, call the `GameplayStatics` object’s
    `SpawnEmitterAtLocation` function.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DodgeballProjectile` 类的源文件中，在其 `OnHit` 函数的实现中，在调用 `Destroy` 函数之前，检查我们的 `HitParticles`
    属性是否有效。如果是，调用 `GameplayStatics` 对象的 `SpawnEmitterAtLocation` 函数。
- en: 'This function will spawn an actor that will play the Particle System we pass
    as a parameter. It receives the following parameters:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将生成一个演员，该演员将播放我们作为参数传递的粒子系统。它接收以下参数：
- en: A `World` object, which we’ll pass using the `GetWorld` function
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `World` 对象，我们将使用 `GetWorld` 函数传递
- en: A `UParticleSystem*` property, which will be our `HitParticles` property
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `UParticleSystem*` 属性，它将成为我们的 `HitParticles` 属性
- en: 'The `FTransform` of the actor that will play the Particle System, which we’ll
    pass using the `GetActorTransform` function:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将播放粒子系统的演员的 `FTransform`，我们将使用 `GetActorTransform` 函数传递：
- en: '[PRE10]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although we won’t be using it in this project, there is another function related
    to spawning Particle Systems available from the `GameplayStatics` object, which
    is the `SpawnEmitterAttached` function. This function will spawn a Particle System
    and attach it to an actor, which might be useful if you want to, for instance,
    make a moving object light on fire so that the Particle System will always remain
    attached to that object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这个项目中不会使用它，但`GameplayStatics`对象还提供了一个与生成粒子系统相关的函数，即`SpawnEmitterAttached`函数。此函数将生成一个粒子系统并将其附加到演员上，这可能在你想要，例如，使移动物体着火时很有用，这样粒子系统就会始终附加到该物体上。
- en: Compile these changes and open the editor.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译这些更改并打开编辑器。
- en: 'Open the `BP_DodgeballProjectile` Blueprint, go to its `HitParticles` property
    to the `P_Explosion` Particle System asset:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_DodgeballProjectile`蓝图，转到其`HitParticles`属性到`P_Explosion`粒子系统资产：
- en: '![Figure 9.13 – Setting the HitParticles property to P_Explosion ](img/Figure_9.13_B18531.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13 – 将HitParticles属性设置为P_Explosion](img/Figure_9.13_B18531.jpg)'
- en: Figure 9.13 – Setting the HitParticles property to P_Explosion
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 将HitParticles属性设置为P_Explosion
- en: 'Now, play the level and let your player character get hit by a dodgeball. You
    should see the explosion Particle System being played:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，播放关卡，并让您的玩家角色被躲避球击中。你应该会看到正在播放的爆炸粒子系统：
- en: '![Figure 9.14 – The explosion particle system being played when the dodgeball
    hits the player ](img/Figure_9.14_B18531.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14 – 当躲避球击中玩家时播放的爆炸粒子系统](img/Figure_9.14_B18531.jpg)'
- en: Figure 9.14 – The explosion particle system being played when the dodgeball
    hits the player
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 当躲避球击中玩家时播放的爆炸粒子系统
- en: And that concludes this exercise. You now know how to play Particle Systems
    in UE5\. Particle Systems add visual flair to your game and make it more visually
    appealing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了这个练习。你现在知道如何在UE5中播放粒子系统了。粒子系统为你的游戏增添了视觉魅力，使其更具视觉吸引力。
- en: In the next activity, we’ll be consolidating our knowledge of playing audio
    in UE5 by playing a sound when the dodgeball hits the player.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们将通过在躲避球击中玩家时播放声音来巩固我们在UE5中播放音频的知识。
- en: Activity 9.01 – Playing a sound when the dodgeball hits the player
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动9.01 – 当躲避球击中玩家时播放声音
- en: In this activity, we will be creating the logic responsible for playing a sound
    every time the player character gets hit by a dodgeball. In a video game, it’s
    very important to transmit the player’s crucial information in many ways, so in
    addition to changing the player character’s health bar, we’ll also be playing
    a sound when the player gets hit so that the player knows that the character is
    taking damage.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个逻辑，每当玩家角色被躲避球击中时都会播放声音。在视频游戏中，以多种方式传达玩家的关键信息非常重要，因此除了更改玩家角色的生命条外，我们还会在玩家被击中时播放声音，以便玩家知道角色正在受到伤害。
- en: 'To do this, follow these steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，请按照以下步骤操作：
- en: Import a sound file that will be played when the player character gets hit into
    the `Audio` folder inside the **Content Browser** area.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将将在玩家角色被击中时播放的声音文件导入**内容浏览器**区域内的`Audio`文件夹。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t have a sound file, you can use the one available at [https://www.freesoundeffects.com/free-track/punch-426855/](https://www.freesoundeffects.com/free-track/punch-426855/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有声音文件，您可以使用在[https://www.freesoundeffects.com/free-track/punch-426855/](https://www.freesoundeffects.com/free-track/punch-426855/)提供的文件。
- en: Open the `DodgeballProjectile` class’s header file. Add a `SoundBase*` property,
    just like we did in *Exercise 9.02 – Playing a sound when the dodgeball bounces
    off a surface*, but this time, call it `DamageSound`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DodgeballProjectile`类的头文件。添加一个`SoundBase*`属性，就像我们在*练习9.02 – 当躲避球从表面上弹跳时播放声音*中做的那样，但这次，将其命名为`DamageSound`。
- en: Open the `DodgeballProjectile` class’s source file. In the `OnHit` function’s
    implementation, once you’ve damaged the player character and before you call the
    `Destroy` function, check whether the `DamageSound` property is valid. If it is,
    call the `GameplayStatics` object’s `PlaySound2D` function (mentioned in *Exercise
    9.02 – Playing a sound when the dodgeball bounces off a surface*), passing `this`
    and `DamageSound` as the parameters to that function call.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DodgeballProjectile`类的源文件。在`OnHit`函数的实现中，一旦你伤害了玩家角色，在调用`Destroy`函数之前，检查`DamageSound`属性是否有效。如果是，调用`GameplayStatics`对象的`PlaySound2D`函数（在*练习9.02
    – 当躲避球从表面上弹跳时播放声音*中提到），将`this`和`DamageSound`作为参数传递给该函数调用。
- en: Compile your changes and open the editor.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的更改并打开编辑器。
- en: Open the `BP_DodgeballProjectile` Blueprint and set its `DamageSound` property
    to the sound file you imported at the start of this activity.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_DodgeballProjectile`蓝图，并将其`DamageSound`属性设置为在活动开始时导入的声音文件。
- en: 'When you play the level, you should notice that every time the player gets
    hit by a dodgeball, you will hear the sound you imported being played:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你玩关卡时，你应该注意到每次玩家被躲避球击中，你都会听到你导入的声音播放：
- en: '![Figure 9.15 – A sound should play when the player character gets hit ](img/Figure_9.14_B18531.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15 – 当玩家角色被击中时应该播放声音](img/Figure_9.14_B18531.jpg)'
- en: Figure 9.15 – A sound should play when the player character gets hit
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 当玩家角色被击中时应该播放声音
- en: And with those steps complete, you have finished this activity and consolidated
    the use of playing both 2D and 3D sounds in UE5.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你就完成了这个活动，并巩固了在UE5中使用2D和3D声音的应用。
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)找到。
- en: Now, let’s wrap up this chapter by learning a bit about the concept of level
    design.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过学习一点关卡设计的概念来结束这一章。
- en: Exploring level design
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索关卡设计
- en: Since [*Chapter 5*](B18531_05.xhtml#_idTextAnchor113), *Query with Line Traces*,
    which was related to our dodgeball game, we added a few game mechanics and gameplay
    opportunities, as well as some audio-visual elements, all of which were handled
    in this chapter. Now that we have all these game elements, we must bring them
    together into a level that can be played from start to finish by the player. To
    do that, let’s learn a bit about level design and level blockouts.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第5章*](B18531_05.xhtml#_idTextAnchor113)，与我们的躲避球游戏相关的*使用线迹查询*，我们添加了一些游戏机制和游戏玩法机会，以及一些视听元素，所有这些都在本章中处理。现在我们有了所有这些游戏元素，我们必须将它们组合成一个玩家可以从头到尾玩的游戏关卡。为了做到这一点，让我们学习一点关于关卡设计和关卡布局的知识。
- en: Level design is a specific game design discipline that focuses on building levels
    in a game. The goal of a level designer is to make a level that is fun to play,
    introduces new gameplay concepts to the player by using the game mechanics built
    for that game, contains good pacing (a good balance of action-packed and relaxed
    gameplay sequences), and much more.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 级别设计是一种特定的游戏设计学科，专注于在游戏中构建关卡。级别设计师的目标是制作一个好玩的游戏关卡，通过使用为该游戏构建的游戏机制向玩家引入新的游戏玩法概念，包含良好的节奏（充满动作和轻松游戏序列的良好平衡），以及更多。
- en: 'To test the structure of a level, level designers must build what is called
    a **level blockout**. This is a very simple and boiled-down version of the level
    that uses most of the elements that the final level will contain, but it is made
    using only simple shapes and geometry. This is so that it will be easier and less
    time-consuming to modify the level in case parts of it need to be changed:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试关卡的结构，级别设计师必须构建所谓的**关卡布局**。这是一个非常简单且简化的关卡版本，使用了最终关卡将包含的大部分元素，但它仅使用简单的形状和几何形状制作。这样，如果需要更改关卡的部分，修改起来会更容易且更节省时间：
- en: '![Figure 9.16 – An example of a level blockout made in UE5 using BSP Brushes
    ](img/Figure_9.16_B18531.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16 – 使用BSP刷子在UE5中制作的关卡布局示例](img/Figure_9.16_B18531.jpg)'
- en: Figure 9.16 – An example of a level blockout made in UE5 using BSP Brushes
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 使用BSP刷子在UE5中制作的关卡布局示例
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It should be noted that level design is its own specific game development skill
    and is worthy of its own book, of which there are quite a few, but diving into
    this topic is outside the scope of this book.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，关卡设计是其自身的特定游戏开发技能，并且值得有它自己的书籍，其中有很多，但深入探讨这个主题超出了本书的范围。
- en: In the next exercise, we will be building a simple level blockout using the
    mechanics we built in the last few chapters.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用我们在过去几章中构建的机制来构建一个简单的关卡布局。
- en: Exercise 9.06 – Building a level blockout
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.06 – 构建关卡布局
- en: In this exercise, we will be creating a new level blockout that will contain
    some structure, where the player will start in a certain place in the level and
    have to go through a series of obstacles to reach the end of the level. We will
    be using all the mechanics and objects that we built in the last few chapters
    to make a level that the player will be able to complete.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个新的水平面布局，其中将包含一些结构，玩家将在水平面中的某个位置开始，并必须通过一系列障碍物到达水平面的尽头。我们将使用我们在过去几章中构建的所有机制和对象来制作一个玩家可以完成的水平面。
- en: Although we will be providing you with a solution in this exercise, you are
    encouraged to let your creativity loose and come up with a solution yourself,
    given that there is no right or wrong answer in this case.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个练习中我们将为您提供解决方案，但我们鼓励您发挥创造力，自己提出解决方案，因为在这种情况下没有正确或错误的答案。
- en: 'To start this exercise, follow these steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 开始这个练习，请按照以下步骤操作：
- en: Open the editor.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器。
- en: Go to the `ThirdPersonCPP` | `Maps` folder in the `ThirdPersonExampleMap` asset,
    and name it `Level1`. You can do this by either selecting the asset and pressing
    *Ctrl* + *D* or by right-clicking on the asset and selecting **Duplicate** (the
    third option). This may not be available in some situations, so you’ll have to
    do this by copying and pasting the existing level (*Ctrl* + *C* and *Ctrl* + *V*).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `ThirdPersonCPP` | `Maps` 文件夹中的 `ThirdPersonExampleMap` 资产，并将其命名为 `Level1`。您可以通过选择资产并按
    *Ctrl* + *D* 或通过右键单击资产并选择 **复制**（第三个选项）来完成此操作。在某些情况下，这可能不可用，因此您需要通过复制和粘贴现有水平面（*Ctrl*
    + *C* 和 *Ctrl* + *V*）来完成此操作。
- en: Open the newly created `Level1` map.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的 `Level1` 地图。
- en: 'Delete all the objects that have a mesh inside the map, except for the following:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除地图内所有带有网格的对象，除了以下对象：
- en: The `PlayerStart` object
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerStart` 对象'
- en: The enemy character (note that both characters will look the same)
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人角色（注意两个角色看起来相同）
- en: The `floor` object
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`floor` 对象'
- en: Both `Wall` objects that we created
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建的两个 `Wall` 对象
- en: The `VictoryBox` object
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VictoryBox` 对象'
- en: Keep in mind that assets related to lighting and sound should remain untouched.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，与照明和声音相关的资产应保持不变。
- en: Build the lighting for `Level1` by pressing the **Build** button. This button
    is to the left of the **Play** button, in the **Toolbar** area at the top of the
    editor window.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 **构建** 按钮为 `Level1` 构建照明。此按钮位于 **播放** 按钮左侧，在编辑器窗口顶部的 **工具栏** 区域。
- en: 'At this point, you should have an empty floor with just the objects you’ll
    be needing for this level (the ones mentioned in *Step 4*). Here’s the `Level1`
    map before and after you followed *Steps 4* and *5*, respectively:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，您应该有一个空旷的地面，上面只有您将在这个水平面中需要的对象（在 *步骤 4* 中提到的那些）。以下是您按照 *步骤 4* 和 *步骤 5*
    执行后的 `Level1` 地图：
- en: '![Figure 9.17 – Before deleting the required objects ](img/Figure_9.17_B18531.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 – 删除所需对象之前](img/Figure_9.17_B18531.jpg)'
- en: Figure 9.17 – Before deleting the required objects
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – 删除所需对象之前
- en: 'Once you have deleted the objects, your floor should look as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 删除对象后，您的地面应该看起来如下：
- en: '![Figure 9.18 – After deleting the required objects  ](img/Figure_9.18_B18531.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18 – 删除所需对象之后](img/Figure_9.18_B18531.jpg)'
- en: Figure 9.18 – After deleting the required objects
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 删除所需对象之后
- en: Because building a level, even a simple one, is something that takes a lot of
    steps and instructions, you will simply be shown a few screenshots of a possible
    level and, again, be encouraged to come up with your own.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因为构建一个水平面，即使是简单的水平面，也需要很多步骤和指令，所以您将只看到一些可能的水平面的截图，并且再次鼓励您提出自己的方案。
- en: 'In this case, we have simply used the existing `EnemyCharacter`, `Wall`, and
    `GhostWall` objects and duplicated them several times to create a simple layout
    that the player can traverse from start to finish. We also moved the `VictoryBox`
    object so that it matches the new level’s end location:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是简单地使用了现有的 `EnemyCharacter`、`Wall` 和 `GhostWall` 对象，并将它们复制了几次来创建一个玩家可以从起点到终点穿越的简单布局。我们还移动了
    `VictoryBox` 对象，使其与新水平面的终点位置相匹配：
- en: '![Figure 9.19 – The created level – isometric view ](img/Figure_9.19_B18531.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19 – 创建的水平面 – 等距视图](img/Figure_9.19_B18531.jpg)'
- en: Figure 9.19 – The created level – isometric view
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – 创建的水平面 – 等距视图
- en: 'The level can be seen in a top-down view too, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 水平面也可以从俯视图看到，如下所示：
- en: '![Figure 9.20 – The created level – top-down view with the player character
    marked with an arrow ](img/Figure_9.20_B18531.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.20 – 创建的水平面 – 从上到下的视图，玩家角色用箭头标记](img/Figure_9.20_B18531.jpg)'
- en: Figure 9.20 – The created level – top-down view with the player character marked
    with an arrow
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 – 创建的关卡 – 从上到下的视图，玩家角色用箭头标记
- en: Once you’re happy with the result, this means you have finished your dodgeball
    game and can now ask your friends and family to play it and see what they think.
    Great job – you are one step closer to mastering the art of game development!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对结果满意，这意味着你已经完成了躲避球游戏，现在可以邀请你的朋友和家人来玩，看看他们有什么看法。干得好——你离掌握游戏开发艺术又近了一步！
- en: Extra features
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外功能
- en: 'Before we conclude this chapter, here are some suggestions on what you can
    do next in this dodgeball project:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，这里有一些关于你在躲避球项目中下一步可以做什么的建议：
- en: Make it so that the normal `Wall` class we created in [*Chapter 6*](B18531_06.xhtml#_idTextAnchor134),
    *Setting Up Collision Objects*, doesn’t block the enemy’s line of sight. This
    way, the enemy will always throw dodgeballs at the player, which should still
    be blocked from going through this wall.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们创建的普通 `Wall` 类在 [*第6章*](B18531_06.xhtml#_idTextAnchor134)，*设置碰撞对象* 中不会阻挡敌人的视线。这样，敌人将始终向玩家投掷躲避球，而玩家仍然应该被阻挡，不能穿过这堵墙。
- en: Add a new feature that will allow the player to visualize where the dodgeball
    thrown by the enemy character will impact first, using the concept of **Sweep
    Traces**.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新功能，允许玩家使用 **Sweep Traces** 的概念可视化敌人角色投掷的躲避球首先会击中的位置。
- en: Add a new type of wall that blocks the player character, the enemy character,
    and the dodgeballs, but that also takes damage from dodgeballs and gets destroyed
    when it runs out of health points.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一种新的墙壁类型，它可以阻挡玩家角色、敌人角色和躲避球，但也会受到躲避球的伤害，当健康点数耗尽时会被摧毁。
- en: There is a whole world of possibilities for expanding the scope of this project.
    You are encouraged to use the skills you’ve learned and do further research to
    build new features and add more complexity to your game.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中扩展范围有无限可能。我们鼓励你使用你学到的技能进行进一步研究，以构建新功能并为你的游戏增加更多复杂性。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You have now completed the dodgeball game project. In this chapter, you learned
    how to add polish to your game by playing audio and using Particle Systems. You
    now know how to add 2D and 3D sounds to your game, as well as some of the tools
    at your disposal regarding that. Now, you can try to add even more sound effects
    to your game, such as a special sound effect for when an enemy character sees
    you for the first time (such as in *Metal Gear Solid*), a footstep sound effect,
    or a victory sound effect.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了躲避球游戏项目。在本章中，你学习了如何通过播放音频和使用粒子系统来为你的游戏增添光彩。你现在知道如何为你的游戏添加2D和3D声音，以及一些你可用于此的工具。现在，你可以尝试为你的游戏添加更多的声音效果，例如当敌人角色第一次看到你时的特殊声音效果（例如在
    *Metal Gear Solid* 中），脚步声效果或胜利声效。
- en: You also built a level using all the tools that you have made throughout the
    last few chapters, thus culminating all the logic we have built in this project.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你还使用你在过去几章中制作的所有工具构建了一个关卡，从而总结了我们在本项目中构建的所有逻辑。
- en: 'In the next chapter, we’ll be starting a new project: the `SuperSideScroller`
    game. In that project, you’ll be introduced to such topics as power-ups, collectibles,
    enemy **artificial intelligence** (**AI**), character animation, and much more.
    You will be creating a side-scrolling platform game where you control a character
    that must complete a level, collect gems, and use power-ups to avoid the enemies.
    The two most important topics you will learn about are UE5’s behavior trees and
    Blackboards, which fuel the AI system, and Animation Blueprints, which allow you
    to manage your character’s animations.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始一个新的项目：`SuperSideScroller` 游戏。在那个项目中，你将接触到诸如增强效果、可收集物品、敌人 **人工智能**（**AI**）、角色动画等主题。你将创建一个横版卷轴平台游戏，你将控制一个角色，必须完成关卡、收集宝石并使用增强效果来躲避敌人。你将学习的两个最重要的主题是
    UE5 的行为树和黑板，它们为 AI 系统提供动力，以及动画蓝图，它允许你管理角色的动画。
