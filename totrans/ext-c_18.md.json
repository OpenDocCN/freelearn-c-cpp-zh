["```cpp\n#include <stdio.h>\n...\n#include <semaphore.h>  // For using semaphores\n#define SHARED_MEM_SIZE 4\n// Shared file descriptor used to refer to the\n// shared memory object\nint shared_fd = -1;\n// The pointer to the shared counter\nint32_t* counter = NULL;\n// The pointer to the shared semaphore\nsem_t* semaphore = NULL;\n```", "```cpp\nvoid init_control_mechanism() {\n  semaphore = sem_open(\"/sem0\", O_CREAT | O_EXCL, 0600, 1);\n  if (semaphore == SEM_FAILED) {\n    fprintf(stderr, \"ERROR: Opening the semaphore failed: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n}\nvoid shutdown_control_mechanism() {\n  if (sem_close(semaphore) < 0) {\n    fprintf(stderr, \"ERROR: Closing the semaphore failed: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n  if (sem_unlink(\"/sem0\") < 0) {\n    fprintf(stderr, \"ERROR: Unlinking failed: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n}\nvoid init_shared_resource() {\n  ... as in the example 17.6 ...\n}\nvoid shutdown_shared_resource() {\n  ... as in the example 17.6 ...\n}\n```", "```cpp\nvoid inc_counter() {\n  usleep(1);\n  sem_wait(semaphore); // Return value should be checked.\n  int32_t temp = *counter;\n  usleep(1);\n  temp++;\n  usleep(1);\n  *counter = temp;\n  sem_post(semaphore); // Return value should be checked.\n  usleep(1);\n}\n```", "```cpp\nint main(int argc, char** argv) {\n  // Parent process needs to initialize the shared resource\n  init_shared_resource();\n  // Parent process needs to initialize the control mechanism\n  init_control_mechanism();\n  ... as in the example 17.6 ...\n  // Only parent process needs to shut down the shared resource\n  // and the employed control mechanism\n  if (pid) {\n    shutdown_shared_resource();\n    shutdown_control_mechanism();\n  }\n  return 0;\n}\n```", "```cpp\n$ gcc ExtremeC_examples_chapter18_1.c -lrt -lpthread -o ex18_1.out\n$ ./ex18_1.out\nShared memory is created with fd: 3\nThe memory region is truncated.\nThe child process sees the counter as 1.\nThe parent process sees the counter as 2.\nThe child process finished with status 0.\n$ ./ex18_1.out\nShared memory is created with fd: 3\nThe memory region is truncated.\nThe parent process sees the counter as 1.\nThe child process sees the counter as 2.\nThe child process finished with status 0.\n$\n```", "```cpp\n#include <stdio.h>\n...\n#include <pthread.h> // For using pthread_mutex_* functions\n#define SHARED_MEM_SIZE 4\n// Shared file descriptor used to refer to shared memory object\nint shared_fd = -1;\n// Shared file descriptor used to refer to the mutex's shared\n// memory object\nint mutex_shm_fd = -1;\n// The pointer to the shared counter\nint32_t* counter = NULL;\n// The pointer to shared mutex\npthread_mutex_t* mutex = NULL;\n```", "```cpp\nvoid init_control_mechanism() {\n  // Open the mutex shared memory\n  mutex_shm_fd = shm_open(\"/mutex0\", O_CREAT | O_RDWR, 0600);\n  if (mutex_shm_fd < 0) {\n    fprintf(stderr, \"ERROR: Failed to create shared memory: %s\\n\"\n        , strerror(errno));\n    exit(1);\n  }\n  // Allocate and truncate the mutex's shared memory region\n  if (ftruncate(mutex_shm_fd, sizeof(pthread_mutex_t)) < 0) {\n    fprintf(stderr, \"ERROR: Truncation of mutex failed: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n  // Map the mutex's shared memory\n  void* map = mmap(0, sizeof(pthread_mutex_t),\n          PROT_READ | PROT_WRITE, MAP_SHARED, mutex_shm_fd, 0);\n  if (map == MAP_FAILED) {\n    fprintf(stderr, \"ERROR: Mapping failed: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  mutex = (pthread_mutex_t*)map;\n  // Initialize the mutex object\n  int ret = -1;\n  pthread_mutexattr_t attr;\n  if ((ret = pthread_mutexattr_init(&attr))) {\n    fprintf(stderr, \"ERROR: Failed to init mutex attrs: %s\\n\",\n        strerror(ret));\n    exit(1);\n  }\n  if ((ret = pthread_mutexattr_setpshared(&attr,\n                  PTHREAD_PROCESS_SHARED))) {\n    fprintf(stderr, \"ERROR: Failed to set the mutex attr: %s\\n\",\n        strerror(ret));\n    exit(1);\n  }\n  if ((ret = pthread_mutex_init(mutex, &attr))) {\n    fprintf(stderr, \"ERROR: Initializing the mutex failed: %s\\n\",\n        strerror(ret));\n    exit(1);\n  }\n  if ((ret = pthread_mutexattr_destroy(&attr))) {\n    fprintf(stderr, \"ERROR: Failed to destroy mutex attrs : %s\\n\"\n        , strerror(ret));\n    exit(1);\n  }\n}\n```", "```cpp\nvoid shutdown_control_mechanism() {\n  int ret = -1;\n  if ((ret = pthread_mutex_destroy(mutex))) {\n    fprintf(stderr, \"ERROR: Failed to destroy mutex: %s\\n\",\n        strerror(ret));\n    exit(1);\n  }\n  if (munmap(mutex, sizeof(pthread_mutex_t)) < 0) {\n    fprintf(stderr, \"ERROR: Unmapping the mutex failed: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n  if (close(mutex_shm_fd) < 0) {\n    fprintf(stderr, \"ERROR: Closing the mutex failed: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n  if (shm_unlink(\"/mutex0\") < 0) {\n    fprintf(stderr, \"ERROR: Unlinking the mutex failed: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n}\n```", "```cpp\nvoid init_shared_resource() {\n  ... as in the example 18.1 ...\n}\nvoid shutdown_shared_resource() {\n  ... as in the example 18.1 ...\n}\n```", "```cpp\nvoid inc_counter() {\n  usleep(1);\n  pthread_mutex_lock(mutex); // Should check the return value.\n  int32_t temp = *counter;\n  usleep(1);\n  temp++;\n  usleep(1);\n  *counter = temp;\n  pthread_mutex_unlock(mutex); // Should check the return value.\n  usleep(1);\n}\nint main(int argc, char** argv) {\n  ... as in the example 18.1 ...\n}\n```", "```cpp\n#include <stdio.h>\n...\n#include <pthread.h> // For using pthread_mutex_* functions\ntypedef uint16_t bool_t;\n#define TRUE 1\n#define FALSE 0\n#define MUTEX_SHM_NAME \"/mutex0\"\n#define SHM_NAME \"/shm0\"\n// Shared file descriptor used to refer to the shared memory\n// object containing the cancel flag\nint cancel_flag_shm_fd = -1;\n// A flag which indicates whether the current process owns the\n// shared memory object\nbool_t cancel_flag_shm_owner = FALSE;\n// Shared file descriptor used to refer to the mutex's shared\n// memory object\nint mutex_shm_fd = -1;\n// The shared mutex\npthread_mutex_t* mutex = NULL;\n// A flag which indicates whether the current process owns the\n// shared memory object\nbool_t mutex_owner = FALSE;\n// The pointer to the cancel flag stored in the shared memory\nbool_t* cancel_flag = NULL;\n```", "```cpp\nvoid init_shared_resource() {\n  // Open the shared memory object\n  cancel_flag_shm_fd = shm_open(SHM_NAME, O_RDWR, 0600);\n  if (cancel_flag_shm_fd >= 0) {\n    cancel_flag_shm_owner = FALSE;\n    fprintf(stdout, \"The shared memory object is opened.\\n\");\n  } else if (errno == ENOENT) {\n    fprintf(stderr,\n            \"WARN: The shared memory object doesn't exist.\\n\");\n    fprintf(stdout, \"Creating the shared memory object ...\\n\");\n    cancel_flag_shm_fd = shm_open(SHM_NAME,\n            O_CREAT | O_EXCL | O_RDWR, 0600);\n    if (cancel_flag_shm_fd >= 0) {\n      cancel_flag_shm_owner = TRUE;\n      fprintf(stdout, \"The shared memory object is created.\\n\");\n    } else {\n      fprintf(stderr,\n          \"ERROR: Failed to create shared memory: %s\\n\",\n          strerror(errno));\n      exit(1);\n    }\n  } else {\n      fprintf(stderr,\n          \"ERROR: Failed to create shared memory: %s\\n\",\n          strerror(errno));\n    exit(1);\n  }\n  if (cancel_flag_shm_owner) {\n    // Allocate and truncate the shared memory region\n    if (ftruncate(cancel_flag_shm_fd, sizeof(bool_t)) < 0) {\n      fprintf(stderr, \"ERROR: Truncation failed: %s\\n\",\n              strerror(errno));\n      exit(1);\n    }\n    fprintf(stdout, \"The memory region is truncated.\\n\");\n  }\n  // Map the shared memory and initialize the cancel flag\n  void* map = mmap(0, sizeof(bool_t), PROT_WRITE, MAP_SHARED,\n      cancel_flag_shm_fd, 0);\n  if (map == MAP_FAILED) {\n    fprintf(stderr, \"ERROR: Mapping failed: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  cancel_flag = (bool_t*)map;\n  if (cancel_flag_shm_owner) {\n    *cancel_flag = FALSE;\n  }\n}\n```", "```cpp\nvoid shutdown_shared_resource() {\n  if (munmap(cancel_flag, sizeof(bool_t)) < 0) {\n    fprintf(stderr, \"ERROR: Unmapping failed: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  if (close(cancel_flag_shm_fd) < 0) {\n    fprintf(stderr,\n        \"ERROR: Closing the shared memory fd filed: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n  if (cancel_flag_shm_owner) {\n    sleep(1);\n    if (shm_unlink(SHM_NAME) < 0) {\n      fprintf(stderr,\n          \"ERROR: Unlinking the shared memory failed: %s\\n\",\n          strerror(errno));\n      exit(1);\n    }\n  }\n}\n```", "```cpp\nvoid init_control_mechanism() {\n  // Open the mutex shared memory\n  mutex_shm_fd = shm_open(MUTEX_SHM_NAME, O_RDWR, 0600);\n  if (mutex_shm_fd >= 0) {\n    // The mutex's shared object exists and I'm now the owner.\n    mutex_owner = FALSE;\n    fprintf(stdout,\n            \"The mutex's shared memory object is opened.\\n\");\n  } else if (errno == ENOENT) {\n    fprintf(stderr,\n            \"WARN: Mutex's shared memory doesn't exist.\\n\");\n    fprintf(stdout,\n            \"Creating the mutex's shared memory object ...\\n\");\n    mutex_shm_fd = shm_open(MUTEX_SHM_NAME,\n            O_CREAT | O_EXCL | O_RDWR, 0600);\n    if (mutex_shm_fd >= 0) {\n      mutex_owner = TRUE;\n      fprintf(stdout,\n              \"The mutex's shared memory object is created.\\n\");\n    } else {\n      fprintf(stderr,\n          \"ERROR: Failed to create mutex's shared memory: %s\\n\",\n          strerror(errno));\n      exit(1);\n    }\n  } else {\n    fprintf(stderr,\n        \"ERROR: Failed to create mutex's shared memory: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n  if (mutex_owner) {\n    // Allocate and truncate the mutex's shared memory region\n  }\n  if (mutex_owner) {\n    // Allocate and truncate the mutex's shared memory region\n    if (ftruncate(mutex_shm_fd, sizeof(pthread_mutex_t)) < 0) {\n      fprintf(stderr,\n          \"ERROR: Truncation of the mutex failed: %s\\n\",\n          strerror(errno));\n      exit(1);\n    }\n  }\n  // Map the mutex's shared memory\n  void* map = mmap(0, sizeof(pthread_mutex_t),\n          PROT_READ | PROT_WRITE, MAP_SHARED, mutex_shm_fd, 0);\n  if (map == MAP_FAILED) {\n    fprintf(stderr, \"ERROR: Mapping failed: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  mutex = (pthread_mutex_t*)map;\n  if (mutex_owner) {\n    int ret = -1;\n    pthread_mutexattr_t attr;\n    if ((ret = pthread_mutexattr_init(&attr))) {\n      fprintf(stderr,\n          \"ERROR: Initializing mutex attributes failed: %s\\n\",\n          strerror(ret));\n      exit(1);\n    }\n    if ((ret = pthread_mutexattr_setpshared(&attr,\n                    PTHREAD_PROCESS_SHARED))) {\n      fprintf(stderr,\n          \"ERROR: Setting the mutex attribute failed: %s\\n\",\n          strerror(ret));\n      exit(1);\n    }\n    if ((ret = pthread_mutex_init(mutex, &attr))) {\n      fprintf(stderr,\n          \"ERROR: Initializing the mutex failed: %s\\n\",\n          strerror(ret));\n      exit(1);\n    }\n    if ((ret = pthread_mutexattr_destroy(&attr))) {\n      fprintf(stderr,\n          \"ERROR: Destruction of mutex attributes failed: %s\\n\",\n          strerror(ret));\n      exit(1);\n    }\n  }\n}\n```", "```cpp\nvoid shutdown_control_mechanism() {\n  sleep(1);\n  if (mutex_owner) {\n    int ret = -1;\n    if ((ret = pthread_mutex_destroy(mutex))) {\n      fprintf(stderr,\n          \"WARN: Destruction of the mutex failed: %s\\n\",\n          strerror(ret));\n    }\n  }\n  if (munmap(mutex, sizeof(pthread_mutex_t)) < 0) {\n    fprintf(stderr, \"ERROR: Unmapping the mutex failed: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n  if (close(mutex_shm_fd) < 0) {\n    fprintf(stderr, \"ERROR: Closing the mutex failed: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n  if (mutex_owner) {\n    if (shm_unlink(MUTEX_SHM_NAME) < 0) {\n      fprintf(stderr, \"ERROR: Unlinking the mutex failed: %s\\n\",\n          strerror(errno));\n      exit(1);\n    }\n  }\n}\n```", "```cpp\nbool_t is_canceled() {\n  pthread_mutex_lock(mutex); // Should check the return value\n  bool_t temp = *cancel_flag;\n  pthread_mutex_unlock(mutex); // Should check the return value\n  return temp;\n}\nvoid cancel() {\n  pthread_mutex_lock(mutex); // Should check the return value\n  *cancel_flag = TRUE;\n  pthread_mutex_unlock(mutex); // Should check the return value\n}\n```", "```cpp\nvoid sigint_handler(int signo) {\n  fprintf(stdout, \"\\nHandling INT signal: %d ...\\n\", signo);\n  cancel();\n}\nint main(int argc, char** argv) {\n  signal(SIGINT, sigint_handler);\n  // Parent process needs to initialize the shared resource\n  init_shared_resource();\n  // Parent process needs to initialize the control mechanism\n  init_control_mechanism();\n  while(!is_canceled()) {\n    fprintf(stdout, \"Working ...\\n\");\n    sleep(1);\n  }\n  fprintf(stdout, \"Cancel signal is received.\\n\");\n  shutdown_shared_resource();\n  shutdown_control_mechanism();\n  return 0;\n}\n```", "```cpp\n$ gcc ExtremeC_examples_chapter18_3.c -lpthread -lrt -o ex18_3.out\n$ ./ex18_3.out\nWARN: The shared memory object doesn't exist.\nCreating a shared memory object ...\nThe shared memory object is created.\nThe memory region is truncated.\nWARN: Mutex's shared memory object doesn't exist.\nCreating the mutex's shared memory object ...\nThe mutex's shared memory object is created.\nWorking ...\nWorking ...\nWorking ...\n```", "```cpp\n$ ./ex18_3.out\nThe shared memory object is opened.\nThe mutex's shared memory object is opened.\nWorking ...\nWorking ...\nWorking ...\n```", "```cpp\n...\nWorking ...\nWorking ...\n^C\nHandling INT signal: 2 ...\nCancel signal is received.\n$\n```", "```cpp\n...\nWorking ...\nWorking ...\nWorking ...\nCancel signal is received.\n$\n```", "```cpp\nstruct shared_mem_t;\ntypedef int32_t bool_t; \nstruct shared_mem_t* shared_mem_new();\nvoid shared_mem_delete(struct shared_mem_t* obj);\nvoid shared_mem_ctor(struct shared_mem_t* obj,\n                     const char* name,\n                     size_t size);\nvoid shared_mem_dtor(struct shared_mem_t* obj);\nchar* shared_mem_getptr(struct shared_mem_t* obj);\nbool_t shared_mem_isowner(struct shared_mem_t* obj);\nvoid shared_mem_setowner(struct shared_mem_t* obj, bool_t is_owner);\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#define TRUE 1\n#define FALSE 0\ntypedef int32_t bool_t;\nbool_t owner_process_set = FALSE;\nbool_t owner_process = FALSE;\ntypedef struct {\n  char* name;\n  int shm_fd;\n  void* map_ptr;\n  char* ptr;\n  size_t size;\n} shared_mem_t;\nshared_mem_t* shared_mem_new() {\n  return (shared_mem_t*)malloc(sizeof(shared_mem_t));\n}\nvoid shared_mem_delete(shared_mem_t* obj) {\n  free(obj->name);\n  free(obj);\n}\nvoid shared_mem_ctor(shared_mem_t* obj, const char* name,\n        size_t size) {\n  obj->size = size;\n  obj->name = (char*)malloc(strlen(name) + 1);\n  strcpy(obj->name, name);\n  obj->shm_fd = shm_open(obj->name, O_RDWR, 0600);\n  if (obj->shm_fd >= 0) {\n    if (!owner_process_set) {\n      owner_process = FALSE;\n      owner_process_set = TRUE;\n    }\n    printf(\"The shared memory %s is opened.\\n\", obj->name);\n  } else if (errno == ENOENT) {\n    printf(\"WARN: The shared memory %s does not exist.\\n\",\n            obj->name);\n    obj->shm_fd = shm_open(obj->name,\n            O_CREAT | O_RDWR, 0600);\n    if (obj->shm_fd >= 0) {\n      if (!owner_process_set) {\n        owner_process = TRUE;\n        owner_process_set = TRUE;\n      }\n      printf(\"The shared memory %s is created and opened.\\n\",\n              obj->name);\n      if (ftruncate(obj->shm_fd, obj->size) < 0) {\n        fprintf(stderr, \"ERROR(%s): Truncation failed: %s\\n\",\n            obj->name, strerror(errno));\n        exit(1);\n      }\n    } else {\n      fprintf(stderr,\n          \"ERROR(%s): Failed to create shared memory: %s\\n\",\n          obj->name, strerror(errno));\n      exit(1);\n    }\n  } else {\n      fprintf(stderr,\n          \"ERROR(%s): Failed to create shared memory: %s\\n\",\n          obj->name, strerror(errno));\n    exit(1);\n  }\n  obj->map_ptr = mmap(0, obj->size, PROT_READ | PROT_WRITE,\n      MAP_SHARED, obj->shm_fd, 0);\n  if (obj->map_ptr == MAP_FAILED) {\n    fprintf(stderr, \"ERROR(%s): Mapping failed: %s\\n\",\n        name, strerror(errno));\n    exit(1);\n  }\n  obj->ptr = (char*)obj->map_ptr;\n}\nvoid shared_mem_dtor(shared_mem_t* obj) {\n  if (munmap(obj->map_ptr, obj->size) < 0) {\n    fprintf(stderr, \"ERROR(%s): Unmapping failed: %s\\n\",\n        obj->name, strerror(errno));\n    exit(1);\n  }\n  printf(\"The shared memory %s is unmapped.\\n\", obj->name);\n  if (close(obj->shm_fd) < 0) {\n    fprintf(stderr,\n        \"ERROR(%s): Closing the shared memory fd failed: %s\\n\",\n        obj->name, strerror(errno));\n    exit(1);\n  }\n  printf(\"The shared memory %s is closed.\\n\", obj->name);\n  if (owner_process) {\n    if (shm_unlink(obj->name) < 0) {\n      fprintf(stderr,\n          \"ERROR(%s): Unlinking the shared memory failed: %s\\n\",\n          obj->name, strerror(errno));\n      exit(1);\n    }\n    printf(\"The shared memory %s is deleted.\\n\", obj->name);\n  }\n}\nchar* shared_mem_getptr(shared_mem_t* obj) {\n  return obj->ptr;\n}\nbool_t shared_mem_isowner(shared_mem_t* obj) {\n  return owner_process;\n}\nvoid shared_mem_setowner(shared_mem_t* obj, bool_t is_owner) {\n    owner_process = is_owner;\n}\n```", "```cpp\nstruct shared_int32_t;\nstruct shared_int32_t* shared_int32_new();\nvoid shared_int32_delete(struct shared_int32_t* obj);\nvoid shared_int32_ctor(struct shared_int32_t* obj,\n                       const char* name);\nvoid shared_int32_dtor(struct shared_int32_t* obj);\nvoid shared_int32_setvalue(struct shared_int32_t* obj,\n                           int32_t value);\nvoid shared_int32_setvalue_ifowner(struct shared_int32_t* obj,\n                                   int32_t value);\nint32_t shared_int32_getvalue(struct shared_int32_t* obj);\n```", "```cpp\n#include \"ExtremeC_examples_chapter18_4_shared_mem.h\"\ntypedef struct {\n  struct shared_mem_t* shm;\n  int32_t* ptr;\n} shared_int32_t;\nshared_int32_t* shared_int32_new(const char* name) {\n  shared_int32_t* obj =\n      (shared_int32_t*)malloc(sizeof(shared_int32_t));\n  obj->shm = shared_mem_new();\n  return obj;\n}\nvoid shared_int32_delete(shared_int32_t* obj) {\n  shared_mem_delete(obj->shm);\n  free(obj);\n}\nvoid shared_int32_ctor(shared_int32_t* obj, const char* name) {\n  shared_mem_ctor(obj->shm, name, sizeof(int32_t));\n  obj->ptr = (int32_t*)shared_mem_getptr(obj->shm);\n}\nvoid shared_int32_dtor(shared_int32_t* obj) {\n  shared_mem_dtor(obj->shm);\n}\nvoid shared_int32_setvalue(shared_int32_t* obj, int32_t value) {\n  *(obj->ptr) = value;\n}\nvoid shared_int32_setvalue_ifowner(shared_int32_t* obj,\n                                   int32_t value) {\n  if (shared_mem_isowner(obj->shm)) {\n    *(obj->ptr) = value;\n  }\n}\nint32_t shared_int32_getvalue(shared_int32_t* obj) {\n  return *(obj->ptr);\n}\n```", "```cpp\n#include <pthread.h>\nstruct shared_mutex_t;\nstruct shared_mutex_t* shared_mutex_new();\nvoid shared_mutex_delete(struct shared_mutex_t* obj);\nvoid shared_mutex_ctor(struct shared_mutex_t* obj,\n                       const char* name);\nvoid shared_mutex_dtor(struct shared_mutex_t* obj);\npthread_mutex_t* shared_mutex_getptr(struct shared_mutex_t* obj);\nvoid shared_mutex_lock(struct shared_mutex_t* obj);\nvoid shared_mutex_unlock(struct shared_mutex_t* obj);\n#if !defined(__APPLE__)\nvoid shared_mutex_make_consistent(struct shared_mutex_t* obj);\n#endif\n```", "```cpp\n#include \"ExtremeC_examples_chapter18_4_shared_mem.h\"\ntypedef struct {\n  struct shared_mem_t* shm;\n  pthread_mutex_t* ptr;\n} shared_mutex_t;\nshared_mutex_t* shared_mutex_new() {\n  shared_mutex_t* obj =\n      (shared_mutex_t*)malloc(sizeof(shared_mutex_t));\n  obj->shm = shared_mem_new();\n  return obj;\n}\nvoid shared_mutex_delete(shared_mutex_t* obj) {\n  shared_mem_delete(obj->shm);\n  free(obj);\n}\nvoid shared_mutex_ctor(shared_mutex_t* obj, const char* name) {\n  shared_mem_ctor(obj->shm, name, sizeof(pthread_mutex_t));\n  obj->ptr = (pthread_mutex_t*)shared_mem_getptr(obj->shm);\n  if (shared_mem_isowner(obj->shm)) {\n    pthread_mutexattr_t mutex_attr;\n    int ret = -1;\n    if ((ret = pthread_mutexattr_init(&mutex_attr))) {\n      fprintf(stderr,\n          \"ERROR(%s): Initializing mutex attrs failed: %s\\n\",\n          name, strerror(ret));\n      exit(1);\n    }\n#if !defined(__APPLE__)\n    if ((ret = pthread_mutexattr_setrobust(&mutex_attr,\n                    PTHREAD_MUTEX_ROBUST))) {\n      fprintf(stderr,\n          \"ERROR(%s): Setting the mutex as robust failed: %s\\n\",\n          name, strerror(ret));\n      exit(1);\n    }\n#endif\n    if ((ret = pthread_mutexattr_setpshared(&mutex_attr,\n                    PTHREAD_PROCESS_SHARED))) {\n      fprintf(stderr,\n          \"ERROR(%s): Failed to set as process-shared: %s\\n\",\n          name, strerror(ret));\n      exit(1);\n    }\n    if ((ret = pthread_mutex_init(obj->ptr, &mutex_attr))) {\n      fprintf(stderr,\n          \"ERROR(%s): Initializing the mutex failed: %s\\n\",\n          name, strerror(ret));\n      exit(1);\n    }\n    if ((ret = pthread_mutexattr_destroy(&mutex_attr))) {\n      fprintf(stderr,\n          \"ERROR(%s): Destruction of mutex attrs failed: %s\\n\",\n          name, strerror(ret));\n      exit(1);\n    }\n  }\n}\nvoid shared_mutex_dtor(shared_mutex_t* obj) {\n  if (shared_mem_isowner(obj->shm)) {\n    int ret = -1;\n    if ((ret = pthread_mutex_destroy(obj->ptr))) {\n      fprintf(stderr,\n          \"WARN: Destruction of the mutex failed: %s\\n\",\n          strerror(ret));\n    }\n  }\n  shared_mem_dtor(obj->shm);\n}\npthread_mutex_t* shared_mutex_getptr(shared_mutex_t* obj) {\n  return obj->ptr;\n}\n#if !defined(__APPLE__)\nvoid shared_mutex_make_consistent(shared_mutex_t* obj) {\n  int ret = -1;\n  if ((ret = pthread_mutex_consistent(obj->ptr))) {\n    fprintf(stderr,\n        \"ERROR: Making the mutex consistent failed: %s\\n\",\n        strerror(ret));\n    exit(1);\n  }\n}\n#endif\nvoid shared_mutex_lock(shared_mutex_t* obj) {\n  int ret = -1;\n  if ((ret = pthread_mutex_lock(obj->ptr))) {\n#if !defined(__APPLE__)\n    if (ret == EOWNERDEAD) {\n        fprintf(stderr,\n                \"WARN: The owner of the mutex is dead ...\\n\");\n        shared_mutex_make_consistent(obj);\n        fprintf(stdout, \"INFO: I'm the new owner!\\n\");\n        shared_mem_setowner(obj->shm, TRUE);\n        return;\n    }\n#endif\n    fprintf(stderr, \"ERROR: Locking the mutex failed: %s\\n\",\n        strerror(ret));\n    exit(1);\n  }\n}\nvoid shared_mutex_unlock(shared_mutex_t* obj) {\n  int ret = -1;\n  if ((ret = pthread_mutex_unlock(obj->ptr))) {\n    fprintf(stderr, \"ERROR: Unlocking the mutex failed: %s\\n\",\n        strerror(ret));\n    exit(1);\n  }\n}\n```", "```cpp\nstruct shared_cond_t;\nstruct shared_mutex_t;\nstruct shared_cond_t* shared_cond_new();\nvoid shared_cond_delete(struct shared_cond_t* obj);\nvoid shared_cond_ctor(struct shared_cond_t* obj,\n                      const char* name);\nvoid shared_cond_dtor(struct shared_cond_t* obj);\nvoid shared_cond_wait(struct shared_cond_t* obj,\n                      struct shared_mutex_t* mutex);\nvoid shared_cond_timedwait(struct shared_cond_t* obj,\n                           struct shared_mutex_t* mutex,\n                           long int time_nanosec);\nvoid shared_cond_broadcast(struct shared_cond_t* obj);\n```", "```cpp\n#include \"ExtremeC_examples_chapter18_4_shared_mem.h\"\n#include \"ExtremeC_examples_chapter18_4_shared_mutex.h\"\ntypedef struct {\n  struct shared_mem_t* shm;\n  pthread_cond_t* ptr;\n} shared_cond_t;\nshared_cond_t* shared_cond_new() {\n  shared_cond_t* obj =\n      (shared_cond_t*)malloc(sizeof(shared_cond_t));\n  obj->shm = shared_mem_new();\n  return obj;\n}\nvoid shared_cond_delete(shared_cond_t* obj) {\n  shared_mem_delete(obj->shm);\n  free(obj);\n}\nvoid shared_cond_ctor(shared_cond_t* obj, const char* name) {\n  shared_mem_ctor(obj->shm, name, sizeof(pthread_cond_t));\n  obj->ptr = (pthread_cond_t*)shared_mem_getptr(obj->shm);\n  if (shared_mem_isowner(obj->shm)) {\n    pthread_condattr_t cond_attr;\n    int ret = -1;\n    if ((ret = pthread_condattr_init(&cond_attr))) {\n      fprintf(stderr,\n          \"ERROR(%s): Initializing cv attrs failed: %s\\n\",\n          name, strerror(ret));\n      exit(1);\n    }\n    if ((ret = pthread_condattr_setpshared(&cond_attr,\n                    PTHREAD_PROCESS_SHARED))) {\n      fprintf(stderr,\n          \"ERROR(%s): Setting as process shared failed: %s\\n\",\n          name, strerror(ret));\n      exit(1);\n    }\n    if ((ret = pthread_cond_init(obj->ptr, &cond_attr))) {\n      fprintf(stderr,\n          \"ERROR(%s): Initializing the cv failed: %s\\n\",\n          name, strerror(ret));\n      exit(1);\n    }\n    if ((ret = pthread_condattr_destroy(&cond_attr))) {\n      fprintf(stderr,\n          \"ERROR(%s): Destruction of cond attrs failed: %s\\n\",\n          name, strerror(ret));\n      exit(1);\n    }\n  }\n}\nvoid shared_cond_dtor(shared_cond_t* obj) {\n  if (shared_mem_isowner(obj->shm)) {\n    int ret = -1;\n    if ((ret = pthread_cond_destroy(obj->ptr))) {\n      fprintf(stderr, \"WARN: Destruction of the cv failed: %s\\n\",\n          strerror(ret));\n    }\n  }\n  shared_mem_dtor(obj->shm);\n}\nvoid shared_cond_wait(shared_cond_t* obj,\n                      struct shared_mutex_t* mutex) {\n  int ret = -1;\n  if ((ret = pthread_cond_wait(obj->ptr,\n                  shared_mutex_getptr(mutex)))) {\n    fprintf(stderr, \"ERROR: Waiting on the cv failed: %s\\n\",\n            strerror(ret));\n    exit(1);\n  }\n}\nvoid shared_cond_timedwait(shared_cond_t* obj,\n                           struct shared_mutex_t* mutex,\n                           long int time_nanosec) {\n  int ret = -1;\n  struct timespec ts;\n  ts.tv_sec = ts.tv_nsec = 0;\n  if ((ret = clock_gettime(CLOCK_REALTIME, &ts))) {\n    fprintf(stderr,\n            \"ERROR: Failed at reading current time: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  ts.tv_sec += (int)(time_nanosec / (1000L * 1000 * 1000));\n  ts.tv_nsec += time_nanosec % (1000L * 1000 * 1000);\n  if ((ret = pthread_cond_timedwait(obj->ptr,\n                  shared_mutex_getptr(mutex), &ts))) {\n#if !defined(__APPLE__)\n    if (ret == EOWNERDEAD) {\n      fprintf(stderr,\n              \"WARN: The owner of the cv's mutex is dead ...\\n\");\n      shared_mutex_make_consistent(mutex);\n      fprintf(stdout, \"INFO: I'm the new owner!\\n\");\n      shared_mem_setowner(obj->shm, TRUE);\n      return;\n    } else if (ret == ETIMEDOUT) {\n#else\n    if (ret == ETIMEDOUT) {\n#endif\n      return;\n    }\n    fprintf(stderr, \"ERROR: Waiting on the cv failed: %s\\n\",\n            strerror(ret));\n    exit(1);\n  }\n}\nvoid shared_cond_broadcast(shared_cond_t* obj) {\n  int ret = -1;\n  if ((ret = pthread_cond_broadcast(obj->ptr))) {\n    fprintf(stderr, \"ERROR: Broadcasting on the cv failed: %s\\n\",\n        strerror(ret));\n    exit(1);\n  }\n}\n```", "```cpp\n#include \"ExtremeC_examples_chapter18_4_shared_int32.h\"\n#include \"ExtremeC_examples_chapter18_4_shared_mutex.h\"\n#include \"ExtremeC_examples_chapter18_4_shared_cond.h\"\nint int_received = 0;\nstruct shared_cond_t* cond = NULL;\nstruct shared_mutex_t* mutex = NULL;\nvoid sigint_handler(int signo) {\n  fprintf(stdout, \"\\nHandling INT signal: %d ...\\n\", signo);\n  int_received = 1;\n}\nint main(int argc, char** argv) {\n  signal(SIGINT, sigint_handler);\n  if (argc < 2) {\n    fprintf(stderr,\n            \"ERROR: You have to provide the process number.\\n\");\n    exit(1);\n  }\n  int my_number = atol(argv[1]);\n  printf(\"My number is %d!\\n\", my_number);\n  struct shared_int32_t* counter = shared_int32_new();\n  shared_int32_ctor(counter, \"/counter0\");\n  shared_int32_setvalue_ifowner(counter, 1);\n  mutex = shared_mutex_new();\n  shared_mutex_ctor(mutex, \"/mutex0\");\n  cond = shared_cond_new();\n  shared_cond_ctor(cond, \"/cond0\");\n  shared_mutex_lock(mutex);\n  while (shared_int32_getvalue(counter) < my_number) {\n    if (int_received) {\n        break;\n    }\n    printf(\"Waiting for the signal, just for 5 seconds ...\\n\");\n    shared_cond_timedwait(cond, mutex, 5L * 1000 * 1000 * 1000);\n    if (int_received) {\n        break;\n    }\n    printf(\"Checking condition ...\\n\");\n  }\n  if (int_received) {\n    printf(\"Exiting ...\\n\");\n    shared_mutex_unlock(mutex);\n    goto destroy;\n  }\n  shared_int32_setvalue(counter, my_number + 1);\n  printf(\"My turn! %d ...\\n\", my_number);\n  shared_mutex_unlock(mutex);\n  sleep(1);\n  // NOTE: The broadcasting can come after unlocking the mutex.\n  shared_cond_broadcast(cond);\ndestroy:\n  shared_cond_dtor(cond);\n  shared_cond_delete(cond);\n  shared_mutex_dtor(mutex);\n  shared_mutex_delete(mutex);\n  shared_int32_dtor(counter);\n  shared_int32_delete(counter);\n  return 0;\n}\n```", "```cpp\n$ gcc -c ExtremeC_examples_chapter18_4_shared_mem.c -o shared_mem.o\n$ gcc -c ExtremeC_examples_chapter18_4_shared_int32.c -o shared_int32.o\n$ gcc -c ExtremeC_examples_chapter18_4_shared_mutex.c -o shared_mutex.o\n$ gcc -c ExtremeC_examples_chapter18_4_shared_cond.c -o shared_cond.o\n$ gcc -c ExtremeC_examples_chapter18_4_main.c -o main.o\n$ gcc shared_mem.o shared_int32.o shared_mutex.o shared_cond.o \\  main.o -lpthread -lrt -o ex18_4.out\n$\n```", "```cpp\n$ ./ex18_4.out 3\nMy number is 3!\nWARN: The shared memory /counter0 does not exist.\nThe shared memory /counter0 is created and opened.\nWARN: The shared memory /mutex0 does not exist.\nThe shared memory /mutex0 is created and opened.\nWARN: The shared memory /cond0 does not exist.\nThe shared memory /cond0 is created and opened.\nWaiting for the signal, just for 5 seconds ...\nChecking condition ...\nWaiting for the signal, just for 5 seconds ...\nChecking condition ...\nWaiting for the signal, just for 5 seconds ...\n```", "```cpp\n$ ./ex18_4.out 2\nMy number is 2!\nThe shared memory /counter0 is opened.\nThe shared memory /mutex0 is opened.\nThe shared memory /cond0 is opened.\nWaiting for the signal, just for 5 seconds ...\nChecking condition ...\nWaiting for the signal, just for 5 seconds ...\n```", "```cpp\n$ ./ex18_4.out 1\nMy number is 1!\nThe shared memory /counter0 is opened.\nThe shared memory /mutex0 is opened.\nThe shared memory /cond0 is opened.\nMy turn! 1 ...\nThe shared memory /cond0 is unmapped.\nThe shared memory /cond0 is closed.\nThe shared memory /mutex0 is unmapped.\nThe shared memory /mutex0 is closed.\nThe shared memory /counter0 is unmapped.\nThe shared memory /counter0 is closed.\n$\n```", "```cpp\n...\nWaiting for the signal, just for 5 seconds ...\nChecking condition ...\nMy turn! 2 ...\nThe shared memory /cond0 is unmapped.\nThe shared memory /cond0 is closed.\nThe shared memory /mutex0 is unmapped.\nThe shared memory /mutex0 is closed.\nThe shared memory /counter0 is unmapped.\nThe shared memory /counter0 is closed.\n$\n```", "```cpp\n...\nWaiting for the signal, just for 5 seconds ...\nChecking condition ...\nMy turn! 3 ...\nThe shared memory /cond0 is unmapped.\nThe shared memory /cond0 is closed.\nThe shared memory /cond0 is deleted.\nThe shared memory /mutex0 is unmapped.\nThe shared memory /mutex0 is closed.\nThe shared memory /mutex0 is deleted.\nThe shared memory /counter0 is unmapped.\nThe shared memory /counter0 is closed.\nThe shared memory /counter0 is deleted.\n$\n```"]