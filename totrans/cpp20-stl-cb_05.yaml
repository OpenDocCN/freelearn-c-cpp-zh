- en: '*Chapter 5*: Lambda Expressions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++11 standard introduced the *lambda expression* (sometimes called the
    *lambda function*, or just *lambda*). This feature allows an anonymous function
    to be used in the context of an expression. Lambdas may be used in function calls,
    containers, variables, and other expression contexts. It may sound innocuous,
    but it's remarkably useful.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a brief review of lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lambda is essentially an anonymous function as a literal expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `la` may now be used as if it were a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be passed to another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be passed to another lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it can be passed anonymously (as a literal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *closure* is often applied to any anonymous function. Strictly speaking,
    a closure is a function that allows the use of symbols outside its own lexical
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed the square brackets in the definition of a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The square brackets are used to specify a list of *captures*. Captures are
    outside variables that are accessible from within the scope of the lambda body.
    If I try to use an outside variable without listing it as a capture, I''ll get
    a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When I try to compile this with GCC, I get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is because the body of the lambda has its own lexical scope and the `greeting`
    variable is outside of that scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can specify the `greeting` variable in a capture. This allows the variable
    into the scope of the lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it compiles and runs as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This ability to capture variables outside its own scope is what makes a lambda
    a *closure*. People use the term in different ways, and that's fine, so long as
    we can understand each other. Still, it's good to know what the term means.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions allow us to write good, clean generic code. They allow the
    use of *functional programming* patterns, where we can use lambdas as functional
    parameters to algorithms and even other lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the use of lambdas with the STL, in the following
    recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Use lambdas for scoped reusable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lambdas as predicates with the algorithm library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::function` as a polymorphic wrapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenate lambdas with recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine predicates with logical conjunction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call multiple lambdas with the same input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use mapped lambdas for a jump table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap05](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap05).
  prefs: []
  type: TYPE_NORMAL
- en: Use lambdas for scoped reusable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions can be defined and stored for later use. They can be passed
    as parameters, stored in data structures, and called in different contexts with
    different parameters. They are as flexible as functions, but with the mobility
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a simple program that we''ll use to test various configurations
    of lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll first define a `main()` function and use it to experiment with lambdas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main()` function, we''ll declare a couple of lambdas. The basic
    definition of a lambda requires a pair of square brackets and a block of code
    in curly brackets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the first example `one` includes parentheses after the square brackets,
    and the second example `two` does not. The empty parameter parentheses are commonly
    included, but are not always required. The return type is inferred by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can call these functions with `cout`, or with `format`, or in any context
    that will take a C-string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In many cases, the compiler can determine the return type from *automatic type
    deduction*. Otherwise, you can specify the return type with the `->` operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lambdas use the *trailing return type* syntax. This consists of the `->` operator
    followed by the type specification. If the return type is not specified, it is
    considered `auto`. If you use a trailing return type, *the parameter parentheses
    are required*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a lambda to print out the values from our other lambdas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `p()` lambda expects a lambda (or function) as its parameter `v`, and calls
    it in its function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `auto` type parameter makes this lambda an *abbreviated template*. Before
    C++20, this was the only way to template a lambda. Beginning with C++20, you may
    specify template parameters (without the `template` keyword) after the capture
    brackets. This is the equivalent with template parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The abbreviated `auto` version is simpler and more common. It works well for
    most purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can pass an anonymous lambda in the function call:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to pass parameters to an anonymous lambda, we can put them in parentheses
    after the lambda expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function parameters, `47` and `73`, are passed to the anonymous lambda in
    the parentheses after the function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access variables from the outside scope of the lambda by including
    them as *captures* in the square brackets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or you can capture them by reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to modify a captured variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also define a local capture variable that maintains its state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `mutable` specifier allows the lambda to modify its captures. Lambdas default
    to `const`-qualified.
  prefs: []
  type: TYPE_NORMAL
- en: As with the trailing return type, any *specifier* requires the parameter parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda supports two types of *default capture*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If I try to compile this code, I get an error that includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'One type of default capture is indicated by an equal sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will capture all the symbols in the lambda's scope. The equal sign performs
    *capture by copy*. It will capture a copy of the objects as if they were copied
    with an assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other default capture uses an ampersand for *capture by reference*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is a default capture that captures by reference.
  prefs: []
  type: TYPE_NORMAL
- en: The default captures only use symbols when they are referenced, so they're not
    as messy as they may look. That said, I recommend explicit captures where possible
    as they generally improve readability.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax of a lambda expression is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Syntax of the lambda expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Syntax of the lambda expression
  prefs: []
  type: TYPE_NORMAL
- en: 'The only required parts of a lambda expression are the capture list and the
    body, which may be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is the minimal lambda expression. It captures nothing and does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider each of the parts.
  prefs: []
  type: TYPE_NORMAL
- en: Capture-list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *capture-list* specifies what we capture, if anything. It cannot be omitted,
    but it may be empty. We can use `[=]` to capture all variables *by copy* or `[&]`
    to capture all variables *by reference*, within the scope of the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may capture individual variables by listing them in the brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The specified captures default to copy. You may capture by reference with the
    reference operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When you capture by reference, you may modify the referenced variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You cannot capture object members directly. You may capture `this` or `*this`
    to dereference class members.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with a function, parameters are specified in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no parameters, specifiers, or trailing return type, the parentheses
    are optional. A specifier or trailing return type makes the parentheses required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The mutable modifier (optional)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A lambda expression defaults to `const`-qualified unless you specify the `mutable`
    modifier. This allows it to be used in `const` context, but it also means that
    it cannot modify any of its captured-by-copy variables. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will fail to compile with an error message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `mutable` modifier, the lambda is no longer `const`-qualified and
    the captured variable may be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The constexpr specifier (optional)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may use `constexpr` to explicitly specify that you want your lambda to be
    considered a *constant expression*. This means that it may be evaluated at compile
    time. If the lambda meets the requirements, it may be considered `constexpr` even
    without the specifier.
  prefs: []
  type: TYPE_NORMAL
- en: The exception attribute (optional)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the `noexcept` specifier to declare that your lambda does not throw
    any exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The trailing return type (optional)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the lambda return type is deduced from the `return` statement,
    as if it were an `auto` return type. You may optionally specify a *trailing return
    type* with the `->` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The parameter parentheses are required if you use any of the optional specifiers
    or the trailing return type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Some compilers, including GCC, allow empty parameter parentheses to be omitted
    even when there's a specifier or trailing return type. This is not correct. According
    to the specification, the parameters, specifiers, and trailing return type are
    all part of the *lambda-declarator* and the parentheses are required when any
    part of it is included. This may change in a future version of C++.
  prefs: []
  type: TYPE_NORMAL
- en: Use lambdas as predicates with the algorithm library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some functions in the `algorithm` library require the use of a *predicate* function.
    A predicate is a function (or functor or lambda) that tests a condition and returns
    a Boolean `true`/`false` response.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will experiment with the `count_if()` algorithm using different
    types of predicates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a function for use as a predicate. A predicate takes a
    certain number of arguments and returns a `bool`. A predicate for `count_if()`
    takes one argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This predicate checks whether an `int` value is divisible by 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main()`, we''ll define a vector of `int` values, and use it to test our
    predicate function with `count_if()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '(The 5 divisible numbers are: 4, 4, 8, 12, and 20.)'
  prefs: []
  type: TYPE_NORMAL
- en: The `count_if()` algorithm uses the predicate function to determine which elements
    of the sequence to count. It calls the predicate with each element as a parameter,
    and only counts the element if the predicate returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we used a function as a predicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also use a *functor* as a predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only change here is that we need to use an *instance* of the class as the
    predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of a functor is that it can carry context and access class and
    instance variables. This was the common way to use predicates before C++11 introduced
    lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a lambda expression, we have the best of both worlds: the simplicity of
    a function and the power of a functor. We can use a lambda as a variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or we can use an anonymous lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take advantage of the lambda capture by wrapping the lambda in a function,
    and using that function context to produce the same lambda with different parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function returns a predicate lambda with the divisor from the capture context.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use that predicate with `count_if()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Each call to `is_div_by()` returns a predicate with a different divisor from
    `i`. Now we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type of a function pointer is represented as a pointer followed by the
    function call `()` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can declare a function pointer and initialize it with the name of an existing
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once declared, a function pointer may be dereferenced and used as if it were
    the function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A lambda expression has the same type as a function pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that wherever you use a function pointer with a certain signature,
    you may also use a lambda with the same signature. This allows function pointers,
    functors, and lambdas to work interchangeably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Because of this interchangeability, an algorithm such as `count_if()` accepts
    a function, functor, or lambda where it expects a predicate with a particular
    function signature.
  prefs: []
  type: TYPE_NORMAL
- en: This applies to any algorithm that uses a predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Use std::function as a polymorphic wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class template `std::function` is a thin polymorphic wrapper for functions.
    It can store, copy, and invoke any function, lambda expression, or other function
    objects. It can be useful in places where you would like to store a reference
    to a function or lambda. Using `std::function` allows you to store functions and
    lambdas with different signatures in the same container, and it maintains the
    context of lambda captures.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses the `std::function` class to store different specializations
    of a lambda in a `vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe is contained in the `main()` function, where we start by declaring
    three containers of different types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These containers, `deque`, `list`, and `vector`, will be referenced by a *template*
    lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll declare a simple `print_c` lambda function for printing out the containers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we declare a lambda that returns an *anonymous* lambda:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `push_c` lambda takes a reference to a container, which is *captured* by
    the anonymous lambda. The anonymous lambda calls the `push_back()` member on the
    captured container. The return value from `push_c` is the anonymous lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we declare a `vector` of `std::function` elements, and populate it with
    three instances of `push_c()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each of the elements in the initializer list is a function call to the `push_c`
    lambda. `push_c` returns an instance of the anonymous lambda, which gets stored
    in the `vector` via the `function` wrapper. The `push_c` lambda is called with
    the three containers, `d`, `l`, and `v`. The containers are passed as *captures*
    with the anonymous lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we loop through the `consumers` vector, and call each of the lambda elements
    10 times, populating the three containers with integers 0–9 in each container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now our three containers, the `deque`, `list`, and `vector`, should all be
    populated with integers. Let''s print them out:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our output should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lambdas are often used with indirection and this recipe is a good example of
    such. For example, the `push_c` lambda returns an anonymous lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This anonymous lambda is the one that''s stored in the `vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This is the definition of the `consumers` container. It is initialized with
    three elements, where each element is initialized with a call to `push_c`, which
    returns an anonymous lambda. It's the anonymous lambda that gets stored in the
    vector, not the `push_c` lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vector` definition uses the `std::function` class as the type of the elements.
    The `function` constructor takes any callable object and stores its reference
    as the `function` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When its function call `()` operator is invoked, the `function` object calls
    the target function with the intended parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This calls each *anonymous lambda*, as stored in the `consumers` container,
    10 times, thus populating the `d`, `l`, and `v` containers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The nature of the `std::function` class makes it useful for many purposes.
    You can think of it as a polymorphic function container. It can store a standalone
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'It can store a member function, using `std::bind` to bind function parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it can store any executable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Concatenate lambdas with recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can stack lambdas so that the output of one is the input of the next, using
    a simple recursive function. This creates a simple way to build one function upon
    another.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a short and simple recipe that uses one recursive function to do most
    of the work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by defining the concatenation function `concat()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function returns an anonymous lambda, which in turn calls the function
    again, until the parameter pack is exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we create a couple of lambdas and call the `concat()`
    function with them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `concat()` function is called with three parameters: two lambdas, and the
    `std::plus()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the recursion unravels, the functions are called right-to-left, starting
    with `plus()`. The `plus()` function takes two arguments and returns the sum.
    The return value from `plus()` is passed to `twice()`, and its return value is
    passed to `thrice()`. The result is then printed to the console with `format()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `concat()` function is simple, but may be confusing due to the *recursion*
    and the *indirection* of the returned lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `concat()` function is called with a parameter pack. With ellipses, the
    `sizeof...` operator returns the number of elements in the parameter pack. This
    is used to test for the end of the recursion.
  prefs: []
  type: TYPE_NORMAL
- en: The `concat()` function returns a lambda. The lambda recursively calls the `concat()`
    function. Because the first argument of `concat()` is not part of the parameter
    pack, each recursive call peels off the first element of the pack.
  prefs: []
  type: TYPE_NORMAL
- en: The outer `return` statement returns the lambda. The inner `return` is from
    the lambda. The lambda calls the function that was passed to `concat()` and returns
    its value.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to take this apart and study it. There's value in this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Combine predicates with logical conjunction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example wraps a lambda in a function to create a custom conjunction for
    use with an algorithm predicate.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `copy_if()` algorithm requires a predicate that takes one parameter. In
    this recipe, we will create a predicate lambda from three other lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll write the `combine()` function. This function returns a lambda
    for use with the `copy_if()` algorithm:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `combine()` function takes three function parameters – a binary conjunction
    and two predicates – and returns a lambda that calls the conjunction with the
    two predicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we create the lambdas for use with `combine()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `begins_with` and `ends_with` lambdas are simple filter predicates to find
    strings that begin with `'a'` and end with `'b'`, respectively. The `bool_and`
    lambda is the conjunction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can call the `copy_if` algorithm with `combine()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `combine()` function returns a lambda that combines the two predicates with
    the conjunction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `std::copy_if()` algorithm requires a predicate function that takes one
    parameter, but our conjunction requires two parameters, each of which require
    one parameter. We resolve this with a function that returns a lambda specifically
    for this context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `combine()` function creates a lambda from three parameters, each of which
    is a function. The returned lambda takes the one parameter that''s required of
    the predicate function. Now we can call `copy_if()` with the `combine()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This passes the combined lambda to the algorithm so it can operate within that
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Call multiple lambdas with the same input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can easily create multiple instances of a lambda with different capture
    values by wrapping the lambda in a function. This allows you to call different
    versions of a lambda with the same input.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a simple example of a lambda that wraps a value in different types
    of braces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating the wrapper function `braces()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `braces()` function wraps a lambda that returns a three-value string, where
    the first and last values are characters passed to the lambda as captures, and
    the middle value is passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we use `braces()` to create four lambdas, using four
    different sets of braces:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can call our lambdas from a simple `for()` loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is two nested `for()` loops. The outer loop simply counts from 1 to 5,
    passing an integer to the inner loop. The inner loop calls the lambdas with the
    braces.
  prefs: []
  type: TYPE_NORMAL
- en: Both loops use an *initializer list* as the container in a range-based `for()`
    loop. This is a convenient technique for looping through a small set of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from our program looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output shows each of the integers, in each combination of braces.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a simple example of how to use a wrapper for a lambda. The `braces()`
    function constructs a lambda using the braces passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing the `braces()` function parameters to the lambda, it can return
    a lambda with that context. So, each of the assignments in the main function carries
    those parameters with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: When these lambdas are called with a digit, they will return a string with that
    digit in the corresponding braces.
  prefs: []
  type: TYPE_NORMAL
- en: Use mapped lambdas for a jump table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A jump table is a useful pattern when you want to select an action from a user
    or other input. Jump tables are often implemented in `if`/`else` or `switch` structures.
    In this recipe, we'll build a concise jump table using only an STL `map` and anonymous
    lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s easy to build a simple jump table from a `map` and lambdas. The `map`
    provides simple indexed navigation and the lambda can be stored as payload. Here''s
    how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create a simple `prompt()` function to get input from the console:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The C-string parameter is used as a prompt. `std::getline()` is called to get
    input from the user. The response is stored in `r`, checked for length, then if
    it's one character in length, it's converted to uppercase and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we declare and initialize a `map` of lambdas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `map` container is loaded with anonymous lambdas for the jump table. These
    lambdas could easily call other functions or perform simple tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `using` alias is for convenience. We''re using the function pointer type
    `void(*)()` for the lambda payload. If you prefer, you could use `std::function()`
    if you need more flexibility or if you just find it more readable. It has very
    little overhead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can prompt for user input and select an action from the `map`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is how we use the `map`-based jump table. We loop until `'X'` is selected
    for exit. We call `prompt()` with a prompt string, call `find()` on the `map`
    object, then call the lambda with `it->second()`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `map` container makes an excellent jump table. It''s concise and easy to
    navigate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous lambdas are stored as payload in the `map` container. The keys are
    the character responses from the menu of actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the validity of a key and select a lambda in one action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple, elegant solution, where we would have otherwise used awkward
    branching code.
  prefs: []
  type: TYPE_NORMAL
