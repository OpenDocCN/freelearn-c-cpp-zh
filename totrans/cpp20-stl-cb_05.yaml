- en: '*Chapter 5*: Lambda Expressions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++11 standard introduced the *lambda expression* (sometimes called the
    *lambda function*, or just *lambda*). This feature allows an anonymous function
    to be used in the context of an expression. Lambdas may be used in function calls,
    containers, variables, and other expression contexts. It may sound innocuous,
    but it's remarkably useful.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a brief review of lambda expressions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lambda is essentially an anonymous function as a literal expression:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The variable `la` may now be used as if it were a function:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It can be passed to another function:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It can be passed to another lambda:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Output:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or it can be passed anonymously (as a literal):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Closures
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *closure* is often applied to any anonymous function. Strictly speaking,
    a closure is a function that allows the use of symbols outside its own lexical
    scope.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed the square brackets in the definition of a lambda:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The square brackets are used to specify a list of *captures*. Captures are
    outside variables that are accessible from within the scope of the lambda body.
    If I try to use an outside variable without listing it as a capture, I''ll get
    a compilation error:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When I try to compile this with GCC, I get the following error:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is because the body of the lambda has its own lexical scope and the `greeting`
    variable is outside of that scope.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'I can specify the `greeting` variable in a capture. This allows the variable
    into the scope of the lambda:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now it compiles and runs as expected:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This ability to capture variables outside its own scope is what makes a lambda
    a *closure*. People use the term in different ways, and that's fine, so long as
    we can understand each other. Still, it's good to know what the term means.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions allow us to write good, clean generic code. They allow the
    use of *functional programming* patterns, where we can use lambdas as functional
    parameters to algorithms and even other lambdas.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the use of lambdas with the STL, in the following
    recipes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Use lambdas for scoped reusable code
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lambdas as predicates with the algorithm library
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::function` as a polymorphic wrapper
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenate lambdas with recursion
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine predicates with logical conjunction
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call multiple lambdas with the same input
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use mapped lambdas for a jump table
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap05](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap05).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Use lambdas for scoped reusable code
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions can be defined and stored for later use. They can be passed
    as parameters, stored in data structures, and called in different contexts with
    different parameters. They are as flexible as functions, but with the mobility
    of data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a simple program that we''ll use to test various configurations
    of lambda expressions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll first define a `main()` function and use it to experiment with lambdas:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside the `main()` function, we''ll declare a couple of lambdas. The basic
    definition of a lambda requires a pair of square brackets and a block of code
    in curly brackets:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that the first example `one` includes parentheses after the square brackets,
    and the second example `two` does not. The empty parameter parentheses are commonly
    included, but are not always required. The return type is inferred by the compiler.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'I can call these functions with `cout`, or with `format`, or in any context
    that will take a C-string:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In many cases, the compiler can determine the return type from *automatic type
    deduction*. Otherwise, you can specify the return type with the `->` operator:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Lambdas use the *trailing return type* syntax. This consists of the `->` operator
    followed by the type specification. If the return type is not specified, it is
    considered `auto`. If you use a trailing return type, *the parameter parentheses
    are required*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a lambda to print out the values from our other lambdas:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `p()` lambda expects a lambda (or function) as its parameter `v`, and calls
    it in its function body.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The `auto` type parameter makes this lambda an *abbreviated template*. Before
    C++20, this was the only way to template a lambda. Beginning with C++20, you may
    specify template parameters (without the `template` keyword) after the capture
    brackets. This is the equivalent with template parameters:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The abbreviated `auto` version is simpler and more common. It works well for
    most purposes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can pass an anonymous lambda in the function call:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we need to pass parameters to an anonymous lambda, we can put them in parentheses
    after the lambda expression:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The function parameters, `47` and `73`, are passed to the anonymous lambda in
    the parentheses after the function body.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access variables from the outside scope of the lambda by including
    them as *captures* in the square brackets:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or you can capture them by reference:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This allows you to modify a captured variable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also define a local capture variable that maintains its state:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `mutable` specifier allows the lambda to modify its captures. Lambdas default
    to `const`-qualified.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: As with the trailing return type, any *specifier* requires the parameter parentheses.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda supports two types of *default capture*:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If I try to compile this code, I get an error that includes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One type of default capture is indicated by an equal sign:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will capture all the symbols in the lambda's scope. The equal sign performs
    *capture by copy*. It will capture a copy of the objects as if they were copied
    with an assignment operator.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The other default capture uses an ampersand for *capture by reference*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a default capture that captures by reference.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The default captures only use symbols when they are referenced, so they're not
    as messy as they may look. That said, I recommend explicit captures where possible
    as they generally improve readability.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax of a lambda expression is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Syntax of the lambda expression'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18267_05_01.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Syntax of the lambda expression
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The only required parts of a lambda expression are the capture list and the
    body, which may be empty:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is the minimal lambda expression. It captures nothing and does nothing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider each of the parts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Capture-list
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *capture-list* specifies what we capture, if anything. It cannot be omitted,
    but it may be empty. We can use `[=]` to capture all variables *by copy* or `[&]`
    to capture all variables *by reference*, within the scope of the lambda.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'You may capture individual variables by listing them in the brackets:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The specified captures default to copy. You may capture by reference with the
    reference operator:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you capture by reference, you may modify the referenced variable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: You cannot capture object members directly. You may capture `this` or `*this`
    to dereference class members.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with a function, parameters are specified in parentheses:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If there are no parameters, specifiers, or trailing return type, the parentheses
    are optional. A specifier or trailing return type makes the parentheses required:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The mutable modifier (optional)
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A lambda expression defaults to `const`-qualified unless you specify the `mutable`
    modifier. This allows it to be used in `const` context, but it also means that
    it cannot modify any of its captured-by-copy variables. For example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will fail to compile with an error message like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With the `mutable` modifier, the lambda is no longer `const`-qualified and
    the captured variable may be changed:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The constexpr specifier (optional)
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may use `constexpr` to explicitly specify that you want your lambda to be
    considered a *constant expression*. This means that it may be evaluated at compile
    time. If the lambda meets the requirements, it may be considered `constexpr` even
    without the specifier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The exception attribute (optional)
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the `noexcept` specifier to declare that your lambda does not throw
    any exceptions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The trailing return type (optional)
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the lambda return type is deduced from the `return` statement,
    as if it were an `auto` return type. You may optionally specify a *trailing return
    type* with the `->` operator:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The parameter parentheses are required if you use any of the optional specifiers
    or the trailing return type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Some compilers, including GCC, allow empty parameter parentheses to be omitted
    even when there's a specifier or trailing return type. This is not correct. According
    to the specification, the parameters, specifiers, and trailing return type are
    all part of the *lambda-declarator* and the parentheses are required when any
    part of it is included. This may change in a future version of C++.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器，包括GCC，允许省略空参数括号，即使存在指定符或尾随返回类型。这是不正确的。根据规范，参数、指定符和尾随返回类型都是`lambda-declarator`的一部分，并且当包含任何部分时都需要括号。这可能在C++的未来的版本中发生变化。
- en: Use lambdas as predicates with the algorithm library
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用算法库中的lambda作为谓词
- en: Some functions in the `algorithm` library require the use of a *predicate* function.
    A predicate is a function (or functor or lambda) that tests a condition and returns
    a Boolean `true`/`false` response.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`algorithm`库中的某些函数需要使用**谓词**函数。谓词是一个函数（或仿函数或lambda），它测试一个条件并返回布尔`true`/`false`响应。'
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'For this recipe, we will experiment with the `count_if()` algorithm using different
    types of predicates:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将通过使用不同类型的谓词来实验`count_if()`算法：
- en: 'First, let''s create a function for use as a predicate. A predicate takes a
    certain number of arguments and returns a `bool`. A predicate for `count_if()`
    takes one argument:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个用作谓词的函数。谓词接受一定数量的参数并返回一个`bool`。`count_if()`的谓词接受一个参数：
- en: '[PRE38]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This predicate checks whether an `int` value is divisible by 4.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谓词检查一个`int`值是否可以被4整除。
- en: 'In `main()`, we''ll define a vector of `int` values, and use it to test our
    predicate function with `count_if()`:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们将定义一个`int`值的向量，并使用它通过`count_if()`测试我们的谓词函数：
- en: '[PRE39]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '(The 5 divisible numbers are: 4, 4, 8, 12, and 20.)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: （可被5整除的数字有：4，4，8，12和20。）
- en: The `count_if()` algorithm uses the predicate function to determine which elements
    of the sequence to count. It calls the predicate with each element as a parameter,
    and only counts the element if the predicate returns `true`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`count_if()`算法使用谓词函数来确定要计数的序列中的哪些元素。它将每个元素作为参数调用谓词，并且只有当谓词返回`true`时才计数元素。'
- en: In this case, we used a function as a predicate.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了一个函数作为谓词。
- en: 'We could also use a *functor* as a predicate:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以使用**仿函数**作为谓词：
- en: '[PRE41]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The only change here is that we need to use an *instance* of the class as the
    predicate:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一变化是我们需要使用类的**一个实例**作为谓词：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The advantage of a functor is that it can carry context and access class and
    instance variables. This was the common way to use predicates before C++11 introduced
    lambda expressions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 仿函数的优势在于它可以携带上下文并访问类和实例变量。这是在C++11引入lambda表达式之前使用谓词的常见方式。
- en: 'With a lambda expression, we have the best of both worlds: the simplicity of
    a function and the power of a functor. We can use a lambda as a variable:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda表达式，我们拥有了两种世界的最佳之处：函数的简洁性和仿函数的强大功能。我们可以将lambda用作变量：
- en: '[PRE43]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or we can use an anonymous lambda:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用匿名lambda：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can take advantage of the lambda capture by wrapping the lambda in a function,
    and using that function context to produce the same lambda with different parameters:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用lambda捕获，通过将lambda包装在函数中来利用它，并使用该函数上下文产生具有不同参数的相同lambda：
- en: '[PRE45]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This function returns a predicate lambda with the divisor from the capture context.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个带有捕获上下文中除数的谓词lambda。
- en: 'We can then use that predicate with `count_if()`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后可以使用该谓词与`count_if()`一起使用：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each call to `is_div_by()` returns a predicate with a different divisor from
    `i`. Now we get this output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`is_div_by()`都会返回一个带有从`i`的不同除数的谓词。现在我们得到以下输出：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The type of a function pointer is represented as a pointer followed by the
    function call `()` operator:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针的类型表示为一个指针后跟函数调用`()`运算符：
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can declare a function pointer and initialize it with the name of an existing
    function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以声明一个函数指针并用现有函数的名称初始化它：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once declared, a function pointer may be dereferenced and used as if it were
    the function itself:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明，函数指针可以被解引用并像函数本身一样使用：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A lambda expression has the same type as a function pointer:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式与函数指针具有相同的类型：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This means that wherever you use a function pointer with a certain signature,
    you may also use a lambda with the same signature. This allows function pointers,
    functors, and lambdas to work interchangeably:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无论你在哪里使用具有特定签名的函数指针，你也可以使用具有相同签名的lambda表达式。这允许函数指针、仿函数和lambda表达式可以互换使用：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Because of this interchangeability, an algorithm such as `count_if()` accepts
    a function, functor, or lambda where it expects a predicate with a particular
    function signature.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: This applies to any algorithm that uses a predicate.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Use std::function as a polymorphic wrapper
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class template `std::function` is a thin polymorphic wrapper for functions.
    It can store, copy, and invoke any function, lambda expression, or other function
    objects. It can be useful in places where you would like to store a reference
    to a function or lambda. Using `std::function` allows you to store functions and
    lambdas with different signatures in the same container, and it maintains the
    context of lambda captures.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe uses the `std::function` class to store different specializations
    of a lambda in a `vector`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe is contained in the `main()` function, where we start by declaring
    three containers of different types:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: These containers, `deque`, `list`, and `vector`, will be referenced by a *template*
    lambda.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll declare a simple `print_c` lambda function for printing out the containers:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we declare a lambda that returns an *anonymous* lambda:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `push_c` lambda takes a reference to a container, which is *captured* by
    the anonymous lambda. The anonymous lambda calls the `push_back()` member on the
    captured container. The return value from `push_c` is the anonymous lambda.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we declare a `vector` of `std::function` elements, and populate it with
    three instances of `push_c()`:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Each of the elements in the initializer list is a function call to the `push_c`
    lambda. `push_c` returns an instance of the anonymous lambda, which gets stored
    in the `vector` via the `function` wrapper. The `push_c` lambda is called with
    the three containers, `d`, `l`, and `v`. The containers are passed as *captures*
    with the anonymous lambda.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we loop through the `consumers` vector, and call each of the lambda elements
    10 times, populating the three containers with integers 0–9 in each container:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now our three containers, the `deque`, `list`, and `vector`, should all be
    populated with integers. Let''s print them out:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Our output should be:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lambdas are often used with indirection and this recipe is a good example of
    such. For example, the `push_c` lambda returns an anonymous lambda:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This anonymous lambda is the one that''s stored in the `vector`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is the definition of the `consumers` container. It is initialized with
    three elements, where each element is initialized with a call to `push_c`, which
    returns an anonymous lambda. It's the anonymous lambda that gets stored in the
    vector, not the `push_c` lambda.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vector` definition uses the `std::function` class as the type of the elements.
    The `function` constructor takes any callable object and stores its reference
    as the `function` target:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When its function call `()` operator is invoked, the `function` object calls
    the target function with the intended parameters:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This calls each *anonymous lambda*, as stored in the `consumers` container,
    10 times, thus populating the `d`, `l`, and `v` containers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The nature of the `std::function` class makes it useful for many purposes.
    You can think of it as a polymorphic function container. It can store a standalone
    function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'It can store a member function, using `std::bind` to bind function parameters:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Or it can store any executable object:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Concatenate lambdas with recursion
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can stack lambdas so that the output of one is the input of the next, using
    a simple recursive function. This creates a simple way to build one function upon
    another.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a short and simple recipe that uses one recursive function to do most
    of the work:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by defining the concatenation function `concat()`:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This function returns an anonymous lambda, which in turn calls the function
    again, until the parameter pack is exhausted.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we create a couple of lambdas and call the `concat()`
    function with them:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `concat()` function is called with three parameters: two lambdas, and the
    `std::plus()` function.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'As the recursion unravels, the functions are called right-to-left, starting
    with `plus()`. The `plus()` function takes two arguments and returns the sum.
    The return value from `plus()` is passed to `twice()`, and its return value is
    passed to `thrice()`. The result is then printed to the console with `format()`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `concat()` function is simple, but may be confusing due to the *recursion*
    and the *indirection* of the returned lambda:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `concat()` function is called with a parameter pack. With ellipses, the
    `sizeof...` operator returns the number of elements in the parameter pack. This
    is used to test for the end of the recursion.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The `concat()` function returns a lambda. The lambda recursively calls the `concat()`
    function. Because the first argument of `concat()` is not part of the parameter
    pack, each recursive call peels off the first element of the pack.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The outer `return` statement returns the lambda. The inner `return` is from
    the lambda. The lambda calls the function that was passed to `concat()` and returns
    its value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to take this apart and study it. There's value in this technique.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Combine predicates with logical conjunction
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example wraps a lambda in a function to create a custom conjunction for
    use with an algorithm predicate.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `copy_if()` algorithm requires a predicate that takes one parameter. In
    this recipe, we will create a predicate lambda from three other lambdas:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll write the `combine()` function. This function returns a lambda
    for use with the `copy_if()` algorithm:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `combine()` function takes three function parameters – a binary conjunction
    and two predicates – and returns a lambda that calls the conjunction with the
    two predicates.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we create the lambdas for use with `combine()`:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `begins_with` and `ends_with` lambdas are simple filter predicates to find
    strings that begin with `'a'` and end with `'b'`, respectively. The `bool_and`
    lambda is the conjunction.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can call the `copy_if` algorithm with `combine()`:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `combine()` function returns a lambda that combines the two predicates with
    the conjunction.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How it works…
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `std::copy_if()` algorithm requires a predicate function that takes one
    parameter, but our conjunction requires two parameters, each of which require
    one parameter. We resolve this with a function that returns a lambda specifically
    for this context:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `combine()` function creates a lambda from three parameters, each of which
    is a function. The returned lambda takes the one parameter that''s required of
    the predicate function. Now we can call `copy_if()` with the `combine()` function:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This passes the combined lambda to the algorithm so it can operate within that
    context.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Call multiple lambdas with the same input
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can easily create multiple instances of a lambda with different capture
    values by wrapping the lambda in a function. This allows you to call different
    versions of a lambda with the same input.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a simple example of a lambda that wraps a value in different types
    of braces:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating the wrapper function `braces()`:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `braces()` function wraps a lambda that returns a three-value string, where
    the first and last values are characters passed to the lambda as captures, and
    the middle value is passed as a parameter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we use `braces()` to create four lambdas, using four
    different sets of braces:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now we can call our lambdas from a simple `for()` loop:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This is two nested `for()` loops. The outer loop simply counts from 1 to 5,
    passing an integer to the inner loop. The inner loop calls the lambdas with the
    braces.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Both loops use an *initializer list* as the container in a range-based `for()`
    loop. This is a convenient technique for looping through a small set of values.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from our program looks like this:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The output shows each of the integers, in each combination of braces.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a simple example of how to use a wrapper for a lambda. The `braces()`
    function constructs a lambda using the braces passed to it:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'By passing the `braces()` function parameters to the lambda, it can return
    a lambda with that context. So, each of the assignments in the main function carries
    those parameters with it:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: When these lambdas are called with a digit, they will return a string with that
    digit in the corresponding braces.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Use mapped lambdas for a jump table
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A jump table is a useful pattern when you want to select an action from a user
    or other input. Jump tables are often implemented in `if`/`else` or `switch` structures.
    In this recipe, we'll build a concise jump table using only an STL `map` and anonymous
    lambdas.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s easy to build a simple jump table from a `map` and lambdas. The `map`
    provides simple indexed navigation and the lambda can be stored as payload. Here''s
    how to do it:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从`map`和lambda构建简单的跳转表很容易。`map`提供了简单的索引导航，lambda可以作为负载存储。下面是如何做到这一点：
- en: 'First, we''ll create a simple `prompt()` function to get input from the console:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的`prompt()`函数来从控制台获取输入：
- en: '[PRE84]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The C-string parameter is used as a prompt. `std::getline()` is called to get
    input from the user. The response is stored in `r`, checked for length, then if
    it's one character in length, it's converted to uppercase and returned.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: C字符串参数用作提示。调用`std::getline()`从用户那里获取输入。响应存储在`r`中，检查长度，然后如果长度为单个字符，则将其转换为大写并返回。
- en: 'In the `main()` function, we declare and initialize a `map` of lambdas:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们声明并初始化一个lambda的`map`：
- en: '[PRE85]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `map` container is loaded with anonymous lambdas for the jump table. These
    lambdas could easily call other functions or perform simple tasks.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`容器加载了用于跳转表的匿名lambda。这些lambda可以轻松调用其他函数或执行简单任务。'
- en: 'The `using` alias is for convenience. We''re using the function pointer type
    `void(*)()` for the lambda payload. If you prefer, you could use `std::function()`
    if you need more flexibility or if you just find it more readable. It has very
    little overhead:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`别名是为了方便。我们使用函数指针类型`void(*)()`作为lambda的负载。如果你更喜欢，你可以使用`std::function()`，如果你需要更多的灵活性或者觉得它更易读。它的开销非常小：'
- en: '[PRE86]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now we can prompt for user input and select an action from the `map`:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以提示用户输入并从`map`中选择一个动作：
- en: '[PRE87]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This is how we use the `map`-based jump table. We loop until `'X'` is selected
    for exit. We call `prompt()` with a prompt string, call `find()` on the `map`
    object, then call the lambda with `it->second()`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用基于`map`的跳转表。我们循环直到选择`'X'`以退出。我们使用提示字符串调用`prompt()`，在`map`对象上调用`find()`，然后调用lambda的`it->second()`。
- en: How it works…
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `map` container makes an excellent jump table. It''s concise and easy to
    navigate:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`容器是一个出色的跳转表。它简洁且易于导航：'
- en: '[PRE88]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Anonymous lambdas are stored as payload in the `map` container. The keys are
    the character responses from the menu of actions.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名lambda存储在`map`容器中作为负载。键是来自动作菜单的字符响应。
- en: 'You can test the validity of a key and select a lambda in one action:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个动作中测试键的有效性并选择一个lambda：
- en: '[PRE89]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This is a simple, elegant solution, where we would have otherwise used awkward
    branching code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单、优雅的解决方案，否则我们可能会使用尴尬的分支代码。
