- en: Intel Edison and Security System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 英特尔爱迪生和安全系统
- en: 'In previous chapters, we learned how we can use the Intel Edison to develop
    applications related to IoT where we displayed live sensor data and also controlled
    the Edison itself. We also learned the development of an Android and a WPF app
    that was used to control the Intel Edison. Well, this chapter is more on the local
    front of the Intel Edison where we are going to use the built-in features of the
    device. This chapter is concentrated mainly on two key points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用英特尔爱迪生开发与物联网相关的应用程序，我们展示了实时传感器数据，并控制了爱迪生本身。我们还学习了开发Android和WPF应用程序，这些应用程序用于控制英特尔爱迪生。嗯，本章更多地关注英特尔爱迪生的本地前端，我们将使用设备的内置功能。本章主要集中在这两个关键点上：
- en: Speech and voice processing with the Intel Edison
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用英特尔爱迪生进行语音和语音处理
- en: Image processing with the Intel Edison
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用英特尔爱迪生进行图像处理
- en: 'All the codes are to be written in Python, so some parts of the chapter will
    concentrate on Python programming as well. In this chapter, we''ll operate the
    Intel Edison using voice commands and then ultimately detect faces using the Intel
    Edison and a webcam. This chapter will thus explore the core capabilities of the
    Intel Edison. Since most of the code is in Python, it is advisable to download
    Python for your PC from the following website:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都应使用Python编写，因此本章的一些部分也将专注于Python编程。在本章中，我们将使用语音命令操作英特尔爱迪生，然后最终使用英特尔爱迪生和摄像头检测人脸。因此，本章将探讨英特尔爱迪生的核心功能。由于大部分代码都是Python编写的，建议您从以下网站下载Python到您的电脑：
- en: '[https://www.python.org/downloads/](https://www.python.org/downloads/)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.python.org/downloads/](https://www.python.org/downloads/)'
- en: This chapter will be divided into two parts. The first part will concentrate
    on only speech or voice processing and we'll do a mini-project based on that while
    the second part, which will be a bit lengthy, will concentrate on the image processing
    aspect of it using OpenCV.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为两部分。第一部分将仅关注语音或语音处理，我们将基于此进行一个迷你项目；而第二部分将更详细，将关注使用OpenCV的图像处理方面。
- en: Speech/voice processing using Edison
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用爱迪生进行语音/语音处理
- en: Speech processing typically refers to the various mathematical techniques that
    are applied on an audio signal to process it. It may be some simple mathematical
    operation or some complex operation. It's a special case of digital signal processing.
    However, we are not typically dealing with speech processing as a whole entity.
    We are interested only in a specific area of speech to text conversion. It is
    to be noted that everything in this chapter is to be performed by the Edison itself
    without accessing any cloud services. The scenario that this chapter will tackle
    initially is that we'll make the Edison perform some tasks based on our voice
    commands. We'll be using a lightweight speech processing tool, but before we proceed
    further with all the code and circuits, make sure you have the following devices
    with you. Initially, we'll walk you through switching an LED on and off. Next
    we'll deal with controlling a servo motor using voice commands.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 语音处理通常指的是应用于音频信号的各种数学技术，以对其进行处理。这可能是一些简单的数学运算，也可能是一些复杂的运算。它是数字信号处理的一个特例。然而，我们通常不将语音处理作为一个整体实体来处理。我们只对语音到文本转换的特定领域感兴趣。需要注意的是，本章中的一切都应由爱迪生本身执行，而不需要访问任何云服务。本章将首先解决的场景是我们将使爱迪生根据我们的语音命令执行一些任务。我们将使用轻量级的语音处理工具，但在继续所有代码和电路之前，请确保您有以下设备。最初，我们将向您展示如何开关LED。接下来，我们将使用语音命令控制伺服电机。
- en: Devices required
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所需设备
- en: 'Along with the Intel Edison, we need a couple of more devices, as listed here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了英特尔爱迪生外，我们还需要一些其他设备，如下所示：
- en: Power adapter of 9V-1 A for the Intel Edison
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英特尔爱迪生的9V-1 A电源适配器
- en: USB sound card
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB声卡
- en: USB hub, preferably powered
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB集线器，最好是供电的
- en: This project will use the Edison on external power and the USB port will be
    used for the sound card. A non-powered USB hub also works, but because of the
    current it's recommended to use a powered USB hub.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将使用爱迪生外部供电，USB端口将用于声卡。非供电USB集线器也可以使用，但由于电流问题，建议使用供电USB集线器。
- en: Make sure that the USB sound card is supported on a Linux environment. The selector
    switch should be towards the USB port. That is because the Edison will be powered
    through the DC adapter and we need power in the USB port that is activated only
    when we provide DC power.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 确保USB声卡在Linux环境中受支持。选择开关应朝向USB端口。这是因为Edison将通过直流适配器供电，我们需要在提供直流电源时才激活的USB端口供电。
- en: Speech processing library
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语音处理库
- en: For this project we are going to use PocketSphinx. It's a lightweight version
    of CMU Sphinx, a project created by Carnegie Mellon University. It's a lightweight
    speech recognition engine meant for mobile and handheld devices and wearables.
    The greatest advantage of using this over any cloud-based service is that it is
    available offline.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用PocketSphinx。它是卡内基梅隆大学创建的CMU Sphinx的一个轻量级版本。它是一个轻量级的语音识别引擎，适用于移动、手持设备和可穿戴设备。使用这个比任何基于云的服务最大的优势是它可以离线使用。
- en: 'More information about PocketSphinx can be accessed from the following links:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于PocketSphinx的信息可以从以下链接获取：
- en: '[http://cmusphinx.sourceforge.net/wiki/develop](http://cmusphinx.sourceforge.net/wiki/develop)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://cmusphinx.sourceforge.net/wiki/develop](http://cmusphinx.sourceforge.net/wiki/develop)'
- en: '[https://github.com/cmusphinx/pocketsphinx](https://github.com/cmusphinx/pocketsphinx)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/cmusphinx/pocketsphinx](https://github.com/cmusphinx/pocketsphinx)'
- en: Setting up the library will be discussed in a later section of this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 设置库将在本章的后续部分讨论。
- en: Initial configuration
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始配置
- en: 'In the first chapter, we performed some very basic configuration for the Intel
    Edison. Here we need to configure our device with the required libraries and sound
    setup with the sound card. For this you need to connect the Intel Edison to only
    one micro USB port. This will be used to communicate using the PuTTY console and
    transfer files using the FileZilla FTP client:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们对Intel Edison进行了一些非常基本的配置。在这里，我们需要使用所需的库和声卡设置来配置我们的设备。为此，您需要将Intel Edison连接到仅一个微型USB端口。这将用于通过PuTTY控制台进行通信，并使用FileZilla
    FTP客户端传输文件：
- en: '![](img/6639_04_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_04_01.jpg)'
- en: Arduino expansion board components
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino扩展板组件
- en: Connect the Intel Edison to the Micro B USB for serial interface to your PC.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将Intel Edison连接到Micro B USB，以通过串行接口连接到您的PC。
- en: Some of the steps were covered in [Chapter 1](c225d705-919a-4442-adc8-7b22d33437fc.xhtml), *Setting
    up Intel Edison;* however, we'll show all the steps from the beginning. Open your
    PuTTY console and log in to your device. Use the `configure_edison -wifi` to connect
    to your Wi-Fi network.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些步骤已在[第一章](c225d705-919a-4442-adc8-7b22d33437fc.xhtml)中介绍，*设置Intel Edison*；然而，我们将从开始展示所有步骤。打开您的PuTTY控制台并登录到您的设备。使用`configure_edison
    -wifi`连接到您的Wi-Fi网络。
- en: Initially, we'll add AlexT's unofficial `opkg` repository. To add this, edit
    the `/etc/opkg/base-feeds.conf` file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们将添加AlexT的非官方`opkg`仓库。要添加它，编辑`/etc/opkg/base-feeds.conf`文件。
- en: 'Add these lines to the preceding file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到前面的文件中：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To do that, execute the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请执行以下命令：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Update the package manager:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更新包管理器：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Install `git` using the package manager:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包管理器安装`git`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will now install Edison helper scripts to simplify things a bit:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将安装Edison辅助脚本以简化一些事情：
- en: 'First `clone` the package:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先克隆该包：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we have to add `~/edison-scripts` to the path:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须将`~/edison-scripts`添加到路径中：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next we will run the following scripts:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们将运行以下脚本：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The initial configuration is done. Now we'll configure the Edison for sound.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 初始配置已完成。现在我们将为声音配置Edison。
- en: 'Now `install` the modules for USB devices, including USB webcams, microphone,
    and speakers. Make sure that your sound card is connected to the Intel Edison:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`安装`USB设备的模块，包括USB摄像头、麦克风和扬声器。确保您的声卡已连接到Intel Edison：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next target is to check whether the USB device is getting detected or not.
    To check that, type the `lsusb` command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个目标是检查USB设备是否被检测到。要检查这一点，请输入`lsusb`命令：
- en: '![](img/6639_04_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_04_02.jpg)'
- en: USB sound card
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: USB声卡
- en: The device that is connected to the Intel Edison is shown in the preceding screenshot.
    It is highlighted in the box. Once we get the device that is connected to the
    Edison, we can proceed further.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中显示了连接到Intel Edison的设备。它在框中被突出显示。一旦我们获取到连接到Edison的设备，我们就可以继续下一步。
- en: 'Now we''ll check whether `alsa` is able to detect the sound card or not. Type
    in the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将检查`alsa`是否能够检测到声卡。输入以下命令：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](img/6639_04_03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_04_03.png)'
- en: Alsa device check
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Alsa设备检查
- en: It is noted that our device is getting detected as card 2, named as `Device`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的设备被检测为卡 2，命名为 `Device`。
- en: 'Now we have to create a `~/.asoundrc` file where we need to add the following
    line. Please note that `Device` must be replaced with the device name that is
    detected on your system:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须创建一个 `~/.asoundrc` 文件，在其中我们需要添加以下行。请注意，`Device` 必须替换为系统上检测到的设备名称：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, once this is done, exit and save the file. Next, to test whether everything
    is working or not, execute the following command and you must hear something on
    the headphone connected:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦完成，退出并保存文件。接下来，为了测试一切是否正常工作，执行以下命令，你必须在连接的耳机上听到一些声音：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should hear the words `Front Center`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该听到“前中心”这个词。
- en: Now, our target is to record something and interpret the result. So let's test
    whether recording is working or not.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的目标是记录一些内容并解释结果。所以让我们测试一下记录是否正常工作。
- en: 'To record a clip, type in the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要录制一段剪辑，输入以下命令：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Press *Ctrl *+ *c* to stop recording. To play the preceding recording, type
    the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Ctrl *+ *c* 停止录制。要播放前面的录音，输入以下命令：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You must hear what you have recorded. If you are not able to hear the sound,
    type `alsamixer` and adjust the playback and record volumes. Initially, you need
    to select the device:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须听到你录制的声音。如果你听不到声音，输入 `alsamixer` 并调整播放和录音音量。最初，你需要选择设备：
- en: '![](img/6639_04_04.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_04_04.png)'
- en: Alsamixer—1
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Alsamixer—1
- en: 'Next, adjust the volume using the arrow keys:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用箭头键调整音量：
- en: '![](img/6639_04_05.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_04_05.png)'
- en: Alsamixer—2
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Alsamixer—2
- en: Now everything related to sound is set up. The next aim is to `install` the
    packages for speech recognition.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有与声音相关的设置都已经完成。下一个目标是安装语音识别的包。
- en: 'Initially, use Python''s `pip` to `install cython`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，使用 Python 的 `pip` 来安装 `cython`：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding package takes a lot of time to install. Once that''s done, there
    are some shell scripts that are required to be executed. I have created a GitHub
    repository for this that contains the required files and the code. Use the git
    command to clone the repository ([https://github.com/avirup171/Voice-Recognition-using-Intel-Edison.git](https://github.com/avirup171/Voice-Recognition-using-Intel-Edison.git)):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的包安装需要很长时间。一旦安装完成，还有一些需要执行的 shell 脚本。我已经为这个创建了一个 GitHub 仓库，其中包含所需的文件和代码。使用
    git 命令克隆仓库 ([https://github.com/avirup171/Voice-Recognition-using-Intel-Edison.git](https://github.com/avirup171/Voice-Recognition-using-Intel-Edison.git))：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next in the bin folder, you will find the packages. Before typing the commands
    to execute those shell scripts, we need to provide permissions. Type the following
    command to add permissions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在 bin 文件夹中，你会找到这些包。在输入执行这些 shell 脚本的命令之前，我们需要提供权限。输入以下命令以添加权限：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next type the filename to execute them. Installation of the packages may take
    a bit of time:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来输入要执行的文件名。安装包可能需要一些时间：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next type these for adding to the path:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来输入以下内容以添加到路径：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next install `Pocketsphinx`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来安装 `Pocketsphinx`：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, install `PyAudio`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，安装 `PyAudio`：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After this step, all the configurations are set up and we are good to go with
    the coding. PocketSphinx works with some specific sets of commands. We need to
    create a language mode and a dictionary for the words to be used. We''ll do that
    using the Sphinx knowledge base tool:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步之后，所有配置都已经设置好，我们可以开始编码了。PocketSphinx 与一些特定的命令集一起工作。我们需要为要使用的单词创建一个语言模式和字典。我们将使用
    Sphinx 知识库工具来完成这项工作：
- en: '[http://www.speech.cs.cmu.edu/tools/lmtool-new.html](http://www.speech.cs.cmu.edu/tools/lmtool-new.html)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.speech.cs.cmu.edu/tools/lmtool-new.html](http://www.speech.cs.cmu.edu/tools/lmtool-new.html)'
- en: 'Upload a text file containing the set of commands that we want the engine to
    decode. Then click on COMPILE KNOWLEDGE BASE. Download the `.tgz` file that contains
    the necessary files that are required. Once we have those files, copy it to the
    Edison using FileZilla. Note the names of the files that contain the following
    extension. Ideally each file should have the same name:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上传包含我们希望引擎解码的命令集的文本文件。然后点击编译知识库。下载包含所需文件的 `.tgz` 文件。一旦我们有了这些文件，使用 FileZilla
    将其复制到 Edison 上。注意包含以下扩展名的文件名称。理想情况下，每个文件都应该有相同的名称：
- en: '`.dic`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dic`'
- en: '`.lm`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.lm`'
- en: Move the entire set to the Edison.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个集合移动到 Edison 上。
- en: Writing the code
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写代码
- en: '**Problem statement**: To turn on and off an LED using voice commands such
    as `ON` and `OFF`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题陈述**：使用如 `ON` 和 `OFF` 的语音命令来打开和关闭 LED。'
- en: Before writing the code, let us discuss the algorithm first. Please note that
    I am writing the algorithm in plain text so that it is easier for the reader to
    understand.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前，让我们先讨论一下算法。请注意，我将算法以纯文本的形式编写，以便读者更容易理解。
- en: Let's start with the algorithm
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们从算法开始
- en: 'Perform the following steps to begin with the algorithm:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以开始算法：
- en: Import all the necessary packages.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所有必要的包。
- en: Set the LED pin.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置LED引脚。
- en: Start an infinite loop. From here on, all the parts or blocks will be inside
    the while loop.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个无限循环。从现在开始，所有部分或块都将位于while循环内。
- en: Store two variables in the path for the `.lm` and `.dic` files.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路径中存储两个变量，用于`.lm`和`.dic`文件。
- en: Record and save a `.wav` file for `3` seconds.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录并保存一个持续`3`秒的`.wav`文件。
- en: Pass the `.wav` file as a parameter to the speech recognition engine.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`.wav`文件作为参数传递给语音识别引擎。
- en: Get the resultant text.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取结果文本。
- en: With an `if else` block test for the `ON` and `OFF` texts and use the `mraa`
    library to turn on and off an LED.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`if else`块测试`ON`和`OFF`文本，并使用`mraa`库来开关LED。
- en: 'The algorithm is pretty much straightforward. Compare the following code with
    the preceding algorithm to get a full grip of it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 算法相当直接。将以下代码与前面的算法进行比较，以全面掌握它：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s go line by line:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们逐行来看：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding segment is just to `import` all the libraries and packages:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分只是为了`导入`所有库和包：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We set the LED pin and set its direction as the output. Next we will begin
    the infinite while loop:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了LED引脚并将其方向设置为输出。接下来，我们将开始无限while循环：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding chunk of code is just the parameters for PocketSphinx and for
    audio recording. We will be recording for `3` seconds. We have also provided the
    path for the `.lmd` and `.dic` files and some other audio recording parameters:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块只是PocketSphinx和音频记录的参数。我们将记录`3`秒。我们还提供了`.lmd`和`.dic`文件的路径以及一些其他音频记录参数：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we record the audio for the specific time interval.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们记录了特定时间间隔的音频。
- en: 'Next, we save it as a `.wav` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将它保存为`.wav`文件：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The final step contains the decoding of the file and comparing it to affect
    the LED:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步包含文件的解码和比较以影响LED：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we initially pass the `.wav` file as a parameter to the
    speech processing engine and then use the result to compare the output. Finally,
    we switch on and off the LEDs based on the output of the speech processing engine.
    Another activity carried out by the preceding code is that whatever is recognized
    is spoken back using `espeak`. `espeak` is a text to speech engine. It uses spectral
    formant synthesis by default, which sounds robotic, but can be configured to use
    Klatt formant synthesis or MBROLA to give it a more natural sound.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们最初将`.wav`文件作为参数传递给语音处理引擎，然后使用结果进行比较。最后，根据语音处理引擎的输出开关LED。前面代码执行的另一项活动是，使用`espeak`将识别的内容重新朗读出来。`espeak`是一个文本到语音引擎。它默认使用频谱共振峰合成，听起来像机器人，但可以配置为使用Klatt共振峰合成或MBROLA以产生更自然的音效。
- en: Transfer the code to your device using FileZilla. Let's assume that the code
    is saved by the file named `VoiceRecognitionTest.py`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FileZilla将代码传输到你的设备。假设代码被保存为名为`VoiceRecognitionTest.py`的文件。
- en: Before executing the code, you may want to attach an LED to GPIO pin 13 or just
    use the on board LED for the purpose.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行代码之前，你可能想要将一个LED连接到GPIO引脚13，或者直接使用板载LED来完成这个目的。
- en: 'To execute the code, type the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行代码，请输入以下内容：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Initially, the console says `*recording`, speak `on`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，控制台显示`*recording`，说`on`：
- en: '![](img/image_04_009.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_009.png)'
- en: Voice recognition—1
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 语音识别—1
- en: 'Then, after you speak, the speech recognition engine will recognize the word
    that you spoke from the existing language model:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你说话之后，语音识别引擎将识别你所说的单词，从现有的语言模型中：
- en: '![](img/image_04_010.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_010.png)'
- en: Voice recognition—2
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 语音识别—2
- en: 'It is noted that on is displayed. That means that the speech recognition engine
    has successfully decoded the speech we just spoke. Similarly, the other option
    stands when we speak off on the microphone:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到显示的是`on`。这意味着语音识别引擎已经成功解码了我们刚才说的语音。同样，当我们通过麦克风说`off`时，另一个选项也会出现：
- en: '![](img/image_04_011.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_04_011.png)'
- en: Voice recognition—3
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 语音识别—3
- en: So now we have a voice recognition proof of concept ready. Now, we are going
    to use this concept with small modifications to lock and unlock the door.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了一个语音识别的概念证明。现在，我们将对这个概念进行一些小的修改，以锁定和解锁门。
- en: Door lock/unlock based on voice commands
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于语音命令的锁门/解锁
- en: In this section, we'll just open and close a door based on voice commands. Similar
    to the previous section, where we switched an LED on and off using voice commands
    such as `ON` and `OFF`, here we are going to do a similar thing using a servo
    motor. The main target is to make the readers understand the core concepts of
    the Intel Edison where we use voice commands to perform different tasks. The question
    may arise, why are we using servo motors?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将根据语音命令打开和关闭门。类似于前一个章节，我们使用如`ON`和`OFF`之类的语音命令开关LED，这里我们将使用伺服电机做类似的事情。主要目标是让读者理解英特尔爱迪生的核心概念，即我们使用语音命令执行不同的任务。可能会有人问，为什么我们使用伺服电机？
- en: A servo motor, unlike normal DC motors, rotates up to a specific angle set by
    the operator. In normal scenarios, controlling the lock of a door may use a relay.
    The usage of relays was discussed in [Chapter 3](3bd53219-a287-4d8f-9a58-5a06c5b14062.xhtml),
    *Intel Edison and IoT (Home Automation)*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通直流电机不同，伺服电机可以旋转到操作者设定的特定角度。在正常情况下，控制门的锁定可能使用继电器。继电器的作用在第3章（3bd53219-a287-4d8f-9a58-5a06c5b14062.xhtml），*英特尔爱迪生和物联网（智能家居自动化）*中已有讨论。
- en: 'Let us also explore the use of servo motors so that we can widen the spectrum
    of controlling devices. In this case, when a servo is set to `0` degrees, it is
    unlocked and when it is set to `90` degrees, it is locked. The control of servo
    motors requires the use of pulse width modulation pins. Intel Edison has four
    PWM pins:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也探讨伺服电机的使用，以便我们可以扩大控制设备的范围。在这种情况下，当伺服电机设置为`0`度时，它是解锁的，当设置为`90`度时，它是锁定的。伺服电机的控制需要使用脉冲宽度调制引脚。英特尔爱迪生有四个PWM引脚：
- en: '![](img/6639_04_09.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_04_09.jpg)'
- en: 'Servo motor. Picture credits: [https://circuitdigest.com](https://circuitdigest.com)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机。图片来源：[https://circuitdigest.com](https://circuitdigest.com)
- en: 'There are three operating lines to operate a servo:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 操作伺服电机有三个操作线路：
- en: Vcc
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vcc
- en: Gnd
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gnd
- en: Signal
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号
- en: 'The typical color coding goes like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的颜色编码如下：
- en: Black—ground
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑色——地线
- en: Red or brown—power supply
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色或棕色——电源
- en: Yellow or white—control signal
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄色或白色——控制信号
- en: We are using a 5V servo motor; therefore the Edison is enough to supply power.
    The Edison and the servo motor must share a common ground. Finally, the signal
    pin is connected to the PWM pin on the Intel Edison. As we move further with this
    mini-project, things will get clearer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是5V伺服电机；因此爱迪生足以供电。爱迪生和伺服电机必须共享一个公共地。最后，信号引脚连接到英特尔爱迪生的PWM引脚。随着我们进一步进行这个小型项目，事情将变得更加清晰。
- en: Circuit diagram
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电路图
- en: 'The following is the circuit diagram for voice recognition:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为语音识别设计的电路图：
- en: '![](img/6639_04_10-1.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_04_10-1.jpg)'
- en: Circuit diagram for voice recognition
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 语音识别电路图
- en: As already mentioned, the servo motor requires PWM pins for operation and the
    Intel Edison has a total of six PWM pins. Here we are using digital pin 6 for
    servo control and digital pin 13 for the LED. As far as the peripheral devices
    are concerned, connect your USB sound card to the USB of the Intel Edison and
    you are all set.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，伺服电机需要PWM引脚来操作，英特尔爱迪生总共有六个PWM引脚。在这里，我们使用数字引脚6进行伺服控制，数字引脚13用于LED。至于外围设备，将您的USB声卡连接到英特尔爱迪生的USB端口，您就设置好了。
- en: Configuring the servo library for Python
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Python配置伺服库
- en: To control a servo, we need to send some signals through the PWM pins. We opt
    for using a library for controlling the servo motors.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制伺服电机，我们需要通过PWM引脚发送一些信号。我们选择使用一个库来控制伺服电机。
- en: 'Use the following link to get access to a `Servo.py` Python script from a GitHub
    repository:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下链接从GitHub仓库获取`Servo.py` Python脚本：
- en: '[https://github.com/MakersTeam/Edison/blob/master/Python-Examples/Servo/Servo.py](https://github.com/MakersTeam/Edison/blob/master/Python-Examples/Servo/Servo.py)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/MakersTeam/Edison/blob/master/Python-Examples/Servo/Servo.py](https://github.com/MakersTeam/Edison/blob/master/Python-Examples/Servo/Servo.py)'
- en: 'Download the file and push it to your Edison device. After that, just execute
    the file similar to executing a Python script:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件并将其推送到你的爱迪生设备。之后，只需像执行Python脚本一样执行该文件：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now once you have done, you are ready to use the servo with your Intel Edison
    using Python.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了，你就可以使用Python和你的英特尔爱迪生使用伺服电机了。
- en: 'Getting back to the hardware, the servo must be connected to digital pin `6`,
    which is a PWM pin. Let''s write a Python script that will test if the library
    is functioning or not:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 回到硬件部分，伺服电机必须连接到数字引脚`6`，这是一个PWM引脚。让我们编写一个Python脚本来测试库是否正常工作：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code basically sweeps from `0` to `180` degrees and back to `0`
    degrees. The circuit remains the same as discussed before. Initially, we attach
    the servo to the servo pin. Then as the standard goes, we put the entire logic
    in an infinite loop. To rotate the servo to a specific angle, we use `.write(angle)`.
    In the two for loops, initially we rotate from `0` to `180` degrees and in the
    second one, we rotate from `180` to `0` degrees.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码基本上从`0`度扫到`180`度，然后再回到`0`度。电路与之前讨论的相同。最初，我们将伺服连接到伺服引脚。然后按照标准，我们将整个逻辑放在一个无限循环中。为了将伺服旋转到特定角度，我们使用`.write(angle)`。在两个for循环中，最初我们从`0`度旋转到`180`度，在第二个循环中，我们从`180`度旋转到`0`度。
- en: It is also to be noted that `time.sleep(time_interval)` is used to pause the
    code for some miliseconds. When you execute the preceding code, the servo should
    rotate and come back to the initial position.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，`time.sleep(time_interval)`用于暂停代码一段时间。当你执行上述代码时，伺服应该旋转并回到初始位置。
- en: Now, we have all the things in place. We'll just put them in the right place
    and your voice controlled door will be ready. Initially, we controlled an LED
    and then we learned how we can operate a servo using Python. Now let's create
    a language model using the Sphinx knowledge base tool.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了所有东西。我们只需将它们放在正确的位置，你的语音控制门就准备好了。最初，我们控制了一个LED，然后我们学习了如何使用Python操作伺服。现在让我们使用Sphinx知识库工具创建一个语言模型。
- en: Language model
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言模型
- en: 'For this project, we''ll be using the following set of commands. To keep things
    simple, we''re using only two sets of commands:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用以下命令集。为了使事情简单，我们只使用两组命令：
- en: '`door open`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`门打开`'
- en: '`door close`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`门关闭`'
- en: 'Follow the process that was discussed earlier and create a text file and just
    write the three unique words:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前讨论的过程进行，创建一个文本文件并只写下三个独特的单词：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Save it and upload it to the Sphinx knowledge base tool and compile it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 保存它并将其上传到Sphinx知识库工具并编译它。
- en: 'Once you have the compressed file downloaded, move on to the next step with
    this code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完压缩文件后，使用以下代码继续下一步：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code is more or less similar to the code for switching an LED
    on and off. The only difference is that the servo control mechanism is added into
    the existing code. In a simple if else block, we check for the `door open` and
    `door close` conditions. Finally based on what is triggered, we set the LED and
    the servo to a `90` degrees or `0` degree position.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与切换LED开关的代码大致相似。唯一的区别是，将伺服控制机制添加到现有代码中。在一个简单的if else块中，我们检查`门打开`和`门关闭`条件。最后根据触发的内容，我们将LED和伺服设置到`90`度或`0`度位置。
- en: Conclusion of speech processing using the Intel Edison
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用英特尔爱迪生进行语音处理的结论
- en: From the projects discussed before, we explored one of the core capabilities
    of the Intel Edison and explored a whole new scenario of controlling the Intel
    Edison by voice. A popular use case that implements the preceding procedure can
    be the case of home automation, which was implemented in the earlier chapter.
    Another use case is building a virtual voice based assistant using your Intel
    Edison. There are multiple opportunities that can be used using voice-based control.
    It's up to the reader's imagination as to what they want to explore.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前讨论的项目中，我们探索了英特尔爱迪生的核心功能之一，并探索了通过语音控制英特尔爱迪生的新场景。一个流行的用例，实现了上述程序，可以是家庭自动化的案例，这在早期章节中已经实现。另一个用例是使用你的英特尔爱迪生构建一个虚拟语音助手。有多个机会可以使用基于语音的控制。这取决于读者的想象力，他们想探索什么。
- en: In the next part, we'll be dealing with the implementation of image processing
    using the Intel Edison.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将处理使用英特尔爱迪生进行图像处理的实现。
- en: Image processing using the Intel Edison
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用英特尔爱迪生进行图像处理
- en: Image processing or computer vision is one such field that requires tremendous
    amounts of research. However, we're not going to do rocket science here. We are
    opting for an open source computer vision library called `OpenCV`. `OpenCV` supports
    multiple languages and we are going to use Python as our programming language
    to perform face detection.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理或计算机视觉是这样一个需要大量研究的领域。然而，我们在这里不会做火箭科学。我们选择了一个开源的计算机视觉库，称为`OpenCV`。`OpenCV`支持多种语言，我们将使用Python作为我们的编程语言来执行人脸检测。
- en: Typically, an image processing application has an input image; we process the
    input image and we get an output processed image.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，图像处理应用程序有一个输入图像；我们处理输入图像，并得到一个处理后的输出图像。
- en: Intel Edison doesn't have a display unit. So essentially we will run the Python
    script on our PC first. Then after the successful working of the code in the PC,
    we'll modify the code to run on the Edison. Things will get clearer when we do
    the practical implementation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Intel Edison没有显示单元。因此，本质上我们首先将在我们的PC上运行Python脚本。然后，在PC上代码成功运行后，我们将修改代码以在Edison上运行。当进行实际实施时，一切将变得更加清晰。
- en: Our target is to perform face detection and, if detected, perform some action.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是执行人脸检测，并在检测到人脸时执行某些操作。
- en: Initial configuration
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始配置
- en: The initial configuration will include installing the `openCV` package both
    on the Edison device as well as the PC.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 初始配置将包括在Edison设备和PC上安装`openCV`包。
- en: For the PC, download Python from [https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/).
    Next install Python on your system. Also download the latest version of openCV
    from [https://sourceforge.net/projects/opencvlibrary/](https://sourceforge.net/projects/opencvlibrary/).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PC，从[https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)下载Python。然后，在您的系统上安装Python。同时，从[https://sourceforge.net/projects/opencvlibrary/](https://sourceforge.net/projects/opencvlibrary/)下载最新版本的openCV。
- en: After you download openCV, move the extracted folder to `C:\`. Next, browse
    to `C:\opencv\build\python\2.7\x86`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下载openCV后，将提取的文件夹移动到`C:\`。然后，浏览到`C:\opencv\build\python\2.7\x86`。
- en: Finally, copy the `cv2.pyd` file to `C:\Python27\Lib\site-packages`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`cv2.pyd`文件复制到`C:\Python27\Lib\site-packages`。
- en: We need to install `numpy` as well. Numpy stands for **Numerical Python**. Download
    and install it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装`numpy`。Numpy代表**数值Python**。下载并安装它。
- en: 'Once you install all the components, we need to test whether everything is
    installed or not. To do that, open up the idle Python GUI and type the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了所有组件，我们需要测试是否一切安装正常。为此，打开idle Python GUI并输入以下内容：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If this proceeds without any error, then everything is installed and in place
    as far as the PC configuration is concerned. Next, we'll configure for our device.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误发生，那么PC配置方面一切安装就绪。接下来，我们将为我们的设备进行配置。
- en: 'To configure your Edison with openCV, initially execute the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置您的Edison与openCV，最初执行以下操作：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, after the preceding is successfully executed, run the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在成功执行前面的操作后，运行以下命令：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This should install all the necessary components. To check whether everything
    is set up or not, type the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会安装所有必要的组件。要检查是否一切设置就绪，请输入以下内容：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And press the *Enter* key. This should enter into the Python shell mode. Next,
    type the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Enter*键。这应该进入Python shell模式。接下来，输入以下内容：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the screenshot of this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是截图：
- en: '![](img/6639_04_11.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_04_11.png)'
- en: Python shell
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Python shell
- en: If this doesn't return any error message, then you are all set to go.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有返回任何错误消息，那么您已经准备就绪。
- en: At first we will be covering everything in the PC and after that we'll move
    on to deploy it to the Intel Edison.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将涵盖PC上的所有内容，然后我们将将其部署到Intel Edison上。
- en: Real-time video display using OpenCV
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV进行实时视频显示
- en: 'Before we move on to face detection, let''s first see whether we can access
    our camera or not. To do that, let''s write a very simple Python script to display
    the webcam video feed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行人脸检测之前，让我们先看看我们是否可以访问我们的摄像头。为此，让我们编写一个非常简单的Python脚本来显示网络摄像头的视频流：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, we initially import the openCV module as `import cv2`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们最初导入openCV模块为`import cv2`。
- en: Next we initialize the video capture device and set the index to zero as we're
    using the default webcam that comes with the laptop. For desktop users, you may
    need to vary the parameter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化视频捕获设备并将索引设置为零，因为我们正在使用笔记本电脑附带的自带摄像头。对于桌面用户，您可能需要调整该参数。
- en: 'After the initialization, in an infinite loop, we read the incoming video frame
    by frame using `cap.read()`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，在一个无限循环中，我们使用`cap.read()`逐帧读取传入的视频帧：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next we apply some operations on the incoming video feed. Here in the sample,
    we convert the RGB video frame to a grayscale image:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对传入的视频流应用一些操作。在这个示例中，我们将RGB视频帧转换为灰度图像：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, the frames are displayed in a separate window:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，帧将在一个单独的窗口中显示：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding two lines, we implement the mechanism of keyboard interrupts.
    When someone presses *q* or presses the *Esc* key, the display will close.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两行中，我们实现了键盘中断机制。当有人按下*q*或按下*Esc*键时，显示将关闭。
- en: Once you get the incoming video feed, then we are ready to move to face detection.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获取到传入的视频流，我们就准备好进行面部检测。
- en: Face detection theory
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面部检测理论
- en: 'Face detection is a very specific case of object recognition. There are many
    approaches to face recognition. However, we are going to discuss the two given
    here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 面部检测是对象识别的一个非常具体的情况。有许多面部识别的方法。然而，我们将讨论这里给出的两种：
- en: Segmentation based on color
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于颜色的分割
- en: Feature-based recognition
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于特征的识别
- en: Segmentation based on color
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于颜色的分割
- en: In this technique, the face is segmented out based on skin color. The input
    of this is typically an RGB image, while in the processing stage we shift it to
    **Hue saturation value** (**HSV**)or YIQ ( Luminance (Y), In-phase Quadrature)
    color formats. In this process, each pixel is classified as a skin-color pixel
    or a non-skin-color pixel. The reason behind the use of other color models other
    than RGB is that sometimes RGB isn't able to distinguish skin colors in different
    light conditions. This significantly improves while using other color models.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项技术中，面部是基于肤色进行分割的。输入通常是RGB图像，而在处理阶段我们将其转换为**色调饱和度值**（**HSV**）或YIQ（亮度（Y），同相正交）颜色格式。在这个过程中，每个像素被分类为肤色像素或非肤色像素。使用除RGB之外的其他颜色模型的原因是，有时RGB无法在不同光照条件下区分肤色。使用其他颜色模型可以显著提高这一点。
- en: This algorithm won't be used here.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法在此处不会使用。
- en: Feature-based recognition
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于特征的识别
- en: In this technique, we go for certain features and based on that we do the recognition.
    Use of the haar feature-based cascade for face detection is an effective object
    detection method proposed by Paul Viola and Michael Jones in their paper "*Rapid
    Object Detection using a Boosted Cascade of Simple Features*" in 2001\. It is
    a machine learning based approach where a cascade function is trained against
    a set of positive and negative images. Then it is used to detect objects in other
    images.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项技术中，我们针对某些特征进行识别。使用基于Haar特征的级联进行面部检测是Paul Viola和Michael Jones在2001年发表的论文"*使用简单特征的快速对象检测*"中提出的一种有效对象检测方法。这是一种基于机器学习的方法，其中级联函数针对一组正面和负面的图像进行训练。然后它被用来检测其他图像中的对象。
- en: The algorithm initially needs a lot of positive images. In our case, these are
    images of faces, while negative images which don't contain images of faces. Then
    we need to extract features from it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 算法最初需要大量的正面图像。在我们的案例中，这些是面部图像，而负面的图像则不包含面部图像。然后我们需要从中提取特征。
- en: 'For this purpose, the haar features shown in the following figure are used.
    Each of the features is a single value obtained by subtracting the sum of pixels
    under a white rectangle from sum of pixels under a black rectangle:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，以下图所示的Haar特征被使用。每个特征都是通过从白色矩形下的像素总和减去黑色矩形下的像素总和得到的单个值：
- en: '![](img/6639_04_12.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_04_12.jpg)'
- en: Haar features
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Haar特征
- en: The haar classifiers need to be trained for face, eyes, smile, and so on. OpenCV
    contains a set of predefined classifiers. They are available in the `C:\opencv\build\etc\haarcascades`
    folder. Now that we know how we can approach face detection, we are going to use
    the pre-trained haar classifiers for face detection.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Haar分类器需要针对面部、眼睛、微笑等进行训练。OpenCV包含一系列预定义的分类器。它们位于`C:\opencv\build\etc\haarcascades`文件夹中。既然我们知道如何进行面部检测，我们将使用预训练的Haar分类器进行面部检测。
- en: Code for face detection
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面部检测的代码
- en: 'The following is the code for face detection:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为面部检测的代码：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s look at the code line by line:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看代码：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Import all the required modules:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 导入所有必需的模块：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We select the cascade classifier file. Also we select the video capture device.
    Make sure you mention the path correctly:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择级联分类器文件。同时，我们选择视频捕获设备。确保你正确地提到了路径：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding lines, which are inside the infinite while loop, we read the
    video frame and convert it from RGB to grayscale:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，位于无限循环内部，我们读取视频帧并将其从RGB转换为灰度：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding line is the most important part of the code. We have actually
    applied the operation on the incoming feed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行是代码中最重要的部分。我们实际上已经对传入的流应用了操作。
- en: '`detectMultiScale` consists of three important parameters. It is a general
    function for detecting images and since we are applying the face haar cascade,
    therefore we are detecting faces:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`detectMultiScale`包含三个重要参数。这是一个用于检测图像的通用函数，因为我们正在应用面部Haar级联，所以我们正在检测面部：'
- en: The first parameter is the input image that needs to be processed. Here we have
    passed the grayscale version of the original image.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是需要处理的输入图像。这里我们传递了原始图像的灰度版本。
- en: The second parameter is the scale factor, which provides us with the factor
    for the creation of a scale pyramid. Typically, around 1.01-1.5 is an appropriate
    one. The higher the value, the speed increases, but the accuracy decreases.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是缩放因子，它为我们提供了创建缩放金字塔的因子。通常，大约1.01-1.5是合适的。值越高，速度越快，但准确性降低。
- en: 'The third parameter is `minNeighbours` which affects the quality of the detected
    regions. A higher value results in less detection. A range of 3-6 is good:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是`minNeighbours`，它影响检测区域的质量。较高的值会导致检测减少。3-6的范围是好的：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding lines simply draw rectangles around the faces.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行只是简单地围绕人脸绘制矩形。
- en: Finally, we display the resultant frame and use the keyboard interrupts to release
    the video capture device and destroy the window.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们显示结果帧，并使用键盘中断来释放视频捕获设备并销毁窗口。
- en: 'Now press *F5* to run the code. Initially, it will ask to save the file, and
    then the execution will begin:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按*F5*运行代码。最初，它将要求保存文件，然后执行开始：
- en: '![](img/image_04_017.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_017.png)'
- en: Screenshot of the image window with a face detected
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 检测到人脸的图像窗口截图
- en: Until now, if everything is carried out in a proper way, you must have a brief
    idea about face detection and how it can be accomplished using openCV. But now,
    we need to transfer it to the Intel Edison. Also we need to alter certain parts
    to meet the capabilities of the device as it doesn't have a display unit and above
    all it has a RAM of 1 GB.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果一切操作都按正确的方式进行，你一定对人脸检测及其如何使用OpenCV实现有了大致的了解。但现在，我们需要将其转移到Intel Edison上。同时，我们还需要修改某些部分以适应设备的性能，因为它没有显示单元，最重要的是它只有1GB的RAM。
- en: Intel Edison code
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Intel Edison代码
- en: 'For the Intel Edison, let''s find out what is actually possible. We don''t
    have a display, so we can rely only on console messages and LED, perhaps, for
    visual signals. Next, we may need to optimize the code to run on the Intel Edison.
    But first let''s edit the code discussed previously to include an LED and some
    kind of messages to the picture:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Intel Edison，让我们找出实际上可以实现什么。我们没有显示屏，所以我们可以仅依赖控制台消息和LED，也许，用于视觉信号。接下来，我们可能需要优化代码以在Intel
    Edison上运行。但首先，让我们编辑之前讨论的代码，以包括LED和一些类型的消息到图片中：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Since the Intel Edison has only one USB port, therefore we have mentioned the
    parameter of `cv2.VideoCapture` as `0`. Also notice the following line:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Intel Edison只有一个USB端口，因此我们已将`cv2.VideoCapture`的参数指定为`0`。同时请注意以下行：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You will notice that the parameters have been changed to optimize them for the
    Intel Edison. You can easily tamper with the parameters to get a good result.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到参数已经被更改以优化它们在Intel Edison上的性能。你可以轻松地调整参数以获得良好的结果。
- en: 'We have included some lines for LED on and off:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为LED添加了一些开关行：
- en: '![](img/6639_04_14.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_04_14.png)'
- en: Console output for face detection in images using openCV
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用openCV在图像中进行人脸检测的控制台输出
- en: This is when you begin to notice that the Intel Edison is simply not meant for
    image processing because of the RAM.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这时你开始注意到，由于RAM的限制，Intel Edison根本不适合图像处理。
- en: Now when you are dealing with high processing applications, we cannot rely on
    the processing power of the Intel Edison alone.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在处理高处理应用时，我们不能仅依赖Intel Edison的处理能力。
- en: In those cases, we opt for cloud-based solutions. For cloud-based solutions,
    there are multiple frameworks that exist. One of them is Project Oxford by Microsoft
    ([https://www.microsoft.com/cognitive-services](https://www.microsoft.com/cognitive-services)).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们选择基于云的解决方案。对于基于云的解决方案，存在多个框架。其中之一是微软的Project Oxford([https://www.microsoft.com/cognitive-services](https://www.microsoft.com/cognitive-services))。
- en: Microsoft Cognitive Services provides us with APIs for face detection, recognition,
    speech recognition, and many more. Use the preceding link to learn more about
    them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 微软认知服务为我们提供了人脸检测、识别、语音识别等多个API。使用前面的链接了解更多信息。
- en: 'After all the discussions that we''ve had in this chapter, we now know that
    voice recognition performs reasonably well. However, things are not so good with
    image processing. But why are we focused on using it? The answer lies in that
    the Intel Edison can definitely be used as an image gathering device while other
    processing can be carried out on the cloud:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 经过本章的所有讨论，我们现在知道语音识别表现相当不错。然而，图像处理方面并不理想。但我们为什么关注使用它呢？答案在于英特尔爱迪生确实可以用作图像收集设备，而其他处理可以在云端进行：
- en: '![](img/6639_04_15.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_04_15.jpg)'
- en: Security-based systems architecture at a glance
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一瞥基于安全的系统架构
- en: Processing can either be performed at the device end or at the cloud end. It
    all depends on the use case and the availability of resources.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 处理可以在设备端或云端进行。这完全取决于用例和资源的可用性。
- en: Open-ended task for the reader
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读者开放性任务
- en: The task for this chapter may require a bit of time, but the end result is going
    to be awesome. Implement Microsoft Cognitive Services to perform facial recognition.
    Use the Edison to gather data from the user and send it to the service for processing
    and perform some actions based on the result.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的任务可能需要一些时间，但最终结果将会非常出色。实现微软认知服务以执行面部识别。使用爱迪生从用户那里收集数据并将其发送到服务进行处理，并根据结果执行一些操作。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have learned some techniques of voice recognition
    using the Intel Edison. We also learned how image processing can be done in Python
    and implemented the same on the Intel Edison. Finally, we explored how a real
    life security-based system would look like and an open-ended question for Microsoft
    Cognitive Services.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用英特尔爱迪生进行语音识别的一些技术。我们还学习了如何在Python中执行图像处理，并在英特尔爱迪生上实现了相同的功能。最后，我们探讨了现实生活中的基于安全的系统会是什么样子，以及微软认知服务的一个开放性问题。
- en: '[Chapter 5](45fccd6a-a75e-465d-89dc-dad31f528ac1.xhtml), *Autonomous Robotics
    with Intel Edison*, will be entirely dedicated to robotics and how the Intel Edison
    can be used with robotics. We''ll be covering both autonomous and manual robotics.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五章](45fccd6a-a75e-465d-89dc-dad31f528ac1.xhtml)，《使用英特尔爱迪生的自主机器人》，将完全致力于机器人技术以及如何使用英特尔爱迪生与机器人结合。我们将涵盖自主和手动机器人技术。'
