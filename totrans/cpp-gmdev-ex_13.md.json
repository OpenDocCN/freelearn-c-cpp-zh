["```cpp\n\n#defineGLFW_INCLUDE_VULKAN \n#include<GLFW/glfw3.h> \n\nint main() { \n\n   glfwInit(); \n\n   glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); \n   glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); \n\n   GLFWwindow* window = glfwCreateWindow(1280, 720, \"HELLO VULKAN \", nullptr, nullptr); \n\n   while (!glfwWindowShouldClose(window)) { \n\n         glfwPollEvents(); \n   } \n\n   glfwDestroyWindow(window); \n   glfwTerminate(); \n\n   return 0; \n}\n```", "```cpp\n#pragmaonce \n\n#include<vulkan\\vulkan.h> \n#include<vector> \n#include<iostream> \n\n#defineGLFW_INCLUDE_VULKAN \n#include<GLFW\\glfw3.h> \n\nclassAppValidationLayersAndExtensions { \n\npublic: \n   AppValidationLayersAndExtensions(); \n   ~AppValidationLayersAndExtensions(); \n\n   const std::vector<constchar*> requiredValidationLayers = { \n         \"VK_LAYER_LUNARG_standard_validation\" \n   }; \n\n   bool checkValidationLayerSupport(); \n   std::vector<constchar*>getRequiredExtensions\n     (boolisValidationLayersEnabled); \n\n   // Debug Callback \n   VkDebugReportCallbackEXT callback; \n\n   void setupDebugCallback(boolisValidationLayersEnabled, \n      VkInstancevkInstance); \n   void destroy(VkInstanceinstance, boolisValidationLayersEnabled); \n\n   // Callback \n\n* pCreateInfo, VkResultcreateDebugReportCallbackEXT( \n       VkInstanceinstance, \n       constVkDebugReportCallbackCreateInfoEXT         \n       constVkAllocationCallbacks* pAllocator, \n       VkDebugReportCallbackEXT* pCallback) { \n\n         auto func = (PFN_vkCreateDebugReportCallbackEXT)\n                     vkGetInstanceProcAddr(instance, \n                     \"vkCreateDebugReportCallbackEXT\"); \n\n         if (func != nullptr) { \n               return func(instance, pCreateInfo, pAllocator, pCallback); \n         } \n         else { \n               returnVK_ERROR_EXTENSION_NOT_PRESENT; \n         } \n\n   } \n\n   void DestroyDebugReportCallbackEXT( \n         VkInstanceinstance, \n         VkDebugReportCallbackEXTcallback, \n         constVkAllocationCallbacks* pAllocator) { \n\n         auto func = (PFN_vkDestroyDebugReportCallbackEXT)\n                     vkGetInstanceProcAddr(instance, \n                     \"vkDestroyDebugReportCallbackEXT\"); \n         if (func != nullptr) { \n               func(instance, callback, pAllocator); \n         } \n   } \n\n}; \n```", "```cpp\nAppValidationLayersAndExtensions::AppValidationLayersAndExtensions(){} \n\nAppValidationLayersAndExtensions::~AppValidationLayersAndExtensions(){} \nThen we add the implementation to checkValidationLayerSupport(). \n\nbool AppValidationLayersAndExtensions::checkValidationLayerSupport() { \n\n   uint32_t layerCount; \n\n   // Get count of validation layers available \n   vkEnumerateInstanceLayerProperties(&layerCount, nullptr); \n\n   // Get the available validation layers names  \n   std::vector<VkLayerProperties>availableLayers(layerCount); \n   vkEnumerateInstanceLayerProperties(&layerCount,\n   availableLayers.data()); \n\n   for (const char* layerName : requiredValidationLayers) { //layers we\n   require \n\n         // boolean to check if the layer was found \n         bool layerFound = false; \n\n         for (const auto& layerproperties : availableLayers) { \n\n               // If layer is found set the layar found boolean to true \n               if (strcmp(layerName, layerproperties.layerName) == 0) { \n                     layerFound = true; \n                     break; \n               } \n         } \n\n         if (!layerFound) { \n               return false; \n         } \n\n         return true; \n\n   } \n\n}\n```", "```cpp\nstd::vector<constchar*>AppValidationLayersAndExtensions::getRequiredExtensions(boolisValidationLayersEnabled) { \n\n   uint32_t glfwExtensionCount = 0; \n   constchar** glfwExtensions; \n\n   // Get extensions \n   glfwExtensions = glfwGetRequiredInstanceExtensions\n                    (&glfwExtensionCount); \n\n   std::vector<constchar*>extensions(glfwExtensions, glfwExtensions \n     + glfwExtensionCount); \n\n   //debug report extention is added. \n\n   if (isValidationLayersEnabled) { \n         extensions.push_back(\"VK_EXT_debug_report\"); \n   } \n\n   return extensions; \n}\n```", "```cpp\n staticVKAPI_ATTRVkBool32VKAPI_CALL debugCallback( \n   VkDebugReportFlagsEXTflags, \n   VkDebugReportObjectTypeEXTobjExt, \n   uint64_tobj, \n   size_tlocation, \n   int32_tcode, \n   constchar* layerPrefix, \n   constchar* msg, \n   void* userData) { \n\n   std::cerr <<\"validation layer: \"<<msg<< std::endl << std::endl; \n\n   returnfalse; \n\n} \n```", "```cpp\nvoidAppValidationLayersAndExtensions::setupDebugCallback(boolisValidationLayersEnabled, VkInstancevkInstance) { \n\n   if (!isValidationLayersEnabled) { \n         return; \n   } \n\n   printf(\"setup call back \\n\"); \n\n   VkDebugReportCallbackCreateInfoEXT info = {}; \n\n   info.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT\n                _CALLBACK_CREATE_INFO_EXT; \n   info.flags = VK_DEBUG_REPORT_ERROR_BIT_EXT | \n                VK_DEBUG_REPORT_WARNING_BIT_EXT; \n   info.pfnCallback = debugCallback; // callback function \n\n   if (createDebugReportCallbackEXT(vkInstance, &info, nullptr, \n     &callback) != VK_SUCCESS) { \n\n         throw std::runtime_error(\"failed to set debug callback!\"); \n   } \n\n} \n\n```", "```cpp\nvoidAppValidationLayersAndExtensions::destroy(VkInstanceinstance, boolisValidationLayersEnabled){ \n\n   if (isValidationLayersEnabled) { \n         DestroyDebugReportCallbackEXT(instance, callback, nullptr); \n   } \n\n} \n```", "```cpp\n#pragmaonce \n#include<vulkan\\vulkan.h> \n\n#include\"AppValidationLayersAndExtensions.h\" \n\nclassVulkanInstance \n{ \npublic: \n   VulkanInstance(); \n   ~VulkanInstance(); \n\n   VkInstance vkInstance; \n\n   void createAppAndVkInstance(,boolenableValidationLayers  \n        AppValidationLayersAndExtensions *valLayersAndExtentions); \n\n};  \n```", "```cpp\n#include\"VulkanInstance.h\" \n\nVulkanInstance::VulkanInstance(){} \n\nVulkanInstance::~VulkanInstance(){}\n```", "```cpp\nvoidVulkanInstance::createAppAndVkInstance(boolenableValidationLayers, AppValidationLayersAndExtensions *valLayersAndExtentions) { \n\n   // links the application to the Vulkan library \n\n   VkApplicationInfo appInfo = {}; \n   appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO; \n   appInfo.pApplicationName = \"Hello Vulkan\"; \n   appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0); \n   appInfo.pEngineName = \"SidTechEngine\"; \n   appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0); \n   appInfo.apiVersion = VK_API_VERSION_1_0; \n\n   VkInstanceCreateInfo vkInstanceInfo = {}; \n   vkInstanceInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; \n   vkInstanceInfo.pApplicationInfo = &appInfo; \n\n   // specify extensions and validation layers \n   // these are global meaning they are applicable to whole program \n      not just the device \n\n   auto extensions = valLayersAndExtentions->\n                   getRequiredExtensions(enableValidationLayers); \n\n   vkInstanceInfo.enabledExtensionCount = static_cast<uint32_t>\n      (extensions.size());; \n   vkInstanceInfo.ppEnabledExtensionNames = extensions.data(); \n\n   if (enableValidationLayers) { \n     vkInstanceInfo.enabledLayerCount = static_cast<uint32_t>\n     (valLayersAndExtentions->requiredValidationLayers.size()); \n     vkInstanceInfo.ppEnabledLayerNames = \n     valLayersAndExtentions->requiredValidationLayers.data(); \n   } \n   else { \n         vkInstanceInfo.enabledLayerCount = 0; \n   } \n  if (vkCreateInstance(&vkInstanceInfo, nullptr, &vkInstance) !=\n   VK_SUCCESS) {\n   throw std::runtime_error(\"failed to create vkInstance \");\n  }\n}   \n```", "```cpp\n#defineGLFW_INCLUDE_VULKAN \n#include<GLFW\\glfw3.h> \n\n#include<vulkan\\vulkan.h> \n\n#include\"AppValidationLayersAndExtensions.h\" \n#include\"VulkanInstance.h\" \n```", "```cpp\n#ifdef _DEBUG \nboolconstbool isValidationLayersEnabled = true; \n#else \nconstbool isValidationLayersEnabled = false; \n#endif \n```", "```cpp\nclassVulkanContext { \n\npublic: \n\nstaticVulkanContextn* instance;   \nstaticVulkanContext* getInstance(); \n\n   ~VulkanContext(); \n\n   void initVulkan(); \n\nprivate: \n\n   // My Classes \n   AppValidationLayersAndExtensions *valLayersAndExt; \n   VulkanInstance* vInstance; \n\n};\n```", "```cpp\n#include\"VulkanContext.h\" \n\nVulkanContext* VulkanContext::instance = NULL; \n\nVulkanContext* VulkanContext::getInstance() { \n\n   if (!instance) { \n         instance = newVulkanContext(); \n   } \n   return instance; \n} \n\nVulkanContext::~VulkanContext(){ \n```", "```cpp\nvoidVulkanContext::initVulkan() { \n\n   // Validation and Extension Layers \n   valLayersAndExt = newAppValidationLayersAndExtensions(); \n\n   if (isValidationLayersEnabled && !valLayersAndExt->\n     checkValidationLayerSupport()) { \n         throw std::runtime_error(\"Validation Layers \n           Not Available !\"); \n   } \n\n   // Create App And Vulkan Instance() \n   vInstance = newVulkanInstance(); \n   vInstance->createAppAndVkInstance(isValidationLayersEnabled, \n      valLayersAndExt); \n\n   // Debug CallBack \n   valLayersAndExt->setupDebugCallback(isValidationLayersEnabled, \n     vInstance->vkInstance); \n\n}  \n```", "```cpp\n #defineGLFW_INCLUDE_VULKAN \n#include<GLFW/glfw3.h> \n\n#include\"VulkanContext.h\" \n\nint main() { \n\n   glfwInit(); \n\n   glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); \n   glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); \n\n   GLFWwindow* window = glfwCreateWindow(1280, 720, \"HELLO VULKAN \", \n                        nullptr, nullptr); \n\n   VulkanContext::getInstance()->initVulkan(); \n\n   while (!glfwWindowShouldClose(window)) { \n\n         glfwPollEvents(); \n   }               \n\n   glfwDestroyWindow(window); \n   glfwTerminate(); \n\n   return 0; \n}\n```", "```cpp\nprivate: \n\n   //surface \n   VkSurfaceKHR surface; \n\n```", "```cpp\n   void initVulkan(GLFWwindow* window); \n\n```", "```cpp\n void VulkanContext::initVulkan(GLFWwindow* window) { \n\n   // -- Platform Specific \n\n   // Validation and Extension Layers \n   valLayersAndExt = new AppValidationLayersAndExtensions(); \n\n   if (isValidationLayersEnabled && !valLayersAndExt->\n      checkValidationLayerSupport()) { \n         throw std::runtime_error(\"Requested Validation Layers\n            Not Available !\"); \n   } \n\n   // Create App And Vulkan Instance() \n   vInstance = new VulkanInstance(); \n   vInstance->createAppAndVkInstance(isValidationLayersEnabled, \n     valLayersAndExt); \n\n   // Debug CallBack \n   valLayersAndExt->setupDebugCallback(isValidationLayersEnabled, \n    vInstance->vkInstance); \n\n   // Create Surface \n   if (glfwCreateWindowSurface(vInstance->vkInstance, window, \n      nullptr, &surface) != VK_SUCCESS) { \n\n         throw std::runtime_error(\" failed to create window \n           surface !\"); \n   } \n} \n\n```", "```cpp\n   GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, \n                        \"HELLO VULKAN \", nullptr, nullptr); \n\n   VulkanContext::getInstance()->initVulkan(window); \n```", "```cpp\n#include<vulkan\\vulkan.h> \n#include<stdexcept> \n\n#include<iostream> \n#include<vector> \n#include<set> \n\n#include\"VulkanInstance.h\" \n#include\"AppValidationLayersAndExtensions.h\" \n```", "```cpp\nstructSwapChainSupportDetails { \n\n   VkSurfaceCapabilitiesKHR surfaceCapabilities; // size and images \n                                                  in swapchain \n   std::vector<VkSurfaceFormatKHR> surfaceFormats; \n   std::vector<VkPresentModeKHR> presentModes; \n}; \n```", "```cpp\nstructQueueFamilyIndices { \n\n   int graphicsFamily = -1; \n   int presentFamily = -1; \n\n   bool arePresent() { \n         return graphicsFamily >= 0 && presentFamily >= 0; \n   } \n}; \n```", "```cpp\n { \n\npublic: \n\n   Device(); \n   ~Device();  \n```", "```cpp\n   VkPhysicalDevice physicalDevice; \n   SwapChainSupportDetails swapchainSupport; \n   QueueFamilyIndices queueFamiliyIndices; \n\n```", "```cpp\nstd::vector<constchar*>deviceExtensions = { VK_KHR_SWAPCHAIN_EXTENSION_NAME };\n```", "```cpp\n   void pickPhysicalDevice (VulkanInstance* vInstance, \n     VkSurfaceKHR surface); \n\n   bool isDeviceSuitable(VkPhysicalDevice device, \n     VkSurfaceKHR surface); \n\n   bool checkDeviceExtensionSupported(VkPhysicalDevice device) ; \n   SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice \n      device, VkSurfaceKHR surface); \n   QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device, \n      VkSurfaceKHR surface); \n```", "```cpp\n QueueFamilyIndicesgetQueueFamiliesIndicesOfCurrentDevice();  \n```", "```cpp\n   // ++++++++++++++ \n   // Logical device \n   // ++++++++++++++ \n\n   void createLogicalDevice(VkSurfaceKHRsurface, \n      boolisValidationLayersEnabled, AppValidationLayersAndExtensions \n      *appValLayersAndExtentions); \n\n   VkDevice logicalDevice; \n\n   // handle to the graphics queue from the queue families of the gpu \n   VkQueue graphicsQueue; // we can also have seperate queue for \n                            compute, memory transfer, etc. \n   VkQueue presentQueue; // queue for displaying the framebuffer \n\n   void destroy(); \n}; // End of Device class\n```", "```cpp\n#include\"Device.h\" \n\nDevice::Device(){} \n\nDevice::~Device(){ \n\n} \n```", "```cpp\n\nvoidDevice::pickPhysicalDevice(VulkanInstance* vInstance, VkSurfaceKHRsurface) { \n\n   uint32_t deviceCount = 0; \n\n   vkEnumeratePhysicalDevices(vInstance->vkInstance, &deviceCount, \n      nullptr); \n\n   if (deviceCount == 0) { \n         throw std::runtime_error(\"failed to find GPUs with vulkan \n           support !\"); \n   } \n\n   std::cout <<\"Device Count: \"<< deviceCount << std::endl; \n\n   std::vector<VkPhysicalDevice>devices(deviceCount); \n   vkEnumeratePhysicalDevices(vInstance->vkInstance, &deviceCount, \n      devices.data()); \n\n   std::cout << std::endl; \n   std::cout <<\"DEVICE PROPERTIES\"<< std::endl; \n   std::cout <<\"=================\"<< std::endl; \n\n   for (constauto& device : devices) { \n\n         VkPhysicalDeviceProperties  deviceProperties; \n\n         vkGetPhysicalDeviceProperties(device, &deviceProperties); \n\n         std::cout << std::endl; \n         std::cout <<\"Device name: \"<< deviceProperties.deviceName \n                   << std::endl; \n\n         if (isDeviceSuitable(device, surface)) \n               physicalDevice = device; \n\n   break; \n\n   } \n\n   if (physicalDevice == VK_NULL_HANDLE) { \n         throw std::runtime_error(\"failed to find suitable GPU !\"); \n   } \n\n} \n```", "```cpp\nbool Device::isDeviceSuitable(VkPhysicalDevice device, VkSurfaceKHR \n   surface)  { \n\n   // find queue families the device supports \n\n   QueueFamilyIndices qFamilyIndices = findQueueFamilies(device, \n                                       surface); \n\n   // Check device extentions supported \n   bool extensionSupported = checkDeviceExtensionSupported(device); \n\n   bool swapChainAdequate = false; \n\n   // If swapchain extension is present  \n   // Check surface formats and presentation modes are supported \n   if (extensionSupported) { \n\n         swapchainSupport = querySwapChainSupport(device, surface); \n         swapChainAdequate = !swapchainSupport.surfaceFormats.empty() \n                             && !swapchainSupport.presentModes.empty(); \n\n   } \n\n   VkPhysicalDeviceFeatures supportedFeatures; \n   vkGetPhysicalDeviceFeatures(device, &supportedFeatures); \n\n   return qFamilyIndices.arePresent() && extensionSupported && \n     swapChainAdequate && supportedFeatures.samplerAnisotropy; \n\n} \n\n```", "```cpp\nQueueFamilyIndicesDevice::findQueueFamilies(VkPhysicalDevicedevice, VkSurfaceKHRsurface) { \n\n   uint32_t queueFamilyCount = 0; \n\n   vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, \n      nullptr); \n\n   std::vector<VkQueueFamilyProperties>queueFamilies(queueFamilyCount); \n\n   vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, \n      queueFamilies.data()); \n\n   int i = 0; \n\n   for (constauto& queueFamily : queueFamilies) { \n\n         if (queueFamily.queueCount > 0 && queueFamily.queueFlags \n           &VK_QUEUE_GRAPHICS_BIT) { \n               queueFamiliyIndices.graphicsFamily = i; \n         } \n\n         VkBool32 presentSupport = false; \n         vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, \n           &presentSupport); \n\n         if (queueFamily.queueCount > 0 && presentSupport) { \n               queueFamiliyIndices.presentFamily = i; \n         } \n\n         if (queueFamiliyIndices.arePresent()) { \n               break; \n         } \n\n         i++; \n   } \n\n   return queueFamiliyIndices; \n}\n```", "```cpp\n boolDevice::checkDeviceExtensionSupported(VkPhysicalDevicedevice){ \n\n   uint32_t extensionCount; \n\n   // Get available device extentions count \n   vkEnumerateDeviceExtensionProperties(device, nullptr, \n     &extensionCount, nullptr); \n\n   // Get available device extentions \n   std::vector<VkExtensionProperties>availableExtensions(extensionCount); \n\n   vkEnumerateDeviceExtensionProperties(device, nullptr,  \n     &extensionCount, availableExtensions.data()); \n\n   // Populate with required device exentions we need \n   std::set<std::string>requiredExtensions(deviceExtensions.begin(), \n     deviceExtensions.end()); \n\n   // Check if the required extention is present \n   for (constauto& extension : availableExtensions) { \n         requiredExtensions.erase(extension.extensionName); \n   } \n\n   // If device has the required device extention then return  \n   return requiredExtensions.empty(); \n} \n\n```", "```cpp\nSwapChainSupportDetailsDevice::querySwapChainSupport\n   (VkPhysicalDevicedevice, VkSurfaceKHRsurface) { \n\n   SwapChainSupportDetails details; \n\n   vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, \n      &details.surfaceCapabilities); \n\n   uint32_t formatCount; \n   vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, \n      nullptr); \n\n   if (formatCount != 0) { \n         details.surfaceFormats.resize(formatCount); \n         vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, \n            &formatCount, details.surfaceFormats.data()); \n   } \n\n   uint32_t presentModeCount; \n   vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, \n     &presentModeCount, nullptr); \n\n   if (presentModeCount != 0) { \n\n         details.presentModes.resize(presentModeCount); \n         vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, \n           &presentModeCount, details.presentModes.data()); \n   } \n\n   return details; \n} \n```", "```cpp\nQueueFamilyIndicesDevice::getQueueFamiliesIndicesOfCurrentDevice() { \n\n   return queueFamiliyIndices; \n} \n```", "```cpp\nvoid Device::createLogicalDevice(VkSurfaceKHRsurface, boolisValidationLayersEnabled, AppValidationLayersAndExtensions *appValLayersAndExtentions) { \n\n   // find queue families like graphics and presentation \n   QueueFamilyIndices indices = findQueueFamilies(physicalDevice, \n          surface); \n\n   std::vector<VkDeviceQueueCreateInfo> queueCreateInfos; \n\n   std::set<int> uniqueQueueFamilies = { indices.graphicsFamily, \n                                       indices.presentFamily }; \n\n   float queuePriority = 1.0f; \n\n   for (int queueFamily : uniqueQueueFamilies) { \n\n         VkDeviceQueueCreateInfo queueCreateInfo = {}; \n         queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE\n                                 _QUEUE_CREATE_INFO; \n         queueCreateInfo.queueFamilyIndex = queueFamily; \n         queueCreateInfo.queueCount = 1; // we only require 1 queue \n         queueCreateInfo.pQueuePriorities = &queuePriority; \n         queueCreateInfos.push_back(queueCreateInfo); \n   } \n```", "```cpp\n //specify device features  \n   VkPhysicalDeviceFeatures deviceFeatures = {};  \n\n   deviceFeatures.samplerAnisotropy = VK_TRUE; \n\n```", "```cpp\n   VkDeviceCreateInfo createInfo = {}; \n   createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; \n   createInfo.pQueueCreateInfos = queueCreateInfos.data(); \n   createInfo.queueCreateInfoCount = static_cast<uint32_t>\n                                     (queueCreateInfos.size()); \n\n   createInfo.pEnabledFeatures = &deviceFeatures; \n   createInfo.enabledExtensionCount = static_cast<uint32_t>\n     (deviceExtensions.size()); \n   createInfo.ppEnabledExtensionNames = deviceExtensions.data(); \n\n   if (isValidationLayersEnabled) { \n      createInfo.enabledLayerCount = static_cast<uint32_t>(appValLayersAndExtentions->requiredValidationLayers.size()); \n      createInfo.ppEnabledLayerNames = appValLayersAndExtentions->\n                               requiredValidationLayers.data(); \n   } \n   else { \n         createInfo.enabledLayerCount = 0; \n   } \n\n   //create logical device \n\n   if (vkCreateDevice(physicalDevice, &createInfo, nullptr, \n      &logicalDevice) != VK_SUCCESS) { \n         throw std::runtime_error(\"failed to create logical \n            device !\"); \n   }\n```", "```cpp\n//get handle to the graphics queue of the gpu \nvkGetDeviceQueue(logicalDevice, indices.graphicsFamily, 0, \n&graphicsQueue); \n\n//get handle to the presentation queue of the gpu \nvkGetDeviceQueue(logicalDevice, indices.presentFamily, 0, &presentQueue); \n\n}  \n```", "```cpp\n// My Classes\n   AppValidationLayersAndExtensions *valLayersAndExt; \n   VulkanInstance* vInstance; \n   Device* device; \n```", "```cpp\ndevice = new Device(); \ndevice->pickPhysicalDevice(vInstance, surface); \ndevice->createLogicalDevice(surface, isValidationLayersEnabled,\n   valLayersAndExt);   \n```"]