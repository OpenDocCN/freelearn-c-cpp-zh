["```cpp\n#include \"stm32f4xx_hal.h\"\nGPIO_InitTypeDef GPIO_InitStruct = {0};\n// Enable the GPIOA Clock\n__HAL_RCC_GPIOA_CLK_ENABLE();\n// Configure the GPIO pin\nGPIO_InitStruct.Pin = GPIO_PIN_5;\nGPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;\nHAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n```", "```cpp\n#include \"stm32f4xx_ll_bus.h\"\n#include \"stm32f4xx_ll_gpio.h\"\n// Enable the GPIOA Clock\nLL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);\n// Configure the GPIO pin\nLL_GPIO_SetPinMode(GPIOA,LL_GPIO_PIN_5,LL_GPIO_MODE_OUTPUT);\n```", "```cpp\n#define GPIOA_MODER (*(volatile unsigned long *)(GPIOA_BASE + 0x00))\n#define RCC_AHB1ENR (*(volatile unsigned long *)(RCC_BASE + 0x30))\n// Enable clock for GPIOA\nRCC_AHB1ENR |= (1 << 0);\n// Set PA5 to output mode\nGPIOA_MODER |= (1 << 10); // Set bit 10 (MODER5[1])\n```", "```cpp\nEQU GPIOA_MODER, 0x40020000\nEQU RCC_AHB1ENR, 0x40023800\n; Enable clock for GPIOA\nLDR R0, =RCC_AHB1ENR\nLDR R1, [R0]\nORR R1, R1, #(1 << 0)\nSTR R1, [R0]\n; Set PA5 as output\nLDR R0, =GPIOA_MODER\nLDR R1, [R0]\nORR R1, R1, #(1 << 10)\nSTR R1, [R0]\n```", "```cpp\nregister |= 1 << bit_position;\n```", "```cpp\n0011: original register value\n(0001 <<2) = 0100: bit-shifted value\n0011\nOR\n0100\n------\n0111 (resulting value)\n```", "```cpp\nregister &= ~(1 << bit_position);\n```", "```cpp\n0111: original register value\n(0001 << 2) = 0100: bit-shifted value\n~0100 = 1011: bitwise NOT of bit-shifted value\n0111\nAND\n1011\n----\n0011 (resulting value)\n```", "```cpp\n    GPIOA_ODR |= 1 << 5;\n    ```", "```cpp\n//  1: Define base address for peripherals\n#define PERIPH_BASE        (0x40000000UL)\n//  2: Offset for AHB1 peripheral bus\n#define AHB1PERIPH_OFFSET  (0x00020000UL)\n//  3: Base address for AHB1 peripherals\n#define AHB1PERIPH_BASE    (PERIPH_BASE + AHB1PERIPH_OFFSET)\n//  4: Offset for GPIOA\n#define GPIOA_OFFSET       (0x0000UL)\n//  5: Base address for GPIOA\n#define GPIOA_BASE         (AHB1PERIPH_BASE + GPIOA_OFFSET)\n//  6: Offset for RCC\n#define RCC_OFFSET         (0x3800UL)\n//  7: Base address for RCC\n#define RCC_BASE           (AHB1PERIPH_BASE + RCC_OFFSET)\n//  8: Offset for AHB1EN register\n#define AHB1EN_R_OFFSET    (0x30UL)\n//  9: Address of AHB1EN register\n#define RCC_AHB1EN_R  (*(volatile unsigned int *)(RCC_BASE +  AHB1EN_R_OFFSET))\n//  10: Offset for mode register\n#define MODE_R_OFFSET      (0x00UL)\n//  11: Address of GPIOA mode register\n#define GPIOA_MODE_R  (*(volatile unsigned int *)(GPIOA_BASE + MODE_R_OFFSET))\n//  12: Offset for output data register\n#define OD_R_OFFSET   (0x14UL)\n//  13: Address of GPIOA output data register\n#define GPIOA_OD_R    (*(volatile unsigned int *)(GPIOA_BASE +  OD_R_OFFSET))\n//  14: Bit mask for enabling GPIOA (bit 0)\n#define GPIOAEN       (1U<<0)\n//  15: Bit mask for GPIOA pin 5\n#define PIN5          (1U<<5)\n//  16: Alias for PIN5 representing LED pin\nUL suffix at the end of each hexadecimal value as well as the use of keywords such as volatile. Let’s delve into the significance of these in the context of C and C++ programming.\n\t\t\tThe UL suffix\n\t\t\tWhen we see a number in the code ending with `UL`, it’s more than just a part of the number – it’s a clear instruction to the compiler about the type and size of the number:\n\n\t\t\t\t*   `U` in `UL` indicates that the number is unsigned. In other words, it’s a positive number with no sign to indicate it could be negative. This designation allows the number to represent a wider range of positive values compared to a signed integer of the same size.\n\t\t\t\t*   `L` signifies that the number is a long integer. This is important because the size of a long integer can vary based on the system and the compiler. Typically, a long integer is larger than a regular int – often 32 bits, but sometimes 64 bits on certain systems.\n\n\t\t\tThe `UL` suffix collectively ensures that these values are treated as unsigned long integers. This is important for firmware development and other forms of low-level programming, where the exact size and “signedness” of an integer can significantly impact program behavior and memory management. Using `UL` leads to more predictable, platform-independent code, ensuring that the values behave consistently across different compilers and systems.\n\t\t\tThe use of “(*(volatile unsigned int *)”\n\t\t\tIn the context of bare-metal programming, particularly in our current code snippet, we notice that the address of each register is prefixed with `\"(*(volatile unsigned` `int *)\".`\n\t\t\tLet’s break down what each part of this notation means and why it’s used:\n\n\t\t\t\t*   `(unsigned int *)` expression is a **type cast**. It tells the compiler to treat the subsequent address as a pointer to an unsigned integer. In C and C++, pointers are variables that store the memory address of another variable. In the context of our firmware, this casting means that we are directing the compiler to treat a certain address as the location of an unsigned integer. However, this unsigned integer is not just any number; it corresponds directly to the state of a 32-bit hardware register. Each bit in this 32-bit integer mirrors a specific bit in the register, thereby allowing direct control and monitoring of the hardware’s state through standard programming constructs.\n\t\t\t\t*   `*`) in `*(unsigned int *)` is used to dereference the pointer. Dereferencing a pointer means accessing the value stored at the memory address the pointer is pointing to. Essentially, it’s not just about knowing where the data is (the address); it’s about actually accessing and using that data.\n\t\t\t\t*   `volatile`: The `volatile` keyword tells the compiler that the value at the pointer can change at any time, without any action being taken by the code. This is often the case with hardware registers, where the value can change due to hardware events, external inputs, or other aspects of the system outside the program’s control.\n\n\t\t\tWithout `volatile`, the compiler might optimize out certain reads and writes to these addresses under the assumption that the values don’t change unexpectedly. This is because when a compiler processes code, it looks for ways to make the program run more efficiently. This includes removing redundant operations or simplifying code paths. This process occurs during the compilation of the program before it’s run. If the compiler determines that a variable (including a memory-mapped hardware register) doesn’t change its value, it might optimize the code by eliminating repeated reads from or writes to that variable. For example, if a value is read from a register and then read again later, the compiler might assume the value hasn’t changed and use the previously read value instead of accessing the register a second time. The use of `volatile` is a directive to tell the compiler not to apply certain optimizations to accesses of the marked variable, maintaining the integrity of operations.\n\t\t\tIn our code snippet, we encounter two additional terms that are very common in bare-metal programming: **bit mask** and **alias**. Let’s take a closer look at each of these concepts to gain a clearer understanding of the roles they play:\n\n\t\t\t\t*   `AND`, `OR`, `XOR`) along with the mask to achieve the desired result. For example, a bit mask might be used to turn on a specific LED connected to a microcontroller pin without altering the state of other pins. A bit mask is created by setting the bits we want to manipulate to `1` while keeping others at `0`. This mask is then combined with the register value using the appropriate bitwise operation.\n\n    For example, a `0b00000100` mask used with `OR` will set the third bit of the target register.\n\n\t\t\t\t*   `LED_PIN` makes the code self-explanatory. We define aliases using preprocessor directives such as `#define` in C or C++. For example, `#define LED_PIN (1U<<5)` creates an `LED_PIN` alias for the bit mask that represents the sixth pin (zero indexing) in a GPIO port ODR.\n\n\t\t\tNow, let’s analyze the second section of the code.\n\t\t\tMain Function\n\t\t\tThis section of our code outlines the primary operations for controlling the LED connected to PA5 of the microcontroller:\n\n```", "```cpp\n\n\t\t\tLet’s break down each part of the code for a clearer understanding:\n\n\t\t\t\t*   *Line 17*: This marks the beginning of the main function. This is the entry point of our program where the execution starts:\n\n    ```", "```cpp\n\n    \t\t\t\t*   *Line 18*: This enables the clock for `GPIOA`. As we learned earlier, the `RCC_AHB1EN_R` register controls the clock to the `AHB1` bus peripherals. The `|= GPIOAEN` operation sets the bit associated with GPIOA (GPIOAEN) in the `RCC_AHB1EN_R` register, ensuring that the GPIOA peripheral has the necessary clock enabled for its operations:\n\n    ```", "```cpp\n\n    \t\t\t\t*   *Line 19–20*: These lines configure `PA5` as an output pin. Setting bit 10 to `1` and bit 11 to `0` in `GPIOA_MODE_R` configures `PA5` in general-purpose output mode:\n\n    ```", "```cpp\n\n    \t\t\t\t*   *Line 21–23*: These lines initiate an infinite loop, which is a common practice in embedded systems for continuous operation:\n\n    ```", "```cpp\n\n    This is what is inside this loop:\n\n    *   *Line 22*: This line sets PA5 high. This is achieved by setting the respective bit in `GPIOA_OD_R`. The `|= LED_PIN` operation ensures that PA5 outputs a high signal (essentially turning the LED on).\n    *   *Line 24*: This marks the end of the main function:\n\n        ```", "```cpp\n\n\t\t\tNow that we have a clear understanding of each line of the code, let’s proceed to enter the entire code into the `main.c` file. Additionally, for your convenience, this complete source code is available in the GitHub repository for the book. You can find it in the folder titled `Chapter2`.\n\t\t\tThis is the entire code:\n\n```", "```cpp\n\n\t\t\tTo build the project, first select it by clicking on the project name once, and then initiate the build process by clicking on the *build* icon, represented by a hammer symbol, in the IDE.\n\t\t\t![Figure 2.20: The build and run icons](img/B21914_02_20.jpg)\n\n\t\t\tFigure 2.20: The build and run icons\n\t\t\tOnce the build process is complete, the next step involves uploading the program to the microcontroller. To do this, we make sure the project is selected in the IDE, and then initiate the upload by clicking on the *run* icon, represented by a play symbol.\n\t\t\tThe first time you run the program, the IDE may prompt you to edit or confirm the launch configurations. A dialog box titled **Edit Configurations** will appear. It’s sufficient to accept the default settings by clicking **OK**. *Figure 2**.21* shows the **Edit Configuration** dialog box.\n\t\t\t![Figure 2.21: The Edit Configuration dialog box](img/B21914_02_21.jpg)\n\n\t\t\tFigure 2.21: The Edit Configuration dialog box\n\t\t\tFollowing this confirmation, the IDE will commence the process of uploading your program to the microcontroller. When the upload is complete, you should see the green LED on the development board light up. This indicates that our bare-metal code is functioning as intended and successfully controlling the hardware.\n\t\t\tWe have now mastered configuring PA5 to control the LED, starting from the very basics of consulting the documentation for accurate addresses, effectively typecasting these addresses for register access, and creating aliases for specific bits within the registers.\n\t\t\tSummary\n\t\t\tIn this chapter, we delved into the core of bare-metal programming, emphasizing the direct interaction with microcontroller registers. This gave us insight into some of the key registers of our microcontroller and the structure of those registers.\n\t\t\tWe began by exploring various firmware development approaches, each offering a distinct level of abstraction. These approaches included the HAL, LL, Bare-Metal C programming, and the assembly language. This exploration helped us understand the trade-offs and applications of each approach in firmware development.\n\t\t\tWe spent a significant part of the chapter defining addresses of some peripherals using the official documentation. This step was important in creating addresses for various registers within those peripherals. It involved gathering specific memory addresses, typecasting them for register access, and creating aliases for bits in the registers.\n\t\t\tThe chapter culminated in a practical application where we configured PA5 to control the User LED on the development board. This exercise integrated the concepts discussed throughout the chapter, showcasing how theoretical knowledge can be applied in real-world firmware programming.\n\t\t\tIn the upcoming chapter, we will delve into the build process. This exploration will allow us to understand the sequential stages that our source code undergoes to become an executable program capable of running on our microcontroller.\n\n```"]