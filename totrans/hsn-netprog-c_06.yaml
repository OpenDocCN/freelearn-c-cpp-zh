- en: Hostname Resolution and DNS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机名解析和 DNS
- en: Hostname resolution is a vital part of network programming. It allows us to
    use simple names, such as `www.example.com`, instead of tedious addresses such
    as `::ffff:192.168.212.115`. The mechanism that allows us to resolve hostnames
    into IP addresses and IP addresses into hostnames is the **Domain Name System**
    (**DNS**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 主机名解析是网络编程的一个关键部分。它允许我们使用简单的名称，如 `www.example.com`，而不是像 `::ffff:192.168.212.115`
    这样繁琐的地址。将主机名解析为 IP 地址以及将 IP 地址解析为主机名的机制是 **域名系统** (**DNS**)。
- en: In this chapter, we begin by covering the built-in `getaddrinfo()` and `getnameinfo()` socket
    functions in more depth. Later, we will build a program that does DNS queries
    using **User Datagram Protocol** (**UDP**) from scratch.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先深入介绍内置的 `getaddrinfo()` 和 `getnameinfo()` 网络套接字函数。稍后，我们将从头开始构建一个使用
    **用户数据报协议** (**UDP**) 进行 DNS 查询的程序。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: How DNS works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS 的工作原理
- en: Common DNS record types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的 DNS 记录类型
- en: The `getaddrinfo()` and `getnameinfo()` functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getaddrinfo()` 和 `getnameinfo()` 函数'
- en: DNS query data structures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS 查询数据结构
- en: DNS UDP protocol
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS UDP 协议
- en: DNS TCP fallback
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS TCP 回退
- en: Implementing a DNS query program
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个 DNS 查询程序
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example programs from this chapter can be compiled with any modern C compiler.
    We recommend MinGW on Windows and GCC on Linux and macOS. See Appendices B, C,
    and D for compiler setup.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例程序可以用任何现代 C 编译器编译。我们推荐在 Windows 上使用 MinGW，在 Linux 和 macOS 上使用 GCC。有关编译器设置，请参阅附录
    B、C 和 D。
- en: The code for this book can be found at [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码可以在 [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)
    找到。
- en: 'From the command line, you can download the code for this chapter with the
    following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，你可以使用以下命令下载本章的代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each example program in this chapter runs on Windows, Linux, and macOS. When
    compiling on Windows, each example program should be linked with the Winsock library.
    This can be accomplished by passing the `-lws2_32` option to `gcc`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个示例程序都在 Windows、Linux 和 macOS 上运行。在 Windows 上编译时，每个示例程序都应该与 Winsock 库链接。这可以通过将
    `-lws2_32` 选项传递给 `gcc` 来实现。
- en: We'll provide the exact commands needed to compile each example as they are
    introduced.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在介绍每个示例时提供编译每个示例所需的精确命令。
- en: All of the example programs in this chapter require the same header files and
    C macros which we developed in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting
    to Grips with Socket APIs.* For brevity, we put these statements in a separate
    header file, `chap05.h`, which we can include in each program. For an explanation
    of these statements, please refer to [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的示例程序都需要我们在 [第 2 章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml) 中开发的相同头文件和
    C 宏，即 *掌握 Socket API*。为了简洁起见，我们将这些语句放在一个单独的头文件 `chap05.h` 中，我们可以在每个程序中包含它。有关这些语句的解释，请参阅
    [第 2 章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml) 的 *掌握 Socket API*。
- en: 'The contents of `chap05.h` are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`chap05.h` 的内容如下：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the `chap05.h` header in place, writing portable network programs is much
    easier. Let's continue now with an explanation of how DNS works, and then we will
    move on to the actual example programs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chap05.h` 头文件就绪的情况下，编写可移植的网络程序变得更加容易。现在让我们继续解释 DNS 的工作原理，然后我们将转到实际的示例程序。
- en: How hostname resolution works
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机名解析是如何工作的
- en: The DNS is used to assign names to computers and systems connected to the internet.
    Similar to how a phone book can be used to link a phone number to a name, the
    DNS allows us to link a hostname to an IP address.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 用于为连接到互联网的计算机和系统分配名称。类似于电话簿可以用来将电话号码与姓名联系起来，DNS 允许我们将主机名与 IP 地址联系起来。
- en: When your program needs to connect to a remote computer, such as `www.example.com`,
    it first needs to find the IP address for `www.example.com`. In this book so far,
    we have been using the built-in `getaddrinfo()` function for this purpose. When
    you call `getaddrinfo()`, your operating system goes through a number of steps
    to resolve the domain name.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序需要连接到远程计算机，例如 `www.example.com`，它首先需要找到 `www.example.com` 的 IP 地址。在这本书到目前为止的内容中，我们一直使用内置的
    `getaddrinfo()` 函数来完成这个目的。当你调用 `getaddrinfo()` 时，你的操作系统会经过一系列步骤来解析域名。
- en: First, your operating system checks whether it already knows the IP address
    for `www.example.com`. If you have used that hostname recently, the OS is allowed
    to remember it in a local cache for a time. This time is referred to as **time-to-live**
    (**TTL**) and is set by the DNS server responsible for the hostname.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您的操作系统检查它是否已经知道`www.example.com`的IP地址。如果您最近使用过该主机名，操作系统允许它在本地缓存中记住一段时间。这段时间被称为**生存时间**（**TTL**），由负责该主机名的DNS服务器设置。
- en: If the hostname is not found in the local cache, then your operating system
    will need to query a DNS server. This DNS server is usually provided by your **Internet
    Service Provider** (**ISP**), but there are also many publicly-available DNS servers.
    When the DNS server receives a query, it also checks its local cache. This is
    useful because numerous systems may be relying on one DNS server. If a DNS server
    receives 1,000 requests for `gmail.com` in one minute, it only needs to resolve
    the hostname the first time. For the other 999 requests, it can simply return
    the memorized answer from its local cache.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机名在本地缓存中没有找到，那么您的操作系统将需要查询一个DNS服务器。这个DNS服务器通常由您的**互联网服务提供商**（**ISP**）提供，但也有许多公开可用的DNS服务器。当DNS服务器收到一个查询时，它也会检查其本地缓存。这很有用，因为许多系统可能依赖于一个DNS服务器。如果一个DNS服务器在一分钟内收到1,000次对`gmail.com`的请求，它只需要在第一次解析主机名。对于其他999次请求，它可以直接从其本地缓存中返回已记住的答案。
- en: 'If the DNS server doesn''t have the requested DNS record in its cache, then
    it needs to query other DNS servers until it connects directly to the DNS server
    responsible for the target system. Here''s an example query resolution broken
    down step-wise:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果DNS服务器在其缓存中没有找到请求的DNS记录，那么它需要查询其他DNS服务器，直到它直接连接到负责目标系统的DNS服务器。以下是一个逐步分解的查询解析示例：
- en: 'Client A''s DNS server is trying to resolve `www.example.com` as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端A的DNS服务器正在尝试以下方式解析`www.example.com`：
- en: It first connects to a root DNS server and asks for `www.example.com`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它首先连接到根DNS服务器，并请求`www.example.com`。
- en: The root DNS server directs it to ask the `.com` server.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根DNS服务器将其引导到询问`.com`服务器。
- en: Our client's DNS server then connects to the server responsible for `.com` and
    asks for `www.example.com`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们的DNS服务器连接到负责`.com`的服务器，并请求`www.example.com`。
- en: The `.com` DNS server gives our server the address of another server – the `example.com` DNS
    server.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.com` DNS服务器给我们服务器另一个服务器的地址——`example.com` DNS服务器。'
- en: Our DNS server finally connects to that server and asks about the record for
    `www.example.com`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的DNS服务器最终连接到那个服务器，并询问`www.example.com`的记录。
- en: The `example.com` server then shares the address of `www.example.com`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`example.com`服务器然后分享`www.example.com`的地址。'
- en: Our client's DNS server relays it back to our client.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的DNS服务器将请求转回我们的客户端。
- en: 'The following diagram illustrates this visually:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表直观地说明了这一点：
- en: '![](img/3885e0b3-c552-4775-926d-4cc361781b2a.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3885e0b3-c552-4775-926d-4cc361781b2a.png)'
- en: 'In this example, you can see that resolving `www.example.com` involved sending
    eight messages. It''s possible that the lookup could have taken even longer. This
    is why it''s imperative for DNS servers to implement caching. Let''s assume that
    **Client B** tries the same query shortly after **Client A**; it''s likely that
    the DNS server would have that value cached:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到解析`www.example.com`涉及发送八条消息。查找可能需要更长的时间。这就是为什么DNS服务器实现缓存至关重要。假设**客户端B**在**客户端A**之后不久尝试相同的查询；DNS服务器很可能已经缓存了该值：
- en: '![](img/ea2e3e19-987a-4c09-80af-f27720d6ad66.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea2e3e19-987a-4c09-80af-f27720d6ad66.png)'
- en: Of course, if a program on **Client A** wants to resolve `www.example.com` again,
    it's likely that it won't have to contact the DNS server at all – the operating
    system running on **Client A** should have cached the result.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果**客户端A**上的程序再次解析`www.example.com`，它很可能根本不需要联系DNS服务器——运行在**客户端A**上的操作系统应该已经缓存了结果。
- en: 'On Windows, you can show your local DNS cache with the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，您可以使用以下命令显示您的本地DNS缓存：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On Linux or macOS, the command to show your local DNS varies depending on your
    exact system setup.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux或macOS上，显示本地DNS的命令取决于您的确切系统设置。
- en: One downside of setting a large TTL value for a domain record is that you have
    to wait at least that long to be sure that all clients are using the new record
    and not just retrieving the old cached record.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为域名记录设置较大的TTL值的一个缺点是，您必须至少等待这么长时间才能确保所有客户端都在使用新记录，而不仅仅是检索旧的缓存记录。
- en: In addition to DNS records that link a hostname to an IP address, there are
    other DNS record types for various purposes. We'll review some of these in the
    next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将主机名链接到IP地址的DNS记录外，还有其他用于各种目的的DNS记录类型。我们将在下一节中回顾一些这些类型。
- en: DNS record types
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS记录类型
- en: The DNS has five main types of records—`A`, `AAAA`, `MX`, `TXT`, `CNAME`, and
    `*` (`ALL`/`ANY`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: DNS有五种主要记录类型——`A`、`AAAA`、`MX`、`TXT`、`CNAME`和`*`（`ALL`/`ANY`）。
- en: As we have learned, the DNS's primary purpose is to translate hostnames into
    IP addresses. This is done with two record types – type `A` and type `AAAA`. These
    records work in the same way, but `A` records return an IPv4 address, while `AAAA`
    records return an IPv6 address.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，DNS的主要目的是将主机名转换为IP地址。这是通过两种记录类型——类型`A`和类型`AAAA`来完成的。这些记录以相同的方式工作，但`A`记录返回IPv4地址，而`AAAA`记录返回IPv6地址。
- en: The `MX` record type is used to return mail server information. For example,
    if you wanted to send an email to `larry@example.com`, then the `MX` record(s)
    for `example.com` would indicate which mail server(s) receives emails for that
    domain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`MX`记录类型用于返回邮件服务器信息。例如，如果您想给`larry@example.com`发送电子邮件，则`example.com`的`MX`记录将指示哪些邮件服务器接收该域的电子邮件。'
- en: '`TXT` records can be used to store arbitrary information for a hostname. In
    practice, these are sometimes set to prove ownership of a domain name or to publish
    email sending guidelines. The **Sender Policy Framework** (**SPF**) standard uses
    `TXT` records to declare which systems are allowed to send mail for a given domain
    name. You can read more about SPF at [http://www.openspf.org/](http://www.openspf.org/).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`TXT`记录可以用于存储主机名的任意信息。实际上，这些有时被设置为证明域名所有权或发布电子邮件发送指南。**发送者策略框架（SPF**）标准使用`TXT`记录来声明哪些系统可以发送给定域名的邮件。您可以在[http://www.openspf.org/](http://www.openspf.org/)了解更多关于SPF的信息。'
- en: '`CNAME` records can be used to provide an alias for a given name. For example,
    many websites are accessible at both their root domain name, for example, `example.com`,
    and at the `www` subdomain. If `example.com` and `www.example.com` should point
    to the same address, then an `A` and an `AAAA` record can be added for `example.com`,
    while a `CNAME` record can be added for `www.example.com` pointing to `example.com`.
    Note that DNS clients don''t query for `CNAME` records directly; instead, a client
    would ask for the `A` or `AAAA` record for `www.example.com` and the DNS server
    would reply with the `CNAME` record pointing to `example.com`. The DNS client
    would then continue the query using `example.com`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`CNAME`记录可以用于为给定名称提供别名。例如，许多网站既可以通过其根域名访问，例如`example.com`，也可以通过`www`子域名访问。如果`example.com`和`www.example.com`应指向同一地址，则可以为`example.com`添加`A`和`AAAA`记录，而为`www.example.com`添加指向`example.com`的`CNAME`记录。请注意，DNS客户端不会直接查询`CNAME`记录；相反，客户端会请求`www.example.com`的`A`或`AAAA`记录，DNS服务器会回复指向`example.com`的`CNAME`记录。然后DNS客户端会继续使用`example.com`进行查询。'
- en: When doing a DNS query, there is also a pseudo-record type called `*` or `ALL`
    or `ANY`. If this record is requested from a DNS server, then the DNS server returns
    all known record types for the current query. Note that a DNS server is allowed
    to respond with only the records in its cache, and this query is not guaranteed
    (or even likely) to actually get all of the records for the requested domain.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行DNS查询时，还有一个名为`*`或`ALL`或`ANY`的伪记录类型。如果从DNS服务器请求此记录，则DNS服务器返回当前查询的所有已知记录类型。请注意，DNS服务器可以仅响应其缓存中的记录，并且此查询不能保证（甚至可能）实际获取请求域名的所有记录。
- en: 'When sending a DNS query, each record type has an associated type ID. The IDs
    for the records discussed so far are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送DNS查询时，每种记录类型都有一个关联的类型ID。迄今为止讨论的记录的ID如下：
- en: '| **Record Type** | **Type ID (decimal)** | **Description** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **记录类型** | **类型ID（十进制）** | **描述** |'
- en: '| `A` | 1 | IPv4 address record |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `A` | 1 | IPv4地址记录 |'
- en: '| `AAAA` | 28 | IPv6 address record |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `AAAA` | 28 | IPv6地址记录 |'
- en: '| `MX` | 15 | Mail exchange record |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `MX` | 15 | 邮件交换记录 |'
- en: '| `TXT` | 16 | Text record |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `TXT` | 16 | 文本记录 |'
- en: '| `CNAME` | 5 | Canonical name |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `CNAME` | 5 | 规范名称 |'
- en: '| `*` | 255 | All cached records |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 255 | 所有缓存记录 |'
- en: There are many other record types in use. Please see the *Further reading* section
    at the end of this chapter for more information.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他记录类型正在使用中。请参阅本章末尾的*进一步阅读*部分以获取更多信息。
- en: It should be noted that one hostname may be associated with multiple records
    of the same type. For example, `example.com` could have several `A` records, each
    with a different IPv4 address. This is useful if multiple servers can provide
    the same service.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，一个主机名可能与多个同类型的记录相关联。例如，`example.com`可能有几个`A`记录，每个记录都有不同的IPv4地址。如果多个服务器可以提供相同的服务，这很有用。
- en: One other aspect of the DNS protocol worth mentioning is security. Let's look
    at that now.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的DNS协议的另一个方面是安全性。现在让我们来看看这一点。
- en: DNS security
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS安全
- en: While most web traffic and email are encrypted today, DNS is still widely used
    in an unsecured manner. Protocols do exist to provide security for DNS, but they
    are not widely adopted yet. This will hopefully change in the near future.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如今大多数网络流量和电子邮件都是加密的，但DNS仍然广泛以未加密的方式使用。确实存在一些协议可以提供DNS的安全性，但它们尚未得到广泛采用。希望这种情况在不久的将来会有所改变。
- en: '**Domain Name System Security Extensions** (**DNSSEC**) are DNS extensions
    that provide data authentication. This authentication allows a DNS client to know
    that a given DNS reply is authentic, but it does not protect against eavesdropping.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**域名系统安全扩展**（**DNSSEC**）是DNS扩展，它提供了数据认证。这种认证允许DNS客户端知道给定的DNS回复是真实的，但它不能防止窃听。'
- en: '**DNS over HTTPS** (**DoH**) is a protocol that provides name resolution over
    HTTPS. HTTPS provides strong security guarantees, including resistance to interception.
    We cover HTTPS in [Chapter 9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml), *Loading
    Secure Web Pages with HTTPS and OpenSSL*, and [Chapter 10](f57ffaa2-3eba-45cf-914b-bb6aef36174f.xhtml),
    *Implementing a Secure Web Server*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**DNS over HTTPS**（**DoH**）是一种在HTTPS上提供名称解析的协议。HTTPS提供了强大的安全保证，包括抵抗拦截的能力。我们在[第9章](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)《使用HTTPS和OpenSSL加载安全网页》和[第10章](f57ffaa2-3eba-45cf-914b-bb6aef36174f.xhtml)《实现安全Web服务器》中介绍了HTTPS。'
- en: What are the implications of using insecure DNS? First, if DNS is not authenticated,
    then it could allow an attacker to lie about a domain name's IP address. This
    could trick a victim into connecting to a server that they think is `example.com`,
    but, in reality, is a malicious server controlled by the attacker at a different
    IP address. If the user is connecting via a secure protocol, such as HTTPS, then
    this attack will fail. HTTPS provides additional authentication to prove server
    identity. However, if the user connects with an insecure protocol, such as HTTP,
    then the DNS attack could successfully trick the victim into connecting to the
    wrong server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不安全的DNS有哪些影响？首先，如果DNS没有进行认证，那么它可能允许攻击者对域名IP地址进行欺骗。这可能会诱骗受害者连接到一个他们认为的`example.com`服务器，但实际上是一个由攻击者控制的恶意服务器，该服务器位于不同的IP地址。如果用户通过安全的协议连接，例如HTTPS，那么这种攻击将失败。HTTPS提供了额外的认证来证明服务器身份。然而，如果用户使用不安全的协议连接，例如HTTP，那么DNS攻击可能会成功欺骗受害者连接到错误的服务器。
- en: If DNS is authenticated, then these hijacking attacks are prevented. However,
    without encryption, DNS queries are still susceptible to eavesdropping. This could
    potentially give an eavesdropper insight into which websites you're visiting and
    other servers that you are connecting to (for example, which email server you
    use). This doesn't let an attacker know what you are doing on each website. For
    example, if you do a DNS query for `example.com`, an attacker would know that
    you planned to visit `example.com`, but the attacker would not be able to determine
    which resources you requested from `example.com` – assuming that you use a secure
    protocol (for example, HTTPS) to retrieve those resources. An attacker with the
    ability to eavesdrop would be able to see that you established a connection to
    the IP address of `example.com` in any case, so them knowing that you performed
    a DNS lookup beforehand is not much extra information.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果DNS进行了认证，那么这些劫持攻击就会被阻止。然而，如果没有加密，DNS查询仍然容易受到窃听。这可能会让窃听者了解到你访问了哪些网站以及你连接到的其他服务器（例如，你使用的电子邮件服务器）。这并不让攻击者知道你在每个网站上做了什么。例如，如果你对`example.com`进行DNS查询，攻击者会知道你打算访问`example.com`，但攻击者无法确定你从`example.com`请求了哪些资源——假设你使用安全的协议（例如HTTPS）来检索这些资源。具有窃听能力的攻击者无论如何都能看到你与`example.com`的IP地址建立了连接，所以他们在你之前进行DNS查找并不会提供太多额外信息。
- en: With some security discussion out of the way, let's look at how to do actual
    DNS lookups. Winsock and Berkeley sockets provide a simple function to do address
    lookup, called `getaddrinfo()`, which we've used in the previous chapters of this
    book. We will start with this in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了某些安全问题之后，让我们看看如何进行实际的DNS查找。Winsock和伯克利套接字提供了一种简单的函数来进行地址查找，称为`getaddrinfo()`，我们在本书的前几章中已经使用过它。我们将在下一节中从这方面开始。
- en: Name/address translation functions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称/地址转换函数
- en: It is common for networked programs to need to translate text-based representatives
    of an address or hostname into an address structure required by the socket programming
    API. The common function we've been using is `getaddrinfo()`. It is a useful function
    because it is highly portable (available on Windows, Linux, and macOS), and it
    works for both IPv4 and IPv6 addresses.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络程序来说，通常需要将地址或主机名的基于文本的表示转换为套接字编程API所需的地址结构。我们一直在使用的常用函数是`getaddrinfo()`。这是一个有用的函数，因为它高度可移植（在Windows、Linux和macOS上可用），并且适用于IPv4和IPv6地址。
- en: It is also common to need to convert a binary address back into a text format.
    We use `getnameinfo()` for this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制地址转换回文本格式也是常见的需求。我们使用`getnameinfo()`来完成这个任务。
- en: Using getaddrinfo()
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`getaddrinfo()`
- en: Although we've been using `getaddrinfo()` in previous chapters, we'll discuss
    it in more detail here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经在之前的章节中使用过`getaddrinfo()`，但我们将在这里更详细地讨论它。
- en: 'The declaration for `getaddrinfo()` is shown in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`getaddrinfo()`的声明如下所示：'
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code snippet is explained as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的解释如下：
- en: '`node` specifies a hostname or address as a string. Valid examples could be
    `example.com`, `192.168.1.1`, or `::1`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`指定一个主机名或地址作为字符串。有效的示例可以是`example.com`、`192.168.1.1`或`::1`。'
- en: '`service` specifies a service or port number as a string. Valid examples could
    be `http` or `80`. Alternately, the null pointer can be passed in for `service`,
    in which case, the resulting address is set to port `0`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service`指定一个服务或端口号作为字符串。有效的示例可以是`http`或`80`。或者，可以将空指针传递给`service`，在这种情况下，结果地址将被设置为端口号`0`。'
- en: '`hints` is a pointer to a `struct addrinfo`, which specifies options for selecting
    the address. The `addrinfo` structure has the following fields:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hints`是一个指向`struct addrinfo`的指针，它指定了选择地址的选项。`addrinfo`结构具有以下字段：'
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should not assume that the fields are stored in the order listed in the
    previous code, or that additional fields aren't present. There is some variation
    between operating systems.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应假设字段是按照之前代码中列出的顺序存储的，或者认为没有其他字段存在。不同操作系统之间存在一些差异。
- en: 'The call to `getaddrinfo()` looks at only four fields in `*hints`. The rest
    of the structure should be zeroed-out. The relevant fields are `ai_family`, `ai_socktype`,
    `ai_protocol`, and `ai_flags`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`getaddrinfo()`的调用只查看`*hints`中的四个字段。其余的结构应该为零。相关的字段是`ai_family`、`ai_socktype`、`ai_protocol`和`ai_flags`：'
- en: '`ai_family` specifies the desired address family. It can be `AF_INET` for IPv4,
    `AF_INET6` for IPv6, or `AF_UNSPEC` for any address family. `AF_UNSPEC` is defined
    as `0`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ai_family`指定所需的地址族。它可以是为IPv4的`AF_INET`，为IPv6的`AF_INET6`，或为任何地址族的`AF_UNSPEC`。`AF_UNSPEC`定义为`0`。'
- en: '`ai_socktype` could be `SOCK_STREAM` for TCP (see [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml),
    *An In-Depth Overview of TCP Connections*), or `SOCK_DGRAM` for UDP (see [Chapter
    4](05a32725-5c72-41e4-92aa-2425bf75282e.xhtml), *Establishing UDP Connections*).
    Setting `ai_socktype` to `0` indicates that the address could be used for either.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ai_socktype`可以是用于TCP的`SOCK_STREAM`（见[第3章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，*TCP连接的深入概述*），或用于UDP的`SOCK_DGRAM`（见[第4章](05a32725-5c72-41e4-92aa-2425bf75282e.xhtml)，*建立UDP连接*）。将`ai_socktype`设置为`0`表示地址可以用于两者。'
- en: '`ai_protocol` should be left to `0`. Strictly speaking, TCP isn''t the only
    streaming protocol supported by the socket interface, and UDP isn''t the only
    datagram protocol supported. `ai_protocol` is used to disambiguate, but it''s
    not needed for our purposes.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ai_protocol`应保留为`0`。严格来说，TCP并不是唯一由套接字接口支持的流协议，UDP也不是唯一支持的报文协议。`ai_protocol`用于消除歧义，但对我们来说不是必需的。'
- en: '`ai_flags` specifies additional options about how `getaddrinfo()` should work.
    Multiple flags can be used by bitwise OR-ing them together. In C, the bitwise
    OR operator uses the pipe symbol, `|`. So, bitwise OR-ing two flags together would
    use the `(flag_one | flag_two)` code.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ai_flags`指定关于`getaddrinfo()`应如何工作的附加选项。可以通过按位或操作将多个标志组合在一起使用。在C中，按位或操作符使用管道符号`|`。因此，将两个标志按位或操作在一起将使用`(flag_one
    | flag_two)`代码。'
- en: 'Common flags you may use for the `ai_flags` field are:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能用于 `ai_flags` 字段的常见标志包括：
- en: '`AI_NUMERICHOST` can be used to prevent name lookups. In this case, `getaddrinfo()`
    would expect `node` to be an address such as `127.0.0.1` and not a hostname such
    as `example.com`. `AI_NUMERICHOST` can be useful because it prevents `getaddrinfo()`
    from doing a DNS record lookup, which can be slow.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AI_NUMERICHOST` 可以用于防止名称查找。在这种情况下，`getaddrinfo()` 预期 `node` 是一个地址，如 `127.0.0.1`，而不是一个主机名，如
    `example.com`。`AI_NUMERICHOST` 可能很有用，因为它可以防止 `getaddrinfo()` 执行 DNS 记录查找，这可能会很慢。'
- en: '`AI_NUMERICSERV` can be used to only accept port numbers for the `service`
    argument. If used, this flag causes `getaddrinof()` to reject service names.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AI_NUMERICSERV` 可以用于仅接受 `service` 参数的端口号。如果使用，则此标志会导致 `getaddrinof()` 拒绝服务名称。'
- en: '`AI_ALL` can be used to request both an IPv4 and IPv6 address. The declaration
    for `AI_ALL` seems to be missing on some Windows setups. It can be defined as
    `0x0100` on those platforms.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AI_ALL` 可以用于请求 IPv4 和 IPv6 地址。在某些 Windows 设置中，`AI_ALL` 的声明似乎缺失。在这些平台上，它可以定义为
    `0x0100`。'
- en: '`AI_ADDRCONFIG` forces `getaddrinfo()` to only return addresses that match
    the family type of a configured interface on the local machine. For example, if
    your machine is IPv4 only, then using `AI_ADDRCONFIG | AI_ALL` prevents IPv6 addresses
    from being returned. It is usually a good idea to use this flag if you plan to
    connect a socket to the address returned by `getaddrinfo()`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AI_ADDRCONFIG` 强制 `getaddrinfo()` 只返回与本地机器上配置的接口的族类型匹配的地址。例如，如果您的机器仅使用 IPv4，则使用
    `AI_ADDRCONFIG | AI_ALL` 防止返回 IPv6 地址。如果您计划将套接字连接到 `getaddrinfo()` 返回的地址，通常使用此标志是一个好主意。'
- en: '`AI_PASSIVE` can be used with `node = 0` to request the *wildcard address*.
    This is the local address that accepts connections on any of the host''s network
    addresses. It is used on servers with `bind()`. If `node` is not `0`, then `AI_PASSIVE`
    has no effect. See [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml), *An
    In-Depth Overview of TCP Connections* for example usage.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AI_PASSIVE` 可以与 `node = 0` 一起使用来请求通配符地址。这是接受主机任何网络地址上连接的本地地址。它在带有 `bind()`
    的服务器上使用。如果 `node` 不是 `0`，则 `AI_PASSIVE` 无效。例如，请参阅[第 3 章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，*TCP
    连接的深入概述*，了解用法。'
- en: All other fields in `hints` should be set to `0`. You can also pass in `0` for
    the `hints` argument, but different operating systems implement different defaults
    in that case.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`hints` 中的所有其他字段应设置为 `0`。您也可以为 `hints` 参数传递 `0`，但在不同操作系统中，这种情况下的默认值可能会有所不同。'
- en: The final parameter to `getaddrinfo()`, `res`, is a pointer to a pointer to `struct
    addrinfo` and returns the address(es) found by `getaddrinfo()`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`getaddrinfo()` 的最后一个参数 `res` 是指向 `struct addrinfo` 指针的指针，并返回 `getaddrinfo()`
    找到的地址（或地址）。'
- en: 'If the call to `getaddrinfo()` succeeds, then its return value is `0`. In this
    case, you should call `freeaddrinfo()` on `*res` when you''ve finished using the
    address. Here is an example of using `getaddrinfo()` to find the address(es) for
    `example.com`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `getaddrinfo()` 调用成功，则其返回值是 `0`。在这种情况下，当您完成使用地址后，应在 `*res` 上调用 `freeaddrinfo()`。以下是一个使用
    `getaddrinfo()` 查找 `example.com` 地址（或地址）的示例：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we first zero out `hints` using a call to `memset()`. We then set
    the `AI_ALL` flag, which specifies that we want both IPv4 and IPv6 addresses returned.
    This even returns addresses that we don't have a network adapter for. If you only
    want addresses that your machine can practically connect to, then use `AI_ALL
    | AI_ADDRCONFIG` for the `ai_flags` field. We can leave the other fields of `hints`
    as their defaults.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们首先使用 `memset()` 调用来将 `hints` 清零。然后设置 `AI_ALL` 标志，指定我们希望返回 IPv4 和 IPv6 地址。这甚至返回我们没有网络适配器的地址。如果您只想获取机器可以实际连接的地址，则使用
    `AI_ALL | AI_ADDRCONFIG` 作为 `ai_flags` 字段。我们可以将 `hints` 的其他字段保留为默认值。
- en: 'We then declare a pointer to hold the return address list: `struct addrinfo
    *peer_address`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明一个指针来保存返回的地址列表：`struct addrinfo *peer_address`。
- en: If the call to `getaddrinfo()` succeeds, then `peer_address` holds the first
    address result. The next result, if any, is in `peer_address->ai_next`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `getaddrinfo()` 调用成功，则 `peer_address` 包含第一个地址结果。如果有下一个结果，它将在 `peer_address->ai_next`
    中。
- en: 'We can loop through all the returned addresses with the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码遍历所有返回的地址：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we''ve finished using `peer_address`, we should free it with the following
    code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成使用 `peer_address` 后，我们应该使用以下代码来释放它：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we can convert a text address or name into an `addrinfo` structure,
    it is useful to see how to convert the `addrinfo` structure back into a text format.
    Let's look at that now.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将文本地址或名称转换为 `addrinfo` 结构，那么查看如何将 `addrinfo` 结构转换回文本格式就很有用了。现在让我们看看这一点。
- en: Using getnameinfo()
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 getnameinfo()
- en: '`getnameinfo()` can be used to convert an `addrinfo` structure back into a
    text format. It works with both IPv4 and IPv6\. It also, optionally, converts
    a port number into a text format number or service name.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`getnameinfo()` 可以用于将 `addrinfo` 结构转换回文本格式。它适用于 IPv4 和 IPv6。它还可以可选地将端口号转换为文本格式的数字或服务名称。'
- en: 'The declaration for `getnameinfo()` can be seen in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`getnameinfo()` 的声明可以在以下代码中看到：'
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first two parameters are passed in from the `ai_addr` and `ai_addrlen` fields
    of `struct addrinfo`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数是从 `struct addrinfo` 的 `ai_addr` 和 `ai_addrlen` 字段传递的。
- en: The next two parameters, `host` and `hostlen`, specify a character buffer and
    buffer length to store the hostname or IP address text.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个参数 `host` 和 `hostlen` 指定用于存储主机名或 IP 地址文本的字符缓冲区和缓冲区长度。
- en: The following two parameters, `serv` and `servlen`, specify the buffer and length
    to store the service name.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个参数 `serv` 和 `servlen` 指定用于存储服务名称的缓冲区和长度。
- en: If you don't need both the hostname and the service, you can optionally pass
    in only one of either `host` or `serv`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要主机名和服务名称，您可以可选地只传递 `host` 或 `serv` 中的一个。
- en: 'Flags can be a bitwise OR combination of the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 标志可以是以下标志的按位或组合：
- en: '`NI_NAMEREQD` requires `getnameinfo()` to return a hostname and not an address.
    By default, `getnameinfo()` tries to return a hostname but returns an address
    if it can''t. `NI_NAMEREQD` will cause an error to be returned if the hostname
    cannot be determined.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NI_NAMEREQD` 要求 `getnameinfo()` 返回主机名而不是地址。默认情况下，`getnameinfo()` 尝试返回主机名，但如果无法确定则返回地址。如果无法确定主机名，`NI_NAMEREQD`
    将导致返回错误。'
- en: '`NI_DGRAM` specifies that the service is UDP-based rather than TCP-based. This
    is only important for ports that have different standard services for UDP versus
    TCP. This flag is ignored if `NI_NUMERICSERV` is set.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NI_DGRAM` 指定服务基于 UDP 而不是 TCP。这对于具有不同标准服务的 UDP 和 TCP 端口很重要。如果设置了 `NI_NUMERICSERV`，则忽略此标志。'
- en: '`NI_NUMERICHOST` requests that `getnameinfo()` returns the IP address and not
    a hostname.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NI_NUMERICHOST` 请求 `getnameinfo()` 返回 IP 地址而不是主机名。'
- en: '`NI_NUMERICSERV` requests that `getnameinfo()` returns the port number and
    not a service name.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NI_NUMERICSERV` 请求 `getnameinfo()` 返回端口号而不是服务名称。'
- en: 'For example, we can use `getnameinfo()` as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以如下使用 `getnameinfo()`：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, `getnameinfo()` attempts to perform a reverse DNS lookup.
    This works like the DNS queries we've done in this chapter so far, but backward.
    A DNS query asks w*hich IP address does this hostname point to?* A reverse DNS
    query asks instead, w*hich* *hostname does this IP address point to?* Keep in
    mind that this is not a one-to-one relationship. Many hostnames can point to one
    IP address, but an IP address can store a DNS record for only one hostname. In
    fact, reverse DNS records are not even set for many IP addresses.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`getnameinfo()` 尝试执行逆向 DNS 查询。这就像我们在本章中迄今为止所做的 DNS 查询一样，但方向相反。DNS 查询询问该主机名指向哪个
    IP 地址？逆向 DNS 查询则相反，询问该 IP 地址指向哪个主机名？请记住，这不是一对一的关系。许多主机名可以指向一个 IP 地址，但一个 IP 地址只能存储一个主机名的
    DNS 记录。事实上，许多 IP 地址甚至没有设置逆向 DNS 记录。
- en: 'If `address` is a `struct addrinfo` with the address for `example.com` port
    `80` (`http`), then the preceding code might print as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `address` 是 `struct addrinfo`，其中包含 `example.com` 的地址 `80`（`http`）端口，那么前面的代码可能打印如下：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the code prints something different for you, it's probably working as intended.
    It is dependent on which address is in `address` and how the reverse DNS is set
    up for that IP address. Try it with a different address.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码为您打印了不同的内容，那么它可能按预期工作。这取决于 `address` 字段中的地址以及该 IP 地址的逆向 DNS 设置。尝试使用不同的地址进行测试。
- en: 'If, instead of the hostname, we would like the IP address, we can modify our
    code to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要 IP 地址而不是主机名，我们可以修改我们的代码如下：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the case of the previous code, it might print the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一段代码的情况下，它可能打印以下内容：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using `NI_NUMERICHOST` generally runs much faster too, as it doesn't require
    `getnameinfo()` to send off any reverse DNS queries.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NI_NUMERICHOST` 通常运行得更快，因为它不需要 `getnameinfo()` 发送任何逆向 DNS 查询。
- en: Alternative functions
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他函数
- en: Two widely-available functions that replicate `getaddrinfo()` are `gethostbyname()`
    and `getservbyname()`. The `gethostbyname()` function is obsolete and has been
    removed from the newer POSIX standards. Furthermore, I recommend against using
    these functions in new code, because they introduce an IPv4 dependency. It's very
    possible to use `getaddrinfo()` in such a way that your program does not need
    to be aware of IPv4 versus IPv6, but still supports both.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 两个广泛使用的、可以复制`getaddrinfo()`功能的函数是`gethostbyname()`和`getservbyname()`。`gethostbyname()`函数已经过时，并被从较新的POSIX标准中删除。此外，我建议不要在新代码中使用这些函数，因为它们引入了IPv4依赖。完全有可能以这种方式使用`getaddrinfo()`，使得你的程序不需要知道IPv4与IPv6的区别，但仍然支持两者。
- en: IP lookup example program
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP查找示例程序
- en: To demonstrate the `getaddrinfo()` and `getnameinfo()` functions, we will implement
    a short program. This program takes a name or IP address for its only argument.
    It then uses `getaddrinfo()` to resolve that name or that IP address into an address
    structure, and the program prints that IP address using `getnameinfo()` for the
    text conversion. If multiple addresses are associated with a name, it prints each
    of them. It also indicates any errors.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`getaddrinfo()`和`getnameinfo()`函数，我们将实现一个简短的程序。此程序接受一个名称或IP地址作为其唯一参数。然后它使用`getaddrinfo()`将名称或IP地址解析为地址结构，并使用`getnameinfo()`进行文本转换来打印该IP地址。如果与名称关联了多个地址，它将打印每个地址。它还指示任何错误。
- en: 'To begin with, we need to include our required header for this chapter. We
    also define `AI_ALL` for systems that are missing it. The code for this is as
    follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要包含本章所需的头文件。我们还为缺少它的系统定义了`AI_ALL`。代码如下所示：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can then begin the `main()` function and check that the user passed in a
    hostname to lookup. If the user doesn''t pass in a hostname, we print a helpful
    reminder. The code for this is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始调用`main()`函数，并检查用户是否传递了一个用于查找的主机名。如果用户没有传递主机名，我们将打印一条有用的提示信息。这段代码如下所示：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need the following code to initialize Winsock on Windows platforms:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下代码来在Windows平台上初始化Winsock：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can then call `getaddrinfo()` to convert the hostname or address into a `struct
    addrinfo`. The code for that is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调用`getaddrinfo()`将主机名或地址转换为`struct addrinfo`。以下是该代码：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The previous code first prints the hostname or address that is passed in as
    the first command-line argument. This argument is stored in `argv[1]`. We then
    set `hints.ai_flags = AI_ALL` to specify that we want all available addresses
    of any type, including both IPv4 and IPv6 addresses.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码首先打印作为第一个命令行参数传递的主机名或地址。此参数存储在`argv[1]`中。然后我们将`hints.ai_flags = AI_ALL`设置为指定我们想要所有类型的可用地址，包括IPv4和IPv6地址。
- en: '`getaddrinfo()` is then called with `argv[1]`. We pass `0` in for the service
    argument because we don''t care about the port number. We are only trying to resolve
    an address. If `argv[1]` contains a name, such as `example.com`, then our operating
    system performs a DNS query (assuming the hostname isn''t already in the local
    cache). If `argv[1]` contains an address such as `192.168.1.1`, then `getaddrinfo()` simply
    fills in the resulting `struct addrinfo` as needed.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`argv[1]`调用`getaddrinfo()`。我们将服务参数传递为`0`，因为我们不关心端口号。我们只是尝试解析一个地址。如果`argv[1]`包含一个名称，例如`example.com`，那么我们的操作系统将执行DNS查询（假设主机名尚未在本地缓存中）。如果`argv[1]`包含一个地址，例如`192.168.1.1`，那么`getaddrinfo()`将根据需要简单地填充结果`struct
    addrinfo`。
- en: If the user passed in an invalid address or a hostname for which no record could
    be found, then `getaddrinfo()` returns a non-zero value. In that case, our previous
    code prints out the error.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户传递了一个无效的地址或找不到记录的主机名，那么`getaddrinfo()`将返回一个非零值。在这种情况下，我们之前的代码将打印出错误。
- en: 'Now that `peer_address` holds the desired address(es), we can use `getnameinfo()` to
    convert them to text. The following code does that:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`peer_address`包含所需的地址（或地址），我们可以使用`getnameinfo()`将它们转换为文本。以下代码实现了这一点：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code works by first storing `peer_address` in a new variable, `address`.
    We then enter a loop. `address_buffer[]` is declared to store the text address,
    and we call `getnameinfo()` to fill in that address. The last parameter to `getnameinfo()`,
    `NI_NUMERICHOST`, indicates that we want it to put the IP address into `address_buffer`
    and not a hostname. The address buffer can then simply be printed out with `printf()`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过首先将`peer_address`存储在一个新变量`address`中来实现。然后我们进入一个循环。`address_buffer[]`被声明为存储文本地址，我们调用`getnameinfo()`来填充该地址。`getnameinfo()`的最后一个参数`NI_NUMERICHOST`表示我们希望它将IP地址放入`address_buffer`而不是主机名。然后可以使用`printf()`简单地打印出地址缓冲区。
- en: If `getaddrinfo()` returned multiple addresses, then the next address is pointed
    to by `address->ai_next`. We assign `address->ai_next` to `address` and loop if
    it is non-zero. This is a simple example of walking through a linked list.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `getaddrinfo()` 返回多个地址，则下一个地址由 `address->ai_next` 指向。我们将 `address->ai_next`
    赋值给 `address` 并在它非零时循环。这是一个遍历链表的简单示例。
- en: 'After we''ve printed our address, we should use `freeaddrinfo()` to free the
    memory allocated by `getaddrinfo()`. We should also call the Winsock cleanup function
    on Windows. We can do both with the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打印了我们的地址之后，我们应该使用`freeaddrinfo()`来释放`getaddrinfo()`分配的内存。在Windows上，我们还应该调用Winsock清理函数。我们可以使用以下代码来完成这两件事：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That concludes our `lookup` program.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的`lookup`程序。
- en: 'You can compile and run `lookup.c` on Linux and macOS by using the following
    command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令在Linux和macOS上编译和运行`lookup.c`：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Compiling and running on Windows with MinGW is done in the following way:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上使用MinGW编译和运行的方式如下：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following screenshot is an example of using `lookup` to print the IP addresses
    for `example.com`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是使用`lookup`打印`example.com`的IP地址的示例：
- en: '![](img/6c0777cf-fe92-47b0-9b88-2c0f2737ef5e.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c0777cf-fe92-47b0-9b88-2c0f2737ef5e.png)'
- en: Although `getaddrinfo()` makes performing DNS lookups easy, it is useful to
    know what happens behind the scenes. We will now look at the DNS protocol in more
    detail.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`getaddrinfo()`使执行DNS查找变得容易，但了解幕后发生的事情是有用的。现在我们将更详细地查看DNS协议。
- en: The DNS protocol
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS协议
- en: 'When a client wants to resolve a hostname into an IP address, it sends a DNS
    query to a DNS server. This is typically done over UDP using port `53`. The DNS
    server then performs the lookup, if possible, and returns an answer. The following
    diagram illustrates this transaction:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要将主机名解析为IP地址时，它会向DNS服务器发送DNS查询。这通常是通过UDP使用端口`53`完成的。然后DNS服务器执行查找（如果可能的话），并返回一个答案。以下图示说明了这个事务：
- en: '![](img/b1727003-67ae-41ac-86c5-afc0e8977d7a.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1727003-67ae-41ac-86c5-afc0e8977d7a.png)'
- en: If the query (or, more commonly, the answer) is too large to fit into one UDP
    packet, then the query can be performed over TCP instead of UDP. In this case,
    the size of the query is sent over TCP as a 16-bit value, and then the query itself
    is sent. This is called **TCP fallback** or **DNS transport over TCP**. However,
    UDP works for most cases, and UDP is how DNS is used the vast majority of the
    time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询（或更常见的是，答案）太大而无法放入一个UDP数据包中，那么查询可以通过TCP而不是UDP进行。在这种情况下，查询的大小以16位值的形式通过TCP发送，然后发送查询本身。这被称为**TCP回退**或**通过TCP的DNS传输**。然而，UDP适用于大多数情况，DNS在绝大多数情况下都是通过UDP使用的。
- en: It's also important to note that the client must know the IP address of at least
    one DNS server. If the client doesn't know of any DNS servers, then it has a sort
    of chicken-and-egg problem. DNS servers are usually provided by your ISP.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，客户端必须知道至少一个DNS服务器的IP地址。如果客户端不知道任何DNS服务器，那么它就有一个类似“鸡生蛋，蛋生鸡”的问题。DNS服务器通常由你的ISP提供。
- en: The actual UDP data format is simple and follows the same basic format for both
    the query and the answer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的UDP数据格式简单，对于查询和答案都遵循相同的基本格式。
- en: DNS message format
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS消息格式
- en: 'The following illustration describes the DNS message format:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了DNS消息格式：
- en: '![](img/debc3c62-a462-47e0-af20-6d25f771e40d.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/debc3c62-a462-47e0-af20-6d25f771e40d.png)'
- en: Every DNS message follows that format, although a query would leave the **Answer**,
    **Authority**, and **Additional** sections blank. A DNS response commonly doesn't
    use **Authority** or **Additional**. We won't concern ourselves with the **Authority**
    or **Additional** sections, as they are not needed for typical DNS queries.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个DNS消息都遵循该格式，尽管查询会留空**答案**、**授权**和**附加**部分。DNS响应通常不使用**授权**或**附加**。我们不会关注**授权**或**附加**部分，因为它们对于典型的DNS查询不是必需的。
- en: DNS message header format
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS消息头格式
- en: 'The header is exactly 12 bytes long and is exactly the same for a DNS query
    or DNS response. The **Header Format** is illustrated graphically in the following
    diagram:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 头部长度正好是12字节，对于DNS查询或DNS响应都是相同的。**头格式**在以下图中以图形方式展示：
- en: '![](img/346de5c8-e0a1-4694-bee3-2ffd68761f09.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/346de5c8-e0a1-4694-bee3-2ffd68761f09.png)'
- en: 'As the preceding diagram illustrates, the DNS message header contains 13 fields—**ID**,
    **QR**, **OPCODE**, **AA**, **TC**, **RD**, **RA**, **Z**, **RCODE**, **QDCOUNT**,
    **ANCOUNT**, **NSCOUNT**, and **ARCOUNT**:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，DNS消息头包含13个字段——**ID**、**QR**、**OPCODE**、**AA**、**TC**、**RD**、**RA**、**Z**、**RCODE**、**QDCOUNT**、**ANCOUNT**、**NSCOUNT**
    和 **ARCOUNT**：
- en: '**ID** is any 16-bit value that is used to identify the DNS message. The client
    is allowed to put any 16 bits into the DNS query, and the DNS server copies those
    same 16 bits into the DNS response **ID**. This is useful to allow the client
    to match up which response is in reply to which query, in cases where the client
    is sending multiple queries.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID** 是用于标识 DNS 消息的任何 16 位值。客户端允许将任何 16 位放入 DNS 查询中，DNS 服务器将相同的 16 位复制到 DNS
    响应的 **ID** 中。这在客户端发送多个查询的情况下，允许客户端匹配哪个响应是对哪个查询的回复非常有用。'
- en: '**QR** is a 1-bit field. It is set to `0` to indicate a DNS query or `1` to
    indicate a DNS response.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QR** 是一个 1 位字段。它设置为 `0` 表示 DNS 查询，或设置为 `1` 表示 DNS 响应。'
- en: '**Opcode** is a 4-bit field, which specifies the type of query. `0` indicates
    a standard query. `1` indicates a reverse query to resolve an IP address into
    a name. `2` indicates a server status request. Other values (`3` through `15`)
    are reserved.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Opcode** 是一个 4 位字段，它指定查询的类型。`0` 表示标准查询。`1` 表示将 IP 地址解析为名称的逆向查询。`2` 表示服务器状态请求。其他值（`3`
    通过 `15`）是保留的。'
- en: '**AA** indicates an authoritative answer.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AA** 表示权威答案。'
- en: '**TC** indicates that the message was truncated. In this case, it should be
    re-sent using TCP.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TC** 表示消息已被截断。在这种情况下，应使用 TCP 重新发送。'
- en: '**RD** should be set if recursion is desired. We leave this bit set to indicate
    that we want the DNS server to contact additional servers until it can complete
    our request.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RD** 应当设置为期望递归。我们保留此位设置为指示我们希望 DNS 服务器联系其他服务器，直到它能够完成我们的请求。'
- en: '**RA** indicates in a response whether the DNS server supports recursion.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RA** 表示在响应中 DNS 服务器是否支持递归。'
- en: '**Z** is unused and should be set to `0`.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z** 未使用，应设置为 `0`。'
- en: '**RCODE** is set in a DNS response to indicate the error condition. Its possible
    values are as follows:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RCODE** 在 DNS 响应中设置，以指示错误条件。其可能的值如下：'
- en: '| **RCODE** | **Description** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **RCODE** | **描述** |'
- en: '| `0` | No error |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 无错误 |'
- en: '| `1` | Format error |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 格式错误 |'
- en: '| `2` | Server failure |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 服务器故障 |'
- en: '| `3` | Name error |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `3` | 名称错误 |'
- en: '| `4` | Not implemented |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `4` | 未实现 |'
- en: '| `5` | Refused |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `5` | 被拒绝 |'
- en: Please see **RFC 1035**: *DOMAIN NAMES – IMPLEMENTATION AND SPECIFICATION,*
    in the *Further reading* section of this chapter for more information on the meaning
    of these values.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章 *进一步阅读* 部分的 **RFC 1035**：*域名系统 – 实现 和 规范*，以获取有关这些值含义的更多信息。
- en: '**QDCOUNT**, **ANCOUNT**, **NSCOUNT**, and **ARCOUNT** indicate the number
    of records in their corresponding sections. **QDCOUNT** indicates the number of
    questions in a DNS query. It is interesting that **QDCOUNT** is a 16-bit value
    capable of storing large numbers, and yet no real-world DNS server allows more
    than one question per message. **ANCOUNT** indicates the number of answers, and
    it is common for a DNS server to return multiple answers in one message.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QDCOUNT**、**ANCOUNT**、**NSCOUNT** 和 **ARCOUNT** 表示它们对应部分中的记录数。**QDCOUNT**
    表示 DNS 查询中的问题数。有趣的是，**QDCOUNT** 是一个 16 位值，可以存储大量数字，但现实中的 DNS 服务器不允许每条消息中超过一个问题。**ANCOUNT**
    表示答案的数量，DNS 服务器通常在一条消息中返回多个答案。'
- en: Question format
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题格式
- en: 'The DNS **Question Format** consists of a name followed by two 16-bit values—`QTYPE`
    and `QCLASS`. This **Question Format** is illustrated as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: DNS **问题格式** 由一个名称后跟两个 16 位值组成——`QTYPE` 和 `QCLASS`。以下是这样表示 **问题格式**：
- en: '![](img/d793dee6-5fa1-4bb2-947d-eae5221dd568.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d793dee6-5fa1-4bb2-947d-eae5221dd568.png)'
- en: '**QTYPE** indicates the record type we are asking for, and **QCLASS** should
    be set to `1` to indicate the internet.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**QTYPE** 表示我们请求的记录类型，**QCLASS** 应设置为 `1` 以表示互联网。'
- en: The name field involves a special encoding. First, a hostname should be broken
    up into its individual labels. For example, `www.example.com` would be broken
    up into `www`, `example`, and `com`. Then, each label should be prepended with
    1 byte, indicating the label length. Finally, the entire name ends with a 0 byte.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 名称字段涉及一种特殊编码。首先，应将主机名分解为其单个标签。例如，`www.example.com` 将被分解为 `www`、`example` 和 `com`。然后，每个标签应前面加上
    1 个字节，表示标签长度。最后，整个名称以 0 字节结束。
- en: 'Visually, the name `www.example.com` is encoded as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，名称 `www.example.com` 被编码如下：
- en: '![](img/982010ad-4fe5-4e83-b2e5-37d2798aa631.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/982010ad-4fe5-4e83-b2e5-37d2798aa631.png)'
- en: If the **QTYPE** and **QCLASS** fields were appended to the preceding name example,
    then it could make up an entire DNS question.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 **QTYPE** 和 **QCLASS** 字段附加到前面的名称示例中，那么它可以组成一个完整的 DNS 问题。
- en: A DNS response is sometimes required to repeat the same name multiple times.
    In this case, a DNS server may encode a pointer to an earlier name instead of
    sending the same name multiple times. A pointer is indicated by a 16-bit value
    with the two most significant bits set. The lower 14 bits indicate the pointer
    value. This 14-bit value specifies the location of the name as an offset from
    the beginning of the message. Having the two most significant bits reserved has
    an additional side-effect of limiting labels to 63 characters. A longer name would
    require setting both high bits in the label length specifier, but if both high
    bits are set, it indicates a pointer and not a label length!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 DNS 响应需要多次重复相同的名称。在这种情况下，DNS 服务器可能会编码一个指向早期名称的指针，而不是多次发送相同的名称。指针由一个 16 位值表示，其中最高两位被设置。最低
    14 位指示指针值。这个 14 位值指定名称的位置，作为从消息开始处的偏移量。保留最高两位的额外副作用是限制标签长度为 63 个字符。一个更长的名称需要设置标签长度指定符中的两个高位，但如果两个高位都被设置，则表示这是一个指针，而不是标签长度！
- en: The answer format is similar to the question format but with a few more fields.
    Let's look at that next.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 答案格式与问题格式类似，但有一些额外的字段。让我们接下来看看这些字段。
- en: Answer format
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案格式
- en: The DNS answer format consists of the same three fields that questions have;
    namely, a name followed by a 16-bit `TYPE` and a 16-bit `CLASS`. The answer format
    then has a 32-bit `TTL` field. This field specifies how many seconds the answer
    is allowed to be cached for. `TTL` is followed by a 16-bit length specifier, `RDLENGTH`,
    followed by data. The data is `RDLENGTH` long, and the data's interpretation is
    dependent upon the type specified by `TYPE`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 答案格式由与问题相同的三个字段组成；即名称后跟一个 16 位的 `TYPE` 和一个 16 位的 `CLASS`。然后答案格式有一个 32 位的
    `TTL` 字段。该字段指定答案允许缓存的秒数。`TTL` 后跟一个 16 位的长度指定符，`RDLENGTH`，然后是数据。数据长度为 `RDLENGTH`，数据的解释取决于
    `TYPE` 指定的类型。
- en: 'Visually, the answer format is shown in the following diagram:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，答案格式在以下图中展示：
- en: '![](img/d78755d4-2ce9-463f-9bc6-f7f5b8a48a5b.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d78755d4-2ce9-463f-9bc6-f7f5b8a48a5b.png)'
- en: Keep in mind that most DNS servers use name pointers in their answer names.
    This is because the DNS response will have already included the relevant name
    in the question section. The answer can simply point back to that, rather than
    encoding the entire name a second (or third) time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，大多数 DNS 服务器在其答案名称中使用名称指针。这是因为 DNS 响应已经在问题部分中包含了相关的名称。答案可以直接指向该名称，而不是再次编码整个名称（第二次或第三次）。
- en: Whenever sending binary data over the network, the issue of byte order becomes
    relevant. Let's consider this now.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在网络上发送二进制数据时，字节序的问题就变得相关了。现在让我们考虑这个问题。
- en: Endianness
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节序
- en: The term **endianness** refers to the order in which individual bytes are stored
    in memory or sent over a network.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 **端序** 指的是单个字节在内存中存储或通过网络发送的顺序。
- en: Whenever we read a multi-byte number from a DNS message, we should be aware
    that it's in big-endian format (or so-called network byte order). The computer
    you're using likely uses little-endian format, although we are careful to write
    our code in an endian-independent manner throughout this book. We accomplish this
    by avoiding the conversion of multiple bytes directly to integers, and instead
    we interpret bytes one at a time.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们从 DNS 消息中读取多字节数字时，我们应该意识到它是以大端格式（或所谓的网络字节序）存储的。你使用的计算机可能使用的是小端格式，尽管我们在整本书中都非常小心地以端无关的方式编写代码。我们通过避免直接将多个字节直接转换为整数，而是逐个解释字节来实现这一点。
- en: For example, consider a message with a single 8-bit value, such as `0x05`. We
    know that the value of that message is `5`. Bytes are sent atomically over a network
    link, so we also know that anyone receiving our message can unambiguously interpret
    that message as `5`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个包含单个 8 位值的消息，例如 `0x05`。我们知道该消息的值是 `5`。字节以原子方式通过网络链路发送，所以我们还知道接收我们消息的任何人都可以明确地将该消息解释为
    `5`。
- en: The issue of endianness comes into play when we need more than one byte to store
    our number. Imagine that we want to send the number `999`. This number is too
    big to fit into 1 byte, so we have to break it up into 2 bytes—a 16-bit value.
    Because `999 = (3 * 2⁸) + 231`, we know that the high-order byte stores `3` while
    the low-order byte stores `231`. In hexadecimal, the number `999` is `0x03E7`.
    The question is whether to send the high-order or the low-order byte over the
    network first.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要多个字节来存储我们的数字时，字节序的问题就会出现。想象一下，我们想要发送数字`999`。这个数字太大，无法放入1个字节中，所以我们必须将其拆分为2个字节——一个16位值。因为`999
    = (3 * 2⁸) + 231`，我们知道高位字节存储`3`，而低位字节存储`231`。在十六进制中，数字`999`是`0x03E7`。问题是先发送高位字节还是低位字节。
- en: Network byte order, which is used by the DNS protocol, specifies that the high-order
    byte is sent first. Therefore, the number `999` is sent over the network as a
    `0x03` followed by `0xE7`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: DNS协议使用的网络字节序指定高位字节首先发送。因此，数字`999`在网络上是作为`0x03`后跟`0xE7`发送的。
- en: See the *Further reading* section of this chapter for more information.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅本章的*进一步阅读*部分。
- en: Let's now look at encoding an entire DNS query.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何编码整个DNS查询。
- en: A simple DNS query
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的DNS查询
- en: To perform a simple DNS query, we would put an arbitrary number into `ID`, set
    the `RD` bit to `1`, and set `QDCOUNT` to `1`. We would then add a question after
    the header. That data would be sent as a UDP packet to port `53` of a DNS server.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行一个简单的DNS查询，我们将任意数字放入`ID`，将`RD`位设置为`1`，并将`QDCOUNT`设置为`1`。然后我们在头部之后添加一个问题。这些数据将作为UDP数据包发送到DNS服务器的端口`53`。
- en: 'A hand-constructed DNS for `example.com` in C is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 用C语言编写的`example.com`的DNS查询如下：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This data could be sent as is to a DNS server over port `53`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据可以直接发送到DNS服务器的端口`53`。
- en: The DNS server, if successful, sends a UDP packet back as a response. This packet
    has `ID` set to match our query. `QR` is set to indicate a response. `QDCOUNT` is
    set to `1`, and our original question is included. `ANCOUNT` is some small positive
    integer that indicates the number of answers included in the message.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: DNS服务器，如果成功，会发送一个UDP数据包作为响应。这个数据包将`ID`设置为与我们的查询匹配。`QR`设置为指示一个响应。`QDCOUNT`设置为`1`，并包含我们的原始问题。`ANCOUNT`是一个小的正整数，表示消息中包含的答案数量。
- en: In the next section, we'll implement a program to send and receive DNS messages.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现一个程序来发送和接收DNS消息。
- en: A DNS query program
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS查询程序
- en: We will now implement a utility to send DNS queries to a DNS server and receive
    the DNS response.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现一个实用工具，用于向DNS服务器发送DNS查询并接收DNS响应。
- en: This should not normally be needed in the field. It is, however, a good opportunity
    to better understand the DNS protocol and to get experience of sending binary
    UDP packets.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中通常不需要这个函数。然而，这是一个更好地理解DNS协议并获得发送二进制UDP数据包经验的好机会。
- en: We begin with a function to print a name from a DNS message.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个DNS消息中打印名称的函数开始。
- en: Printing a DNS message name
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印DNS消息名称
- en: DNS encodes names in a particular way. Normally, each label is indicated by
    its length, followed by its text. A number of labels can be repeated, and then
    the name is terminated with a single 0 byte.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: DNS以特定方式编码名称。通常，每个标签由其长度指示，后跟其文本。可以重复多个标签，然后使用单个0字节终止名称。
- en: If a length has its two highest bits set (that is, `0xc0`), then it and the
    next byte should be interpreted as a pointer instead.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个长度的两个最高位被设置（即`0xc0`），那么它和下一个字节应该被解释为一个指针。
- en: We must also be aware at all times that the DNS response from the DNS server
    could be ill-formed or corrupted. We must try to write our program in such a way
    that it won't crash if it receives a bad message. This is easier said than done.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须始终意识到，DNS服务器返回的DNS响应可能是格式不正确或损坏的。我们必须尽量编写我们的程序，以便在接收到坏消息时不会崩溃。说起来容易做起来难。
- en: 'The declaration for our name-printing function looks like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们名称打印函数的声明如下：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We take `msg` to be a pointer to the message's beginning, `p` to be a pointer
    to the name to print, and `end` to be a pointer to one past the end of the message.
    `end` is required so that we can check that we're not reading past the end of
    the received message. `msg` is required for the same reason, but also so that
    we can interpret name pointers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`msg`视为消息开始的指针，`p`视为打印名称的指针，`end`视为消息结束之后的指针。`end`是必需的，这样我们就可以检查我们是否没有读取到接收到的消息的末尾。`msg`也是必需的，但也是为了我们可以解释名称指针。
- en: 'Inside the `print_name` function, our code checks that a proper name is even
    possible. Because a name should consist of at least a length and some text, we
    can return an error if `p` is already within two characters of the end. The code
    for that check is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `print_name` 函数内部，我们的代码检查一个合适的名称是否可能。因为一个名称应该至少包含一个长度和一些文本，如果 `p` 已经在末尾两个字符之内，我们可以返回一个错误。该检查的代码如下：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then check to see if `p` points to a name pointer. If it does, we interpret
    the pointer and call `print_name` recursively to print the name that is pointed
    to. The code for this is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后检查 `p` 是否指向一个名称指针。如果是，我们解释该指针并递归调用 `print_name` 来打印指向的名称。该代码如下：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that `0xC0` in binary is `0b11000000`. We use `(*p & 0xC0) == 0xC0` to
    check for a name pointer. In that case, we take the lower 6 bits of `*p` and all
    8 bits of `p[1]` to indicate the pointer. We know that `p[1]` is still within
    the message because of our earlier check that `p` was at least 2 bytes from the
    end. Knowing the name pointer, we can pass a new value of `p` to `print_name()`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，二进制中的 `0xC0` 是 `0b11000000`。我们使用 `(*p & 0xC0) == 0xC0` 来检查名称指针。在这种情况下，我们取
    `*p` 的低 6 位和 `p[1]` 的所有 8 位来表示指针。由于我们之前检查 `p` 至少在消息末尾 2 个字节处，我们知道 `p[1]` 仍然在消息内。知道了名称指针后，我们可以将新的
    `p` 值传递给 `print_name()`。
- en: 'If the name is not a pointer, we simply print it one label at a time. The code
    for printing the name is as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果名称不是一个指针，我们简单地逐个标签打印它。打印名称的代码如下：
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, `*p` is read into `len` to store the length of the current
    label. We are careful to check that reading `len + 1` bytes doesn't put us past
    the end of the buffer. We can then print the next `len` characters to the console.
    If the next byte isn't `0`, then the name is continued, and we should print a
    dot to separate the labels. We call `print_name()` recursively to print the next
    label of the name.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`*p` 被读取到 `len` 中以存储当前标签的长度。我们小心地检查读取 `len + 1` 字节不会使我们超出缓冲区的末尾。然后我们可以打印出控制台上的下一个
    `len` 个字符。如果下一个字节不是 `0`，那么名称将继续，我们应该打印一个点来分隔标签。我们递归调用 `print_name()` 来打印名称的下一个标签。
- en: If the next byte is `0`, then that means the name is finished and we return.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下一个字节是 `0`，那么这意味着名称已结束，我们返回。
- en: That concludes the `print_name()` function.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 `print_name()` 函数。
- en: Now we will devise a function that prints an entire DNS message.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将设计一个函数来打印整个 DNS 消息。
- en: Printing a DNS message
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印 DNS 消息
- en: Using `print_name()` that we have just defined, we can now construct a function
    to print an entire DNS message to the screen. DNS messages share the same format
    for both the request and the response, so our function is able to print either.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们刚刚定义的 `print_name()`，我们现在可以构建一个函数来将整个 DNS 消息打印到屏幕上。DNS 消息在请求和响应中都使用相同的格式，所以我们的函数能够打印出任何一种。
- en: 'The declaration for our function is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数的声明如下：
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`print_dns_message()` takes a pointer to the start of the message, and an `int` data
    type indicates the message''s length.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_dns_message()` 接收一个指向消息开始的指针，以及一个 `int` 数据类型来指示消息的长度。'
- en: Inside `print_dns_message()`, we first check that the message is long enough
    to be a valid DNS message. Recall that the DNS header is 12 bytes long. If a DNS
    message is less than 12 bytes, we can easily reject it as an invalid message.
    This also ensures that we can read at least the header without worrying about
    reading past the end of the received data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `print_dns_message()` 函数内部，我们首先检查消息是否足够长，以成为有效的 DNS 消息。回想一下，DNS 头部长度为 12 字节。如果一个
    DNS 消息小于 12 字节，我们可以轻松地将其拒绝为无效消息。这也确保了我们至少可以读取头部，而不用担心读取到接收数据的末尾。
- en: 'The code for checking the DNS message length is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 DNS 消息长度的代码如下：
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We then copy the `message` pointer into a new variable, `msg`. We define `msg`
    as an `unsigned char` pointer, which makes certain calculations easier to work
    with.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `message` 指针复制到一个新变量 `msg` 中。我们定义 `msg` 为一个 `unsigned char` 指针，这使得某些计算更容易处理。
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you want to print out the entire raw DNS message, you can do that with the
    following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想打印出整个原始 DNS 消息，你可以使用以下代码：
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Be aware that running the preceding code will print out many lines. This can
    be annoying, so I would recommend using it only if you are curious about seeing
    the raw DNS message.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，运行前面的代码将打印出许多行。这可能会很烦人，所以我建议只有在你好奇想看到原始 DNS 消息时才使用它。
- en: 'The message ID can be printed very easily. Recall that the message ID is simply
    the first two bytes of the message. The following code prints it in a nice hexadecimal
    format:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 消息 ID 可以非常容易地打印出来。回想一下，消息 ID 只是消息的前两个字节。以下代码以良好的十六进制格式打印它：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we get the `QR` bit from the message header. This bit is the most significant
    bit of `msg[2]`. We use the bitmask `0x80` to see whether it is set. If it is,
    we know that the message is a response; otherwise, it''s a query. The following
    code reads `QR` and prints a corresponding message:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从消息头中获取 `QR` 位。这个位是 `msg[2]` 的最高有效位。我们使用掩码 `0x80` 来查看它是否被设置。如果是，我们知道这是一个响应消息；否则，它是一个查询。以下代码读取
    `QR` 并打印相应的消息：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `OPCODE`, `AA`, `TC`, and `RD` fields are read in much the same way as
    `QR`. The code for printing them is as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPCODE`、`AA`、`TC` 和 `RD` 字段与 `QR` 的读取方式几乎相同。打印它们的代码如下：'
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we can read in `RCODE` for response-type messages. Since `RCODE` can
    have several different values, we use a `switch` statement to print them. Here
    is the code for that:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以读取响应类型消息的 `RCODE`。由于 `RCODE` 可以有多个不同的值，我们使用 `switch` 语句来打印它们。以下是相应的代码：
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next four fields in the header are the question count, the answer count,
    the name server count, and the additional count. We can read and print them in
    the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 标头中的下一个四个字段是问题计数、答案计数、名称服务器计数和附加计数。我们可以在以下代码中读取并打印它们：
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That concludes reading the DNS message header (the first 12 bytes).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 DNS 消息头（前 12 个字节）的读取。
- en: 'Before reading the rest of the message, we define two new variables as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取消息的其余部分之前，我们定义了两个新变量，如下所示：
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, the `p` variable is used to walk through the message.
    We set the `end` variable to one past the end of the message. This is to help
    us detect whether we're about to read past the end of the message – a situation
    we certainly wish to avoid!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`p` 变量用于遍历消息。我们将 `end` 变量设置为消息结束之后的一个位置。这是为了帮助我们检测是否即将读取到消息的末尾——这是一个我们当然希望避免的情况！
- en: 'We read and print each question in the DNS message with the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码读取并打印 DNS 消息中的每个问题：
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Although no real-world DNS server will accept a message with multiple questions,
    the DNS RFC does clearly define the format to encode multiple questions. For that
    reason, we make our code loop through each question using a `for` loop. First,
    the `print_name()` function, which we defined earlier, is called to print the
    question name. We then read in and print out the question type and class.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有实际的 DNS 服务器会接受包含多个问题的消息，但 DNS RFC 明确定义了编码多个问题的格式。因此，我们使我们的代码通过 `for` 循环遍历每个问题。首先，调用我们之前定义的
    `print_name()` 函数来打印问题名称。然后，读取并打印问题类型和类别。
- en: 'Printing the answer, authority, and additional sections is slightly more difficult
    than the question section. These sections start the same way as the question section
    – with a name, a type, and a class. The code for reading the name, type, and class
    is as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 打印答案、授权和附加部分比打印问题部分稍微困难一些。这些部分以与问题部分相同的方式开始——有一个名称、一个类型和一个类别。读取名称、类型和类别的代码如下：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that, in the preceding code, we stored the class in a variable called `qclass`.
    This is to be nice to our C++ friends, who are not allowed to use `class` as a
    variable name.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面提到的代码中，我们将类别存储在一个名为 `qclass` 的变量中。这是为了对 C++ 朋友友好，他们不允许将 `class` 作为变量名。
- en: 'We then expect to find a 16-bit TTL field, and a 16-bit data length field.
    The TTL field tells us how many seconds we are allowed to cache an answer for.
    The data length field tells us how many bytes of additional data are included
    for the answer. We read TTL and the data length in the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们期望找到一个 16 位的 TTL 字段和一个 16 位的长度字段。TTL 字段告诉我们可以缓存答案多少秒。数据长度字段告诉我们答案中包含多少字节的附加数据。我们在以下代码中读取
    TTL 和数据长度：
- en: '[PRE38]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Before we can read in the data of the `rdlen` length, we should check that
    we won''t read past the end of the message. The following code achieves that:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取 `rdlen` 长度的数据之前，我们应该检查我们不会读取到消息的末尾。以下代码实现了这一点：
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can then try to interpret the answer data. Each record type stores different
    data. We need to write code to display each type. For our purposes, we limit this
    to the `A`, `MX`, `AAAA`, `TXT`, and `CNAME` records. The code to print each type
    is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以尝试解释答案数据。每种记录类型存储不同的数据。我们需要编写代码来显示每种类型。就我们的目的而言，我们限制这仅限于 `A`、`MX`、`AAAA`、`TXT`
    和 `CNAME` 记录。打印每种类型的代码如下：
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can then finish the loop. We check that all the data was read and print
    a message if it wasn''t. If our program is correct, and if the DNS message is
    properly formatted, we should have read all the data with nothing left over. The
    following code checks this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以完成循环。我们检查是否读取了所有数据，如果没有，则打印一条消息。如果我们的程序是正确的，并且DNS消息格式正确，我们应该已经读取了所有数据而没有剩余。以下代码检查这一点：
- en: '[PRE41]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That concludes the `print_dns_message()` function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`print_dns_message()`函数。
- en: We can now define our `main()` function to create the DNS query, send it to
    a DNS server, and await a response.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义我们的`main()`函数来创建DNS查询，将其发送到DNS服务器，并等待响应。
- en: Sending the query
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送查询
- en: 'We start `main()` with the following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从以下代码开始`main()`：
- en: '[PRE42]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding code checks that the user passed in a hostname and record type
    to query. If they didn't, it prints a helpful message. It also checks that the
    hostname isn't more than 255 characters long. Hostnames longer than that aren't
    allowed by the DNS standard, and checking it now ensures that we don't need to
    allocate too much memory.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码检查用户是否传递了要查询的域名和记录类型。如果没有，它将打印一条有用的消息。它还检查域名长度是否不超过255个字符。超过这个长度的域名不被DNS标准允许，现在检查它确保我们不需要分配太多的内存。
- en: 'We then try to interpret the record type requested by the user. We support
    the following options – `a`, `aaaa`, `txt`, `mx`, and `any`. The code to read
    in those types and store their corresponding DNS integer value is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们尝试解释用户请求的记录类型。我们支持以下选项 - `a`，`aaaa`，`txt`，`mx`和`any`。读取这些类型并存储它们对应的DNS整数值的代码如下：
- en: '[PRE43]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Like all of our previous programs, we need to initialize Winsock. The code
    for that is as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前所有的程序一样，我们需要初始化Winsock。以下是其代码：
- en: '[PRE44]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our program connects to `8.8.8.8`, which is a public DNS server run by Google.
    Refer to [Chapter 1](e3e07fa7-ff23-4871-b897-c0d4551e6422.xhtml),  *An Introduction
    to Networks and Protocols*, *Domain Names*, for a list of additional public DNS
    servers you can use.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序连接到`8.8.8.8`，这是一个由Google运行的可公开DNS服务器。请参阅[第1章](e3e07fa7-ff23-4871-b897-c0d4551e6422.xhtml)，《网络和协议简介》中的《域名》部分，以获取您可以使用的一些其他公共DNS服务器列表。
- en: 'Recall that we are connecting on UDP port `53`. We use `getaddrinfo()` to set
    up the required structures for our socket with the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们正在连接UDP端口`53`。我们使用`getaddrinfo()`通过以下代码设置套接字所需的结构：
- en: '[PRE45]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then create our socket using the data returned from `getaddrinfo()`. The
    following code does that:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着使用`getaddrinfo()`返回的数据创建我们的套接字。以下代码实现了这一点：
- en: '[PRE46]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Our program then constructs the data for the DNS query message. The first 12
    bytes compose the header and are known at compile time. We can store them with
    the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的程序构建DNS查询消息的数据。前12个字节组成头部，在编译时已知。我们可以用以下代码存储它们：
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding code sets our query's ID to `0xABCD`, sets a recursion request,
    and indicates that we are attaching `1` question. As mentioned earlier, `1` is
    the only number of questions supported by real-world DNS servers.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将我们的查询ID设置为`0xABCD`，设置递归请求，并指示我们附加`1`个问题。如前所述，`1`是现实世界中DNS服务器支持的唯一问题数量。
- en: 'We then need to encode the user''s desired hostname into the query. The following
    code does that:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将用户想要的域名编码到查询中。以下代码实现了这一点：
- en: '[PRE48]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding code first sets a new pointer, `p`, to the end of the query header.
    We will be adding to the query starting at `p`. We also define a pointer, `h`,
    which we use to loop through the hostname.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先将一个新指针`p`设置为查询头部的末尾。我们将从`p`开始添加到查询中。我们还定义了一个指针`h`，我们用它来遍历域名。
- en: We can loop while `*h != 0` because `*h` is equal to zero when we've finished
    reading the hostname. Inside the loop, we use the `len` variable to store the
    position of the label beginning. The value in this position needs to be set to
    indicate the length of the upcoming label. We then copy characters from `*h` to
    `*p` until we find a dot or the end of the hostname. If either is found, the code
    sets `*len` equal to the label length. The code then loops into the next label.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以循环直到`*h != 0`，因为当我们完成读取域名时`*h`等于零。在循环内部，我们使用`len`变量来存储标签开始的位臵。这个位置的值需要设置为指示即将到来的标签的长度。然后我们从`*h`复制字符到`*p`，直到找到一个点或域名的末尾。如果找到任何一个，代码将`*len`设置为标签长度。然后代码进入下一个标签的循环。
- en: Finally, outside the loop, we add a terminating 0 byte to finish the name section
    of the question.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在循环外部，我们添加一个终止的0字节来完成问题的名称部分。
- en: 'We then add the question type and question class to the query with the following
    code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码将问题类型和问题类别添加到查询中：
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can then calculate the query size by comparing `p` to the query beginning.
    The code for figuring the total query size is as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过比较`p`与查询开始处来计算查询大小。计算总查询大小的代码如下：
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, with the query message formed, and its length known, we can use `sendto()`
    to transmit the DNS query to the DNS server. The code for sending the query is
    as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查询消息已经形成，其长度已知，我们可以使用`sendto()`将DNS查询发送到DNS服务器。发送查询的代码如下：
- en: '[PRE51]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For debugging purposes, we can also display the query we sent with the following
    code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试目的，我们还可以使用以下代码显示我们发送的查询：
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding code is useful to see whether we've made any mistakes in encoding
    our query.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码有助于查看我们是否在编码查询时犯了任何错误。
- en: Now that the query has been sent, we await a DNS response message using `recvfrom()`.
    In a practical program, you may want to use `select()` here to time out. It could
    also be wise to listen for additional messages in the case that an invalid message
    is received first.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查询已经发送，我们使用`recvfrom()`等待DNS响应消息。在实际程序中，您可能希望在这里使用`select()`来超时。如果首先收到无效消息，监听额外消息可能也是明智的。
- en: 'The code to receive and display the DNS response is as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接收和显示DNS响应的代码如下：
- en: '[PRE53]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can finish our program by freeing the address(es) from `getaddrinfo()` and
    cleaning up Winsock. The code to complete the `main()` function is as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从`getaddrinfo()`释放地址并清理Winsock来完成我们的程序。完成`main()`函数的代码如下：
- en: '[PRE54]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: That concludes the `dns_query` program.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`dns_query`程序。
- en: 'You can compile and run `dns_query.c` on Linux and macOS by running the following
    command:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令在Linux和macOS上编译和运行`dns_query.c`：
- en: '[PRE55]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Compiling and running on Windows with MinGW is done by using the following
    command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MinGW在Windows上编译和运行可以通过以下命令完成：
- en: '[PRE56]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Try running `dns_query` with different domain names and different record types.
    In particular, try it with `mx` and `txt` records. If you're brave, try running
    it with the `any` record type. You may find the results interesting.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的域名和不同的记录类型运行`dns_query`。特别是，尝试使用`mx`和`txt`记录。如果你有勇气，可以尝试使用`any`记录类型。你可能会发现结果很有趣。
- en: 'The following screenshot is an example of using `dns_query` to query the `A`
    record of `example.com`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是使用`dns_query`查询`example.com`的`A`记录的示例：
- en: '![](img/969470fe-66c2-45b8-bc85-cfc29b63d33b.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/969470fe-66c2-45b8-bc85-cfc29b63d33b.png)'
- en: 'The next screenshot shows `dns_query` querying the `mx` record of `gmail.com`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图显示了`dns_query`正在查询`gmail.com`的`mx`记录：
- en: '![](img/fc7393f1-2aa1-42c4-877a-2f78463f726e.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc7393f1-2aa1-42c4-877a-2f78463f726e.png)'
- en: Note that UDP is not always reliable. If our DNS query is lost in transit, then
    `dns_query` hangs while waiting forever for a reply that never comes. This could
    be fixed by using the `select()` function to time out and retry.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，UDP并不总是可靠的。如果我们的DNS查询在传输过程中丢失，那么`dns_query`将无限期地挂起，等待永远不会到来的回复。这可以通过使用`select()`函数超时并重试来修复。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was all about hostnames and DNS queries. We covered how the DNS
    works, and we learned that resolving a hostname can involve many UDP packets being
    sent over the network.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍了主机名和DNS查询。我们了解了DNS的工作原理，并了解到解析主机名可能涉及在网络中发送许多UDP数据包。
- en: We looked at `getaddrinfo()` in more depth and showed why it is usually the
    preferred way to do a hostname lookup. We also looked at its sister function,
    `getnameinfo()`, which is capable of converting an address to text or even doing
    a reverse DNS query.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更深入地研究了`getaddrinfo()`，并展示了为什么它通常是进行主机名查找的首选方式。我们还研究了其姐妹函数`getnameinfo()`，该函数可以将地址转换为文本，甚至执行反向DNS查询。
- en: Finally, we implemented a program that sent DNS queries from scratch. This program
    was a good learning experience to better understand the DNS protocol, and it gave
    us a chance to gain experience in implementing a binary protocol. When implementing
    a binary protocol, we had to pay special attention to byte order. For the simple
    DNS message format, this was achieved by carefully interpreting bytes one at a
    time.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了一个从头开始发送DNS查询的程序。这个程序是一个很好的学习经验，有助于更好地理解DNS协议，并给了我们实现二进制协议的机会。在实现二进制协议时，我们必须特别注意字节序。对于简单的DNS消息格式，这是通过逐个仔细解释字节来实现的。
- en: Now that we've worked with a binary protocol, DNS, we will move on to text-based
    protocols in the next few chapters. In the next chapter, we will learn about HTTP,
    the protocol used to request and retrieve web pages.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经与二进制协议 DNS 一起工作，接下来几章我们将转向基于文本的协议。在下一章，我们将学习 HTTP，这是请求和检索网页所使用的协议。
- en: Questions
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge of this chapter:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试你对本章知识的掌握：
- en: Which function fills in an address needed for socket programming in a portable
    and protocol-independent way?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个函数以可移植和协议无关的方式填充套接字编程所需的地址？
- en: Which socket programming function can be used to convert an IP address back
    into a name?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个套接字编程函数可以将 IP 地址转换回域名？
- en: A DNS query converts a name into an address, and a reverse DNS query converts
    an address back into a name. If you run a DNS query on a name, and then a reverse
    DNS query on the resulting address, do you always get back the name you started
    with?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DNS 查询将域名转换为地址，而反向 DNS 查询将地址转换回域名。如果你对一个域名执行 DNS 查询，然后对结果地址执行反向 DNS 查询，你是否总是能回到最初的域名？
- en: What are the DNS record types used to return IPv4 and IPv6 addresses for a name?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用哪些 DNS 记录类型来为域名返回 IPv4 和 IPv6 地址？
- en: Which DNS record type stores special information about email servers?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种 DNS 记录类型存储有关电子邮件服务器的特殊信息？
- en: Does `getaddrinfo()` always return immediately? or can it block?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getaddrinfo()` 总是立即返回吗？或者它可以阻塞？'
- en: What happens when a DNS response is too large to fit into a single UDP packet?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 DNS 响应太大而无法放入单个 UDP 数据包时会发生什么？
- en: The answers are in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml),
    *Answers to Questions*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在 [附录 A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml)，*问题解答* 中。
- en: Further reading
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about DNS, please refer to:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 DNS 的信息，请参考：
- en: '**RFC 1034**: *DOMAIN NAMES – CONCEPTS AND FACILITIES* *(*[https://tools.ietf.org/html/rfc1034](https://tools.ietf.org/html/rfc1034))'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 1034**：*域名 – 概念和设施 ([https://tools.ietf.org/html/rfc1034](https://tools.ietf.org/html/rfc1034))'
- en: '**RFC 1035**: *DOMAIN NAMES – IMPLEMENTATION AND SPECIFICATION* *(*[https://tools.ietf.org/html/rfc1035](https://tools.ietf.org/html/rfc1035))'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 1035**：*域名 – 实现和规范 ([https://tools.ietf.org/html/rfc1035](https://tools.ietf.org/html/rfc1035))'
- en: '**RFC 3596**: *DNS Extensions to Support IP Version 6 (*[https://tools.ietf.org/html/rfc3596](https://tools.ietf.org/html/rfc3596))'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 3596**：*支持 IP 版本 6 的 DNS 扩展 ([https://tools.ietf.org/html/rfc3596](https://tools.ietf.org/html/rfc3596))'
