["```cpp\nimport Qt3D.Core 2.0 \nimport Qt3D.Render 2.0 \nimport Qt3D.Extras 2.0 \n\nEntity { \n\n    property alias position: transform.translation \n    PhongMaterial { \n        id: material \n        diffuse: \"red\" \n    } \n\n    SphereMesh { \n        id: mesh \n    } \n\n    Transform { \n        id: transform \n    } \n\n    components: [material, mesh, transform] \n} \n\n```", "```cpp\nimport Qt3D.Core 2.0 \nimport Qt3D.Render 2.0 \nimport Qt3D.Extras 2.0 \n\nEntity { \n    id: sceneRoot \n     RenderSettings { \n        id: frameFraph \n        activeFrameGraph: ForwardRenderer { \n            clearColor: Qt.rgba(0, 0, 0, 1) \n        } \n    } \n\n    Apple { \n        id: apple \n        position: Qt.vector3d(3.0, 0.0, 2.0) \n    } \n\n    components: [frameGraph] \n} \n\n```", "```cpp\nimport Qt3D.Core 2.0 \nimport Qt3D.Render 2.0 \nimport Qt3D.Extras 2.0 \n\n```", "```cpp\nRectangle { \n\n    Scene3D { \n        id: scene \n        anchors.fill: parent \n        focus: true \n\n        World { } \n    } \n} \n\n```", "```cpp\ngit clone git://code.qt.io/qt/<modulename>.git -b 5.7\ncd <modulename>\n~/raspi/qt5/bin/qmake -r\nmake\nmake install\n\n```", "```cpp\nrsync -avz qt5pi pi@IP:/usr/local\n\n```", "```cpp\nTEMPLATE = app \n\nQT += qml quick 3dcore 3drender 3dquick 3dinput 3dextras \nCONFIG += c++11 \n\nSOURCES += main.cpp \n\nRESOURCES += \\ \n    snake.qrc \n\nHEADERS += \n\ntarget.files = ch06-snake \ntarget.path = /home/pi \nINSTALLS += target \n\n```", "```cpp\n#include <QGuiApplication> \n#include <QtGui/QOpenGLContext> \n#include <QtQuick/QQuickView> \n#include <QtQml/QQmlEngine> \n\nint main(int argc, char *argv[]) \n{ \n    QGuiApplication app(argc, argv); \n\n    qputenv(\"QT3D_GLSL100_WORKAROUND\", \"\"); \n\n    QSurfaceFormat format; \n    if (QOpenGLContext::openGLModuleType() == \n        QOpenGLContext::LibGL) { \n        format.setVersion(3, 2); \n        format.setProfile(QSurfaceFormat::CoreProfile); \n    } \n    format.setDepthBufferSize(24); \n    format.setStencilBufferSize(8); \n\n    QQuickView view; \n    view.setFormat(format); \n    view.setResizeMode(QQuickView::SizeRootObjectToView); \n    QObject::connect(view.engine(), &QQmlEngine::quit,  \n                     &app, &QGuiApplication::quit); \n    view.setSource(QUrl(\"qrc:/main.qml\")); \n    view.show(); \n\n    return app.exec(); \n} \n\n```", "```cpp\nimport QtQuick 2.6 \nimport QtQuick.Controls 1.4 \n\nItem { \n    id: mainView \n\n    property int score: 0 \n    readonly property alias window: mainView \n\n    width: 1280; height: 768 \n    visible: true \n\n    Keys.onEscapePressed: { \n        Qt.quit() \n    } \n\n    Rectangle { \n        id: hud \n\n        color: \"#31363b\" \n        anchors.left: parent.left \n        anchors.right: parent.right \n        anchors.top : parent.top \n        height: 60 \n\n        Label { \n            id: snakeSizeText \n            anchors.centerIn: parent \n            font.pointSize: 25 \n            color: \"white\" \n            text: \"Score: \" + score \n        } \n    } \n} \n\n```", "```cpp\nimport QtQuick 2.6 \nimport QtQuick.Controls 1.4 \nimport QtQuick.Scene3D 2.0 \n\nItem { \n    ... \n\n    Rectangle { \n        id: hud \n        ... \n    } \n\n    Scene3D { \n        id: scene \n        anchors.top: hud.bottom \n        anchors.bottom: parent.bottom \n        anchors.left: parent.left \n        anchors.right: parent.right \n        focus: true \n        aspects: \"input\" \n    } \n} \n\n```", "```cpp\nimport Qt3D.Core 2.0 \nimport Qt3D.Render 2.0 \nimport Qt3D.Extras 2.0 \n\nEntity { \n    id: root \n\n    property alias gameRoot: root \n\n    Camera { \n        id: camera \n        property real x: 24.5 \n        property real y: 14.0 \n\n        projectionType: CameraLens.PerspectiveProjection \n        fieldOfView: 45 \n        aspectRatio: 16/9 \n        nearPlane : 0.1 \n        farPlane : 1000.0 \n        position: Qt.vector3d( x, y, 33.0 ) \n        upVector: Qt.vector3d( 0.0, 1.0, 0.0 ) \n        viewCenter: Qt.vector3d( x, y, 0.0 ) \n    } \n\n    RenderSettings { \n        id: frameFraph \n        activeFrameGraph: ForwardRenderer { \n            clearColor: Qt.rgba(0, 0, 0, 1) \n            camera: camera \n        } \n    } \n\n    components: [frameFraph] \n} \n\n```", "```cpp\nimport Qt3D.Core 2.0 \nimport Qt3D.Render 2.0 \nimport Qt3D.Input 2.0 \n\nEntity { \n    ... \n    RenderSettings { \n        ... \n    } \n\n    KeyboardDevice { \n        id: keyboardController \n    } \n\n    InputSettings { id: inputSettings } \n\n    KeyboardHandler { \n        id: input \n        sourceDevice: keyboardController \n        focus: true \n        onPressed: { } \n    } \n\n    components: [frameFraph, input] \n} \n\n```", "```cpp\nimport Qt3D.Core 2.0 \nimport Qt3D.Render 2.0 \nimport Qt3D.Input 2.0 \nimport QtQuick 2.6 as QQ2 \n\nEntity { \n    id: root \n\n    property alias gameRoot: root \n    property alias timerInterval: timer.interval \n    property int initialTimeInterval: 80 \n    property int initialSnakeSize: 5 \n    property string state: \"\" \n    ... \n\n    KeyboardDevice { \n        id: keyboardController \n    } \n\n    QQ2.Component.onCompleted: { \n        console.log(\"Start game...\"); \n        timer.start() \n    } \n\n    QQ2.Timer { \n        id: timer \n        interval: initialTimeInterval \n        repeat: true \n        onTriggered: {} \n    } \n\n    components: [frameFraph, input] \n}  \n\n```", "```cpp\nimport Qt3D.Core 2.0 \n\nEntity { \n    property int type: 0 \n    property vector2d gridPosition: Qt.vector2d(0, 0) \n} \n\n```", "```cpp\nimport Qt3D.Core 2.0 \n\nGameEntity { \n    id: root \n\n    property alias position: transform.translation \n\n    Transform { \n        id: transform \n    } \n\n    components: [transform] \n} \n\n```", "```cpp\nimport Qt3D.Core 2.0 \nimport Qt3D.Render 2.0 \nimport Qt3D.Extras 2.0 \n\nGameEntity { \n    id: root \n\n    property alias position: transform.translation \n\n    PhongMaterial { \n        id: material \n        diffuse: \"green\" \n    } \n\n    CuboidMesh { \n        id: mesh \n    } \n\n    Transform { \n        id: transform \n    } \n\n    components: [material, mesh, transform] \n} \n\n```", "```cpp\nimport Qt3D.Core 2.0 \nimport Qt3D.Render 2.0 \nimport Qt3D.Extras 2.0 \n\nGameEntity { \n    id: root \n\n    property alias position: transform.translation \n    property alias color: material.diffuse \n\n    Transform { \n        id: transform \n        scale: 0.5 \n    } \n\n    Mesh { \n        id: mesh \n        source: \"models/apple.obj\" \n    } \n\n    DiffuseMapMaterial { \n        id: material \n        diffuse: \"qrc:/models/apple-texture.png\" \n    } \n\n    components: [material, mesh, transform] \n} \n\n```", "```cpp\nimport Qt3D.Core 2.0 \nimport Qt3D.Render 2.0 \nimport Qt3D.Extras 2.0 \n\nEntity { \n    id: root \n\n    property alias position: transform.translation \n    property alias scale3D: transform.scale3D \n\n    MaterialBackground { \n        id: material \n    } \n\n    CuboidMesh { \n        id: mesh \n    } \n\n    Transform { \n        id: transform \n    } \n\n    components: [material, mesh, transform] \n} \n\n```", "```cpp\nimport Qt3D.Core 2.0 \nimport Qt3D.Render 2.0 \n\nMaterial { \n    id: material \n\n    effect: Effect { \n        techniques: [ \n            Technique { \n                graphicsApiFilter { \n                    api: GraphicsApiFilter.OpenGL \n                    majorVersion: 3 \n                    minorVersion: 2 \n                } \n                renderPasses: RenderPass { \n                    shaderProgram: ShaderProgram { \n                        vertexShaderCode:   \n                        loadSource(\"qrc:/shaders/gl3/grass.vert\") \n                        fragmentShaderCode:  \n                        loadSource(\"qrc:/shaders/gl3/grass.frag\") \n                    } \n                } \n            } \n        ] \n    } \n} \n\n```", "```cpp\nTechnique { \n    graphicsApiFilter { \n        api: GraphicsApiFilter.OpenGLES \n        majorVersion: 2 \n        minorVersion: 0 \n    } \n\n    renderPasses: RenderPass { \n        shaderProgram: ShaderProgram { \n            vertexShaderCode:  \n                loadSource(\"qrc:/shaders/es2/grass.vert\") \n            fragmentShaderCode:  \n                loadSource(\"qrc:/shaders/es2/grass.frag\") \n        } \n    } \n} \n\n```", "```cpp\nMaterial { \n    id: material \n\n    parameters:  [ \n        Parameter { \n            name: \"score\"; value: score \n        } \n    ] \n    ... \n} \n\n```", "```cpp\nEntity { \n    id: root \n    ... \n\n    Background { \n        position: Qt.vector3d(camera.x, camera.y, 0) \n        scale3D: Qt.vector3d(camera.x * 2, camera.y * 2, 0) \n    } \n\n    components: [frameFraph, input] \n} \n\n```", "```cpp\nfunction Board(columnCount, rowCount, blockSize) { \n    this.columnCount = columnCount; \n    this.rowCount = rowCount; \n    this.blockSize = blockSize; \n    this.maxIndex = columnCount * rowCount; \n    this.data = new Array(this.maxIndex); \n} \n\n```", "```cpp\nBoard.prototype.init = function() { \n    for (var i = 0; i < this.data.length; i++) { \n        this.data[i] = null; \n    } \n} \n\nBoard.prototype.index = function(column, row) { \n    return column + (row * this.columnCount); \n} \n\nBoard.prototype.setData = function(data, column, row) { \n    this.data[this.index(column, row)] = data; \n} \n\nBoard.prototype.at = function(column, row) { \n    return this.data[this.index(column, row)]; \n} \n\n```", "```cpp\nvar SNAKE_TYPE = 1; \nvar WALL_TYPE  = 2; \nvar APPLE_TYPE = 3; \n\nvar snakeComponent = Qt.createComponent(\"Snake.qml\"); \nvar wallComponent = Qt.createComponent(\"Wall.qml\"); \nvar appleComponent = Qt.createComponent(\"Apple.qml\"); \n\n```", "```cpp\nfunction GameFactory() { \n\n    this.board = null; \n    this.parentEntity = null; \n    this.entities = []; \n} \n\nGameFactory.prototype.removeAllEntities = function() { \n    for(var i = 0; i < this.entities.length; i++) { \n        this.entities[i].setParent(null); \n    } \n\n```", "```cpp\nGameFactory.prototype.createGameEntity = function(type, column, row) { \n    var component; \n    switch(type) { \n    case SNAKE_TYPE: \n        component = snakeComponent; \n        break; \n\n    case WALL_TYPE: \n        component = wallComponent; \n        break; \n\n    case APPLE_TYPE: \n        component = appleComponent; \n        break; \n    } \n    var gameEntity = component.createObject(this.parentEntity); \n    gameEntity.setParent(this.parentEntity); \n\n    this.board.setData(gameEntity, column, row); \n    gameEntity.gridPosition = Qt.vector2d(column, row); \n    gameEntity.position.x = column * this.board.blockSize; \n    gameEntity.position.y = row * this.board.blockSize; \n\n    this.entities.push(gameEntity); \n    return gameEntity; \n} \n\n```", "```cpp\nimport \"factory.js\" as Factory \n\nGameEntity { \n\n    id: root \n    type: Factory.APPLE_TYPE \n    ... \n} \n\n```", "```cpp\n.import \"factory.js\" as Factory \n.import \"board.js\" as Board \n\nvar COLUMN_COUNT = 50; \nvar ROW_COUNT = 29; \nvar BLOCK_SIZE = 1; \n\nvar factory = new Factory.GameFactory(); \nvar board = new Board.Board(COLUMN_COUNT, ROW_COUNT, BLOCK_SIZE); \n\nvar snake = []; \nvar direction; \n\n```", "```cpp\nfunction start() { \n    initEngine(); \n\n    createSnake(); \n    createWalls(); \n\n    spawnApple(); \n    gameRoot.state = \"PLAY\"; \n} \n\n```", "```cpp\nfunction initEngine() { \n    timer.interval = initialTimeInterval; \n    score = 0; \n\n    factory.board = board; \n    factory.parentEntity = gameRoot; \n    factory.removeAllEntities(); \n\n    board.init(); \n    direction = Qt.vector2d(-1, 0); \n} \n\n```", "```cpp\nfunction createSnake() { \n    snake = []; \n    var initialPosition = Qt.vector2d(25, 12); \n    for (var i = 0; i < initialSnakeSize; i++) { \n       snake.push(factory.createGameEntity(Factory.SNAKE_TYPE, \n                                 initialPosition.x + i, \n                                 initialPosition.y)); \n    } \n} \n\n```", "```cpp\nfunction createWalls() { \n    for (var x = 0; x < board.columnCount; x++) { \n        factory.createGameEntity(Factory.WALL_TYPE, x, 0); \n        factory.createGameEntity(Factory.WALL_TYPE, x, board.rowCount - 1); \n    } \n    for (var y = 1; y < board.rowCount - 1; y++) { \n        factory.createGameEntity(Factory.WALL_TYPE, 0, y); \n        factory.createGameEntity(Factory.WALL_TYPE, board.columnCount - 1, y); \n    } \n} \n\n```", "```cpp\nfunction spawnApple() { \n    var isFound = false; \n    var position; \n    while (!isFound) { \n        position = Qt.vector2d(Math.floor(Math.random()  \n                                    * board.columnCount), \n                               Math.floor(Math.random()  \n                                    * board.rowCount)); \n        if (board.at(position.x, position.y) == null) { \n            isFound = true; \n        } \n    } \n    factory.createGameEntity(Factory.APPLE_TYPE, position.x, position.y); \n\n    if (timerInterval > 10) { \n        timerInterval -= 2; \n    } \n} \n\n```", "```cpp\nfunction setPosition(item, column, row) { \n    board.setData(item, column, row); \n    item.gridPosition = Qt.vector2d(column, row); \n    item.position.x = column * board.blockSize; \n    item.position.y = row * board.blockSize; \n} \n\nfunction moveSnake(column, row) { \n    var last = snake.pop(); \n    board.setData(null, last.gridPosition.x, last.gridPosition.y); \n    setPosition(last, column, row); \n    snake.unshift(last); \n} \n\n```", "```cpp\nfunction handleKeyEvent(event) { \n    switch(event.key) { \n        // restart game \n        case Qt.Key_R: \n            start(); \n            break; \n\n        // direction UP \n        case Qt.Key_I: \n            if (direction != Qt.vector2d(0, -1)) { \n                direction = Qt.vector2d(0, 1); \n            } \n            break; \n\n        // direction RIGHT \n        case Qt.Key_L: \n            if (direction != Qt.vector2d(-1, 0)) { \n                direction = Qt.vector2d(1, 0); \n            } \n            break; \n\n        // direction DOWN \n        case Qt.Key_K: \n            if (direction != Qt.vector2d(0, 1)) { \n                direction = Qt.vector2d(0, -1); \n            } \n            break; \n\n        // direction LEFT \n        case Qt.Key_J: \n            if (direction != Qt.vector2d(1, 0)) { \n                direction = Qt.vector2d(-1, 0); \n            } \n            break; \n    } \n} \n\n```", "```cpp\nfunction update() { \n    if (gameRoot.state == \"GAMEOVER\") { \n        return; \n    } \n\n    var headPosition = snake[0].gridPosition; \n    var newPosition = Qt.vector2d(headPosition.x + direction.x, \n                                  headPosition.y + direction.y); \n    var itemOnNewPosition = board.at(newPosition.x, \n                                     newPosition.y); \n\n   ... \n} \n\n```", "```cpp\nfunction update() { \n    ... \n    if(itemOnNewPosition == null) { \n        moveSnake(newPosition.x, newPosition.y); \n        return; \n    } \n\n    switch(itemOnNewPosition.type) { \n        case Factory.SNAKE_TYPE: \n            gameRoot.state = \"GAMEOVER\"; \n            break; \n\n        case Factory.WALL_TYPE: \n            gameRoot.state = \"GAMEOVER\"; \n            break; \n\n        case Factory.APPLE_TYPE: \n            itemOnNewPosition.setParent(null); \n            board.setData(null, newPosition.x, newPosition.y); \n            snake.unshift(factory.createGameEntity( \n                   Factory.SNAKE_TYPE, \n                   newPosition.x, \n                   newPosition.y)); \n            spawnApple(); \n            score++; \n            break; \n    } \n} \n\n```", "```cpp\n... \nimport \"engine.js\" as Engine \n\nEntity { \n    ... \n    QQ2.Component.onCompleted: { \n        console.log(\"Start game...\"); \n        Engine.start(); \n        timer.start() \n    } \n\n    QQ2.Timer { \n        id: timer \n        interval: initialTimeInterval \n        repeat: true \n        onTriggered: Engine.update() \n    } \n\n    KeyboardInput { \n        id: input \n        controller: keyboardController \n        focus: true \n        onPressed: Engine.handleKeyEvent(event) \n    } \n    ... \n} \n\n```", "```cpp\nItem { \n    id: root \n    anchors.fill: parent \n\n    onVisibleChanged: { \n        scoreLabel.text = \"Your score: \" + score \n    } \n\n    Rectangle { \n        anchors.fill: parent \n        color: \"black\" \n        opacity: 0.75 \n    } \n\n    Label { \n        id: gameOverLabel \n        anchors.centerIn: parent \n        color: \"white\" \n        font.pointSize: 50 \n        text: \"Game Over\" \n    } \n\n    Label { \n        id: scoreLabel \n        width: parent.width \n        anchors.top: gameOverLabel.bottom \n        horizontalAlignment: \"AlignHCenter\" \n        color: \"white\" \n        font.pointSize: 20 \n    } \n\n    Label { \n        width: parent.width \n        anchors.bottom: parent.bottom \n        anchors.bottomMargin: 50 \n        horizontalAlignment: \"AlignHCenter\" \n        color: \"white\" \n        font.pointSize: 30 \n        text:\"Press R to restart the game\" \n    } \n} \n\n```", "```cpp\nItem { \n    id: root \n\n    states: [ \n        State { \n            name: \"PLAY\" \n            PropertyChanges { target: root; visible: false } \n        }, \n        State { \n            name: \"GAMEOVER\" \n            PropertyChanges { target: root; visible: true } \n            PropertyChanges { target: gameOver; visible: true } \n        } \n    ] \n\n    GameOverItem { \n        id: gameOver \n    } \n} \n\n```", "```cpp\nItem { \n    id: mainView \n    property int score: 0 \n    readonly property alias window: mainView \n    ... \n    OverlayItem { \n        id: overlayItem \n        anchors.fill: mainView \n        visible: false \n\n        Connections { \n            target: gameArea \n            onStateChanged: { \n                overlayItem.state = gameArea.state; \n            } \n        } \n    } \n} \n\n```", "```cpp\non<PropertyName>Changed \n\n```", "```cpp\n-qmljsdebugger=file:/tmp/QtCreator.OU7985 \n\n```", "```cpp\n-qmljsdebugger=port:10000 \n\n```", "```cpp\n./ch06-snake -qmljsdebugger=port:3768 \n\n```"]