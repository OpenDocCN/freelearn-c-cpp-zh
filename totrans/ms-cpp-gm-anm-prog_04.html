<html><head></head><body><div><div><div><h1 class="chapterNumber">3</h1>
    <h1 id="_idParaDest-85" class="chapterTitle">Adding a Visual Selection</h1>
    <p class="normal">Welcome to <a href=""><em class="italic">Chapter 3</em></a>! In the previous chapter, we offloaded the majority of matrix and vector calculations to the GPU. A modern graphics card has more (and also more specialized) computing cores than a desktop CPU, so, moving the compute load to the GPU will free the main CPU from most of the animation work.</p>
    <p class="normal">In this chapter, we will add a couple of simplifications when working with a lot of model instances. After the changes in the previous chapter, we are able to display thousands of model instances on the screen, but selecting a specific instance is still hard. We will start by adding coordinate arrows to identify the currently selected instance. Next, we will add a function that allows us to center the specified instance in the middle of the screen. Then, a graphical highlight will be created, further helping us to find the selected instance among all instances. As the last step, we will add a model without triangles, and an instance from this empty model, allowing us to deselect the visible instances.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Implementing a “move to instance” function</li>
      <li class="bulletList">Adding a highlight to the selected instance</li>
      <li class="bulletList">Selecting a model instance with point and click</li>
      <li class="bulletList">Implementing a null object to allow deselection</li>
    </ul>
    <p class="normal">At first glance, these topics may look unrelated to animation programming. But proper tooling is an essential part of creating a user-friendly application. Good tools will help the user to simplify application handling.</p>
    <p class="normal">Later in the book, when you have created dozens or even hundreds of instances that are happily jumping and running around randomly on the screen, selecting one instance by simply clicking on it with the mouse, using a UI button to center the instance on the screen, or moving and rotating the instance by using the mouse will make your life a lot easier. And you might even forget how cumbersome the first two chapters were when it came to selecting an instance or changing instance properties.</p>
    <h1 id="_idParaDest-86" class="heading-1">Technical requirements</h1>
    <p class="normal">We will need the application code from <a href="Chapter_2.xhtml"><em class="italic">Chapter 2</em></a>: <a href="https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming">https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming</a>.</p>
    <p class="normal">The example source code for this chapter can be found in the folder <code class="inlineCode">chapter03</code>, subfolder <code class="inlineCode">01_opengl_selection</code> for OpenGL, and <code class="inlineCode">02_vulkan_selection</code> for Vulkan.</p>
    <h1 id="_idParaDest-87" class="heading-1">Implementing a “move to instance” function</h1>
    <p class="normal">As the first change for the “move to instance” functionality, we will add a small set of coordinate arrows appearing at<a id="_idIndexMarker111"/> the origin of the drawn model to identify the currently selected instance. We will also add a button to center the currently selected instance. Let’s start with the implementation of the coordinate arrows.</p>
    <h2 id="_idParaDest-88" class="heading-2">Adding coordinate arrows</h2>
    <p class="normal">Since we will use lines instead of<a id="_idIndexMarker112"/> triangles to draw coordinate arrows at the center of the selected instance, we need some extra data structures, objects and shaders. To store the vertex and color data, we add two new structs to the declarations in the file <code class="inlineCode">OGLRenderData.h</code> in the <code class="inlineCode">opengl</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code">struct OGLLineVertex {
  glm::vec3 position = glm::vec3(0.0f);
  glm::vec3 color = glm::vec3(0.0f);
};
struct OGLLineMesh {
  std::vector&lt;OGLLineVertex&gt; vertices{};
};
</code></pre>
    <p class="normal">For Vulkan, the new structs are named <code class="inlineCode">VkLineVertex</code> and <code class="inlineCode">VkLineMesh</code>, residing in the file <code class="inlineCode">VkRenderData.h</code> in the <code class="inlineCode">vulkan</code> folder.</p>
    <p class="normal">Uploading the coordinate arrow data to the GPU, a new class, <code class="inlineCode">LineVertexBuffer</code>, in the <code class="inlineCode">opengl</code> folder, will be added. A simple way to get the new class files is to copy the two source files for the <code class="inlineCode">VertexIndexBuffer</code> class (<code class="inlineCode">VertexIndexBuffer.h</code> and <code class="inlineCode">VertexIndexBuffer.cpp</code>) in the <code class="inlineCode">opengl</code> folder, and then adjust the <code class="inlineCode">init()</code> method to send <code class="inlineCode">position</code> and <code class="inlineCode">color</code> data to the graphics card:</p>
    <pre class="programlisting code"><code class="hljs-code">  glVertexAttribPointer(0, 3, GL_FLOAT,
    GL_FALSE, sizeof(OGLLineVertex),
    (void*) offsetof(OGLLineVertex, position));
  glVertexAttribPointer(1, 3, GL_FLOAT,
    GL_FALSE, sizeof(OGLLineVertex),
    (void*) offsetof(OGLLineVertex, color));
  glEnableVertexAttribArray(0);
  glEnableVertexAttribArray(1);
</code></pre>
    <p class="normal">We must also enable both the <code class="inlineCode">position</code> and the <code class="inlineCode">color</code> attributes by using <code class="inlineCode">glEnableVertexAttribArray()</code> with the corresponding index values (the first parameter of <code class="inlineCode">glVertexAttribPointer</code>) to send the vertex data for both attributes to the vertex shader.</p>
    <p class="normal">On the GPU side, two simple pass-through shaders are needed – the vertex and fragment shader will only pass the data through without additional transformations, except the required view and projection matrix transformations. The vertex shader named <code class="inlineCode">line.vert</code>, located in the <code class="inlineCode">shader</code> folder, uses the <code class="inlineCode">view</code> and <code class="inlineCode">projection</code> matrices of the camera position to calculate the final vertex positions. Then, the position and the color of the line endpoints are handed over to the fragment<a id="_idIndexMarker113"/> shader named <code class="inlineCode">line.frag</code>, also located in the <code class="inlineCode">shader</code> folder.</p>
    <p class="normal">The vertices for our coordinate arrows are taken from a static model file named <code class="inlineCode">CoordArrowsModel</code> in the <code class="inlineCode">model</code> folder. We can hard-code the vertex positions and colors to keep the initialization simple:</p>
    <pre class="programlisting code"><code class="hljs-code">  /*  X axis - red */
  mVertexData.vertices[0].position =
    glm::vec3(0.0f,0.0f, 0.0f);
  mVertexData.vertices[1].position =
    glm::vec3(1.0f, 0.0f,  0.0f);
  mVertexData.vertices[2].position =
    glm::vec3(1.0f, 0.0f,  0.0f);
  ...
  mVertexData.vertices[0].color =
    glm::vec3(0.8f, 0.0f, 0.0f);
  mVertexData.vertices[1].color =
    glm::vec3(0.8f, 0.0f, 0.0f);
  mVertexData.vertices[2].color =
    glm::vec3(0.8f, 0.0f, 0.0f);
  ...
</code></pre>
    <p class="normal">The final positions for the vertices of the coordinate arrows are set in the <code class="inlineCode">draw()</code> call of the render. As the first step, the line counter will be zeroed, and the <code class="inlineCode">mLineMesh</code> vector for the vertices of the coordinate arrows is cleared:</p>
    <pre class="programlisting code"><code class="hljs-code">  mCoordArrowsLineIndexCount = 0;
  mLineMesh-&gt;vertices.clear();
</code></pre>
    <p class="normal">Next, we retrieve the settings of the currently selected instance, containing the position and rotation of the instance:</p>
    <pre class="programlisting code"><code class="hljs-code">  InstanceSettings instSettings =
    mModelInstData.miAssimpInstances.at(
    mModelInstData.miSelectedInstance)
    -&gt;getInstanceSettings();
</code></pre>
    <p class="normal">Then, we add the number of vertices to the line counter variable <code class="inlineCode">mCoordArrowsLineIndexCount</code> and iterate over each vertex in a <code class="inlineCode">std::for_each</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">mCoordArrowsLineIndexCount +=
     mCoordArrowsMesh.vertices.size();
std::for_each(mCoordArrowsMesh.vertices.begin(),
    mCoordArrowsMesh.vertices.end(),
      [=](auto &amp;n){
      n.color /= 2.0f;
      n.position =
        glm::quat(glm::radians(
        instSettings.isWorldRotation)) * n.position;
        n.position += instSettings.isWorldPosition;
    });
</code></pre>
    <p class="normal">By using a lambda function, the position data of the vertices is altered to match the position and rotation of the instance. In<a id="_idIndexMarker114"/> addition, we dim the color of the coordinate arrows by dividing the color vector by a value of two.</p>
    <p class="normal">The resulting per-vertex data is collected in the <code class="inlineCode">mLineMesh</code> vector:</p>
    <pre class="programlisting code"><code class="hljs-code">    mLineMesh-&gt;vertices.insert(mLineMesh-&gt;vertices.end(),
      mCoordArrowsMesh.vertices.begin(),
      mCoordArrowsMesh.vertices.end());
</code></pre>
    <p class="normal">Then, we will upload the vertex data to the GPU, and draw the coordinate lines:</p>
    <pre class="programlisting code"><code class="hljs-code">  mLineVertexBuffer.uploadData(*mLineMesh);
  if (mCoordArrowsLineIndexCount &gt; 0) {
    mLineShader.use();
    mLineVertexBuffer.bindAndDraw(GL_LINES, 0,
      mCoordArrowsLineIndexCount);
  }
</code></pre>
    <p class="normal">Here, the <code class="inlineCode">mCoordArrowsLineIndexCount</code> is used to check if coordinate lines exist at all, and as a parameter to draw the correct number of points for the lines. Using the line count as a check value and a counter helps us if we don’t want to draw any coordinate lines at all: We can simply skip filling <code class="inlineCode">mLineMesh</code> and counting coordinate lines, skipping the line drawing automatically. Or, we could draw multiple coordinate arrows in a multi-selection scenario.</p>
    <p class="normal">Uploading vertex data in Vulkan is much more complex compared to OpenGL due to the explicit nature of the Vulkan API. The full process for creating a different shader and uploading vertex data requires the following steps in Vulkan:</p>
    <ol>
      <li class="numberedList" value="1">Create a pair of passthrough shaders in GLSL or HLSL (High-Level Shader Language for DirectX). For GLSL shaders, the syntax has only small differences – mostly it’s about being more explicit when using the <code class="inlineCode">layout</code> statement.</li>
      <li class="numberedList">Create a new pipeline with the new shaders and a corresponding attribute definition. Vulkan needs a new pipeline since the pipeline itself will become <em class="italic">immutable</em> after creation (except for a few explicit dynamically configurable sub-objects, like the viewport). Vulkan shaders <em class="italic">cannot</em> be swapped at runtime like in OpenGL; we need to bind another pipeline to draw vertices with a different shader.</li>
      <li class="numberedList">Upload the vertex data to the GPU by using a staging buffer. To achieve the best performance in Vulkan, the vertex data should be stored in an optimized format in a memory area where only the GPU has access. Using a buffer shared between the CPU and GPU requires additional synchronization by the driver and the data may not be in the optimal format for the GPU to draw, resulting in performance losses.</li>
      <li class="numberedList">While recording the render<a id="_idIndexMarker115"/> pass commands to send to the GPU, we must bind both the new pipeline by using the <code class="inlineCode">vkCmdBindPipeline()</code> method and the vertex buffer by using <code class="inlineCode">vkCmdBindVertexBuffers()</code>. After submitting the command buffer to the driver, the vertices are drawn with the new shader.</li>
    </ol>
    <p class="normal">You can check out the classes <code class="inlineCode">Shader</code>, <code class="inlineCode">Pipeline</code>, and <code class="inlineCode">VertexBuffer</code> in the <code class="inlineCode">vulkan</code> folder of the example code for implementation details. Also, a link in the section <em class="italic">Additional resources</em> to a Vulkan tutorial is available. The tutorial has a separate section about vertex buffer creation and data uploading.</p>
    <p class="normal">Now, three small arrows are added to the selected instance, as shown in <em class="italic">Figure 3.1</em>:</p>
    <figure class="mediaobject"><img src="img/Figure_3.1_B22428.png" alt="" width="1647" height="1288"/></figure>
    <p class="packt_figref">Figure 3.1: New coordinate arrows to identify the selected instance</p>
    <p class="normal">The red arrow points to the direction of the positive <code class="inlineCode">x</code> axis, the blue arrow points to the positive <code class="inlineCode">z</code> axis, and the green arrow towards the positive <code class="inlineCode">y</code> axis.</p>
    <p class="normal">As the second step towards the “move to instance” function, the new UI button will be added.</p>
    <h2 id="_idParaDest-89" class="heading-2">Creating a button to center the selected instance</h2>
    <p class="normal">For the new button in the user interface, we <a id="_idIndexMarker116"/>will follow the previous implementations and add a callback for the <code class="inlineCode">UserInterface</code> class. The callback calls a method in the renderer class, moving the camera calculations related from the user interface to the renderer.</p>
    <p class="normal">In the <code class="inlineCode">UserInterface</code> class, we add a new ImGui button, plus the new callback, using the current instance as parameter:</p>
    <pre class="programlisting code"><code class="hljs-code">    if (ImGui::Button("Center This Instance")) {
      std::shared_ptr&lt;AssimpInstance&gt; currentInstance =
        modInstData.miAssimpInstances.at(
          modInstData.miSelectedInstance);
       modInstData.miInstanceCenterCallbackFunction(
         currentInstance);
    }
</code></pre>
    <p class="normal">When the renderer is initialized, the callback <code class="inlineCode">miInstanceCenterCallbackFunction</code> will be bound via a lambda function to the new <code class="inlineCode">centerInstance()</code> method of the renderer:</p>
    <pre class="programlisting code"><code class="hljs-code">  mModelInstData.miInstanceCenterCallbackFunction =
   [this](std::shared_ptr&lt;AssimpInstance&gt; instance)
   { centerInstance(instance); };
</code></pre>
    <p class="normal">The <code class="inlineCode">centerInstance()</code> method extracts the position of the instance, adds a static offset of 5 units on all axes, and calls <code class="inlineCode">moveCameraTo()</code> of the camera object:</p>
    <pre class="programlisting code"><code class="hljs-code">void OGLRenderer::centerInstance(
    std::shared_ptr&lt;AssimpInstance&gt; instance) {
  InstanceSettings instSettings =
    instance-&gt;getInstanceSettings();
  mCamera.moveCameraTo(mRenderData,
    instSettings.isWorldPosition + glm::vec3(5.0f));
}
</code></pre>
    <p class="normal">Finally, <code class="inlineCode">moveCameraTo()</code> moves the camera to the instance position plus offset given in the renderer, and uses fixed values for azimuth and elevation to center the selected instance in the middle of the screen:</p>
    <pre class="programlisting code"><code class="hljs-code">void Camera::moveCameraTo(OGLRenderData&amp; renderData,
    glm::vec3 position) {
  renderData.rdCameraWorldPosition = position;
  renderData.rdViewAzimuth = 310.0f;
  renderData.rdViewElevation = -15.0f;
}
</code></pre>
    <p class="normal">Using hard-coded values for azimuth and elevation makes the process a bit easier, since the extraction of both values from a matrix generated by a method like <code class="inlineCode">glm::lookAt()</code> is a bit more complex. You might try to set the camera angles from a transformation matrix by yourself – see the <em class="italic">Practical sessions</em> section.</p>
    <p class="normal">You can add the new ImGui centering button anywhere in the collapsed header for the instances. In the example code, the<a id="_idIndexMarker117"/> button has been placed right below the arrows to select the current instance, as shown in <em class="italic">Figure 3.2</em>:</p>
    <figure class="mediaobject"><img src="img/Figure_3.2_B22428.png" alt="" width="1647" height="997"/></figure>
    <p class="packt_figref">Figure 3.2: The currently selected instance has been centered</p>
    <p class="normal">Centering the currently selected instance is a huge step towards a better <em class="italic">look &amp; feel</em> for the application. We don’t need to search for the blinking instance or the coordinate arrows to find the selected instance; now, we are literally only a mouse click away from reaching the instance.</p>
    <p class="normal">Still, this solution has some drawbacks. What if we don’t want to center the selected instance, maybe because we would like to keep the camera position fixed. So, let’s add another function to the code that makes the currently selected instance even easier to find among all instances shown on the screen.</p>
    <h1 id="_idParaDest-90" class="heading-1">Adding a highlight to the selected instance</h1>
    <p class="normal">At first sight, adding some sort of highlight seems <a id="_idIndexMarker118"/>to be easy by adding some more fields to the vertices and the vertex buffer. Sadly, we are using instanced rendering for performance reasons. This means that all instances share the same vertex data. So, this approach does not work.</p>
    <p class="normal">The next idea may be the instance placement and animations data. These matrices are calculated entirely by our compute shaders from <a href="Chapter_2.xhtml"><em class="italic">Chapter 2</em></a>, fed by the node transform data of the nodes. Adding model related data to every node seems to be a bit overkill, since the highlighted data is needed only once per instance, not once per node.</p>
    <p class="normal">A better idea would be another SSBO, filled with the correct data in the <code class="inlineCode">draw()</code> call of the renderer, right after the node transform data has been retrieved from the instance. In the instance loop, we have direct access to all instances of a model and can simply push a value to a <code class="inlineCode">std::vector</code>, stating if this is the selected instance or not. After uploading the data of the vector to the SSBO, the shader instance can check the buffer data to see if the highlight should be added to the instance it is<a id="_idIndexMarker119"/> working on, or not.</p>
    <h2 id="_idParaDest-91" class="heading-2">Preparing the renderer to support highlights</h2>
    <p class="normal">As the first step for adding the highlight <a id="_idIndexMarker120"/>to the selected instance, we add a vector containing a <code class="inlineCode">float</code>, and, for the OpenGL renderer, an SSBO to the renderer header file:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::vector&lt;float&gt; mSelectedInstance{};
    ShaderStorageBuffer mSelectedInstanceBuffer{};
</code></pre>
    <p class="normal">Due to the different data logic, for Vulkan, a <code class="inlineCode">VkShaderStorageBufferData</code> object in the <code class="inlineCode">VkRenderData</code> struct in the file <code class="inlineCode">VkRenderData.h</code> will be used instead.</p>
    <p class="normal">In the <code class="inlineCode">draw()</code> call of the renderer, we save the smart pointer of the currently selected instance, right before we start the loop across the models and instances:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::shared_ptr&lt;AssimpInstance&gt; currentSelectedInstance =
    nullptr;
  ...
    currentSelectedInstance =
      mModelInstData.miAssimpInstances.at(
      mModelInstData.miSelectedInstance);
</code></pre>
    <p class="normal">In addition to storing the instance, we alter a float value inside the <code class="inlineCode">OGLRenderData</code> respective <code class="inlineCode">VkRenderData</code> struct by adding a scaled <code class="inlineCode">deltaTime</code>, and resetting the value once it reaches <code class="inlineCode">2.0f</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  mRenderData.rdSelectedInstanceHighlightValue +=
    deltaTime * 4.0f;
  if (mRenderData.rdSelectedInstanceHighlightValue &gt; 2.0f) {
      mRenderData.rdSelectedInstanceHighlightValue = 0.1f
  }
</code></pre>
    <p class="normal">The value of the variable <code class="inlineCode">rdSelectedInstanceHighlightValue</code> will be used in the shader to scale up or down the color of the selected instance. By adding the value of <code class="inlineCode">deltaTime</code> in every <code class="inlineCode">draw()</code> call and resetting the highlight variable to <code class="inlineCode">0.1f</code> when we reach <code class="inlineCode">2.0f</code>, the selected install will blink from very dark to very bright. The blinking instance will be easier to spot on the screen, compared to just the coordinate arrows.</p>
    <p class="normal">Inside the instance loop, we compare the smart pointer of the instance we are working on and the saved smart pointer of the selected instance. If they are identical, the alternating value of the variable <code class="inlineCode">rdSelectedInstanceHighlightValue</code> will be set at the index of the current instance in the <code class="inlineCode">mSelectedInstance</code> vector:</p>
    <pre class="programlisting code"><code class="hljs-code">      if (currentSelectedInstance ==
        modelType.second.at(i)) {
        mSelectedInstance.at(i) =
          mRenderData.rdSelectedInstanceHighlightValue;
      } else {
        mSelectedInstance.at(i) = 1.0f;
      }
</code></pre>
    <p class="normal">If we are working on any <a id="_idIndexMarker121"/>other instance in the loop, we simply set the <code class="inlineCode">x</code> value to <code class="inlineCode">1.0f</code>, resulting in an unchanged color of the instance in the shader.</p>
    <p class="normal">The collected data of the <code class="inlineCode">mSelectedInstance</code> vector is then uploaded to the SSBO. For example, the OpenGL renderer uses the <code class="inlineCode">uploadSsboData()</code> method of the <code class="inlineCode">ShaderStorageBuffer</code> class to upload the vector data to the GPU:</p>
    <pre class="programlisting code"><code class="hljs-code">    mSelectedInstanceBuffer.uploadSsboData(
      mSelectedInstance, 3);
</code></pre>
    <h2 id="_idParaDest-92" class="heading-2">Adjusting logic to shaders and the UI</h2>
    <p class="normal">As the next step for adding the highlight to the <a id="_idIndexMarker122"/>selected instance, the shaders have to be adjusted. In the <code class="inlineCode">assimp_skinning.vert</code> vertex shader in the <code class="inlineCode">shader</code> folder, the new SSBO must be added:</p>
    <pre class="programlisting code"><code class="hljs-code">layout (std430, binding = 3) readonly restrict
    buffer InstanceSelected {
  float selected[];
};
</code></pre>
    <p class="normal">The same addition is needed in the <code class="inlineCode">assimp.vert</code> shader in the <code class="inlineCode">shader</code> folder, used for non-animated model instances.</p>
    <p class="normal">Please check the binding number – due to the missing animation data, the number of SSBOs differs between the shaders for animated and non-animated instances: The shader for animated models binds the instance selection data on binding point <code class="inlineCode">3</code> since binding point <code class="inlineCode">2</code> is already used by the world position matrices:</p>
    <pre class="programlisting code"><code class="hljs-code">  mShaderBoneMatrixBuffer.bind(1);
  mShaderModelRootMatrixBuffer.uploadSsboData(
      mWorldPosMatrices, 2);
  mSelectedInstanceBuffer.uploadSsboData(
      mSelectedInstance, 3);
</code></pre>
    <p class="normal">In contrast, the shader for non-animated models binds only two buffers:</p>
    <pre class="programlisting code"><code class="hljs-code">  mShaderModelRootMatrixBuffer.uploadSsboData(
    mWorldPosMatrices, 1);
  mSelectedInstanceBuffer.uploadSsboData(
    mSelectedInstance, 2);
</code></pre>
    <p class="normal">To adjust the color of the selected instance, we can now use the internal variable <code class="inlineCode">gl_InstanceID</code> of the shader, retrieving<a id="_idIndexMarker123"/> the value of the data at the location of the instance in the <code class="inlineCode">selected</code> buffer:</p>
    <pre class="programlisting code"><code class="hljs-code">  color = aColor * selected[gl_InstanceID];
</code></pre>
    <p class="normal">As an optional change, we could also decrement the depth value of the selected instance by <code class="inlineCode">1.0f</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  if (selected[gl_InstanceID] != 1.0f) {
    gl_Position.z -= 1.0f;
  }
</code></pre>
    <p class="normal">Lowering the <code class="inlineCode">z</code> element of the internal variable <code class="inlineCode">gl_Position</code> will adjust the depth value of the triangle to the lowest possible value. This depth adjustment makes the highlighted instance visible even if other instances are closer to the camera position.</p>
    <p class="normal">Finally, we add a <code class="inlineCode">Boolean</code> variable named <code class="inlineCode">rdHighlightSelectedInstance</code> in the <code class="inlineCode">OGLRenderData</code> respective <code class="inlineCode">VkRenderData</code> struct, allowing us to switch the highlight on and off. This new variable will be attached to an ImGui checkbox in the <code class="inlineCode">UserInterface</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    ImGui::Text("Hightlight Instance:");
    ImGui::SameLine();
    ImGui::Checkbox("##HighlightInstance",
      &amp;renderData.rdHighlightSelectedInstance);
</code></pre>
    <p class="normal">In <em class="italic">Figure 3.3</em>, the effect of combining highlighting and <code class="inlineCode">z</code> position adjustment in the vertex shader is shown:</p>
    <figure class="mediaobject"><img src="img/Figure_3.3_B22428.png" alt="" width="1644" height="1215"/></figure>
    <p class="packt_figref">Figure 3.3: Highlighted instance drawn on top of instances closer to the camera</p>
    <p class="normal">According to the relative size of the brighter instance, this instance would be at least partially hidden behind other instances closer to the camera. Yet, the adjustment of the <code class="inlineCode">z</code> position draws the selected instance on top of all instances on the screen.</p>
    <p class="normal">What cannot be shown in the <a id="_idIndexMarker124"/>picture is the alternating brightness of the selected instance. As set in the <code class="inlineCode">draw()</code> call of the renderer, the colors of the selected instance go up from only 10% of the original color (start value of <code class="inlineCode">0.1f</code>) to 200% of the original colors (clamping at <code class="inlineCode">2.0f</code>).</p>
    <p class="normal">The flashing colors of the instance will make it fairly easy to find the currently selected instance on the screen. But there is still a piece missing in the application: Being able to select the instance of choice by clicking into the window, instead of searching through all instances by using the instance number arrows. Let’s tackle the visual selection now.</p>
    <h1 id="_idParaDest-93" class="heading-1">Selecting a model instance with point and click</h1>
    <p class="normal">Before we start with the<a id="_idIndexMarker125"/> implementation, we will look at the two different approaches to add visual selection to an application: by “shooting” a ray into the virtual scene, and by using a texture holding an index of the instances.</p>
    <h2 id="_idParaDest-94" class="heading-2">Pros and cons of shooting virtual rays</h2>
    <p class="normal">You may find the following<a id="_idIndexMarker126"/> idea of shooting a virtual ray into your scene appealing:</p>
    <p class="normal">We already have the position of the camera in the virtual world as the first endpoint, and by mapping the mouse pointer positions back from screen positions to scene coordinates, you will get the second endpoint. Mapping coordinates back to the scene is only a couple of matrix inversions and multiplications away.</p>
    <p class="normal">Sounds promising and easy, doesn’t it?</p>
    <p class="normal">Sadly, it is common to underestimate the final complexity at this point. As long as you only have a single model in the world, or two, everything is fine. You shoot the virtual ray into the scene, and loop over the triangles of each instance to find the closest intersection between the ray and the instance triangles.</p>
    <p class="normal">But what happens when you have, say, 1,000 instances?</p>
    <p class="normal">Every time you click the selection button on your mouse, you would have to iterate over all triangles of all instances, hoping to find at least one match. The test model of the book has roughly 2,000 triangles, so you will have to check for 2,000,000 possible intersections in a virtual world with 1,000 instances. Even with massive parallel computer shaders, this amount of calculation is a lot of wood to chuck for modern graphics cards.</p>
    <p class="normal">There are several ways to exclude large areas of the virtual world from the hit tests. In combination with other hierarchical approaches on the node level, the number of intersection checks can be lowered by several orders of magnitude. We will cover optimizations of the process to find intersections when we handle instance collisions in <a href="Chapter_8.xhtml"><em class="italic">Chapter 8</em></a>.</p>
    <p class="normal">What about the alternative idea – using a texture?</p>
    <h2 id="_idParaDest-95" class="heading-2">Advantages of drawing the instance index into a texture</h2>
    <p class="normal">The basic idea of an extra texture for the instance selection comes from <strong class="keyWord">Deferred Rendering</strong>. In deferred rendering, computations like<a id="_idIndexMarker127"/> lighting are not done in the fragment shader, but “deferred” after storing the required information in textures. The set of textures containing all information<a id="_idIndexMarker128"/> about the pixels on the screen is called the <strong class="keyWord">G-Buffer</strong>, short for <strong class="keyWord">geometry buffer</strong>.</p>
    <p class="normal">By using the data of the textures in the G-Buffer, the complexity to apply lighting to a scene is lowered from <code class="inlineCode">Number of triangles * Number of lights in the entire scene</code> to <code class="inlineCode">Number of pixels of the G-Buffer * Number of nearby lights</code>.</p>
    <p class="normal">Even for 4K or 8K graphic resolutions, the number of operations to create the lighting information is lowered drastically. And, by using other information from the rendering process, other effects are easily possible with deferred rendering, like shadow mapping, or indirect lighting.</p>
    <p class="normal">For naive ray-shooting, the selection complexity grows with the number of instances in the virtual world, even if these instances are not visible on the screen. When we apply the deferred rendering approach to visual selection, we have a constant overhead of drawing some pixels into a separate texture. Our selection process no longer depends on a variable number of instances in the world. Also, the resolution of the buffers may affect the performance of the instance selection only marginally.</p>
    <p class="normal">The amount of changes<a id="_idIndexMarker129"/> required to add visual selection with a separate texture is surprisingly low. Let’s look at the steps we have to take.</p>
    <h2 id="_idParaDest-96" class="heading-2">Adjusting the framebuffer</h2>
    <p class="normal">We start with the <code class="inlineCode">FrameBuffer</code> class and add a<a id="_idIndexMarker130"/> new color attachment. For the OpenGL version, the new color attachment is <a id="_idIndexMarker131"/>created as follows.</p>
    <pre class="programlisting code"><code class="hljs-code">  glGenTextures(1, &amp;mSelectionTex);
  glBindTexture(GL_TEXTURE_2D, mSelectionTex);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_R32F, width, height,
    0, GL_RED, GL_FLOAT, NULL);
  glBindTexture(GL_TEXTURE_2D, 0);
  glFramebufferTexture(GL_FRAMEBUFFER,
    GL_COLOR_ATTACHMENT1, mSelectionTex, 0);
</code></pre>
    <p class="normal">For the selection texture, we add a texture containing only a single element, the red color. But we use a 32-bit wide red color, not only 8 bits, allowing us to store much more instance indices. The new texture is then added as a color attachment with the index 1 to the framebuffer.</p>
    <div><p class="normal">A note on the texture data type (float)</p>
      <p class="normal">It is possible to create a texture with the type of <code class="inlineCode">GL_R32UI</code>, containing a 32-bit wide unsigned integer for every pixel. But all integer <a id="_idIndexMarker132"/>versions of the texture use a conversion factor for the components, raising the complexity of the selection process due to extra computations on reads and writes. In contrast, a <code class="inlineCode">GL_R32F</code> buffer stores and retrieves an unaltered float value. By using a float on the GPU side, we are still able to store ~16.7 million instance indices (2<sup class="superscript">24</sup>), before the precision of a 32-bit float may lead to rounding errors during the conversion between integer and float values. See the section <em class="italic">Additional resources</em> for a link to a blog entry with more details of float precision.</p>
    </div>
    <p class="normal">Also, during framebuffer creation, we have to make sure our shader writes to both color attachments:</p>
    <pre class="programlisting code"><code class="hljs-code">  const GLenum buffers[] = { GL_COLOR_ATTACHMENT0,
   GL_COLOR_ATTACHMENT1 };
  glDrawBuffers(2, buffers);
</code></pre>
    <p class="normal">If we don’t change the buffers to draw to, only the models will be drawn on the screen, and the selection texture will never be filled.</p>
    <p class="normal">To clear the color buffer and the selection buffer with different values, a new method called <code class="inlineCode">clearTextures()</code> has been added to the <code class="inlineCode">FrameBuffer</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">void Framebuffer::clearTextures() {
  static GLfloat colorClear[] =
    { 0.25f, 0.25f, 0.25f, 1.0f };
  glClearBufferfv(GL_COLOR, 0, colorClear);
  static GLfloat selectionClearColor = -1.0f;
  glClearBufferfv(GL_COLOR, 1, &amp;selectionClearColor);
  static GLfloat depthValue = 1.0f;
  glClearBufferfv(GL_DEPTH, 0, &amp;depthValue);
}
</code></pre>
    <p class="normal">The selection texture can store arbitrary float values, using a <code class="inlineCode">-1.0f</code> to clear the selection texture, which is a nice method to<a id="_idIndexMarker133"/> have a unique value for the empty background.</p>
    <p class="normal">We also avoid <a id="_idIndexMarker134"/>creating yet another SSBO to store the instance index, and extend the <code class="inlineCode">mSelectedInstance</code> vector from <code class="inlineCode">float</code> to <code class="inlineCode">glm::vec2</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::vector&lt;glm::vec2&gt; mSelectedInstance{};
</code></pre>
    <p class="normal">By moving the existing highlight color to the <code class="inlineCode">x</code> element of the <code class="inlineCode">glm::vec2</code> vector, we have a free <code class="inlineCode">float</code> type spot, and we can store the instance index in the <code class="inlineCode">y</code> element.</p>
    <h3 id="_idParaDest-97" class="heading-3">Creating a selection shader</h3>
    <p class="normal">Adding a new color buffer to the framebuffer also requires two new pairs of vertex/fragment shaders: One pair for <a id="_idIndexMarker135"/>animated models, another pair for non-animated models. But since we already send the selection information for instance highlighting to the shader, only small additions to the existing shader code are needed.</p>
    <p class="normal">Since we can reuse the shaders, the first step is to copy the existing files. For the non-animated models, copy the shader <code class="inlineCode">assimp.vert</code> to <code class="inlineCode">assimp_selection.vert</code>, and <code class="inlineCode">assimp.frag</code> to <code class="inlineCode">assimp_selection.frag</code>. The same name addition will be used for the animated model shader: Copy the file <code class="inlineCode">assimp_skinning.vert</code> to <code class="inlineCode">assimp_skinning_selection.vert</code>, and <code class="inlineCode">assimp_skinning.frag</code> to <code class="inlineCode">assimp_skinning_selection.frag</code>.</p>
    <p class="normal">We also need two new shader objects in the renderer, so we add the <code class="inlineCode">private</code> <code class="inlineCode">Shader</code> member variables named <code class="inlineCode">mAssimpSelectionShader</code> and <code class="inlineCode">mAssimpSkinningSelectionShader</code> to the file <code class="inlineCode">OGLRenderer.h</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    Shader mAssimpSelectionShader{};
    Shader mAssimpSkinningSelectionShader{};
</code></pre>
    <p class="normal">Like the existing shaders, the two new shaders are loaded in the <code class="inlineCode">init()</code> method of the renderer.</p>
    <p class="normal">Then, two lines must be added to the new vertex shaders. The first new line adds a new output variable named <code class="inlineCode">selectInfo</code> to the vertex shader, allowing us to hand over the selection data for the current triangle to the fragment shader:</p>
    <pre class="programlisting code"><code class="hljs-code">...
layout (location = 2) out vec2 texCoord;
<strong class="hljs-keyword-slc">layout</strong><strong class="hljs-slc"> (</strong><strong class="hljs-keyword-slc">location</strong><strong class="hljs-slc"> = </strong><strong class="hljs-number-slc">3</strong><strong class="hljs-slc">) </strong><strong class="hljs-keyword-slc">out</strong><strong class="hljs-slc"> </strong><strong class="hljs-type-slc">float</strong><strong class="hljs-slc"> selectInfo;</strong>
</code></pre>
    <p class="normal">The second line at the end of the <code class="inlineCode">main()</code> method does the actual forwarding to the fragment shader:</p>
    <pre class="programlisting code"><code class="hljs-code">  selectInfo = selected[gl_InstanceID].y;
}
</code></pre>
    <p class="normal">For the two new fragment<a id="_idIndexMarker136"/> shaders, similar changes are needed. On top of the shader code, we must add the new input variable <code class="inlineCode">selectInfo</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">layout (location = 2) in vec2 texCoord;
<strong class="hljs-keyword-slc">layout</strong><strong class="hljs-slc"> (</strong><strong class="hljs-keyword-slc">location</strong><strong class="hljs-slc"> = </strong><strong class="hljs-number-slc">3</strong><strong class="hljs-slc">) </strong><strong class="hljs-keyword-slc">flat</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">in</strong><strong class="hljs-slc"> </strong><strong class="hljs-type-slc">float</strong><strong class="hljs-slc"> selectInfo;</strong>
</code></pre>
    <p class="normal">Also, the fragment shader output has to be adjusted. Replace the single <code class="inlineCode">FragColor</code> output line with the following two lines:</p>
    <pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">layout</strong><strong class="hljs-slc"> (</strong><strong class="hljs-keyword-slc">location</strong><strong class="hljs-slc"> = </strong><strong class="hljs-number-slc">0</strong><strong class="hljs-slc">) </strong><strong class="hljs-keyword-slc">out</strong><strong class="hljs-slc"> </strong><strong class="hljs-type-slc">vec4</strong><strong class="hljs-slc"> FragColor;</strong>
<strong class="hljs-keyword-slc">layout</strong><strong class="hljs-slc"> (</strong><strong class="hljs-keyword-slc">location</strong><strong class="hljs-slc"> = </strong><strong class="hljs-number-slc">1</strong><strong class="hljs-slc">) </strong><strong class="hljs-keyword-slc">out</strong><strong class="hljs-slc"> </strong><strong class="hljs-type-slc">float</strong><strong class="hljs-slc"> SelectedInstance;</strong>
</code></pre>
    <p class="normal">We write two different outputs now, one for each color buffer: The color buffer of the frame buffer will be filled with the RGBA values for the on-screen color of each pixel as before, and at the end of the <code class="inlineCode">main()</code> method, the instance index passed through from the vertex shader will be written to the second color buffer:</p>
    <pre class="programlisting code"><code class="hljs-code">  SelectedInstance = selectInfo;
</code></pre>
    <p class="normal">If we use the new selection shader now when drawing the instances, the index of the instance will be added to the selection buffer for every single pixel of that of the instances onscreen.</p>
    <h3 id="_idParaDest-98" class="heading-3">Reading a pixel from a texture</h3>
    <p class="normal">Reading out the color of the pixel at a given position will be done in the method <code class="inlineCode">readPixelFromPos()</code> of the <code class="inlineCode">FrameBuffer</code> class.</p>
    <p class="normal">First, we initialize our designated<a id="_idIndexMarker137"/> return variable with a special value, making it easy to find errors when OpenGL refuses to read out the pixel color due to a configuration problem:</p>
    <pre class="programlisting code"><code class="hljs-code">float Framebuffer::readPixelFromPos(unsigned int xPos,
    unsigned int yPos) {
  float pixelColor = -444.0f;
</code></pre>
    <p class="normal">Next, we bind our framebuffer object as buffer to read from, and we select the color attachment <code class="inlineCode">1</code> of the framebuffer, containing the selection texture:</p>
    <pre class="programlisting code"><code class="hljs-code">  glBindFramebuffer(GL_READ_FRAMEBUFFER, mBuffer);
  glReadBuffer(GL_COLOR_ATTACHMENT1);
</code></pre>
    <p class="normal">Then, we adjust the internal <a id="_idIndexMarker138"/>alignment used during the read process, and read out the color value of a single pixel at the given <code class="inlineCode">xPos</code> and <code class="inlineCode">yPos</code> position:</p>
    <pre class="programlisting code"><code class="hljs-code">  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
  glReadPixels(xPos, yPos, 1, 1, GL_RED, GL_FLOAT,
    &amp;pixelColor);
</code></pre>
    <p class="normal">Finally, we switch the framebuffer back to color attachment <code class="inlineCode">0</code>, unbind the buffer and return the pixel color:</p>
    <pre class="programlisting code"><code class="hljs-code">  glReadBuffer(GL_COLOR_ATTACHMENT0);
  glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
  return pixelColor;
}
</code></pre>
    <h2 id="_idParaDest-99" class="heading-2">Adding mouse button handling</h2>
    <p class="normal">Selecting an instance will be added to the left mouse button. It feels natural to click on an instance to select it. To store the status of the selection, a Boolean member variable named <code class="inlineCode">mMousePick</code> is added to the renderer.</p>
    <p class="normal">Then, the following line <a id="_idIndexMarker139"/>must be added to the <code class="inlineCode">handleMouseButtonEvents()</code> method of the renderer:</p>
    <pre class="programlisting code"><code class="hljs-code">  if (button == GLFW_MOUSE_BUTTON_LEFT &amp;&amp;
      action == GLFW_RELEASE) {
    mMousePick = true;
  }
</code></pre>
    <p class="normal">Using the <code class="inlineCode">GLFW_RELEASE</code> <code class="inlineCode">action</code> here, reacting when the left mouse button is released, matches the selection style of many applications. If you want to change the behavior, you can use the action <code class="inlineCode">GLFW_PRESS</code>.</p>
    <p class="normal">We use the <code class="inlineCode">mMousePick</code> value to trigger different actions in the drawing process only when a selection event has been triggered by the user. Separating normal drawing and the extra operation for selection helps to retain the maximum speed of the application, avoiding operations that are only required during the selection.</p>
    <p class="normal">As an example, the shader with the logic to draw into the selection texture will be only called if a selection event was triggered:</p>
    <pre class="programlisting code"><code class="hljs-code">    if (mMousePick) {
      mAssimpSkinningSelectionShader.use();
    } else {
      mAssimpSkinningShader.use();
    }
</code></pre>
    <h2 id="_idParaDest-100" class="heading-2">Assigning an index to each instance</h2>
    <p class="normal">To ensure we always maintain a <a id="_idIndexMarker140"/>unique index for every instance, any time an instance is added or removed, we assign its overall index. Using the unique index per instance also helps us in accessing the current instance in the <code class="inlineCode">miAssimpInstances</code> vector.</p>
    <p class="normal">We add a new variable <code class="inlineCode">isInstanceIndexPosition</code> to the struct <code class="inlineCode">InstanceSettings</code>, located in the file <code class="inlineCode">InstanceSettings.h</code> in the <code class="inlineCode">model</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code">struct InstanceSettings {
 ...
  int isInstanceIndexPosition = -1;
};
</code></pre>
    <p class="normal">The variable <code class="inlineCode">isInstanceIndexPosition</code> will be set in the method <code class="inlineCode">assignInstanceIndices()</code>, doing a loop over all the instances:</p>
    <pre class="programlisting code"><code class="hljs-code">void OGLRenderer::assignInstanceIndices() {
  for (size_t i = 0;
      i &lt; mModelInstData.miAssimpInstances.size(); ++i) {
  InstanceSettings instSettings =
    mModelInstData.miAssimpInstances.at(i)
    -&gt;getInstanceSettings();
  instSettings.isInstanceIndexPosition = i;
  mModelInstData.miAssimpInstances.at(i)
    -&gt;setInstanceSettings(instSettings);
  }
}
</code></pre>
    <p class="normal">The method <code class="inlineCode">assignInstanceIndices()</code> is called whenever instances are added or removed.</p>
    <p class="normal">Having an easy to access instance number at hand helps us to fill the <code class="inlineCode">y</code> element of the <code class="inlineCode">mSelectedInstance</code> vector during the loop over all instances of a model:</p>
    <pre class="programlisting code"><code class="hljs-code">    if (mMousePick) {
      InstanceSettings instSettings =
         modelType.second.at(i)-&gt;getInstanceSettings();
      mSelectedInstance.at(i).y =
        static_cast&lt;float&gt;(
        instSettings.isInstanceIndexPosition);
    }
</code></pre>
    <h2 id="_idParaDest-101" class="heading-2">Selecting the instance at mouse positions</h2>
    <p class="normal">As the final step for the <a id="_idIndexMarker141"/>visual selection, we trigger the pixel read at the end of the <code class="inlineCode">draw()</code> call in the renderer:</p>
    <pre class="programlisting code"><code class="hljs-code">  if (mMousePick) {
    glFlush();
    glFinish();
</code></pre>
    <p class="normal">By surrounding the pixel read with a check for the <code class="inlineCode">mMousePick</code> variable, we make sure the functions to read back the pixel will be called only on the selection event.</p>
    <p class="normal">This guarding check is especially important for the calls to <code class="inlineCode">glFlush()</code> and <code class="inlineCode">glFinish()</code>. Both commands are required to make sure all shader runs have ended, and the data in the selection texture is complete. While <code class="inlineCode">glFlush()</code> empties the internal buffers and triggers the rendering itself, <code class="inlineCode">glFinish()</code> blocks the renderer and waits for all previous OpenGL calls to have finished. Forcing these OpenGL commands on every frame decreases the number of frames per second in most implementations.</p>
    <p class="normal">Next, we call <code class="inlineCode">readPixelFromPos()</code> on the <code class="inlineCode">FrameBuffer</code> instance:</p>
    <pre class="programlisting code"><code class="hljs-code">    float selectedInstanceId =
      mFramebuffer.readPixelFromPos(mMouseXPos,
      (mRenderData.rdHeight - mMouseYPos - 1));
</code></pre>
    <p class="normal">Due to the different orientations of the <code class="inlineCode">y</code> axis in OpenGL on the one hand and Windows and Linux on the other, we need to invert the <code class="inlineCode">y</code> position when reading out the pixel.</p>
    <p class="normal">After we retrieve the pixel color, we check if any instance was selected, or the mouse click was done on the background of the screen:</p>
    <pre class="programlisting code"><code class="hljs-code">    if (selectedInstanceId &gt;= 0.0f) {
      mModelInstData.miSelectedInstance =
        static_cast&lt;int&gt;(selectedInstanceId);
    }
    mMousePick = false;
  }
</code></pre>
    <p class="normal">As the last step, we set <code class="inlineCode">mMousePick</code> to <code class="inlineCode">false</code>, stopping the selection mode immediately.</p>
    <p class="normal">In <em class="italic">Figure 3.4</em>, the selection texture for a larger group of model instances is shown:</p>
    <figure class="mediaobject"><img src="img/Figure_3.4_B22428.png" alt="" width="1546" height="655"/></figure>
    <p class="packt_figref">Figure 3.4: The selection texture</p>
    <p class="normal">The background color in <em class="italic">Figure 3.4</em> has been changed to white. In the actual selection texture, the clear value of <code class="inlineCode">-1.0f</code> will be clamped to zero, resulting in a black background. Also, the index values have been adjusted to enhance the visibility of the instances. If we render the selection texture with the real float values, all index values will be clamped to <code class="inlineCode">1.0f</code>, resulting in a picture where all instances <a id="_idIndexMarker142"/>appear in bright red.</p>
    <p class="normal">Selecting a single instance by using the mouse is working great now. As one of the ideas in the <em class="italic">Practical sessions</em> section, you could try to add more functionality, like selecting multiple instances at the same time. i.e., by keeping the <em class="italic">Ctrl</em> or <em class="italic">Shift</em> key down while selecting instances, newly selected instances are added, showing the coordinate arrows and the highlight on all selected instances.</p>
    <p class="normal">But there is one thing left that may annoy you: There is no way to select no instance at all. We will add a solution for an empty selection in the last section of this chapter.</p>
    <h1 id="_idParaDest-102" class="heading-1">Implementing a null object to allow deselection</h1>
    <p class="normal">Adding a deselection by doing a click into the background of the application window comes with a bunch of interesting implications. For instance, the position <code class="inlineCode">0</code> may be a valid index in the <code class="inlineCode">miAssimpInstance</code> vector, stating that the<a id="_idIndexMarker143"/> first instance has been selected. So, simply using zero to signal that no instances are selected does not work. Even worse: Using zero as the first index may confuse users of the application, as it is not intentional to start counting numbers at zero, instead of one.</p>
    <p class="normal">In addition, the default buffer background value of <code class="inlineCode">–1</code> is an invalid array index. Using the value of <code class="inlineCode">-1</code> as an index into the <code class="inlineCode">miAssimpInstance</code> vector would simply crash the application. Since we will use the instance vector frequently in the code, adding a range check for every single access would be crucial because even missing a single check will lead to a crash.</p>
    <p class="normal">So, we need another signalling mechanism to switch between the two selection variants and a simplification of the range <a id="_idIndexMarker144"/>checks. To catch both problems with a single solution, we will use an empty model as a <strong class="keyWord">null object</strong>.</p>
    <h2 id="_idParaDest-103" class="heading-2">What is a null object?</h2>
    <p class="normal">Using a null object is a well-known <a id="_idIndexMarker145"/>design pattern for object-oriented programming. Usually, you would use a <code class="inlineCode">nullptr</code> to signal the absence of an object instance. But, using a <code class="inlineCode">nullptr</code> requires creating an extra check before every usage of the instance for being valid or not. Dereferencing a non-existing instance leads to a runtime error, and the application crashes.</p>
    <p class="normal">The null object is a valid object instance, delivering a well-defined, but neutral behavior. Function calls in the instance of the null object are valid, but may return nothing viable, like an empty list, or some default values. This behavior frees the code of extra checks, since the instance itself is valid.</p>
    <p class="normal">For our selection problem, we simply create an instance of the <code class="inlineCode">AssimpModel</code> class that returns no vertices, plus empty lists or vectors for nodes, meshes, and so on. Then, we add the special model as the first model to the <code class="inlineCode">miModelList</code> vector and add one instance of the “null model” as the first instance to the <code class="inlineCode">miAssimpInstances</code> vector and to the <code class="inlineCode">miAssimpInstancesPerModel</code> map.</p>
    <p class="normal">If we select the first model instance now, we have a valid object, just without any triangles drawn to the screen. Switching off the coordinate arrows or adjusting the user interface to disable controls if no instance is selected can be done without extra signalling variables. We just need to test <code class="inlineCode">miSelectedInstance</code> for being <code class="inlineCode">0</code>.</p>
    <p class="normal">We will alter the original pattern a bit, and don’t use a derived class. Instead, we will provide an empty object of the <code class="inlineCode">AssimpModel</code> class.</p>
    <h2 id="_idParaDest-104" class="heading-2">Creating and using the AssimpModel null object</h2>
    <p class="normal">Since we initialized the class members variables already in the header file <code class="inlineCode">AssimpModel.h</code> with default values, creating a<a id="_idIndexMarker146"/> null object can be achieved by creating an empty instance. And the simplest way to create an instance of the <code class="inlineCode">AssimpModel</code> class without <a id="_idIndexMarker147"/>setting any data is by using the implicitly created default constructor. We don’t even need to define a custom constructor; the C++ compiler will handle everything we need in the background.</p>
    <p class="normal">In the <code class="inlineCode">init()</code> method of the renderer, we create a smart pointer to the null model, and add the model pointer to the <code class="inlineCode">miModelList</code> vector:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::shared_ptr&lt;AssimpModel&gt; nullModel =
    std::make_shared&lt;AssimpModel&gt;();
  mModelInstData.miModelList.emplace_back(nullModel)
</code></pre>
    <p class="normal">Then, we can create an <code class="inlineCode">AssimpInstance</code> instance from the null model, and place it into the <code class="inlineCode">miAssimpInstancesPerModel</code> map and the <code class="inlineCode">miAssimpInstances</code> vector:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::shared_ptr&lt;AssimpInstance&gt; nullInstance =
    std::make_shared&lt;AssimpInstance&gt;(nullModel);
  mModelInstData.miAssimpInstancesPerModel[nullModel
    -&gt;getModelFileName()].emplace_back(nullInstance);
  mModelInstData.miAssimpInstances.emplace_back(
    nullInstance);
</code></pre>
    <p class="normal">As the final initialization step, we update the index numbers of the instances:</p>
    <pre class="programlisting code"><code class="hljs-code">  assignInstanceIndices();
</code></pre>
    <p class="normal">Now, the instance of the <code class="inlineCode">nullModel</code> model has the index number <code class="inlineCode">0</code>. Any instance added in the application will now start at index <code class="inlineCode">1</code>. Matching numbers for the overall number of instances and the instance index will <a id="_idIndexMarker148"/>avoid confusion about differences in the instance numbering schema.</p>
    <p class="normal">To skip the model during vertex processing in the <code class="inlineCode">draw()</code> call of the renderer, a check for the triangle count has been added:</p>
    <pre class="programlisting code"><code class="hljs-code">    if (numberOfInstances &gt; 0 &amp;&amp;
        modelType.second.at(0)-&gt;getModel()
        -&gt;getTriangleCount() &gt; 0) {
      ...
</code></pre>
    <p class="normal">In case we have no triangles in a model, all instances of this specific model will be skipped.</p>
    <p class="normal">In addition, we check for the instance number <code class="inlineCode">0</code> before generating the final vertex position for the coordinate arrows:</p>
    <pre class="programlisting code"><code class="hljs-code">  if (mModelInstData.miSelectedInstance &gt; 0) {
    ....
</code></pre>
    <p class="normal">Whenever the very first instance is selected – the instance of the null model – no coordinate arrows will be drawn on the screen. We can even remove the <code class="inlineCode">size()</code> check of the <code class="inlineCode">miAssimpInstances</code> vector here, as we know we have at least one valid instance available.</p>
    <h2 id="_idParaDest-105" class="heading-2">Adjusting the user interface</h2>
    <p class="normal">In the user interface, we will cheat <a id="_idIndexMarker149"/>a bit to keep the instance selection fields disabled in case the null instance is selected:</p>
    <pre class="programlisting code"><code class="hljs-code">    bool modelListEmtpy =
       modInstData.miModelList.size() == 1;
    bool nullInstanceSelected =
      modInstData.miSelectedInstance == 0;
    size_t numberOfInstances =
      modInstData.miAssimpInstances.size() - 1;
</code></pre>
    <p class="normal">By subtracting <code class="inlineCode">1</code> from the size of the <code class="inlineCode">miModelList</code> vector, we ignore the null model in that vector. We also ignore the null instance of the null model to count the instances in <code class="inlineCode">numberOfInstances</code>. The additional Boolean <code class="inlineCode">nullInstanceSelected</code> helps us to disable parts of the user interface when models and instances are available, but we have not selected any of the instances.</p>
    <p class="normal">In <em class="italic">Figure 3.5</em>, the effect of the deselection by using the null object is shown:</p>
    <figure class="mediaobject"><img src="img/Figure_3.5_B22428.png" alt="" width="1641" height="966"/></figure>
    <p class="packt_figref">Figure 3.5: User interface is partially disabled when nothing is selected</p>
    <p class="normal">No coordinate arrows are drawn<a id="_idIndexMarker150"/> at the feet of the model instance, as we hide the arrows when the null instance is selected. Also, the user interface is partially disabled, an effect of ignoring the null instance when counting the number of instances.</p>
    <h1 id="_idParaDest-106" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we enhanced the instance selection methods in the code for better handling of finding the selected instance on the screen. Plus, we added the ability to select an instance by using the mouse. First, we implemented a button to center our virtual camera on the selected instance. Next, we added the ability to highlight the selected model, making it easier to spot on the screen. Then, we implemented a visual selection, allowing the user to select an instance by clicking on any instance with the mouse. Finally, we created the possibility to select no instance at all, avoiding accidental changes.</p>
    <p class="normal">In the next chapter, we will lay some groundwork to adapt more game engine features to the model viewer. As well as splitting the behavior of the viewer into an edit mode and a pure viewer functionality, we will add the ability to revert ongoing changes to an instance. At the end of the next chapter, we will implement undo/redo functionality, allowing the user to revert changes, or to reapply previous changes.</p>
    <h1 id="_idParaDest-107" class="heading-1">Practical sessions</h1>
    <p class="normal">There are some additions you could make to the code:</p>
    <ul>
      <li class="bulletList">Calculate azimuth and elevation when moving the camera.</li>
    </ul>
    <p class="normal-one">Right now, the values for azimuth and elevation are hard-coded. You could try to calculate both values from the transformation matrix.</p>
    <ul>
      <li class="bulletList">Implement a visual multi-selection.</li>
    </ul>
    <p class="normal-one">Enhance the selection so that holding <em class="italic">Ctrl</em> or <em class="italic">Shift</em> during selection clicks will add the newly selected instance to the other selected instances, instead of replacing the current selected instance.</p>
    <ul>
      <li class="bulletList">Extra difficulty: Implement instance moving via coordinate arrows.</li>
    </ul>
    <p class="normal-one">Since the coordinate arrows for the selection are drawn in a separate shader, you could try to add an extra set of selection indices to the arrows and adding the arrows to the selection texture. When the user clicks on one of the arrows instead of the mode, you could switch the application to a mode where the instance can be moved along the selected axis. This behavior is similar to moving an instance in any common 3D editor.</p>
    <h1 id="_idParaDest-108" class="heading-1">Additional resources</h1>
    <ul>
      <li class="bulletList">OpenGL basics: <a href="https://learnopengl.com/Getting-started/Hello-Triangle">https://learnopengl.com/Getting-started/Hello-Triangle</a></li>
      <li class="bulletList">OpenGL Shader programming: <a href="https://learnopengl.com/Getting-started/Shaders">https://learnopengl.com/Getting-started/Shaders</a></li>
      <li class="bulletList">Vulkan Tutorial: <a href="https://vulkan-tutorial.com">https://vulkan-tutorial.com</a></li>
      <li class="bulletList">Demystifying Floating Point Precision: <a href="https://blog.demofox.org/2017/11/21/floating-point-precision/">https://blog.demofox.org/2017/11/21/floating-point-precision/</a></li>
      <li class="bulletList">Null object pattern: <a href="https://www.geeksforgeeks.org/null-object-design-pattern/">https://www.geeksforgeeks.org/null-object-design-pattern/</a></li>
    </ul>
    <h1 id="_idParaDest-109" class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/cppgameanimation">https://packt.link/cppgameanimation</a></p>
    <p class="normal"><img src="img/QR_code_Discord.png" alt="A qr code with black squares  AI-generated content may be incorrect." width="150" height="150"/></p>
  </div>
</div></div></body></html>