["```cpp\n#include <boost/asio.hpp>\n\nusing namespace boost;\n\nint main()\n{\n  // Steps 1 and 2\\. Create and fill simple buffers.\n  const char* part1 = \"Hello \";\n  const char* part2 = \"my \";\n  const char* part3 = \"friend!\";\n\n  // Step 3\\. Create an object representing a composite buffer.\n  std::vector<asio::const_buffer> composite_buffer;\n\n  // Step 4\\. Add simple buffers to the composite buffer.\n  composite_buffer.push_back(asio::const_buffer(part1, 6));\n  composite_buffer.push_back(asio::const_buffer(part2, 3));\n  composite_buffer.push_back(asio::const_buffer(part3, 7));\n\n  // Step 5\\. Now composite_buffer can be used with Boost.Asio\n  // output operations as if it was a simple buffer represented\n  // by contiguous block of memory.\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n\nusing namespace boost;\n\nint main()\n{\n  // Step 1\\. Allocate simple buffers.\n  char part1[6];\n  char part2[3];\n  char part3[7];\n\n  // Step 2\\. Create an object representing a composite buffer.\n  std::vector<asio::mutable_buffer> composite_buffer;\n\n  // Step 3\\. Add simple buffers to the composite buffer object.\n  composite_buffer.push_back(asio::mutable_buffer(part1,\n  sizeof(part1)));\n  composite_buffer.push_back(asio::mutable_buffer(part2,\n  sizeof(part2)));\n  composite_buffer.push_back(asio::mutable_buffer(part3,\n  sizeof(part3)));\n\n  // Now composite_buffer can be used with Boost.Asio \n  // input operation as if it was a simple buffer \n  // represented by contiguous block of memory.\n\n  return 0;\n}\n```", "```cpp\ntypedef basic_waitable_timer< std::chrono::system_clock >\n   system_timer;\ntypedef basic_waitable_timer< std::chrono::steady_clock > \n   steady_timer;\ntypedef basic_waitable_timer< std::chrono::high_resolution_clock >\n   high_resolution_timer;\n```", "```cpp\n#include <boost/asio/steady_timer.hpp>\n#include <iostream>\n\nusing namespace boost;\n```", "```cpp\nint main()\n{\n```", "```cpp\n  asio::io_service ios;\n```", "```cpp\n  asio::steady_timer t1(ios);\n  t1.expires_from_now(std::chrono::seconds(2));\n```", "```cpp\n  asio::steady_timer t2(ios);\n  t2.expires_from_now(std::chrono::seconds(5));\n```", "```cpp\n   t1.async_wait([&t2](boost::system::error_code ec) {\n      if (ec == 0) {\n         std::cout << \"Timer #2 has expired!\" << std::endl;\n      }\n      else if (ec == asio::error::operation_aborted) {\n         std::cout << \"Timer #2 has been cancelled!\" \n                     << std::endl;\n      }\n      else {\n         std::cout << \"Error occured! Error code = \"\n            << ec.value()\n            << \". Message: \" << ec.message() \n                      << std::endl;\n      }\n\n      t2.cancel();\n   });\n```", "```cpp\n   t2.async_wait([](boost::system::error_code ec) {\n      if (ec == 0) {\n         std::cout << \"Timer #2 has expired!\" << std::endl;\n      }\n      else if (ec == asio::error::operation_aborted) {\n         std::cout << \"Timer #2 has been cancelled!\" \n<< std::endl;\n      }\n      else {\n         std::cout << \"Error occured! Error code = \"\n            << ec.value()\n            << \". Message: \" << ec.message() \n<< std::endl;\n      }\n   });\n```", "```cpp\n  ios.run();\n\n  return 0;\n}\n```", "```cpp\nvoid callback(\n  const boost::system::error_code& ec);\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main()\n{\n  try {\n    asio::io_service ios;\n\n    // Create and open a TCP socket.\n    asio::ip::tcp::socket sock(ios, asio::ip::tcp::v4());\n\n    // Create an object representing receive buffer\n      // size option.\n    asio::socket_base::receive_buffer_size cur_buf_size;\n\n    // Get the currently set value of the option. \n    sock.get_option(cur_buf_size);\n\n    std::cout << \"Current receive buffer size is \"\n      << cur_buf_size.value() << \" bytes.\"\n      << std::endl;\n\n    // Create an object representing receive buffer\n      // size option with new value.\n    asio::socket_base::receive_buffer_size\n      new_buf_size(cur_buf_size.value() * 2);\n\n    // Set new value of the option.\n    sock.set_option(new_buf_size);\n\n    std::cout << \"New receive buffer size is \"\n      << new_buf_size.value() << \" bytes.\"\n      << std::endl;\n  }\n  catch (system::system_error &e) {\n    std::cout << \"Error occured! Error code = \" << e.code()\n      << \". Message: \" << e.what();\n\n    return e.code().value();\n  }\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n#include <iostream>\n\nusing namespace boost;\n\nint main() \n{\n  asio::ip::tcp::iostream stream(\"localhost\", \"3333\");\n  if (!stream) {\n    std::cout << \"Error occurred! Error code = \" \n      << stream.error().value()\n      << \". Message = \" << stream.error().message()\n      << std::endl;\n\n    return -1;\n  }\n\n  stream << \"Request.\";\n  stream.flush();\n\n  std::cout << \"Response: \" << stream.rdbuf();\n\n  return 0;\n} \n```", "```cpp\n  // ... \n  asio::io_service io_service;\n\n  asio::ip::tcp::acceptor acceptor(io_service,\n    asio::ip::tcp::endpoint(asio::ip::tcp::v4(), 3333));\n\n  asio::ip::tcp::iostream stream;\n\nacceptor.accept(*stream.rdbuf());\nstd::cout << \"Request: \" << stream.rdbuf();\nstream << \"Response.\";\n// ...\n```"]