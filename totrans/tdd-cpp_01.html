<html><head></head><body>
		<div><h1 id="_idParaDest-15" class="chapter-number" lang="en-GB"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16" lang="en-GB"><a id="_idTextAnchor015"/>Desired Test Declaration</h1>
			<p lang="en-GB">If we’re going to have a <strong class="bold" lang="">test-driven development</strong> (<strong class="bold" lang="">TDD</strong>) process, we need tests. This chapter will explain what the tests will do, how we will write them, and how we will use them.</p>
			<p lang="en-GB">We’ll be starting from the very beginning and slowly building a full library to help manage and run tests, and we’ll be using the test library to help build itself. Initially, there will only be a single test. The following chapters will add more capabilities and grow the test library.</p>
			<p lang="en-GB">Starting with the end goal in mind, we’ll first think about what it will be like to create and use a test. Writing tests is a big part of TDD, so it makes sense to start thinking about testing even before we have the ability to create and run tests.</p>
			<p lang="en-GB">TDD is a process that will help you design better code and then make changes to your code without breaking parts that you’ve already verified to be working as expected. In order for this process to work, we need to be able to write tests. This chapter will explore what tests can do for us and how we can write them.</p>
			<p lang="en-GB">We’ll cover the following main topics in this chapter:</p>
			<ul>
				<li lang="en-GB">What do we want tests to do for us?</li>
				<li lang="en-GB">What should a test look like?</li>
				<li lang="en-GB">What information does a test need?</li>
				<li lang="en-GB">How can we use C++ to write tests?</li>
				<li lang="en-GB">How will the first test be used?</li>
			</ul>
			<h1 id="_idParaDest-17" lang="en-GB"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p lang="en-GB">All the code in this chapter uses standard C++, which builds on any modern C++ 17 or later compiler and standard library. Future chapters will require C++ 20 but for now, only C++ 17 is needed. The number refers to the year that the standard was approved and finalized, so C++ 17 was released in 2017 and C++ 20 was released in 2020. Each release adds new features and capabilities to the language.</p>
			<p lang="en-GB">The code we’ll be working with starts with an empty console project with a single source file called <code>main.cpp</code>.</p>
			<p lang="en-GB">If your development environment gives you a “Hello, world!” project when starting a new command line or console project, you can delete the contents of the <code>main.cpp</code> file because this chapter will start from the very beginning with an empty file.</p>
			<p lang="en-GB">You can find all the code for this chapter at the following GitHub repository: <a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</a>.</p>
			<h1 id="_idParaDest-18" lang="en-GB"><a id="_idTextAnchor017"/>What do we want tests to do for us?</h1>
			<p lang="en-GB">Before we start learning about test-driven development, what it is, and what the process involves, let’s step back and think about what we want. Without knowing all the details about what a test is, let’s ask ourselves what our tests should look like.</p>
			<p lang="en-GB">I like to relate <a id="_idIndexMarker000"/>programming concepts to everyday experiences whenever possible. Maybe you have an idea to solve a problem that you have noticed and want to see whether your idea will work. If you wanted to test this idea before announcing it to the world, how would you do it?</p>
			<p lang="en-GB">You probably won’t be able to test everything to do with your idea at once. What would that even mean? There are probably small parts of your idea that you can think about initially. These should be easier to test and should help to clarify your idea and get you to think of other things to test.</p>
			<p lang="en-GB">So, let’s focus on simply testing small parts of the idea, whatever it is. You’d want to get everything set up and then start some actions or steps that should tell you whether each part works or not. Some of your tests might work well and some might cause you to rethink your idea. This is definitely better than jumping into the full idea without knowing whether it will work or not.</p>
			<p lang="en-GB">To put this into a real context, let’s say you have an idea to build a better broom. That’s a vague idea that’s hard to envision. However, let’s say that while sweeping the floor recently, you noticed your arms getting sore and thought that there had to be a better way. Thinking about the actual problem is a good way to turn a vague idea into something with a more solid meaning.</p>
			<p lang="en-GB">Now, you might start thinking about testing broom handles of different shapes, different grips, or different sweeping motions. These are the smaller parts of the idea that can be tested. You can take each grip or motion and turn it into a set of steps or actions that will test that part until you find one that works best.</p>
			<p lang="en-GB">Well, in programming, a set of <a id="_idIndexMarker001"/>steps can be a <strong class="bold" lang="">function</strong>. It doesn’t matter what that function does right now. We<a id="_idIndexMarker002"/> can think of each test as represented by a function. If you can call a function and it gives you the expected result, then you can say that the test passed. We’ll build on this idea throughout this book.</p>
			<p lang="en-GB">Now that we’ve decided to use a function for a test, what should it look like? After all, there are lots of ways to write a function.</p>
			<h1 id="_idParaDest-19" lang="en-GB"><a id="_idTextAnchor018"/>What should a test look like?</h1>
			<p lang="en-GB">It should be as simple to write a test as it is to declare and write a function, and we should be able to <a id="_idIndexMarker003"/>simplify things even further. A normal function can have whatever return type you want, a name, a set of parameters, and a body of code.</p>
			<p lang="en-GB">A function is also something that you write so that it can be called by other code. This code should know what the function does, what it returns, and what arguments need to be passed. We’ll keep things simple for our test functions and only worry about the name for now.</p>
			<p lang="en-GB">We want each test function to have its own name. Otherwise, how would we be able to keep track of all the various tests we’ll eventually be writing? As for the return type, we haven’t identified an actual need yet, so we’ll use <code>void</code>.</p>
			<p lang="en-GB">You’ll learn more about this process in <a href="B18567_03.xhtml#_idTextAnchor031"><em class="italic" lang="">Chapter 3</em></a>, <em class="italic" lang="">The TDD Process</em>. When using TDD, don’t get ahead of yourself. Only do what you need to do at the time. As with the <code>void</code> return type, we’ll also not have any parameters.</p>
			<p lang="en-GB">It might seem too simple but this is a good start. So far, a test is nothing more than a function, which returns nothing and takes no parameters. It has a name to identify it and will include whatever code is needed to run the test.</p>
			<p lang="en-GB">Because we’re going to start using TDD to help design a simple testing library, our first test should ensure that we can create a test. This is a simple start, which defines a test function and calls it from <code>main</code>. All of this is in a single file called <code>main.cpp</code>:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;iostream&gt;
void testCanBeCreated ()
{
    std::cout &lt;&lt; "testCanBeCreated" &lt;&lt; std::endl;
}
int main ()
{
    testCanBeCreated();
    return 0;
}</pre>
			<p lang="en-GB">You might be thinking that this is not a test, it’s just a function that prints its own name, and you’d be right. We’re going to build it up from the very beginning in an agile manner using only what <a id="_idIndexMarker004"/>we have available. Right now, we don’t have a test library to use yet.</p>
			<p lang="en-GB">Still, this is starting to resemble what we eventually want. We want a test to be just like writing a function. If you build and run the project now, the output is as expected:</p>
			<pre>testCanBeCreated
Program ended with exit code: 0</pre>
			<p lang="en-GB">This shows the output from running the program. It displays the name of the function. The text in the second line actually comes from my development tools and shows the program exit code. The exit code is the value returned from <code>main</code>.</p>
			<p lang="en-GB">This is a start but it<a id="_idIndexMarker005"/> can be improved. The next section will look at what information a test needs, such as its name.</p>
			<h1 id="_idParaDest-20" lang="en-GB"><a id="_idTextAnchor019"/>What information does a test need?</h1>
			<p lang="en-GB">The current test function doesn’t really know its name. We want the test to have a name so that it can be<a id="_idIndexMarker006"/> identified but does that name really need to be the name of the function? It would be better if the name was available as data so it could be displayed without hardcoding the name inside the test body.</p>
			<p lang="en-GB">Equally, the current test function doesn’t have any idea of success or failure. We purposefully ignored the test result until now, but let’s think about it. Is it enough for a test function to return the status? Maybe it needs a <code>bool</code> return type where true would mean success and false would mean the test failed.</p>
			<p lang="en-GB">That might be a bit too simplistic. Sure, it would be enough for now, but if a test fails, it might be good to know why. A <code>bool</code> return type won’t be enough later. Instead of designing the entire solution, we just need to figure out what to do that will meet the expected needs.</p>
			<p lang="en-GB">Since we already know that we need some data to hold the test name, what if we now add simple <code>bool</code> result data in the same place? This would let us keep the test function return type as <code>void</code>, and it leaves room for a more advanced solution later.</p>
			<p lang="en-GB">Let’s change the test<a id="_idIndexMarker007"/> function into a <code>operator(</code><code>)</code>, as this code shows:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;iostream&gt;
#include &lt;string_view&gt;
class Test
{
public:
    Test (std::string_view name)
    : mName(name), mResult(true)
    {}
    void operator () ()
    {
        std::cout &lt;&lt; mName &lt;&lt; std::endl;
    }
private:
    std::string mName;
    bool mResult;
};
Test test("testCanBeCreated");
int main ()
{
    test();
    return 0;
}</pre>
			<p lang="en-GB">The biggest problem with this is that we no longer have a simple way to write a test as if it was a simple function. By providing <code>operator ()</code>, or <em class="italic" lang="">function call operator</em>, we created a functor that will let us call the class as if it was a function from within the <code>main</code> function. However, it’s more code to write. It solves the problem of the test name, gives us a simple solution for the result, which can be expanded later, and also solves another problem that wasn’t obvious before.</p>
			<p lang="en-GB">When we called the test function in <code>main</code> before, we had to call it by the function name. That’s how functions are called in code, right? This new design eliminates that coupling by creating <a id="_idIndexMarker009"/>an instance of the <code>Test</code> functor called <code>test</code>. Now, <code>main</code> doesn’t care about the test name. It only refers to the instance of the functor. The only place in which the name of the test now appears in the code is when the functor instance is created.</p>
			<p lang="en-GB">We can fix the problem of all the extra code needed to write a test by using a <em class="italic" lang="">macro</em>. Macros are not needed in C++ as they used to be and some people might even think that they should be removed from the language entirely. They do have a couple of good uses left and <em class="italic" lang="">wrapping up code</em> into a macro is one of them.</p>
			<p lang="en-GB">We’ll eventually put the macro definition into a separate header file, which will become the test library. What we want to do is wrap up all the functor code in the macro but leave the implementation of the actual test function body to be written as if everything was a normal function.</p>
			<p lang="en-GB">First, we’ll make a simple change to move the implementation of the test function body outside of the class definition, like this. The function call operator is the method that needs to be moved outside:</p>
			<pre class="source-code" lang="en-GB">
class Test
{
public:
    Test (std::string_view name)
    : mName(name), mResult(true)
    {}
    void operator () ();
private:
    std::string mName;
    bool mResult;
};
Test test("testCanBeCreated");
void Test::operator () ()
{
    std::cout &lt;&lt; mName &lt;&lt; std::endl;
}</pre>
			<p lang="en-GB">Then, the class definition, instance declaration, and first line of the function call operator can be turned into a macro. Compare the following code with the previous code to see how the <code>Test</code> class is turned into the <code>TEST</code> macro. By itself, this macro would not compile because it leaves the function call operator in an unfinished state. That’s exactly <a id="_idIndexMarker010"/>what we want because it lets the code use the macro like a function signature declaration and finish it up by providing the code inside the curly braces:</p>
			<pre class="source-code" lang="en-GB">
#define TEST class Test \
{ \
public: \
    Test (std::string_view name) \
    : mName(name), mResult(true) \
    {} \
    void operator () (); \
private: \
    std::string mName; \
    bool mResult; \
}; \
Test test("testCanBeCreated"); \
void Test::operator () ()
TEST
{
    std::cout &lt;&lt; mName &lt;&lt; std::endl;
}</pre>
			<p lang="en-GB">Because the macro is defined over multiple lines, each line except the last needs to end with a backslash. The macro is a little more compact because the empty lines have been removed. This is<a id="_idIndexMarker011"/> a personal choice and you can leave the empty lines if you want. An empty line still needs the backslash though, which defeats the purpose of having an empty line.</p>
			<p lang="en-GB">The code uses the <code>TEST</code> macro with the unfinished function call operator just like a function definition, but then it completes the code by providing the curly braces and method implementation needed.</p>
			<p lang="en-GB">We’re making progress! It might be hard to see it because everything is in a single file. Let’s fix that by creating a new file called <code>Test.h</code> and moving the macro definition to the new file, like this:</p>
			<pre class="source-code" lang="en-GB">
#ifndef TEST_H
#define TEST_H
#include &lt;string_view&gt;
#define TEST class Test \
{ \
public: \
    Test (std::string_view name) \
    : mName(name), mResult(true) \
    {} \
    void operator () (); \
private: \
    std::string mName; \
    bool mResult; \
}; \
Test test("testCanBeCreated"); \
void Test::operator () ()
#endif // TEST_H</pre>
			<p lang="en-GB">Now, we can go back to simpler code in <code>main.cpp</code>, like this next block of code shows. All we need to<a id="_idIndexMarker012"/> do is include <code>Test.h</code> and we can use the macro:</p>
			<pre class="source-code" lang="en-GB">
#include "Test.h"
#include &lt;iostream&gt;
TEST
{
    std::cout &lt;&lt; mName &lt;&lt; std::endl;
}
int main ()
{
    test();
    return 0;
}</pre>
			<p lang="en-GB">We now have something that’s beginning to look like the simple function we started with, but there’s a lot of code hidden inside the <code>TEST</code> macro to make it seem simple.</p>
			<p lang="en-GB">In the next section, we’ll fix<a id="_idIndexMarker013"/> the need for <code>main</code> to call <code>test()</code> directly. The name of the functor, <code>test</code>, is a detail that should not be known outside of the macro, and we definitely shouldn’t need to call a test directly to run it, no matter what it’s called.</p>
			<h1 id="_idParaDest-21" lang="en-GB"><a id="_idTextAnchor020"/>How can we use C++ to write tests?</h1>
			<p lang="en-GB">Calling the test<a id="_idIndexMarker014"/> directly might not seem like a big problem right now because<a id="_idIndexMarker015"/> we only have one test. However, as more tests are added, the need to call each one from <code>main</code> will lead to problems. Do you really want to have to modify the <code>main</code> function every time you add or remove a test?</p>
			<p lang="en-GB">The C++ language doesn’t have a way to add extra custom information to a function or a class that could be used to identify all the tests. So, there is no way to look through all the code, find all the tests automatically, and run them.</p>
			<p lang="en-GB">One of the tenets of C++ is to avoid adding language features that you might not need, especially language features that affect your code without your awareness. Other languages might let you do other things, such as adding custom attributes, which you can use to identify tests. C++ defines standard attributes, which are intended to help the compiler optimize code execution or improve the compilation of your code. The standard C++ attributes are not something that we can use to identify tests and custom attributes would go against the tenet of unneeded features. I like this about C++, even if it means that we have to work a little harder to figure out which tests to run.</p>
			<p lang="en-GB">All we need to do is <a id="_idIndexMarker016"/>let each test identify itself. This is different from writing code that would try to find the tests. Finding the tests requires that they be marked in some<a id="_idIndexMarker017"/> way, such as using an attribute, so that they stand out and this isn’t possible in C++. Instead of <em class="italic" lang="">finding them</em>, we can use the constructor of each test functor so that they <em class="italic" lang="">register themselves</em>. The constructor for each test will add itself to the registry by pushing a pointer to itself onto a collection.</p>
			<p lang="en-GB">Once all the tests are registered through addition to a collection, we can go through the collection and run them all. We already simplified the tests so that they can all be run in the same way.</p>
			<p lang="en-GB">There’s just one complication that we need to be careful about. The test instances that are created in the <code>TEST</code> macro are global variables and can be spread out over many different source files. Right now, we have a single test declared in a single <code>main.cpp</code> source file. We’ll need to make sure that the collection that will eventually hold all the registered tests is set up and ready to hold the tests before we start trying to add tests to the collection. We’ll use a function to help coordinate the setup. This is the <code>getTests</code> function, shown in the following code. The way <code>getTests</code> works is not obvious and is described in more detail after the next code.</p>
			<p lang="en-GB">Now is also a good time to start<a id="_idIndexMarker018"/> thinking about a <code>MereTDD</code>.</p>
			<p lang="en-GB">Here is the first part of the <code>Test.h</code> file with the new namespace and registration code added. We should also<a id="_idIndexMarker019"/> update the <code>include</code> guard to something more specific, such<a id="_idIndexMarker020"/> as <code>MERETDD_TEST_H</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
#ifndef MERETDD_TEST_H
#define MERETDD_TEST_H
#include &lt;string_view&gt;
#include &lt;vector&gt;
namespace MereTDD
{
class TestInterface
{
public:
    virtual ~TestInterface () = default;
    virtual void run () = 0;
};
std::vector&lt;TestInterface *&gt; &amp; getTests ()
{
    static std::vector&lt;TestInterface *&gt; tests;
    return tests;
}
} // namespace MereTDD</pre>
			<p lang="en-GB">Inside the namespace, there is a new <code>TestInterface</code> class declared with a <code>run</code> method. I decided to move away from a functor and to this new design because when we need to actually run the test later, it looks more intuitive and understandable to have a method called <code>run</code>.</p>
			<p lang="en-GB">The collection of tests is stored in a <em class="italic" lang="">vector</em> of <code>TestInterface</code> <em class="italic" lang="">pointers</em>. This is a good place to use raw pointers because there is no ownership implied. The collection will not be<a id="_idIndexMarker021"/> responsible for deleting these pointers. The vector is declared as a <em class="italic" lang="">static</em> variable inside the <code>getTests</code> function. This is to make sure that the vector <a id="_idIndexMarker022"/>is properly initialized, even if it is first accessed from another <code>.cpp</code> source file compilation unit.</p>
			<p lang="en-GB">C++ language makes sure that <em class="italic" lang="">global variables</em> are initialized before <code>main</code> begins. That means we have code in the <code>test</code> instance constructors that get run before <code>main</code> begins. When we have multiple <code>.cpp</code> files later, making sure that the collection is initialized first becomes important. If the collection is a normal global variable that is accessed directly from another compilation unit, then it could be that the collection is not yet ready when the test tries to push itself onto the collection. Nevertheless, by going through the <code>getTests</code> function, we avoid the readiness issue because the compiler will make sure to initialize the static vector the <em class="italic" lang="">first time that the function is called</em>.</p>
			<p lang="en-GB">We need to scope references to classes and functions declared inside the namespace anytime they are used within the macro. Here is the last part of <code>Test.h</code>, with changes to the macro to use the namespace:</p>
			<pre class="source-code" lang="en-GB">
#define TEST \
class Test : public MereTDD::TestInterface \
{ \
public: \
    Test (std::string_view name) \
    : mName(name), mResult(true) \
    { \
        MereTDD::getTests().push_back(this); \
    } \
    void run () override; \
private: \
    std::string mName; \
    bool mResult; \
}; \
Test test("testCanBeCreated"); \
void Test::run ()
#endif // MERETDD_TEST_H</pre>
			<p lang="en-GB">The <code>Test</code> constructor now registers itself by calling <code>getTests</code> and pushing back a pointer to itself to<a id="_idIndexMarker023"/> the vector it gets. It doesn’t matter which <code>.cpp</code> file is being<a id="_idIndexMarker024"/> compiled now. The collection of tests will be fully initialized once <code>getTests</code> returns the vector.</p>
			<p lang="en-GB">The <code>TEST</code> macro remains outside of the namespace because it doesn’t get compiled here. It only gets inserted into other code whenever the macro is used. That’s why inside the macro, it now needs to qualify <code>TestInterface</code> and the <code>getTests</code> call with the <code>MereTDD</code> namespace.</p>
			<p lang="en-GB">Inside <code>main.cpp</code>, the only change is how to call the test. We no longer refer to the test instance directly and now iterate through all the tests and call <code>run</code> for each one. This is the reason I decided to use a method called <code>run</code> instead of the function call operator:</p>
			<pre class="source-code" lang="en-GB">
int main ()
{
    for (auto * test: MereTDD::getTests())
    {
        test-&gt;run();
    }
    return 0;
}</pre>
			<p lang="en-GB">We can simplify this even more. The code in <code>main</code> seems like it needs to know too much about how the tests are run. Let’s create a new function called <code>runTests</code> to hold the <code>for</code> loop. We <a id="_idIndexMarker025"/>might later need to enhance the <code>for</code> loop and this seems<a id="_idIndexMarker026"/> like it should be internal to the test library. Here is what <code>main</code> should look like now:</p>
			<pre class="source-code" lang="en-GB">
int main ()
{
    MereTDD::runTests();
    return 0;
}</pre>
			<p lang="en-GB">We can enable this change by adding the <code>runTests</code> function to <code>Test.h</code> inside the namespace, like this:</p>
			<pre class="source-code" lang="en-GB">
namespace MereTDD
{
class TestInterface
{
public:
    virtual ~TestInterface () = default;
    virtual void run () = 0;
};
std::vector&lt;TestInterface *&gt; &amp; getTests ()
{
    static std::vector&lt;TestInterface *&gt; tests;
    return tests;
}
void runTests ()
{
    for (auto * test: getTests())
    {
        test-&gt;run();
    }
}
} // namespace MereTDD</pre>
			<p lang="en-GB">After all these changes, we have a simplified <code>main</code> function that just calls on the test library to<a id="_idIndexMarker027"/> run all the tests. It doesn’t know anything about which tests<a id="_idIndexMarker028"/> are run or how. Even though we still have a single test, we’re creating a solid design that will support multiple tests.</p>
			<p lang="en-GB">The next section explains how you will use tests by looking at the first test.</p>
			<h1 id="_idParaDest-22" lang="en-GB"><a id="_idTextAnchor021"/>How will the first test be used?</h1>
			<p lang="en-GB">So far, we have a single test<a id="_idIndexMarker029"/> that outputs its name when run, and this test is declared inside of <code>main.cpp</code>. This is not how you’ll want to declare your tests going forward. I’ve mentioned having multiple <code>.cpp</code> files with multiple tests in each one. We’re not ready for that yet but we can at least move the single test that we have into its own <code>.cpp</code> file.</p>
			<p lang="en-GB">The whole point of declaring multiple tests in multiple <code>.cpp</code> files is to help organize your tests. Group them into something meaningful. We’ll get to multiple tests later. For now, what is the purpose of our single test?</p>
			<p lang="en-GB">It is supposed to show that a test can be created. There may be other aspects of test creation that we’ll be interested in. So, it might make sense to create a <code>.cpp</code> file focused on test creation. Inside this <code>.cpp</code> file would be all the tests relating to <em class="italic" lang="">different ways to create tests</em>.</p>
			<p lang="en-GB">You can organize your tests however you want. If you have a project you are working on that has its own set of source files, it might make sense to group your tests around the source files. So, you would have a test <code>.cpp</code> file with many tests inside, which are all designed to test everything related to a <code>.cpp</code> file from your actual project. This would make sense if your project files were already organized well.</p>
			<p lang="en-GB">Or, you might take a more functional approach to organizing your tests. Since we only have a single header file called <code>Test.h</code> that we need to test, instead of also creating a single <code>.cpp</code> file to hold all the tests, let’s take a functional approach and split the tests based on their purpose.</p>
			<p lang="en-GB">Let’s add a new <code>.cpp</code> file to the project called <code>Creation.cpp</code> and move the single test that we have so far into the new file. At the same time, let’s think for a moment about how we will use the test library later on.</p>
			<p lang="en-GB">What we’re building is not really a library that gets compiled and linked into another project. It’s just a single header file called <code>Test.h</code>, which other projects can include. It’s still a library, just one that gets compiled alongside the other project.</p>
			<p lang="en-GB">We can even start treating the tests we have now this way. In the project structure, we have <code>Test.h</code> and <code>main.cpp</code> so far. The <code>main.cpp</code> file is similar to that of the test project that is intended to test the <code>Test.h</code> include file. Let’s reorganize the project structure so that both <code>main.cpp</code> and the new <code>Creation.cpp</code> files are in a folder called <code>tests</code>. These will form the basis for a testing executable that exercises all the tests needed to test <code>Test.h</code>. In other words, we’re turning the console project that we have into a test project designed to test the test library. The test library is not a separate project because it’s just a single header file that will be included as part of other projects.</p>
			<p lang="en-GB">Later on, in other <a id="_idIndexMarker030"/>projects of your own, you can do the same thing. You’ll have your primary project with all its source files. You’ll also have another test project in a subfolder called <code>tests</code> with its own <code>main.cpp</code> and all the test files. Your test project will include <code>Test.h</code> from the test library but it won’t be trying to test the test library as we’re doing here. It will instead be focused on testing your own project in the primary project folder. You’ll see how all this works once we get the test library to a suitable state so that it can be used to create a different project. We’ll be creating a logging library in <em class="italic" lang="">Part 2</em>, <em class="italic" lang="">Logging Library</em>. The logging library will have a subfolder called <code>tests</code>, as I just described.</p>
			<p lang="en-GB">Turning back to what we have now, let’s reorganize the overall project structure for the test library. You can create the <code>tests</code> folder and move <code>main.cpp</code> into it. Make sure to place the new <code>Creation.cpp</code> file into the <code>tests</code> folder. The project structure should look like this:</p>
			<pre class="source-code" lang="en-GB">
MereTDD project root folder
    Test.h
    tests folder
        main.cpp
        Creation.cpp</pre>
			<p lang="en-GB">The <code>main.cpp</code> file can be simplified like this by removing the test and leaving only <code>main</code>:</p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
int main ()
{
    MereTDD::runTests();
    return 0;
}</pre>
			<p lang="en-GB">Now, the new <code>Creation.cpp</code> file only<a id="_idIndexMarker031"/> contains the single test we have so far, like so:</p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
#include &lt;iostream&gt;
TEST
{
    std::cout &lt;&lt; mName &lt;&lt; std::endl;
}</pre>
			<p lang="en-GB">However, building the project like so now gives a linker error, because we are including <code>Test.h</code> in both the <code>main.cpp</code> and the <code>Creation.cpp</code> compilation units. As a result, we have two methods that result in duplicate symbols. In order to remove the duplicate symbols, we need to declare both <code>getTests</code> and <code>runTests</code> to be inline, like this:</p>
			<pre class="source-code" lang="en-GB">
inline std::vector&lt;TestInterface *&gt; &amp; getTests ()
{
    static std::vector&lt;TestInterface *&gt; tests;
    return tests;
}
inline void runTests ()
{
    for (auto * test: getTests())
    {
        test-&gt;run();
    }
}</pre>
			<p lang="en-GB">Now, everything builds<a id="_idIndexMarker032"/> and runs again and we get the same result as before. The output displays the name of the single test we have so far:</p>
			<pre>testCanBeCreated
Program ended with exit code: 0</pre>
			<p lang="en-GB">The output remains unchanged from before. We haven’t added any more tests or changed what the current test does. We have changed how the tests are registered and run, and we have <a id="_idIndexMarker033"/>reorganized the project structure.</p>
			<h1 id="_idParaDest-23" lang="en-GB"><a id="_idTextAnchor022"/>Summary</h1>
			<p lang="en-GB">This chapter has introduced the test library, which consists of a single header file called <code>Test.h</code>. It has also shown us how to create a test project, which is a console application that will be used to test the test library.</p>
			<p lang="en-GB">We have seen how this has evolved from a simple function into a test library that knows how to register and run tests. It’s not ready yet. We still have a way to go before the test library can be used in a TDD process to help you design and test your own projects.</p>
			<p lang="en-GB">By seeing how the test library evolves, you’ll come to understand how to use it in your own projects. In the next chapter, you’ll understand the challenges of adding multiple tests. There’s a reason why we only have a single test so far. Enabling multiple tests and reporting the results of the tests is what the next chapter will cover.</p>
		</div>
	</body></html>