["```cpp\n$ cmake . && cmake —build .\n```", "```cpp\nexport ASAN_SYMBOLIZER_PATH=`which llvm-symbolizer`\nexport PATH=$ASAN_SYMBOLIZER_PATH:$PATH\n```", "```cpp\ntype:location_pattern\n```", "```cpp\n# Suppress known memory leaks in third-party function Func1 in library Lib1\nleak:Lib1::Func1\n# Ignore false-positive from function Func2 in library Lib2\nrace:Lib2::Func2\n# Suppress issue from libc\nleak:/usr/lib/libc.so.*\n```", "```cpp\n$ clang++ -O0 -g -fsanitize=address -fno-omit-frame-pointer test.cpp –o test\n$ ASAN_OPTIONS=suppressions=myasan.supp ./test\n```", "```cpp\n#if defined(__clang__) || defined (__GNUC__)\n# define ATTRIBUTE_NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address))\n#else\n# define ATTRIBUTE_NO_SANITIZE_ADDRESS\n#endif\n...\nATTRIBUTE_NO_SANITIZE_ADDRESS\nvoid ThisFunctionWillNotBeInstrumented() {...}\n```", "```cpp\nASAN_OPTIONS=detect_stack_use_after_return=1,print_stacktrace=1,log_path=asan.log\n```", "```cpp\nASAN_OPTIONS=strict_string_checks=1:detect_stack_use_after_return=1:check_initialization_order=1:strict_init_order=1\n```", "```cpp\n#include <iostream>\n#include <memory>\nint main() {\n  auto arr = new int[100];\n  delete[] arr;\n  std::cout << \"arr[0] = \" << arr[0] << '\\n';\n  return 0;\n}\n```", "```cpp\n$ clang++ -fsanitize=address -fno-omit-frame-pointer -g -O0 –o test test.cpp\n```", "```cpp\nERROR: AddressSanitizer: heap-use-after-free on address 0x514000000040 at pc 0x63acc82a0bec bp 0x7fff2d096c60 sp 0x7fff2d096c58\nREAD of size 4 at 0x514000000040 thread T0\n    #0 0x63acc82a0beb in main test.cpp:7:31\n0x514000000040 is located 0 bytes inside of 400-byte region [0x514000000040,0x5140000001d0)\nfreed by thread T0 here:\n    #0 0x63acc829f161 in operator delete[](void*) (/mnt/StorePCIE/Projects/Books/Packt/Book/Code/build/bin/Chapter_11/11x02-ASAN_heap_use_after_free+0x106161) (BuildId: 7bf8fe6b1f86a8b587fbee39ae3a5ced3e866931)\npreviously allocated by thread T0 here:\n    #0 0x63acc829e901 in operator new[](unsigned long) (/mnt/StorePCIE/Projects/Books/Packt/Book/Code/build/bin/Chapter_11/11x02-ASAN_heap_use_after_free+0x105901) (BuildId: 7bf8fe6b1f86a8b587fbee39ae3a5ced3e866931)\nSUMMARY: AddressSanitizer: heap-use-after-free test.cpp:7:31 in main\n```", "```cpp\n#include <iostream>\nint main() {\n  auto arr = new int[100];\n  arr[0] = 0;\n  int res = arr[100];\n  std::cout << \"res = \" << res << '\\n';\n  delete[] arr;\n  return 0;\n}\n```", "```cpp\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x5140000001d0 at pc 0x582953d2ac07 bp 0x7ffde9d58910 sp 0x7ffde9d58908\nREAD of size 4 at 0x5140000001d0 thread T0\n    #0 0x582953d2ac06 in main test.cpp:6:13\n0x5140000001d0 is located 0 bytes after 400-byte region [0x514000000040,0x5140000001d0)\nallocated by thread T0 here:\n    #0 0x582953d28901 in operator new[](unsigned long) (test+0x105901) (BuildId: 82a16fc86e01bc81f6392d4cbcad0fe8f78422c0)\n    #1 0x582953d2ab78 in main test.cpp:4:14\n(test+0x2c374) (BuildId: 82a16fc86e01bc81f6392d4cbcad0fe8f78422c0)\nSUMMARY: AddressSanitizer: heap-buffer-overflow test.cpp:6:13 in main\n```", "```cpp\n#include <string.h>\n#include <iostream>\n#include <memory>\nint main() {\n    auto arr = new char[100];\n    strcpy(arr, \"Hello world!\");\n    std::cout << \"String = \" << arr << '\\n';\n    return 0;\n}\n```", "```cpp\n$ clang++ -fsanitize=leak -fno-omit-frame-pointer -g -O2 –o test test.cpp\n```", "```cpp\nERROR: LeakSanitizer: detected memory leaks\nDirect leak of 100 byte(s) in 1 object(s) allocated from:\n    #0 0x5560ba9a017c in operator new[](unsigned long) (test+0x3417c) (BuildId: 2cc47a28bb898b4305d90c048c66fdeec440b621)\n    #1 0x5560ba9a2564 in main test.cpp:6:16\nSUMMARY: LeakSanitizer: 100 byte(s) leaked in 1 allocation(s).\n```", "```cpp\nTSAN_OPTIONS=halt_on_error=1\n```", "```cpp\n#include <thread>\nint globalVar{0};\nvoid increase() {\n  globalVar++;\n}\nvoid decrease() {\n  globalVar--;\n}\nint main() {\n  std::thread t1(increase);\n  std::thread t2(decrease);\n  t1.join();\n  t2.join();\n  return 0;\n}\n```", "```cpp\n$ clang++ -fsanitize=thread -fno-omit-frame-pointer -g -O2 –o test test.cpp\n```", "```cpp\nWARNING: ThreadSanitizer: data race (pid=31692)\n  Write of size 4 at 0x5932b0585ae8 by thread T2:\n    #0 decrease() test.cpp:10:12 (test+0xe0b32) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)\n  Previous write of size 4 at 0x5932b0585ae8 by thread T1:\n    #0 increase() test.cpp:6:12 (test+0xe0af2) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)\n  Thread T2 (tid=31695, running) created by main thread at:\n    #0 pthread_create <null> (test+0x6062f) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)\n  Thread T1 (tid=31694, finished) created by main thread at:\n    #0 pthread_create <null> (test+0x6062f) (BuildId: 895b75ef540c7b44daa517a874d99d06bd27c8f7)\nSUMMARY: ThreadSanitizer: data race test.cpp:10:12 in decrease()\nThreadSanitizer: reported 1 warnings\n```", "```cpp\nFATAL: ThreadSanitizer: unexpected memory mapping 0x603709d10000-0x603709d11000\n```", "```cpp\n$ sudo sysctl vm.mmap_rnd_bits=30\n```", "```cpp\n$ sudo sysctl vm.mmap_rnd_bits\nvm.mmap_rnd_bits = 30\n```", "```cpp\n$ setarch `uname -m` -R ./test\n```", "```cpp\n#include <map>\n#include <thread>\nstd::map<int,int> m;\nvoid Thread1() {\n  m[123] = 1;\n}\nvoid Thread2() {\n  m[345] = 0;\n}\nint main() {\n  std::jthread t1(Thread1);\n  std::jthread t2(Thread1);\n  return 0;\n}\n```", "```cpp\nWARNING: ThreadSanitizer: data race (pid=8907)\n  Read of size 4 at 0x720c00000020 by thread T2:\n  Previous write of size 8 at 0x720c00000020 by thread T1:\n  Location is heap block of size 40 at 0x720c00000000 allocated by thread T1:\n  Thread T2 (tid=8910, running) created by main thread at:\n  Thread T1 (tid=8909, finished) created by main thread at:\nSUMMARY: ThreadSanitizer: data race test.cpp:11:3 in Thread2()\n```", "```cpp\n#include <iostream>\n#include <thread>\n#include <map>\n#include <string>\ntypedef std::map<std::string, std::string> map_t;\nvoid *func(void *p) {\n  map_t& m = *static_cast<map_t*>(p);\n  m[\"foo\"] = \"bar\";\n  return 0;\n}\nint main() {\n  map_t m;\n  std::thread t(func, &m);\n  std::cout << \"foo = \" << m[\"foo\"] << '\\n';\n  t.join();\n  return 0;\n}\n```", "```cpp\nWARNING: ThreadSanitizer: data race (pid=10505)\n  Read of size 8 at 0x721800003028 by main thread:\n    #8 main test.cpp:17:28 (test+0xe1d75) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)\n  Previous write of size 8 at 0x721800003028 by thread T1:\n    #0 operator new(unsigned long) <null> (test+0xe0c3b) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)\n    #9 func(void*) test.cpp:10:3 (test+0xe1bb7) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)\n  Location is heap block of size 96 at 0x721800003000 allocated by thread T1:\n    #0 operator new(unsigned long) <null> (test+0xe0c3b) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)\n    #9 func(void*) test.cpp:10:3 (test+0xe1bb7) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)\n  Thread T1 (tid=10507, finished) created by main thread at:\n    #0 pthread_create <null> (test+0x616bf) (BuildId: 8eef80df1b5c81ce996f7ef2c44a6c8a11a9304f)\nSUMMARY: ThreadSanitizer: data race test.cpp:17:28 in main\nThreadSanitizer: reported 7 warnings\n```", "```cpp\n#include <iostream>\n#include <thread>\nclass RefCountedObject {\n   public:\n    void Ref() {\n        ++ref_;\n    }\n    void Unref() {\n        --ref_;\n    }\n   private:\n    // ref_ should be atomic to avoid synchronization issues\n    int ref_{0};\n};\nint main() {\n  RefCountedObject obj;\n  std::jthread t1(&RefCountedObject::Ref, &obj);\n  std::jthread t2(&RefCountedObject::Unref, &obj);\n  return 0;\n}\n```", "```cpp\nWARNING: ThreadSanitizer: data race (pid=32574)\n  Write of size 4 at 0x7fffffffcc04 by thread T2:\n    #0 RefCountedObject::Unref() test.cpp:12:9 (test+0xe1dd0) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)\n  Previous write of size 4 at 0x7fffffffcc04 by thread T1:\n    #0 RefCountedObject::Ref() test.cpp:8:9 (test+0xe1c00) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)\n  Location is stack of main thread.\n  Location is global '??' at 0x7ffffffdd000 ([stack]+0x1fc04)\n  Thread T2 (tid=32577, running) created by main thread at:\n    #0 pthread_create <null> (test+0x6164f) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)\n    #2 main test.cpp:23:16 (test+0xe1b94) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)\n  Thread T1 (tid=32576, finished) created by main thread at:\n    #0 pthread_create <null> (test+0x6164f) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)\n    #2 main test.cpp:22:16 (test+0xe1b56) (BuildId: 448eb3f3d1602e21efa9b653e4760efe46b621e6)\nSUMMARY: ThreadSanitizer: data race test.cpp:12:9 in RefCountedObject::Unref()\nThreadSanitizer: reported 1 warnings\n```", "```cpp\n#include <iostream>\n#include <thread>\nclass MyObj {};\nstatic MyObj *obj = nullptr;\nvoid init_object() {\n  if (!obj) {\n    obj = new MyObj();\n  }\n}\nvoid func1() {\n  init_object();\n}\nvoid func2() {\n  init_object();\n}\nint main() {\n  std::thread t1(func1);\n  std::thread t2(func2);\n  t1.join();\n  t2.join();\n  return 0;\n}\n```", "```cpp\nWARNING: ThreadSanitizer: data race (pid=32826)\n  Read of size 1 at 0x5663912cbae8 by thread T2:\n    #0 func2() test.cpp (test+0xe0b68) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)\n  Previous write of size 1 at 0x5663912cbae8 by thread T1:\n    #0 func1() test.cpp (test+0xe0b3d) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)\n  Location is global 'obj (.init)' of size 1 at 0x5663912cbae8 (test+0x150cae8)\n  Thread T2 (tid=32829, running) created by main thread at:\n    #0 pthread_create <null> (test+0x6062f) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)\n  Thread T1 (tid=32828, finished) created by main thread at:\n    #0 pthread_create <null> (test+0x6062f) (BuildId: 12f32c1505033f9839d17802d271fc869b7a3e38)\nSUMMARY: ThreadSanitizer: data race test.cpp in func2()\nThreadSanitizer: reported 1 warnings\n```", "```cpp\nint main() {\n  int val = 0x7fffffff;\n  val += 1;\n  return 0;\n}\n```", "```cpp\n$ clang++ -fsanitize=undefined -fno-omit-frame-pointer -g -O2 –o test test.cpp\n```", "```cpp\ntest.cpp:3:7: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior test.cpp:3:7\n```", "```cpp\n-fsanitize=memory -fPIE -pie -fno-omit-frame-pointer\n```", "```cpp\n#include <iostream>\nint main() {\n  auto arr = new int[10];\n  arr[5] = 0;\n  std::cout << \"Value at position 0 = \" << arr[0] << '\\n';\n  return 0;\n}\n```", "```cpp\n$ clang++ -fsanitize=memory -fno-omit-frame-pointer -g -O2 –o test test.cpp\n```", "```cpp\n==20932==WARNING: MemorySanitizer: use-of-uninitialized-value\n    #0 0x5b9fa2bed38f in main test.cpp:6:41\n    #3 0x5b9fa2b53324 in _start (test+0x32324) (BuildId: c0a0d31f01272c3ed59d4ac66b8700e9f457629f)\nSUMMARY: MemorySanitizer: use-of-uninitialized-value test.cpp:6:41 in main\n```", "```cpp\n#include <gtest/gtest.h>\n#include <chrono>\n#include <future>\nusing namespace std::chrono_literals;\nint asyncFunc() {\n    std::this_thread::sleep_for(100ms);\n    return 42;\n}\nTEST(AsyncTests, TestHandleAsyncOperation) {\n    std::future<int> result = std::async(\n                         std::launch::async,\n                         asyncFunc);\n    EXPECT_EQ(result.get(), 42);\n}\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```", "```cpp\n#include <gtest/gtest.h>\n#include <chrono>\n#include <future>\nusing namespace std::chrono;\nusing namespace std::chrono_literals;\nint asyncFunc() {\n    std::this_thread::sleep_for(100ms);\n    return 42;\n}\nTEST(AsyncTest, TestTimeOut) {\n    auto start = steady_clock::now();\n    std::future<int> result = std::async(\n                         std::launch::async,\n                         asyncFunc);\n    if (result.wait_for(200ms) ==\n               std::future_status::timeout) {\n        FAIL() << \"Test timed out!\";\n    }\n    EXPECT_EQ(result.get(), 42);\n    auto end = steady_clock::now();\n    auto elapsed = duration_cast<milliseconds>(\n                                end - start);\n    EXPECT_LT(elapsed.count(), 200);\n}\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```", "```cpp\n#include <gtest/gtest.h>\n#include <chrono>\n#include <functional>\n#include <iostream>\n#include <thread>\nusing namespace std::chrono_literals;\nvoid asyncFunc(std::function<void(int)> callback) {\n    std::thread([callback]() {\n        std::this_thread::sleep_for(1s);\n        callback(42);\n    }).detach();\n}\nTEST(AsyncTest, TestCallback) {\n    int result = 0;\n    bool callback_called = false;\n    auto callback = [&](int value) {\n        callback_called = true;\n        result = value;\n    };\n    asyncFunc(callback);\n    std::this_thread::sleep_for(2s);\n    EXPECT_TRUE(callback_called);\n    EXPECT_EQ(result, 42);\n}\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```", "```cpp\n#include <gtest/gtest.h>\n#include <boost/asio.hpp>\n#include <chrono>\n#include <thread>\nusing namespace std::chrono_literals;\nvoid asyncFunc(boost::asio::io_context& io_context,\n               std::function<void(int)> callback) {\n    io_context.post([callback]() {\n        std::this_thread::sleep_for(100ms);\n        callback(42);\n    });\n}\nTEST(AsyncTest, BoostAsio) {\n    boost::asio::io_context io_context;\n    int result = 0;\n    asyncFunc(io_context, [&result](int value) {\n        result = value;\n    });\n    std::jthread io_thread([&io_context]() {\n        io_context.run();\n    });\n    std::this_thread::sleep_for(150ms);\n    EXPECT_EQ(result, 42);\n}\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```", "```cpp\n#include <gtest/gtest.h>\n#include <functional>\nclass AsyncTaskScheduler {\n   public:\n    virtual int runTask(std::function<int()> task) = 0;\n};\nclass MockTaskScheduler : public AsyncTaskScheduler {\n   public:\n    int runTask(std::function<int()> task) override {\n        return task();\n    }\n};\nTEST(AsyncTests, TestDependencyInjection) {\n    MockTaskScheduler scheduler;\n    auto task = []() -> int {\n        return 42;\n    };\n    int result = scheduler.runTask(task);\n    EXPECT_EQ(result, 42);\n}\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```", "```cpp\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n#include <functional>\nclass AsyncTaskScheduler {\n   public:\n    virtual int runTask(std::function<int()> task) = 0;\n};\nclass MockTaskScheduler : public AsyncTaskScheduler {\n   public:\n    MOCK_METHOD(int, runTask, (std::function<int()> task), (override));\n};\nTEST(AsyncTests, TestDependencyInjection) {\n    using namespace testing;\n    MockTaskScheduler scheduler;\n    auto task = []() -> int {\n        return 42;\n    };\n    EXPECT_CALL(scheduler, runTask(_)).WillOnce(\n        Invoke(task)\n    );\n    auto result = scheduler.runTask(task);\n    EXPECT_EQ(result, 42);\n}\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```", "```cpp\n#include <gtest/gtest.h>\n#include <chrono>\n#include <future>\n#include <iostream>\n#include <stdexcept>\nusing namespace std::chrono_literals;\nint asyncFunc(bool should_fail) {\n    std::this_thread::sleep_for(100ms);\n    if (should_fail) {\n        throw std::runtime_error(\"Simulated failure\");\n    }\n    return 42;\n}\nTEST(AsyncTest, TestAsyncFailure1) {\n    try {\n        std::future<int> result = std::async(\n                             std::launch::async,\n                             asyncFunc, true);\n        result.get();\n        FAIL() << \"No expected exception thrown\";\n    } catch (const std::exception& e) {\n        SUCCEED();\n    }\n}\nTEST(AsyncTest, TestAsyncFailure2) {\n    std::future<int> result = std::async(\n                         std::launch::async,\n                         asyncFunc, true);\n    EXPECT_ANY_THROW(result.get());\n}\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```", "```cpp\n#include <gtest/gtest.h>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <iostream>\n#include <mutex>\n#include <syncstream>\n#include <thread>\n#include <vector>\nusing namespace std::chrono_literals;\n#define sync_cout std::osyncstream(std::cout)\nstd::condition_variable cv;\nstd::mutex mtx;\nbool ready = false;\nstd::atomic<unsigned> counter = 0;\nconst std::size_t num_threads = 5;\n```", "```cpp\nvoid asyncTask(int id) {\n    sync_cout << \"Thread \" << id << \": Starting work...\"\n              << std::endl;\n    std::this_thread::sleep_for(100ms);\n    sync_cout << \"Thread \" << id << \": Work finished.\"\n              << std::endl;\n    ++counter;\n    cv.notify_one();\n}\n```", "```cpp\nTEST(AsyncTest, TestMultipleThreads) {\n    std::vector<std::jthread> threads;\n    for (int i = 0; i < num_threads; ++i) {\n        threads.emplace_back(asyncTask, i + 1);\n    }\n    {\n        std::unique_lock<std::mutex> lock(mtx);\n        cv.wait_for(lock, 150ms, [] {\n            return counter == num_threads;\n        });\n        sync_cout << \"All threads have finished.\"\n                  << std::endl;\n    }\n    EXPECT_EQ(counter, num_threads);\n}\n```", "```cpp\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```", "```cpp\n#include <gtest/gtest.h>\n#include <coroutine>\n#include <exception>\n#include <iostream>\nstruct Task {\n    struct promise_type;\n    using handle_type =\n              std::coroutine_handle<promise_type>;\n    handle_type handle_;\n    Task(handle_type h) : handle_(h) {}\n    ~Task() {\n        if (handle_) handle_.destroy();\n    }\n    // struct promise_type definition\n    // and await methods\n};\n```", "```cpp\nstruct Task {\n    // ...\n    struct promise_type {\n        int result_;\n        std::exception_ptr exception_;\n        Task get_return_object() {\n            return Task(handle_type::from_promise(*this));\n        }\n        std::suspend_always initial_suspend() {\n            return {};\n        }\n        std::suspend_always final_suspend() noexcept {\n            return {};\n        }\n        void return_value(int value) {\n            result_ = value;\n        }\n        void unhandled_exception() {\n            exception_ = std::current_exception();\n        }\n    };\n    // ....\n};\n```", "```cpp\nstruct Task {\n    // ...\n    bool await_ready() const noexcept {\n        return handle_.done();\n    }\n    void await_suspend(std::coroutine_handle<>\n                           awaiting_handle) {\n        handle_.resume();\n        awaiting_handle.resume();\n    }\n    int await_resume() {\n        if (handle_.promise().exception_) {\n            std::rethrow_exception(\n                handle_.promise().exception_);\n        }\n        return handle_.promise().result_;\n    }\n    int result() {\n        if (handle_.promise().exception_) {\n            std::rethrow_exception(\n                    handle_.promise().exception_);\n        }\n        return handle_.promise().result_;\n    }\n    // ....\n};\n```", "```cpp\nTask asyncFunc(int x) {\n    co_return 2 * x;\n}\nTask asyncFuncWithException() {\n    throw std::runtime_error(\"Exception from coroutine\");\n    co_return 0;\n}\n```", "```cpp\nTask testCoroutineHelper(int value) {\n    co_return co_await asyncFunc(value);\n}\nTask testCoroutineWithExceptionHelper() {\n    co_return co_await asyncFuncWithException();\n}\n```", "```cpp\nTEST(AsyncTest, TestCoroutine) {\n    auto task = testCoroutineHelper(5);\n    task.handle_.resume();\n    EXPECT_EQ(task.result(), 10);\n}\nTEST(AsyncTest, TestCoroutineWithException) {\n    auto task = testCoroutineWithExceptionHelper();\n    EXPECT_THROW({\n            task.handle_.resume();\n            task.result();\n        },\n        std::runtime_error);\n}\nint main(int argc, char **argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```", "```cpp\n#include <gtest/gtest.h>\n#include <atomic>\n#include <chrono>\n#include <iostream>\n#include <thread>\n#include <vector>\nstd::atomic<int> counter(0);\nconst std::size_t total_runs = 100;\nvoid asyncIncrement() {\n    std::this_thread::sleep_for(std::chrono::milliseconds(rand() % 100));\n    counter.fetch_add(1);\n}\nTEST(AsyncTest, StressTest) {\n    std::vector<std::thread> threads;\n    for (std::size_t i = 0; i < total_runs; ++i) {\n        threads.emplace_back(asyncIncrement);\n    }\n    for (auto& thread : threads) {\n        thread.join();\n    }\n    EXPECT_EQ(counter, total_runs);\n}\nint main(int argc, char** argv) {\n    ::testing::InitGoogleTest(&argc, argv);\n    return RUN_ALL_TESTS();\n}\n```", "```cpp\n$ ctest –j <num_jobs>\n```"]