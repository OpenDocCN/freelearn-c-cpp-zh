["```cpp\n// Example 01\ntemplate <typename T>\n  T* p_;\n  class SmartPtr {\n  public:\n  explicit SmartPtr(T* p = nullptr) : p_(p) {}\n  ~SmartPtr() {\n    delete p_;\n  }\n  T* operator->() { return p_; }\n  const T* operator->() const { return p_; }\n  T& operator*() { return *p_; }\n  const T& operator*() const { return *p_; }\n  SmartPtr(const SmartPtr&) = delete;\n  SmartPtr& operator=(const SmartPtr&) = delete;\n  SmartPtr(SmartPtr&& that) :\n    p_(std::exchange(that.p_, nullptr)) {}\n  SmartPtr& operator=(SmartPtr&& that) {\n    delete p_;\n    p_ = std::exchange(that.p_, nullptr);\n  }\n};\n```", "```cpp\n// Example 01\nClass C { ... };\n{\n  SmartPtr<C> p(new C);\n  ... use p ...\n} // Object *p is deleted automatically\n```", "```cpp\n// Example 02\ntemplate <typename T, typename DeletionPolicy>\nclass SmartPtr {\n  T* p_;\n  DeletionPolicy deletion_policy_;\n  public:\n  explicit SmartPtr(\n    T* p = nullptr,\n    const DeletionPolicy& del_policy = DeletionPolicy()) :\n    p_(p), deletion_policy_(del_policy)\n  {}\n  ~SmartPtr() {\n    deletion_policy_(p_);\n  }\n  T* operator->() { return p_; }\n  const T* operator->() const { return p_; }\n  T& operator*() { return *p_; }\n  const T& operator*() const { return *p_; }\n  SmartPtr(const SmartPtr&) = delete;\n  SmartPtr& operator=(const SmartPtr&) = delete;\n  SmartPtr(SmartPtr&& that) :\n    p_(std::exchange(that.p_, nullptr)),\n    deletion_policy_(std::move(deletion_policy_))\n {}\n  SmartPtr& operator=(SmartPtr&& that) {\n    deletion_policy_(p_);\n    p_ = std::exchange(that.p_, nullptr);\n    deletion_policy_ = std::move(deletion_policy_);\n  }\n};\n```", "```cpp\n// Example 02\ntemplate <typename T>\nstruct DeleteByOperator {\n  void operator()(T* p) const {\n    delete p;\n  }\n};\n```", "```cpp\nclass C { ... };\nSmartPtr<C, DeleteByOperator<C>> p(new C(42));\n```", "```cpp\nclass C { ... };\nSmartPtr p(new C(42));\n```", "```cpp\n// Example 03\ntemplate <typename T, typename F> concept Callable1 =\n  requires(F f, T* p) { { f(p) } -> std::same_as<void>; };\ntemplate <typename T, typename DeletionPolicy>\nrequires Callable1<T, DeletionPolicy>\nclass SmartPtr {\n  ...\n};\n```", "```cpp\n// Example 04\ntemplate <typename T, typename DeletionPolicy>\nrequires Callable1<T, DeletionPolicy>\nclass SmartPtr {\n  ...\n  static_assert(std::is_same<\n    void, decltype(deletion_policy_(p_))>::value, \"\");\n};\n```", "```cpp\n// Example 02\ntemplate <typename T> struct DeleteHeap {\n  explicit DeleteHeap(Heap& heap) : heap_(heap) {}\n  void operator()(T* p) const {\n    p->~T();\n    heap_.deallocate(p);\n  }\n  private:\n  Heap& heap_;\n};\n```", "```cpp\n// Example 02\ntemplate <typename T> struct DeleteDestructorOnly {\n  void operator()(T* p) const {\n    p->~T();\n  }\n};\n```", "```cpp\n// Example 02\nusing delete_int_t = void (*)(int*);\nvoid delete_int(int* p) { delete p; }\nSmartPtr<int, delete_int_t> p(new int(42), delete_int);\n```", "```cpp\ntemplate <typename T> void delete_T(T* p) { delete p; }\nSmartPtr<int, delete_int_t> p(new int(42), delete_T<int>);\n```", "```cpp\n// Example 02\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>>\nclass SmartPtr {\n  ...\n};\n```", "```cpp\nSmartPtr<C> p(new C(42));\n```", "```cpp\nexplicit SmartPtr(T* p = nullptr,\n  const DeletionPolicy& del_policy = DeletionPolicy());\n```", "```cpp\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>>\nclass SmartPtr {\n  T* p_;\n  DeletionPolicy deletion_policy_;\n  ...\n};\n```", "```cpp\n// Example 05\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>>\nclass SmartPtr {\n  T* p_;\n  const DeletionPolicy& deletion_policy_;\n  ...\n};\n```", "```cpp\nHeap h;\nDeleteHeap<C> del_h(h);\nSmartPtr<C, DeleteHeap<C>> p(new (&heap) C, del_h);\n```", "```cpp\nSmartPtr<C> p(new C, DeleteByOperator<C>());\n```", "```cpp\n{\n  const C& c = C();\n  ... c is not dangling! ...\n} // the temporary is deleted here\n```", "```cpp\n// Example 06\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>>\nclass SmartPtr {\n  T* p_;\n  DeletionPolicy deletion_policy_;\n  public:\n  explicit SmartPtr(T* p = nullptr,\n      DeletionPolicy&& del_policy = DeletionPolicy())\n    : p_(p), deletion_policy_(std::move(del_policy))\n  {}\n  ...\n};\n```", "```cpp\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>>\nclass SmartPtr { ... };\n```", "```cpp\nclass C { ... };\nSmartPtr<C, DeleteByOperator<C>> p(\n  new C(42), DeleteByOperator<C>());\n```", "```cpp\nSmartPtr p(new C, DeleteByOperator<C>());\n```", "```cpp\n// Example 07\nstruct DeleteByOperator {\n  template <typename T> void operator()(T* p) const {\n    delete p;\n  }\n};\n```", "```cpp\n// Example 07\nSmartPtr<C, DeleteByOperator> p(\n  new C, DeleteByOperator());             // Before C++17\nSmartPtr p(new C, DeleteByOperator());     // C++17\n```", "```cpp\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator>\nclass SmartPtr { ... };\n```", "```cpp\nstruct DeleteHeap {\n  explicit DeleteHeap(SmallHeap& heap) : heap_(heap) {}\n  template <typename T> void operator()(T* p) const {\n    p->~T();\n    heap_.deallocate(p);\n  }\n  private:\n  Heap& heap_;\n};\n```", "```cpp\n// Example 08\ntemplate <typename T,\n          template <typename> class DeletionPolicy =\n                                    DeleteByOperator>\nclass SmartPtr {\n  public:\n  explicit SmartPtr(T* p = nullptr,\n    const DeletionPolicy<T>& del_policy =\n                             DeletionPolicy<T>())\n  : p_(p), deletion_policy_(deletion_policy)\n  {}\n  ~SmartPtr() {\n    deletion_policy_(p_);\n  }\n  ...\n};\n```", "```cpp\nSmartPtr<C, DeleteByOperator> p(\n  new C, DeleteByOperator<C>());\n```", "```cpp\nSmartPtr p(new C, DeleteByOperator<C>());\n```", "```cpp\ntemplate <typename T, typename Heap = MyHeap> class DeleteHeap { ... };\n```", "```cpp\n// Example 09\ntemplate <typename T,\n          template <typename...> class DeletionPolicy =\n                                    DeleteByOperator>\nclass SmartPtr {\n  ...\n};\n```", "```cpp\ntemplate <typename T> struct DeleteByOperator {\n  void operator()(T* p) const {\n    delete p;\n  }\n};\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>>\nclass SmartPtr {\n  T* p_;\n  DeletionPolicy deletion_policy_;\n  ...\n};\n```", "```cpp\nDeleteByOperator<int> d1;     // &d1 = ....\nDeleteByOperator<long> d2; // &d2 must be != &d1\n```", "```cpp\n// Example 10\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>>\nclass SmartPtr : private DeletionPolicy {\n  T* p_;\n  public:\n  explicit SmartPtr(T* p = nullptr,\n    DeletionPolicy&& deletion_policy = DeletionPolicy())\n  : DeletionPolicy(std::move(deletion_policy)), p_(p)\n  {}\n  ~SmartPtr() {\n    DeletionPolicy::operator()(p_);\n  }\n  ...\n};\n```", "```cpp\ntemplate <typename T,\n          typename DeletionPolicy>\nclass SmartPtr : private DeletionPolicy {\n  T* p_;\n  public:\n  ~SmartPtr() {\n    if (p) DeletionPolicy::operator()(p_);\n  }\n  void release() { p_ = nullptr; }\n  ...\n};\n```", "```cpp\n// Example 11\ntemplate <typename T> struct WithRelease {\n  void release(T*& p) { p = nullptr; }\n};\n```", "```cpp\ntemplate <typename T,\n          typename DeletionPolicy,\n          typename ReleasePolicy>\nclass SmartPtr : private DeletionPolicy,\n                 public ReleasePolicy {\n  ...\n};\n```", "```cpp\n// Example 11\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>,\n          template <typename...> class ReleasePolicy =\n                                       WithRelease>\nclass SmartPtr : private DeletionPolicy,\n                 public ReleasePolicy<SmartPtr<T,\n                          DeletionPolicy, ReleasePolicy>>\n{ ... };\n```", "```cpp\n// Example 11\ntemplate <typename P> struct WithRelease {\n  void release() { static_cast<P*>(this)->p_ = nullptr; }\n};\n```", "```cpp\n// Example 11\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>,\n          template <typename...> class ReleasePolicy =\n                                       WithRelease>\nclass SmartPtr : private DeletionPolicy,\n  public ReleasePolicy<SmartPtr<T, DeletionPolicy,\n                                   ReleasePolicy>>\n{\n  friend class ReleasePolicy<SmartPtr>;\n  T* p_;\n  ...\n};\n```", "```cpp\n// Example 11\ntemplate <typename P> struct NoRelease {};\n```", "```cpp\n// Example 12\ntemplate <typename T,\n          typename DeletionPolicy,\n          typename DebugPolicy = NoDebug>\nclass SmartPtr : private DeletionPolicy {\n  T* p_;\n  public:\n  explicit SmartPtr(T* p = nullptr,\n    DeletionPolicy&& deletion_policy = DeletionPolicy())\n  : DeletionPolicy(std::move(deletion_policy)), p_(p) {\n    DebugPolicy::constructed(p_);\n  }\n  ~SmartPtr() {\n    DebugPolicy::deleted(p_);\n    DeletionPolicy::operator()(p_);\n  }\n  ...\n};\n```", "```cpp\n// Example 12\nstruct Debug {\n  template <typename T>\n  static void constructed(const T* p) {\n    std::cout << \"Constructed SmartPtr for object \" <<\n      static_cast<const void*>(p) << std::endl;\n  }\n  template <typename T>\n  static void deleted(const T* p) {\n    std::cout << \"Destroyed SmartPtr for object \" <<\n      static_cast<const void*>(p) << std::endl;\n  }\n};\n```", "```cpp\n// Example 12\nstruct NoDebug {\n  template <typename T>\n    static void constructed(const T* p) {}\n  template <typename T> static void deleted(const T* p) {}\n};\n```", "```cpp\nSmartPtr<C> p1(new C);\nSmartPtr<C> p2(&*p1); // Now two pointers own one object\np1.release();\n```", "```cpp\nSmartPtr<C> p1(new C);\nSmartPtr<C> p2(std::move(p1));\n```", "```cpp\ntemplate <typename T,\n  typename DeletionPolicy = DeleteByOperator<T>,\n  typename MovePolicy = MoveForbidden\n>\nclass SmartPtr ...;\n```", "```cpp\n// Example 13\ntemplate <typename T,\n  typename DeletionPolicy = DeleteByOperator<T>,\n  typename MovePolicy = MoveForbidden>\nclass SmartPtr : private DeletionPolicy,\n                 private MovePolicy {\n  T* p_;\n  public:\n  explicit SmartPtr(T* p = nullptr,\n    DeletionPolicy&& deletion_policy = DeletionPolicy())\n    : DeletionPolicy(std::move(deletion_policy)),\n      MovePolicy(), p_(p) {}\n  … SmartPtr code unchanged …\n  SmartPtr(SmartPtr&& that) :\n    DeletionPolicy(std::move(that)),\n    MovePolicy(std::move(that)),\n    p_(std::exchange(that.p_, nullptr)) {}\n  SmartPtr(const SmartPtr&) = delete;\n};\n```", "```cpp\n// Example 13\nstruct MoveForbidden {\n  MoveForbidden() = default;\n  MoveForbidden(MoveForbidden&&) = delete;\n  MoveForbidden(const MoveForbidden&) = delete;\n  MoveForbidden& operator=(MoveForbidden&&) = delete;\n  MoveForbidden& operator=(const MoveForbidden&) = delete;\n};\n```", "```cpp\n// Example 13\nstruct MoveAllowed {\n};\n```", "```cpp\nclass C { ... };\nSmartPtr<C, DeleteByOperator<C>, MoveAllowed> p = ...;\nauto p1(std::move(p)); // OK\nSmartPtr<C, DeleteByOperator<C>, MoveForbidden> q = ...;\nauto q1(std::move(q)); // Does not compile\n```", "```cpp\n// Example 13\ntemplate <typename T,\n  typename DeletionPolicy = DeleteByOperator<T>,\n  typename MovePolicy = MoveForbidden>\nclass SmartPtr : private DeletionPolicy,\n                 private MovePolicy {\n  T* p_;\n  public:\n  explicit SmartPtr(T* p = nullptr,\n    DeletionPolicy&& deletion_policy = DeletionPolicy())\n    : DeletionPolicy(std::move(deletion_policy)),\n      MovePolicy(), p_(p) {}\n  … SmartPtr code unchanged …\n  SmartPtr& operator=(SmartPtr&& that) {\n    if (this == &that) return *this;\n    DeletionPolicy::operator()(p_);\n    p_ = std::exchange(that.p_, nullptr);\n    DeletionPolicy::operator=(std::move(that));\n    MovePolicy::operator=(std::move(that));\n    return *this;\n  }\n  SmartPtr& operator=(const SmartPtr&) = delete;\n};\n```", "```cpp\n// Example 14\ntemplate <typename T,\n  typename DeletionPolicy = DeleteByOperator<T>,\n  typename CopyMovePolicy = NoMoveNoCopy\n>\nclass SmartPtr : private DeletionPolicy,\n                 public CopyMovePolicy {\n  T* p_;\n  public:\n  explicit SmartPtr(T* p = nullptr,\n    DeletionPolicy&& deletion_policy = DeletionPolicy())\n    : DeletionPolicy(std::move(deletion_policy)), p_(p)\n  {}\n  SmartPtr(SmartPtr&& other) :\n    DeletionPolicy(std::move(other)),\n    CopyMovePolicy(std::move(other)),\n    p_(std::exchange(that.p_, nullptr)) {}\n  SmartPtr(const SmartPtr& other) :\n    DeletionPolicy(other),\n    CopyMovePolicy(other),\n    p_(other.p_) {}\n  ~SmartPtr() {\n    if (CopyMovePolicy::must_delete())\n      DeletionPolicy::operator()(p_);\n  }\n};\n```", "```cpp\n// Example 14\nclass NoMoveNoCopy {\n  protected:\n  NoMoveNoCopy() = default;\n  NoMoveNoCopy(NoMoveNoCopy&&) = delete;\n  NoMoveNoCopy(const NoMoveNoCopy&) = delete;\n  NoMoveNoCopy& operator=(NoMoveNoCopy&&) = delete;\n  NoMoveNoCopy& operator=(const NoMoveNoCopy&) = delete;\n  constexpr bool must_delete() const { return true; }\n};\n```", "```cpp\n// Example 14\nclass MoveNoCopy {\n  protected:\n  MoveNoCopy() = default;\n  MoveNoCopy(MoveNoCopy&&) = default;\n  MoveNoCopy(const MoveNoCopy&) = delete;\n  MoveNoCopy& operator=(MoveNoCopy&&) = default;\n  MoveNoCopy& operator=(const MoveNoCopy&) = delete;\n  constexpr bool must_delete() const { return true; }\n};\n```", "```cpp\n// Example 14\nclass NoMoveCopyRefCounted {\n  size_t* count_;\n  protected:\n  NoMoveCopyRefCounted() : count_(new size_t(1)) {}\n  NoMoveCopyRefCounted(const NoMoveCopyRefCounted& other) :\n    count_(other.count_)\n  {\n    ++(*count_);\n  }\n  NoMoveCopyRefCounted(NoMoveCopyRefCounted&&) = delete;\n  ~NoMoveCopyRefCounted() {\n    --(*count_);\n    if (*count_ == 0) {\n      delete count_;\n    }\n  }\n  bool must_delete() const { return *count_ == 1; }\n};\n```", "```cpp\nSmartPtr<C, DeleteByOperator<C>, NoMoveCopyRefCounted> p1{new C};\nauto p2(p1);\n```", "```cpp\nSmartPtr<C, DeleteByOperator<C>, NoMoveCopyRefCounted> p1{new C};\nauto p2(std::move(p1)); // Does not compile\n```", "```cpp\n// Example 15\nclass MoveCopyRefCounted {\n  size_t* count_;\n  protected:\n  MoveCopyRefCounted() : count_(new size_t(1)) {}\n  MoveCopyRefCounted(const MoveCopyRefCounted& other) :\n    count_(other.count_)\n  {\n    if (count_) ++(*count_);\n  }\n  ~MoveCopyRefCounted() {\n    if (!count_) return;\n    --(*count_);\n    if (*count_ == 0) {\n      delete count_;\n    }\n  }\n  MoveCopyRefCounted(MoveCopyRefCounted&& other) :\n    count_(std::exchange(other.count_, nullptr)) {}\n  bool must_delete() const {\n    return count_ && *count_ == 1;\n  }\n};\n```", "```cpp\n// Test 1: only one pointer\n{\n  SmartPtr<C, ... policies ...> p(new C);\n} // C should be deleted here\n// Test 2: one copy\n{\n  SmartPtr<C, ... policies ...> p(new C);\n  {\n    auto p1(p); // Reference count should be 2\n  } // C should not be deleted here\n} // C should be deleted here\n```", "```cpp\nclass NoMoveCopyRefCounted {\n  protected:\n  size_t* count_;\n  ...\n};\nclass NoMoveCopyRefCountedTest :\n  public NoMoveCopyRefCounted {\n  public:\n  using NoMoveCopyRefCounted::NoMoveCopyRefCounted;\n  size_t count() const { return *count_; }\n};\n```", "```cpp\n// Test 1: only one pointer\n{\n  SmartPtr<C, ... NoMoveCopyRefCountedTest> p(new C);\n  assert(p.count() == 1);\n} // C should be deleted here\n// Test 2: one copy\n{\n  SmartPtr<C, ... NoMoveCopyRefCountedTest> p(new C);\n  {\n  auto p1(p); // Reference count should be 2\n    assert(p.count() == 2);\n    assert(p1.count() == 2);\n    assert(&*p == &*p1);\n  } // C should not be deleted here\n  assert(p.count == 1);\n} // C should be deleted here\n```", "```cpp\n// Example 16:\ntemplate <... template parameters ...,\n          typename DebugPolicy = NoDebug>\nclass SmartPtr : ... base policies ... {\n  T* p_;\n  public:\n  explicit SmartPtr(T* p = nullptr,\n    DeletionPolicy&& deletion_policy = DeletionPolicy()) :\n    DeletionPolicy(std::move(deletion_policy)), p_(p)\n  {\n    DebugPolicy::construct(this, p);\n  }\n  ~SmartPtr() {\n    DebugPolicy::destroy(this, p_,\n                         CopyMovePolicy::must_delete());\n  if (CopyMovePolicy::must_delete())\n    DeletionPolicy::operator()(p_);\n  }\n  ...\n};\n```", "```cpp\n// Example 16\nstruct NoDebug {\n  template <typename P, typename T>\n  static void construct(const P* ptr, const T* p) {}\n  template <typename P, typename T>\n  static void destroy(const P* ptr, const T* p,\n                      bool must_delete) {}\n  ... other events ...\n};\n```", "```cpp\n// Example 16\nstruct Debug {\n  template <typename P, typename T>\n  static void construct(const P* ptr, const T* p) {\n    std::cout << \"Constructed SmartPtr at \" << ptr <<\n      \", object \" << static_cast<const void*>(p) <<\n      std::endl;\n  }\n  template <typename P, typename T>\n  static void destroy(const P* ptr, const T* p,\n                      bool must_delete) {\n    std::cout << \"Destroyed SmartPtr at \" << ptr <<\n      \", object \" << static_cast<const void*>(p) <<\n      (must_delete ? \" is\" : \" is not\") << \" deleted\" <<\n      std::endl;\n  }\n};\n```", "```cpp\nSmartPtr<C, DeleteByOperator<T>, MoveNoCopy,\n         WithRelease, Debug> p( ... );\n```", "```cpp\nSmartPtr<C, DeleteByOperator<T>, MoveNoCopy,\n         WithRelease, NoDebug>\np( ... );\n```", "```cpp\nSmartPtr<C> p( ... );\n```", "```cpp\nSmartPtr<C, DeleteHeap<T>> p( ... );\n```", "```cpp\n// Example 17\ntemplate <typename T, typename DebugPolicy = NoDebug>\nusing SmartPtrAdapter =\n  SmartPtr<T, DeleteByOperator<T>, MoveNoCopy,\n              WithRelease, DebugPolicy>;\n```", "```cpp\n// Example 18\ntemplate <typename T, typename DebugPolicy = NoDebug>\nclass SmartPtrAdapter : public SmartPtr<T,\n  DeleteByOperator<T>, MoveNoCopy,\n  WithRelease, DebugPolicy>\n{...};\n```", "```cpp\n// Example 18\ntemplate <typename T, typename DebugPolicy = NoDebug>\nclass SmartPtrAdapter : public SmartPtr<T,\n  DeleteByOperator<T>, MoveNoCopy,\n  WithRelease, DebugPolicy>\n{\n  using base_t = SmartPtr<T, DeleteByOperator<T>,\n    MoveNoCopy, WithRelease, DebugPolicy>;\n  using base_t::SmartPtr;\n  using base_t::operator=;\n};\n```", "```cpp\nSmartPtrAdapter<C, Debug> p1{new C); // Debug pointer\nSmartPtrAdapter<C> p2{new C); // Non-debug pointer\n```", "```cpp\n// Example 19\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>,\n          typename ReleasePolicy = NoRelease>\nclass SmartPtr : private DeletionPolicy {\n  T* p_;\n  public:\n  void release() { p_ = nullptr; }\n  ...\n};\n```", "```cpp\n// Example 19\nstruct WithRelease {\n  static constexpr bool enabled = true;\n};\nstruct NoRelease {\n  static constexpr bool enabled = false;\n};\n```", "```cpp\n// Example 19\ntemplate <...> class SmartPtr ... {\n  ...\n  void release() requires ReleasePolicy::enabled {\n    p_ = nullptr;\n  }\n};\n```", "```cpp\ntemplate <...> class SmartPtr ... {\n  ...\n  std::enable_if_t<ReleasePolicy::enabled> release() {\n    p_ = nullptr;\n  }\n};\n```", "```cpp\n// Example 20\ntemplate <...> class SmartPtr ... {\n  ...\n  template<typename U = T>\n  std::enable_if_t<sizeof(U) != 0 &&\n                   ReleasePolicy::enabled> release() {\n    p_ = nullptr;\n  }\n};\n```", "```cpp\n// Example 21\nstruct MoveForbidden {\n  static constexpr bool enabled = false;\n};\nstruct MoveAllowed {\n  static constexpr bool enabled = true;\n};\n```", "```cpp\n// Example 21\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>,\n          typename MovePolicy = MoveForbidden>\nclass SmartPtr : private DeletionPolicy {\n  public:\n  SmartPtr(SmartPtr&& other)\n    requires MovePolicy::enabled :\n    DeletionPolicy(std::move(other)),\n    p_(std::exchange(other.p_, nullptr)) {}\n  ...\n};\n```", "```cpp\n// Example 22\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>,\n          typename MovePolicy = MoveForbidden>\nclass SmartPtr : private DeletionPolicy {\n  public:\n  template <typename U = T,\n    std::enable_if_t<sizeof(U) != 0 && MovePolicy::enabled,\n                     bool> = true>\n  SmartPtr(SmartPtr&& other) :\n    DeletionPolicy(std::move(other)),\n    p_(std::exchange(other.p_, nullptr)) {}\n  ...\n};\n```", "```cpp\n// Example 22\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>,\n          typename MovePolicy = MoveForbidden>\nclass SmartPtr : private DeletionPolicy {\n  public:\n  template <typename U = T,\n    REQUIRES(sizeof(U) != 0 && MovePolicy::enabled)>\n  SmartPtr(SmartPtr&& other) :\n    DeletionPolicy(std::move(other)),\n    p_(std::exchange(other.p_, nullptr)) {}\n  ...\n};\n```", "```cpp\nvoid f(C*);\nSmartPtr<C> p(...);\nf((C*)(p));     // Explicit conversion\nf(p);         // Implicit conversion\n```", "```cpp\ntemplate <typename T, ...>\nclass SmartPtr ... {\n  T* p_;\n  public:\n  explicit operator T*() { return p_; } // Explicit\n  operator T*() { return p_; }          // Implicit\n  ...\n};\n```", "```cpp\n// Example 23\nstruct NoRaw {\n  static constexpr bool implicit_conv = false;\n  static constexpr bool explicit_conv = false;\n};\nstruct ExplicitRaw {\n  static constexpr bool implicit_conv = false;\n  static constexpr bool explicit_conv = true;\n};\nstruct ImplicitRaw {\n  static constexpr bool implicit_conv = true;\n  static constexpr bool explicit_conv = false;\n};\n```", "```cpp\n// Example 23\ntemplate <typename T, ..., typename ConversionPolicy>\nclass SmartPtr : ... {\n  T* p_;\n  public:\n  explicit operator T*()\n    requires ConversionPolicy::explicit_conv\n    { return p_; }\n  operator T*()\n    requires ConversionPolicy::implicit_conv\n    { return p_; }\n  explicit operator const T*()\n    requires ConversionPolicy::explicit_conv const\n    { return p_; }\n  operator const T*()\n    requires ConversionPolicy::implicit_conv const\n    { return p_; }\n};\n```", "```cpp\n// Example 24\ntemplate <typename T, ..., typename ConversionPolicy>\nclass SmartPtr : ... {\n  T* p_;\n  public:\n  explicit (ConversionPolicy::explicit_conv)\n  operator T*()\n    requires (ConversionPolicy::explicit_conv ||\n              ConversionPolicy::implicit_conv)\n    { return p_; }\n  explicit (ConversionPolicy::explicit_conv)\n  operator const T*()\n    requires (ConversionPolicy::explicit_conv const ||\n              ConversionPolicy::implicit_conv const)\n    { return p_; }\n};\n```", "```cpp\n// Example 25 – does not compile!\ntemplate <typename T, ..., typename ConversionPolicy>\nclass SmartPtr : ... {\n  T* p_;\n  public:\n  template <typename U = T,\n            REQUIRES(ConversionPolicy::explicit_conv)>\n  explicit operator T*() { return p_; }\n  template <typename U = T,\n            REQUIRES(ConversionPolicy::implicit_conv)>\n  operator T*() { return p_; }\n  ...\n};\n```", "```cpp\n// Example 26\ntemplate <typename P, typename T> struct NoRaw {\n};\ntemplate <typename P, typename T> struct ExplicitRaw {\n  explicit operator T*() {\n    return static_cast<P*>(this)->p_;\n  }\n  explicit operator const T*() const {\n    return static_cast<const P*>(this)->p_;\n  }\n};\ntemplate <typename P, typename T> struct ImplicitRaw {\n  operator T*() {\n    return static_cast<P*>(this)->p_;\n  }\n  operator const T*() const {\n    return static_cast<const P*>(this)->p_;\n  }\n};\n```", "```cpp\n// Example 26\ntemplate <typename T, ... other policies ...\n          template <typename, typename>\n          class ConversionPolicy = ExplicitRaw>\nclass SmartPtr : ... other base policies ...,\n  public ConversionPolicy<SmartPtr<... paramerers ...>, T>\n{\n  T* p_;\n  template<typename, typename>\n  friend class ConversionPolicy;\n  public:\n  ...\n};\n```", "```cpp\nfriend class ConversionPolicy<\n  SmartPtr<T, ... parameters ..., ConversionPolicy>, T>;\n```", "```cpp\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>,\n          typename CopyMovePolicy = NoMoveNoCopy,\n          template <typename, typename>\n            class ConversionPolicy = ExplicitRaw>\nclass SmartPtr : ... base policies ... {\n  T* p_;\n  public:\n  using value_type = T;\n  using deletion_policy_t = DeletionPolicy;\n  using copy_move_policy_t = CopyMovePolicy;\n  template <typename P, typename T1>\n  using conversion_policy_t = ConversionPolicy<P, T1>;\n  ...\n};\n```", "```cpp\n// Example 27\nSmartPtr<int,\n  DeleteByOperator<int>, MoveNoCopy, ImplicitRaw>\n  p1(new int(42));\nusing ptr_t = decltype(p1); // The exact type of p1\nSmartPtr<ptr_t::value_type,\n  ptr_t::deletion_policy_t, ptr_t::copy_move_policy_t,\n  ptr_t::conversion_policy_t> p2;\nSmartPtr<double,\n  ptr_t::deletion_policy_t, ptr_t::copy_move_policy_t,\n  ptr_t::conversion_policy_t> p3;\n```", "```cpp\n// Example 27\ntemplate <typename T> struct DeleteByOperator {\n  void operator()(T* p) const { delete p; }\n  template <typename U>\n    using rebind_type = DeleteByOperator<U>;\n};\ntemplate <typename T,\n          typename DeletionPolicy = DeleteByOperator<T>,\n          typename CopyMovePolicy = NoMoveNoCopy,\n          template <typename, typename>\n            class ConversionPolicy = ExplicitRaw>\nclass SmartPtr : private DeletionPolicy,\n  public CopyMovePolicy,\n  public ConversionPolicy<SmartPtr<T, DeletionPolicy,\n    CopyMovePolicy, ConversionPolicy>, T> {\n  T* p_;\n  public:\n  ...\n  template <typename U>\n  using rebind = SmartPtr<U,\n    typename DeletionPolicy::template rebind<U>,\n    CopyMovePolicy, ConversionPolicy>;\n};\n```", "```cpp\nSmartPtr<int,\n  DeleteByOperator<int>, MoveNoCopy, ImplicitRaw>\np(new int(42));\nusing dptr_t = decltype(p)::rebind<double>;\ndptr_t q(new double(4.2));\n```", "```cpp\nSmartPtr<int, DeleteByOperator<int>, NoMoveNoCopy, ExplicitRaw, WithoutArrow, NoDebug> p;\n```"]