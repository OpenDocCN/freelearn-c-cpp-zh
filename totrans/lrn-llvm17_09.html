<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer022">&#13;
			<h1 id="_idParaDest-115" class="chapter-number"><a id="_idTextAnchor117"/>7</h1>&#13;
			<h1 id="_idParaDest-116"><a id="_idTextAnchor118"/>Optimizing IR</h1>&#13;
			<p>LLVM uses a series of passes to optimize the IR. A pass operates on a unit of IR, such as a function or a module. The operation can be a transformation, which changes the IR in a defined way, or an analysis, which collects information such as dependencies. This series of passes is called the <strong class="bold">pass pipeline</strong>. The<a id="_idIndexMarker399"/> pass manager executes the pass pipeline on the IR, which our compiler produces. Therefore, you need to know what the pass manager does and how to construct a pass pipeline. The semantics of a programming language may require the development of new passes, and we must add these passes to <span class="No-Break">the pipeline.</span></p>&#13;
			<p>In this chapter, you will learn about <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>How to leverage the LLVM pass manager to implement passes <span class="No-Break">within LLVM</span></li>&#13;
				<li>How to implement an instrumentation pass, as an example, within the LLVM project, as well as a <span class="No-Break">separate plugin</span></li>&#13;
				<li>In using the ppprofiler pass with LLVM tools, you will learn how to use a pass plugin with <strong class="source-inline">opt</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">clang</strong></span></li>&#13;
				<li>In adding an optimization pipeline to your compiler, you will extend the <strong class="source-inline">tinylang</strong> compiler with an optimization pipeline based on the new <span class="No-Break">pass manager</span></li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you will know how to develop a new pass and how you can add it to a pass pipeline. You will also be able to set up the pass pipeline in <span class="No-Break">your compiler.</span></p>&#13;
			<h1 id="_idParaDest-117"><a id="_idTextAnchor119"/>Technical requirements</h1>&#13;
			<p>The source code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter07"><span class="No-Break">https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter07</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-118"><a id="_idTextAnchor120"/>The LLVM pass manager</h1>&#13;
			<p>The LLVM core libraries <a id="_idIndexMarker400"/>optimize the IR that your compiler creates and turn it into object code. This giant task is broken down into separate steps called <strong class="bold">passes</strong>. These<a id="_idIndexMarker401"/> passes need to be executed in the right order, which is the objective of the <span class="No-Break">pass manager.</span></p>&#13;
			<p>Why not hard-code the order of the passes? The user of your compiler usually expects your compiler to provide a different level of optimization. Developers prefer fast compilation speed over optimization during development time. The final application should run as fast as possible, and your compiler should be able to perform sophisticated optimizations, with longer a compilation time being accepted. A different level of optimization means a different number of optimization passes that need to be executed. Thus, as a compiler writer, you may want to provide your own passes to take advantage of your knowledge of your source language. For example, you may want to replace well-known library functions with inlined IR or even with the precomputed result. For C, such a pass is part of the LLVM libraries, but for other languages, you will need to provide it yourself. After introducing your own passes, you may need to re-order or add some passes. For example, if you know that the operation of your pass leaves some IR code unreachable, then you want to run the dead code removal pass additionally after your pass. The pass manager helps organize <span class="No-Break">these requirements.</span></p>&#13;
			<p>A pass is often categorized by the scope on which <span class="No-Break">it works:</span></p>&#13;
			<ul>&#13;
				<li>A <em class="italic">module pass</em> takes <a id="_idIndexMarker402"/>a whole module as input. Such a pass performs its work on the given module and can be used for intra-procedure operations inside <span class="No-Break">this module.</span></li>&#13;
				<li>A <em class="italic">call graph</em> pass <a id="_idIndexMarker403"/>operates on the <strong class="bold">strongly connected components</strong> (<strong class="bold">SCCs</strong>) of a call graph. It traverses the components in <span class="No-Break">bottom-up order.</span></li>&#13;
				<li>A <em class="italic">function pass</em> takes <a id="_idIndexMarker404"/>a single function as input and performs its work on this <span class="No-Break">function only.</span></li>&#13;
				<li>A <em class="italic">loop pass</em> works <a id="_idIndexMarker405"/>on a loop inside <span class="No-Break">a function.</span></li>&#13;
			</ul>&#13;
			<p>Besides the IR code, a pass may also require, update, or invalidate some analysis results. A lot of different analyses are performed, for example, alias analysis or the construction of a dominator tree. If a pass requires such analyses, then it can request it from an analyses manager. If the information is already computed, then the cached result will be returned. Otherwise, the information will be computed. If a pass changes the IR code, then it needs to announce which analysis results are preserved so that the cached analysis information can be invalidated <span class="No-Break">if necessary.</span></p>&#13;
			<p>Under the hood, the <a id="_idIndexMarker406"/>pass manager ensures <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>Analysis results are shared among passes. This requires keeping track of which pass requires which analysis and the state of each analysis. The goal is to avoid needless precomputation of analysis and to free up memory held by analysis results as soon <span class="No-Break">as possible.</span></li>&#13;
				<li>The passes are executed in a pipeline fashion. For example, if several function passes should be executed in sequence, then the pass manager runs each of these function passes on the first function. Then, it will run all function passes on the second function, and so on. The underlying idea here is to improve the cache behavior as the compiler only performs transformations on a limited set of data (one IR function) and then moves on to the next limited set <span class="No-Break">of data.</span></li>&#13;
			</ul>&#13;
			<p>Let’s implement a new IR transformation pass and explore how to add it to the <span class="No-Break">optimization pipeline.</span></p>&#13;
			<h1 id="_idParaDest-119"><a id="_idTextAnchor121"/>Implementing a new pass</h1>&#13;
			<p>A <a id="_idIndexMarker407"/>pass can perform arbitrary complex transformations on the LLVM IR. To illustrate the mechanics of adding a new pass, we add a pass that performs a <span class="No-Break">simple instrumentation.</span></p>&#13;
			<p>To investigate the performance of a program, it is interesting to know how often functions are called, and how long they run. One way to collect this data is to insert counters into each function. This process <a id="_idIndexMarker408"/>is called <strong class="bold">instrumentation</strong>. We will write a simple instrumentation pass that inserts a special function call at the entry of each function and each exit point. These functions collect the timing information and write it into a file. As a result, we can create a very basic profiler that we’ll name the <strong class="bold">poor person’s profiler</strong>, or in short, <strong class="source-inline">ppprofiler</strong>. We will develop the new pass so that it can be used as a standalone plugin or added as a plugin to the LLVM source tree. After that, we’ll look at how the passes that come with LLVM are integrated into <span class="No-Break">the framework.</span></p>&#13;
			<h2 id="_idParaDest-120"><a id="_idTextAnchor122"/>Developing the ppprofiler pass as a plugin</h2>&#13;
			<p>In this<a id="_idIndexMarker409"/> section, we’ll look at creating a new pass as a plugin out of the LLVM tree. The goal of the new pass is to insert a call to the <strong class="source-inline">__ppp_enter()</strong> function at the entry of a function, and a call to the <strong class="source-inline">__ppp_exit()</strong> function before each return instruction. Only the name of the current function is passed as a parameter. The implementation of these functions can then count the number of calls and measure the elapsed time. We will implement this runtime support at the end of this chapter. We’ll examine how to develop <span class="No-Break">the pass.</span></p>&#13;
			<p>We’ll store the source in the <strong class="source-inline">PPProfiler.cpp</strong> file. Follow <span class="No-Break">these steps:</span></p>&#13;
			<ol>&#13;
				<li>First, let’s include <span class="No-Break">some files:</span><pre class="source-code">&#13;
#include "llvm/ADT/Statistic.h"&#13;
#include "llvm/IR/Function.h"&#13;
#include "llvm/IR/PassManager.h"&#13;
#include "llvm/Passes/PassBuilder.h"&#13;
#include "llvm/Passes/PassPlugin.h"&#13;
#include "llvm/Support/Debug.h"</pre></li>				<li>To shorten the source, we’ll tell the compiler that we’re using the <span class="No-Break"><strong class="source-inline">llvm</strong></span><span class="No-Break"> namespace:</span><pre class="source-code">&#13;
using namespace llvm;</pre></li>				<li>The built-in debug infrastructure of LLVM requires that we define a debug type, which is a string. This string is later shown in the <span class="No-Break">printed statistic:</span><pre class="source-code">&#13;
#define DEBUG_TYPE "ppprofiler"</pre></li>				<li>Next, we’ll define one counter variable with the <strong class="source-inline">ALWAYS_ENABLED_STATISTIC</strong> macro. The first parameter is the name of the counter variable, while the second parameter is the text that will be printed in <span class="No-Break">the statistic:</span><pre class="source-code">&#13;
ALWAYS_ENABLED_STATISTIC(&#13;
    NumOfFunc, "Number of instrumented functions.");</pre></li>			</ol>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">Two macros can be used to define a counter variable. If you use the <strong class="source-inline">STATISTIC</strong> macro, then the statistic value will only be collected in a debug build if assertions are enabled, or if <strong class="source-inline">LLVM_FORCE_ENABLE_STATS</strong> is set to <strong class="source-inline">ON</strong> on the CMake command line. If you use the <strong class="source-inline">ALWAYS_ENABLED_STATISTIC</strong> macro instead, then the statistic value is always collected. However, printing the statistics using the<strong class="source-inline">–stats</strong> command-line option only works with the former methods. If needed, you can print the collected statistics by calling the <span class="No-Break"><strong class="source-inline">llvm::PrintStatistics(llvm::raw_ostream)</strong></span><span class="No-Break"> function.</span></p>&#13;
			<ol>&#13;
				<li value="5">Next, we <a id="_idIndexMarker410"/>must declare the pass class in an anonymous namespace. The class inherits from the <strong class="source-inline">PassInfoMixin</strong> template. This template only adds some boilerplate code, such as a <strong class="source-inline">name()</strong> method. It is not used to determine the type of the pass. The <strong class="source-inline">run()</strong> method is called by LLVM when the pass is executed. We also need a helper method <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">instrument()</strong></span><span class="No-Break">:</span><pre class="source-code">&#13;
namespace {&#13;
class PPProfilerIRPass&#13;
    : public llvm::PassInfoMixin&lt;PPProfilerIRPass&gt; {&#13;
public:&#13;
  llvm::PreservedAnalyses&#13;
  run(llvm::Module &amp;M, llvm::ModuleAnalysisManager &amp;AM);&#13;
private:&#13;
  void instrument(llvm::Function &amp;F,&#13;
                  llvm::Function *EnterFn,&#13;
                  llvm::Function *ExitFn);&#13;
};&#13;
}</pre></li>				<li>Now, let’s define<a id="_idIndexMarker411"/> how a function is instrumented. Besides the function to instrument, the functions to call <span class="No-Break">are passed:</span><pre class="source-code">&#13;
void PPProfilerIRPass::instrument(llvm::Function &amp;F,&#13;
                                  Function *EnterFn,&#13;
                                  Function *ExitFn) {</pre></li>				<li>Inside the function, we update the <span class="No-Break">statistic counter:</span><pre class="source-code">&#13;
  ++NumOfFunc;</pre></li>				<li>To easily insert IR code, we need an instance of the <strong class="source-inline">IRBuilder</strong> class. We will set it to the first basic block, which is the entry block of <span class="No-Break">the function:</span><pre class="source-code">&#13;
  IRBuilder&lt;&gt; Builder(&amp;*F.getEntryBlock().begin());</pre></li>				<li>Now that we have the builder, we can insert a global constant that holds the name of the function we wish <span class="No-Break">to instrument:</span><pre class="source-code">&#13;
  GlobalVariable *FnName =&#13;
      Builder.CreateGlobalString(F.getName());</pre></li>				<li>Next, we will insert a call to the <strong class="source-inline">__ppp_enter()</strong> function, passing the name as <span class="No-Break">an argument:</span><pre class="source-code">&#13;
  Builder.CreateCall(EnterFn-&gt;getFunctionType(), EnterFn,&#13;
                     {FnName});</pre></li>				<li>To call the <strong class="source-inline">__ppp_exit()</strong> function, we have to locate all return instructions. Conveniently, the insertion point that’s set by the calling <strong class="source-inline">SetInsertionPoint()</strong> function is before the instruction that’s passed as a parameter, so <a id="_idIndexMarker412"/>we can just insert the call at <span class="No-Break">that point:</span><pre class="source-code">&#13;
  for (BasicBlock &amp;BB : F) {&#13;
    for (Instruction &amp;Inst : BB) {&#13;
      if (Inst.getOpcode() == Instruction::Ret) {&#13;
        Builder.SetInsertPoint(&amp;Inst);&#13;
        Builder.CreateCall(ExitFn-&gt;getFunctionType(),&#13;
                           ExitFn, {FnName});&#13;
      }&#13;
    }&#13;
  }&#13;
}</pre></li>				<li>Next, we will implement the <strong class="source-inline">run()</strong> method. LLVM passes in the module our pass works on and an analysis manager from which we can request analysis results <span class="No-Break">if needed:</span><pre class="source-code">&#13;
PreservedAnalyses&#13;
PPProfilerIRPass::run(Module &amp;M,&#13;
                      ModuleAnalysisManager &amp;AM) {</pre></li>				<li>There is a slight annoyance here: if the runtime module that contains the implementation of the <strong class="source-inline">__ppp_enter()</strong> and <strong class="source-inline">__ppp_exit()</strong> functions are instrumented, then we run into trouble because we create an infinite recursion. To avoid this, we must simply do nothing if one of those functions <span class="No-Break">is defined:</span><pre class="source-code">&#13;
  if (M.getFunction("__ppp_enter") ||&#13;
      M.getFunction("__ppp_exit")) {&#13;
    return PreservedAnalyses::all();&#13;
  }</pre></li>				<li>Now, we are <a id="_idIndexMarker413"/>ready to declare the functions. There is nothing unusual here: first, the function type is created, followed by <span class="No-Break">the functions:</span><pre class="source-code">&#13;
  Type *VoidTy = Type::getVoidTy(M.getContext());&#13;
  PointerType *PtrTy =&#13;
      PointerType::getUnqual(M.getContext());&#13;
  FunctionType *EnterExitFty =&#13;
      FunctionType::get(VoidTy, {PtrTy}, false);&#13;
  Function *EnterFn = Function::Create(&#13;
      EnterExitFty, GlobalValue::ExternalLinkage,&#13;
      "__ppp_enter", M);&#13;
  Function *ExitFn = Function::Create(&#13;
      EnterExitFty, GlobalValue::ExternalLinkage,&#13;
      "__ppp_exit", M);</pre></li>				<li>All we need to do now is loop over all the functions of the module and instrument the found functions by calling our <strong class="source-inline">instrument()</strong> method. Of course, we need to ignore function declarations, which are just prototypes. There can also be functions without a name, which does not work well with our approach. We’ll filter out those <span class="No-Break">functions too:</span><pre class="source-code">&#13;
  for (auto &amp;F : M.functions()) {&#13;
    if (!F.isDeclaration() &amp;&amp; F.hasName())&#13;
      instrument(F, EnterFn, ExitFn);&#13;
  }</pre></li>				<li>Lastly, we must declare that we did not preserve any analysis. This is most likely too pessimistic but we are on the safe side by <span class="No-Break">doing so:</span><pre class="source-code">&#13;
  return PreservedAnalyses::none();&#13;
}</pre><p class="list-inset">The <a id="_idIndexMarker414"/>functionality of our new pass is now implemented. To be able to use our pass, we need to register it with the <strong class="source-inline">PassBuilder</strong> object. This can happen in two ways: statically or dynamically. If the plugin is statically linked, then it needs to provide a function called <strong class="source-inline">get&lt;Plugin-Name&gt;PluginInfo()</strong>. To use dynamic linking, the <strong class="source-inline">llvmGetPassPluginInfo()</strong> function needs to be provided. In both cases, an instance of the <strong class="source-inline">PassPluginLibraryInfo</strong> struct is returned, which provides some basic information about a plugin. Most importantly, this structure contains a pointer to the function that registers the pass. Let’s add this to <span class="No-Break">our source.</span></p></li>				<li>In the <strong class="source-inline">RegisterCB()</strong> function, we register a Lambda function that is called when a pass pipeline string is parsed. If the name of the pass is <strong class="source-inline">ppprofiler</strong>, then we add our pass to the module pass manager. These callbacks will be expanded upon in the <span class="No-Break">next section:</span><pre class="source-code">&#13;
void RegisterCB(PassBuilder &amp;PB) {&#13;
  PB.registerPipelineParsingCallback(&#13;
      [](StringRef Name, ModulePassManager &amp;MPM,&#13;
         ArrayRef&lt;PassBuilder::PipelineElement&gt;) {&#13;
        if (Name == "ppprofiler") {&#13;
          MPM.addPass(PPProfilerIRPass());&#13;
          return true;&#13;
        }&#13;
        return false;&#13;
      });&#13;
}</pre></li>				<li>The <strong class="source-inline">getPPProfilerPluginInfo()</strong> function is called when the plugin is statically linked. It returns some basic information about <span class="No-Break">the plugin:</span><pre class="source-code">&#13;
llvm::PassPluginLibraryInfo getPPProfilerPluginInfo() {&#13;
  return {LLVM_PLUGIN_API_VERSION, "PPProfiler", "v0.1",&#13;
          RegisterCB};&#13;
}</pre></li>				<li>Finally, if the<a id="_idIndexMarker415"/> plugin is dynamically linked, then the <strong class="source-inline">llvmGetPassPluginInfo()</strong> function is called when the plugin is loaded. However, when linking this code statically into a tool, you might end up with linker errors because that function could be defined in several source files. The solution is to guard the function with <span class="No-Break">a macro:</span><pre class="source-code">&#13;
#ifndef LLVM_PPPROFILER_LINK_INTO_TOOLS&#13;
extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo&#13;
llvmGetPassPluginInfo() {&#13;
  return getPPProfilerPluginInfo();&#13;
}&#13;
#endif</pre></li>			</ol>&#13;
			<p>With that, we’ve implemented the pass plugin. Before we look at how to use the new plugin, let’s examine what needs to be changed if we want to add the pass plugin to the LLVM <span class="No-Break">source tree.</span></p>&#13;
			<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>Adding the pass to the LLVM source tree</h2>&#13;
			<p>Implementing<a id="_idIndexMarker416"/> a new pass as a plugin is useful if you plan to use it with a precompiled clang, for example. On the other hand, if you write your own compiler, then there can be good reasons to add your new passes directly to the LLVM source tree. There are two different ways you can do this – as a plugin and as a fully integrated pass. The plugin approach requires <span class="No-Break">fewer changes.</span></p>&#13;
			<h3>Utilizing the plugin mechanisms inside the LLVM source tree</h3>&#13;
			<p>The <a id="_idIndexMarker417"/>source of passes that perform transformations on LLVM IR is located in the <strong class="source-inline">llvm-project/llvm/lib/Transforms</strong> directory. Inside this directory, create a new directory called <strong class="source-inline">PPProfiler</strong> and copy the source file, <strong class="source-inline">PPProfiler.cpp</strong>, into it. You do not need to make any <span class="No-Break">source changes!</span></p>&#13;
			<p>To integrate the new plugin into the build system, create a file called <strong class="source-inline">CMakeLists.txt</strong> with the <span class="No-Break">following content:</span></p>&#13;
			<pre class="source-code">&#13;
add_llvm_pass_plugin(PPProfiler PPProfiler.cpp)</pre>			<p>Finally, in the <strong class="source-inline">CmakeLists.txt</strong> file in the parent directory, you need to include the new source directory by adding the <span class="No-Break">following line:</span></p>&#13;
			<pre class="source-code">&#13;
add_subdirectory(PPProfiler)</pre>			<p>You are now ready to build LLVM with <strong class="source-inline">PPProfiler</strong> added. Change into the build directory of LLVM and manually <span class="No-Break">run Ninja:</span></p>&#13;
			<pre class="console">&#13;
$ ninja install</pre>			<p>CMake will detect a change in the build description and rerun the configuration step. You will see an <span class="No-Break">additional line:</span></p>&#13;
			<pre class="console">&#13;
-- Registering PPProfiler as a pass plugin (static build: OFF)</pre>			<p>This tells you that the plugin was detected and has been built as a shared library. After the installation step, you will find that shared library, <strong class="source-inline">PPProfiler.so</strong>, in the <strong class="source-inline">&lt;install </strong><span class="No-Break"><strong class="source-inline">directory&gt;/lib</strong></span><span class="No-Break"> directory.</span></p>&#13;
			<p>So far, the only difference to the pass plugin from the previous section is that the shared library is installed as part of LLVM. But you can also statically link the new plugin to the LLVM tools. To<a id="_idIndexMarker418"/> do this, you need to rerun the CMake configuration and add the <strong class="source-inline">-DLLVM_PPPROFILER_LINK_INTO_TOOLS=ON</strong> option on the command line. Look for this information from CMake to confirm the changed <span class="No-Break">build option:</span></p>&#13;
			<pre class="console">&#13;
-- Registering PPProfiler as a pass plugin (static build: ON)</pre>			<p>After compiling and installing LLVM again, the following <span class="No-Break">has changed:</span></p>&#13;
			<ul>&#13;
				<li>The plugin is compiled into the static library, <strong class="source-inline">libPPProfiler.a</strong>, and that library is installed in the <strong class="source-inline">&lt;install </strong><span class="No-Break"><strong class="source-inline">directory&gt;/lib</strong></span><span class="No-Break"> directory.</span></li>&#13;
				<li>The LLVM tools, such as <strong class="bold">opt</strong>, are linked against <span class="No-Break">that library.</span></li>&#13;
				<li>The plugin is registered as an extension. You can check that the <strong class="source-inline">&lt;install directory&gt;/include/llvm/Support/Extension.def</strong> file now contains the <span class="No-Break">following line:</span><pre class="source-code">&#13;
HANDLE_EXTENSION(PPProfiler)</pre></li>			</ul>&#13;
			<p>In addition, all tools that support this extension mechanism pick up the new pass. In the <em class="italic">Creating an optimization pipeline</em> section, you will learn how to do this in <span class="No-Break">your compiler.</span></p>&#13;
			<p>This approach works well because the new source files reside in a separate directory, and only one existing file was changed. This minimizes the probability of merge conflicts if you try to keep your modified LLVM source tree in sync with the <span class="No-Break">main repository.</span></p>&#13;
			<p>There are also situations where adding the new pass as a plugin is not the best way. The passes that LLVM provides use a different way for registration. If you develop a new pass and propose to add it to LLVM, and the LLVM community accepts your contribution, then you will want to use the same <span class="No-Break">registration mechanism.</span></p>&#13;
			<h3>Fully integrating the pass into the pass registry</h3>&#13;
			<p>To fully integrate <a id="_idIndexMarker419"/>the new pass into LLVM, the source of the plugin needs to be structured slightly differently. The main reason for this is that the constructor of the pass class is called from the pass registry, which requires the class interface to be put into a <span class="No-Break">header file.</span></p>&#13;
			<p>Like before, you<a id="_idIndexMarker420"/> must put the new pass into the <strong class="source-inline">Transforms</strong> component of LLVM. Begin the implementation by creating the <strong class="source-inline">llvm-project/llvm/include/llvm/Transforms/PPProfiler/PPProfiler.h</strong> header file. The content of that file is the class definition; put it into the <strong class="source-inline">llvm</strong> namespace. No other changes <span class="No-Break">are required:</span></p>&#13;
			<pre class="source-code">&#13;
#ifndef LLVM_TRANSFORMS_PPPROFILER_PPPROFILER_H&#13;
#define LLVM_TRANSFORMS_PPPROFILER_PPPROFILER_H&#13;
#include "llvm/IR/PassManager.h"&#13;
namespace llvm {&#13;
class PPProfilerIRPass&#13;
    : public llvm::PassInfoMixin&lt;PPProfilerIRPass&gt; {&#13;
public:&#13;
  llvm::PreservedAnalyses&#13;
  run(llvm::Module &amp;M, llvm::ModuleAnalysisManager &amp;AM);&#13;
private:&#13;
  void instrument(llvm::Function &amp;F,&#13;
                  llvm::Function *EnterFn,&#13;
                  llvm::Function *ExitFn);&#13;
};&#13;
} // namespace llvm&#13;
#endif</pre>			<p>Next, copy the source file of the pass plugin, <strong class="source-inline">PPProfiler.cpp</strong>, into the new directory, <strong class="source-inline">llvm-project/llvm/lib/Transforms/PPProfiler</strong>. This file needs to be <a id="_idIndexMarker421"/>updated in the <span class="No-Break">following way:</span></p>&#13;
			<ol>&#13;
				<li>Since the class definition is now in a header file, you must remove the class definition from this file. At the top, add the <strong class="source-inline">#include</strong> directive for the <span class="No-Break">header file:</span><pre class="source-code">&#13;
#include "llvm/Transforms/PPProfiler/PPProfiler.h"</pre></li>				<li>The <strong class="source-inline">llvmGetPassPluginInfo()</strong> function must be removed because the pass wasn’t built into a shared library of <span class="No-Break">its own.</span></li>&#13;
			</ol>&#13;
			<p>As before, you also need to provide a <strong class="source-inline">CMakeLists.txt</strong> file for the build. You must declare the new pass as a <span class="No-Break">new component:</span></p>&#13;
			<pre class="source-code">&#13;
add_llvm_component_library(LLVMPPProfiler&#13;
  PPProfiler.cpp&#13;
  LINK_COMPONENTS&#13;
  Core&#13;
  Support&#13;
)</pre>			<p>After, like in the previous section, you need to include the new source directory by adding the following line to the <strong class="source-inline">CMakeLists.txt</strong> file in the <span class="No-Break">parent directory:</span></p>&#13;
			<pre class="source-code">&#13;
add_subdirectory(PPProfiler)</pre>			<p>Inside LLVM, the available passes are kept in the <strong class="source-inline">llvm/lib/Passes/ PassRegistry.def</strong> database file. You need to update this file. The new pass is a module pass, so we need to search inside the file for the section in which module passes are defined, for example, by searching for the <strong class="source-inline">MODULE_PASS</strong> macro. Inside this section, add the <span class="No-Break">following line:</span></p>&#13;
			<pre class="source-code">&#13;
MODULE_PASS("ppprofiler", PPProfilerIRPass())</pre>			<p>This database file is used in the <strong class="source-inline">llvm/lib/Passes/PassBuilder.cpp</strong> class. This file needs to include your new <span class="No-Break">header file:</span></p>&#13;
			<pre class="source-code">&#13;
#include "llvm/Transforms/PPProfiler/PPProfiler.h"</pre>			<p>These are <a id="_idIndexMarker422"/>all required source changes based on the plugin version of the <span class="No-Break">new pass.</span></p>&#13;
			<p>Since you created a new LLVM component, it is also necessary to add a link dependency in the <strong class="source-inline">llvm/lib/Passes/CMakeLists.txt</strong> file. Under the <strong class="source-inline">LINK_COMPONENTS</strong> keyword, you need to add a line with the name of the <span class="No-Break">new component:</span></p>&#13;
			<pre class="source-code">&#13;
  PPProfiler</pre>			<p>Et voilà – you are ready to build and install LLVM. The new pass, <strong class="source-inline">ppprofiler</strong>, is now available to all LLVM tools. It has been compiled into the <strong class="source-inline">libLLVMPPProfiler.a</strong> library and available in the build system as the <span class="No-Break"><strong class="source-inline">PPProfiler</strong></span><span class="No-Break"> component.</span></p>&#13;
			<p>So far, we have talked about how to create a new pass. In the next section, we will examine how to use the <span class="No-Break"><strong class="source-inline">ppprofiler</strong></span><span class="No-Break"> pass.</span></p>&#13;
			<h1 id="_idParaDest-122"><a id="_idTextAnchor124"/>Using the ppprofiler pass with LLVM tools</h1>&#13;
			<p>Recall<a id="_idIndexMarker423"/> the ppprofiler pass that we developed as a plugin out of the LLVM tree in the <em class="italic">Developing the ppprofiler pass as a plugin</em> section. Here, we’ll learn how to use this pass with LLVM tools, such as <strong class="source-inline">opt</strong> and <strong class="source-inline">clang</strong>, as they can <span class="No-Break">load plugins.</span></p>&#13;
			<p>Let’s look at <span class="No-Break"><strong class="source-inline">opt</strong></span><span class="No-Break"> first.</span></p>&#13;
			<h3>Run the pass plugin in opt</h3>&#13;
			<p>To play <a id="_idIndexMarker424"/>around with the new plugin, you need a file containing LLVM IR. The easiest way to do this is to translate a C program, such as a basic “Hello World” <span class="No-Break">style program:</span></p>&#13;
			<pre class="source-code">&#13;
#include &lt;stdio.h&gt;&#13;
int main(int argc, char *argv[]) {&#13;
  puts("Hello");&#13;
  return 0;&#13;
}</pre>			<p>Compile this file, <strong class="source-inline">hello.c</strong>, <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">clang</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="console">&#13;
$ clang -S -emit-llvm -O1 hello.c</pre>			<p>You will <a id="_idIndexMarker425"/>get a very simple IR file called <strong class="source-inline">hello.ll</strong> that contains the <span class="No-Break">following code:</span></p>&#13;
			<pre class="console">&#13;
$ cat hello.ll&#13;
@.str = private unnamed_addr constant [6 x i8] c"Hello\00",&#13;
        align 1&#13;
define dso_local i32 @main(&#13;
          i32 noundef %0, ptr nocapture noundef readnone %1) {&#13;
  %3 = tail call i32 @puts(&#13;
                 ptr noundef nonnull dereferenceable(1) @.str)&#13;
  ret i32 0&#13;
}</pre>			<p>This is enough to test <span class="No-Break">the pass.</span></p>&#13;
			<p>To run the pass, you have to provide a couple of arguments. First, you need to tell <strong class="source-inline">opt</strong> to load the shared library via the <strong class="source-inline">--load-pass-plugin</strong> option. To run a single pass, you must specify the<strong class="source-inline">–-passes</strong> option. Using the <strong class="source-inline">hello.ll</strong> file as input, you can run <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ opt --load-pass-plugin=./PPProfile.so \&#13;
      --passes="ppprofiler" --stats hello.ll -o hello_inst.bc</pre>			<p>If statistic generation is enabled, you will see the <span class="No-Break">following output:</span></p>&#13;
			<pre class="console">&#13;
===--------------------------------------------------------===&#13;
                 ... Statistics Collected ...&#13;
===--------------------------------------------------------===&#13;
1 ppprofiler - Number of instrumented functions.</pre>			<p>Otherwise, you<a id="_idIndexMarker426"/> will be informed that statistic collection is <span class="No-Break">not enabled:</span></p>&#13;
			<pre class="console">&#13;
Statistics are disabled.  Build with asserts or with&#13;
-DLLVM_FORCE_ENABLE_STATS</pre>			<p>The bitcode file, <strong class="source-inline">hello_inst.bc</strong>, is the result. You can turn this file into readable IR with the <strong class="source-inline">llvm-dis</strong> tool. As expected, you will see the calls to the <strong class="source-inline">__ppp_enter()</strong> and <strong class="source-inline">__ppp_exit()</strong> functions and a new constant for the name of <span class="No-Break">the function:</span></p>&#13;
			<pre class="console">&#13;
$ llvm-dis hello_inst.bc -o –&#13;
@.str = private unnamed_addr constant [6 x i8] c"Hello\00",&#13;
        align 1&#13;
@0 = private unnamed_addr constant [5 x i8] c"main\00",&#13;
     align 1&#13;
define dso_local i32 @main(i32 noundef %0,&#13;
                          ptr nocapture noundef readnone %1) {&#13;
  call void @__ppp_enter(ptr @0)&#13;
  %3 = tail call i32 @puts(&#13;
                 ptr noundef nonnull dereferenceable(1) @.str)&#13;
  call void @__ppp_exit(ptr @0)&#13;
  ret i32 0&#13;
}</pre>			<p>This already looks good! It would be even better if we could turn this IR into an executable and run it. For this, you need to provide implementations for the <span class="No-Break">called functions.</span></p>&#13;
			<p>Often, the<a id="_idIndexMarker427"/> runtime support for a feature is more complicated than adding that feature to the compiler itself. This is also true in this case. When the <strong class="source-inline">__ppp_enter()</strong> and <strong class="source-inline">__ppp_exit()</strong> functions are called, you can view this as an event. To analyze the data later, it is necessary to save the events. The basic data you would like to get is the event of the type, the name of the function and its address, and a timestamp. Without tricks, this is not as easy as it seems. Let’s give it <span class="No-Break">a try.</span></p>&#13;
			<p>Create a file called <strong class="source-inline">runtime.c</strong> with the <span class="No-Break">following content:</span></p>&#13;
			<ol>&#13;
				<li>You need the file I/O, standard functions, and time support. This is provided by the <span class="No-Break">following includes:</span><pre class="source-code">&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;time.h&gt;</pre></li>				<li>For the file, a file descriptor is needed. Moreover, when the program finishes, that file descriptor should be <span class="No-Break">closed properly:</span><pre class="source-code">&#13;
static FILE *FileFD = NULL;&#13;
static void cleanup() {&#13;
  if (FileFD == NULL) {&#13;
    fclose(FileFD);&#13;
    FileFD = NULL;&#13;
  }&#13;
}</pre></li>				<li>To simplify the runtime, only a fixed name for the output is used. If the file is not open, then open the file and register the <span class="No-Break"><strong class="source-inline">cleanup</strong></span><span class="No-Break"> function:</span><pre class="source-code">&#13;
static void init() {&#13;
  if (FileFD == NULL) {&#13;
    FileFD = fopen("ppprofile.csv", "w");&#13;
    atexit(&amp;cleanup);&#13;
  }&#13;
}</pre></li>				<li>You can <a id="_idIndexMarker428"/>call the <strong class="source-inline">clock_gettime()</strong> function to get a timestamp. The <strong class="source-inline">CLOCK_PROCESS_CPUTIME_ID</strong> parameter returns the time consumed by this process. Please note that not all systems support this parameter. You can use one of the other clocks, such as <strong class="source-inline">CLOCK_REALTIME</strong>, <span class="No-Break">if necessary:</span><pre class="source-code">&#13;
typedef unsigned long long Time;&#13;
static Time get_time() {&#13;
  struct timespec ts;&#13;
  clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;ts);&#13;
  return 1000000000L * ts.tv_sec + ts.tv_nsec;&#13;
}</pre></li>				<li>Now, it is easy to define the <strong class="source-inline">__ppp_enter()</strong> function. Just make sure the file is open, get the timestamp, and write <span class="No-Break">the event:</span><pre class="source-code">&#13;
void __ppp_enter(const char *FnName) {&#13;
  init();&#13;
  Time T = get_time();&#13;
  void *Frame = __builtin_frame_address(1);&#13;
  fprintf(FileFD,&#13;
          // "enter|name|clock|frame"&#13;
          „enter|%s|%llu|%p\n", FnName, T, Frame);&#13;
}</pre></li>				<li>The <strong class="source-inline">__ppp_exit()</strong> function only differs in terms of the <span class="No-Break">event type:</span><pre class="source-code">&#13;
void __ppp_exit(const char *FnName) {&#13;
  init();&#13;
  Time T = get_time();&#13;
  void *Frame = __builtin_frame_address(1);&#13;
  fprintf(FileFD,&#13;
          // "exit|name|clock|frame"&#13;
          „exit|%s|%llu|%p\n", FnName, T, Frame);&#13;
}</pre></li>			</ol>&#13;
			<p>That<a id="_idIndexMarker429"/> concludes a very simple implementation for runtime support. Before we try it, some remarks should be made about the implementation as it should be obvious that there are several <span class="No-Break">problematic parts.</span></p>&#13;
			<p>First of all, the implementation is not thread-safe since there is only one file descriptor, and access to it is not protected. Trying to use this runtime implementation with a multithreaded program will most likely lead to disturbed data in the <span class="No-Break">output file.</span></p>&#13;
			<p>In addition, we omitted checking the return value of the I/O-related functions, which can result in <span class="No-Break">data loss.</span></p>&#13;
			<p>But most importantly, the timestamp of the event is not precise. Calling a function already adds overhead, but performing I/O operations in that function makes it even worse. In principle, you can match the enter and exit events for a function and calculate the runtime of the function. However, this value is inherently flawed because it may include the time required for I/O. In summary, do not trust the times <span class="No-Break">recorded here.</span></p>&#13;
			<p>Despite all the flaws, this small runtime file allows us to produce some output. Compile the bitcode of the instrumented file together with the file containing the runtime code and run the <span class="No-Break">resulting executable:</span></p>&#13;
			<pre class="console">&#13;
$ clang hello_inst.bc runtime.c&#13;
$ ./a.out</pre>			<p>This results in a <a id="_idIndexMarker430"/>new file called <strong class="source-inline">ppprofile.csv</strong> in the directory that contains the <span class="No-Break">following content:</span></p>&#13;
			<pre class="console">&#13;
$ cat ppprofile.csv&#13;
enter|main|3300868|0x1&#13;
exit|main|3760638|0x1</pre>			<p>Cool – the new pass and the runtime seem <span class="No-Break">to work!</span></p>&#13;
			<p class="callout-heading">Specifying a pass pipeline</p>&#13;
			<p class="callout">With the <strong class="source-inline">–-passes</strong> option, you can not only name a single pass but you can also describe a whole pipeline. For example, the default pipeline for optimization level 2 is named <strong class="source-inline">default&lt;O2&gt;</strong>. You can run the <strong class="source-inline">ppprofile</strong> pass before the default pipeline with the<strong class="source-inline">–-passes="ppprofile,default&lt;O2&gt;"</strong> argument. Please note that the pass names in such a pipeline description must be of the <span class="No-Break">same type.</span></p>&#13;
			<p>Now, let’s turn to using the new pass <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">clang</strong></span><span class="No-Break">.</span></p>&#13;
			<h3>Plugging the new pass into clang</h3>&#13;
			<p>In the<a id="_idIndexMarker431"/> previous section, you learned how you can run a single pass using <strong class="source-inline">opt</strong>. This is useful if you need to debug a pass but for a real compiler, the steps should not be <span class="No-Break">that involved.</span></p>&#13;
			<p>To achieve the best result, a compiler needs to run the optimization passes in a certain order. The LLVM pass manager <a id="_idIndexMarker432"/>has a default order for pass execution. This is also called the <strong class="bold">default pass pipeline</strong>. Using <strong class="source-inline">opt</strong>, you can specify a different pass pipeline with the <strong class="source-inline">–passes</strong> option. This is flexible but also complicated for the user. It also turns out that most of the time, you just want to add a new pass at very specific points, such as before optimization passes are run or at the end of the loop optimization processes. These points are<a id="_idIndexMarker433"/> called <strong class="bold">extension points</strong>. The <strong class="source-inline">PassBuilder</strong> class allows you to register a pass at an extension point. For example, you can call the <strong class="source-inline">registerPipelineStartEPCallback()</strong> method to add a pass to the beginning of the optimization pipeline. This is exactly the place we need for the <strong class="source-inline">ppprofiler</strong> pass. During optimization, functions may be inlined, and the pass will miss those inline functions. Instead, running the pass before the optimization passes guarantees that all functions <span class="No-Break">are instrumented.</span></p>&#13;
			<p>To use this<a id="_idIndexMarker434"/> approach, you need to extend the <strong class="source-inline">RegisterCB()</strong> function in the pass plugin. Add the following code to <span class="No-Break">the function:</span></p>&#13;
			<pre class="source-code">&#13;
  PB.registerPipelineStartEPCallback(&#13;
      [](ModulePassManager &amp;PM, OptimizationLevel Level) {&#13;
        PM.addPass(PPProfilerIRPass());&#13;
      });</pre>			<p>Whenever the pass manager populates the default pass pipeline, it calls all the callbacks for the extension points. We simply add the new <span class="No-Break">pass here.</span></p>&#13;
			<p>To load the plugin into <strong class="source-inline">clang</strong>, you can use the <strong class="source-inline">-fpass-plugin</strong> option. Creating the instrumented executable of the <strong class="source-inline">hello.c</strong> file now becomes <span class="No-Break">almost trivial:</span></p>&#13;
			<pre class="console">&#13;
$ clang -fpass-plugin=./PPProfiler.so hello.c runtime.c</pre>			<p>Please run the executable and verify that the run creates the <span class="No-Break"><strong class="source-inline">ppprofiler.csv</strong></span><span class="No-Break"> file.</span></p>&#13;
			<p class="callout-heading">Note</p>&#13;
			<p class="callout">The <strong class="source-inline">runtime.c</strong> file is not instrumented because the pass checks that the special functions are not yet declared in <span class="No-Break">a module.</span></p>&#13;
			<p>This already looks better, but does it scale to larger programs? Let’s assume you want to build an instrumented binary of the <strong class="source-inline">tinylang</strong> compiler for <a href="B19561_05.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. How would you <span class="No-Break">do this?</span></p>&#13;
			<p>You can pass compiler and linker flags on the CMake command line, which is exactly what we need. The flags for the C++ compiler are given in the <strong class="source-inline">CMAKE_CXX_FLAGS</strong> variable. Thus, specifying the following on the CMake command line adds the new pass to all <span class="No-Break">compiler runs:</span></p>&#13;
			<pre class="source-code">&#13;
-DCMAKE_CXX_FLAGS="-fpass-plugin=&lt;PluginPath&gt;/PPProfiler.so"</pre>			<p>Please <a id="_idIndexMarker435"/>replace <strong class="source-inline">&lt;PluginPath&gt;</strong> with the absolute path to the <span class="No-Break">shared library.</span></p>&#13;
			<p>Similarly, specifying the following adds the <strong class="source-inline">runtime.o</strong> file to each linker invocation. Again, please replace <strong class="source-inline">&lt;RuntimePath&gt;</strong> with the absolute path to a compiled version <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">runtime.c</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code">&#13;
-DCMAKE_EXE_LINKER_FLAGS="&lt;RuntimePath&gt;/runtime.o"</pre>			<p>Of course, this requires <strong class="source-inline">clang</strong> as the build compiler. The fastest way to make sure <strong class="source-inline">clang</strong> is used as the build compiler is to set the <strong class="source-inline">CC</strong> and <strong class="source-inline">CXX</strong> environment <span class="No-Break">variables accordingly:</span></p>&#13;
			<pre class="source-code">&#13;
export CC=clang&#13;
export CXX=clang++</pre>			<p>With these additional options, the CMake configuration from <a href="B19561_05.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> should run <span class="No-Break">as usual.</span></p>&#13;
			<p>After building the <strong class="source-inline">tinylang</strong> executable, you can run it with the example <strong class="source-inline">Gcd.mod</strong> file. The <strong class="source-inline">ppprofile.csv</strong> file will also be written, this time with more than <span class="No-Break">44,000 lines!</span></p>&#13;
			<p>Of course, having such a dataset raises the question of if you can get something useful out of it. For example, getting a list of the 10 most often called functions, together with the call count and the time spent in the function, would be useful information. Luckily, on a Unix system, you have a couple of tools that can help. Let’s build a short pipeline that matches enter events with exit events, counts the functions, and displays the top 10 functions. The <strong class="source-inline">awk</strong> Unix tool helps with most of <span class="No-Break">these steps.</span></p>&#13;
			<p>To match an enter event with an exit event, the enter event must be stored in the <strong class="source-inline">record</strong> associative map. When an exit event is matched, the stored enter event is looked up, and the new record is written. The emitted line contains the timestamp from the enter event, the timestamp from the exit event, and the difference between both. We must put this into the <span class="No-Break"><strong class="source-inline">join.awk</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="source-code">&#13;
BEGIN { FS = "|"; OFS = "|" }&#13;
/enter/ { record[$2] = $0 }&#13;
/exit/ { split(record[$2],val,"|")&#13;
         print val[2], val[3], $3, $3-val[3], val[4] }</pre>			<p>To count <a id="_idIndexMarker436"/>the function calls and the execution, two associative maps, <strong class="source-inline">count</strong> and <strong class="source-inline">sum</strong>, are used. In <strong class="source-inline">count</strong>, the function calls are counted, while in <strong class="source-inline">sum</strong>, the execution time is added. In the end, the maps are dumped. You can put this into the <span class="No-Break"><strong class="source-inline">avg.awk</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="source-code">&#13;
BEGIN { FS = "|"; count[""] = 0; sum[""] = 0 }&#13;
{ count[$1]++; sum[$1] += $4 }&#13;
END { for (i in count) {&#13;
        if (i != "") {&#13;
          print count[i], sum[i], sum[i]/count[i], I }&#13;
} }</pre>			<p>After running these two scripts, the result can be sorted in descending order, and then the top 10 lines can be taken from the file. However, we can still improve the function names, <strong class="source-inline">__ppp_enter()</strong> and <strong class="source-inline">__ppp_exit()</strong>, which are mangled and are therefore difficult to read. Using the <strong class="source-inline">llvm-cxxfilt</strong> tool, the names can be demangled. The <strong class="source-inline">demangle.awk</strong> script is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
{ cmd = "llvm-cxxfilt " $4&#13;
  (cmd) | getline name&#13;
  close(cmd); $4 = name; print }</pre>			<p>To get the top 10 function calls, you can run <span class="No-Break">the following:</span></p>&#13;
			<pre class="console">&#13;
$ cat ppprofile.csv | awk -f join.awk | awk -f avg.awk |\&#13;
  sort -nr | head -15 | awk -f demangle.awk</pre>			<p>Here are some sample lines from <span class="No-Break">the output:</span></p>&#13;
			<pre class="source-code">&#13;
446 1545581 3465.43 charinfo::isASCII(char)&#13;
409 826261 2020.2 llvm::StringRef::StringRef()&#13;
382 899471 2354.64&#13;
           tinylang::Token::is(tinylang::tok::TokenKind) const&#13;
171 1561532 9131.77 charinfo::isIdentifierHead(char)</pre>			<p>The <a id="_idIndexMarker437"/>first number is the call count of the function, the second is the cumulated execution time, and the third number is the average execution time. As explained previously, do not trust the time values, though the call counts should <span class="No-Break">be accurate.</span></p>&#13;
			<p>So far, we’ve implemented a new instrumentation pass, either as a plugin or as an addition to LLVM, and we used it in some real-world scenarios. In the next section, we’ll explore how to set up an optimization pipeline in <span class="No-Break">our compiler.</span></p>&#13;
			<h1 id="_idParaDest-123"><a id="_idTextAnchor125"/>Adding an optimization pipeline to your compiler</h1>&#13;
			<p>The <strong class="source-inline">tinylang</strong> compiler <a id="_idIndexMarker438"/>we developed in the<a id="_idIndexMarker439"/> previous chapters performs no optimizations on the IR code. In the next few subsections, we’ll add an optimization pipeline to the compiler to achieve <span class="No-Break">this accordingly.</span></p>&#13;
			<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Creating an optimization pipeline</h2>&#13;
			<p>The <strong class="source-inline">PassBuilder</strong> class is<a id="_idIndexMarker440"/> central to setting up the optimization pipeline. This class knows about all registered passes and can construct a pass pipeline from a textual description. We can use this class to either create the pass pipeline from a description given on the command line or use a default pipeline based on the requested optimization level. We also support the use of pass plugins, such as the <strong class="source-inline">ppprofiler</strong> pass plugin we discussed in the previous section. With this, we can mimic part of the functionality <a id="_idIndexMarker441"/>of the <strong class="bold">opt</strong> tool and also use similar names for the <span class="No-Break">command-line options.</span></p>&#13;
			<p>The <strong class="source-inline">PassBuilder</strong> class populates an instance of a <strong class="source-inline">ModulePassManager</strong> class, which is the pass manager that holds the constructed pass pipeline and runs it. The code generation passes still use the old pass manager. Therefore, we have to retain the old pass manager for <span class="No-Break">this purpose.</span></p>&#13;
			<p>For the implementation, we will extend the <strong class="source-inline">tools/driver/Driver.cpp</strong> file from our <span class="No-Break"><strong class="source-inline">tinylang</strong></span><span class="No-Break"> compiler:</span></p>&#13;
			<ol>&#13;
				<li>We’ll use new classes, so we’ll begin with adding new include files. The <strong class="source-inline">llvm/Passes/PassBuilder.h</strong> file defines the <strong class="source-inline">PassBuilder</strong> class. The <strong class="source-inline">llvm/Passes/PassPlugin.h</strong> file is required for plugin support. Finally, the <strong class="source-inline">llvm/Analysis/TargetTransformInfo.h</strong> file provides a pass that connects IR-level transformations with <span class="No-Break">target-specific information:</span><pre class="source-code">&#13;
#include "llvm/Passes/PassBuilder.h"&#13;
#include "llvm/Passes/PassPlugin.h"&#13;
#include "llvm/Analysis/TargetTransformInfo.h"</pre></li>				<li>To use<a id="_idIndexMarker442"/> certain features of the new pass manager, we must add three command-line options, using the same names as the <strong class="source-inline">opt</strong> tool does. The <strong class="source-inline">--passes</strong> option allows the textual specification of the pass pipeline, while the <strong class="source-inline">--load-pass-plugin</strong> option allows the use of pass plugins. If the <strong class="source-inline">--debug-pass-manager</strong> option is given, then the pass manager prints out information about the <span class="No-Break">executed passes:</span><pre class="source-code">&#13;
static cl::opt&lt;bool&gt;&#13;
    DebugPM("debug-pass-manager", cl::Hidden,&#13;
            cl::desc("Print PM debugging information"));&#13;
static cl::opt&lt;std::string&gt; PassPipeline(&#13;
    "passes",&#13;
    cl::desc("A description of the pass pipeline"));&#13;
static cl::list&lt;std::string&gt; PassPlugins(&#13;
    "load-pass-plugin",&#13;
    cl::desc("Load passes from plugin library"));</pre></li>				<li>The user influences the construction of the pass pipeline with the optimization level. The <strong class="source-inline">PassBuilder</strong> class supports six different optimization levels: no optimization, three levels for optimizing speed, and two levels for reducing size. We can <a id="_idIndexMarker443"/>capture all levels in one <span class="No-Break">command-line option:</span><pre class="source-code">&#13;
static cl::opt&lt;signed char&gt; OptLevel(&#13;
    cl::desc("Setting the optimization level:"),&#13;
    cl::ZeroOrMore,&#13;
    cl::values(&#13;
        clEnumValN(3, "O", "Equivalent to -O3"),&#13;
        clEnumValN(0, "O0", "Optimization level 0"),&#13;
        clEnumValN(1, "O1", "Optimization level 1"),&#13;
        clEnumValN(2, "O2", "Optimization level 2"),&#13;
        clEnumValN(3, "O3", "Optimization level 3"),&#13;
        clEnumValN(-1, "Os",&#13;
                   "Like -O2 with extra optimizations "&#13;
                   "for size"),&#13;
        clEnumValN(&#13;
            -2, "Oz",&#13;
            "Like -Os but reduces code size further")),&#13;
    cl::init(0));</pre></li>				<li>The plugin mechanism of LLVM supports a plugin registry for statically linked plugins, which is created during the configuration of the project. To make use of this registry, we must include the <strong class="source-inline">llvm/Support/Extension.def</strong> database file to create the prototype for the functions that return the <span class="No-Break">plugin information:</span><pre class="source-code">&#13;
#define HANDLE_EXTENSION(Ext)                          \&#13;
  llvm::PassPluginLibraryInfo get##Ext##PluginInfo();&#13;
#include "llvm/Support/Extension.def"</pre></li>				<li>Now, we <a id="_idIndexMarker444"/>must replace the existing <strong class="source-inline">emit()</strong> function with a new version. Additionally, we must declare the required <strong class="source-inline">PassBuilder</strong> instance at the top of <span class="No-Break">the function:</span><pre class="source-code">&#13;
bool emit(StringRef Argv0, llvm::Module *M,&#13;
          llvm::TargetMachine *TM,&#13;
          StringRef InputFilename) {&#13;
  PassBuilder PB(TM);</pre></li>				<li>To implement the support for pass plugins given on the command line, we must loop through the list of plugin libraries given by the user and try to load the plugin. We’ll emit an error message if this fails; otherwise, we’ll register <span class="No-Break">the passes:</span><pre class="source-code">&#13;
  for (auto &amp;PluginFN : PassPlugins) {&#13;
    auto PassPlugin = PassPlugin::Load(PluginFN);&#13;
    if (!PassPlugin) {&#13;
      WithColor::error(errs(), Argv0)&#13;
          &lt;&lt; "Failed to load passes from '" &lt;&lt; PluginFN&#13;
          &lt;&lt; "'. Request ignored.\n";&#13;
      continue;&#13;
    }&#13;
    PassPlugin-&gt;registerPassBuilderCallbacks(PB);&#13;
  }</pre></li>				<li>The information<a id="_idIndexMarker445"/> from the static plugin registry is used in a similar way to register those plugins with our <span class="No-Break"><strong class="source-inline">PassBuilder</strong></span><span class="No-Break"> instance:</span><pre class="source-code">&#13;
#define HANDLE_EXTENSION(Ext)                          \&#13;
  get##Ext##PluginInfo().RegisterPassBuilderCallbacks( \&#13;
      PB);&#13;
#include "llvm/Support/Extension.def"</pre></li>				<li>Now, we need to declare variables for the different analysis managers. The only parameter is the <span class="No-Break">debug flag:</span><pre class="source-code">&#13;
  LoopAnalysisManager LAM(DebugPM);&#13;
  FunctionAnalysisManager FAM(DebugPM);&#13;
  CGSCCAnalysisManager CGAM(DebugPM);&#13;
  ModuleAnalysisManager MAM(DebugPM);</pre></li>				<li>Next, we must populate the analysis managers with calls to the respective <strong class="source-inline">register</strong> method on the <strong class="source-inline">PassBuilder</strong> instance. Through this call, the analysis manager is populated with the default analysis passes and also runs registration callbacks. We must also make sure that the function analysis manager uses the default alias-analysis pipeline and that all analysis managers know about <span class="No-Break">each other:</span><pre class="source-code">&#13;
  FAM.registerPass(&#13;
      [&amp;] { return PB.buildDefaultAAPipeline(); });&#13;
  PB.registerModuleAnalyses(MAM);&#13;
  PB.registerCGSCCAnalyses(CGAM);&#13;
  PB.registerFunctionAnalyses(FAM);&#13;
  PB.registerLoopAnalyses(LAM);&#13;
  PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);</pre></li>				<li>The <strong class="source-inline">MPM</strong> module pass manager holds the pass pipeline that we constructed. The instance is initialized with the <span class="No-Break">debug flag:</span><pre class="source-code">&#13;
  ModulePassManager MPM(DebugPM);</pre></li>				<li>Now, we <a id="_idIndexMarker446"/>need to implement two different ways to populate the module pass manager with the pass pipeline. If the user provided a pass pipeline on the command line – that is, they have used the <strong class="source-inline">--passes</strong> option – then we use this as the <span class="No-Break">pass pipeline:</span><pre class="source-code">&#13;
  if (!PassPipeline.empty()) {&#13;
    if (auto Err = PB.parsePassPipeline(&#13;
            MPM, PassPipeline)) {&#13;
      WithColor::error(errs(), Argv0)&#13;
          &lt;&lt; toString(std::move(Err)) &lt;&lt; "\n";&#13;
      return false;&#13;
    }&#13;
  }</pre></li>				<li>Otherwise, we use the chosen optimization level to determine the pass pipeline to construct. The name of the default pass pipeline is <strong class="source-inline">default</strong>, and it takes the optimization level as <span class="No-Break">a parameter:</span><pre class="source-code">&#13;
  else {&#13;
    StringRef DefaultPass;&#13;
    switch (OptLevel) {&#13;
    case 0: DefaultPass = "default&lt;O0&gt;"; break;&#13;
    case 1: DefaultPass = "default&lt;O1&gt;"; break;&#13;
    case 2: DefaultPass = "default&lt;O2&gt;"; break;&#13;
    case 3: DefaultPass = "default&lt;O3&gt;"; break;&#13;
    case -1: DefaultPass = "default&lt;Os&gt;"; break;&#13;
    case -2: DefaultPass = "default&lt;Oz&gt;"; break;&#13;
    }&#13;
    if (auto Err = PB.parsePassPipeline(&#13;
            MPM, DefaultPass)) {&#13;
      WithColor::error(errs(), Argv0)&#13;
          &lt;&lt; toString(std::move(Err)) &lt;&lt; "\n";&#13;
      return false;&#13;
    }&#13;
  }</pre></li>				<li>With that, the <a id="_idIndexMarker447"/>pass pipeline to run transformations on the IR code has been set up. After this step, we need an open file to write the result to. The system assembler and LLVM IR output are text-based, so we should set the <strong class="source-inline">OF_Text</strong> flag <span class="No-Break">for them:</span><pre class="source-code">&#13;
  std::error_code EC;&#13;
  sys::fs::OpenFlags OpenFlags = sys::fs::OF_None;&#13;
  CodeGenFileType FileType = codegen::getFileType();&#13;
  if (FileType == CGFT_AssemblyFile)&#13;
    OpenFlags |= sys::fs::OF_Text;&#13;
  auto Out = std::make_unique&lt;llvm::ToolOutputFile&gt;(&#13;
      outputFilename(InputFilename), EC, OpenFlags);&#13;
  if (EC) {&#13;
    WithColor::error(errs(), Argv0)&#13;
        &lt;&lt; EC.message() &lt;&lt; '\n';&#13;
    return false;&#13;
  }</pre></li>				<li>For the code generation process, we have to use the old pass manager. We must simply declare the <strong class="source-inline">CodeGenPM</strong> instances and add the pass, which makes target-specific information available at the IR <span class="No-Break">transformation level:</span><pre class="source-code">&#13;
  legacy::PassManager CodeGenPM;&#13;
  CodeGenPM.add(createTargetTransformInfoWrapperPass(&#13;
      TM-&gt;getTargetIRAnalysis()));</pre></li>				<li>To output<a id="_idIndexMarker448"/> LLVM IR, we must add a pass that prints the IR into <span class="No-Break">a stream:</span><pre class="source-code">&#13;
  if (FileType == CGFT_AssemblyFile &amp;&amp; EmitLLVM) {&#13;
    CodeGenPM.add(createPrintModulePass(Out-&gt;os()));&#13;
  }</pre></li>				<li>Otherwise, we must let the <strong class="source-inline">TargetMachine</strong> instance add the required code generation passes, direc<a id="_idTextAnchor127"/>ted by the <strong class="source-inline">FileType</strong> value we pass as <span class="No-Break">an argument:</span><pre class="source-code">&#13;
  else {&#13;
    if (TM-&gt;addPassesToEmitFile(CodeGenPM, Out-&gt;os(),&#13;
                                nullptr, FileType)) {&#13;
      WithColor::error()&#13;
          &lt;&lt; "No support for file type\n";&#13;
      return false;&#13;
    }&#13;
  }</pre></li>				<li>After all this preparation, we are now ready to execute the passes. First, we must run the optimization pipeline on the IR module. Next, the code generation passes are run. Of course, after all this work, we want to keep the <span class="No-Break">output file:</span><pre class="source-code">&#13;
  MPM.run(*M, MAM);&#13;
  CodeGenPM.run(*M);&#13;
  Out-&gt;keep();&#13;
  return true;&#13;
}</pre></li>				<li>That was<a id="_idIndexMarker449"/> a lot of code, but the process was straightforward. Of course, we have to update the dependencies in the <strong class="source-inline">tools/driver/CMakeLists.txt</strong> build file too. Besides adding the target components, we must add all the transformation and code generation components from LLVM. The names roughly resemble the directory names where the source is located. The component name is translated into the link library name during the <span class="No-Break">configuration process:</span><pre class="source-code">&#13;
set(LLVM_LINK_COMPONENTS ${LLVM_TARGETS_TO_BUILD}&#13;
  AggressiveInstCombine Analysis AsmParser&#13;
  BitWriter CodeGen Core Coroutines IPO IRReader&#13;
  InstCombine Instrumentation MC ObjCARCOpts Remarks&#13;
  ScalarOpts Support Target TransformUtils Vectorize&#13;
  Passes)</pre></li>				<li>Our compiler driver supports plugins, and we must announce <span class="No-Break">this support:</span><pre class="source-code">&#13;
add_tinylang_tool(tinylang Driver.cpp SUPPORT_PLUGINS)</pre></li>				<li>As before, we have to link against our <span class="No-Break">own libraries:</span><pre class="source-code">&#13;
target_link_libraries(tinylang&#13;
  PRIVATE tinylangBasic tinylangCodeGen&#13;
  tinylangLexer tinylangParser tinylangSema)</pre><p class="list-inset">These are necessary additions to the source code and the <span class="No-Break">build system.</span></p></li>				<li>To build the extended compiler, you must change into your <strong class="source-inline">build</strong> directory and type <span class="No-Break">the following:</span><pre class="source-code">&#13;
<strong class="bold">$ ninja</strong></pre></li>			</ol>&#13;
			<p>Changes to the files of the build system are automatically detected, and <strong class="source-inline">cmake</strong> is run before compiling and linking our changed source. If you need to re-run the configuration step, please follow the instructions in <a href="B19561_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Installing LLVM</em>, the <em class="italic">Compiling the tinylang </em><span class="No-Break"><em class="italic">application</em></span><span class="No-Break"> section.</span></p>&#13;
			<p>As we have used the options for the <strong class="source-inline">opt</strong> tool as a blueprint, you should try running <strong class="source-inline">tinylang</strong> with the options to load a pass plugin and run the pass, as we did in the <span class="No-Break">previous sections.</span></p>&#13;
			<p>With the current<a id="_idIndexMarker450"/> implementation, we can either run a default pass pipeline or we can construct one ourselves. The latter is very flexible, but in almost all cases, it would be overkill. The default pipeline runs very well for C-like languages. However, what is missing is a way to extend the pass pipeline. We’ll look at how to implement this in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-125"><a id="_idTextAnchor128"/>Extending the pass pipeline</h2>&#13;
			<p>In the previous<a id="_idIndexMarker451"/> section, we used the <strong class="source-inline">PassBuilder</strong> class to create a pass pipeline, either from a user-provided description or a predefined name. Now, let’s look at another way to customize the pass pipeline: using <span class="No-Break">extension points.</span></p>&#13;
			<p>During the construction of the pass pipeline, the pass builder allows passes contributed by the user to be added. These places are<a id="_idIndexMarker452"/> called <strong class="bold">extension points</strong>. A couple of extension points exist, <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li>The pipeline start extension point, which allows us to add passes at the beginning of <span class="No-Break">the pipeline</span></li>&#13;
				<li>The peephole extension point, which allows us to add passes after each instance of the instruction <span class="No-Break">combiner pass</span></li>&#13;
			</ul>&#13;
			<p>Other extension points exist too. To employ an extension point, you must register a callback. During the construction of the pass pipeline, your callback is run at the defined extension point and can add passes to the given <span class="No-Break">pass manager.</span></p>&#13;
			<p>To register a callback for the pipeline start extension point, you must call the <strong class="source-inline">registerPipelineStartEPCallback()</strong> method of the <strong class="source-inline">PassBuilder</strong> class. For example, to add our <strong class="source-inline">PPProfiler</strong> pass to the beginning of the pipeline, you would adapt the pass to be used as a module pass with a call to the <strong class="source-inline">createModuleToFunctionPassAdaptor()</strong> template function and then add the pass to the module <span class="No-Break">pass manager:</span></p>&#13;
			<pre class="source-code">&#13;
PB.registerPipelineStartEPCallback(&#13;
    [](ModulePassManager &amp;MPM) {&#13;
        MPM.addPass(PPProfilerIRPass());&#13;
    });</pre>			<p>You can add this snippet in the pass pipeline setup code anywhere before the pipeline is created – that is, before the <strong class="source-inline">parsePassPipeline()</strong> method <span class="No-Break">is called.</span></p>&#13;
			<p>A very natural <a id="_idIndexMarker453"/>extension to what we did in the previous section is to let the user pass a pipeline description for an extension point on the command line. The <strong class="source-inline">opt</strong> tool allows this too. Let’s do this for the pipeline start extension point. Add the following code to the <span class="No-Break"><strong class="source-inline">tools/driver/Driver.cpp</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>First, we must a new command line for the user to specify the pipeline description. Again, we take the option name from the <span class="No-Break"><strong class="source-inline">opt</strong></span><span class="No-Break"> tool:</span><pre class="source-code">&#13;
static cl::opt&lt;std::string&gt; PipelineStartEPPipeline(&#13;
    "passes-ep-pipeline-start",&#13;
    cl::desc("Pipeline start extension point));</pre></li>				<li>Using a Lambda function as a callback is the most convenient way to do this. To parse the pipeline description, we must call the <strong class="source-inline">parsePassPipeline()</strong> method of the <strong class="source-inline">PassBuilder</strong> instance. The passes are added to the <strong class="source-inline">PM</strong> pass manager and given as an argument to the Lambda function. If an error occurs, we only print an error message without stopping the application. You can add this snippet after the call to the <span class="No-Break"><strong class="source-inline">crossRegisterProxies()</strong></span><span class="No-Break"> method:</span><pre class="source-code">&#13;
  PB.registerPipelineStartEPCallback(&#13;
      [&amp;PB, Argv0](ModulePassManager &amp;PM) {&#13;
        if (auto Err = PB.parsePassPipeline(&#13;
                PM, PipelineStartEPPipeline)) {&#13;
          WithColor::error(errs(), Argv0)&#13;
              &lt;&lt; "Could not parse pipeline "&#13;
              &lt;&lt; PipelineStartEPPipeline.ArgSt<a id="_idTextAnchor129"/>r &lt;&lt; ": "&#13;
              &lt;&lt; toString(std::move(Err)) &lt;&lt; "\n";&#13;
        }&#13;
      });</pre></li>			</ol>&#13;
			<p class="callout-heading">Tip</p>&#13;
			<p class="callout">To allow the user to add passes at every extension point, you need to add the preceding code snippet for each <span class="No-Break">extension point.</span></p>&#13;
			<ol>&#13;
				<li value="3">Now is <a id="_idIndexMarker454"/>a good time to try out the different <strong class="source-inline">pass manager</strong> options. With the <strong class="source-inline">--debug-pass-manager</strong> option, you can follow which passes are executed in which order. You can also print the IR before or after each pass, which is invoked with the <strong class="source-inline">--print-before-all</strong> and <strong class="source-inline">--print-after-all</strong> options. If you created your own pass pipeline, then you can insert the <strong class="source-inline">print</strong> pass in points of interest. For example, try the <strong class="source-inline">--passes="print,inline,print"</strong> option. Furthermore, to identify which pass changes the IR code, you can use the <strong class="source-inline">--print-changed</strong> option, which will only print the IR code if it has changed compared to the result from the pass before. The greatly reduced output makes it much easier to follow <span class="No-Break">IR transformations.</span><p class="list-inset">The <strong class="source-inline">PassBuilder</strong> class has a nested <strong class="source-inline">OptimizationLevel</strong> class to represent the six different optimization levels. Instead of using the <strong class="source-inline">"default&lt;O?&gt;" </strong>pipeline description as an argument to the <strong class="source-inline">parsePassPipeline()</strong> method, we can also call the <strong class="source-inline">buildPerModuleDefaultPipeline()</strong> method, which builds the default optimization pipeline for the request level – except for level <strong class="source-inline">O0</strong>. This optimization level means that no optimization <span class="No-Break">is performed.</span></p><p class="list-inset">Consequently, no passes are added to the pass manager. If we still want to run a certain pass, then we can add it to the pass manager manually. A simple pass to run at this level is the <strong class="source-inline">AlwaysInliner</strong> pass, which inlines a function marked with the <strong class="source-inline">always_inline</strong> attribute into the caller. After translating the command-line option value for the optimization level into the corresponding member <a id="_idIndexMarker455"/>of the <strong class="source-inline">OptimizationLevel</strong> class, we can implement this <span class="No-Break">as follows:</span></p><pre class="source-code">&#13;
    PassBuilder::OptimizationLevel Olevel = …;&#13;
    if (OLevel == PassBuilder::OptimizationLevel::O0)&#13;
      MPM.addPass(AlwaysInlinerPass());&#13;
    else&#13;
      MPM = PB.buildPerModuleDefaultPipeline(OLevel, DebugPM);</pre><p class="list-inset">Of course, it is possible to add more than one pass to the pass manager in this fashion. <strong class="source-inline">PassBuilder</strong> also uses the <strong class="source-inline">addPass()</strong> method when constructing the <span class="No-Break">pass pipeline.</span></p></li>			</ol>&#13;
			<p class="callout-heading">Running extension point callbacks</p>&#13;
			<p class="callout">Because the pass pipeline is not populated for optimization level <strong class="source-inline">O0</strong>, the registered extension points are not called. If you use the extension points to register passes that should also run at <strong class="source-inline">O0</strong> level, this is problematic. You can call the <strong class="source-inline">runRegisteredEPCallbacks()</strong> method to run the registered extension point callbacks, resulting in a pass manager populated only with the passes that were registered through the <span class="No-Break">extension points.</span></p>&#13;
			<p>By adding the optimization pipeline to <strong class="source-inline">tinylang</strong>, you created an optimizing compiler similar to <strong class="source-inline">clang</strong>. The LLVM community works on improving the optimizations and the optimization pipeline with each release. Due to this, it is very seldom that the default pipeline is not used. Most often, new<a id="_idIndexMarker456"/> passes are added to implement certain semantics of the <span class="No-Break">programming language.</span></p>&#13;
			<h1 id="_idParaDest-126"><a id="_idTextAnchor130"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to create a new pass for LLVM. You ran the pass using a pass pipeline description and an extension point. You extended your compiler with the construction and execution of a pass pipeline similar to <strong class="source-inline">clang</strong>, turning <strong class="source-inline">tinylang</strong> into an optimizing compiler. The pass pipeline allows the addition of passes at extension points, and you learned how you can register passes at these points. This allows you to extend the optimization pipeline with your developed passes or <span class="No-Break">existing passes.</span></p>&#13;
			<p>In the next chapter, you will learn the basics of the <strong class="bold">TableGen</strong> language, which is used extensively in LLVM and <strong class="source-inline">clang</strong> to significantly reduce <span class="No-Break">manual programming.</span></p>&#13;
		</div>&#13;
	</div></body></html>