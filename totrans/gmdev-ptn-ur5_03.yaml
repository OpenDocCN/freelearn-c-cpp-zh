- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UE5 Patterns in Action – Double Buffer, Flyweight, and Spatial Partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, you will have realized by now that Unreal Engine 5 is a really big
    engine. Behind the scenes, it already employs a lot of the patterns that we will
    cover in later chapters. This chapter will break down the **double buffer**, **flyweight**,
    and **spatial partitioning** patterns. You don’t need to build these three patterns
    yourself as Unreal already has good implementations, but knowledge of their existence
    and how they have been created will help you build on top of them. This chapter
    will look into how Unreal implements each pattern into a system and what problems
    they are solving for you in the process. This should give you a roadmap to not
    only discover more about the engine but also some examples of good practice to
    reference moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Double buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spatial partitioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to delve into three patterns that are important
    to how any commercial engine performs. There will be some use of **Big O notation**,
    which is simply a low-resolution way of measuring the time efficiency of an algorithm.
    The lower the resulting number when replacing the *n* with a large number, such
    as 1,000, the better the time efficiency. For example, an algorithm that compares
    each element of an array with every other element of the same array could be described
    as O(*n*2). This comes from the idea that the algorithm is a couple of nested
    for loops that run for the length of the input data. Maybe then we improve efficiency,
    meaning we don’t need to recheck elements as we go through making the seconds
    for the loop shorter with each iteration. This would result in O(*n* log2*n*).
    Looking at these values, you can tell that for large numbers, O(*n*2) is far worse,
    giving an estimated cost of 1,000,000 executions for an array of size 1,000, whereas
    the same array put into O(*n* log2*n* ) costs only 9,965 executions.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, we will once again make use of some example files. You
    can grab these from the [*Chapter 3*](B18297_03.xhtml#_idTextAnchor046) branch
    on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter03](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter03)
  prefs: []
  type: TYPE_NORMAL
- en: Double buffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this pattern, we need to imagine a photocopier being operated by an artist.
    The artist has been commissioned to deliver at least two copies of every picture
    they draw, so they think smart and use a photocopier to copy their work. To save
    time moving artwork from the easel to the copier, they simply put their canvas
    straight onto the scanner. They then paint as fast as they can and hit *Copy*
    at the same time. What follows is a race where the artist needs to paint each
    line fast enough to stay ahead of the scanning head. If they are successful, the
    artwork and the copy will look the same with no extra time taken. More than likely,
    the scanning head will get in front of the artist, which will result in a picture
    up until the point where the artist fell behind and a blank copy after that point.
    This is known as **frame tearing**, the issue we are trying to solve. Frame tearing
    occurs when the frame buffer, our example artist’s canvas, has not been fully
    updated by the time the read pointer passes over it to draw to the display. This
    was a big problem back in the early days of graphics, where you only have 76 clock
    cycles to load the next row of pixels into the frame buffer before it was dispatched
    to the display. This perpetual race with the GPU, which immediately restarts once
    it finishes, creates a problem for graphics programmers. *Figure 3**.1* shows
    how the artifacts created due to frame tearing can cause issues for the person
    viewing the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Image showing visual artifacts created by screen tearing in
    two places](img/Figure_03.01_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Image showing visual artifacts created by screen tearing in two
    places
  prefs: []
  type: TYPE_NORMAL
- en: If this issue occurs frequently in a game being played at a standard 60 frames
    per second, it can cause everything from dissatisfaction with the game to nausea.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.2* shows what visually happens when the read pointer (red) starts
    behind the write pointer (green): in the middle column, the write pointer is overtaken
    by the read pointer, meaning from this point on, none of the work done by the
    write pointer will make it to the screen as the read pointer will have already
    read that pixel data. This will result in the screen looking like the right column,
    even though all the data was rendered to the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Diagram showing how race conditions between the read (red) and
    write (green) pointers cause frame tearing](img/Figure_03.02_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Diagram showing how race conditions between the read (red) and
    write (green) pointers cause frame tearing
  prefs: []
  type: TYPE_NORMAL
- en: 'This raises the question: how can we calculate all the shaders required to
    draw every visible object in this strict time limit?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is to not try to. Instead of optimizing to beat the current situation,
    we can change the situation. Currently, the display is catching the write pointer
    mid-calculation; instead, we could draw our picture to a different buffer, a back
    buffer. This allows the GPU to calculate in peace with no fear that the half-finished
    image will be shoved in the face of an unsuspecting viewer. Once the new frame
    is calculated into the back buffer, a pointer changes to make this new picture
    the new active frame buffer. The next time the GPU needs to send data to the screen,
    we know the image is finished. In *Figure 3**.3*, we can see that although the
    read pointer overtakes the write pointer in the middle column, because it is pulling
    from a buffer that is complete, no tear is rendered to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Diagram showing the screen (top) rendering from the frame buffer
    (middle) while the write pointer works on the back buffer (bottom)](img/Figure_03.03_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Diagram showing the screen (top) rendering from the frame buffer
    (middle) while the write pointer works on the back buffer (bottom)
  prefs: []
  type: TYPE_NORMAL
- en: In slow calculations, this means that an old image will be displayed on the
    screen for maybe multiple calls, as the new image can’t be completed in good time,
    but it is better to have this stutter than a tear across the middle of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: If the opposite was true and we well outpaced the display frequency of the attached
    monitor, then we have a lot of wasted time where the GPU simply waits. The backup
    artwork is ready to ship and the main one has not been taken yet. Most gamers
    know this as a setting called **vertical synchronization** (**VSync**). With VSync
    off, as soon as the back buffer is full, the back and frame buffers are swapped,
    which can lead to situations where one frame has a sudden drop in performance
    and there is no back buffer sitting in reserve to fill the visual gap. This does
    lead to more responsiveness as the image being shown is technically more recent,
    but the difference in latency between having the setting on and off is negligible
    in comparison to the visual issue of a screen tear.
  prefs: []
  type: TYPE_NORMAL
- en: Something we can do to increase our productivity during large VSync wait times
    is to use more buffers. This idea of a double buffer extends to infinity. Triple
    buffers would be efficient to implement if there is a chance that low refresh
    rate monitors will be used with high-end graphics cards. This way, once the first
    back buffer is full of data, the GPU can turn to another back buffer so as not
    to remain idle. When the display call comes through, the newest finished buffer
    becomes the frame buffer and all others, bar the one that is currently being filled,
    are wiped and sent to the back of the queue. This strategy is largely unnecessary
    with modern hardware, though, which is why Unreal only uses a double-buffered
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not so easy to find the exact place where this pattern is used within
    the Unreal Engine source code, as it has a different implementation for each render
    pipeline. By default, Unreal launches with **DirectX**. DirectX is a graphics
    pipeline designed for use on the Windows platform by Microsoft and has built-in
    methods for creating and managing frame buffers. DirectX calls the double buffer
    process the **swap chain**. This particular implementation can be found by navigating
    to your Unreal Engine 5 install folder and heading to the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<``UE_5.0 folder>\Engine\Source\Runtime\Windows\D3D11RHI\`'
  prefs: []
  type: TYPE_NORMAL
- en: This folder contains all the DirectX-specific files in the public and private
    folders. This includes files such as `D3D11Viewport.cpp`, which contains the editor
    implementation of a swap chain of buffers. These files are very dense DirectX
    code, and so won’t be covered in great detail here, but this is a good starting
    point to explore how Unreal deals with its graphics pipeline. Keep in mind that
    Unreal Engine also supports **Vulkan**, and this has a different implementation.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may be considering double buffers as a low-level tool. Primarily,
    they are, but you can use them for other high-level gameplay situations. Any time
    that data gathering and processing has been parallelized to run on multiple threads,
    a double buffer could be used to make sure processing is being done on cohesive
    data. This could take the form of heatmap analytics, keeping track of where players
    die on a level, or AI gathering data about its surroundings to make decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move from a system running under your code all the time to an automatic
    process within the engine that silently boosts your game efficiency: the flyweight
    pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The flyweight pattern is focused on reducing memory usage for large collections
    of objects and reducing the time spent loading them in. For the flyweight pattern,
    we first need to consider three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intrinsic data** – The data values that are immutable and considered to always
    be true on an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extrinsic data** – The data values that are mutable and considered to be
    changeable per instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory costs** – All data must be stored somewhere and for loaded objects,
    that means on our RAM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that in mind, let’s look at trees in the forest. Taking a simple approach,
    we could load in and store the model, texture, and transform data once for each
    tree. This would make our data storage look like *Figure 3**.4*, with each tree
    connected to its own plot of memory, holding its copy of the data needed for rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Diagram showing the data associated with each tree](img/Figure_03.04_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Diagram showing the data associated with each tree
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider the memory cost of a **model** and **texture** combined to be
    about 5 MB and the transform component to be 12 bytes of data per tree, then our
    memory footprint for three trees is a little over 15 MB. This may not seem like
    much, but it scales badly. Considering a forest of 100 trees, we would need a
    little over 500 MB of RAM to hold what is essentially set dressing. Something
    must be done, so let’s consider what data in the concept of a tree can be considered
    intrinsic, and what needs to remain extrinsic to each tree. As all our trees are
    identical to look at, all the data for visuals (model and texture data) can probably
    be safely made intrinsic. Great, we have a definite set of data that is each type;
    so what? Well, the flyweight pattern places all data we consider to be intrinsic
    in shared memory. In practice, this looks like *Figure 3**.5*, where all intrinsic
    visual data that will be shared between all trees has been collected into a shared
    block and you can spatially visualize the difference in memory cost. Things like
    the objects transform still remain extrinsic, as each tree will at least have
    a different position vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Diagram showing how the separation of intrinsic data saves memory
    with repeated objects spatially](img/Figure_03.05_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Diagram showing how the separation of intrinsic data saves memory
    with repeated objects spatially
  prefs: []
  type: TYPE_NORMAL
- en: In terms of memory allocation, the implemented flyweight pattern has a fixed
    cost of 5 MB for the shared model and texture data and a variable cost of 12 bytes
    per tree. This means our forest of 100 trees now only takes up 5.1 MB, which is
    a far cry from the 500 MB we needed previously.
  prefs: []
  type: TYPE_NORMAL
- en: With the basics down, let’s investigate how our system might break. Well, we
    obviously get a benefit from sharing data, but what if we wanted two types of
    trees in our forest with different model and texture data? You’d think, based
    on the previous explanation, that this would make that data extrinsic and therefore
    not eligible for the flyweight pattern. However, you can invoke the type object
    pattern, which we will discuss in greater detail in a later chapter. The type
    object pattern collects intrinsic data about a *type* and applies the same idea.
    This calculation for memory cost would then look like the amount of types you
    have multiplied by 5 MB, plus 12 bytes per object in the world. The type object
    pattern, of course, has some other benefits that we will look at in [*Chapter
    9*](B18297_09.xhtml#_idTextAnchor130), but this is how it pairs with the flyweight
    pattern to give an expandable, efficient system.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine applies the flyweight pattern by default to every asset loaded
    into a project. Assets are then referenced from a single place when needed and
    their data is shared across all references. If you need to make a change to a
    specific loaded version of an asset, you need to actively break the flyweight
    pattern to do so. An example of where this may be needed is in dynamic material
    instances. Some value may be needed to alter the appearance of only one object
    in the scene, so a copy of the intrinsic data for the material must be made.
  prefs: []
  type: TYPE_NORMAL
- en: The last pattern for this chapter is less automatic and silent than the previous
    two. It is a subsystem designed around making vast worlds possible and performant
    to play in. In Unreal Engine, we call it **World Partition** (based on the toolset
    available in the editor to manage how a large-scale world is split up), but more
    generally it is known as the spatial partitioning pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine the Matrix is a real concept, and we are living in a giant physics
    simulation. Anybody who has dabbled in physics simulations knows that you don’t
    need many interacting objects to make the simulation chug. The naïve solution
    is to check every object against every other object leading to an *O(n**2**-n)*
    solution, where you can see in *Figure 3**.6* that 4 objects have 12 collision
    checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Diagram showing each collision check performed in an inefficient
    collision detection solution](img/Figure_03.06_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Diagram showing each collision check performed in an inefficient
    collision detection solution
  prefs: []
  type: TYPE_NORMAL
- en: Improvements can obviously be made to not repeat calculations that have already
    been made, bringing us down to *O(nLog2(n))* where those same four points use
    only six collision checks. This is better, but there is only so far we can go
    by checking every object against every other object. We could just not calculate
    some of them, but that would be like giving some people in our Matrix simulation
    wall hacks, allowing them to possibly phase through walls, or worse, each other.
  prefs: []
  type: TYPE_NORMAL
- en: We could check the distance between objects before we check their collisions.
    This would mean objects far apart would not even try to collide. This may work
    for more complex collision geometries but realistically, if we are smart developers
    using only primitives for collision, we would just be adding to all the calculations.
    This would in the worst case lower the efficiency to *O(nLog2(n) + n)*. The theory
    has merit, though, so instead of checking every object we should instead group
    them based on geography. The world needs to be divided into cells; we’ll call
    them chunks. Each cell knows the objects it fully encompasses and its position
    in the grid of cells. We need only then to check collisions between objects in
    neighboring cells. This is the basis of spatial partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: What if an object is bigger than the cell it is centered on? We can group cells
    together into a bigger chunk and include any objects that cross the cell boundaries
    that the new cell group fully encompasses. This process is then repeated until
    the cell contains the whole world. This creates a tree structure of cells. To
    then check an object’s collision, only objects in the tree directly connected
    above and below need to be checked. This has the potential to cut out most checks
    we would have otherwise done.
  prefs: []
  type: TYPE_NORMAL
- en: 'One issue is how we establish where each object is in the tree. This does have
    some overhead cost, meaning for small simulations, it is wild overkill. That said,
    if you are going to use this across your entire world and only update the tree
    positions of moving objects, you end up with massive efficiency gains. 2D implementations
    might follow a structure called a **quadtree** (pictured in *Figure 3**.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Diagram showing how a quadtree can reduce the number of needed
    collision checks (green) to eight for these six objects (red) when they are in
    these positions](img/Figure_03.07_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Diagram showing how a quadtree can reduce the number of needed
    collision checks (green) to eight for these six objects (red) when they are in
    these positions
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can clearly see how objects in different cells (or quads) do not check
    collision with each other. As an object crosses a boundary, it starts existing
    in the cell a layer above and must check collision with all objects in child cells.
    Generally, this is not the case, and so with a large number of objects, there
    will always be a performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unreal Engine 5 uses the idea of a quadtree in three dimensions called an `Fscene`
    class and is used by the render thread to determine quickly whether an object
    exists in the light’s area of effect. This way, the number of lighting calculations
    is drastically reduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Screenshot of the octree location in the ScenePrivate.h file](img/Figure_03.08_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Screenshot of the octree location in the ScenePrivate.h file
  prefs: []
  type: TYPE_NORMAL
- en: Extra note
  prefs: []
  type: TYPE_NORMAL
- en: If you drill down through the struct and class definitions from the line pictured
    in *Figure 3**.8*, you will eventually find a `Toctree2` class name (the first
    one has been deprecated). In this class, you can explore Epic’s implementation
    of the octree.
  prefs: []
  type: TYPE_NORMAL
- en: That is not all. With Unreal Engine 5 comes the introduction of a system called
    World Partition. This is another implementation of a spatial partition, this time
    in two dimensions, that is used for a different purpose. As a developer, you must
    define what size cell Unreal should use, and unlike the tree variants, this is
    limited to a single layer of depth. That being said, it does provide a fast way
    of hooking up large worlds with **level of detail** (**LOD**) systems to affect
    everything from visuals to collision meshes. LOD systems are used to reduce how
    much detail is being rendered (in either a 3D mesh or texture) when the object
    being rendered appears smaller on the screen. So, an object further away from
    the screen will feature an LOD mesh that has a much lower triangle count than
    if the same object was drawn directly in front of the player.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at exploring World Partition by looking at an example map
    we’ve provided that uses an Open World level. We will begin by looking at how
    the example works, then change some variables to get different results to better
    understand how the system works. The example levels used for this section are
    available in the `PatternsInAction` project on GitHub that is linked at the start
    of the chapter. Unlike in [*Chapter 2*](B18297_02.xhtml#_idTextAnchor031), this
    time we have provided a full Unreal Project, and this time, you can extract the
    `.zip` contents and double-click on the `PatternsInAction.uproject` file.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing World Partition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, open the `WorldPartitionExample` map file from the `Content\Maps`
    folder. This map should open by default when you launch the project but in case
    it doesn’t, navigate to **File** | **Open Level** and select it from the directories.
    You should then see a world with a series of blueprint actors, all of which are
    displayed as primitive shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – World Partition example map from the PatternsinAction project](img/Figure_03.09_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – World Partition example map from the PatternsinAction project
  prefs: []
  type: TYPE_NORMAL
- en: This level already has World Partition enabled and set up for the terrain. This
    is standard for the Open World level template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the World Partition setting tool so we can see how it
    works. If it hasn’t opened by default, go to **Window** | **World Partition**
    | **World** **Partition Editor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Accessing the World Partition Editor from the menus](img/Figure_03.10_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Accessing the World Partition Editor from the menus
  prefs: []
  type: TYPE_NORMAL
- en: 'This should open **World Partition Editor** in the same section of the user
    interface as the **Details** tab; you can zoom in using your scroll wheel, after
    which you will eventually be able to see the grid reference system for the map
    (provided you have turned on **Show Cell Coords** in the top menu of the **World
    Partition** editor). It’s worth noting that this grid does not directly relate
    to the cell grid produced by the World Partition system. Instead, it offers a
    grid based on an editor cell size which, by default, is set to 12,800 (128 square
    meters), half the size of the default World Partition cell, which is 25,600 (256
    square meters):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – World Partition editor tab, resized horizontally so the text
    on the left is visible (left) and then zoomed in with Show Grid Coords ON to show
    the grid reference system (right)](img/Figure_03.11_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – World Partition editor tab, resized horizontally so the text on
    the left is visible (left) and then zoomed in with Show Grid Coords ON to show
    the grid reference system (right)
  prefs: []
  type: TYPE_NORMAL
- en: World Partition splits (partitions) the world based on a cell grid, with each
    cell corresponding to a physical section of the level. If an actor’s bounding
    box is in that cell, it will be drawn (or hidden) depending on whether the cell
    is within a set distance of a **streaming source** (an entity in the world that
    controls when World Partition cells are loaded), such as the player character
    or an actor with a World Partition streaming source component. This allows Unreal
    to divide the map and only draw the required cells, making it possible for developers
    to build incredibly large maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the distance from a streaming source that a cell must be within
    to be drawn, the engine uses the **Loading Range** variable, which can be found
    in **World Settings** | **World Partition** | **Runtime Settings** | **Grids**
    | **Index [0]**. The value of **Loading Range** sets the radius from the character
    that a cell needs to be within for it to be loaded and rendered. The default value
    for **Loading Range** is 76,800, which is shown in **Unreal Units** (uu). 1 uu
    = 1 cm, so the default radius is the in-game equivalent of 768 m:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – World Partition rollout of the World Settings tab showing the
    grid settings](img/Figure_03.12_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – World Partition rollout of the World Settings tab showing the
    grid settings
  prefs: []
  type: TYPE_NORMAL
- en: The **Index [0]** section of **World Settings** also contains variables to determine
    the size of each cell on the grid. In a built-up city environment, where the visible
    distance is shortened due to the height of buildings, you could set a smaller
    **Cell Size** value and **Loading Range** value compared to an open landscape,
    such as a desert.
  prefs: []
  type: TYPE_NORMAL
- en: While it may appear logical to significantly reduce the cell size and loading
    range, setting these too low will result in frame rate issues owing to a bottleneck
    caused by trying to load (and unload) too many cells at one time.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve had a look at how the cell grid is made up, we can start to look
    at how that cell grid controls when objects load and unload based on the position
    of streaming sources.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding when objects are loaded
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a better understanding of how World Partition works, we can change some
    of the **Runtime Settings** values in **Index [0]**. We will make changes to **Loading
    Range** and **Cell Size** to control the way World Partition works within our
    example map. The changes we make will adjust when the blueprints in the map are
    loaded and unloaded. Observing the differences will help you to experience World
    Partition (and spatial partitioning) in action.
  prefs: []
  type: TYPE_NORMAL
- en: Before we make any changes, press the *Play* button to play the level in the
    editor viewport. You should notice a stream of print strings on the left side
    of the screen. This is because each of the blueprint actors have been set up to
    print a short message and their display name.
  prefs: []
  type: TYPE_NORMAL
- en: Move around the map using typical first-person *W*, *A*, *S*, and *D* keys to
    control the character. You should notice that, if you move all the way to one
    side of the map, prints change as fewer objects are printing their messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve seen this effect, try changing `76800` to `768`, making the radius
    that objects need to be within to load 100 times smaller than the default settings.
    This will cause a significantly different result. Now, try testing the level once
    again. You should notice that only two objects are visible: a tall rectangular
    box and a cone, both of which are in front of the character from the starting
    position. These are visible because a small section of each mesh is inside a partition
    cell that is within a 7.68 m radius of the player character.'
  prefs: []
  type: TYPE_NORMAL
- en: Walking toward either object will eventually cause other objects to suddenly
    appear (you will need to get very close) as you get within range of the neighboring
    partition cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further understand why we get this behavior, let’s change the **World Partition
    Editor Cell** **Size** variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Below the **Runtime Settings** section we’ve used so far, expand the **Advanced**
    section by clicking the title or the arrow to the side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `25600` to match the **Cell Size** value from the **Index [0]** settings,
    ensuring our editor display matches the behavior we are experiencing when we play
    the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have made the change, rebuild the Minimap by navigating to **Build**
    | **Build Minimap** from the top menu. You will be asked to save the level and
    any modified assets, and then you will be shown a series of progress bars while
    the build takes place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch back to the **World Partition** editor tab; you should now see a lot
    fewer cells in the grid, as shown in *Figure 3**.13*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Updated editor cell display showing how the visible objects
    are partially inside the initially loaded cells (-1,0) and (0,0)](img/Figure_03.13_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Updated editor cell display showing how the visible objects are
    partially inside the initially loaded cells (-1,0) and (0,0)
  prefs: []
  type: TYPE_NORMAL
- en: 'The grid should now show where each of the actors is positioned, with at least
    one of each of the object types (cone and cube) in a grid cell that the character
    starts within (or very close to). The second object of each pair sits in the neighboring
    grid cell, so will only appear once the player character is within 7.68 m of the
    cell, which is a very short distance when you consider each cell is 256 m x 256
    m and the default loading range that we changed was originally a radius of 768
    m. Based on the default values, when the character stands at the starting location
    at the origin of the grid, 36 of the cells are being loaded as opposed to the
    4 that are loaded with the shortened range of 7.68 m, which would be inappropriate
    for use in a game but works as an extreme example of how the system works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Visual representation of the overlapping area of a 768 m radius
    circle over 256 m x 256 m grid cells, resulting in 36 cells being loaded compared
    to a radius of 7.68 m (inner circle) only overlapping 4](img/Figure_03.14_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Visual representation of the overlapping area of a 768 m radius
    circle over 256 m x 256 m grid cells, resulting in 36 cells being loaded compared
    to a radius of 7.68 m (inner circle) only overlapping 4
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set an extreme value, try some different values, such as setting
    `38400`, which will result in more objects being loaded at any one point. Standing
    at the center of the map will load a similar number of visible objects to the
    default setting, but you will see the objects disappear much sooner as you walk
    away from them. Remember, you can always return to the default value of `76800`.
  prefs: []
  type: TYPE_NORMAL
- en: This shows how, with different loading ranges, we can control when parts of
    our 3D world appear. Getting the correct values for your game might require some
    testing and, in some cases, the inclusion of scalability settings to ensure your
    game runs on different hardware. For now, the key thing is understanding how to
    control when things load and unload based on streaming sources so that once you
    have a 3D world to control, you can make the most of World Partition.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring actors are loaded when required
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to ensure that actors are loaded and ready for the player.
    One option is to force an actor to always be loaded by preventing it from being
    loaded and unloaded by World Partition. This could be useful if you have managers
    in the world who are required to control aspects across the entire level, or if
    you have a monument that needs to be always visible. To do this, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the chosen actor in the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Details** panel, scroll down to the **World** **Partition** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15 – World Partition settings in the Details panel with an actor
    selected](img/Figure_03.15_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – World Partition settings in the Details panel with an actor selected
  prefs: []
  type: TYPE_NORMAL
- en: Set `OFF`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second approach is to include actors in the world that have a World Partition
    streaming source component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve included a `BP_StreamingSourceActor` blueprint, which has a World Partition
    streaming source component set up with the target grid already set up. To see
    it in action, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a `BP_StreamingSourceActor` blueprint from the `Content Browser/Blueprints`
    folder into the world between the two cone actors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `768` for testing purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When testing the level, you should now see that, unlike when we first set the
    loading range to `768`, both cone objects are visible.
  prefs: []
  type: TYPE_NORMAL
- en: You will, however, notice that after five seconds of gameplay, one of the cones
    (the furthest one from the player) will disappear. This is because the `BP_StreamingSourceActor`
    blueprint includes some crude code to toggle the streaming source on and off.
    This provides a nice insight into how a streaming source actor can be used to
    control loading cells ready for the player, in cases such as where the character
    will be teleported to a new location that needs to be fully loaded before the
    player is relocated.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.16* you can see the logic within the `BP_StreamingSourceActor`’s
    event graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Crude blueprint setup that disables and enables the streaming
    source every five seconds using a timer](img/Figure_03.16_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Crude blueprint setup that disables and enables the streaming
    source every five seconds using a timer
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored World Partition, we will look at using it with levels
    that have been created without it.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling World Partition on an existing level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To convert an existing level (that wasn’t created using the Open World starter
    map) to make use of World Partition, all you need to do is use the built-in tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the level you want to convert to a World Partition-enabled level is saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Tools** | **Convert Level** from the top menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the popup, select the map you would like to convert.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tool will create a new version of the map with the `_WP` suffix in the name
    unless you select **In Place** from the final settings dialog, which will simply
    overwrite your existing level.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed a number of existing patterns that are present
    in Unreal Engine, focusing on double buffer, flyweight, and spatial partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: We have taken a look at some of these systems, including exploring editor examples
    of spatial partitioning using the World Partition system, experimenting with different
    variables to control when objects are loaded and unloaded, and testing an actor
    with a World Partition streaming source component.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore some pre-made patterns in Unreal.
    We will be looking at creating components using the `update` method, and creating
    a simple AI-controlled **Real-Time Strategy** (**RTS**) game unit using Unreal’s
    AI **Behavior Trees**.
  prefs: []
  type: TYPE_NORMAL
