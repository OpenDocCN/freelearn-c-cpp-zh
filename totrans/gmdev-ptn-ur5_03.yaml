- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: UE5 Patterns in Action – Double Buffer, Flyweight, and Spatial Partitioning
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UE5模式实战 – 双缓冲、享元和空间分区
- en: Hopefully, you will have realized by now that Unreal Engine 5 is a really big
    engine. Behind the scenes, it already employs a lot of the patterns that we will
    cover in later chapters. This chapter will break down the **double buffer**, **flyweight**,
    and **spatial partitioning** patterns. You don’t need to build these three patterns
    yourself as Unreal already has good implementations, but knowledge of their existence
    and how they have been created will help you build on top of them. This chapter
    will look into how Unreal implements each pattern into a system and what problems
    they are solving for you in the process. This should give you a roadmap to not
    only discover more about the engine but also some examples of good practice to
    reference moving forward.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到现在你已经意识到，虚幻引擎5确实是一个非常大的引擎。在幕后，它已经采用了我们将在后续章节中介绍的大量模式。本章将解析**双缓冲**、**享元**和**空间分区**模式。你不需要自己构建这三个模式，因为虚幻引擎已经有了很好的实现。但是，了解它们的存续及其创建方式将有助于你在其基础上进行构建。本章将探讨虚幻引擎如何将每个模式实现为一个系统，以及它们在过程中为你解决的问题。这应该为你提供一条路线图，不仅可以帮助你更深入地了解引擎，还可以提供一些良好的实践示例供你参考。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Double buffer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双缓冲
- en: Flyweight
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元
- en: Spatial partitioning
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间分区
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we are going to delve into three patterns that are important
    to how any commercial engine performs. There will be some use of **Big O notation**,
    which is simply a low-resolution way of measuring the time efficiency of an algorithm.
    The lower the resulting number when replacing the *n* with a large number, such
    as 1,000, the better the time efficiency. For example, an algorithm that compares
    each element of an array with every other element of the same array could be described
    as O(*n*2). This comes from the idea that the algorithm is a couple of nested
    for loops that run for the length of the input data. Maybe then we improve efficiency,
    meaning we don’t need to recheck elements as we go through making the seconds
    for the loop shorter with each iteration. This would result in O(*n* log2*n*).
    Looking at these values, you can tell that for large numbers, O(*n*2) is far worse,
    giving an estimated cost of 1,000,000 executions for an array of size 1,000, whereas
    the same array put into O(*n* log2*n* ) costs only 9,965 executions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究三个对任何商业引擎性能都非常重要的模式。我们将使用一些**大O符号**，它只是衡量算法时间效率的一种低分辨率方式。当用大数（如1,000）替换*n*时，结果数字越低，时间效率越好。例如，一个将数组的每个元素与数组中其他每个元素进行比较的算法可以描述为O(*n*2)。这源于算法是由几个嵌套的for循环组成的，这些循环的运行长度等于输入数据长度。也许我们可以提高效率，这意味着我们不需要在遍历过程中重新检查元素，这样我们可以通过每次迭代缩短循环的秒数。这将导致O(*n*
    log2*n*)。查看这些值，你可以知道对于大数来说，O(*n*2)要差得多，对于一个大小为1,000的数组，其估计成本为1,000,000次执行，而将相同的数组放入O(*n*
    log2*n*)中，成本仅为9,965次执行。
- en: Later in the chapter, we will once again make use of some example files. You
    can grab these from the [*Chapter 3*](B18297_03.xhtml#_idTextAnchor046) branch
    on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter03](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter03)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们还将再次使用一些示例文件。你可以从GitHub上的[*第3章*](B18297_03.xhtml#_idTextAnchor046)分支获取这些文件，网址为[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter03](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter03)。
- en: Double buffer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双缓冲
- en: 'For this pattern, we need to imagine a photocopier being operated by an artist.
    The artist has been commissioned to deliver at least two copies of every picture
    they draw, so they think smart and use a photocopier to copy their work. To save
    time moving artwork from the easel to the copier, they simply put their canvas
    straight onto the scanner. They then paint as fast as they can and hit *Copy*
    at the same time. What follows is a race where the artist needs to paint each
    line fast enough to stay ahead of the scanning head. If they are successful, the
    artwork and the copy will look the same with no extra time taken. More than likely,
    the scanning head will get in front of the artist, which will result in a picture
    up until the point where the artist fell behind and a blank copy after that point.
    This is known as **frame tearing**, the issue we are trying to solve. Frame tearing
    occurs when the frame buffer, our example artist’s canvas, has not been fully
    updated by the time the read pointer passes over it to draw to the display. This
    was a big problem back in the early days of graphics, where you only have 76 clock
    cycles to load the next row of pixels into the frame buffer before it was dispatched
    to the display. This perpetual race with the GPU, which immediately restarts once
    it finishes, creates a problem for graphics programmers. *Figure 3**.1* shows
    how the artifacts created due to frame tearing can cause issues for the person
    viewing the screen:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种模式，我们需要想象一个由艺术家操作的复印机。艺术家被委托至少提供他们所画每张图片的两份副本，所以他们想得很聪明，使用复印机来复制他们的作品。为了节省从画架移动艺术品到复印机的时间，他们直接将画布放在扫描仪上。然后他们尽可能地快地画画，并同时在按下“复制”。接下来是一场赛跑，艺术家需要快速地画出每一笔，以保持在扫描头之前。如果他们成功了，艺术品和副本将看起来一样，而且不会花费额外的时间。更有可能的是，扫描头会超过艺术家，这会导致艺术家落后于某个点之前的图片，之后则是空白副本。这被称为**帧撕裂**，是我们试图解决的问题。帧撕裂发生在帧缓冲区，也就是我们例子中的艺术家画布，在读取指针经过它绘制到显示之前，尚未完全更新。这在图形的早期是一个大问题，当时你只有76个时钟周期来将下一行像素加载到帧缓冲区，然后将其发送到显示。与GPU的这种持续赛跑，一旦完成就立即重新开始，给图形程序员带来了问题。*图
    3.1* 展示了由于帧撕裂产生的伪影如何对观看屏幕的人造成问题：
- en: '![Figure 3.1 – Image showing visual artifacts created by screen tearing in
    two places](img/Figure_03.01_B18297.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 展示屏幕撕裂在两个位置产生的视觉伪影的图像](img/Figure_03.01_B18297.jpg)'
- en: Figure 3.1 – Image showing visual artifacts created by screen tearing in two
    places
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 展示屏幕撕裂在两个位置产生的视觉伪影的图像
- en: If this issue occurs frequently in a game being played at a standard 60 frames
    per second, it can cause everything from dissatisfaction with the game to nausea.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个问题在每秒60帧的标准游戏中频繁发生，它可能会导致从对游戏的不满到恶心等各种问题。
- en: '*Figure 3**.2* shows what visually happens when the read pointer (red) starts
    behind the write pointer (green): in the middle column, the write pointer is overtaken
    by the read pointer, meaning from this point on, none of the work done by the
    write pointer will make it to the screen as the read pointer will have already
    read that pixel data. This will result in the screen looking like the right column,
    even though all the data was rendered to the buffer:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.2* 展示了当读取指针（红色）开始落后于写入指针（绿色）时视觉上发生的情况：在中间列，写入指针被读取指针超过，这意味着从这一点开始，写入指针所做的所有工作都不会显示在屏幕上，因为读取指针已经读取了那些像素数据。这将导致屏幕看起来像右侧列，尽管所有数据都已渲染到缓冲区：'
- en: '![Figure 3.2 – Diagram showing how race conditions between the read (red) and
    write (green) pointers cause frame tearing](img/Figure_03.02_B18297.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 展示读取（红色）和写入（绿色）指针之间竞态条件导致帧撕裂的图](img/Figure_03.02_B18297.jpg)'
- en: Figure 3.2 – Diagram showing how race conditions between the read (red) and
    write (green) pointers cause frame tearing
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 展示读取（红色）和写入（绿色）指针之间竞态条件导致帧撕裂的图
- en: 'This raises the question: how can we calculate all the shaders required to
    draw every visible object in this strict time limit?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个问题：我们如何在严格的时间限制内计算出绘制每个可见对象所需的全部着色器？
- en: 'The answer is to not try to. Instead of optimizing to beat the current situation,
    we can change the situation. Currently, the display is catching the write pointer
    mid-calculation; instead, we could draw our picture to a different buffer, a back
    buffer. This allows the GPU to calculate in peace with no fear that the half-finished
    image will be shoved in the face of an unsuspecting viewer. Once the new frame
    is calculated into the back buffer, a pointer changes to make this new picture
    the new active frame buffer. The next time the GPU needs to send data to the screen,
    we know the image is finished. In *Figure 3**.3*, we can see that although the
    read pointer overtakes the write pointer in the middle column, because it is pulling
    from a buffer that is complete, no tear is rendered to the screen:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是不尝试。与其优化以打败当前情况，我们可以改变情况。目前，显示器在计算中途捕捉到写入指针；相反，我们可以在不同的缓冲区，即后台缓冲区中绘制我们的图像。这允许GPU在没有担心半成品图像会被推到不知情观众面前的恐惧中平静地计算。一旦新帧被计算到后台缓冲区，一个指针就会改变，使这张新图片成为新的活动帧缓冲区。下次GPU需要向屏幕发送数据时，我们知道图像已经完成。在*图3.3*中，我们可以看到，尽管读取指针在中列超过了写入指针，因为它是从一个完整的缓冲区中拉取的，所以屏幕上没有渲染撕裂：
- en: '![Figure 3.3 – Diagram showing the screen (top) rendering from the frame buffer
    (middle) while the write pointer works on the back buffer (bottom)](img/Figure_03.03_B18297.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 图表显示屏幕（顶部）从帧缓冲区（中间）渲染，同时写入指针在后台缓冲区（底部）工作](img/Figure_03.03_B18297.jpg)'
- en: Figure 3.3 – Diagram showing the screen (top) rendering from the frame buffer
    (middle) while the write pointer works on the back buffer (bottom)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 图表显示屏幕（顶部）从帧缓冲区（中间）渲染，同时写入指针在后台缓冲区（底部）工作
- en: In slow calculations, this means that an old image will be displayed on the
    screen for maybe multiple calls, as the new image can’t be completed in good time,
    but it is better to have this stutter than a tear across the middle of the screen.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓慢的计算中，这意味着旧图像可能会在屏幕上显示多次，因为新图像不能及时完成，但与屏幕中间的撕裂相比，这种卡顿更好。
- en: If the opposite was true and we well outpaced the display frequency of the attached
    monitor, then we have a lot of wasted time where the GPU simply waits. The backup
    artwork is ready to ship and the main one has not been taken yet. Most gamers
    know this as a setting called **vertical synchronization** (**VSync**). With VSync
    off, as soon as the back buffer is full, the back and frame buffers are swapped,
    which can lead to situations where one frame has a sudden drop in performance
    and there is no back buffer sitting in reserve to fill the visual gap. This does
    lead to more responsiveness as the image being shown is technically more recent,
    but the difference in latency between having the setting on and off is negligible
    in comparison to the visual issue of a screen tear.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果情况相反，并且我们远远超过了连接显示器的显示频率，那么GPU将会有很多浪费的时间，简单地等待。备用艺术品已经准备好发货，而主要的一个还没有被取走。大多数游戏玩家都知道这被称为**垂直同步**（**VSync**）的设置。关闭VSync后，一旦后台缓冲区充满，后台和帧缓冲区就会交换，这可能导致一种情况，即一个帧的性能突然下降，而没有后台缓冲区作为备用来填补视觉差距。这确实导致了更多的响应性，因为显示的图像在技术上更近，但开启和关闭设置之间的延迟差异与屏幕撕裂的视觉问题相比可以忽略不计。
- en: Something we can do to increase our productivity during large VSync wait times
    is to use more buffers. This idea of a double buffer extends to infinity. Triple
    buffers would be efficient to implement if there is a chance that low refresh
    rate monitors will be used with high-end graphics cards. This way, once the first
    back buffer is full of data, the GPU can turn to another back buffer so as not
    to remain idle. When the display call comes through, the newest finished buffer
    becomes the frame buffer and all others, bar the one that is currently being filled,
    are wiped and sent to the back of the queue. This strategy is largely unnecessary
    with modern hardware, though, which is why Unreal only uses a double-buffered
    system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型VSync等待时间期间提高我们生产力的一个方法就是使用更多的缓冲区。这种双缓冲的概念可以扩展到无限。如果有可能使用低端刷新率显示器与高端显卡配合，那么三缓冲将是一个高效的实现方式。这样，一旦第一个后缓冲区充满数据，GPU就可以转向另一个后缓冲区，以免保持空闲状态。当显示调用通过时，最新完成的缓冲区成为帧缓冲区，而所有其他缓冲区（除了当前正在填充的那个）都被清除并发送到队列的末尾。然而，这种策略在现代硬件中很大程度上是不必要的，这就是为什么虚幻引擎只使用双缓冲系统。
- en: 'It is not so easy to find the exact place where this pattern is used within
    the Unreal Engine source code, as it has a different implementation for each render
    pipeline. By default, Unreal launches with **DirectX**. DirectX is a graphics
    pipeline designed for use on the Windows platform by Microsoft and has built-in
    methods for creating and managing frame buffers. DirectX calls the double buffer
    process the **swap chain**. This particular implementation can be found by navigating
    to your Unreal Engine 5 install folder and heading to the following path:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎源代码中找到这个模式的确切位置并不容易，因为它为每个渲染管道有不同的实现。默认情况下，虚幻引擎使用**DirectX**。DirectX是微软为Windows平台设计的图形管道，内置了创建和管理帧缓冲区的方法。DirectX将双重缓冲过程称为**交换链**。这个特定的实现可以通过导航到您的虚幻引擎5安装文件夹并前往以下路径找到：
- en: '`<``UE_5.0 folder>\Engine\Source\Runtime\Windows\D3D11RHI\`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`<``UE_5.0 文件夹>\Engine\Source\Runtime\Windows\D3D11RHI\`'
- en: This folder contains all the DirectX-specific files in the public and private
    folders. This includes files such as `D3D11Viewport.cpp`, which contains the editor
    implementation of a swap chain of buffers. These files are very dense DirectX
    code, and so won’t be covered in great detail here, but this is a good starting
    point to explore how Unreal deals with its graphics pipeline. Keep in mind that
    Unreal Engine also supports **Vulkan**, and this has a different implementation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹包含公共和私有文件夹中所有与DirectX相关的文件。这包括如`D3D11Viewport.cpp`这样的文件，它包含了缓冲区交换链的编辑器实现。这些文件是高度密集的DirectX代码，因此在此不会详细说明，但这是一个探索虚幻如何处理其图形管道的好起点。请注意，虚幻引擎还支持**Vulkan**，这有不同的实现。
- en: At this point, you may be considering double buffers as a low-level tool. Primarily,
    they are, but you can use them for other high-level gameplay situations. Any time
    that data gathering and processing has been parallelized to run on multiple threads,
    a double buffer could be used to make sure processing is being done on cohesive
    data. This could take the form of heatmap analytics, keeping track of where players
    die on a level, or AI gathering data about its surroundings to make decisions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可能正在考虑双重缓冲作为一项低级工具。主要来说，它确实是，但您也可以在其他高级游戏玩法场景中使用它。任何数据收集和处理已经并行化以在多个线程上运行时，双重缓冲可以用来确保处理是在一致的数据上进行的。这可能包括热图分析，跟踪玩家在关卡中的死亡位置，或者AI收集其周围环境数据以做出决策。
- en: 'Let’s move from a system running under your code all the time to an automatic
    process within the engine that silently boosts your game efficiency: the flyweight
    pattern.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一直运行在您代码下的系统转变为在引擎内部自动运行的进程，这个进程默默地提高您的游戏效率：轻量级模式。
- en: Flyweight
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻量级
- en: 'The flyweight pattern is focused on reducing memory usage for large collections
    of objects and reducing the time spent loading them in. For the flyweight pattern,
    we first need to consider three things:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级模式专注于减少大量对象占用的内存以及减少加载它们所需的时间。对于轻量级模式，我们首先需要考虑以下三个因素：
- en: '**Intrinsic data** – The data values that are immutable and considered to always
    be true on an object'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部数据** – 不可变的数据值，被认为是对象上始终为真的'
- en: '**Extrinsic data** – The data values that are mutable and considered to be
    changeable per instance'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部数据** – 可变的数据值，被认为是每个实例可变的'
- en: '**Memory costs** – All data must be stored somewhere and for loaded objects,
    that means on our RAM'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存成本** – 所有数据都必须存储在某处，对于已加载的对象，这意味着在我们的RAM上'
- en: 'With that in mind, let’s look at trees in the forest. Taking a simple approach,
    we could load in and store the model, texture, and transform data once for each
    tree. This would make our data storage look like *Figure 3**.4*, with each tree
    connected to its own plot of memory, holding its copy of the data needed for rendering:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑到这一点，让我们看看森林中的树木。采用简单的方法，我们可以为每棵树加载并存储一次模型、纹理和变换数据。这将使我们的数据存储看起来像*图3**.4*，其中每棵树连接到自己的内存块，持有其渲染所需数据的副本： '
- en: '![Figure 3.4 – Diagram showing the data associated with each tree](img/Figure_03.04_B18297.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 显示与每棵树关联的数据的图表](img/Figure_03.04_B18297.jpg)'
- en: Figure 3.4 – Diagram showing the data associated with each tree
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 显示与每个树关联的数据的图表
- en: 'If we consider the memory cost of a **model** and **texture** combined to be
    about 5 MB and the transform component to be 12 bytes of data per tree, then our
    memory footprint for three trees is a little over 15 MB. This may not seem like
    much, but it scales badly. Considering a forest of 100 trees, we would need a
    little over 500 MB of RAM to hold what is essentially set dressing. Something
    must be done, so let’s consider what data in the concept of a tree can be considered
    intrinsic, and what needs to remain extrinsic to each tree. As all our trees are
    identical to look at, all the data for visuals (model and texture data) can probably
    be safely made intrinsic. Great, we have a definite set of data that is each type;
    so what? Well, the flyweight pattern places all data we consider to be intrinsic
    in shared memory. In practice, this looks like *Figure 3**.5*, where all intrinsic
    visual data that will be shared between all trees has been collected into a shared
    block and you can spatially visualize the difference in memory cost. Things like
    the objects transform still remain extrinsic, as each tree will at least have
    a different position vector:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将模型和纹理的内存成本合计为大约 5 MB，并将变换组件视为每棵树 12 字节的数据，那么我们三棵树的内存占用略超过 15 MB。这看起来可能不多，但扩展性不好。考虑到一个由
    100 棵树组成的森林，我们需要略超过 500 MB 的 RAM 来存储本质上只是装饰性的内容。必须做些什么，因此让我们考虑在树的概念中哪些数据可以被认为是内在的，哪些需要保留为每棵树的外在。由于我们的树看起来都相同，所有用于视觉的数据（模型和纹理数据）可能都可以安全地被认为是内在的。很好，我们有一个明确的数据集，每个类型都有数据；那么呢？嗯，享元模式将我们认为是内在的所有数据放置在共享内存中。在实践中，这看起来像
    *图 3**.5*，其中所有将在所有树之间共享的内在视觉数据都被收集到一个共享块中，你可以从空间上可视化内存成本的差异。像对象变换这样的东西仍然保持外在，因为每棵树至少会有一个不同的位置向量：
- en: '![Figure 3.5 – Diagram showing how the separation of intrinsic data saves memory
    with repeated objects spatially](img/Figure_03.05_B18297.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 展示如何通过空间重复对象分离内在数据来节省内存的图](img/Figure_03.05_B18297.jpg)'
- en: Figure 3.5 – Diagram showing how the separation of intrinsic data saves memory
    with repeated objects spatially
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 展示如何通过空间重复对象分离内在数据来节省内存的图
- en: In terms of memory allocation, the implemented flyweight pattern has a fixed
    cost of 5 MB for the shared model and texture data and a variable cost of 12 bytes
    per tree. This means our forest of 100 trees now only takes up 5.1 MB, which is
    a far cry from the 500 MB we needed previously.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存分配方面，实现的享元模式对于共享模型和纹理数据有固定的 5 MB 成本，每棵树有 12 字节的可变成本。这意味着我们现在的 100 棵树只需要 5.1
    MB，这与之前需要的 500 MB 相去甚远。
- en: With the basics down, let’s investigate how our system might break. Well, we
    obviously get a benefit from sharing data, but what if we wanted two types of
    trees in our forest with different model and texture data? You’d think, based
    on the previous explanation, that this would make that data extrinsic and therefore
    not eligible for the flyweight pattern. However, you can invoke the type object
    pattern, which we will discuss in greater detail in a later chapter. The type
    object pattern collects intrinsic data about a *type* and applies the same idea.
    This calculation for memory cost would then look like the amount of types you
    have multiplied by 5 MB, plus 12 bytes per object in the world. The type object
    pattern, of course, has some other benefits that we will look at in [*Chapter
    9*](B18297_09.xhtml#_idTextAnchor130), but this is how it pairs with the flyweight
    pattern to give an expandable, efficient system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 基础知识掌握之后，让我们来探讨我们的系统可能会出现的问题。显然，我们通过共享数据获得了好处，但如果我们想在森林中拥有两种不同模型和纹理数据的树呢？根据之前的解释，你可能认为这将使这些数据成为外在的，因此不符合享元模式。然而，你可以调用类型对象模式，我们将在后面的章节中更详细地讨论。类型对象模式收集有关
    *类型* 的内在数据并应用相同的概念。内存成本的这种计算将类似于类型的数量乘以 5 MB，再加上世界中每个对象 12 字节。当然，类型对象模式还有一些其他的好处，我们将在
    [*第 9 章*](B18297_09.xhtml#_idTextAnchor130) 中探讨，但这是它与享元模式结合以提供一个可扩展、高效系统的方式。
- en: Unreal Engine applies the flyweight pattern by default to every asset loaded
    into a project. Assets are then referenced from a single place when needed and
    their data is shared across all references. If you need to make a change to a
    specific loaded version of an asset, you need to actively break the flyweight
    pattern to do so. An example of where this may be needed is in dynamic material
    instances. Some value may be needed to alter the appearance of only one object
    in the scene, so a copy of the intrinsic data for the material must be made.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 默认将享元模式应用于项目中加载的每个资产。当需要时，资产从单一位置引用，并且它们的数据在所有引用之间共享。如果你需要更改特定加载版本的资产，你需要主动打破享元模式才能做到这一点。这种可能需要的情况之一是在动态材质实例中。可能需要一些值来改变场景中单个对象的外观，因此必须制作材质的内在数据的副本。
- en: The last pattern for this chapter is less automatic and silent than the previous
    two. It is a subsystem designed around making vast worlds possible and performant
    to play in. In Unreal Engine, we call it **World Partition** (based on the toolset
    available in the editor to manage how a large-scale world is split up), but more
    generally it is known as the spatial partitioning pattern.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个模式比前两个模式更不自动、更不默默无闻。这是一个围绕实现广阔世界并使其可玩性得到保证而设计的子系统。在 Unreal Engine 中，我们称之为**世界分区**（基于编辑器中可用的工具集来管理如何分割大规模世界），但更普遍地，它被称为空间分区模式。
- en: Spatial partitioning
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间分区
- en: 'Imagine the Matrix is a real concept, and we are living in a giant physics
    simulation. Anybody who has dabbled in physics simulations knows that you don’t
    need many interacting objects to make the simulation chug. The naïve solution
    is to check every object against every other object leading to an *O(n**2**-n)*
    solution, where you can see in *Figure 3**.6* that 4 objects have 12 collision
    checks:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设矩阵是一个真实的概念，而我们正生活在一个巨大的物理模拟中。任何涉足物理模拟的人都知道，你不需要很多相互作用的物体来使模拟变得缓慢。简单的解决方案是检查每个对象与每个其他对象，导致一个
    *O(n^2-n)* 的解决方案，如图 *3.6* 中所示，4 个对象有 12 次碰撞检查：
- en: '![Figure 3.6 – Diagram showing each collision check performed in an inefficient
    collision detection solution](img/Figure_03.06_B18297.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 显示在低效碰撞检测解决方案中执行每个碰撞检查的图](img/Figure_03.06_B18297.jpg)'
- en: Figure 3.6 – Diagram showing each collision check performed in an inefficient
    collision detection solution
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 显示在低效碰撞检测解决方案中执行每个碰撞检查的图
- en: Improvements can obviously be made to not repeat calculations that have already
    been made, bringing us down to *O(nLog2(n))* where those same four points use
    only six collision checks. This is better, but there is only so far we can go
    by checking every object against every other object. We could just not calculate
    some of them, but that would be like giving some people in our Matrix simulation
    wall hacks, allowing them to possibly phase through walls, or worse, each other.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以通过避免重复已经完成的计算来提高效率，将我们降低到 *O(nLog2(n))*，其中这四个点仅使用六个碰撞检查。这更好，但我们只能通过检查每个对象与每个其他对象来走这么远。我们本可以不计算其中的一些，但这就像在我们的矩阵模拟中给一些人提供墙壁黑客，允许他们可能穿过墙壁，或者更糟，穿过彼此。
- en: We could check the distance between objects before we check their collisions.
    This would mean objects far apart would not even try to collide. This may work
    for more complex collision geometries but realistically, if we are smart developers
    using only primitives for collision, we would just be adding to all the calculations.
    This would in the worst case lower the efficiency to *O(nLog2(n) + n)*. The theory
    has merit, though, so instead of checking every object we should instead group
    them based on geography. The world needs to be divided into cells; we’ll call
    them chunks. Each cell knows the objects it fully encompasses and its position
    in the grid of cells. We need only then to check collisions between objects in
    neighboring cells. This is the basis of spatial partitioning.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在检查对象的碰撞之前检查它们之间的距离。这意味着距离较远的对象甚至不会尝试碰撞。这可能适用于更复杂的碰撞几何形状，但现实情况下，如果我们是只使用原始碰撞的智能开发者，我们只是在增加所有计算。在最坏的情况下，这会将效率降低到
    *O(nLog2(n) + n)*。尽管如此，这个理论是合理的，所以我们不应该检查每个对象，而应该根据地理位置将它们分组。世界需要被分成单元格；我们将它们称为块。每个单元格都知道它完全包含的对象及其在单元格网格中的位置。我们只需要检查相邻单元格中对象的碰撞。这是空间分区的基础。
- en: What if an object is bigger than the cell it is centered on? We can group cells
    together into a bigger chunk and include any objects that cross the cell boundaries
    that the new cell group fully encompasses. This process is then repeated until
    the cell contains the whole world. This creates a tree structure of cells. To
    then check an object’s collision, only objects in the tree directly connected
    above and below need to be checked. This has the potential to cut out most checks
    we would have otherwise done.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象比它中心所在的细胞大怎么办？我们可以将细胞组合成更大的块，并包括任何跨越新细胞组边界的对象。这个过程会一直重复，直到细胞包含整个世界。这创建了一个细胞的树状结构。要检查一个对象的碰撞，只需要检查树中直接连接在上面的和下面的对象。这有可能减少我们本应进行的多数检查。
- en: 'One issue is how we establish where each object is in the tree. This does have
    some overhead cost, meaning for small simulations, it is wild overkill. That said,
    if you are going to use this across your entire world and only update the tree
    positions of moving objects, you end up with massive efficiency gains. 2D implementations
    might follow a structure called a **quadtree** (pictured in *Figure 3**.7*):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是我们在树中确定每个对象位置的方式。这确实有一些开销成本，意味着对于小规模模拟来说，这可能是过度杀鸡用牛刀。话虽如此，如果你打算在整个世界中使用它，并且只更新移动对象的树位置，你最终会获得巨大的效率提升。二维实现可能遵循一个称为**四叉树**的结构（如图3.7所示）：
- en: '![Figure 3.7 – Diagram showing how a quadtree can reduce the number of needed
    collision checks (green) to eight for these six objects (red) when they are in
    these positions](img/Figure_03.07_B18297.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 图表展示了四叉树如何将这些六个对象（红色）在当前位置时所需的碰撞检查（绿色）数量减少到八个](img/Figure_03.07_B18297.jpg)'
- en: Figure 3.7 – Diagram showing how a quadtree can reduce the number of needed
    collision checks (green) to eight for these six objects (red) when they are in
    these positions
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 图表展示了四叉树如何将这些六个对象（红色）在当前位置时所需的碰撞检查（绿色）数量减少到八个
- en: Here, you can clearly see how objects in different cells (or quads) do not check
    collision with each other. As an object crosses a boundary, it starts existing
    in the cell a layer above and must check collision with all objects in child cells.
    Generally, this is not the case, and so with a large number of objects, there
    will always be a performance improvement.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以清楚地看到不同细胞（或四叉形）中的对象之间不会检查碰撞。当一个对象跨越边界时，它开始存在于上一层细胞中，并且必须检查与子细胞中所有对象的碰撞。通常情况下并非如此，因此，在大量对象的情况下，总会带来性能提升。
- en: 'Unreal Engine 5 uses the idea of a quadtree in three dimensions called an `Fscene`
    class and is used by the render thread to determine quickly whether an object
    exists in the light’s area of effect. This way, the number of lighting calculations
    is drastically reduced:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 5使用三维四叉树的概念，称为`Fscene`类，并由渲染线程用于快速确定对象是否存在于光的作用区域内。这样，光照计算的次数会大幅减少：
- en: '![Figure 3.8 – Screenshot of the octree location in the ScenePrivate.h file](img/Figure_03.08_B18297.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – ScenePrivate.h文件中八叉树位置的截图](img/Figure_03.08_B18297.jpg)'
- en: Figure 3.8 – Screenshot of the octree location in the ScenePrivate.h file
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – ScenePrivate.h文件中八叉树位置的截图
- en: Extra note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 额外说明
- en: If you drill down through the struct and class definitions from the line pictured
    in *Figure 3**.8*, you will eventually find a `Toctree2` class name (the first
    one has been deprecated). In this class, you can explore Epic’s implementation
    of the octree.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从图3.8中所示的那一行开始深入到结构体和类定义中，你最终会找到一个名为`Toctree2`的类名（第一个已经被弃用）。在这个类中，你可以探索Epic对八叉树的实现。
- en: That is not all. With Unreal Engine 5 comes the introduction of a system called
    World Partition. This is another implementation of a spatial partition, this time
    in two dimensions, that is used for a different purpose. As a developer, you must
    define what size cell Unreal should use, and unlike the tree variants, this is
    limited to a single layer of depth. That being said, it does provide a fast way
    of hooking up large worlds with **level of detail** (**LOD**) systems to affect
    everything from visuals to collision meshes. LOD systems are used to reduce how
    much detail is being rendered (in either a 3D mesh or texture) when the object
    being rendered appears smaller on the screen. So, an object further away from
    the screen will feature an LOD mesh that has a much lower triangle count than
    if the same object was drawn directly in front of the player.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不算完。随着虚幻引擎5的推出，引入了一个名为世界分区的系统。这是空间分区的一种实现，这次是在二维中，用于不同的目的。作为开发者，你必须定义虚幻应该使用多大的单元格大小，而且与树变体不同，这限制在单层深度。话虽如此，它确实提供了一种快速连接大型世界与**细节级别**（**LOD**）系统的方法，从而影响从视觉效果到碰撞网格的各个方面。LOD系统用于在渲染的对象在屏幕上显得更小的时候减少渲染的细节（无论是3D网格还是纹理）。当屏幕上的对象距离较远时，将具有一个具有更低三角形计数的LOD网格，如果相同的对象直接在玩家面前绘制，则三角形计数会更高。
- en: Let’s take a look at exploring World Partition by looking at an example map
    we’ve provided that uses an Open World level. We will begin by looking at how
    the example works, then change some variables to get different results to better
    understand how the system works. The example levels used for this section are
    available in the `PatternsInAction` project on GitHub that is linked at the start
    of the chapter. Unlike in [*Chapter 2*](B18297_02.xhtml#_idTextAnchor031), this
    time we have provided a full Unreal Project, and this time, you can extract the
    `.zip` contents and double-click on the `PatternsInAction.uproject` file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看我们提供的示例地图来探索世界分区，该地图使用开放式世界级别。我们将首先查看示例是如何工作的，然后更改一些变量以获得不同的结果，以便更好地理解该系统的工作原理。本节使用的示例级别可在GitHub上的`PatternsInAction`项目中找到，该链接位于章节开头。与[*第2章*](B18297_02.xhtml#_idTextAnchor031)不同，这次我们提供了一个完整的虚幻项目，这次，你可以提取`.zip`内容，然后双击`PatternsInAction.uproject`文件。
- en: Introducing World Partition
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍世界分区
- en: 'Firstly, open the `WorldPartitionExample` map file from the `Content\Maps`
    folder. This map should open by default when you launch the project but in case
    it doesn’t, navigate to **File** | **Open Level** and select it from the directories.
    You should then see a world with a series of blueprint actors, all of which are
    displayed as primitive shapes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从`Content\Maps`文件夹中打开`WorldPartitionExample`地图文件。当你启动项目时，此地图应该默认打开，但如果它没有打开，请导航到**文件**
    | **打开级别**并从目录中选择它。然后你应该看到一个包含一系列蓝图演员的世界，所有这些演员都显示为原始形状：
- en: '![Figure 3.9 – World Partition example map from the PatternsinAction project](img/Figure_03.09_B18297.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – PatternsinAction项目中的世界分区示例地图](img/Figure_03.09_B18297.jpg)'
- en: Figure 3.9 – World Partition example map from the PatternsinAction project
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – PatternsinAction项目中的世界分区示例地图
- en: This level already has World Partition enabled and set up for the terrain. This
    is standard for the Open World level template.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此级别已经启用了世界分区并设置了地形。这对于开放式世界级别模板来说是标准的。
- en: 'Let’s start by opening the World Partition setting tool so we can see how it
    works. If it hasn’t opened by default, go to **Window** | **World Partition**
    | **World** **Partition Editor**:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先打开世界分区设置工具，以便我们可以看到它是如何工作的。如果它没有默认打开，请转到**窗口** | **世界分区** | **世界分区编辑器**：
- en: '![Figure 3.10 – Accessing the World Partition Editor from the menus](img/Figure_03.10_B18297.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – 从菜单访问世界分区编辑器](img/Figure_03.10_B18297.jpg)'
- en: Figure 3.10 – Accessing the World Partition Editor from the menus
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 从菜单访问世界分区编辑器
- en: 'This should open **World Partition Editor** in the same section of the user
    interface as the **Details** tab; you can zoom in using your scroll wheel, after
    which you will eventually be able to see the grid reference system for the map
    (provided you have turned on **Show Cell Coords** in the top menu of the **World
    Partition** editor). It’s worth noting that this grid does not directly relate
    to the cell grid produced by the World Partition system. Instead, it offers a
    grid based on an editor cell size which, by default, is set to 12,800 (128 square
    meters), half the size of the default World Partition cell, which is 25,600 (256
    square meters):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在用户界面与**详细**标签页相同的部分打开**世界分区编辑器**；你可以使用滚轮放大，之后你将最终能够看到地图的网格参考系统（前提是你已在**世界分区**编辑器的顶部菜单中开启**显示单元格坐标**）。值得注意的是，这个网格并不直接与世界分区系统产生的单元格网格相关。相反，它提供了一个基于编辑器单元格大小的网格，默认设置为12,800（128平方米），是默认世界分区单元格大小的一半，即25,600（256平方米）：
- en: '![Figure 3.11 – World Partition editor tab, resized horizontally so the text
    on the left is visible (left) and then zoomed in with Show Grid Coords ON to show
    the grid reference system (right)](img/Figure_03.11_B18297.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – 世界分区编辑器标签页，水平调整大小以便左侧的文本可见（左侧），然后开启显示网格坐标以放大显示网格参考系统（右侧）](img/Figure_03.11_B18297.jpg)'
- en: Figure 3.11 – World Partition editor tab, resized horizontally so the text on
    the left is visible (left) and then zoomed in with Show Grid Coords ON to show
    the grid reference system (right)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 世界分区编辑器标签页，水平调整大小以便左侧的文本可见（左侧），然后开启显示网格坐标以放大显示网格参考系统（右侧）
- en: World Partition splits (partitions) the world based on a cell grid, with each
    cell corresponding to a physical section of the level. If an actor’s bounding
    box is in that cell, it will be drawn (or hidden) depending on whether the cell
    is within a set distance of a **streaming source** (an entity in the world that
    controls when World Partition cells are loaded), such as the player character
    or an actor with a World Partition streaming source component. This allows Unreal
    to divide the map and only draw the required cells, making it possible for developers
    to build incredibly large maps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 世界分区根据单元格网格分割（分区）世界，每个单元格对应于级别的物理部分。如果一个角色的边界框在那个单元格内，它将根据单元格是否在**流源**（控制何时加载世界分区单元格的实体）的设定距离内而被绘制（或隐藏），例如玩家角色或具有世界分区流源组件的演员。这允许虚幻引擎分割地图，并且只绘制所需的单元格，使得开发者能够构建极其庞大的地图。
- en: 'To determine the distance from a streaming source that a cell must be within
    to be drawn, the engine uses the **Loading Range** variable, which can be found
    in **World Settings** | **World Partition** | **Runtime Settings** | **Grids**
    | **Index [0]**. The value of **Loading Range** sets the radius from the character
    that a cell needs to be within for it to be loaded and rendered. The default value
    for **Loading Range** is 76,800, which is shown in **Unreal Units** (uu). 1 uu
    = 1 cm, so the default radius is the in-game equivalent of 768 m:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定一个单元格必须位于流源多近才能被绘制，引擎使用**加载范围**变量，该变量可在**世界设置** | **世界分区** | **运行时设置** |
    **网格** | **索引[0]**中找到。**加载范围**的值设置单元格需要位于角色半径内才能加载和渲染。**加载范围**的默认值是76,800，以**虚幻单位**（uu）表示。1
    uu = 1 cm，因此默认半径是游戏中的768米：
- en: '![Figure 3.12 – World Partition rollout of the World Settings tab showing the
    grid settings](img/Figure_03.12_B18297.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – 世界设置标签页的世界分区展开，显示网格设置](img/Figure_03.12_B18297.jpg)'
- en: Figure 3.12 – World Partition rollout of the World Settings tab showing the
    grid settings
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 世界设置标签页的世界分区展开，显示网格设置
- en: The **Index [0]** section of **World Settings** also contains variables to determine
    the size of each cell on the grid. In a built-up city environment, where the visible
    distance is shortened due to the height of buildings, you could set a smaller
    **Cell Size** value and **Loading Range** value compared to an open landscape,
    such as a desert.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**世界设置**的**索引[0]**部分还包含确定网格中每个单元格大小的变量。在建筑物高度导致可见距离缩短的城市环境中，你可以设置比开阔景观（如沙漠）更小的**单元格大小**值和**加载范围**值。'
- en: While it may appear logical to significantly reduce the cell size and loading
    range, setting these too low will result in frame rate issues owing to a bottleneck
    caused by trying to load (and unload) too many cells at one time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然显著减小单元格大小和加载范围看起来似乎是合理的，但如果设置得太低，由于一次尝试加载（和卸载）过多单元格而造成的瓶颈，将会导致帧率问题。
- en: Now that we’ve had a look at how the cell grid is made up, we can start to look
    at how that cell grid controls when objects load and unload based on the position
    of streaming sources.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了单元格网格的构成，我们可以开始了解单元格网格是如何根据流源的位置来控制对象的加载和卸载的。
- en: Understanding when objects are loaded
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解对象何时加载
- en: To get a better understanding of how World Partition works, we can change some
    of the **Runtime Settings** values in **Index [0]**. We will make changes to **Loading
    Range** and **Cell Size** to control the way World Partition works within our
    example map. The changes we make will adjust when the blueprints in the map are
    loaded and unloaded. Observing the differences will help you to experience World
    Partition (and spatial partitioning) in action.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解世界分区的工作原理，我们可以在**索引 [0]**中更改一些**运行时设置**值。我们将更改**加载范围**和**单元格大小**，以控制我们的示例地图中世界分区的工作方式。我们做出的更改将调整地图中蓝图加载和卸载的时间。观察这些差异将帮助你体验世界分区（以及空间分区）的实际应用。
- en: Before we make any changes, press the *Play* button to play the level in the
    editor viewport. You should notice a stream of print strings on the left side
    of the screen. This is because each of the blueprint actors have been set up to
    print a short message and their display name.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何更改之前，按下**播放**按钮以在编辑器视图中播放关卡。你应该注意到屏幕左侧有一串打印字符串。这是因为每个蓝图行为者都已被设置为打印一条简短的消息和它们的显示名称。
- en: Move around the map using typical first-person *W*, *A*, *S*, and *D* keys to
    control the character. You should notice that, if you move all the way to one
    side of the map, prints change as fewer objects are printing their messages.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用典型的第一人称*W*、*A*、*S*和*D*键在地图上移动，以控制角色。你应该注意到，如果你移动到地图的一侧，打印的内容会减少，因为较少的对象正在打印它们的消息。
- en: 'Once you’ve seen this effect, try changing `76800` to `768`, making the radius
    that objects need to be within to load 100 times smaller than the default settings.
    This will cause a significantly different result. Now, try testing the level once
    again. You should notice that only two objects are visible: a tall rectangular
    box and a cone, both of which are in front of the character from the starting
    position. These are visible because a small section of each mesh is inside a partition
    cell that is within a 7.68 m radius of the player character.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你看到了这个效果，尝试将`76800`更改为`768`，使对象需要位于其中的半径比默认设置小100倍。这将导致显著不同的结果。现在，再次测试关卡。你应该注意到只有两个对象可见：一个高矩形箱和一个圆锥体，它们都位于从起始位置的角色前方。这些对象是可见的，因为每个网格的一小部分位于玩家角色7.68米半径内的一个分区单元格内。
- en: Walking toward either object will eventually cause other objects to suddenly
    appear (you will need to get very close) as you get within range of the neighboring
    partition cells.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 向任一对象走去，最终会导致其他对象突然出现（你需要非常靠近），因为当你进入相邻分区单元格的范围内时。
- en: 'To further understand why we get this behavior, let’s change the **World Partition
    Editor Cell** **Size** variable:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解我们为什么会有这种行为，让我们更改**世界分区编辑器单元格****大小**变量：
- en: Below the **Runtime Settings** section we’ve used so far, expand the **Advanced**
    section by clicking the title or the arrow to the side.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们之前使用的**运行时设置**部分下方，通过点击标题或旁边的箭头来展开**高级**部分。
- en: Set the `25600` to match the **Cell Size** value from the **Index [0]** settings,
    ensuring our editor display matches the behavior we are experiencing when we play
    the level.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`25600`设置为与**索引 [0]**设置中的**单元格大小**值匹配，确保我们的编辑器显示与我们在玩关卡时体验到的行为一致。
- en: Once you have made the change, rebuild the Minimap by navigating to **Build**
    | **Build Minimap** from the top menu. You will be asked to save the level and
    any modified assets, and then you will be shown a series of progress bars while
    the build takes place.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你进行了更改，通过导航到顶部菜单中的**构建** | **构建迷你地图**来重建迷你地图。你将被要求保存关卡和任何修改过的资源，然后在构建过程中会显示一系列进度条。
- en: 'Switch back to the **World Partition** editor tab; you should now see a lot
    fewer cells in the grid, as shown in *Figure 3**.13*:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回**世界分区**编辑器标签；你现在应该看到网格中的单元格少得多，如图*图3.13*所示。13*：
- en: '![Figure 3.13 – Updated editor cell display showing how the visible objects
    are partially inside the initially loaded cells (-1,0) and (0,0)](img/Figure_03.13_B18297.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13 – 更新后的编辑器单元格显示，显示可见对象部分位于最初加载的单元格(-1,0)和(0,0)内](img/Figure_03.13_B18297.jpg)'
- en: Figure 3.13 – Updated editor cell display showing how the visible objects are
    partially inside the initially loaded cells (-1,0) and (0,0)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 更新后的编辑器单元格显示，显示可见对象部分位于最初加载的单元格(-1,0)和(0,0)内
- en: 'The grid should now show where each of the actors is positioned, with at least
    one of each of the object types (cone and cube) in a grid cell that the character
    starts within (or very close to). The second object of each pair sits in the neighboring
    grid cell, so will only appear once the player character is within 7.68 m of the
    cell, which is a very short distance when you consider each cell is 256 m x 256
    m and the default loading range that we changed was originally a radius of 768
    m. Based on the default values, when the character stands at the starting location
    at the origin of the grid, 36 of the cells are being loaded as opposed to the
    4 that are loaded with the shortened range of 7.68 m, which would be inappropriate
    for use in a game but works as an extreme example of how the system works:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在网格应显示每个演员的位置，在每个对象类型（圆锥体和立方体）至少有一个位于角色开始位置（或非常接近）的网格单元中。每一对中的第二个对象位于相邻的网格单元中，因此只有在玩家角色位于7.68米内时才会出现。当你考虑到每个单元是256米
    x 256米，而我们更改的默认加载范围最初是一个半径为768米的圆时，这是一个非常短的距离。根据默认值，当角色站在网格原点的起始位置时，有36个单元正在加载，而使用缩短范围为7.68米的4个单元，这在游戏中使用是不合适的，但可以作为系统如何工作的极端示例：
- en: '![Figure 3.14 – Visual representation of the overlapping area of a 768 m radius
    circle over 256 m x 256 m grid cells, resulting in 36 cells being loaded compared
    to a radius of 7.68 m (inner circle) only overlapping 4](img/Figure_03.14_B18297.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – 768米半径的圆在256米 x 256米网格单元上的重叠区域视觉表示，与7.68米半径（内圈）仅重叠4个单元相比，有36个单元被加载](img/Figure_03.14_B18297.jpg)'
- en: Figure 3.14 – Visual representation of the overlapping area of a 768 m radius
    circle over 256 m x 256 m grid cells, resulting in 36 cells being loaded compared
    to a radius of 7.68 m (inner circle) only overlapping 4
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 768米半径的圆在256米 x 256米网格单元上的重叠区域视觉表示，与7.68米半径（内圈）仅重叠4个单元相比，有36个单元被加载
- en: Now that we’ve set an extreme value, try some different values, such as setting
    `38400`, which will result in more objects being loaded at any one point. Standing
    at the center of the map will load a similar number of visible objects to the
    default setting, but you will see the objects disappear much sooner as you walk
    away from them. Remember, you can always return to the default value of `76800`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个极端值，尝试一些不同的值，例如设置`38400`，这将导致在任何一点加载更多的对象。站在地图的中心将加载与默认设置相似数量的可见对象，但当你远离它们时，你会看到对象消失得更快。记住，你总是可以返回默认值`76800`。
- en: This shows how, with different loading ranges, we can control when parts of
    our 3D world appear. Getting the correct values for your game might require some
    testing and, in some cases, the inclusion of scalability settings to ensure your
    game runs on different hardware. For now, the key thing is understanding how to
    control when things load and unload based on streaming sources so that once you
    have a 3D world to control, you can make the most of World Partition.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何，通过不同的加载范围，我们可以控制我们3D世界的哪些部分何时出现。为你的游戏获取正确的值可能需要一些测试，在某些情况下，可能需要包含可伸缩性设置以确保游戏在不同的硬件上运行。目前，关键是要了解如何根据流源控制加载和卸载，这样一旦你有一个可以控制的3D世界，你就可以充分利用世界分区。
- en: Ensuring actors are loaded when required
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保演员在需要时加载
- en: 'There are two ways to ensure that actors are loaded and ready for the player.
    One option is to force an actor to always be loaded by preventing it from being
    loaded and unloaded by World Partition. This could be useful if you have managers
    in the world who are required to control aspects across the entire level, or if
    you have a monument that needs to be always visible. To do this, do the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 确保演员加载并准备好播放有两种方法。一种选项是通过防止演员被世界分区加载和卸载来强制演员始终处于加载状态。这可能在你需要控制整个级别的各个方面时很有用，或者如果你有一个需要始终可见的纪念碑。为此，请执行以下操作：
- en: Select the chosen actor in the level.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在级别中选择选定的演员。
- en: 'In the **Details** panel, scroll down to the **World** **Partition** section:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，向下滚动到**世界** **分区**部分：
- en: '![Figure 3.15 – World Partition settings in the Details panel with an actor
    selected](img/Figure_03.15_B18297.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图3.15 – 在详细信息面板中选中演员时的世界分区设置](img/Figure_03.15_B18297.jpg)'
- en: Figure 3.15 – World Partition settings in the Details panel with an actor selected
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – 在详细信息面板中选中演员时的世界分区设置
- en: Set `OFF`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置为**关闭**。
- en: The second approach is to include actors in the world that have a World Partition
    streaming source component.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是在世界中包含具有世界分区流源组件的演员。
- en: 'We’ve included a `BP_StreamingSourceActor` blueprint, which has a World Partition
    streaming source component set up with the target grid already set up. To see
    it in action, do the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了一个`BP_StreamingSourceActor`蓝图，该蓝图已设置好带有目标网格的世界分区流源组件。要看到它的实际效果，请执行以下操作：
- en: Drag a `BP_StreamingSourceActor` blueprint from the `Content Browser/Blueprints`
    folder into the world between the two cone actors.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BP_StreamingSourceActor`蓝图从`内容浏览器/蓝图`文件夹拖放到两个圆锥形演员之间的世界中。
- en: Set `768` for testing purposes.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试目的，将`768`设置为测试。
- en: When testing the level, you should now see that, unlike when we first set the
    loading range to `768`, both cone objects are visible.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试级别时，您现在应该看到，与最初将加载范围设置为`768`时不同，两个圆锥形对象都是可见的。
- en: You will, however, notice that after five seconds of gameplay, one of the cones
    (the furthest one from the player) will disappear. This is because the `BP_StreamingSourceActor`
    blueprint includes some crude code to toggle the streaming source on and off.
    This provides a nice insight into how a streaming source actor can be used to
    control loading cells ready for the player, in cases such as where the character
    will be teleported to a new location that needs to be fully loaded before the
    player is relocated.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您会注意到，在五秒钟的游戏后，其中一个圆锥（离玩家最远的圆锥）将消失。这是因为`BP_StreamingSourceActor`蓝图包含一些粗略的代码来切换流源的开和关。这为如何使用流源演员来控制为玩家准备好的加载单元提供了很好的见解，例如，当角色将被传送到一个需要完全加载的新位置，而玩家被重新定位之前。
- en: In *Figure 3**.16* you can see the logic within the `BP_StreamingSourceActor`’s
    event graph.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3*.16中，您可以看到`BP_StreamingSourceActor`事件图中的逻辑。
- en: '![Figure 3.16 – Crude blueprint setup that disables and enables the streaming
    source every five seconds using a timer](img/Figure_03.16_B18297.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16 – 使用计时器每五秒禁用和启用流源的粗略蓝图设置](img/Figure_03.16_B18297.jpg)'
- en: Figure 3.16 – Crude blueprint setup that disables and enables the streaming
    source every five seconds using a timer
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – 使用计时器每五秒禁用和启用流源的粗略蓝图设置
- en: Now that we’ve explored World Partition, we will look at using it with levels
    that have been created without it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了世界分区，我们将看看如何在没有它的级别中使用它。
- en: Enabling World Partition on an existing level
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在现有级别上启用世界分区
- en: 'To convert an existing level (that wasn’t created using the Open World starter
    map) to make use of World Partition, all you need to do is use the built-in tool:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要将现有级别（未使用开放世界启动地图创建的级别）转换为使用世界分区，您只需使用内置工具：
- en: Ensure the level you want to convert to a World Partition-enabled level is saved.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您想要转换为世界分区启用级别的级别已保存。
- en: Navigate to **Tools** | **Convert Level** from the top menu.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶部菜单导航到**工具** | **转换级别**。
- en: From the popup, select the map you would like to convert.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出菜单中选择您想要转换的地图。
- en: Click **OK**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**。
- en: The tool will create a new version of the map with the `_WP` suffix in the name
    unless you select **In Place** from the final settings dialog, which will simply
    overwrite your existing level.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在最终设置对话框中选择**就地**，则工具将创建一个带有名称后缀`_WP`的新地图版本；否则，它将简单地覆盖您现有的级别。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed a number of existing patterns that are present
    in Unreal Engine, focusing on double buffer, flyweight, and spatial partitioning.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在虚幻引擎中存在的一些现有模式，重点关注双缓冲、享元和空间分区。
- en: We have taken a look at some of these systems, including exploring editor examples
    of spatial partitioning using the World Partition system, experimenting with different
    variables to control when objects are loaded and unloaded, and testing an actor
    with a World Partition streaming source component.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了一些这些系统，包括使用世界分区系统探索空间分区编辑器示例，实验不同的变量以控制何时加载和卸载对象，以及测试具有世界分区流源组件的演员。
- en: In the next chapter, we are going to explore some pre-made patterns in Unreal.
    We will be looking at creating components using the `update` method, and creating
    a simple AI-controlled **Real-Time Strategy** (**RTS**) game unit using Unreal’s
    AI **Behavior Trees**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索 Unreal 中的一些预定义模式。我们将探讨如何使用 `update` 方法创建组件，以及如何使用 Unreal 的 AI **行为树**创建一个简单的由
    AI 控制的**实时策略**（**RTS**）游戏单位。
