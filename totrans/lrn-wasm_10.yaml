- en: Advanced Tools and Upcoming Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly's ecosystem is constantly growing and evolving. Developers have
    seen the potential for WebAssembly. They build tools to improve the development
    experience or output Wasm modules from their language of choice (albeit with some
    limitations).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll evaluate the underlying technologies that make WebAssembly
    tick. We'll also review tools you can use in the browser and cover an advanced
    use case that utilizes Web Workers. Finally, we'll quickly review upcoming features
    and proposals that are on the roadmap for WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal for this chapter is to understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How WABT and Binaryen fit into the build process and what they can be used for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to compile a WebAssembly module using LLVM (rather than Emscripten)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online tools such as WasmFiddle and other useful tooling online
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to utilize Web Workers to run WebAssembly in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upcoming features (proposed and in progress) that will be integrated into WebAssembly
    in the future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WABT and Binaryen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WABT and Binaryen allow developers to work with source files and develop tooling
    for WebAssembly. If you're interested in working with WebAssembly at a lower level,
    these tools provide the means for accomplishing such a goal. In this section,
    we'll evaluate these tools in greater detail and review the purpose and capabilities
    of each one.
  prefs: []
  type: TYPE_NORMAL
- en: WABT – the WebAssembly binary toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WABT's focus is on the manipulation of WebAssembly binary (`.wasm`) files and
    text (`.wat`) files, as well as conversion between the two formats. WABT provides
    tools to translate **Wat to Wasm** (**wat2wasm**) and vice versa (**wasm2wat**),
    as well as a tool to convert a Wasm file to a C source and header file (**wasm2c**).
    You can view the entire list of tools in the README file of the WABT GitHub repository
    at [https://github.com/WebAssembly/wabt](https://github.com/WebAssembly/wabt).
  prefs: []
  type: TYPE_NORMAL
- en: 'One example use case of WABT is the *WebAssembly Toolkit for VS Code* extension
    we installed in [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting
    Up a Development Environment*. The extension depends on WABT to view the text
    format associated with a `.wasm` file. The repository provides links to wat2wasm
    and wasm2wat demos, which you can use to test the validity of a Wat program or
    interact with a compiled binary using JavaScript. The following screenshot contains
    the Wat and JavaScript instantiation code from the wat2wasm demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c941193-4415-400d-9085-4d78bd80a19a.png)'
  prefs: []
  type: TYPE_IMG
- en: Wat and JavaScript loading code from wat2wasm's "simple" example
  prefs: []
  type: TYPE_NORMAL
- en: In line `3` of the JS panel, you may have noticed that the `addTwo()` function
    from `wasmInstance.exports` isn't prefixed with a `_`. Emscripten adds the `_`
    automatically in the compilation process. You could omit the `_` by converting
    the `.wasm` file to a `.wat`, updating the function names, and converting it back
    to `.wasm` using the WABT, although this wouldn't be very practical. The WABT
    simplifies the process of transforming text format to binary format and vice versa.
    If you want to build compilation tooling for WebAssembly, you'd use Binaryen,
    which we will cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Binaryen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Binaryen''s GitHub page at [https://github.com/WebAssembly/binaryen](https://github.com/WebAssembly/binaryen)
    describes Binaryen as a compiler and toolchain infrastructure library for WebAssembly,
    written in C++. It aims to make compiling to WebAssembly easy, fast, and effective.
    It achieves these aims by providing a simple C API, an internal IR, and an optimizer.
    Just as with the WABT, Binaryen provides an extensive suite of tools for developing
    WebAssembly tooling. The following list describes a subset of the tools that Binaryen
    provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '**wasm-shell**: Tool capable of loading and interpreting WebAssembly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**asm2wasm**: Compiles asm.js code to a Wasm module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wasm2js**: Compiles a Wasm module to JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wasm-merge**: Combines multiple Wasm files into one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wasm.js**: JavaScript library that includes the Binaryen interpreter, asm2wasm,
    the Wat parser, and other Binaryen tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**binaryen.js**: JavaScript library that provides a JavaScript interface for
    the Binaryen toolchain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wasm.js and binaryen.js tools are of particular interest for JavaScript
    developers interested in building WebAssembly tooling. The `binaryen.js` library
    is available as an `npm` package ([https://www.npmjs.com/package/binaryen](https://www.npmjs.com/package/binaryen)).
  prefs: []
  type: TYPE_NORMAL
- en: An excellent example of `binaryen.js` usage is AssemblyScript ([https://github.com/AssemblyScript/assemblyscript](https://github.com/AssemblyScript/assemblyscript)).
    AssemblyScript is a strictly typed subset of TypeScript that generates WebAssembly
    modules. The library comes packaged with a CLI to quickly scaffold new projects
    and manage the build step. In the *Compiling with LLVM *section, we'll cover how
    to compile Wasm modules using LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling with LLVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1, ](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)*What is WebAssembly?*,
    we discussed the relationship between Emscripten's EMSDK and LLVM. Emscripten
    uses LLVM and Clang to compile C/C++ down to LLVM bitcode. The Emscripten compiler
    (`emcc`) compiles that bitcode to asm.js, which is passed to Binaryen to generate
    a Wasm file. If you're interested in using LLVM, you can compile C/C++ to Wasm
    without installing the EMSDK. In this section, we will review the process for
    enabling Wasm compilation using LLVM. After compiling some example C++ code to
    a Wasm file, we'll try it out in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The installation process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to compile WebAssembly modules using LLVM, several tools need to
    be installed and configured. Getting these tools working together correctly can
    be an arduous and time-consuming process. Fortunately, someone went through the
    trouble of making this process much simpler. Daniel Wirtz created an `npm` package
    named `webassembly` ([https://www.npmjs.com/package/webassembly](https://www.npmjs.com/package/webassembly))
    that can perform the following operations (with the corresponding CLI commands):'
  prefs: []
  type: TYPE_NORMAL
- en: Compile C/C++ code to a WebAssembly module (`wa compile`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link multiple WebAssembly modules to one (`wa link`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decompile a WebAssembly module to text format (`wa disassemble`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble WebAssembly text format to a module (`wa assemble`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The library is using Binaryen, Clang, LLVM, and additional LLVM tools behind
    the scenes. We''ll install this package globally to ensure we have access to the
    `wa` command. To install, open a terminal instance and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It may take a few minutes to install any required dependencies. Once complete,
    run the following command to validate the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following in terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02098a68-e5fa-4ef1-8370-ba78bed728b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the wa command
  prefs: []
  type: TYPE_NORMAL
- en: You should be ready to start compiling Wasm modules. Let's move on to the example
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test out the compiler, we're going to use a slightly modified version of
    the `without-glue.c` file from the *Interacting with JavaScript without glue code*
    section of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*. The code for this section is located in the
    `/chapter-10-advanced-tools/compile-with-llvm` directory of the `learn-webassembly`
    repository. Follow the following instructions to create the files necessary for
    the compiler test. Let's start with the C++ file.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new directory in your `/book-examples` directory named `/compile-with-llvm`.
    Create a new file in the `/compile-with-llvm` directory named `main.cpp` and populate
    it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code in this file is almost identical to the contents of `without-glue.c`
    from [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading
    a WebAssembly Module*. The comments have been removed from the file and the imported/exported
    functions are wrapped in an `extern "C"` block. The `__attribute__((visibility("default")))`
    lines are macro statements (similar to `EMSCRIPTEN_KEEPALIVE`) that ensure the
    functions aren't removed from the compiled output during the dead-code elimination
    step. Just as with prior examples, we'll interact with the compiled Wasm module
    through an HTML file. Let's create that next.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a file named `index.html` in the `/compile-with-llvm` directory and
    populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The contents of this file are very similar to the `without-glue.html` file from
    [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading
    a WebAssembly Module*. Instead of using the `loadWasm()` function from the `/common/load-wasm.js`
    file, we're using the `WebAssembly.instantiateStreaming()` function. This allows
    us to omit an additional `<script>` element and serve the files directly from
    the `/compile-with-llvm` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `_` is omitted from the `jsFillRect` and `jsClearRect` functions passed
    into the `importObj`. We can omit the `_` for the functions present on the `instance.exports`
    object as well. LLVM doesn't prefix any of the data/functions passed in or out
    of the module with a `_`. In the next section, we'll compile `main.cpp` and interact
    with the resultant Wasm file in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running the example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We installed the `webassembly npm` package with the `-g` flag, so the `wa`
    command should be available in the terminal. Open a terminal instance in the `/compile-with-llvm`
    directory and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file named `main.wasm` appear in the `compile-with-llvm` folder
    of VS Code''s file explorer. To ensure the Wasm module compiled correctly, run
    the following command within the `/compile-with-llvm` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you navigate to `http://127.0.0.1:8080/index.html` in your browser, you
    should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb069bef-1df9-437f-b2ce-8622b845ef2c.png)'
  prefs: []
  type: TYPE_IMG
- en: LLVM compiled module running in the browser
  prefs: []
  type: TYPE_NORMAL
- en: Online tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The installation and configuration process for compiling WebAssembly modules
    locally is, admittedly, a little cumbersome. Fortunately, there are several online
    tools available that allow you to develop and interact with WebAssembly in the
    browser. In this section, we'll review those tools and discuss the functionality
    each one provides.
  prefs: []
  type: TYPE_NORMAL
- en: WasmFiddle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Connecting the dots with WasmFiddle* section in [Chapter 2](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml), *Elements
    of WebAssembly* *- Wat, Wasm, and the JavaScript API*, we used WasmFiddle to compile
    a simple C function to Wasm and interact with it using JavaScript. WasmFiddle
    provides a C/C++ editor, JavaScript editor, Wat/x86 viewer, and JavaScript output
    panel. You can also interact with the `<canvas>` if desired. WasmFiddle uses LLVM
    to generate the Wasm modules, which is why the imports and exports aren't prefixed
    with a `_`. You can interact with WasmFiddle at [https://wasdk.github.io/WasmFiddle](https://wasdk.github.io/WasmFiddle).
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly Explorer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebAssembly Explorer, located at [https://mbebenita.github.io/WasmExplorer](https://mbebenita.github.io/WasmExplorer),
    provides similar functionality to WasmFiddle. It allows you to compile C or C++
    to a Wasm module and view the corresponding Wat. However, WebAssembly Explorer
    provides additional functionality not present in WasmFiddle. For example, you
    can compile C or C++ to Wasm and view the corresponding Firefox x86 and LLVM x86
    code. You can select from a list of code examples and specify the optimization
    level (`-O` flag in `emcc`). It also provides a button that allows you to import
    the code into WasmFiddle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbe79b3c-c5b9-41b1-b817-e71e0e85c3fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of WebAssembly Explorer
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebAssembly Studio, located at [https://webassembly.studio](https://webassembly.studio),
    is a feature-rich editor and development environment. You can create C, Rust,
    and AssemblyScript projects. It provides the capabilities to build and run code
    within the browser and integrates well with GitHub. WebAssembly Studio enables
    you to build a web application without having to install and configure the required
    WebAssembly tooling locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/586895b5-ace5-4179-9423-bae1c39361ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of WebAssembly Studio
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll demonstrate how to add parallelism to your WebAssembly
    application with Web Workers.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel Wasm with Web Workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of building a complex application that performs heavy computation
    or other resource-intensive work can benefit greatly from using **threads**. Threads
    allow you to perform operations in parallel by dividing functionality among tasks
    that run independently. At of writing this, support for threads in WebAssembly
    is in the *Feature Proposal* phase. In this phase, the specification hasn't been
    written and the feature isn't implemented. Fortunately, JavaScript provides threading
    capabilities in the form of Web Workers. In this section, we'll demonstrate how
    to use JavaScript's Web Workers API to interact with Wasm modules in separate
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: Web Workers and WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Workers allow you to utilize threads in the browser, which can improve the
    performance of your application by offloading some of the logic from the main
    (UI) thread. Worker threads are also capable of performing I/O using `XMLHttpRequest`.
    Worker threads communicate with the main thread by posting messages to an event
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Web Workers allow us to load Wasm modules into separate threads and perform
    operations that don't hinder the performance of the UI. Web Workers do have some
    limitations. They're unable to directly manipulate the DOM or access some of the
    methods and properties on the `window` object. The messages passed between threads
    must be serialized objects, which means you can't pass functions. Now that you
    know what a worker is, let's discuss how to create one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can create a worker, you need a JavaScript file with code that runs
    in the worker thread. You can see a simple example of a worker definition file
    at [https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js](https://github.com/mdn/simple-web-worker/blob/gh-pages/worker.js).
    The file should contain a `message` event listener that performs operations when
    messages are received from other threads and responds accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Once that file is created, you're ready to use it with a worker. A worker is
    created by passing a URL argument to the `Worker()` constructor. The URL can be
    a string representing the name of the file with your worker definition code, or
    constructed using a `Blob`. The `Blob` technique can be useful if you're fetching
    the worker definition code from a server. The example application demonstrates
    how to use both approaches. Let's move on to the process of integrating WebAssembly
    with Web Workers.
  prefs: []
  type: TYPE_NORMAL
- en: The WebAssembly workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to utilize Wasm modules in separate threads, the Wasm file must be
    compiled in the main thread and instantiated in a Web Worker. Let''s review this
    process in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: A new Web Worker (we'll refer to it as `wasmWorker`) is created using the `Worker()`
    constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A fetch call is made to retrieve a `.wasm` file and the `arrayBuffer()` function
    is called on the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resolved value of the `arrayBuffer()` function is passed to the `WebAssembly.compile()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `WebAssembly.compile()` function resolves with a `WebAssembly.Module` instance,
    which is included in the body of a message posted to the `wasmWorker` using the
    `postMessage()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `wasmWorker`, the `WebAssembly.Module` instance from the message body
    is passed to the `WebAssembly.instantiate()` function, which resolves with a `WebAssembly.Instance`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `WebAssembly.Instance` exports object is assigned to a local variable in
    `wasmWorker` and is used to call Wasm functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To call a function from the `wasmWorker` Wasm instance, you post a message to
    the worker thread with any arguments to pass to the Wasm function. Then, `wasmWorker`
    executes the function and passes the results back to the main thread. That's the
    crux of how threads are utilized in the context of Web Workers. Before we move
    on to the example application, you may need to address a limitation that Google
    Chrome imposes. Follow the instructions in the *Limitations in Google Chrome *section
    to ensure the example application works successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations in Google Chrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Google Chrome places a restriction on what can be included in the body of a
    Web Worker''s `postMessage()` function. If you tried to send a compiled `WebAssembly.Module`
    to a worker, you''d get an error and the operation would be unsuccessful. You
    can override this by setting a flag. To enable this functionality, open Google
    Chrome and enter `chrome://flags` in the address bar. Type `cloning` in the search
    box at the top of the page. You should see a list item titled WebAssembly structured
    cloning support. Select the Enabled option from the dropdown next to the list
    item and press the RELAUNCH NOW button when prompted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/077e795e-460d-413b-b6f4-cf82e5e797b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating the WebAssembly flag in Google Chrome
  prefs: []
  type: TYPE_NORMAL
- en: After Chrome restarts, you can run the example application without issue. If
    you're using Mozilla Firefox, no action is required. It supports this feature
    by default. Let's move on to the example application that demonstrates the use
    of WebAssembly in threads.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example application isn't much of an application. It's a simple form that
    accepts two input values and returns the sum or difference of these two values.
    The add and subtract operations are each exported from their own Wasm module instantiated
    in a worker thread. The example may be contrived, but it effectively demonstrates
    how to integrate WebAssembly into Web Workers.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section is located in the `/chapter-10-advanced-tools/parallel-wasm`
    directory of the `learn-webassembly` repository. The following sections walk through
    each section of the code base and describe how to build the application from scratch.
    If you wish to follow along, create a folder in your `/book-examples` directory
    named `/parallel-wasm`.
  prefs: []
  type: TYPE_NORMAL
- en: The C code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example uses two worker threads: one for addition and another for subtraction.
    Consequently, we''ll need two separate Wasm modules. Create a folder named `/lib`
    in your `/parallel-wasm` directory. Within the `/lib` directory, create a file
    named `add.c` and populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another file in `/lib` named `subtract.c` and populate it with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the function name in both files is `calculate`. This was done so we
    don't have to write any conditional logic within the worker code to determine
    the Wasm function to call. The algebraic operation is tied to a worker, so when
    we need to add two numbers, the `_calculate()` function will be called in the
    `addWorker`. This will become clearer when we review the JavaScript portion of
    the code, which we'll cover next.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dig into the JavaScript code, create a folder named `/src` in your
    `/parallel-wasm` directory. Let's start with the file containing the code that
    runs in the worker thread.
  prefs: []
  type: TYPE_NORMAL
- en: Defining thread execution in worker.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file in the `/src` directory named `worker.js` and populate it
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code is encapsulated within the event listener for the `message` event (`self.addEventListener(...)`),
    which is raised when the `postMessage()` function is called on the corresponding
    worker. The `event` parameter in the event listener's callback function contains
    a `data` property with the contents of the message. All of the messages passed
    between threads in the application follow the **Flux Standard Action** (**FSA**)
    convention. Objects that adhere to this convention have a `type` and `payload`
    property, where `type` is a string and `payload` can be of any type. You can read
    more about the FSA at [https://github.com/redux-utilities/flux-standard-action](https://github.com/redux-utilities/flux-standard-action).
  prefs: []
  type: TYPE_NORMAL
- en: You can use any format or structure for the data you pass using the `postMessage()`
    function, as long as the data is serializable.
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` statement executes an action based on the message's `type` value,
    which is a string. If the `type` is `'COMPILE_WASM_REQUEST'`, the `WebAssembly.instantiate()`
    function is called with the `payload` from the message and `importObj`. The `exports`
    object of the result is assigned to the local `wasmInstance` variable for later
    use. If the `type` is `'CALC_REQUEST'`, the `wasmInstance._calculate()` function
    is called with the `firstVal` and `secondVal` values from the `payload` object.
    The calculation code should shed some light on why the function was named `_calculate()`
    instead of `_add()` or `_subtract()`. By using a general name, the worker doesn't
    care what operation it's performing, it just calls the function to get the result.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the worker posts a message back to the main thread using the
    `postMessage()` function. I used a `REQUEST`/`RESPONSE` convention for the `type`
    property value. This allows you to quickly identify which thread the messages
    are originating from. Messages sent from the main thread end with `_REQUEST` in
    the `type` while responses coming from the worker threads end with `_RESPONSE`.
    Let's move on to the WebAssembly interaction code.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Wasm in WasmWorker.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file in the `/src` directory named `WasmWorker.js` and populate
    it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `WasmWorker` class manages a worker thread associated with a Wasm file.
    In the `WasmWorker` constructor, a new `Worker` is created and default event listeners
    are added for the `error` and `message` events. The `initialize()` function fetches
    the `.wasm` file associated with the `name` argument, compiles it, and sends the
    resultant `WebAssembly.Module` instance to the worker thread to be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: The `addListenerForType()` function is used to specify a `callback` function
    (`listener`) to execute when the `type` field in the message response matches
    the `type` argument passed to the function. This is required to capture the result
    of the `_calculate()` function from the worker thread.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `calculate()` function in `WasmWorker` posts a message to the worker
    thread with the `firstVal` and `secondVal` arguments passed in from the `<input>`
    elements on the `<form>`. Let's move on to the application loading code to see
    how `WasmWorker` interacts with the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the application in index.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file in the `/src` directory named `index.js` and populate it
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The application entry point is the `loadPage()` function. Before we dig into
    the worker initialization code, let''s discuss the `getWorkerUrl()` function.
    Earlier in this section, we learned that you can pass a string representing a
    filename or a URL created from a `Blob` to the `Worker()` constructor. The following
    example code demonstrates the first technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second technique is demonstrated in the `if (isBlob === 'true')` block of
    the `getWorkerUrl()` function. If the current `window.location` value ends with
    `?blob=true`, the URL passed to the `Worker()` constructor is created from a `Blob`.
    The only noticeable difference is the `document.title` value, which updates to
    reflect the URL type. Let's jump back to the `loadPage()` function to discuss
    the initialization code.
  prefs: []
  type: TYPE_NORMAL
- en: 'After an event listener is added to the Reset button in the `loadPage()` function,
    two `WasmWorker` instances are created: `addWorker` and `subtractWorker`. Each
    worker is passed to the `initializeWorker()` function as the `wasmWorker` argument.
    In `initializeWorker()`, the `wasmWorker.initialize()` function is called to instantiate
    the Wasm module. The `wasmWorker.addListenerForType()` function is called to set
    the value of the Result `<input>` to the value returned from the `_calculate()`
    function in the corresponding worker. Finally, an event listener is added to the
    `click` event of the `<button>` that either adds or subtracts the `firstVal` and
    `secondVal` `<input>` values (based on the `name` argument). That''s it for the
    JavaScript code. Let''s create an HTML and CSS file, then move on to the build
    step.'
  prefs: []
  type: TYPE_NORMAL
- en: The web assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need an HTML file to act as the entry point to the application. Create a
    file in the `/src` directory named `index.html` and populate it with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The application consists of a `<form>` with three `<input>` elements and a block
    of three `<button>` elements. The first two `<input>` elements correspond to the
    `firstVal` and `secondVal` properties included in the `payload` sent to either
    worker thread. The final `<input>` is read-only and displays the result of either
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: The block of `<button>` elements below the `<form>` perform operations on the
    `<input>` values. The first two `<button>` elements send the `<input>` values
    to either the `addWorker` or `subtractWorker` thread (depending on which button
    was pressed). The final `<button>` sets all of the `<input>` values to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application is initialized in the `<script>` tag in the last line before
    the `</body>` closing tag. Just as with Cook the Books, the `type="module"` attribute
    allows us to use the `import`/`export` syntax available in newer browsers. Finally,
    we need to add some styles to the application. Create a file in the `/src` directory
    named `styles.css` and populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That's the last file we need to create, but not the last one required to run
    the application. We still need to generate Wasm files from the C files in the
    `/lib` directory. Let's move on to the build step.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the code written, it's time to build and test the application. After completing
    the build step, we'll interact with the running application and review how to
    troubleshoot Web Workers using the browser's development tools.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the C files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to compile each C file to a separate `.wasm` file, which means the
    command needed to perform the compilation step is verbose. To perform the build,
    open a terminal instance in your `/parallel-wasm` directory and run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see two new files in the `/src` directory: `calc-add.wasm` and `calc-subtract.wasm`.
    With the required files in place, it''s time to test out the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a terminal instance in the `/parallel-wasm` directory and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you navigate to `http://127.0.0.1:8080/index.html` in your browser, you
    should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de8e6b2e-53e0-49d2-9628-af2948abcb4e.png)'
  prefs: []
  type: TYPE_IMG
- en: ￼Wasm Workers application running in the browser
  prefs: []
  type: TYPE_NORMAL
- en: 'Try changing the values in the First Value and Second Value inputs and pressing
    the Add and Subtract buttons. The Result input should update with the calculated
    result. If you navigate to `http://127.0.0.1:8080/index.html?blob=true`, the URL
    argument passed to the `Worker()` constructor will use a `Blob` instead of the
    filename. The tab should change to reflect that the `Blob` technique is used to
    construct the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06832741-0c1c-40a3-9b02-e6694db0942c.png)'
  prefs: []
  type: TYPE_IMG
- en: Tab title updated to reflect the Blob URL technique
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Web Workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can set breakpoints and interact with worker threads using the browser''s
    development tools. In Google Chrome, open Developer Tools and select the Sources
    tab. The file list panel should contain two instances of `worker.js`. The debugger
    panel contains a Threads section with the `main` thread and two `worker.js` threads.
    The following screenshot indicates the thread debugging elements within the Chrome
    Developer Tools panel for the running application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/243575cd-3c5c-43ad-a78c-cc3c248a0158.png)'
  prefs: []
  type: TYPE_IMG
- en: Thread debugging tools in the Chrome Developer Tools panel
  prefs: []
  type: TYPE_NORMAL
- en: 'In Firefox, worker debugging is done in separate Developer Tools windows. To
    see this in action, open Developer Tools in Firefox and select the Debugger panel.
    Click on one of the `worker.js` list items in the Workers panel. A new Developer
    Tools window should appear that corresponds with the selected worker. The following
    screenshot shows a separate Developer Tools window for one of the `worker.js`
    instances selected from the Workers panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/886e9bcd-c446-4a8d-aab4-2a303255aa2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Thread debugging tools in the Firefox Developer Tools panel
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll discuss some of the upcoming features of WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Upcoming features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several upcoming WebAssembly features in various phases of the standardization
    process. Some of them are more impactful than others, but all of them are valuable
    improvements. In this section, we'll describe the standardization process and
    review a subset of the features that represent a significant shift in WebAssembly's
    capabilities. Most of the content in this section was referenced from Colin Eberhardt's
    blog post titled *The future of WebAssembly - A look at upcoming features and
    proposals*. The post can be found at [https://blog.scottlogic.com/2018/07/20/wasm-future.html](https://blog.scottlogic.com/2018/07/20/wasm-future.html).
  prefs: []
  type: TYPE_NORMAL
- en: The standardization process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The WebAssembly W3C Process documentation at [https://github.com/WebAssembly/meetings/blob/master/process/phases.md](https://github.com/WebAssembly/meetings/blob/master/process/phases.md)
    describes the six phases (from 0 to 5) of the standardization process. The following
    list provides brief descriptions of each of these phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase 0\. Pre-Proposal**: A WebAssembly **Community Group** (**CG**) member
    has an idea, and the CG votes on whether to move it to Phase 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 1\. Feature Proposal**: The pre-proposal process has succeeded and
    a repository is created in the WebAssembly organization on GitHub to document
    the feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 2\. Proposed Spec Text Available**: The full proposed spec text is
    available, possible implementations are prototyped, and a test suite is added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 3\. Implementation Phase**: Embedders implement the feature, the repository
    is updated to include revisions to the formalization, and the spec is updated
    to include implementation of the feature in the reference interpreter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 4\. Standardize the Feature**: If two or more Web VMs and at least
    one toolchain implement the feature, the feature is fully handed off to the WebAssembly
    **Working Group** (**WG**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase 5\. The Feature is Standardized**: The WG members have reached consensus
    that the feature is complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you're familiar with the phases associated with the standardization
    process, let's move on to the threads proposal.
  prefs: []
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we used Web Workers to move Wasm modules into worker
    threads, which allowed us to call Wasm functions without blocking the main thread.
    However, passing messages between worker threads has performance limitations.
    In an effort to address this issue, a threads feature was proposed for WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proposal, currently in Phase 1, is described in detail at [https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md](https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md).
    Per the proposal documentation, the threads feature adds a new shared linear memory
    type and some new operations for atomic memory access. This proposal is relatively
    limited in scope. Eberhardt provides the following elaboration in his blog post:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Notably, this proposal does not introduce a mechanism for creating threads
    (which has caused a lot of debate) instead this functionality is supplied by the
    host. Within the context of wasm executed by the browser this will be the familiar
    WebWorkers."'
  prefs: []
  type: TYPE_NORMAL
- en: Although the feature wouldn't allow for the creation of threads, it provides
    a simpler way of sharing data between the worker threads we create in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Host bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The host bindings proposal, which is also in Phase 1, would address a significant
    limitation of WebAssembly when used in the browser: DOM manipulation. The proposal
    documentation at [https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md](https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md)
    provides the following list of goals for this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ergonomics**: Allow WebAssembly modules to create, pass around, call, and
    manipulate JavaScript + DOM objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: Allow JS/DOM or other host calls to be well optimized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform consistency**: Allow WebIDL to be used to annotate Wasm imports/exports
    (via a tool)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incrementalism**: Provide a strategy that is polyfillable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving WebAssembly's interoperability with JavaScript and Web APIs would
    simplify the development process considerably. It would also eliminate the need
    for the "glue" code that tools such as Emscripten provide.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **garbage collection** (**GC**) proposal is currently in Phase 1\. We discussed
    garbage collection in the *What are the Limitations?* section of [Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What
    is WebAssembly?* The proposal documentation at [https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md](https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md)
    provides an extensive overview of the feature and describes the elements that
    need to be added to the specification. Eberhardt provides the following description
    of the proposal in his blog post:'
  prefs: []
  type: TYPE_NORMAL
- en: '"This proposal adds GC capabilities to WebAssembly. Interestingly, it will
    not have its own GC, instead it will integrate with the GC provided by the host
    environment. This makes a lot of sense as this, and various other proposals (host
    bindings, reference types), are designed to improve the interop with the host,
    making it easier to share state and call APIs. Having a single GC to manage memory
    makes this much easier."'
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature will require a great deal of effort to implement, but adding it
    to WebAssembly will be worth the effort. Let''s wrap up this section with a feature
    currently in the implementation phase: reference types.'
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reference types, currently in Phase 3, form the basis for the host bindings
    and GC features. The proposal documentation at [https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md](https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md)
    describes the addition of a new type, `anyref`, which can be used as both a value
    type and a table element type. The `anyref` type allows you to pass a JavaScript
    object to a Wasm module. Eberhardt describes the implications of this feature
    in his blog post:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The wasm module can''t really do much with the object via the anyref type.
    What''s more important is that the module is holding a reference to a garbage
    collected object on the JS heap, meaning they need to be traced during wasm execution.
    This proposal is seen as a stepping-stone towards the more significant garbage
    collection proposal."'
  prefs: []
  type: TYPE_NORMAL
- en: There are several other exciting features in the pipeline for WebAssembly. The
    WebAssembly CG and WG are devoting their time and resources to making these features
    a reality. You can view all of the proposals at the WebAssembly organization page
    on GitHub, located at [https://github.com/WebAssembly](https://github.com/WebAssembly).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed advanced tools and an alternate compilation method
    for WebAssembly. We learned about WABT and Binaryen's role in the WebAssembly
    development process and the functionality they provide. We compiled a Wasm module
    with LLVM through the use of the WebAssembly `npm` package and interacted with
    the result in the browser. We reviewed some of the WebAssembly tooling available
    online and created a simple application that uses Web Workers to store Wasm modules
    in separate threads. Finally, we discussed the upcoming features of WebAssembly
    and the standardization process. Now that you've gained a greater understanding
    of WebAssembly, go out there and build something!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does WABT stand for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What three elements does Binaryen provide to make compiling to WebAssembly *easy*,
    *fast*, and *effective*?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the main difference between modules compiled using Emscripten versus
    LLVM with regard to the `importObj`/`exports`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which online tool allows you to use AssemblyScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the two types of arguments you can pass to the `Worker()` constructor?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What convention was used for passing messages between the main thread and worker
    threads?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many phases are in the WebAssembly standardization process?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the name of the new type defined in the reference types feature?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A crash course in memory management: [https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management](https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MDN Web Workers API: [https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebAssembly - Web Workers: [https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a](https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
