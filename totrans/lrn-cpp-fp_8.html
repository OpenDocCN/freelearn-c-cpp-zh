<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating and Debugging Application in Functional Approach</h1>
                </header>
            
            <article>
                
<p>We discussed some basic techniques to develop functional programming in the previous chapters that include a first-class function, a pure function, and an immutable object. In this chapter, we will use all the techniques we have learned in the previous chapters to produce an application in a functional way. It will also explain how to debug an application that is built using the C++ language.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Preparing an imperative code as a base code to be transformed to the functional code</li>
<li>Implementing the pure function to the base code</li>
<li>Implementing the template metaprogramming to the base code</li>
<li>Implementing the filtering technique to the base code using the Lambda expression</li>
<li>Implementing the recursion technique to the base code</li>
<li>Implementing the memoization technique to the base code</li>
<li>Debugging the code to solve, if we get an unexpected result</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing an imperative class</h1>
                </header>
            
            <article>
                
<p>We will now develop the functional class so we can consume it to our functional program. Before that, let's prepare a new imperative class named <kbd>Customer</kbd>. The class will have an <kbd>int</kbd> property named <kbd>id</kbd> <span>as a unique customer ID number. It also has</span> four string properties to store the information about our customer--<kbd>name</kbd>, <kbd>address</kbd>, <kbd>phoneNumber</kbd>, and <kbd>email</kbd>. The class also has a flag--<kbd>isActive</kbd>--to indicate whether or not our customer is active. If the customer has signed a contract with us, they are regarded as an active customer. Another property is <kbd>registeredCustomers</kbd>, to save all registered customers we have, regardless of the active customer. We will make the <kbd>registeredCustomers</kbd> <span>member become <kbd>static</kbd> so we can fill it from outside the class and can keep the list of the</span> <kbd>Customer</kbd> class<span>.</span></p>
<p>Besides these properties, our class will also have four methods to access the list of our properties. They will be the following methods:</p>
<ul>
<li><kbd>GetActiveCustomerNames()</kbd>: This can be used to get the list of active customer names</li>
<li><kbd>GetActiveCustomerAddresses()</kbd>: This can be used to get the list of active customer addresses</li>
<li><kbd>GetActiveCustomerPhoneNumbers()</kbd>: This can be used to get the list of active customer phone numbers</li>
<li><kbd>GetActiveCustomerEmails()</kbd>: This can be used to get the list of active customer emails</li>
</ul>
<p>Now, let's take a look at the following <kbd>Customer.h</kbd> code that we can find in the <kbd>Step01</kbd> folder to accommodate our preceding scenario:</p>
<pre>
    /* Customer.h - Step01 */<br/>    #ifndef __CUSTOMER_H__<br/>    #define __CUSTOMER_H__<br/><br/>    #include &lt;string&gt;<br/>    #include &lt;vector&gt;<br/><br/>    class Customer<br/>    {<br/>      public:<br/>        static std::vector&lt;Customer&gt; registeredCustomers;<br/>        int id = 0;<br/>        std::string name;<br/>        std::string address;<br/>        std::string phoneNumber;<br/>        std::string email;<br/>        bool isActive = true;<br/><br/>        std::vector&lt;std::string&gt; GetActiveCustomerNames();<br/>        std::vector&lt;std::string&gt; GetActiveCustomerAddresses();<br/>        std::vector&lt;std::string&gt; GetActiveCustomerPhoneNumbers();<br/>        std::vector&lt;std::string&gt; GetActiveCustomerEmails();<br/>    };<br/>    #endif // __CUSTOMER_H__
</pre>
<p>From the preceding code, we have four public methods that haven't been defined yet. Now, let's define them as we can see in the following <kbd>Customer.cpp</kbd> code:</p>
<pre>
    /* Customer.cpp - Step01 */<br/>    #include "Customer.h"<br/><br/>    using namespace std;<br/><br/>    vector&lt;Customer&gt; Customer::registeredCustomers;<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerNames()<br/>    {<br/>      vector&lt;string&gt; returnList;<br/>      for (auto &amp;customer : Customer::registeredCustomers)<br/>      {<br/>        if (customer.isActive)<br/>        {<br/>            returnList.push_back(customer.name);<br/>        }<br/>      }<br/>       return returnList;<br/>    }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerAddresses()<br/>    {<br/>      vector&lt;string&gt; returnList;<br/>      for (auto &amp;customer : Customer::registeredCustomers)<br/>      {<br/>        if (customer.isActive)<br/>        {<br/>            returnList.push_back(customer.address);<br/>        }<br/>      }<br/>      return returnList;<br/>    }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerPhoneNumbers()<br/>    {<br/>      vector&lt;string&gt; returnList;<br/>      for (auto &amp;customer : Customer::registeredCustomers)<br/>      {<br/>        if (customer.isActive)<br/>        {<br/>            returnList.push_back(customer.phoneNumber);<br/>        }<br/>      }<br/>      return returnList;<br/>    }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerEmails()<br/>    {<br/>      vector&lt;string&gt; returnList;<br/>      for (auto &amp;customer : Customer::registeredCustomers)<br/>      {<br/>        if (customer.isActive)<br/>        {<br/>            returnList.push_back(customer.email);<br/>        }<br/>      }<br/>      return returnList;<br/>    } 
</pre>
<p>From the preceding code, we can see the definition of the four methods we have in the <kbd>Customer</kbd> class. For instance, in the <kbd>GetActiveCustomerNames()</kbd> <span>method, the code loops each element in the</span> <kbd>registeredCustomers</kbd> vector to find out the active customer. If it finds them, the code will extract the name of each customer and store it to the <kbd>returnList</kbd> vector. After finishing the method process, the method will feed the <kbd>returnList</kbd> <span>result to the method user.</span></p>
<p>Now, let's consume the preceding class using the following <kbd>main.cpp</kbd> code:</p>
<pre>
    /* Main.cpp - Step01 */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include "Customer.h"<br/><br/>    using namespace std;<br/><br/>    void RegisterCustomers()<br/>    {<br/>      int i = 0;<br/>      bool b = false;<br/><br/>      // Initialize name<br/>      vector&lt;string&gt; nameList =<br/>      {<br/>        "William",<br/>        "Aiden",<br/>        "Rowan",<br/>        "Jamie",<br/>        "Quinn",<br/>        "Haiden",<br/>        "Logan",<br/>        "Emerson",<br/>        "Sherlyn",<br/>        "Molly"<br/>       };<br/><br/>       // Clear the registeredCustomers vector array<br/>       Customer::registeredCustomers.clear();<br/><br/>       for (auto name : nameList)<br/>       {<br/>         // Create Customer object<br/>         // and fill all properties<br/>         Customer c;<br/>         c.id = i++;<br/>         c.name = name;<br/>         c.address = "somewhere";<br/>         c.phoneNumber = "0123";<br/>         c.email = name + "@xyz.com";<br/>         c.isActive = b;<br/><br/>         // Flip the b value<br/>         b = !b;<br/> <br/>         // Send data to the registeredCustomers<br/>         Customer::registeredCustomers.push_back(c);<br/>      }<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[Step01]" &lt;&lt; endl;<br/>      cout &lt;&lt; "--------" &lt;&lt; endl;<br/><br/>      // Fill the Customer::registeredCustomers<br/>      // with the content<br/>      RegisterCustomers();<br/><br/>      // Instance Customer object<br/>      Customer customer;<br/><br/>      // Get the active customer names<br/>      cout &lt;&lt; "List of active customer names:" &lt;&lt; endl;<br/>      vector&lt;string&gt; activeCustomerNames =<br/>        customer.GetActiveCustomerNames();<br/>      for (auto &amp;name : activeCustomerNames)<br/>      {<br/>        cout &lt;&lt; name &lt;&lt; endl;<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>From the preceding code, in the <kbd>main()</kbd> method, we can see that we first register our customer from the <kbd>RegisterCustomers()</kbd> method. There, we fill the static public property of the <kbd>Customer</kbd> class, <kbd>registeredCustomers</kbd>, with a bunch of our customer information. After that, the code instances the <kbd>Customer</kbd> class and invokes the method of the class named <kbd>GetActiveCustomerNames()</kbd>. As we can see, the method returns a vector of string that contains the list of active customer names that we will then store in the <kbd>activeCustomerNames</kbd> vector. Now, we can iterate the vector to extract the list of the active customer names. The following is the output we should see in the console:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/0c74fd8b-73c6-4039-b261-75edddd462dd.png"/></div>
<p>As we can see in the <kbd>RegisterCustomer()</kbd> method, only five from ten customers are active, so not all of the names will be listed in the preceding output. We can try the remaining three methods to the information about the active customers specifically, their addresses, phone numbers, and email addresses. Our goal in this chapter is to use the concepts we've learned in the previous chapters and make an application using the functional approach. So, let's see how we can achieve that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring the imperative class to become a functional class</h1>
                </header>
            
            <article>
                
<p>Indeed, the preceding <kbd>Customer</kbd> class can work well, and we have successfully invoked its methods. However, the class can still be tweaked by transforming it into a functional class. As we can see in the preceding code, we can implement a pure function, first-class function, higher-order function, and memoization to it to make it become functional. So, in this section, we will refactor the <kbd>Customer</kbd> class to become a functional class and use the knowledge we have from the previous chapters. In the upcoming section, <span>we will implement the functional method that we have discussed in the previous chapter, which is the</span> first<span>-class function.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing a function as a parameter</h1>
                </header>
            
            <article>
                
<p>As we discussed in <a href="a1baf007-8f40-4616-8718-9887f95120b0.xhtml" target="_blank">Chapter 2</a>, <em>Manipulating Functions in Functional Programming</em>, we can rewrite the function to be a first-class function, which means we can pass a function to another function. We will simplify the definition of all the four methods we have in the <kbd>Step01</kbd> code, then we will call the function by passing it to another method named <kbd>GetActiveCustomerByFunctionField()</kbd>. We will also create a new method named <kbd>GetActiveCustomerByField()</kbd> to select the correct method we should run. The definition of the <kbd>Customer</kbd> class is now like the following <kbd>Customer.h</kbd> code:</p>
<pre>
    /* Customer.h - Step02 */<br/>    #ifndef __CUSTOMER_H__<br/>    #define __CUSTOMER_H__<br/><br/>    #include &lt;string&gt;<br/>    #include &lt;vector&gt;<br/>    #include &lt;functional&gt;<br/><br/>    class Customer<br/>    {<br/>      private:<br/>        std::string GetActiveCustomerNames(<br/>          Customer customer) const;<br/>        std::string GetActiveCustomerAddresses(<br/>          Customer customer) const;<br/>        std::string GetActiveCustomerPhoneNumbers(<br/>          Customer customer) const;<br/>        std::string GetActiveCustomerEmails(<br/>          Customer customer) const;<br/><br/>      public:<br/>        static std::vector&lt;Customer&gt; registeredCustomers;<br/>        int id = 0;<br/>        std::string name;<br/>        std::string address;<br/>        std::string phoneNumber;<br/>        std::string email;<br/>        bool isActive = true;<br/><br/><strong>        std::vector&lt;std::string&gt; GetActiveCustomerByField(</strong><br/><strong>          const std::string &amp;field);</strong><br/><br/><strong>        std::vector&lt;std::string&gt; GetActiveCustomerByFunctionField(</strong><br/><strong>          std::function&lt;std::string(const Customer&amp;, Customer)&gt; </strong><br/><strong>          funcField);</strong><br/>     };<br/>     #endif //#ifndef __CUSTOMER_H__
</pre>
<p>As we can see in the preceding header file, besides the four private methods, we add a new public method named <kbd>GetActiveCustomerByFunctionField()</kbd>, which we will invoke when we need a list of one of the properties. Now, let's define the four methods we create in the preceding header file. The code should be as the following <kbd>Customer.cpp</kbd> file:</p>
<pre>
    /* Customer.cpp - Step02 */<br/>    #include &lt;stdexcept&gt;<br/>    #include "Customer.h"<br/><br/>    using namespace std;<br/><br/>    vector&lt;Customer&gt; Customer::registeredCustomers;<br/><br/>    string Customer::GetActiveCustomerNames(<br/>      Customer customer) const<br/>      {<br/>        <strong>return customer.name;</strong><br/>      }<br/><br/>    string Customer::GetActiveCustomerAddresses(<br/>      Customer customer) const<br/>      {<br/>        <strong>return customer.address;</strong><br/>      }<br/><br/>    string Customer::GetActiveCustomerPhoneNumbers(<br/>      Customer customer) const<br/>      {<br/>        <strong>return customer.phoneNumber;</strong><br/>      }<br/><br/>    string Customer::GetActiveCustomerEmails(<br/>      Customer customer) const<br/>      {<br/><strong>        return customer.email;</strong><br/>      }<br/><br/><strong>    vector&lt;string&gt; Customer::GetActiveCustomerByFunctionField(</strong><br/><strong>      function&lt;string(const Customer&amp;, Customer)&gt; funcField)</strong><br/><strong>       {</strong><br/><strong>         vector&lt;string&gt; returnList;</strong><br/> <br/><strong>         Customer c;</strong><br/>  <br/><strong>         for (auto customer : Customer::registeredCustomers)</strong><br/><strong>         {</strong><br/><strong>           if (customer.isActive)</strong><br/><strong>           {</strong><br/><strong>             returnList.push_back(</strong><br/><strong>                funcField(c, customer));</strong><br/><strong>           }</strong><br/><strong>         }</strong><br/><strong>         return returnList;</strong><br/><strong>       }</strong><br/><br/><strong>       vector&lt;string&gt; Customer::GetActiveCustomerByField(</strong><br/><strong>       const string &amp;field)</strong><br/><strong>       {</strong><br/><strong>       function&lt;string(const Customer&amp;, Customer)&gt; funct;</strong><br/><br/><strong>       if (field == "name")</strong><br/><strong>       {</strong><br/><strong>         funct = &amp;Customer::GetActiveCustomerNames;</strong><br/><strong>       }</strong><br/><strong>       else if (field == "address")</strong><br/><strong>       {</strong><br/><strong>         funct = &amp;Customer::GetActiveCustomerAddresses;</strong><br/><strong>       }</strong><br/><strong>       else if (field == "phoneNumber")</strong><br/><strong>       {</strong><br/><strong>         funct = &amp;Customer::GetActiveCustomerPhoneNumbers;</strong><br/><strong>       }</strong><br/><strong>       else if (field == "email")</strong><br/><strong>       {</strong><br/><strong>         funct = &amp;Customer::GetActiveCustomerEmails;</strong><br/><strong>       }</strong><br/><strong>       else</strong><br/><strong>       {</strong><br/><strong>         throw invalid_argument("Unknown field");</strong><br/><strong>       }</strong><br/><br/><strong>       return GetActiveCustomerByFunctionField(funct);</strong><br/><strong>     }</strong>
</pre>
<p>Comparing with the <kbd>Step01</kbd> code, the implementation of the <kbd>GetActiveCustomerNames()</kbd><span>,</span> <kbd>GetActiveCustomerAddresses()</kbd><span>,</span> <kbd>GetActiveCustomerPhoneNumbers()</kbd><span>, and</span> <kbd>GetActiveCustomerEmails()</kbd> <span>methods is more concise now. They only contain a single line code. However, we need a new method to accommodate the process to get a list of the class' private properties, that is the</span> <kbd>GetActiveCustomerByField()</kbd> method. The method is passed to the function to make it a first-class function, as we can see in the preceding code. In this <kbd>Step02</kbd> folder, the <kbd>main.cpp</kbd> code should be as follows:</p>
<pre>
    /* Main.cpp - Step02 */<br/>    #include &lt;iostream&gt;<br/>    #include "Customer.h"<br/><br/>    using namespace std;<br/><br/>    void RegisterCustomers()<br/>    {<br/>      int i = 0;<br/>      bool b = false;<br/><br/>      // Initialize name<br/>      vector&lt;string&gt; nameList =<br/>      {<br/>        "William",<br/>        "Aiden",<br/>        "Rowan",<br/>        "Jamie",<br/>        "Quinn",<br/>        "Haiden",<br/>        "Logan",<br/>        "Emerson",<br/>        "Sherlyn",<br/>        "Molly"<br/>       };<br/><br/>      // Clear the registeredCustomers vector array<br/>      Customer::registeredCustomers.clear();<br/>      for (auto name : nameList)<br/>      {<br/>        // Create Customer object<br/>        // and fill all properties<br/>        Customer c;<br/>        c.id = i++;<br/>        c.name = name;<br/>        c.address = "somewhere";<br/>        c.phoneNumber = "0123";<br/>        c.email = name + "@xyz.com";<br/>        c.isActive = b;<br/><br/>        // Flip the b value<br/>        b = !b;<br/><br/>        // Send data to the registeredCustomers<br/>        Customer::registeredCustomers.push_back(c);<br/>       }<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[Step02]" &lt;&lt; endl;<br/>      cout &lt;&lt; "--------" &lt;&lt; endl;<br/><br/>      // Fill the Customer::registeredCustomers<br/>      // with the content<br/>      RegisterCustomers();<br/><br/>      // Instance Customer object<br/>      Customer customer;<br/><br/>      // Get the active customer names<br/>      cout &lt;&lt; "List of active customer names:" &lt;&lt; endl;<br/>      <strong>vector&lt;string&gt; activeCustomerNames =</strong><br/><strong>        customer.GetActiveCustomerByField("name");</strong><br/>      for (auto &amp;name : activeCustomerNames)<br/>      {<br/>        cout &lt;&lt; name &lt;&lt; endl;<br/>      }<br/> <br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding <kbd>main.cpp</kbd> code, we will now invoke the <kbd>GetActiveCustomerByField()</kbd> method instead of <kbd>GetActiveCustomerNames()</kbd>, as we do in <kbd>Step01</kbd>. We just need to pass a field name in string data type to the <kbd>GetActiveCustomerNames()</kbd> method and it will call the appropriate method to retrieve the properties value. For instance, we will retrieve the <kbd>name</kbd> properties value because we pass <kbd>name</kbd> in the <kbd>GetActiveCustomerByField()</kbd> method. And, if we run the preceding <kbd>Step02</kbd> code, we s<span>hould see the following screenshot, which is exactly the</span> same <span>as what we see in the</span> <kbd>Step01</kbd> <span>code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/793236ef-020b-465c-b392-8edceb8b9408.png"/></div>
<p>Although we have the code running properly, there's a problem we will face if we want to add more fields or properties to the class, and then need to collect the list of that new field. By using the preceding code, we have to add a new <kbd>else</kbd> section in the <kbd>GetActiveCustomerByFunctionField()</kbd> <span>method.</span> Next, we will find the solution to counter it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a base class</h1>
                </header>
            
            <article>
                
<p>If we want to add more fields in the class and want to access the list of it easily every time we add a new field, we have to create a new class that derives from a base class containing a virtual function. By doing this, we can derive the base class virtual method and implement the correct code to it. We will also gain the power of template metaprogramming here, since we will design the base class as a template. The declaration of the base class will be as follows:</p>
<pre>
    template&lt;typename T, typename U&gt;<br/>    class BaseClass<br/>    {<br/>      public:<br/>        virtual U InvokeFunction(<br/>          const std::shared_ptr&lt;T&gt;&amp;) = 0;<br/>    };
</pre>
<p>Now, we can declare four new classes derived from the base class for the four methods in the class. The declaration of the classes should be as follows:</p>
<pre>
    class CustomerName :<br/>      public BaseClass&lt;Customer, std::string&gt;<br/>      {<br/>        public:<br/>          virtual std::string InvokeFunction(<br/>            const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>          {<br/>             return customer-&gt;name;<br/>          }<br/>      };<br/><br/>    class CustomerAddress :<br/>      public BaseClass&lt;Customer, std::string&gt;<br/>      {<br/>        public:<br/>          virtual std::string InvokeFunction(<br/>            const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>            {<br/>              return customer-&gt;address;<br/>            }<br/>      };<br/><br/>    class CustomerPhoneNumber :<br/>      public BaseClass&lt;Customer, std::string&gt;<br/>      {<br/>         public:<br/>           virtual std::string InvokeFunction(<br/>             const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>             {<br/>               return customer-&gt;phoneNumber;<br/>             }<br/>      };<br/><br/>    class CustomerEmail :<br/>      public BaseClass&lt;Customer, std::string&gt;<br/>      {<br/>        public:<br/>          virtual std::string InvokeFunction(<br/>            const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>            {<br/>              return customer-&gt;email;<br/>            }<br/>    };
</pre>
<p>We also need to modify the argument type for the <kbd>GetActiveCustomerByFunctionField()</kbd> <span>method, so the signature of the method should be as follows:</span></p>
<pre>
    template&lt;typename T&gt;<br/>    static std::vector&lt;T&gt; GetActiveCustomerByFunctionField(<br/>      const std::shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt;<br/>        &amp;classField);
</pre>
<p>Additionally, the complete header file for this <kbd>Step03</kbd> code that implements the preceding codes should be as follows:</p>
<pre>
    /* Customer.h - Step03 */<br/>    #ifndef __CUSTOMER_H__<br/>    #define __CUSTOMER_H__<br/><br/>    #include &lt;string&gt;<br/>    #include &lt;vector&gt;<br/>    #include &lt;memory&gt;<br/><br/>    class Customer<br/>    {<br/>      private:<br/>        template&lt;typename T, typename U&gt;<br/>        class BaseClass<br/>        {<br/>          public:<br/>            virtual U InvokeFunction(<br/>            const std::shared_ptr&lt;T&gt;&amp;) = 0;<br/>         };<br/><br/>        class CustomerName :<br/>          public BaseClass&lt;Customer, std::string&gt;<br/>          {<br/>            public:<br/>              virtual std::string InvokeFunction(<br/>                const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>                {<br/>                  return customer-&gt;name;<br/>                }<br/>          };<br/><br/>        class CustomerAddress :<br/>          public BaseClass&lt;Customer, std::string&gt;<br/>          {<br/>            public:<br/>              virtual std::string InvokeFunction(<br/>                const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>                {<br/>                  return customer-&gt;address;<br/>                }<br/>          };<br/><br/>        class CustomerPhoneNumber :<br/>          public BaseClass&lt;Customer, std::string&gt;<br/>          {<br/>            public:<br/>            virtual std::string InvokeFunction(<br/>              const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>              {<br/>                return customer-&gt;phoneNumber;<br/>               }<br/>          };<br/><br/>        class CustomerEmail :<br/>          public BaseClass&lt;Customer, std::string&gt;<br/>          {<br/>            public:<br/>              virtual std::string InvokeFunction(<br/>                const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>                {<br/>                  return customer-&gt;email;<br/>                }<br/>           };<br/><br/>         public:<br/>           static std::vector&lt;Customer&gt; registeredCustomers;<br/>           int id = 0;<br/>           std::string name;<br/>           std::string address;<br/>           std::string phoneNumber;<br/>           std::string email;<br/>           bool isActive = true;<br/><br/>           static std::vector&lt;std::string&gt; GetActiveCustomerNames();<br/>           static std::vector&lt;std::string&gt; <br/>             GetActiveCustomerAddresses();<br/>           static std::vector&lt;std::string&gt; <br/>             GetActiveCustomerPhoneNumbers();<br/>           static std::vector&lt;std::string&gt; GetActiveCustomerEmails();<br/><br/>           template&lt;typename T&gt;<br/>           static std::vector&lt;T&gt; GetActiveCustomerByFunctionField(<br/>             const std::shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt;<br/>             &amp;classField);<br/>      };<br/>     #endif // __CUSTOMER_H__
</pre>
<p>Now, each method in each preceding class has a different task and can be identified by the class' name. We will also modify the <kbd>GetActiveCustomerByFunctionField()</kbd> <span>method implementation since it's now passed a new argument type, which is the class name. By passing a class, it's now easier to pass our desired task that lied in the class' method.</span> <span>The implementation of the <kbd>GetActiveCustomerByFunctionField()</kbd> method should be as follows:</span></p>
<pre>
    template&lt;typename T&gt;<br/>    vector&lt;T&gt; Customer::GetActiveCustomerByFunctionField(<br/>      const shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt; &amp;classField)<br/>      {<br/>        vector&lt;T&gt; returnList;<br/>        for (auto customer : Customer::registeredCustomers)<br/>        {<br/>          if (customer.isActive)<br/>           {<br/>            returnList.push_back(<br/>              classField-&gt;InvokeFunction(<br/>                make_shared&lt;Customer&gt;(customer)));<br/>           }<br/>         }<br/>         return returnList;<br/>       }
</pre>
<p>As we can see, the preceding method can run the method of the class we have passed, which is <kbd>classField</kbd>. Moreover, since the class we have is derived from the <kbd>BaseClass</kbd> class, we can notify the method to receive the parameter typed <span><kbd>BaseClass</kbd>.</span></p>
<p>Now we can implement the public method that we have declared in the header file-- the <kbd>GetActiveCustomerNames()</kbd>, <kbd>GetActiveCustomerAddresses()</kbd>, <kbd>GetActiveCustomerPhoneNumbers()</kbd>, and <kbd>GetActiveCustomerEmails()</kbd> methods. These four methods will invoke the <kbd>GetActiveCustomerByFunctionField()</kbd> <span>method and pass the definition of the <kbd>InvokeFunction()</kbd> method. The code should be as follows:</span></p>
<pre>
    vector&lt;string&gt; Customer::GetActiveCustomerNames()<br/>    {<br/>      return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        make_shared&lt;CustomerName&gt;());<br/>    }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerAddresses()<br/>    {<br/>      return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        make_shared&lt;CustomerAddress&gt;());<br/>    }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerPhoneNumbers()<br/>    {<br/>      return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        make_shared&lt;CustomerPhoneNumber&gt;());<br/>    }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerEmails()<br/>    {<br/>      return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        make_shared&lt;CustomerEmail&gt;());<br/>    }
</pre>
<p>Then, we will have a complete <kbd>Customer.cpp</kbd> file as follows:</p>
<pre>
    /* Customer.cpp - Step03 */<br/>    #include "Customer.h"<br/><br/>    using namespace std;<br/><br/>    vector&lt;Customer&gt; Customer::registeredCustomers;<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerNames()<br/>    {<br/>      return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        make_shared&lt;CustomerName&gt;());<br/>    }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerAddresses()<br/>    {<br/>      return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        make_shared&lt;CustomerAddress&gt;());<br/>    }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerPhoneNumbers()<br/>    {<br/>      return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        make_shared&lt;CustomerPhoneNumber&gt;());<br/>    }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerEmails()<br/>    {<br/>      return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        make_shared&lt;CustomerEmail&gt;());<br/>    }<br/><br/>    template&lt;typename T&gt;<br/>    vector&lt;T&gt; Customer::GetActiveCustomerByFunctionField(<br/>    const shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt; &amp;classField)<br/>    {<br/>      vector&lt;T&gt; returnList;<br/>      for (auto &amp;customer : Customer::registeredCustomers)<br/>      {<br/>        if (customer.isActive)<br/>        {<br/>          returnList.push_back(<br/>            classField-&gt;InvokeFunction(<br/>              make_shared&lt;Customer&gt;(customer)));<br/>         }<br/>       }<br/>       return returnList;<br/>    }
</pre>
<p>By having the <kbd>Customer.h</kbd> and <kbd>Customer.cpp</kbd> code in this <kbd>Step03</kbd> folder, it's now easier for us to fetch the list of the properties we have in the <kbd>Customer</kbd> class. For instance, if we want to retrieve a list of active customers, we can directly invoke the <kbd>GetActiveCustomerNames()</kbd> method, as we can see in the following <kbd>main.cpp</kbd> code:</p>
<pre>
    /* Main.cpp - Step03 */<br/>    #include &lt;iostream&gt;<br/>    #include "Customer.h"<br/><br/>    using namespace std;<br/><br/>    void RegisterCustomers()<br/>    {<br/>      int i = 0;<br/>      bool b = false;<br/><br/>      // Initialize name<br/>      vector&lt;string&gt; nameList =<br/>      {<br/>        "William",<br/>        "Aiden",<br/>        "Rowan",<br/>        "Jamie",<br/>        "Quinn",<br/>        "Haiden",<br/>        "Logan",<br/>        "Emerson",<br/>        "Sherlyn",<br/>        "Molly"<br/>      };<br/><br/>      // Clear the registeredCustomers vector array<br/>      Customer::registeredCustomers.clear();<br/><br/>      for (auto name : nameList)<br/>      {<br/>        // Create Customer object<br/>        // and fill all properties<br/>        Customer c;<br/>        c.id = i++;<br/>        c.name = name;<br/>        c.address = "somewhere";<br/>        c.phoneNumber = "0123";<br/>        c.email = name + "@xyz.com";<br/>        c.isActive = b;<br/><br/>        // Flip the b value<br/>        b = !b;<br/><br/>        // Send data to the registeredCustomers<br/>        Customer::registeredCustomers.push_back(c);<br/>      }<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[Step03]" &lt;&lt; endl;<br/>      cout &lt;&lt; "--------" &lt;&lt; endl;<br/><br/>      // Fill the Customer::registeredCustomers<br/>      // with the content<br/>      RegisterCustomers();<br/><br/>      // Instance Customer object<br/>      Customer customer;<br/><br/>      // Get the active customer names<br/>      cout &lt;&lt; "List of active customer names:" &lt;&lt; endl;<br/><strong>      vector&lt;string&gt; activeCustomerNames =</strong><br/><strong>        customer.GetActiveCustomerNames();</strong><br/>      for (auto &amp;name : activeCustomerNames)<br/>      {<br/>        cout &lt;&lt; name &lt;&lt; endl;<br/>      }<br/><br/>       return 0;<br/>    }
</pre>
<p>Now, let's run the program in the <kbd>Step03</kbd> folder. We should see the following screenshot on the console:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/5bc3935e-3059-4f30-b414-8e04a2a1086a.png"/></div>
<p>Again, we've got the exact same output comparing the previous step. We will make the <kbd>Customer</kbd> class become pure in the next section. So, keep going!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transforming the class to become pure</h1>
                </header>
            
            <article>
                
<p>As we discussed in <a href="a1baf007-8f40-4616-8718-9887f95120b0.xhtml" target="_blank">Chapter 2</a>, <span><em>Manipulating Functions in Functional Programming</em>,</span> we have to create a pure function in functional programming to avoid the side effect. If we come back to the previous <kbd>GetActiveCustomerByFunctionField()</kbd> method definition, it iterates a <kbd>registeredCustomers</kbd> static member that is a global variable. It will be a problem since the <kbd>GetActiveCustomerByFunctionField()</kbd> <span>method will feed a different output, although with the exact same passed as an argument.</span></p>
<p>To counter this problem, we have to abolish this global variable. We then have to modify the method definition as follows:</p>
<pre>
    template&lt;typename T&gt;<br/>    vector&lt;T&gt; Customer::GetActiveCustomerByFunctionField(<br/>      vector&lt;Customer&gt; <strong>customers</strong>,<br/>      const shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt;<br/>        &amp;classField)<br/>        {<br/>          vector&lt;T&gt; returnList;<br/>          for (auto &amp;customer : customers)<br/>          {<br/>            if (customer.isActive)<br/>            {<br/>              returnList.push_back(<br/>                classField-&gt;InvokeFunction(<br/>                make_shared&lt;Customer&gt;(<strong>customer</strong>)));<br/>            }<br/>          }<br/>          return returnList;<br/>        }
</pre>
<p>Since we don't have the <kbd>registeredCustomers</kbd> <span>properties anymore, we also have to pass a registered customer list to the <kbd>GetActiveCustomerByFunctionField()</kbd> method. The method will then iterate the customer list we pass, to find the active customer. Moreover, because we have modified the method signature, we also have to modify the method declaration in the <kbd>Customer.h</kbd> file as follows:</span></p>
<pre>
    template&lt;typename T&gt;<br/>    static std::vector&lt;T&gt; GetActiveCustomerByFunctionField(<br/>      std::vector&lt;Customer&gt; customers,<br/>      const std::shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt;<br/>        &amp;classField);
</pre>
<p>We discussed that the <kbd>GetActiveCustomerByFunctionField()</kbd> <span>method is called by the other methods in the <kbd>Customer</kbd> class. As a result, we also have to modify the method implementation, as we can see in the following code snippet:</span></p>
<pre>
    vector&lt;string&gt; Customer::GetActiveCustomerNames(<br/>      <strong>vector&lt;Customer&gt; customers</strong>)<br/>      {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        <strong>customers</strong>,<br/>        make_shared&lt;CustomerName&gt;());<br/>      }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerAddresses(<br/>      <strong>vector&lt;Customer&gt; customer</strong>)<br/>      {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        <strong>customer</strong>,<br/>        make_shared&lt;CustomerAddress&gt;());<br/>      }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerPhoneNumbers(<br/>      <strong>vector&lt;Customer&gt; customer</strong>)<br/>      {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        <strong>customer</strong>,<br/>        make_shared&lt;CustomerPhoneNumber&gt;());<br/>      }<br/> <br/>   vector&lt;string&gt; Customer::GetActiveCustomerEmails(<br/>     <strong>vector&lt;Customer&gt; customer</strong>)<br/>     {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        <strong>customer</strong>,<br/>        make_shared&lt;CustomerEmail&gt;());<br/>     }
</pre>
<p>We also need to modify the method declarations in the <kbd>Customer.h</kbd> file, as shown in the following code snippet:</p>
<pre>
    static std::vector&lt;std::string&gt; GetActiveCustomerNames(<br/>      <strong>std::vector&lt;Customer&gt; customer</strong>);<br/>    static std::vector&lt;std::string&gt; GetActiveCustomerAddresses(<br/>      <strong>std::vector&lt;Customer&gt; customer</strong>);<br/>    static std::vector&lt;std::string&gt; GetActiveCustomerPhoneNumbers(<br/>      <strong>std::vector&lt;Customer&gt; customer</strong>);<br/>    static std::vector&lt;std::string&gt; GetActiveCustomerEmails(<br/>      <strong>std::vector&lt;Customer&gt; customer</strong>);
</pre>
<p>Now, the <kbd>Customer.h</kbd> file will contain the following complete code block:</p>
<pre>
    /* Customer.h - Step04 */<br/>    #ifndef __CUSTOMER_H__<br/>    #define __CUSTOMER_H__<br/><br/>    #include &lt;string&gt;<br/>    #include &lt;vector&gt;<br/>    #include &lt;memory&gt;<br/><br/>    class Customer<br/>    {<br/>      private:<br/>        template&lt;typename T, typename U&gt;<br/>        class BaseClass<br/>        {<br/>          public:<br/>            virtual U InvokeFunction(<br/>            const std::shared_ptr&lt;T&gt;&amp;) = 0;<br/>        };<br/><br/>        class CustomerName :<br/>          public BaseClass&lt;Customer, std::string&gt;<br/>          {<br/>            public:<br/>              virtual std::string InvokeFunction(<br/>                const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>                {<br/>                  return customer-&gt;name;<br/>                }<br/>          };<br/><br/>       class CustomerAddress :<br/>         public BaseClass&lt;Customer, std::string&gt;<br/>         {<br/>           public:<br/>             virtual std::string InvokeFunction(<br/>               const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>              {<br/>            return customer-&gt;address;<br/>          }<br/>    };<br/><br/>      class CustomerPhoneNumber :<br/>        public BaseClass&lt;Customer, std::string&gt;<br/>        {<br/>          public:<br/>            virtual std::string InvokeFunction(<br/>              const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>              {<br/>                return customer-&gt;phoneNumber;<br/>              }<br/>       };<br/><br/>     class CustomerEmail :<br/>        public BaseClass&lt;Customer, std::string&gt;<br/>        {<br/>          public:<br/>            virtual std::string InvokeFunction(<br/>            const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>            {<br/>              return customer-&gt;email;<br/>            }<br/>        };<br/><br/>      public:<br/>        int id = 0;<br/>        std::string name;<br/>        std::string address;<br/>        std::string phoneNumber;<br/>        std::string email;<br/>        bool isActive = true;<br/><br/>        static std::vector&lt;std::string&gt; GetActiveCustomerNames(<br/>          std::vector&lt;Customer&gt; customer);<br/>       static std::vector&lt;std::string&gt; GetActiveCustomerAddresses(<br/>          std::vector&lt;Customer&gt; customer);<br/>       static std::vector&lt;std::string&gt; GetActiveCustomerPhoneNumbers(<br/>          std::vector&lt;Customer&gt; customer);<br/>       static std::vector&lt;std::string&gt; GetActiveCustomerEmails(<br/>          std::vector&lt;Customer&gt; customer);<br/><br/>       template&lt;typename T&gt;<br/>       static std::vector&lt;T&gt; GetActiveCustomerByFunctionField(<br/>        std::vector&lt;Customer&gt; customers,<br/>        const std::shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt;<br/>          &amp;classField);<br/>    };<br/>    #endif // __CUSTOMER_H__
</pre>
<p>And, the <kbd>Customer.cpp</kbd> file will be as follows:</p>
<pre>
    /* Customer.cpp - Step04 */<br/>    #include "Customer.h"<br/><br/>    using namespace std;<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerNames(<br/>      vector&lt;Customer&gt; customers)<br/>      {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        customers,<br/>        make_shared&lt;CustomerName&gt;());<br/>      }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerAddresses(<br/>      vector&lt;Customer&gt; customer)<br/>      {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>          customer,<br/>        make_shared&lt;CustomerAddress&gt;());<br/>       }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerPhoneNumbers(<br/>      vector&lt;Customer&gt; customer)<br/>      {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>         customer,<br/>        make_shared&lt;CustomerPhoneNumber&gt;());<br/>      }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerEmails(<br/>      vector&lt;Customer&gt; customer)<br/>      {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        customer,<br/>        make_shared&lt;CustomerEmail&gt;());<br/>       }<br/><br/>    template&lt;typename T&gt;<br/>    vector&lt;T&gt; Customer::GetActiveCustomerByFunctionField(<br/>      vector&lt;Customer&gt; customers,<br/>      const shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt;<br/>        &amp;classField)<br/>        {<br/>          vector&lt;T&gt; returnList;<br/>          for (auto &amp;customer : customers)<br/>          {<br/>            if (customer.isActive)<br/>            {<br/>              returnList.push_back(<br/>                classField-&gt;InvokeFunction(<br/>                make_shared&lt;Customer&gt;(customer)));<br/>             }<br/>           }<br/>           return returnList;<br/>         }
</pre>
<p>Since the <kbd>Customer</kbd> class has been changed and has no <kbd>registeredCustomer</kbd> variable anymore, we also need to modify the <kbd>RegisterCustomers()</kbd> method in the <kbd>main.cpp</kbd> file. The previous version of the method returns nothing. Now, we will make the code return the list of customers. We also need to modify the <kbd>main()</kbd> method since we have to consume the new <kbd>RegisterCustomers()</kbd> <span>method</span> in the <kbd>Main.cpp</kbd> file. The file will contain the following block of code:</p>
<pre>
    /* Main.cpp - Step04 */<br/>    #include &lt;iostream&gt;<br/>    #include "Customer.h"<br/><br/>    using namespace std;<br/><br/><strong>    vector&lt;Customer&gt;</strong> RegisterCustomers()<br/>    {<br/>      int i = 0;<br/>      bool b = false;<br/><br/>      <strong>vector&lt;Customer&gt; returnValue;</strong><br/><br/>      // Initialize name<br/>      vector&lt;string&gt; nameList =<br/>      {<br/>        "William",<br/>        "Aiden",<br/>        "Rowan",<br/>        "Jamie",<br/>        "Quinn",<br/>        "Haiden",<br/>        "Logan",<br/>        "Emerson",<br/>        "Sherlyn",<br/>        "Molly"<br/>       };<br/><br/>      for (auto name : nameList)<br/>      {<br/>        // Create Customer object<br/>        // and fill all properties<br/>        Customer c;<br/>        c.id = i++;<br/>        c.name = name;<br/>        c.address = "somewhere";<br/>        c.phoneNumber = "0123";<br/>        c.email = name + "@xyz.com";<br/>        c.isActive = b;<br/>        // Flip the b value<br/>        b = !b;<br/>        // Send data to the registeredCustomers<br/>        returnValue.push_back(c);<br/>      }<br/><br/>      <strong>return returnValue;</strong><br/>    }<br/> <br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[Step04]" &lt;&lt; endl;<br/>      cout &lt;&lt; "--------" &lt;&lt; endl;<br/><br/>      // Instance Customer object<br/>      Customer customer;<br/><br/>      // Get the active customer names<br/>      cout &lt;&lt; "List of active customer names:" &lt;&lt; endl;<br/>      vector&lt;string&gt; activeCustomerNames =<br/>        customer.GetActiveCustomerNames(<br/>            RegisterCustomers());<br/>      for (auto name : activeCustomerNames)<br/>      {<br/>        cout &lt;&lt; name &lt;&lt; endl;<br/>       }<br/><br/>       return 0;<br/>    }
</pre>
<p>As we can see in the preceding <kbd>main()</kbd> method, we invoke the <kbd>GetActiveCustomerNames()</kbd> method and pass the result of the <kbd>RegisterCustomers()</kbd> method. Now, let's try the code by running the program in the <kbd>Step06</kbd> folder. We should get the following output on the console when we run the program:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/83af4fa6-23aa-4db0-a7a2-860c55bfc133.png"/></div>
<p>Again, we've got the exact same output we saw in the previous step, but with a new approach in functional programming. Next, we will refactor the code to use a Lambda expression to ease the filtering task.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filtering the condition and implementing a Lambda expression</h1>
                </header>
            
            <article>
                
<p>Let's focus on the <kbd>GetActiveCustomerByFunctionField()</kbd> method. There, we can find an <kbd>if</kbd> structure to filter the active customer. As we discussed in the previous chapters, we can use the <kbd>copy_if()</kbd> method to filter the condition. The following code snippet implements the <kbd>copy_if()</kbd> <span>method to filter the active customer:</span></p>
<pre>
    template&lt;typename T&gt;<br/>    vector&lt;T&gt; Customer::GetActiveCustomerByFunctionField(<br/>      vector&lt;Customer&gt; customers,<br/>      const shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt;<br/>        &amp;classField)<br/>        {<br/><strong>          vector&lt;Customer&gt; activeCustomers;</strong><br/>          vector&lt;T&gt; returnList;<br/><br/><strong>          copy_if(</strong><br/><strong>            customers.begin(),</strong><br/><strong>            customers.end(),</strong><br/><strong>            back_inserter(activeCustomers),</strong><br/><strong>            [](Customer customer)</strong><br/><strong>            {</strong><br/><strong>             if (customer.isActive)</strong><br/><strong>                return true;</strong><br/><strong>             else</strong><br/><strong>                return false;</strong><br/><strong>            });</strong><br/><br/>            for (auto &amp;customer : customers)<br/>             {<br/>                if (customer.isActive)<br/>                {<br/>                  returnList.push_back(<br/>                  classField-&gt;InvokeFunction(<br/>                  make_shared&lt;Customer&gt;(customer)));<br/>                 }<br/>             }<br/> <br/>          return returnList;<br/>      }
</pre>
<p>As we can see in the preceding code snippet, we create an anonymous method that returns true if the customer instance we pass is active. Also, we can refactor the preceding <kbd>GetActiveCustomerByFunctionField()</kbd> <span>method so it will use an anonymous method again, as we can see in the following code snippet:</span></p>
<pre>
    template&lt;typename T&gt;<br/>    vector&lt;T&gt; Customer::GetActiveCustomerByFunctionField(<br/>      vector&lt;Customer&gt; customers,<br/>      const shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt; <br/>        &amp;classField)<br/>        {<br/>          <strong>vector&lt;Customer&gt; activeCustomers;</strong><br/>          vector&lt;T&gt; returnList;<br/><br/>          copy_if(<br/>            customers.begin(),<br/>            customers.end(),<br/>            back_inserter(activeCustomers),<br/>            [](Customer customer)<br/>            {<br/>              if (customer.isActive)<br/>                return true;<br/>              else<br/>                return false;<br/>             });<br/><br/><strong>            for_each(</strong><br/><strong>              activeCustomers.begin(),</strong><br/><strong>              activeCustomers.end(),</strong><br/><strong>              [&amp;returnList, &amp;classField](Customer customer)</strong><br/><strong>              {</strong><br/><strong>                returnList.push_back(</strong><br/><strong>                classField-&gt;InvokeFunction(</strong><br/><strong>                  make_shared&lt;Customer&gt;(customer))</strong><br/><strong>                  );</strong><br/><strong>              });</strong><br/><br/>         return returnList;<br/>    }
</pre>
<p>In addition to implementing the filtering technique using the Lambda expression, we will also add a method to the <kbd>Customer</kbd> class named <kbd>CountActiveCustomers()</kbd>. The method will count the active customers. The definition of this method should be as follows:</p>
<pre>
    int Customer::CountActiveCustomers(<br/>      vector&lt;Customer&gt; customer)<br/>      {<br/>        int add = 0;<br/> <br/>        for (auto cust : customer)<br/>        {<br/>          // Adding 1 if the customer is active<br/>          if(cust.isActive)<br/>            ++add;<br/>        }<br/><br/>        return add;<br/>    }
</pre>
<p>Now, we will have the <kbd>Customer.cpp</kbd> code in this <kbd>Step05</kbd> code block as follows:</p>
<pre class="mce-root">
    /* Customer.cpp - Step05 */<br/>    #include &lt;algorithm&gt;<br/>    #include "Customer.h"<br/><br/>    using namespace std;<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerNames(<br/>      vector&lt;Customer&gt; customers)<br/>      {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        customers,<br/>        make_shared&lt;CustomerName&gt;());<br/>      }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerAddresses(<br/>      vector&lt;Customer&gt; customer)<br/>      {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>          customer,<br/>        make_shared&lt;CustomerAddress&gt;());<br/>      }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerPhoneNumbers(<br/>      vector&lt;Customer&gt; customer)<br/>      {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>          customer,<br/>        make_shared&lt;CustomerPhoneNumber&gt;());<br/>      }<br/><br/>    vector&lt;string&gt; Customer::GetActiveCustomerEmails(<br/>      vector&lt;Customer&gt; customer)<br/>      {<br/>        return Customer::GetActiveCustomerByFunctionField&lt;string&gt;(<br/>        customer,<br/>        make_shared&lt;CustomerEmail&gt;());<br/>      }<br/><br/><strong>    int Customer::CountActiveCustomers(</strong><br/><strong>      vector&lt;Customer&gt; customer)</strong><br/><strong>      {</strong><br/><strong>        int add = 0;</strong><br/><br/><strong>        for (auto cust : customer)</strong><br/><strong>        {</strong><br/><strong>          // Adding 1 if the customer is active</strong><br/><strong>          if(cust.isActive)</strong><br/><strong>            ++add;</strong><br/><strong>         }</strong><br/><br/><strong>      return add;</strong><br/><strong>    }</strong><br/><br/>    template&lt;typename T&gt;<br/>    vector&lt;T&gt; Customer::GetActiveCustomerByFunctionField(<br/><strong>      vector&lt;Customer&gt; customers,</strong><br/>      const shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt;<br/>        &amp;classField)<br/>        {<br/><strong>          vector&lt;Customer&gt; activeCustomers;</strong><br/>          vector&lt;T&gt; returnList;<br/><br/><strong>          copy_if(</strong><br/><strong>            customers.begin(),</strong><br/><strong>            customers.end(),</strong><br/><strong>            back_inserter(activeCustomers),</strong><br/><strong>           [](Customer customer)</strong><br/><strong>           {</strong><br/><strong>            if (customer.isActive)</strong><br/><strong>                return true;</strong><br/><strong>            else</strong><br/><strong>                return false;</strong><br/><strong>          });</strong><br/><br/><strong>          for_each(</strong><br/><strong>            activeCustomers.begin(),</strong><br/><strong>            activeCustomers.end(),</strong><br/><strong>            [&amp;returnList, &amp;classField](Customer customer)</strong><br/><strong>            {</strong><br/><strong>              returnList.push_back(</strong><br/><strong>                classField-&gt;InvokeFunction(</strong><br/><strong>                  make_shared&lt;Customer&gt;(customer))</strong><br/><strong>            );</strong><br/><strong>        });</strong><br/><br/><strong>        return returnList;</strong><br/>     }
</pre>
<p>Don't forget to modify the <kbd>Customer.h</kbd> file as well, since we have added a new method to the class. The file should contain the following piece of code:</p>
<pre class="mce-root">
    /* Customer.h - Step05 */<br/>    #ifndef __CUSTOMER_H__<br/>    #define __CUSTOMER_H__<br/><br/>    #include &lt;string&gt;<br/>    #include &lt;vector&gt;<br/>    #include &lt;memory&gt;<br/> <br/>    class Customer<br/>    {<br/>      private:<br/>        template&lt;typename T, typename U&gt;<br/>        class BaseClass<br/>        {<br/>          public:<br/>            virtual U InvokeFunction(<br/>            const std::shared_ptr&lt;T&gt;&amp;) = 0;<br/>        };<br/><br/>        class CustomerName :<br/>          public BaseClass&lt;Customer, std::string&gt;<br/>          {<br/>            public:<br/>              virtual std::string InvokeFunction(<br/>                const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>                {<br/>                  return customer-&gt;name;<br/>                 }<br/>          };<br/><br/>        class CustomerAddress :<br/>          public BaseClass&lt;Customer, std::string&gt;<br/>          {<br/>             public:<br/>               virtual std::string InvokeFunction(<br/>                 const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>                 {<br/>                   return customer-&gt;address;<br/>                 }<br/>          };<br/><br/>        class CustomerPhoneNumber :<br/>          public BaseClass&lt;Customer, std::string&gt;<br/>          {<br/>            public:<br/>              virtual std::string InvokeFunction(<br/>                const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>                {<br/>                 return customer-&gt;phoneNumber;<br/>                }<br/>           };<br/><br/>    class CustomerEmail :<br/>        public BaseClass&lt;Customer, std::string&gt;<br/>    {<br/>    public:<br/>        virtual std::string InvokeFunction(<br/>            const std::shared_ptr&lt;Customer&gt; &amp;customer)<br/>        {<br/>            return customer-&gt;email;<br/>        }<br/>    };<br/><br/>    public:<br/>      int id = 0;<br/>      std::string name;<br/>      std::string address;<br/>      std::string phoneNumber;<br/>      std::string email;<br/>      bool isActive = true;<br/><br/>      static std::vector&lt;std::string&gt; GetActiveCustomerNames(<br/>        std::vector&lt;Customer&gt; customer);<br/>      static std::vector&lt;std::string&gt; GetActiveCustomerAddresses(<br/>        std::vector&lt;Customer&gt; customer);<br/>      static std::vector&lt;std::string&gt; GetActiveCustomerPhoneNumbers(<br/>        std::vector&lt;Customer&gt; customer);<br/>      static std::vector&lt;std::string&gt; GetActiveCustomerEmails(<br/>        std::vector&lt;Customer&gt; customer);<br/><br/><strong>      static int CountActiveCustomers(</strong><br/><strong>        std::vector&lt;Customer&gt; customer);</strong><br/><br/>      template&lt;typename T&gt;<br/>      static std::vector&lt;T&gt; GetActiveCustomerByFunctionField(<br/>        std::vector&lt;Customer&gt; customers,<br/>        const std::shared_ptr&lt;BaseClass&lt;Customer, T&gt;&gt;<br/>            &amp;classField);<br/>    };<br/>    #endif // __CUSTOMER_H__
</pre>
<p>Now, we will invoke the <kbd>CountActiveCustomers()</kbd> method in our <kbd>main()</kbd> function. We will see how we do that by examining the following <kbd>Main.cpp</kbd> code block:</p>
<pre>
    /* Main.cpp - Step05 */<br/>    #include &lt;iostream&gt;<br/>    #include &lt;chrono&gt;<br/>    #include "Customer.h"<br/><br/>    using namespace std;<br/><br/>    vector&lt;Customer&gt; RegisterCustomers()<br/>    {<br/>      int i = 0;<br/>      bool b = false;<br/><br/>      vector&lt;Customer&gt; returnValue;<br/><br/>      // Initialize name<br/>      vector&lt;string&gt; nameList =<br/>      {<br/>        "William",<br/>        "Aiden",<br/>        "Rowan",<br/>        "Jamie",<br/>        "Quinn",<br/>        "Haiden",<br/>        "Logan",<br/>        "Emerson",<br/>        "Sherlyn",<br/>        "Molly"<br/>      };<br/><br/>      for (auto name : nameList)<br/>      {<br/>        // Create Customer object<br/>        // and fill all properties<br/>        Customer c;<br/>        c.id = i++;<br/>        c.name = name;<br/>        c.address = "somewhere";<br/>        c.phoneNumber = "0123";<br/>        c.email = name + "@xyz.com";<br/>        c.isActive = b;<br/><br/>        // Flip the b value<br/>        b = !b;<br/><br/>        // Send data to the registeredCustomers<br/>        returnValue.push_back(c);<br/>      }<br/><br/>     return returnValue;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[Step05]" &lt;&lt; endl;<br/>      cout &lt;&lt; "--------" &lt;&lt; endl;<br/><br/><strong>      // Recording start time for the program</strong><br/><strong>      auto start = chrono::high_resolution_clock::now();</strong><br/><br/>      // Instance Customer object<br/>      Customer customer;<br/><br/><strong>      // Counting active customers</strong><br/><strong>      cout &lt;&lt; "Total active customers: " &lt;&lt; endl;</strong><br/><strong>      cout &lt;&lt; customer.CountActiveCustomers(</strong><br/><strong>        RegisterCustomers());</strong><br/><strong>      cout &lt;&lt; endl &lt;&lt; "--------" &lt;&lt; endl;</strong><br/><br/>      // Get the active customer names<br/>      cout &lt;&lt; "List of active customer names:" &lt;&lt; endl;<br/>      vector&lt;string&gt; activeCustomerNames =<br/>        customer.GetActiveCustomerNames(<br/>            RegisterCustomers());<br/>      for (auto name : activeCustomerNames)<br/>      {<br/>        cout &lt;&lt; name &lt;&lt; endl;<br/>      }<br/><br/><strong>      // Recording end time for the program</strong><br/><strong>      auto finish = chrono::high_resolution_clock::now();</strong><br/><br/><strong>      // Calculating the elapsed time for the program</strong><br/><strong>      chrono::duration&lt;double, milli&gt; elapsed = finish - start;</strong><br/><br/><strong>      // Displaying elapsed time for the program</strong><br/><strong>      cout &lt;&lt; "--------" &lt;&lt; endl;</strong><br/><strong>      cout &lt;&lt; "Total consuming time = ";</strong><br/><strong>      cout &lt;&lt; elapsed.count() &lt;&lt; " milliseconds" &lt;&lt; endl;</strong><br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we invoke the <kbd>CountActiveCustomers()</kbd> method and pass the output of the <kbd>RegisterCustomers()</kbd> method as the argument. We also add a simple stopwatch to calculate how long the code needs to run the program. The output of the preceding code should be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="200" src="assets/b6c381e2-85f3-4717-9990-031a1a9fb7f3.png" width="500"/></div>
<p>As we can see, we need <kbd>0.997</kbd> milliseconds to run the code in this step. However, we can optimize the preceding code to run faster by implementing recursion and memoization, which we will discuss in the next section.</p>
<div class="packt_infobox">Indeed, we can find out the total of the active customers by running the method of <kbd>activeCustomerNames.size()</kbd> to get the number of elements in the vector after we run the following code line:<br/>
<br/>
<kbd>vector&lt;string&gt; activeCustomerNames =<br/>
customer.GetActiveCustomerNames(RegisterCustomers())</kbd><br/>
<br/>
However, the preceding code example wants to show us how the <kbd>for</kbd> loop can be transformed into recursion, to optimize the speed of execution. We will discuss this in the upcoming<br/>
section.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing recursion and memoization techniques to the Customer class</h1>
                </header>
            
            <article>
                
<p>If we look at the <kbd>CountActiveCustomers()</kbd> method definition in <kbd>Step05</kbd>, we use the <kbd>for</kbd> loop to count the active customers. However, we can rewrite the method to use the recursion technique. Let's take a look at the following code, which is the new definition for the <kbd>CountActiveCustomers()</kbd> method:</p>
<pre>
    int Customer::CountActiveCustomers(<br/>      vector&lt;Customer&gt; customer)<br/>      {<br/>        if(customer.empty())<br/>          return 0;<br/>        else<br/>        {<br/>          // Adding 1 if the customer is active<br/>          int add = customer.front().isActive ? 1 : 0;<br/><br/>          // Removing the first element of vector<br/>          // It's similar with removing head<br/>          // and pass the tail<br/>          customer.erase(customer.begin());<br/><br/>          // Running the recursion<br/>          return add + CountActiveCustomers(<br/>            customer);<br/>         }<br/>       }
</pre>
<p>As we can see in the preceding code snippet, we use tail recursion for the <kbd>CountActiveCustomers()</kbd> method. We just need to increment the <kbd>add</kbd> variable every time we find an active customer in the <kbd>customer</kbd> vector. The code then removes the first element of the <kbd>customer</kbd> vector and passes it to the <kbd>CountActiveCustomers()</kbd> method again. We recurse this process until the element of the <kbd>customer</kbd> vector is empty.</p>
<p>Also, we use the <kbd>Memoization</kbd> class we discussed in <a href="aaf78dc0-36c9-41f9-bf10-efcbd979c096.xhtml" target="_blank">Chapter 5</a>, <em>Procrastinating the Execution Process Using Lazy Evaluation</em>, to optimize our code. We will modify the <kbd>main()</kbd> function in the <kbd>Main.cpp</kbd> file so the <kbd>main()</kbd> function contains the following code snippet:</p>
<pre>
    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[Step06]" &lt;&lt; endl;<br/>      cout &lt;&lt; "--------" &lt;&lt; endl;<br/><br/>      // Recording start time for the program<br/>      auto start = chrono::high_resolution_clock::now();<br/><br/>      // Instance Customer object<br/>      Customer customer;<br/><br/>      // Counting active customers<br/>      cout &lt;&lt; "Total active customers: " &lt;&lt; endl;<br/>      cout &lt;&lt; customer.CountActiveCustomers(<br/>        RegisterCustomers());<br/>      cout &lt;&lt; endl &lt;&lt; "--------" &lt;&lt; endl;<br/><br/><strong>      // Initializing memoization instance</strong><br/><strong>      Memoization&lt;vector&lt;string&gt;&gt; custMemo(</strong><br/><strong>        [customer]()</strong><br/><strong>        {</strong><br/><strong>            return customer.GetActiveCustomerNames(</strong><br/><strong>                RegisterCustomers());</strong><br/><strong>        });</strong><br/><br/>      // Get the active customer names<br/>      cout &lt;&lt; "List of active customer names:" &lt;&lt; endl;<br/><strong>      vector&lt;string&gt; activeCustomerNames =</strong><br/><strong>        custMemo.Fetch();</strong><br/>      for (auto name : activeCustomerNames)<br/>      {<br/>        cout &lt;&lt; name &lt;&lt; endl;<br/>      }<br/><br/>      // Recording end time for the program<br/>      auto finish = chrono::high_resolution_clock::now();<br/><br/>      // Calculating the elapsed time for the program<br/>      chrono::duration&lt;double, milli&gt; elapsed = finish - start;<br/><br/>      // Displaying elapsed time for the program<br/>      cout &lt;&lt; "--------" &lt;&lt; endl;<br/>      cout &lt;&lt; "Total consuming time = ";<br/>      cout &lt;&lt; elapsed.count() &lt;&lt; " milliseconds" &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code snippet, we now run the <kbd>GetActiveCustomerNames()</kbd> method from the <kbd>Memoization</kbd> instance by calling the <kbd>Fetch()</kbd> method. If we run the <kbd>Step06</kbd> code, we should see the following output on the console:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="194" src="assets/75cf002b-d6a6-4118-a72b-89ccb548a3d4.png" width="481"/></div>
<p>The code now only needs <kbd>0.502</kbd> milliseconds to run. Compared to the <kbd>Step05</kbd> code, the speed of code execution is almost twice as fast. It proves that, by using the functional approach, we can gain not only a better code structure, but also speed optimization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging the code</h1>
                </header>
            
            <article>
                
<p>Sometimes, in the coding process, when we run the code, we've got an unexpected result from one or more variables. It might happen in the middle of the execution. To avoid getting stuck in this situation, we can <span class="fontstyle0">analyze our program by running it step-by-step.</span> We can use the debugger tool that is included in the GCC compiler--<strong>GDB</strong> (<strong>The GNU Project Debugger</strong>). This tool <span>allows us to figure out what happens inside the target program while it executes, or what it was doing at the moment it crashed. In this section, we will apply the GDB to ease our programming task and find a solution for the problem and deal with it.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting the debugging tool</h1>
                </header>
            
            <article>
                
<p>Now, let's prepare the executable file we will analyze. We will use the code from the <kbd>Step01</kbd> folder since it's a simple code, and we can learn easily from it. We have to recompile the code using the <kbd>-g</kbd> option and name the executable as <kbd>customer.exe</kbd>. The following are the three commands to compile the code so it can be debugged:</p>
<pre class="mce-root">
<strong>g++ -Wall -g -c Main.cpp -o Main.o</strong><br/><strong>g++ -Wall -g -c Customer.cpp -o Customer.o</strong><br/><strong>g++ Main.o Customer.o -o Customer.exe</strong>
</pre>
<div class="packt_infobox">GDB can only analyze the executable file that contains th<span>e debugging information and symbols that are important in the debugging process. We can insert <span class="fontstyle0">the</span> <kbd><span class="fontstyle2">-g</span></kbd> <span class="fontstyle0">option when we compile the source so the debugging information and symbol will be added to the executable file.</span></span></div>
<p>Typing <kbd>gdb <span>customer</span></kbd> on the console will open the debugger tool and load the debugger information and symbol from the <kbd>customer.exe</kbd> file. We will then see the following screenshot on the console:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/075cb3bb-6396-46a8-aa8d-6cb3bd8b24b6.png"/></div>
<p>As we can see in the preceding screenshot, it has successfully read the symbol from the <kbd>customer.exe</kbd> file. Then, type <kbd>start</kbd> in the GDB console to start the analyzing process. The debugger will create a temporary breakpoint in the first line of the <kbd>main()</kbd> method. We will see the following screenshot on the console after starting the GDB:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/c1fb49c2-5b72-40fa-9555-4cb2a43d7635.png"/></div>
<p>Now, the program is in the debugging process. We can continue the process to analyze what is going on with the program. In the next section, we can choose between continuing step by step or running the program until the next breakpoint is found.</p>
<div class="packt_infobox"><span class="fontstyle0">To start the debugging process, we can either call the</span> <span class="fontstyle2"><kbd>run</kbd></span> <span class="fontstyle0">or</span> <span class="fontstyle2"><kbd>start</kbd></span> <span class="fontstyle0">command. The former will start our program under GDB, while the latter will behave similarly but will execute the code line by line. The difference is, if we don't have the breakpoint yet, the program will run as usual, just like it does when we call the</span> <span class="fontstyle2"><kbd>run</kbd></span> <span class="fontstyle0">command, while the debugger will automatically set the breakpoint in the main block of code and the program will stop when it reaches that breakpoint, if we start with the</span> <span class="fontstyle2"><kbd>start</kbd></span> <span class="fontstyle0">command.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuing and stepping the debugging process</h1>
                </header>
            
            <article>
                
<p>There are three commands to continue the step in the preceding section. They are as follows:</p>
<ul>
<li><span class="fontstyle0"><kbd>continue</kbd>: This</span> <span class="fontstyle1"><span class="fontstyle1">resumes the execution of the program until our program completes normally. If it finds a breakpoint, the execution will stop at the line where the breakpoint is set.</span></span></li>
<li><span class="fontstyle0"><kbd>step</kbd>: This</span> <span class="fontstyle1">executes just one more step of our program. The</span> <span class="fontstyle3">step</span> <span class="fontstyle1">might mean either one line of source code or one machine instruction. If it finds the invocation of a function, it will come into the function and run one more step inside the function.</span></li>
<li><span class="fontstyle0"><kbd>next</kbd>: This</span> <span class="fontstyle1">continues to the next line in the current stack frame. In other words, if the</span> <span class="fontstyle0">next</span> <span class="fontstyle1">command finds the invocation of a function, it will not enter the function.</span></li>
</ul>
<p>Since we haven't set the breakpoint yet, let's type the <kbd>next</kbd> command so the debugging pointer goes to the next line of the code. We will run the <kbd>next</kbd> command multiple times until the end of the code is reached (or until we can see that the process is exited normally). We should see the following screenshot when we apply the <kbd>next</kbd> command multiple times:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/99f37d0c-0b09-4a03-8fe5-dca276cb92e6.png"/></div>
<p>As we can see in the preceding screenshot, we can analyze our program by running it step by step. Next, we will set the breakpoint if we have a suspect object to be analyzed.</p>
<div class="packt_tip">We just need to press the <kbd>Enter</kbd> key to run the previous command in GDB. Pressing the <em>Q</em> key will make the debugging console exit to the window console.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting and deleting the breakpoint</h1>
                </header>
            
            <article>
                
<p>Let's exit from the debugging console by typing the <em>Q</em> key. We need to restart the debugging, so we need to type <kbd>gdb <span>customer</span></kbd> <span>again on the window console. After that, instead of typing the <kbd>start</kbd> command, let's set the breakpoint before we continue the process. Let's type <kbd>break 68</kbd> and <kbd>break Customer.cpp:15</kbd> respectively in the GDB console. The output is shown as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/e49ce2b0-4515-4fe4-bb5a-9b6ad9bd43dc.png"/></div>
<p>Now, we have two breakpoint in separate files--<kbd>Main.cpp</kbd> and <kbd>Customer.cpp</kbd>. We can now start the debugger by typing <kbd>run</kbd> in GDB console, as we can see in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/a98825ab-5bc8-4cdb-8ee1-23f8afd0f400.png"/></div>
<p>Since the debugger hit the <kbd>GetActiveCustomerNames()</kbd> method first, it stops in the line where we put the breakpoint in that method, which is line <kbd>15</kbd> in the <kbd>Customer.cpp</kbd> file. Just type the <kbd>continue</kbd> command and press <em>Enter</em> multiple times until it hits the breakpoint in the <kbd>Main.cpp</kbd> file, line <kbd>69</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Printing the object value</h1>
                </header>
            
            <article>
                
<p>Let's rerun the debugger by setting the breakpoint on line <kbd>68</kbd> in the <kbd>Main.cpp</kbd> file, then start the debugger until it hits the breakpoint. After the breakpoint is hit, type <kbd>print name</kbd> to see what the value of the name variable is. The following screenshot shows the steps of the process:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/7a03fa03-bbf0-4f84-bb7c-b253f53ac888.png"/></div>
<p>As we can see in the preceding screenshot, the value of the <kbd>name</kbd> variable is <kbd>Aiden</kbd>. We can continue the debugging by typing the <kbd>continue</kbd> command so the debugger hits the breakpoint again in the <kbd>for</kbd> loop, then typing <kbd>print name</kbd> to find out the next name value.</p>
<div class="packt_tip">There are so many commands in the GDB that, will be overloaded if they are written in this book. If you need to find more commands in the GDB, refer to the following link:<br/>
<br/>
<a href="https://www.gnu.org/software/gdb/documentation/">https://www.gnu.org/software/gdb/documentation/</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In the last chapter of this book, we developed the functional class successfully by refactoring it from the imperative class that we can use to create a more complex program with. We implemented what we learned in the previous chapters. We also discussed the debugging technique, which is a useful weapon when we face an unexpected result or get a crash in the middle of the program.</p>


            </article>

            
        </section>
    </body></html>