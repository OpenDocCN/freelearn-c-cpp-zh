- en: Sharing Hardware Peripherals across Tasks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在任务间共享硬件外设
- en: In the previous chapter, we went through several examples of creating drivers,
    but they were only used by a single task. Since we're creating a multi-tasking
    asynchronous system, a few additional considerations need to be made to ensure
    that the peripherals exposed by our drivers can safely be used by multiple tasks.
    Preparing a driver for use by multiple tasks requires a number of additional considerations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了创建驱动程序的好几个例子，但它们仅被单个任务使用。由于我们正在创建一个多任务异步系统，需要考虑一些额外的因素以确保我们的驱动程序暴露的外设可以安全地被多个任务使用。为多个任务准备驱动程序需要考虑许多额外的因素。
- en: Accordingly, this chapter first illustrates the pitfalls of a shared peripheral
    in a multi-tasking, real-time environment. After understanding the problem we're
    trying to solve, we'll investigate potential solutions for wrapping a driver in
    a way that provides an easy-to-use abstraction layer that is safe to use across
    multiple tasks. We'll be using the STM32 USB stack to implement a **Communication
    Device Class** (**CDC**) to provide an interactive **Virtual COM Port** (**VPC**).
    Unlike the previous chapter, which took an extremely low-level approach to driver
    development, this chapter focuses on writing threadsafe code on top of an existing
    driver stack.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章首先阐述了在多任务、实时环境中共享外设的陷阱。在理解我们要解决的问题之后，我们将研究如何将驱动程序封装起来，以便提供一个易于使用且在多个任务中安全使用的抽象层。我们将使用STM32
    USB堆栈来实现一个**通信设备类**（**CDC**），以提供交互式的**虚拟串行端口**（**VPC**）。与上一章不同，上一章采用了极端低级的驱动程序开发方法，本章则侧重于在现有的驱动程序堆栈之上编写线程安全的代码。
- en: 'In a nutshell, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将涵盖以下主题：
- en: Understanding shared peripherals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解共享外设
- en: Introducing the STM USB driver stack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍STM USB驱动程序堆栈
- en: Developing a StreamBuffer USB virtual COM port
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发StreamBuffer USB虚拟串行端口
- en: Using mutexes for access control
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥锁进行访问控制
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the hands-on experiments in this chapter, you''ll require the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的动手实验，你需要以下工具：
- en: Nucleo F767 Dev Board
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nucleo F767开发板
- en: Micro-USB cable (x2)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro-USB线（x2）
- en: STM32CubeIDE and source code (instructions in [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml),
    *Selecting an IDE*, under the section entitled *Setting up our IDE*)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32CubeIDE和源代码（[第5章](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)，*选择IDE*，在*设置我们的IDE*部分中提供说明）
- en: SEGGER JLink, Ozone, and SystemView (instructions in [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),
    *Debugging Tools for Real-Time Systems*)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEGGER JLink、Ozone和SystemView（[第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*）
- en: 'STM USB virtual COM port drivers:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM USB虚拟串行端口驱动程序：
- en: 'Windows: The driver should install automatically from Windows Update ([https://www.st.com/en/development-tools/stsw-stm32102.html](https://www.st.com/en/development-tools/stsw-stm32102.html)).'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows：驱动程序应自动从Windows更新中安装（[https://www.st.com/en/development-tools/stsw-stm32102.html](https://www.st.com/en/development-tools/stsw-stm32102.html)）。
- en: 'Linux/ macOS: These use built-in virtual COM port drivers.'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux/ macOS：这些系统使用内置的虚拟串行端口驱动程序。
- en: 'Serial Terminal Client:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行终端客户端：
- en: Tera Term (or similar) (Windows)
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tera Term（或类似）(Windows)
- en: minicom (or similar) (Linux /macOS)
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: minicom（或类似）(Linux / macOS)
- en: miniterm.py (cross-platform serial client also included with Python modules
    used in *[Chapter 13](e728e173-c9b2-4bb8-91c8-ed348ccf9518.xhtml), Creating Loose
    Coupling with Queues*)
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: miniterm.py（跨平台串行客户端，也包含在*[第13章](e728e173-c9b2-4bb8-91c8-ed348ccf9518.xhtml)，使用队列创建松散耦合*）中使用的Python模块
- en: All source code for this chapter is available from [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_11](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_11).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码均可在[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_11](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_11)找到。
- en: Understanding shared peripherals
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解共享外设
- en: A hardware peripheral is similar to any other shared resource. When there is
    a single resource with multiple tasks that need access to the resource, some sort
    of arbitration needs to be created to guarantee orderly access to the resource
    across tasks. In the previous chapter, we focused on different ways of developing
    low-level peripheral drivers. Some guidance as to driver selection was provided
    and it was suggested that the appropriate interface the driver provides should
    be based on how the driver was to be used in the system ([Chapter 10](dd741273-db9a-4e9a-a699-b4602e160b84.xhtml),
    *Drivers and ISR's,* under the section entitled *Choosing a driver model*).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件外围设备类似于任何其他共享资源。当有多个任务需要访问单个资源时，需要创建某种仲裁机制来保证任务间对资源的有序访问。在前一章中，我们关注了开发低级外围驱动程序的不同方法。提供了一些关于驱动程序选择的指导，并建议驱动程序提供的适当接口应根据驱动程序在系统中的使用方式来确定（[第10章](dd741273-db9a-4e9a-a699-b4602e160b84.xhtml)，*驱动程序和中断服务例程*，在*选择驱动程序模型*部分）。
- en: Shared resources were covered conceptually in [Chapter 3](a410ddd6-10eb-4e97-965e-e390f4dc2890.xhtml),* Task
    Signaling and Communication Mechanisms.*
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](a410ddd6-10eb-4e97-965e-e390f4dc2890.xhtml)中，*任务信号和通信机制*概念上介绍了共享资源。
- en: There are many different examples of sharing peripherals in real-world applications.
    Communication peripherals such as SPI, I2C, USARTs, and ethernet peripherals can
    all be used by multiple tasks simultaneously, provided the timing constraints
    of the application allow for it and the drivers are written in a way that provides
    safe concurrent access. Since all of the blocking RTOS calls can be time-bound,
    it is easy to detect when accessing a shared peripheral is causing timing issues.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用中，共享外围设备的例子有很多。通信外围设备如SPI、I2C、USART和以太网外围设备都可以由多个任务同时使用，前提是应用的定时约束允许这样做，并且驱动程序以提供安全并发访问的方式编写。由于所有阻塞的RTOS调用都可以设置时间限制，因此很容易检测到访问共享外围设备是否导致定时问题。
- en: It is important to remember that sharing a single peripheral across multiple
    tasks creates delays and uncertainty in timing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在多个任务之间共享单个外围设备会导致延迟和定时不确定性。
- en: In some cases where timing is critical, it is best to avoid sharing a peripheral
    and instead use dedicated hardware. This is part of the reason why there are multiple
    bus-based peripherals available, including SPI, USART's, and I2C. Even though
    the hardware for each of these communication buses is perfectly capable of addressing
    multiple devices, sometimes it is best to use a dedicated peripheral.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些对定时要求严格的场合，最好避免共享外围设备，而是使用专用硬件。这也是为什么有多个基于总线的外围设备可用，包括SPI、USART和I2C的原因之一。尽管这些通信总线的硬件完全能够处理多个设备，但有时最好使用专用外围设备。
- en: In other cases, a driver for a piece of hardware may be so specific that it
    is best to dedicate an entire peripheral to it for performance reasons. High bandwidth
    peripherals will typically fall into this category. An example of this would be
    a medium bandwidth ADC sampling thousands or tens of thousands of data points
    per second. The most efficient way of interacting with devices such as these is
    to use DMA as much as possible, transferring data from the communication bus (like
    SPI) directly into RAM.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，一个硬件设备的驱动程序可能非常特定，出于性能考虑，最好为它分配一个完整的外围设备。通常，高带宽的外围设备会属于这一类别。一个例子是中等带宽的ADC，每秒采样数千或数万个数据点。与这类设备交互的最高效方式是尽可能使用DMA，将数据从通信总线（如SPI）直接传输到RAM。
- en: Defining the peripheral driver
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义外围设备驱动程序
- en: This chapter provides fully fleshed-out examples of interacting with a driver
    in a real-world situation. A USB virtual COM port was chosen because it won't
    require any additional hardware, other than a second micro-USB cable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了在现实世界情况下与驱动程序交互的完整示例。选择USB虚拟COM端口是因为它不需要任何额外的硬件，除了另一条微USB线。
- en: 'Our goal is to make it easy to interact with the Nucleo board using USB CDC
    in a reasonably efficient way. Desirable features for interaction include the
    following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是使使用USB CDC与Nucleo板交互变得尽可能高效。交互的理想特性包括以下内容：
- en: The ability to easily write to a USB virtual COM port from multiple tasks.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够从多个任务中轻松写入USB虚拟COM端口。
- en: Efficient event-driven execution (avoiding wasteful polling as much as possible).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的事件驱动执行（尽可能避免无用的轮询）。
- en: Data should be sent over USB immediately (avoid delayed sending whenever possible).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据应立即通过USB发送（尽可能避免延迟发送）。
- en: Calls should be non-blocking (tasks may add data to be sent without waiting
    for the actual transaction).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用应该是非阻塞的（任务可以添加要发送的数据，而无需等待实际的事务）。
- en: Tasks may choose how long to wait for space to be available before data is dropped.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务可以选择在数据被丢弃之前等待空间可用的时长。
- en: 'These design decisions will have several implications:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计决策将产生几个影响：
- en: '**Transmit timing uncertainty**: While data is queued in a non-blocking manner,
    the exact timing of the transfer is not guaranteed. This is not an issue for this
    specific example, but if this were being used for time-sensitive interactions,
    it could be. USB CDC isn''t a great choice for something with extremely sensitive
    timing requirements to begin with.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输时间不确定性**：虽然数据以非阻塞方式排队，但传输的确切时间不能保证。这在这个特定示例中不是问题，但如果这是用于对时间敏感的交互，则可能是问题。USB
    CDC一开始就不是非常适合对时间要求极为敏感的应用。'
- en: '**Trade-offs between buffer size and latency**: In order to provide sufficient
    space for transmitting large messages, the queue can be made larger. However,
    it takes longer for data to exit a large queue than a small one. If latency or
    timing is a consideration, this time needs to be taken into account.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区大小和延迟之间的权衡**：为了为传输大消息提供足够的空间，队列可以做得更大。然而，数据从大队列中退出所需的时间比从小队列中退出所需的时间更长。如果延迟或时间是一个考虑因素，则需要考虑这段时间。'
- en: '**RAM usage**: The queue requires additional RAM, on top of what the USB buffers
    already require.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM使用**：队列需要额外的RAM，这超出了USB缓冲区已经需要的RAM。'
- en: '**Efficiency**: This driver represents a trade-off between ease of use and
    efficiency. There are effectively two buffers – the buffer used by USB and the
    queue. To provide ease of use, data will be copied by value *twice*, once into
    the queue and once into the USB transmit buffer. Depending on the required bandwidth,
    this could present a significant performance constraint.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：此驱动程序代表了易用性和效率之间的权衡。实际上有两个缓冲区——USB使用的缓冲区和队列。为了提供易用性，数据将被值复制**两次**，一次进入队列，一次进入USB传输缓冲区。根据所需的带宽，这可能会带来显著的性能限制。'
- en: First, let's take a high-level look at the STM USB device driver stack to better
    understand the options we have when interfacing with the STM-supplied CDC driver.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从高层次上了解一下STM USB设备驱动程序堆栈，以便更好地理解我们在与STM提供的CDC驱动程序接口时拥有的选项。
- en: Introducing the STM USB driver stack
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍STM USB驱动程序堆栈
- en: STM32CubeMX was used as a starting point to generate a USB device driver stack
    with CDC support. Here's an overview of the significant USB source files and where
    they reside, relative to the root of the repository: [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: STM32CubeMX被用作起点，以生成具有CDC支持的USB设备驱动程序堆栈。以下是重要的USB源文件及其相对于存储库根目录的位置概述：[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/)
- en: 'Low-level HAL USB files:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 低级HAL USB文件：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `stm32f7xx_ll_usb.c/h` files are the lowest level files, which provide access
    to the USB hardware peripherals. These files are used by the STM-supplied USB
    driver stack middleware.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`stm32f7xx_ll_usb.c/h`文件是最低级别的文件，提供了访问USB硬件外设的接口。这些文件被STM提供的USB驱动程序堆栈中间件使用。'
- en: 'STM USB device stack:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: STM USB设备堆栈：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding files implement the core USB device and CDC class functionality.
    These are also supplied by STM. These provide most of the functionality required
    for dealing with USB transactions and enumeration.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前述文件实现了核心USB设备和CDC类功能。这些也是由STM提供的。这些提供了处理USB事务和枚举所需的大部分功能。
- en: 'Most interaction with the USB library will take place at the CDC interface
    level, in the BSP folder:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与USB库的大部分交互将在CDC接口级别进行，在BSP文件夹中：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s a brief description of each source file pair and its purpose. These
    files are the most likely files to be modified during USB development:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个源文件对及其用途的简要描述。这些文件在USB开发过程中最有可能被修改：
- en: '`Nucleo_F767ZI_Init.c/h`: Initialization code for the MCU, which is specific
    to this hardware. Functions such as clock and individual pin configuration happen
    here.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nucleo_F767ZI_Init.c/h`：MCU的初始化代码，针对特定硬件。时钟和单个引脚配置等功能在这里发生。'
- en: '`usbd_cdc_if.c/h`: (STM Cube generated). Contains the USB device CDC interface
    functions. `CDC_Transmit_FS()` is used to transmit data from the MCU to the USB
    host (a PC in this case). `CDC_Receive_FS()` is used to receive data from the
    USB host.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usbd_conf.c/h`: (STM Cube generated). Used to map functions and required callbacks
    of `stm32f7xx_hal_pcd.c` (the USB peripheral control driver) to `stm32f7xx_ll_usb.c`
    (the low-level USB peripheral interface driver).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usbd_desc.c/h`: (STM Cube generated). USB device descriptors that are used
    during USB enumeration are defined here. This is where product and vendor identification
    numbers are defined (PID, VID).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usb_device.c/h`: (STM Cube generated). Contains the top-level function for
    initializing the USB stack. This file contains `MX_USB_DEVICE_Init()`, which is
    used to initialize the entire USB device driver stack. `MX_USB_DEVICE_Init()`
    should be called *after* all lower-level clock and pin initialization has been
    performed (`HWInit()` in `Nucleo_F767ZI_Init.c` performs this initialization).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a general idea of how the code is structured, let's create
    a simple example to better understand how to interact with it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Using the stock CDC drivers
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`mainRawCDC.c` contains a minimal amount of code to configure the MCU hardware
    and USB device stack. It will allow the MCU to enumerate over USB as a virtual
    COM port when a micro-USB cable is plugged into CN1 (and goes to a USB host such
    as a PC) and power is applied through CN13\. It will attempt to send two messages
    over USB: *test* and *message:*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The USB stack is initialized by using the `MX_USB_Device_Init()` function after
    the hardware is fully initialized:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is a single task that outputs two strings over USB, with a forced 100
    tick delay after the second transmission using a naive call to `usbd_cdc_if.c`: `CDC_Transmit_FS`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After compiling and loading this application to our target board, we can observe
    the output of the USB port by opening a terminal emulator (Tera Term in this case).
    You''ll likely see something similar to the following screenshot:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5731c4e7-e36c-41b1-9ec5-d9f7a7c0fa60.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: Since we were outputting a single line containing test and then a single line
    containing message, we would hope that the virtual serial port would contain that
    same sequence, but there are multiple *test* lines that aren't always followed
    by a *message* line.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Watching this same application run from SystemView shows that the code is executing
    in the order that we would expect:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fb6c15f-018a-42f6-ac32-75986b1a9ff9.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'Upon closer inspection of `CDC_Transmit_FS`, we can see that there is a return
    value that should have been inspected. `CDC_Transmit_FS` first checks to ensure
    that there isn''t already a transfer being performed before overwriting the transmit
    buffer with new data. Here are the contents of `CDC_Transmit_FS`(automatically
    generated by STM Cube):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Data will only be transmitted if there isn't already a transfer in progress
    (indicated by `hcdc->TxState`). So, to ensure that all of the messages are transmitted,
    we have a number of options here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在没有正在进行的传输（由`hcdc->TxState`指示）时，才会进行数据传输。因此，为了确保所有消息都得到传输，我们这里有几个选择。
- en: 'We could simply wrap each and every call to `CDC_Transmit_FS` in a conditional
    statement to check whether the transfer was successful:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以简单地用条件语句包裹对`CDC_Transmit_FS`的每一个调用，以检查传输是否成功：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are several downsides to this approach:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个缺点：
- en: It is slow when attempting to transmit multiple messages back to back (because
    of the delay between each attempt).
  id: totrans-77
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在尝试连续发送多个消息时，速度较慢（因为每次尝试之间的延迟）。
- en: If the delay is removed, it will be extremely wasteful of CPU, since the code
    will essentially poll on transmission completion.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果移除延迟，将极度浪费CPU资源，因为代码将基本上在传输完成时进行轮询。
- en: It is undesirably complex. By forcing the calling code to evaluate whether a
    low-level USB transaction was valid, we're adding a loop and nested conditional
    statements to something that could potentially be very simple. This will increase
    the likelihood that it is coded incorrectly and reduce readability.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是不希望看到的复杂性。通过强制调用代码评估低级USB事务是否有效，我们在可能非常简单的事情上添加了一个循环和嵌套条件语句。这将增加代码编写错误的概率并降低可读性。
- en: 'We could write a new wrapper based on `usbd_cdc_if.c` that uses FreeRTOS stream
    buffers to efficiently move data to the USB stack. This approach has a few caveats:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以基于`usbd_cdc_if.c`编写一个新的包装器，使用FreeRTOS流缓冲区有效地将数据移动到USB堆栈。这种方法有几个注意事项：
- en: To keep the calling code simple, we'll be tolerant of dropped data (if space
    in the stream buffer is unavailable).
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保持调用代码简单，我们将容忍丢失的数据（如果流缓冲区空间不足）。
- en: To support calls from multiple tasks, we'll need to protect access to the stream
    buffer with a mutex.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持来自多个任务的调用，我们需要使用互斥锁保护对流缓冲区的访问。
- en: The stream buffer will effectively create a duplicate buffer, thereby consuming
    additional RAM.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流缓冲区将实际上创建一个重复的缓冲区，从而消耗额外的RAM。
- en: We could use a FreeRTOS queue instead of a stream buffer. As seen in *[Chapter
    10](dd741273-db9a-4e9a-a699-b4602e160b84.xhtml), Drivers and ISRs,* we would receive
    a performance hit when using a queue (relative to a stream buffer) since it would
    be moving only a single byte at a time. However, a queue wouldn't require being
    wrapped in a mutex when used across tasks.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用FreeRTOS队列代替流缓冲区。如[第10章](dd741273-db9a-4e9a-a699-b4602e160b84.xhtml)，*驱动程序和中断服务例程*）中所示，使用队列（相对于流缓冲区）时，由于每次只移动一个字节，因此会收到性能上的影响。然而，当在任务间使用时，队列不需要被互斥锁封装。
- en: The *best* solution depends on many factors (there's a list of considerations
    at the end of [Chapter 10](dd741273-db9a-4e9a-a699-b4602e160b84.xhtml), *Drivers
    and ISRs*). For this example, we'll be using a stream buffer implementation. There
    is plenty of room for the extra space required by the buffer. The code here is
    only intended to support occasional short messages, rather than a fully reliable
    data channel. This limitation is mainly being placed to minimize complexity to
    make the examples easier to read.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案取决于许多因素（有关考虑因素的列表见[第10章](dd741273-db9a-4e9a-a699-b4602e160b84.xhtml)，*驱动程序和中断服务例程*）。在此示例中，我们将使用流缓冲区实现。缓冲区所需的额外空间有足够的空间。这里的代码仅用于支持偶尔的短消息，而不是一个完全可靠的数据通道。这种限制主要是为了最小化复杂性，使示例更容易阅读。
- en: 'Let''s now have a look at how options 2 and 3 look, relative to the STM HAL
    drivers already present:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看选项2和3相对于已存在的STM HAL驱动程序的样子：
- en: '![](img/ad3be02b-ea4a-49fc-aeb0-608c6b975f20.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad3be02b-ea4a-49fc-aeb0-608c6b975f20.png)'
- en: For this driver, we'll be modifying the stubbed out HAL-generated code supplied
    by ST (`usbd_cdc_if.c`) as a starting point. Its functionality will be replaced
    by our newly created `VirtualCommDriver.c`. This will be detailed in the next
    section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个驱动程序，我们将修改由ST提供的HAL生成的代码（`usbd_cdc_if.c`）作为起点。其功能将被我们新创建的`VirtualCommDriver.c`所取代。这将在下一节中详细介绍。
- en: 'We''ll also make a very small modification to the CDC middleware supplied by
    STM (`usbd_cdc.c/h`) to enable a non-polled method for determining when transfers
    are finished. The `USBD_CDC_HandleTypeDef` struct in `usbd_cdc.h` already has
    a variable named `TxState` that can be polled to determine when a transmission
    has completed. But, to increase efficiency, we''d like to avoid polling. To make
    this possible, we''ll add another member to the struct – a function pointer that
    will be called when a transfer is complete: `usbd_cdc.h`(additions in **bold**):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将对 STM 提供的 CDC 中间件（`usbd_cdc.c/h`）进行非常小的修改，以启用一种非轮询方法来确定传输何时完成。`usbd_cdc.h`
    中的 `USBD_CDC_HandleTypeDef` 结构体已经有一个名为 `TxState` 的变量，可以通过轮询来确定传输何时完成。但是，为了提高效率，我们希望避免轮询。为了实现这一点，我们将在结构体中添加另一个成员——一个在传输完成时将被调用的函数指针：`usbd_cdc.h`（**粗体**新增内容）：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ll then add the following code to `usbd_cdc.c.` (additions in bold):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将向 `usbd_cdc.c` 添加以下代码（**粗体**新增内容）：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This addition executes the function pointed to by `TxCallBack` if it has been
    provided (indicated by a non-NULL value). This happens when `TxState` in the CDC
    struct is set to 0. `TxCallBack` was also initialized to NULL in `USBD_CDC_Init()`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了 `TxCallBack` 函数指针（通过非空值指示），则执行该函数。这发生在 CDC 结构体中的 `TxState` 被设置为 0 时。`TxCallBack`
    也在 `USBD_CDC_Init()` 中初始化为 NULL。
- en: Modifying drivers supplied by STM will make it harder to migrate between different
    versions of HAL. These considerations must be weighed against any advantages they
    provide.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 STM 提供的驱动程序将使迁移到 HAL 的不同版本变得更加困难。必须权衡这些考虑与它们提供的任何优势。
- en: 'NOTE: More recent versions of HAL and STMCubeIDE include support for `TxCallBack`,
    so this modification won''t be necessary if you''re starting from scratch with
    the latest released code from ST.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：HAL 和 STMCubeIDE 的较新版本包括对 `TxCallBack` 的支持，因此如果你是从 ST 最新发布的代码开始，这个修改将不再必要。
- en: Developing a StreamBuffer USB virtual COM port
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 StreamBuffer USB 虚拟串行端口
- en: '`VirtualComDriver.c` is located in the top-level `Drivers` folder (since we''re
    likely to use it in a future chapter). It is available here: [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Drivers/HandsOnRTOS/](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Drivers/HandsOnRTOS/)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualComDriver.c` 位于顶层 `Drivers` 文件夹中（因为我们很可能在未来的章节中使用它）。它在这里可用：[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Drivers/HandsOnRTOS/](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Drivers/HandsOnRTOS/)'
- en: First, we'll walk through each of the functions that have been created, and
    their purpose.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将逐一介绍创建的每个函数及其用途。
- en: Public functions
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共函数
- en: '`VirtualComDriver.c`  currently has three publicly available functions:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualComDriver.c` 当前有三个公开可用的函数：'
- en: '`TransmitUsbDataLossy`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransmitUsbDataLossy`'
- en: '`TransmitUsbData`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TransmitUsbData`'
- en: '`VirtualCommInit`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualCommInit`'
- en: '`TransmitUsbDataLossy` is simply a wrapper around a stream buffer function
    call. It uses an ISR-safe variant, which is guaranteed not to block (but may also
    not copy all data into the buffer). The number of bytes copied into the buffer
    is returned. In this case, it is up to the calling code to determine whether or
    not to finish copying data into the buffer:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransmitUsbDataLossy` 简单地是一个围绕流缓冲区函数调用的包装器。它使用了一个中断服务例程（ISR）安全的变体，这保证了它不会阻塞（但可能也不会将所有数据复制到缓冲区中）。返回的是复制到缓冲区中的字节数。在这种情况下，是否完成数据复制到缓冲区由调用代码来决定：'
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`TransmitUsbData` provides a bit more convenience. It will block up to two
    ticks waiting for space to become available in the buffer. This is broken into
    two calls in case the buffer fills part way through the initial transfer. It is
    likely that enough space will be available 1 tick later when the second call to
    `xStreamBufferSend` is made. In most cases, there will be very little dropped
    data using this method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransmitUsbData` 提供了更多的便利性。它将阻塞最多两个滴答等待缓冲区中有空间可用。如果缓冲区在初始传输过程中部分填满，这将被分成两个调用。在第二次调用
    `xStreamBufferSend` 时，很可能会有足够的空间可用。在大多数情况下，使用这种方法丢失的数据非常少：'
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`VirtualCommInit` performs all of the setup required for both the USB stack
    and the necessary FreeRTOS task. The stream buffer is being initialized with a
    trigger level of 1 to minimize the latency between when `TransmitUsbData` is called
    and when the data is moved into the USB stack. This value can be adjusted in conjunction
    with the maximum blocking time used in `xStreamBufferReceive` to achieve better
    efficiency by ensuring that larger blocks of data are transferred simultaneously:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualCommInit` 执行 USB 栈和必要的 FreeRTOS 任务所需的所有设置。流缓冲区正在以触发级别 1 初始化，以最小化 `TransmitUsbData`
    被调用与数据移动到 USB 栈之间的延迟。此值可以与 `xStreamBufferReceive` 中使用的最大阻塞时间一起调整，以确保同时传输更大的数据块，从而实现更好的效率：'
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These are all of the publicly available functions. By modifying slightly the
    interaction with the stream buffer, this driver can be optimized for many different
    use cases. The remainder of the functionality is provided by functions that aren't
    publicly accessible.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是公开可用的函数。通过稍微修改与流缓冲区的交互，此驱动程序可以针对许多不同的用例进行优化。其余的功能由不可公开访问的函数提供。
- en: Private functions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有函数
- en: '`usbTask` is a private function that takes care of the initial setup of our
    CDC overrides. It also monitors the stream buffer and task notifications, making
    the required calls to the CDC implementation provided by STM.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`usbTask` 是一个私有函数，负责我们 CDC 覆盖的初始设置。它还监控流缓冲区和任务通知，对 STM 提供的 CDC 实现进行必要的调用。'
- en: 'Before starting its main loop, there are a few items that need to be initialized:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始主循环之前，有一些项目需要初始化：
- en: 'The task must wait until all of the underlying peripherals and USB stack initialization
    are performed. This is because the task will be accessing data structures created
    by the USB CDC stack:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务必须等待所有底层外设和 USB 栈初始化完成。这是因为任务将访问由 USB CDC 栈创建的数据结构：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A task notification is given, provided a transmission is not already in progress.
    The notification is also taken, which allows for an efficient way to block in
    case a transfer is already in progress:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果传输尚未进行，则提供任务通知。通知也被接受，这允许在传输正在进行时以高效的方式阻塞：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`usbTxComplete` is the callback function that will be executed when a transmission
    is finished. The USB CDC stack is ready to accept more data to be transmitted.
    Setting the `TxCallBack` variable to `usbTxComplete` configures the structure
    used by `usbd_cdc.c`, allowing our function to be called at the right time:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`usbTxComplete` 是当传输完成时将被执行的回调函数。USB CDC 栈已准备好接受更多要传输的数据。将 `TxCallBack` 变量设置为
    `usbTxComplete` 配置 `usbd_cdc.c` 使用的结构，允许我们的函数在正确的时间被调用：'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`usbTxComplete` is short, only consisting of a few lines that will provide
    a task notification and force a context switch to be evaluated (so `usbTask` will
    be unblocked as quickly as possible):'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`usbTxComplete` 很短，只包含几行代码，用于提供任务通知并强制进行上下文切换以进行评估（因此 `usbTask` 将尽可能快地被解除阻塞）：'
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A function pointed to by `TxCallBack` is executed within the USB ISR, so any
    code executed by the callback must be kept extremely brief, call only ISR-safe
    versions of FreeRTOS functions, and have its priority properly configured.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 USB 中断服务例程（ISR）中执行由 `TxCallBack` 指向的函数，因此回调中执行的任何代码都必须非常简短，只能调用 FreeRTOS 函数的
    ISR 安全版本，并且其优先级必须正确配置。
- en: 'The infinite `while` loop portion of `usbTask` follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`usbTask` 的无限 `while` 循环部分如下：'
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The task notification provides an efficient way to gate transmissions without
    polling:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 任务通知提供了一种高效的方式来控制传输，而不需要轮询：
- en: Whenever a transmission has finished, the callback (`usbTxComplete`) will be
    executed from the USB stack. `usbTxComplete` will provide a notification that
    will unblock the `usbTask`, at which point it will go out to the stream buffer
    and collect as much data as it can in one call, copying all available data into `usbTxBuff`
    (up to `numBytes` bytes).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当传输完成时，回调（`usbTxComplete`）将从 USB 栈中执行。`usbTxComplete` 将提供通知，这将解除 `usbTask`
    的阻塞，此时它将转到流缓冲区并尽可能在一次调用中收集尽可能多的数据，将所有可用数据复制到 `usbTxBuff`（最多 `numBytes` 字节）中。
- en: If a transmission is complete, `usbTask` will block indefinitely until data
    shows up in the stream buffer (`txStream`). `usbTask` won't be consuming any CPU
    time while blocking, but it will also automatically unblock whenever data is available.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传输完成，`usbTask` 将无限期地阻塞，直到流缓冲区（`txStream`）中出现数据。在阻塞期间，`usbTask` 不会消耗任何 CPU
    时间，但它也会在数据可用时自动解除阻塞。
- en: This method provides a very efficient way of queueing data, while also providing
    good throughput and low latency. Any tasks adding data to the queue don't need
    to block or wait until their data is transmitted.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法提供了一种非常高效的数据排队方式，同时提供良好的吞吐量和低延迟。向队列添加数据的任何任务都不需要阻塞或等待其数据被传输。
- en: Putting it all together
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: 'There''s a fair amount going on here, with multiple sources of asynchronous
    events. Here''s a sequence diagram of how all of these functions fit together:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行中，有多个异步事件源。以下是所有这些函数如何组合在一起的时序图：
- en: '![](img/91dc6143-3515-4e56-88d8-d0d6fda668ae.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91dc6143-3515-4e56-88d8-d0d6fda668ae.png)'
- en: 'Here are a few noteworthy items from the preceding diagram:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前一个图中的一些值得注意的项目：
- en: Calls to `TransmitUsbData` and `TransmitUsbDataLossy` are non-blocking. If space
    is available, data is transferred into the stream buffer, `txStream`, and the
    number of bytes copied is returned. Partial messages may be copied into the buffer
    (which happens under extremely high load when the buffer gets filled).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `TransmitUsbData` 和 `TransmitUsbDataLossy` 的调用是非阻塞的。如果空间可用，数据将被传输到流缓冲区 `txStream`，并返回复制的字节数。在极高负载下，当缓冲区被填满时，可能将部分消息复制到缓冲区中。
- en: 'Two things need to happen before a packet of data is sent via `USBD_CDC_TransmitPacket`:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通过 `USBD_CDC_TransmitPacket` 发送数据包之前，需要发生两件事：
- en: '`usbTask` must receive a task notification, indicating that it is clear to
    send data.'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usbTask` 必须接收到一个任务通知，表明可以发送数据。'
- en: Data must be available in `txStream`.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据必须在 `txStream` 中可用。
- en: Once transmission has started, the USB stack will be called by `OTG_FS_IRQHandler`
    in `stm32f7xx_it.c` until the transfer is complete, at which point the function
    pointed to by `TxCallBack` (`usbTxComplete`) will be called. This callback is
    executed from within the USB ISR, so the ISR-safe version of `vTaskNotify` (`vTaskNotifyFromISR`)
    must be used.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输开始后，USB 堆栈将在 `stm32f7xx_it.c` 中的 `OTG_FS_IRQHandler` 被调用，直到传输完成，此时将调用由 `TxCallBack`
    指向的函数（`usbTxComplete`）。此回调在 USB 中断服务例程（ISR）内部执行，因此必须使用 ISR 安全版本的 `vTaskNotify`（`vTaskNotifyFromISR`）。
- en: 'In `mainStreamBuffer.c`, (available from [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_11/Src/mainUsbStreamBuffer.c](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Drivers/STM32F7xx_HAL_Driver)),
    the virtual COM port is initialized with a single line, once the hardware initialization
    has been performed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mainStreamBuffer.c` 中（可在 [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_11/Src/mainUsbStreamBuffer.c](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Drivers/STM32F7xx_HAL_Driver)
    获取），一旦完成硬件初始化，虚拟串口通过单行初始化：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A single task has been created in `mainStreamBuffer.c` to push data over to
    the USB:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mainStreamBuffer.c` 中创建了一个单独的任务来将数据推送到 USB：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This results in output that alternates as we would expect, thanks to the buffering
    provided by the stream buffer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致输出交替变化，正如我们所预期的那样，归功于流缓冲区提供的缓冲：
- en: '![](img/fb8c955c-520e-4f57-95f7-71397b969164.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb8c955c-520e-4f57-95f7-71397b969164.png)'
- en: 'Let''s now take a look at a single transfer using SystemView:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个使用 SystemView 的单个传输示例：
- en: '![](img/3c6a6009-497b-4811-af2d-a338ecf2916e.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c6a6009-497b-4811-af2d-a338ecf2916e.png)'
- en: 'All of the tasks and ISRs are arranged in ascending priority. Numbers in the
    SystemView terminal on the right have corresponding numbers on the timeline:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有任务和中断服务例程（ISRs）都按照升序优先级排列。在右侧的 SystemView 终端上的数字与时间线上的相应数字相对应：
- en: The first item, *test\n*, was added to the buffer. `usbTask` is now ready to
    run (indicated by the blue box).
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一项，*test\n* 被添加到缓冲区。`usbTask` 现在准备运行（由蓝色框表示）。
- en: The second item, *message\n*, was added to the buffer. After the `usbPrint`
    task blocks, `usbTask` is brought into context by the scheduler.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二项，*message\n* 被添加到缓冲区。在 `usbPrint` 任务阻塞后，调度器将 `usbTask` 带入上下文。
- en: All 15 bytes are copied from the stream buffer, `txStream`, and placed into
    the local `usbTxBuff`. This buffer is fed into the USB stack using `USBD_CDC_SetTxBuffer`
    and a transfer is started with `USBD_CDC_TransmitPacket`. The USB stack takes
    care of the transfer and issues a callback when it is finished (`usbTxComplete`).
    This callback sends a task notification to `usbTask`, signaling that the transfer
    is complete.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有 15 个字节都从流缓冲区 `txStream` 复制到本地的 `usbTxBuff`。此缓冲区通过 `USBD_CDC_SetTxBuffer`
    被喂入 USB 堆栈，并通过 `USBD_CDC_TransmitPacket` 启动传输。USB 堆栈负责传输并在完成后发出回调（`usbTxComplete`）。此回调向
    `usbTask` 发送任务通知，表示传输已完成。
- en: '`usbTask` receives the task notification and continues with the loop.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`usbTask`接收任务通知并继续循环。'
- en: '`usbTask` begins waiting on data to become available in `txStream`.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`usbTask`开始等待`txStream`中有可用数据。'
- en: 'This general sequence repeats every 2 ms, which translates into about 1,000
    lines being transmitted each second. Keep in mind that the delay is present to
    make analysis easier. The non-lossy `TransmitUsbData()` could be utilized instead
    with no delay, but seeing *exactly *what is occurring is a bit more of a challenge:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一般序列每2毫秒重复一次，这相当于每秒传输大约1,000行。请注意，延迟是为了使分析更容易。可以使用无损耗的`TransmitUsbData()`代替，但看到*确切地*发生了什么要困难一些：
- en: '![](img/174b876a-76ed-4aec-af89-56c36dca0b79.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/174b876a-76ed-4aec-af89-56c36dca0b79.png)'
- en: The total CPU time consumed is around 10%, with most of the time spent in `usbTask`
    and `usbPrint.`
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 总CPU时间消耗大约为10%，大部分时间花在`usbTask`和`usbPrint`上。
- en: 'If we wanted to minimize CPU usage, at the expense of introducing a bit more
    latency between when a message was first printed and when it was transmitted over
    the line, the following changes could be made:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要最小化CPU使用率，以牺牲在消息首次打印和通过线路传输之间的延迟为代价，可以进行以下更改：
- en: 'The following is an excerpt from `VirtualCommDriver.c`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`VirtualCommDriver.c`的摘录：
- en: 'Increase the trigger value used to initialize `txStream` from 1 to 500\. This
    will cause the buffer to attempt to gather 500 bytes before returning data:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用于初始化`txStream`的触发值从1增加到500。这将导致缓冲区在返回数据之前尝试收集500个字节：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Decrease the maximum amount of time to wait on data to become available in
    the stream from an infinite timeout to 100 ticks. This will guarantee that the
    stream is emptied at least once every 100 ticks (which happens to be 100 ms with
    the current configuration). This minimizes context switching and how often `usbTask`
    will need to run. It also allows for more data to be transferred to the USB stack
    at a time:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在流中等待数据可用的最大时间从无限超时减少到100个滴答。这将保证流至少每100个滴答（在当前配置下恰好是100毫秒）清空一次。这最小化了上下文切换以及`usbTask`需要运行的频率。它还允许一次传输更多数据到USB堆栈：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Increasing the trigger value of the stream buffer from 1 to 500 bytes and increasing
    the available block time from 1 to 100 ticks *reduces the CPU usage of*** `usbTask`**
    *by a whopping 94%*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将流缓冲区的触发值从1增加到500字节，并将可用块时间从1增加到100个滴答*将`usbTask`的CPU使用率降低了94%*：
- en: '![](img/a193835d-8bf2-4f13-8a88-dbd4a4b945b9.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a193835d-8bf2-4f13-8a88-dbd4a4b945b9.png)'
- en: Now, this means we also have an increase in latency – the amount of time it
    takes between when a call to `TransmitUsbDataLossy` is made and when that message
    is transmitted across the USB cable. So, there is a trade-off to be made. In this
    simple example, where the use case is just a simple printout with a human looking
    at the text, 10 Hz is likely more than fast enough.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这也意味着我们也有延迟的增加——从调用`TransmitUsbDataLossy`到消息通过USB电缆传输所需的时间。因此，需要做出权衡。在这个简单的例子中，使用场景只是简单的打印输出，由人查看文本，10
    Hz可能已经足够快了。
- en: Now that we have most of our USB driver written, we can add in some additional
    safety measures to guarantee that `VirtualCommDriver` is safe to use across multiple
    tasks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了大部分USB驱动程序，我们可以添加一些额外的安全措施来确保`VirtualCommDriver`可以在多个任务之间安全使用。
- en: Using mutexes for access control
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥锁进行访问控制
- en: Since we implemented our driver with a stream buffer, if we are interested in
    having more than one task write to it, access to the stream buffer must be protected
    by a mutex. Most of the other FreeRTOS primitives, such as queues, don't have
    this limitation; they are safe to use across multiple tasks without any additional
    effort. Let's take a look at what would be required to extend VirtualCommDriver
    to make it usable by more than one task.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用流缓冲区实现了我们的驱动程序，如果我们希望有多个任务写入它，则必须通过互斥锁来保护对流缓冲区的访问。大多数其他FreeRTOS原语，如队列，没有这种限制；它们可以在多个任务之间安全使用，无需额外努力。让我们看看扩展VirtualCommDriver使其能够被多个任务使用需要哪些改动。
- en: Extending VirtualCommDriver
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展VirtualCommDriver
- en: To make usage for the users of VirtuCommPortDriver as easy as possible, we can
    incorporate all of the mutex handling within the function call itself, rather
    than requiring users of the function to manage the mutex.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使VirtuCommPortDriver的用户使用尽可能简单，我们可以在函数调用本身中包含所有互斥锁处理，而不是要求函数的用户管理互斥锁。
- en: 'An additional file, `VirtualCommDriverMultiTask.c`has been created to illustrate
    this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'A mutex is defined and created, along with all of the other variables required
    across multiple functions in this source file:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To prevent multiple copies of this mutex from being created for each compilation
    unit `VirtualComDriverMultitTask` is included in, we won't define our *private
    global* variables as having *static* scope this time. Since we don't have namespaces
    in C, we'll prepend the names with `vcom_` in an attempt to avoid naming collisions
    with other globals.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The mutex is initialized in `VirtualCommInit()`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A new `TransmitUsbData()`function has been defined. It now includes a maximum
    delay (specified in milliseconds):'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define a few variables to help keep track of elapsed time:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The previous calls to `xStreamBufferSend` are wrapped inside the mutex, `vcom_mutexPtr`.
    `remainingTime` is updated after each blocking FreeRTOS API call to accurately
    limit the maximum amount of time spent in this function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A new main file, `mainUsbStreamBufferMultiTask`, was created to illustrate
    usage:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '`usbPrintOutTask` was created. This takes a number as an argument as a means
    to easily differentiate which task is writing:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Two instances of `usbPrintOutTask` are created, passing in the numbers *1*
    and *2*. A cast to `(void*)` prevents complaints from the compiler:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, multiple tasks are able to send data over the USB. The amount of time that
    each call to `TransmitUsbData` may block is specified with each function call.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Guaranteeing atomic transactions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it is desirable to transmit a message and then be confident that
    the response is for that message. In these cases, a mutex can be used at a higher
    level. This allows for groups of messages to be clustered together. An example
    of when this technique can be especially useful is a single peripheral servicing
    multiple physical ICs across multiple tasks:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d19521f-e780-41d2-b8c5-fba0dc26bff4.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the same peripheral (SPI1) is used to service two
    different ICs. Although the SPI peripheral is shared, there are separate chip
    select lines (CS1 and CS2) for each IC. There are also two completely independent
    drivers for these devices (one is an ADC and one is a DAC). In this situation,
    a mutex can be used to group multiple messages going to the same device together
    so they all occur when the correct chip select line is activated; things wouldn't
    go well if the ADC was meant to receive data when CS2 was asserted (the DAC would
    receive the data instead).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach can work well when all of the the following conditions exist:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Individual transfers are fast.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peripherals have low latency.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility (at least several ms, if not 10's of ms) as to exactly when transfers
    can take place.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared hardware isn't much different from any other shared resource. There are
    many other real-world examples that haven't been discussed here.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into creating an efficient interface to
    a complex driver stack that was very convenient to use. Using stream buffers,
    we analyzed trade-offs between decreasing latency and minimizing CPU usage. After
    a basic interface was in place, it was extended to be used across multiple tasks.
    We also saw an example of how a mutex could be used for ensuring that a multi-stage
    transaction remained atomic, even while the peripheral was shared between tasks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了创建一个高效接口，该接口用于一个非常方便使用的复杂驱动程序堆栈。使用流缓冲区，我们分析了降低延迟和最小化CPU使用之间的权衡。在基本接口就位后，它被扩展到可以在多个任务中使用。我们还看到了一个示例，展示了如何使用互斥锁来确保多阶段事务在多个任务之间共享外设时保持原子性。
- en: Throughout the examples, we focused on performance versus ease of use and coding
    effort. Now that you have a good understanding of why design decisions are being
    made, you should be in a good position to make informed decisions regarding your
    own code base and implementations. When the time comes to implement your design,
    you'll also have a solid understanding of the steps that need to be taken to guarantee
    race condition-free access to your shared peripheral.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有示例中，我们关注的是性能与易用性以及编码工作量之间的权衡。现在您已经很好地理解了为什么需要做出这些设计决策，您应该能够就您自己的代码库和实现做出明智的决策。当您准备实现设计时，您也将对确保对共享外设无竞争条件访问所需的步骤有坚实的理解。
- en: So far, we've been discussing trade-offs when creating drivers, so that we write
    something that is as close to perfect for our use case as possible. Wouldn't it
    be nice if (at the beginning of a new project) we didn't need to re-invent the
    wheel by copying, pasting, and modifying all of these drivers every time? Instead
    of continually introducing low-level, hard-to-find bugs, we could simply bring
    in everything we know that works well and get to work adding new features required
    for the new project? With a well-architected system, this type of workflow is
    entirely possible! In the next chapter, we'll cover several tips on creating a
    firmware architecture that is flexible and doesn't suffer from the copy-paste-modify
    trap many firmware engineers find themselves stuck in.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在讨论创建驱动程序时的权衡，以便我们编写的东西尽可能接近我们用例的完美。如果（在新的项目开始时）我们不需要每次都通过复制、粘贴和修改所有这些驱动程序来重新发明轮子，那岂不是很好？我们不必不断地引入低级、难以发现的错误，而可以简单地引入我们所知道的一切有效内容，然后开始添加新项目所需的新功能？在良好的系统架构下，这种工作流程是完全可能的！在下一章中，我们将介绍创建灵活且不受复制粘贴修改陷阱困扰的固件架构的几个技巧。
- en: Questions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments* section
    of the Appendix:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结之际，这里有一份问题列表，供您测试对本章节内容的理解。您将在附录的*评估*部分找到答案：
- en: 'It is *always* best to minimize the number of hardware peripherals being used:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是最好最小化使用的硬件外设数量：
- en: 'True'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: 'When sharing a hardware peripheral across multiple tasks, the only concern
    is creating threadsafe code that ensures that only one task has access to the
    peripheral at a time:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在多个任务之间共享硬件外设时，唯一关心的是创建线程安全的代码，确保一次只有一个任务可以访问外设：
- en: 'True'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: What trade-offs do stream buffers allow us to make when creating them?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建流缓冲区时，我们允许做出哪些权衡？
- en: Latency
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟
- en: CPU efficiency
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU效率
- en: Required RAM size
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需RAM大小
- en: All of the above
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以上所有
- en: 'Stream buffers can be used directly by multiple tasks:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流缓冲区可以直接由多个任务使用：
- en: 'True'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: What is one of the mechanisms that can be used to create threadsafe atomic access
    to a peripheral for the entire duration of a multi-stage message?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在整个多阶段消息期间，可以用来创建线程安全原子访问外设的机制之一是什么？
