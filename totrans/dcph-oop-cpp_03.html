<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer019">
<h1 class="chapter-number" id="_idParaDest-56"><a id="_idTextAnchor118"/>3</h1>
<h1 id="_idParaDest-57"><a id="_idTextAnchor119"/>Indirect Addressing – Pointers</h1>
<p>This chapter will provide a thorough understanding of how to utilize pointers in C++. Though it is assumed that you have some prior experience with indirect addressing, we will start at the beginning. Pointers are a ground-level and pervasive feature of the language – one you must thoroughly understand and be able to utilize with ease. Many other languages use indirect addressing through references alone; however, in C++ you must roll up your sleeves and understand how to use and return heap memory correctly and effectively with pointers. You will see pointers heavily used throughout code from other programmers; there is no sensible way to ignore their use. Misusing pointers can create the most difficult errors to find in a program. A thorough understanding of indirect addressing using pointers is a necessity in C++ to create successful and maintainable code.</p>
<p>In this chapter, you will additionally preview the concept of a smart pointer, which can help alleviate the difficulty and potential pitfalls that may easily arise with native pointers. Nonetheless, you will need to have a facility with all types of pointers in order to successfully use existing class libraries or to integrate with or maintain existing code.</p>
<p>The goal of this chapter will be to build or enhance your understanding of indirect addressing using pointers so that you can easily understand and modify others’ code, as well as write original, sophisticated, error-free C++ code yourself.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Pointer basics, including access, and memory allocation and release – for standard and user defined types</li>
<li>Dynamically allocating arrays of <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">N</strong> dimensions, and managing their memory release</li>
<li>Pointers as arguments to functions and as return values from functions</li>
<li>Adding the <strong class="source-inline">const</strong> qualifier to pointer variables</li>
<li>Using void pointers – pointers to objects of unspecified types</li>
<li>Looking ahead to smart pointers to alleviate typical pointer usage errors</li>
</ul>
<p>By the end of this chapter, you will understand how to allocate memory from the heap using <strong class="source-inline">new()</strong> for simple and complex data types, as well as mark the memory for return to the heap management facility using <strong class="source-inline">delete()</strong>. You will be able to dynamically allocate arrays of any data type and of any number of dimensions, as well as understand basic memory management for releasing memory when it is no longer needed in your applications, to avoid memory leakage. You will be able to pass pointers as arguments to functions with any level of indirection – that is, pointers to data, pointers to pointers to data, and so on. You will understand how and why to combine the const qualification with pointers – to the data, to the pointer itself, or to both. You will additionally understand how to declare and utilize generic pointers with no type – void pointers – and understand the situations in which they may prove useful. Lastly, you will preview the concept of a smart pointer to alleviate potential pointer conundrums and usage errors. These skills will be necessary in order to move forward with the next chapters in the book successfully.</p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor120"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter03">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter03</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter03</strong> in a file named <strong class="source-inline">Chp3-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3AtBPlV">https://bit.ly/3AtBPlV</a>.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor121"/>Understanding pointer basics and memory allocation</h1>
<p>In this section, we <a id="_idIndexMarker143"/>will review pointer<a id="_idIndexMarker144"/> basics as well as introduce operators applicable to pointers, such as the address-of operator, th<a id="_idTextAnchor122"/>e dereference operator, and operators <strong class="source-inline">new()</strong> and <strong class="source-inline">delete()</strong>. We will employ the address-of operator <strong class="source-inline">&amp;</strong> to calculate the address of an existing variable, and conversely, we will apply the dereference operator <strong class="source-inline">*</strong> to a pointer variable to go to the address contained within the variable. We will see examples of memory allocation on the heap, as well as how to mark that same memory for potential reuse by returning it to the free list when we are done with it.</p>
<p>Using pointer variables allows our applications to have greater flexibility. At runtime, we can determine the quantity of a certain data type we may need (such as in a dynamically allocated array), organize data in data structures that facilitate sorting (such as in a linked list), or gain speed by passing an address of a large piece of data to a function (rather than passing a copy of the entire piece of data itself). Pointers have many uses, and we<a id="_idIndexMarker145"/> will <a id="_idIndexMarker146"/>see many examples throughout this chapter and throughout the course. Let’s start at the beginning with pointer basics.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor123"/>Revisiting pointer basics</h2>
<p>First and foremost, let <a id="_idIndexMarker147"/>us review the meaning of a pointer variable. A pointer variable is one that may contain an address, and memory at that address may contain relevant data. It is typical to say that the pointer variable <em class="italic">points</em> to an address containing the relevant data. The value of the pointer variable itself is an address, not the data we are after. When we then go to that address, we find the data of interest. This is known<a id="_idIndexMarker148"/> as <strong class="bold">indirect addressing</strong>. To summarize, the content of a pointer variable is an address; if you then go to that address, you find the data. This is for a single level of indirection.</p>
<p>A pointer variable may point to the existing memory of a non-pointer variable, or it may point to memory that is dynamically allocated on the heap. The latter case is the most usual situation. Unless a pointer variable is properly initialized or assigned a value, the content of the pointer variable is meaningless and does not represent a usable address. A large mistake can be assuming that a pointer variable has been properly initialized when it may not have been. Let us look at some basic operators that are useful with pointers. We will start with the address-of <strong class="source-inline">&amp;</strong> and the dereference operat<a id="_idTextAnchor124"/>or <strong class="source-inline">*</strong>.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor125"/>Using the address-of and dereference operators</h2>
<p>The <a id="_idIndexMarker149"/>address-of<a id="_idIndexMarker150"/> operator <strong class="source-inline">&amp;</strong> can <a id="_idIndexMarker151"/>be <a id="_idIndexMarker152"/>applied to a variable to determine its location in memory. The dereference operator <strong class="source-inline">*</strong> can be applied to a pointer variable to obtain the value of the data at the valid address contained within the pointer variable. </p>
<p>Let’s see a simple example:</p>
<pre class="source-code">
int x = 10;
int *pointerToX = nullptr; // pointer variable which may 
                           // someday point to an integer
pointerToX = <strong class="bold">&amp;</strong>x;  // assign memory loc. of x to pointerTo<a id="_idTextAnchor126"/>X
cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; " and *pointerToX: " &lt;&lt; <strong class="bold">*</strong>pointerToX;</pre>
<p>Notice in the previous segment of code that we first declare and initialize variable <strong class="source-inline">x</strong> to <strong class="source-inline">10</strong>. Next, we declare <strong class="source-inline">int *pointerToX = nullptr;</strong> to state that variable <strong class="source-inline">pointerToX</strong> may someday point to an integer, yet it is initialized with a <strong class="source-inline">nullptr</strong> for safety. Had we not initialized this variable with a <strong class="source-inline">nullptr</strong>, it would have been uninitialized and, therefore, would not contain a valid memory address.</p>
<p>Moving<a id="_idIndexMarker153"/> forward <a id="_idIndexMarker154"/>in<a id="_idIndexMarker155"/> the <a id="_idIndexMarker156"/>code to the line <strong class="source-inline">pointerToX = &amp;x;</strong>, we assign the memor<a id="_idTextAnchor127"/>y location of <strong class="source-inline">x</strong> using the address-of operator (<strong class="source-inline">&amp;</strong>) as the value of <strong class="source-inline">pointerToX</strong>, which is waiting to be filled with a valid address of some integer. On the last line of this code fragment, we print out both <strong class="source-inline">x</strong> and <strong class="source-inline">*pointerToX</strong>. Here, we are using the derefer<a id="_idTextAnchor128"/>ence operator <strong class="source-inline">*</strong> with the variable <strong class="source-inline">pointerToX</strong>. The dereference operator tells us to go to the address contained in the variable <strong class="source-inline">pointerToX</strong>. At that address, we find the data value of integer <strong class="source-inline">10</strong>.</p>
<p>Here is the output this fragment would generate as a full program:</p>
<p class="source-code">X: 10 and *pointerToX: 10</p>
<p class="callout-heading">Important note</p>
<p class="callout">For efficiency, C++ does not neatly initialize all memory with zeros when an application starts, nor does C++ ensure that memory is conveniently empty, without values, when paired with a variable. The memory simply has in it what was previously stored there; C++ memory is not considered <em class="italic">clean</em>. Because memory is not given to a programmer <em class="italic">clean</em> in C++, the contents of a newly declared pointer variable, unless properly initialized or assigned a value, should not be construed to contain a valid address.</p>
<p>In the preceding example, we used the address-of operator <strong class="source-inline">&amp;</strong> to calculate the address of an existing integer in memory, and we set our pointer variable to point to that memory. Instead, let us<a id="_idIndexMarker157"/> introduce operators <strong class="source-inline">new()</strong> and <strong class="source-inline">delete()</strong> to<a id="_idIndexMarker158"/> allow us to utilize dynamically <a id="_idIndexMarker159"/>allocated <a id="_idIndexMarker160"/>heap memory for use with pointer variables.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor129"/>Using operators new() and delete() </h2>
<p>Operator <strong class="source-inline">new()</strong> can<a id="_idIndexMarker161"/> be <a id="_idIndexMarker162"/>utilized <a id="_idIndexMarker163"/>to <a id="_idIndexMarker164"/>obtain dynamically allocated memory from the heap. A pointer variable may choose to point to memory that is dynamically allocated at runtime, rather than to point to another variable’s existing memory. This gives us flexibility as to when we want to allocate the memory, and how many pieces of such memory we may choose to have. Operator <strong class="source-inline">delete()</strong> can then be applied to a pointer variable to mark memory we no longer require, returning the memory to the heap management facility for later reuse in the application. It is important to understand that once we <strong class="source-inline">delete()</strong> a pointer variable, we should no longer use the address contained within that variable as a valid address.</p>
<p>Let’s take a look at simple memory allocation and release using a basic data type:</p>
<pre class="source-code">
int *y = nullptr; // ptr y may someday point to an int
y = <strong class="bold">new</strong> int;   // y pts to uninit. memory allocated on heap
*y = 17;   // dereference y to load the newly allocated
           // memory with <a id="_idTextAnchor130"/>a value of 17
cout &lt;&lt; "*y is: " &lt;&lt; *y &lt;&lt; endl;
<strong class="bold">delete</strong> y;  // relinquish the allocated memory
// alternative ptr declaration, mem alloc., initialization
int *z = <strong class="bold">new</strong> int(22); 
cout &lt;&lt;  "*z is: " &lt;&lt; *z &lt;&lt; endl;
<strong class="bold">delete</strong> z;  // relinquish heap memory</pre>
<p>In the previous program segment, we first declare pointer variable <strong class="source-inline">y</strong> with <strong class="source-inline">int *y = nullptr;</strong>. Here, <strong class="source-inline">y</strong> may someday contain the address of an integer, yet it is meanwhile safely initialized with a <strong class="source-inline">nullptr</strong>. On the next line, we allocate memory from the heap large enough to accommodate an integer with <strong class="source-inline">y = new int;</strong>, storing that address in pointer variable <strong class="source-inline">y</strong>. Next, with <strong class="source-inline">*y = 17;</strong>, we dereference <strong class="source-inline">y</strong> and store the value of <strong class="source-inline">17</strong> in the memory location pointed to by <strong class="source-inline">y</strong>. After printing out the value of <strong class="source-inline">*y</strong>, we then decide that we are done with the memory <strong class="source-inline">y</strong> points to and return it to the heap management facility by using operator <strong class="source-inline">delete()</strong>. It is important to note that variable <strong class="source-inline">y</strong> still contains the memory address it obtained with its call to <strong class="source-inline">new()</strong>; however, <strong class="source-inline">y</strong> should no longer use this relinquished memory.</p>
<p>Towards the end of the previous program segment, we alternatively declare pointer variable <strong class="source-inline">z</strong>, allocate heap memory for it to point to, and initialize that memory with <strong class="source-inline">int *z = new int(22);</strong>. Notice that we likewise deallocate the heap me<a id="_idTextAnchor131"/>mory using <strong class="source-inline">delete z;</strong>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">It is the programmer’s responsibility to remember that once memory has been deallocated, you should never again dereference that pointer variable; please understand that that address may have been reissued to another variable through another call to <strong class="source-inline">new()</strong> elsewhere in the program. A safeguard would be to reset a pointer to <strong class="source-inline">nullptr</strong> once its memory has been deallocated with <strong class="source-inline">delete()</strong>.</p>
<p>Now <a id="_idIndexMarker165"/>that<a id="_idIndexMarker166"/> we <a id="_idIndexMarker167"/>understand<a id="_idIndexMarker168"/> pointer basics with simple data types, let us move onward by allocating more complex data types, as well as understanding the notation necessary to utilize and access members of user defined data types.</p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor132"/>Creating and using pointers to user defined types</h2>
<p>Next, let us <a id="_idIndexMarker169"/>examine how to declare pointers <a id="_idIndexMarker170"/>to user defined types, and how to allocate their associated memory on the heap. To dynamically allocate a user defined type, the pointer will first be declared of that type. The pointer then must either be initialized or assigned a valid memory address – the memory can either be that of an existing variable or newly allocated heap memory. Once the address for the appropriate memory has been placed within the pointer variable, the <strong class="source-inline">-&gt;</strong> operator may be utilized to access struct or class members. Alternatively, the <strong class="source-inline">(*ptr).member</strong> notation may be used to access struct or class members.<a id="_idTextAnchor133"/> </p>
<p>Let’s see a <a id="_idIndexMarker171"/>basic example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob<span id="_idTextAnchor134"/>/main/Chapter03/Chp3-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::endl;
struct collection
{
    int x;
    float y;
};
 
int main()  
{
    collection *item = nullptr;   // pointer declaration 
    item = new collection;   // memory allocation 
    <strong class="bold">item-&gt;x</strong> = 9;        // use -&gt; to access data member x
    <strong class="bold">(*item).y</strong> = 120.77; // alt. notation to access member y
    cout &lt;&lt; <strong class="bold">(*item).x</strong> &lt;&lt; " " &lt;&lt; <strong class="bold">item-&gt;y</strong> &lt;&lt; endl;
    delete item;           // relinquish memory
    return 0;
}</pre>
<p>First, in the aforementioned program, we have declared a user defined type of <strong class="source-inline">collection</strong>, with data members <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>. Next, we declare <strong class="source-inline">item</strong> as a pointer to that type with <strong class="source-inline">collection *item = nullptr;</strong> while initializing the pointer with a <strong class="source-inline">nullptr</strong> for safety. Then, we allocate heap memory for <strong class="source-inline">item</strong> to point to, using operator <strong class="source-inline">new()</strong>. Now, we assign values to the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> members of <strong class="source-inline">item</strong>, respectively, using either the <strong class="source-inline">-&gt;</strong> operator or the <strong class="source-inline">(*).</strong> member access notation. In either case, the notation means to first dereference the pointer and then choose the appropriate data member. It’s pretty straightforward with the <strong class="source-inline">(*).</strong> notation – the parentheses show us that the pointer dereference happens first, and then the choice of the member happens next with the <strong class="source-inline">.</strong> (member selection) operator. The <strong class="source-inline">-&gt;</strong> shorthand notation indicates pointer dereference followed by member selection. After we use <strong class="source-inline">cout</strong> with the insertion operator <strong class="source-inline">&lt;&lt;</strong> to print the appropriate values, we decide that we no longer need the memory associated with <strong class="source-inline">item</strong> and issue a <strong class="source-inline">delete item;</strong> to mark this segment of heap memory for return to the free list.</p>
<p>Let’s take a look at this example’s output:</p>
<p class="source-code">9 120.77</p>
<p>Let us also<a id="_idIndexMarker172"/> take<a id="_idIndexMarker173"/> a look at the memory layout for this example. The memory address (<strong class="source-inline">9000</strong>) used is arbitrary – just an example address that may be generated by <strong class="source-inline">new()</strong>.</p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<img alt="Figure 3.1 – Memory model for Chp3-Ex1.cpp " height="223" src="image/Figure_3.01_B19087.jpg" width="701"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Memory model for Chp3-Ex1.cpp</p>
<p>Now that we know how to allocate and release memory for user defined types, let’s move forward <a id="_idIndexMarker174"/>  and dynamically <a id="_idIndexMarker175"/>allocate arrays of any data type.</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor135"/>Allocating and deallocating arrays at runtime</h1>
<p>Arrays may be<a id="_idIndexMarker176"/> dynamically allocated so that their size may be determined at runtime. Dynamically allocated arrays may be of any type, including user defined types. Determining the size of an array at runtime can be a space-saving advantage and gives us programming flexibility. Rather than allocating a fixed-sized array of the largest possible quantity needed (potentially wasting space), you can instead allocate the necessary size determined by various factors at runtime. You have the additional flexibility to delete and reallocate an array should the need arise to change an array’s size. Arrays of any number of dimensions can be dynamically allocated.</p>
<p>In this section, we will examine how to dynamically allocate arrays of both basic and user defined data types, and of single and multipl<a id="_idTextAnchor136"/>e dimensions. Let’s get started.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor137"/>Dynamically allocating single dimension arrays</h2>
<p>Single-dimension <a id="_idIndexMarker177"/>arrays may be dynamically allocated so that their size may be determined at runtime. We will use a pointer to represent each array and will allocate the required memory with operator <strong class="source-inline">new()</strong>. Once the array is allocated, standard array notation can be used to access each array element.</p>
<p>Let’s take a look at a simple example. We’ll break it into two segments, however, the full program example <a id="_idIndexMarker178"/>can be found using the following link:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::cin;
using std:::endl;
using std::flush;
struct collection
{
    int x;
    float y;
};
 
int main()
{
    int numElements = 0;
    <strong class="bold">int *intArray = nullptr;</strong>    // pointer declarations to
    <strong class="bold">collection *collectionArray = nullptr;</strong> // future arrays
    cout &lt;&lt; "How many elements would you like? " &lt;&lt; flush;
    cin &gt;&gt; numElements;
    <strong class="bold">intArray = new int[numElements];</strong> // alloc. array bodies
    <strong class="bold">collectionArray = new collection[numElements];</strong>
    // continued …</pre>
<p>In the first part of this program, we first declare a user defined type, <strong class="source-inline">collection</strong>, using a struct. Next, we declare an integer variable to hold the number of elements we would like to prompt the user to enter to select as the size for our two arrays. We also declare a pointer to an integer with <strong class="source-inline">int *intArray;</strong>, and a pointer to a <strong class="source-inline">collection</strong> using <strong class="source-inline">collection *collectionArray;</strong>. These declarations state that these pointers may one day each, respectively, point to one or more integers, or one or more objects of type <strong class="source-inline">collection</strong>. These variables, once allocated, will comprise our two arrays.</p>
<p>After prompting the user to enter the number of elements desired using <strong class="source-inline">cin</strong> and the extraction operator <strong class="source-inline">&gt;&gt;</strong>, we dynamically allocate both an array of integers of that size and an array of <strong class="source-inline">collection</strong> of that size. We use operator <strong class="source-inline">new()</strong> in both cases: <strong class="source-inline">intArray = new int[numElements];</strong> and <strong class="source-inline">collectionArray = new collection[numElements];</strong>. The bracketed quantity of <strong class="source-inline">numElements</strong> indicates that the respective chunks of memory requested for each data type will be large enough to accommodate that many sequential elements of the relevant data type. That is, <strong class="source-inline">intArray</strong> will have memory allocated to accommodate <strong class="source-inline">numElements</strong> multiplied by the size needed for an integer. Note that an object’s data type is known because the data type of what will be pointed to is included in the pointer declaration itself. The<a id="_idIndexMarker179"/> appropriate amount of memory for <strong class="source-inline">collectionArray</strong> will be similarly provided for with its respective call to operator <strong class="source-inline">new()</strong>.</p>
<p>Let’s continue by examining the remaining code in this example program:</p>
<pre class="source-code">
    // load each array with values
    for (int i = 0; i &lt; numElements; i++)
    {
        intArray[i] = i; // load each array w values using
        collectionArray[i].x = i;  // array notation []
        collectionArray[i].y = i + .5;
        // alternatively use ptr notation to print values
        cout &lt;&lt; *(intArray + i) &lt;&lt; " ";
        cout &lt;&lt; (*(collectionArray + i)).y &lt;&lt; endl;
    }
    <strong class="bold">delete [] intArray;</strong>     // mark memory for deletion
    <strong class="bold">delete [] collectionArray;</strong>
    return 0;
}</pre>
<p>Next, as we continue this example with the <strong class="source-inline">for</strong> loop, notice that we are using a typical array notation of <strong class="source-inline">[]</strong> to access each element of the two arrays, even though the arrays have been dynamically allocated. Because <strong class="source-inline">collectionArray</strong> is a dynamically allocated array of user defined types, we must also use <strong class="source-inline">.</strong> notation to access individual data members within each array element. Though using standard array notation makes accessing dynamically <a id="_idIndexMarker180"/>arrays quite simple, you may alternatively use pointer notation to access the memory.</p>
<p>Within the loop, notice that we incrementally print both the elements of <strong class="source-inline">intArray</strong> and the <strong class="source-inline">y</strong> member of <strong class="source-inline">collectionArray</strong> using pointer notation. In the expression <strong class="source-inline">*(intArray +i)</strong>, the identifier <strong class="source-inline">intArray</strong> represents the starting address of the array. By adding <strong class="source-inline">i</strong> offsets to this address, you are now at the address of the <strong class="source-inline">i</strong><span class="superscript">th</span> element in this array. By dereferencing this composite address with <strong class="source-inline">*</strong>, you will now go to the proper address to retrieve the relevant integer data, which is then printed using <strong class="source-inline">cout</strong> and the insertion operator <strong class="source-inline">&lt;&lt;</strong>. Likewise, with <strong class="source-inline">(*(collectionArray + i)).y</strong>, we first add <strong class="source-inline">i</strong> to the starting address of <strong class="source-inline">collectionArray</strong>, then using <strong class="source-inline">()</strong>, we dereference that address with <strong class="source-inline">*</strong>. Since this is a user defined type, we must then use <strong class="source-inline">.</strong> to select the appropriate data member <strong class="source-inline">y</strong>.</p>
<p>Lastly, in this example, we demonstrate how to deallocate memory that we no longer need using <strong class="source-inline">delete()</strong>. Though a simple statement of <strong class="source-inline">delete intArray;</strong> would suffice for the dynamically allocated array of standard types, we instead choose <strong class="source-inline">delete [] intArray;</strong> to be consistent with the required manner for deletion for dynamically allocated arrays of user defined types. That is, the more complex statement of <strong class="source-inline">delete [] collectionArray;</strong> is necessary for the proper deletion of an array of user defined types. In all cases, the memory associated with each dynamically allocated array will be returned to the free-list, and can then be reused when heap memory is again allocated with subsequent calls to operator <strong class="source-inline">new()</strong>. However, as we will later see, the <strong class="source-inline">[]</strong> used with <strong class="source-inline">delete()</strong> will allow for a special clean-up function to be applied to each array element of a user defined type before the memory is relinquished. Additionally, consistency is appreciated: if you allocate with <strong class="source-inline">new()</strong>, relinquish the memory with <strong class="source-inline">delete()</strong>; if you allocate with <strong class="source-inline">new []</strong>, then relinquish with <strong class="source-inline">delete []</strong>. This consistent pairing will also keep your program working as intended should any of these aforementioned operators be overloaded (that is, redefined) at a future date by the programmer.</p>
<p>It is crucial to remember not to dereference a pointer variable once its memory has been marked for deletion. Though that address will remain in the pointer variable until you assign the pointer a new address (or null pointer), once memory is marked for deletion, the memory in question might have been already reused by a subsequent call to <strong class="source-inline">new()</strong> elsewhere in the program. This is one of many ways you must be d<a id="_idTextAnchor138"/>iligent when using <a id="_idIndexMarker181"/>pointers in C++. </p>
<p>The output to accompany the full program example is as follows:</p>
<p class="source-code">How many elements would you like? 3</p>
<p class="source-code">0 0.5</p>
<p class="source-code">1 1.5</p>
<p class="source-code">2 2.5</p>
<p>Let’s additionally take a look at the memory layout for this example. The memory addresses (<strong class="source-inline">8500</strong> and <strong class="source-inline">9500</strong>) used are arbitrary – they are example addresses on the heap that may be generated by <strong class="source-inline">new()</strong>.</p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="Figure 3.2 – Memory model for Chp3-Ex2.cpp " height="384" src="image/Figure_3.02_B19087.jpg" width="643"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Memory model for Chp3-Ex2.cpp</p>
<p>Next, let’s<a id="_idIndexMarker182"/> move forward with our discussion on dynamically allocated arrays by allocating arrays of multiple dimensions.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor139"/>Dynamically allocating 2-D arrays – an array of pointers</h2>
<p>Two or more <a id="_idIndexMarker183"/>dimensioned arrays may also be dynamically allocated. For a 2-D array, the column dimension may be dynamically allocated and the row dimension may remain fixed, or both dimensions may be dynamically allocated. Allocating one or more dimensions dynamically allows the programmer to account for run time decisions regarding the array size.</p>
<p>Let’s first consider the case where we have a fixed number of rows and a variable amount of entries in each of those rows (which would be the column dimension). For simplicity, we will assume that the number of entries in each row is the same from row to row, but it need not be. We can model a 2-D array with a fixed number of rows and a run-time-determined amount of entries in each of those rows (the column dimension) using an array of pointers.</p>
<p>Let’s consider an example to illustrate a 2-D array where the column dimension is dynamically allocated:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-wit<span id="_idTextAnchor140"/>h-CPP/blob/main/Chapter03/Chp3-Ex3.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;
using std::flush;
constexpr int NUMROWS = 5; // convention to use uppercase
                    // since value<a id="_idTextAnchor141"/> is known at compile time
int main()
{
    <strong class="bold">float *TwoDimArray[NUMROWS] = { };</strong> // init. to nullptrs
    int numColumns = 0;
    cout &lt;&lt; "Enter number of columns: ";
    cin &gt;&gt; numColumns;
    for (int i = 0; i &lt; NUMROWS; i++)
    {
        // all<a id="_idTextAnchor142"/>ocate column quantity for each row
        <strong class="bold">TwoDimArray[i] = new float [numColumns];</strong>
        // load each column entry with data
        for (int j = 0; j &lt; numColumns; j++)
        {
            TwoDimArray[i][j] = i + j + .05;
            cout &lt;&lt; TwoDimArray[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;  // print newline between rows
    }
 <a id="_idTextAnchor143"/>   for (int i = 0; i &lt; NUMROWS; i++)
        <strong class="bold">delete [] TwoDimArray[i];</strong>  // del col. for each row
    return 0;
}</pre>
<p>In this example, notice that we initially declare an array of pointers to floats using <strong class="source-inline">float *TwoDimArray[NUMROWS];</strong>. For safety, we initialize each of these pointers to <strong class="source-inline">nullptr</strong>. Sometimes, it is helpful to read pointer declarations from right to left; that is, we have an array <strong class="source-inline">NUMROWS</strong> in size that contains pointers to floating-point numbers. More<a id="_idIndexMarker184"/> specifically, we have a fixed-sized array of pointers where each pointer entry can point to one or more contiguous floating-point numbers. The number of entries pointed to in each row comprises the column dimension.</p>
<p>Next, we prompt the user for the number of column entries. Here, we are assuming that each row will have the same number of entries in it (to make the column dimension); however, it is possible that each row could have a different total number of entries. By assuming each row will have a uniform number of entries, we have a straightforward loop using <strong class="source-inline">i</strong> to allocate the column quantity for each row using <strong class="source-inline">TwoDimArray[i] = new float [numColumns];</strong>.</p>
<p>In the nested loop that uses <strong class="source-inline">j</strong> as an index, we simply load values for each column entry of the row specified by <strong class="source-inline">i</strong> in the outer loop. The arbitrary assignment of <strong class="source-inline">TwoDimArray[i][j] = i + j + .05;</strong> loads an interesting value into each element. In the nested loop indexed on <strong class="source-inline">j</strong>, we also print out each column entry for row <strong class="source-inline">i</strong>.</p>
<p>Lastly, the program illustrates how to deallocate the dynamically allocated memory. Since the memory was allocated in a loop over a fixed number of rows – one memory allocation to gather memory to comprise each row’s column entries – the deallocation will work similarly. For each of the rows, we utilize th<a id="_idTextAnchor144"/>e statement: <strong class="source-inline">delete [] TwoDimArray[i];</strong>.</p>
<p>The output for the example is as follows:</p>
<p class="source-code">Enter number of columns: 3</p>
<p class="source-code">0.05 1.05 2.05</p>
<p class="source-code">1.05 2.05 3.05</p>
<p class="source-code">2.05 3.05 4.05</p>
<p class="source-code">3.05 4.05 5.05</p>
<p class="source-code">4.05 5.05 6.05</p>
<p>Next, let’s take a look at the memory layout for this example. As in previous memory diagrams, the memory addresses used are arbitrary – they are example addresses on the heap as may be <a id="_idIndexMarker185"/>generated by <strong class="source-inline">new()</strong>.</p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<img alt="Figure 3.3 – Memory model for Chp3-Ex3.cpp " height="517" src="image/Figure_3.03_B19087.jpg" width="792"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Memory model for Chp3-Ex3.cpp</p>
<p>Now that we have seen how to utilize an array of pointers to model a 2-D array, let’s move onward to see how we can model a 2-D array using a pointer to a pointer so that we may choose both dimensions at runtime.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor145"/>Dynamically allocating 2-D arrays – pointers to pointers</h2>
<p>Dynamically<a id="_idIndexMarker186"/> allocating both the row and column dimensions for an array can add necessary runtime flexibility to a program. To achieve this ultimate flexibility, a 2-D array can be modeled using a pointer to a pointer of the desired data type. Initially, the dimension representing the number of rows will be allocated. Next, for each row, the number of elements in each row will be allocated. As with the last example using an array of pointers, the number of elements in each row (the column entries) need not be uniform in size across rows. However, to accurately model the concept of a 2-D array, it is assumed that the column size will be allocated uniformly from row to row.</p>
<p>Let’s consider an example to illustrate a 2-D array where both the row and column dimensions are dynamically allocated:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex4.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;
using std::flush;
int main()
{
    int numRows = 0, numColumns = 0;
    <strong class="bold">float **TwoDimArray = nullptr;</strong>  // pointer to a pointer
    cout &lt;&lt; "Enter number of<a id="_idTextAnchor146"/> rows: " &lt;&lt; flush;
    cin &gt;&gt; numRows;
    <strong class="bold">TwoDimArray = new float * [numRows];</strong> // alloc. row ptrs
    cout &lt;&lt; "Enter number of Columns: ";
    cin &gt;&gt; numColumns;
    for (int i = 0; i &lt; numRows; i++)
    {
        // allocate column quantity for each row
        <strong class="bold">TwoDimArray[i] = new float [numColumns];</strong>
        // load each column entry with data
        for (int j = 0; j &lt; numColumns; j++)
        {
            TwoDimArray[i][j] = i + j + .05;
            cout &lt;&lt; TwoDimArray[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; end;  // print newline between rows
    }
    for (i = 0; i &lt; numRows; i++)
        <strong class="bold">delete [] TwoDimArray[i];</strong>  // del col. for each row
    <strong class="bold">delete [] TwoDimArray;</strong>  // delete allocated rows
    return 0;
}</pre>
<p>In this example, notice<a id="_idIndexMarker187"/> that we initially declare a pointer to a pointer of type <strong class="source-inline">float</strong> using: <strong class="source-inline">float **TwoDimArray;</strong>. Reading this declaration from right to left, we see that <strong class="source-inline">TwoDimArray</strong> is a pointer to a pointer to <strong class="source-inline">float</strong>. More specifically, we understand that <strong class="source-inline">TwoDimArray</strong> will contain the address of one or more contiguous pointers, each of which may point to one or more contiguous floating-point numbers.</p>
<p>Now, we prompt the user for the number of row entries. We follow this input with the allocation to a set of float pointers, <strong class="source-inline">TwoDimArray = new float * [numRows];</strong>. This allocation creates a <strong class="source-inline">numRows</strong> quantity of contiguous <strong class="source-inline">float</strong> pointers. </p>
<p>Just as in the previous example, we prompt the user for how many columns in each row we would like to have. Just as before, in the outer loop indexed on <strong class="source-inline">i</strong>, we allocate the column entries for each row. In the nested loop indexed on <strong class="source-inline">j</strong>, we again assign values to our array entries and print them just as before.</p>
<p>Lastly, the program continues with the memory deallocation. Just as before, the column entries for each row are deallocated within a loop. Additionally, however, we need to deallocate the dynamically allocated number of row entries. We do this with <strong class="source-inline">delete [] TwoDimArray;</strong>.</p>
<p>The output for <a id="_idIndexMarker188"/>this program is slightly more flexible, as we can enter at runtime the number of both the desired rows and columns:</p>
<p class="source-code">Enter number of rows: 3</p>
<p class="source-code">Enter number of columns: 4</p>
<p class="source-code">0.05 1.05 2.05 3.05</p>
<p class="source-code">1.05 2.05 3.05 4.05</p>
<p class="source-code">2.05 3.05 4.05 5.05</p>
<p>Let’s again take a look at the memory model for this program. As a reminder, just as in previous memory diagrams, the memory addresses used are arbitrary – they are example addresses on the heap as may be generated by <strong class="source-inline">new()</strong>.</p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<img alt="Figure 3.4 – Memory model for Chp3-Ex4.cpp " height="367" src="image/Figure_3.04_B19087.jpg" width="874"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Memory model for Chp3-Ex4.cpp</p>
<p>Now that we have seen how to utilize pointers to pointers to model a 2-D array, let’s move onward to see how we may model arrays of any number of dimensions using pointers to pointers <a id="_idIndexMarker189"/>to pointers, and so on. In C++, you can model any dimensionality of a dynamically allocated array, so long as you can imagine it!</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor147"/>Dynamically allocating N-D arrays – pointers to pointers to pointers</h2>
<p>In C++, you<a id="_idIndexMarker190"/> can model any dimensionality of a dynamically allocated array. You need only to be able to imagine it, declare the appropriate levels of pointers, and make the required levels of memory allocation (and eventual deallocation).</p>
<p>Let’s take a look at the pattern you will need to follow:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex5.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main<span id="_idTextAnchor148"/>/Chapter03/Chp3-Ex5.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;
using std::flush;
int main()
{
    int dim1 = 0, dim2 = 0, dim3 = 0;
    <strong class="bold">int ***ThreeDimArray = nu<a id="_idTextAnchor149"/>llptr;</strong> // 3D dyn. alloc. array
    cout &lt;&lt; "Enter dim 1, dim 2, d<a id="_idTextAnchor150"/>im 3: ";
    cin &gt;&gt; dim1 &gt;&gt; dim2 &gt;&gt; dim3;
    <strong class="bold">ThreeDimArray = new int ** [dim1];</strong> // allocate dim 1
    for (int i = 0; i &lt; dim1; i++)
    {
        <strong class="bold">ThreeDimArray[i] = new int * [dim2];</strong> // alloc dim 2
        for (int j = 0; j &lt; dim2; j++)
        {
            // allocate dim 3
            <strong class="bold">ThreeDimArray[i][j] = new int [dim3];</strong>
            for (int k = 0; k &lt; dim3; k++)
            {
               ThreeDimArray[i][j][k] = i + j + k; 
               cout &lt;&lt; ThreeDimArray[i][j][k] &lt;&lt; " ";
            }
            cout &lt;&lt; endl;  // print '\n' between dimensions
        }
        cout &lt;&lt; end;  // print '\n' between dimensions
    }
    for (int i = 0; i &lt; dim1; i++)
    {
        for (int j = 0; j &lt; dim2; j++)
           <strong class="bold">delete [] ThreeDimArray[i][j];</strong> // release dim 3
        <strong class="bold">delete [] ThreeDimArray[i];</strong>  // release dim 2
    }
    <strong class="bold">delete [] ThreeDimArray;</strong>   // release dim 1
    return 0;
}</pre>
<p>In this example, notice<a id="_idIndexMarker191"/> that we use three levels of indirection to specify the variable to represent the 3-D array <strong class="source-inline">int ***ThreeDimArray;</strong>. We subsequently allocate the required memory for each level of indirection. The first allocation is <strong class="source-inline">ThreeDimArray = new int ** [dim1];</strong>, which allocates dimension 1’s set of pointers to pointers. Next, in a loop iterating over <strong class="source-inline">i</strong>, and for each element in dimension 1, we allocate <strong class="source-inline">ThreeDimArray[i] = new int * [dim2];</strong> to allocate the pointers to integers for the second dimension of the array. And in a nested loop iterating over <strong class="source-inline">j</strong>, and for each element in dimension 2, we allocate <strong class="source-inline">ThreeDimArray[i][j] = new int [dim3];</strong> to allocate the integers themselves in a quantity specified by <strong class="source-inline">dim3</strong>.</p>
<p>As in the last two examples, we initialize the array elements in the inner loops and print their values. At this point, you will undoubtedly notice the similarities between this program and its predecessor. A pattern for the allocation is emerging.</p>
<p>Lastly, we will deallocate the three levels of memory in a manner similar – yet in reverse – to the levels of allocation. We use a nested loop iterating over <strong class="source-inline">j</strong> to release the memory of the innermost level, followed by the memory release in the outer loop that iterates over <strong class="source-inline">i</strong>. Finally, we relinquish the memory for the initial dimension with a simple call to <strong class="source-inline">delete [] ThreeDimArray;</strong>.</p>
<p>The output for this example is as follows:</p>
<p class="source-code">Enter dim1, dim2, dim3: 2 4 3</p>
<p class="source-code">0 1 2</p>
<p class="source-code">1 2 3</p>
<p class="source-code">2 3 4</p>
<p class="source-code">3 4 5</p>
<p class="source-code">1 2 3</p>
<p class="source-code">2 3 4</p>
<p class="source-code">3 4 5</p>
<p class="source-code">4 5 6</p>
<p>Now that we have seen how to model a 3-D array using pointers to pointers to pointers, a pattern has emerged to show us how to declare the required level and number of pointers to model an N-D array. We can also see the pattern for the necessary allocations. Multidimensional arrays can become quite large, especially if you were forced to model them with the largest potentially necessary fixed-sized array. The beauty of modeling with pointers to pointers (to pointers, and so on) for each level of a necessary multi-dimensional array is that you can allocate exactly a size that may be determined at runtime. To make usage easy, array notation using <strong class="source-inline">[]</strong> can be used as an alternative to pointer <a id="_idIndexMarker192"/>notation to access the elements in the dynamically allocated array. C++ has a lot of flexibility stemming from pointers. Dynamically allocated arrays demonstrate one such flexibility.</p>
<p>Let’s now move forward with our understanding of po<a id="_idTextAnchor151"/>inters and consider their usage in functions.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor152"/>Using pointers with functions</h1>
<p>Functions <a id="_idIndexMarker193"/>in C++ will<a id="_idIndexMarker194"/> undoubtedly take arguments. We have seen many examples in the previous chapters illustrating function prototypes and function definitions. Now, let’s augment our understanding of functions by passing pointers as arguments to functions, and using pointers as return values from a function.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor153"/>Passing pointers as arguments to functions</h2>
<p>Arguments<a id="_idIndexMarker195"/> passed<a id="_idIndexMarker196"/> from actual to formal parameters in a function call are by default copied on the stack. In order to modify the contents of a variable as an argument to a function, a pointer to that argument must instead be used as a function parameter.</p>
<p>Any time an actual parameter is passed to a function in C++, a copy of something is made and passed on the stack to that function. For example, if an integer is passed as an actual parameter to a function, a copy of that integer is made and then passed on the stack to the function to be received as the formal parameter. Changing the formal parameter in the scope of the function would only change the copy of the data that was passed into the function.</p>
<p>Should we instead require the ability to modify a function’s parameters, it is then necessary that we pass a pointer to the desired data as a parameter to the function. In C++, passing a pointer as an actual parameter copies this address on the stack, and the copy of the address is received as the formal parameter in the function. However, using the copy of the address, we can still go to that address (by dereferencing that pointer) to access the desired data and make changes to the desired data. </p>
<p>To reiterate, something is always copied on the stack when you pass a parameter in C++. If you pass a non-pointer variable, you get a copy of that data passed on the stack to the function. Changes made to that data in the scope of that function are local changes only and do not persist when the function returns. The local copy is simply popped off the stack at the conclusion of the function. However, if you pass a pointer to a function, though the address stored in the pointer variable is still copied on the stack and passed to the function, you can still dereference the copy of the pointer to access the real data at the desired address. </p>
<p>You always need to be one step back from that which you want to modify. If you want to change a standard data type, pass a pointer to that type. If you want to change the value of the pointer itself (the address), you must pass a pointer to that pointer as a parameter to the function. Remember, a copy of something is passed to the function on the stack. You cannot change that copy beyond the scope of the function. Pass the address of that which you want to change – you are still passing a copy of that address, but using it will get you to the real data.</p>
<p>Let’s take a few minutes to understand an example illustrating passing pointers as arguments to functions. Here, we will begin by examining two functions that <a id="_idTextAnchor154"/>contribute to the<a id="_idIndexMarker197"/> following<a id="_idIndexMarker198"/> full program example: </p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex6.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex6.cpp</a></p>
<pre class="source-code">
void TryToAddOne(int arg)
{
   arg++;
}
void AddOne(<strong class="bold">int *arg</strong>)
{
   (*arg)++;
}</pre>
<p>Examining the previous functions, notice that <strong class="source-inline">TryToAddOne()</strong> takes an <strong class="source-inline">int</strong> as a formal parameter, while <strong class="source-inline">AddOne()</strong> takes an <strong class="source-inline">int *</strong> as a formal parameter.</p>
<p>In <strong class="source-inline">TryToAddOne()</strong>, an integer passed to the function is merely a copy of the actual parameter sent to the function. This parameter is referred to as <strong class="source-inline">arg</strong> in the formal parameter list. Incrementing the value of <strong class="source-inline">arg</strong> by one in the body of the function is a local change only within <strong class="source-inline">TryToAddOne()</strong>.<a id="_idTextAnchor155"/> Once the function completes, the formal parameter, <strong class="source-inline">arg</strong>, is popped off the stack and the actual parameter in the call to this function will not have been modified.</p>
<p>However, notice that <strong class="source-inline">AddOne()</strong> takes an <strong class="source-inline">int *</strong> as a formal parameter. The address of the actual integer parameter will be copied on the stack and received as the formal parameter, <strong class="source-inline">arg</strong>. Using the copy of that address, we dereference the pointer <strong class="source-inline">arg</strong> using <strong class="source-inline">*</strong>, then increment the integer value at that address using <strong class="source-inline">++</strong> in the line of code: <strong class="source-inline">(*arg)++;</strong>. When this function completes, the actual parameter will have been modified because we have passed a copy of the pointer to that integer, rather than a copy of the integer itself.</p>
<p>Let’s examine the remainder of this program:</p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::endl;
void TryToAddOne(int); // function prototypes
void AddOne(<strong class="bold">int *</strong>);
int main()
{
   int x = 10, *y = nullptr;
   y = new int;    // allocate y's memory
   *y = 15;  <a id="_idTextAnchor156"/>      // dereference y to assign a value
   cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; " and *y: " &lt;&lt; *y &lt;&lt; endl;
   TryToAddOne(x);   // unsuccessful, call by value
   TryToAddOne(*y);  // still unsuccessful
   cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; " and *y: " &lt;&lt; *y &lt;&lt; endl;
   AddOne(<strong class="bold">&amp;x</strong>);   // successful, passing an address 
   AddOne(<strong class="bold">y</strong>);    // also successful
   cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; " and *y: " &lt;&lt; *y &lt;&lt; endl;
   delete y;     // relinquish heap memory
   return 0;
}</pre>
<p>Notice the function prototypes at the top of this program segment. They will match the function definitions in the previous segment of code. Now, in the <strong class="source-inline">main()</strong> function, we declare and initialize <strong class="source-inline">int x = 10;</strong> and declare a pointer: <strong class="source-inline">int *y;</strong>. We allocate the memory for <strong class="source-inline">y</strong> using <strong class="source-inline">new()</strong> and then assign a value by dereferencing the pointer with <strong class="source-inline">*y = 15;</strong>. We print out the respective values of <strong class="source-inline">x</strong> and <strong class="source-inline">*y</strong> as a baseline.</p>
<p>Next, we call <strong class="source-inline">TryToAddOne(x);</strong> followed by <strong class="source-inline">TryToAddOne(*y);</strong>. In both cases, we are passing integers as actual parameters to the function. Variable <strong class="source-inline">x</strong> is declared to be an integer, and <strong class="source-inline">*y</strong> refers to the integer pointed to by <strong class="source-inline">y</strong>. Neither of these function calls will result in the actual parameter being changed, which we can verify when their respective values are next printed using <strong class="source-inline">cout</strong> and the insertion operator <strong class="source-inline">&lt;&lt;</strong>.</p>
<p>Finally, we call <strong class="source-inline">AddOne(&amp;x);</strong> followed by <strong class="source-inline">AddOne(y);</strong>. In both cases, we are passing a copy of an address as the actual parameter to the function. Of course, <strong class="source-inline">&amp;x</strong> is the address of variable <strong class="source-inline">x</strong>, so this works. Likewise, <strong class="source-inline">y</strong> itself is an address – it is declared as a pointer variable. Recall that inside the <strong class="source-inline">AddOne()</strong> function, the formal parameter is first dereferenced and then incremented in the body of the function: <strong class="source-inline">(*arg)++;</strong>. We can use a copy of a pointer to access actual data.</p>
<p>Here is<a id="_idIndexMarker199"/> the <a id="_idIndexMarker200"/>output for the full program example:</p>
<p class="source-code">x: 10 and *y: 15</p>
<p class="source-code">x: 10 and *y: 15</p>
<p class="source-code">x: 11 and *y: 16</p>
<p>Next, let us add to our discussion of using pointers with functions by using pointers as return values from functions.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor157"/>Using pointers as return values from functions</h2>
<p>Functions <a id="_idIndexMarker201"/>may return pointers to data via their <a id="_idIndexMarker202"/>return statements. When returning a pointer via the return statement of a function, be sure that the memory that is pointed to will persist after the function call is completed. Do not return a pointer to stack memory that is local to the function. That is, do not return a pointer to local variables defined on the stack within the function. However, returning a pointer to memory allocated using <strong class="source-inline">new()</strong> within the function is acceptable. As the allocated memory will be on the heap, it will exist past the function call.</p>
<p>Let’s see an example to illustrate these concepts:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex7.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex7.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using std::cin;
using std::cout;
using std::endl;
using std::flush;
using std::setw;
constexpr int MAX = 20;
<strong class="bold">[[nodiscard]] char *createName();</strong>  // function prototype
int main()    
{
   ch<a id="_idTextAnchor158"/>ar *name = nullptr;   // pointer declaration and init.
   <strong class="bold">name = createName();</strong>    // function will allocate memory
   cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; endl;
   delete [] name;  // del alloc. memory (in a diff. scope
   return 0;   // than allocated); this can be error prone!
}
<strong class="bold">[[nodiscard]] char *createName()</strong>
{
   char *temp = new char[MAX];
   cout &lt;&lt; "Enter name: " &lt;&lt; flush;
   cin &gt;&gt; setw(MAX) &gt;&gt; temp; // ensure no overflow of temp
   <strong class="bold">return temp;</strong>
}</pre>
<p>In this example, <strong class="source-inline">constexpr int MAX = 20;</strong> is defined and then <strong class="source-inline">char *createName();</strong> is prototyped, indicating that this function takes no arguments, yet returns a pointer to one or more characters.</p>
<p>In the <strong class="source-inline">main()</strong> function, a local variable: <strong class="source-inline">char *name;</strong> is defined, but not initialized. Next, <strong class="source-inline">createName()</strong> is called and its return value is used to assign a value to <strong class="source-inline">name</strong>. Notice that both <strong class="source-inline">name</strong> and the function’s return type are of type <strong class="source-inline">char *</strong>.</p>
<p>In the call to <strong class="source-inline">createName()</strong>, notice that a local variable <strong class="source-inline">char *temp = new char[MAX];</strong> is both defined and allocated to point to a fixed amount of memory on the heap using operator <strong class="source-inline">new()</strong>. The user is then prompted to enter a name and that name is stored in <strong class="source-inline">temp</strong>. The local variable <strong class="source-inline">temp</strong> is then returned from <strong class="source-inline">createName()</strong>.</p>
<p>In <strong class="source-inline">createName()</strong>, it is<a id="_idIndexMarker203"/> important that the <a id="_idIndexMarker204"/>memory for <strong class="source-inline">temp</strong> be comprised of heap memory so that it will persist beyond the scope of this function. Here, a copy of the address stored in <strong class="source-inline">temp</strong> will be copied onto the stack in the area reserved for a return value from the function. Fortunately, that address refers to heap memory. The assignment <strong class="source-inline">name = createName();</strong> in <strong class="source-inline">main()</strong> will capture this address and copy it to be stored into the <strong class="source-inline">name</strong> variable, which is local to <strong class="source-inline">main()</strong>. Since the memory allocated in <strong class="source-inline">createName()</strong> is on the heap, this memory will exist once the function completes.</p>
<p>Just as important to note, had <strong class="source-inline">temp</strong> been defined as <strong class="source-inline">char temp[MAX];</strong> in <strong class="source-inline">createName()</strong>, the memory comprising <strong class="source-inline">temp</strong> would have existed on the stack and would have been local to <strong class="source-inline">createName()</strong>. Once <strong class="source-inline">createName()</strong> returns to <strong class="source-inline">main()</strong>, the memory for this variable would have been popped off the stack and been unavailable for proper use – even if that address had been captured in a pointer variable within <strong class="source-inline">main()</strong>. This is another potential pointer trap in C++. When returning a pointer from a function, always ensure that the memory to which the pointer points exists beyond the extent of the function.</p>
<p>The output for this example is:</p>
<p class="source-code">Enter name: Gabrielle</p>
<p class="source-code">Name: Gabrielle</p>
<p>Now that we understand how pointers can be used within parameters to functions and as return <a id="_idIndexMarker205"/>values <a id="_idIndexMarker206"/>from function<a id="_idTextAnchor159"/>s, let’s move forward by examining further pointer nuances.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor160"/>Using the const qualifier with pointers</h1>
<p>The <strong class="source-inline">const</strong> qualifier<a id="_idIndexMarker207"/> can <a id="_idIndexMarker208"/>be used to qualify pointers in several different ways. The keyword <strong class="source-inline">const</strong> can be applied to the data pointed to, to the pointer itself, or both. By using the <strong class="source-inline">const</strong> qualifier in these ways, C++ offers means to protect values in a program that may be meant to be initialized but never again modified. Let’s examine each of these various scenarios. We will also be combining <strong class="source-inline">const</strong> qualified pointers with return values from functions to understand which of these various scenarios are reasonable to implement. </p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor161"/>Using pointers to constant objects</h2>
<p>A pointer <a id="_idIndexMarker209"/>to a constant<a id="_idIndexMarker210"/> object may be specified so that the object that is pointed to may not be directly modified. A dereferenced pointer to this object may not be used as an l-value in any assignment. An <strong class="bold">l-value</strong> means a value that can be modified, and that occurs on the left-hand side of an assignment<a id="_idTextAnchor162"/>.</p>
<p>Let’s introduce a simple example to understand the situation:</p>
<pre class="source-code">
// const qualified<a id="_idTextAnchor163"/> str; the data pointed to will be const
<strong class="bold">const char *constData = "constant"; </strong>
<strong class="bold">const char *moreConstData = nullptr;  </strong>
// regular strings, defined. One is loaded using strcpy()  
char *regularString = nullptr;
char *anotherRegularString = new char[8];  // sized to fit 
                                           // this string 
strcpy(anotherRegularString, "regular");
// Trying to modify data marked as const will not work
<strong class="bold">// strcpy(constData, "Can I do this? ");  // NO! </strong>
// Trying to circumvent by having a char * point to
// a const char * also will not work
<strong class="bold">// regularString = constData; // NO! </strong>
// But we can treat a char * more strictly by assigning to 
// const char *. It will be const from that viewpoint only
<strong class="bold">moreConstData = anotherRegularString;</strong> // Ye<a id="_idTextAnchor164"/>s - can do this!</pre>
<p>Here, we’ve <a id="_idIndexMarker211"/>introduced <strong class="source-inline">const char *constData = "constant";</strong>. The <a id="_idIndexMarker212"/>pointer points to data, which is initialized, and which may never again be modified through this identifier. For example, should we try to alter this value using a <strong class="source-inline">strcpy</strong>, where <strong class="source-inline">constData</strong> is the destination string, the compiler will issue an error.</p>
<p>Also, trying to circumvent the situation by trying to store <strong class="source-inline">constData</strong> into a pointer of the same (but not <strong class="source-inline">const</strong>) type, will generate a compiler error, such as in the line of code <strong class="source-inline">regularString = constData;</strong>. Of course, in C++, you can do anything if you try hard enough, so an explicit typecast here will work, but is purposely not shown. An explicit typecast will still generate a compiler warning to allow you to question whether this is truly something you intend to do. When we move forward with OO concepts, we will introduce ways to further protect data so that this type of circumvention can be eliminated.</p>
<p>On the last line of the previous code, notice that we store the address of a regular string into <strong class="source-inline">const char *moreConstData</strong>. This is allowed – you can always treat something with more respect than it was defined to have (just not less). This means that when using the identifier <strong class="source-inline">moreConstData</strong>, this string may not be modified. However, using its own identifier, which is defined as <strong class="source-inline">char *anotherRegularString;</strong>, this string may be changed. This seems inconsistent, but it is not. The <strong class="source-inline">const char *</strong> variable chose to point to a <strong class="source-inline">char *</strong> – elevating its protection for a particular situation. If the <strong class="source-inline">const char *</strong> truly wanted to point to an immutable object, it would have chosen<a id="_idIndexMarker213"/> to<a id="_idIndexMarker214"/> instead point to anothe<a id="_idTextAnchor165"/>r <strong class="source-inline">const char *</strong> variable.</p>
<p>Next, let’s see a variation on this theme.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor166"/>Using constant pointers to objects</h2>
<p>A constant pointer<a id="_idIndexMarker215"/> to an object is a pointer that is initialized to point to a specific object. This pointer may never be assigned to point to another object. This pointer itself may not be<a id="_idTextAnchor167"/> used as an l-value in an assignment.</p>
<p>Let’s review a simple example:</p>
<pre class="source-code">
// Define, allocate, load simple strings using strcpy()
char *regularString = new char[36]; // sized for str below
strcpy(regularString, "I am a modifiable string");
char *anotherRegularString = new char[21]; // sized for
                                           // string below
strcpy(anotherRegularString, "I am also modifiable");
// Define a const pointer to a string; must be initialized
<strong class="bold">char *const constPtrString = regularString; // Ok</strong>
// You may not modify a const pointer to point elsewhere
<strong class="bold">// constPtrString = anotherRegularString;  // No! </strong>
// But you may change the data which you point to
<strong class="bold">strcpy(constPtrString, "I can change the value"); // Yes</strong></pre>
<p>In this example, two regular <strong class="source-inline">char *</strong> variables (<strong class="source-inline">regularString</strong> and <strong class="source-inline">anotherRegularString</strong>) are defined and loaded with string literals. Next, <strong class="source-inline">char *const constPtrString = regularString;</strong> is defined and initialized to point to a modifiable string. Because the <strong class="source-inline">const</strong> qualification is on the pointer itself and not the data pointed to, the pointer itself must be initialized with a value at declaration. Notice that the line of code: <strong class="source-inline">constPtrString = anotherRegularString;</strong> would generate a compiler error because a <strong class="source-inline">const</strong> pointer cannot be on the left hand of an assignment. However, because the <strong class="source-inline">const</strong> qualification is not applicable to the data <a id="_idIndexMarker216"/>pointed to, a <strong class="source-inline">strcpy</strong> may be used to modify the value of the data as is seen in <strong class="source-inline">strcpy(constPtrString, "I can change the value");</strong>.</p>
<p>Next, let us combine the <strong class="source-inline">const</strong> qualifier on both the pointer and the data which is pointed to.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor168"/>Using constant pointers to constant objects</h2>
<p>A constant<a id="_idIndexMarker217"/> pointer to a constant object is a pointer that is established to point to a specific object and to unmodifiable data. The pointer itself must be initialized to a given object, which is (hopefully) initialized with appropriate values. Neither the object nor the pointer <a id="_idTextAnchor169"/>may be modified or used as l-values in assignments.</p>
<p>Her<a id="_idTextAnchor170"/>e is an example:</p>
<pre class="source-code">
// Define two regular strings and load using strcpy()
char *regularString = new char[36]; // sized for str below
strcpy(regularString, "I am a modifiable string");
char *anotherRegularString = new char[21]; // sized for
                                           // string below
strcpy(anotherRegularString, "I am also mod<a id="_idTextAnchor171"/>ifiable");
// Define const ptr to a const object; must be initialized
<strong class="bold">const char *const constStringandPtr = regularString; // Ok</strong> 
// Trying to change the pointer or the data is illegal
<strong class="bold">constStringandPtr = anotherRegularString; // No! Can't </strong>
<strong class="bold">               <a id="_idTextAnchor172"/>                           // modify address</strong>
<strong class="bold">strcpy(constStringandPtr, "Nope"); // No! Can't modify data</strong></pre>
<p>In this example, two regular <strong class="source-inline">char *</strong> variables are declared, <strong class="source-inline">regularString</strong> and <strong class="source-inline">anotherRegularString</strong>. Each is initialized with a string literal. Next, we introduce <strong class="source-inline">const char *const constStringandPtr = regularString;</strong>, which is a <strong class="source-inline">const</strong> qualified pointer to data that is also treated as <strong class="source-inline">const</strong>. Notice that this variable must be initialized because the pointer itself cannot be an l-value in a later assignment. You will also want to ensure that this pointer is initialized with a meaningful value, as the data that is pointed to also cannot be changed (as illustrated by the <strong class="source-inline">strcpy</strong> statement, which would generate a compiler error). Combining <strong class="source-inline">const</strong> on the pointer as well as the data pointed to is<a id="_idTextAnchor173"/> a strict way to safeguard data.</p>
<p class="callout-heading">Tip – deciphering pointer declarations</p>
<p class="callout">To read complex pointer declarations, it often helps to read the declaration backward – from right to left. For example, the pointer declaration <strong class="source-inline">const char *p1 = "hi!";</strong> would be interpreted as <strong class="source-inline">p1</strong> is a pointer to (one or more) characters that are constant. The declaration <strong class="source-inline">const char *const p2 = p1;</strong> would be read as <strong class="source-inline">p2</strong> is a constant pointer to (one or more) characters that are constant. </p>
<p>Finally, let <a id="_idIndexMarker218"/>us move forward to understand the implications of <strong class="source-inline">const</strong> qualifying pointers, which serve as function parameters or as return values from functions.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor174"/>Using pointers to constant objects as function arguments and as return types from functions</h2>
<p>Copying<a id="_idIndexMarker219"/> arguments <a id="_idIndexMarker220"/>on the stack that are user defined types can be time-consuming. Passing a pointer as a function argument is speedier, yet permits the dereferenced object to possibly be modified in the scope of the function. Passing a pointer to a constant object as a function argument provides both speed and safety for the argument in question. The dereferenced pointer simply may not be an l-value in the scope of the function in question. The same principle holds true for the return value from a function. Constant qualifying the data pointed to insists that the caller of the function must also store the return value in a pointer to a constant object, ensuring the object’s long-term immutability.</p>
<p>Let’s take a look at an example to examine these ideas:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex8.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex8.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstring&gt;  // we'll generally prefer std::string, 
        // however, let's understand<a id="_idTextAnchor175"/> ptr concept shown here
using std::cout;
using std::endl;
char suffix = 'A';
<strong class="bold">const char *GenId(const char *);</strong>  // function prototype
int main()    
{
    const char *newId1, *newId2;   // pointer declarations
    newId1 = <strong class="bold">GenId("Group");</strong>  // func. will allocate memory
    newId2 = <strong class="bold">GenId("Group");</strong>  
    cout &lt;&lt; "New ids: " &lt;&lt; newId1 &lt;&lt; " " &lt;&lt; newId2 &lt;&lt; endl;
    delete [] newId1;  // delete allocated memory  
    delete [] newId2;  // caution: deleting in different 
                       // scope than allocation can 
                       // lead to potential errors
    return 0;
}
<strong class="bold">const char *GenId(const char *base</strong>)
{
    char *temp = new char[strlen(base) + 2]; 
    strcpy(temp, base);  // use base to initialize string
    temp[strlen(base)] = suffix++; // Append suffix to base
    temp[strlen(base) + 1] = '\0'; // Add null character
    <strong class="bold">return temp;</strong> // temp will be upcast to a const char *
                 // to be treated more restrictively than 
                 // it was defined
}  </pre>
<p>In this<a id="_idIndexMarker221"/> example, we<a id="_idIndexMarker222"/> begin with a global variable to store an initial suffix, <strong class="source-inline">char *suffix = 'A';</strong>, and the prototype for the function: <strong class="source-inline">const char *GenId(const char *base);</strong>. In <strong class="source-inline">main()</strong>, we declare, but do not initialize, <strong class="source-inline">const char* newId1, *newId2;</strong>, which will eventually hold the IDs generated by <strong class="source-inline">GenId()</strong>.</p>
<p>Next, we call <strong class="source-inline">GenId()</strong> twice, passing a string literal <strong class="source-inline">"Group"</strong> to this function as the actual parameter. This parameter is received as a formal parameter: <strong class="source-inline">const char *base</strong>. The return value of this function will be used to assign values to <strong class="source-inline">newId1</strong> a<a id="_idTextAnchor176"/>nd <strong class="source-inline">newId2</strong>, respectively.</p>
<p>Looking more closely, we see that the call to <strong class="source-inline">GenId("Group")</strong> passes the strin<a id="_idTextAnchor177"/>g literal <strong class="source-inline">"Group"</strong> as the actual parameter, which is received as <strong class="source-inline">const char *base</strong> in the formal parameter list of the function definition. This means that when using the identifier <strong class="source-inline">base</strong>, this string may not be modified.</p>
<p>Next, within <strong class="source-inline">GenId()</strong>, we declare local pointer variable <strong class="source-inline">temp</strong> on the stack and allocate enough heap memory for <strong class="source-inline">temp</strong> to point to, to accommodate the string pointed to by <strong class="source-inline">base</strong> plus an extra character for the suffix to be added, plus one for the null character to terminate the new string. Note that <strong class="source-inline">strlen()</strong> counts the number of characters in a string, excluding the null character. Now, by using <strong class="source-inline">strcpy()</strong>, <strong class="source-inline">base</strong> is copied into <strong class="source-inline">temp</strong>. Then, using the assignment <strong class="source-inline">temp[strlen(base)] = suffix++;</strong>, the letter stored in <strong class="source-inline">suffix</strong> is added to the string pointed to by <strong class="source-inline">temp</strong> (and <strong class="source-inline">suffix</strong> is incremented to the next letter for the next time we call this function). Remember<a id="_idIndexMarker223"/> that <a id="_idIndexMarker224"/>arrays are zero-based in C++ when adding characters to the end of a given string. For example, if <strong class="source-inline">"Group"</strong> comprises five characters in array <strong class="source-inline">temp</strong>’s positions 0 through 4, then the next character (from <strong class="source-inline">suffix</strong>) would be added at position 5 in <strong class="source-inline">temp</strong> (overwriting the current null character). In the next line of code, the null character is re-added to the end of the new string pointed to by <strong class="source-inline">temp</strong>, as all strings need to be null terminated. Note that, whereas <strong class="source-inline">strcpy()</strong> will automatically null-terminate a string, once you resort to a single-character replacement, such as by adding the suffix to the string, you then need to re-add the null character to the new overall string yourself.</p>
<p>Lastly, in this function, <strong class="source-inline">temp</strong> is returned. Notice that though <strong class="source-inline">temp</strong> is declared as a <strong class="source-inline">char *</strong>, it is returned as a <strong class="source-inline">const char *</strong>. This means that the string will be treated in a more restrictive fashion upon its return to <strong class="source-inline">main()</strong> than it was treated in the body of the function. In essence, it has been upcast to a <strong class="source-inline">const char *</strong>. The implication is that since the return value of this function is a <strong class="source-inline">const char *</strong>, only a pointer of type <strong class="source-inline">const char *</strong> can capture the return value of this function. This is required so that the string cannot be treated in a less restrictive fashion than intended by the creator of function <strong class="source-inline">GenId()</strong>. Had <strong class="source-inline">newId1</strong> and <strong class="source-inline">newId2</strong> been declared of type <strong class="source-inline">char *</strong> rather than <strong class="source-inline">const char *</strong>, they would not have been allowed to serve as l-values to capture the return value of <strong class="source-inline">GenId()</strong>.</p>
<p>At the end of <strong class="source-inline">main()</strong>, we delete the memory associated with <strong class="source-inline">newId1</strong> and <strong class="source-inline">newId2</strong>. Notice that the memory for these pointer variables was allocated and released in different scopes within the program. The programmer must always be diligent to keep track of memory allocation and release in C++. Forgetting to deallocate memory can lead to memory leakage within an application.</p>
<p>Here is the output to accompany our example:</p>
<p class="source-code">New ids: GroupA GroupB</p>
<p>Now<a id="_idIndexMarker225"/> that <a id="_idIndexMarker226"/>we have an understanding of how and why to <strong class="source-inline">const</strong> qualify pointers, let’s take a look at h<a id="_idTextAnchor178"/>ow and why we might choose a generic pointer type by considering void pointers.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor179"/>Using pointers to objects of unspecified types</h1>
<p>Sometimes, programmers <a id="_idIndexMarker227"/>ask why they cannot simply have a generic pointer. That is, why must we always declare the type of data to which the pointer will eventually point, such as <strong class="source-inline">int *ptr;</strong>? C++ certainly does allow us to create pointers without associated types, but C++ then requires the programmer to keep track of things that would normally be done on their behalf. Nonetheless, we will see why void pointers are useful and what the <a id="_idTextAnchor180"/>programmer must undertake when using more generic void pointers in this section.</p>
<p>It is important to note that void pointers require careful handling, and their misuse can be extremely dangerous. We will, much later in the book, see a safer alternative to genericize types (including pointers) in <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>. Nonetheless, there are careful encapsulated techniques that use an underlying implementation of a <strong class="source-inline">void *</strong> for efficiency, paired with a safe wrapper of a template. We will see that templates are expanded for every type needed and can sometimes lead to <em class="italic">template bloat</em>. In these cases, a safe pairing of a template with an underlying <strong class="source-inline">void *</strong> implementation gives us both safety and efficiency.</p>
<p>To understand a void pointer, let us first consider why a type is typically associated with a pointer variable. Typically, declaring the type with the pointer gives C++ information about how to conduct pointer arithmetic or index into a dynamically allocated array of that pointer type. That is, if we have allocated <strong class="source-inline">int *ptr = new int [10];</strong>, we have 10 consecutive integers. Using either the array notation of <strong class="source-inline">ptr[3] = 5;</strong> or the pointer arithmetic of <strong class="source-inline">*(ptr + 3) = 5;</strong> to access one such element in this dynamically allocated set relies on the size of the data type <strong class="source-inline">int</strong> to internally allow C++ to understand how large each element is and how to move from one such item to the next. The data type also tells C++, once it has arrived at an appropriate memory address, how to interpret the memory. For example, an <strong class="source-inline">int</strong> and a <strong class="source-inline">float</strong> may have the same storage size on a given machine, however, the two’s complement memory layout of an <strong class="source-inline">int</strong> versus the mantissa, exponent layout of a <strong class="source-inline">float</strong> is quite different. C++’s knowledge of how to interpret the given memory is crucial, and the data type of the pointer does just that.</p>
<p>However, the need still exists to have a more generic pointer. For example, you may want a pointer that might point to an integer in one situation, yet to a set of user defined types in another situation. Using a <strong class="source-inline">void *</strong> allows just this to happen. But what about type? What happens when you dereference a void pointer? If C++ does not know how many bytes to go from one element in a set to another, how can it index into a dynamically allocated array of void pointers? How will it interpret the bytes once at an address? What is the type?</p>
<p>The answer is that you, the programmer, must personally remember what you are pointing to at all times. Without the type associated with the pointer, the compiler cannot do this for you. And when it is time to dereference the void pointer, you will be in charge of <a id="_idIndexMarker228"/>correctly remembering the ultimate type involved and performing the appropriate type cast on that pointer.</p>
<p>Let’s take a look at the mechanics and logistics of what is involved.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor181"/>Creating void pointers</h2>
<p>Pointers to <a id="_idIndexMarker229"/>objects of unspecified types may be specified by using <strong class="source-inline">void *</strong>. The void pointer may then point to an object of any type. Explicit casting must be used in order to dereference actual memory pointed to by the <strong class="source-inline">void *</strong>. Explicit casting must also be used in C++ to assign memory pointed to by a <strong class="source-inline">void *</strong> to a pointer variable of a known type. It is the programmer’s responsibility to ensure that the dereferenced data types are the same before making the assignment. Should the programmer be incorrect, there will be an elusive pointer mistake to find elsewhere in the code.</p>
<p>Here is an example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex9.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex9.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::endl;
int main()
{
    <strong class="bold">void *unspecified = nullptr;</strong> // may point to any 
                                 // data type
    int *x = nullptr;
    unspecified = new int; // void ptr now points to an int
    // void * must be cast to int * before dereferencing
    *(<strong class="bold">static_cast&lt;int *&gt;</strong>(unspecified)) = 89;
    // let x point to the memory that unspecified points to
    x = <strong class="bold">static_cast&lt;int *&gt;</strong>(unspecified);
    cout &lt;&lt; *x &lt;&lt; " " &lt;&lt; *(<strong class="bold">static_cast&lt;int *&gt;</strong>(unspecified)) 
         &lt;&lt; endl;
    delete <strong class="bold">static_cast&lt;int *&gt;</strong>(unspecified);
    return 0;
}</pre>
<p>In this example, the<a id="_idIndexMarker230"/> declaration <strong class="source-inline">void *unspecified;</strong> creates a pointer that may, one day, point to memory that can be of any data type. The declaration <strong class="source-inline">int *x;</strong> declares a p<a id="_idTextAnchor182"/>ointer that may someday point to one or more consecutive integers.</p>
<p>The assignment <strong class="source-inline">*(static_cast&lt;int *&gt;(unspecified)) = 89;</strong> first uses an explicit typecast to cast <strong class="source-inline">unspecified</strong> to an <strong class="source-inline">(int *)</strong> and then dereferences the <strong class="source-inline">int *</strong> to place the value of <strong class="source-inline">89</strong> in memory. It is important to note that this typecast must be done before <strong class="source-inline">unspecified</strong> may be dereferenced – otherwise, C++ does not understand how to interpret the memory that <strong class="source-inline">unspecified</strong> points to. Also note that if you accidentally typecast <strong class="source-inline">unspecified</strong> to the wrong type, the compiler would let you proceed, as typecasts are seen as a <em class="italic">“just do it”</em> command to the compiler. It is your job, as the programmer, to remember what type of data your <strong class="source-inline">void *</strong> points.</p>
<p>Lastly, we would like <strong class="source-inline">x</strong> to point to where <strong class="source-inline">unspecified</strong> points. Variable <strong class="source-inline">x</strong> is an integer and needs to point to one or more integers. Variable <strong class="source-inline">unspecified</strong> truly points to an integer, but since the data type of unspecified is <strong class="source-inline">void *</strong>, we must use an explicit typecast to make the following assignment work: <strong class="source-inline">x = static_cast&lt;int *&gt;(unspecified) ;</strong>. Also, programmatically, we hope that we are correct and that we have remembered that <strong class="source-inline">unspecified</strong> truly points to an <strong class="source-inline">int</strong>; knowing the correct memory layout is important should the <strong class="source-inline">int *</strong> ever be dereferenced. Otherwise, we have just forced an assignment between pointers of different types, leaving a lurking error in our program.</p>
<p>Here is the output to accompany our program:</p>
<p class="source-code">89 89</p>
<p>There are many creative uses of void pointers in C++. Some techniques use <strong class="source-inline">void *</strong>’s for generic pointer manipulations and pair this inner processing with a thin layer on top to cast the data into a known data type. The thin top layers can be further genericized with the C++ feature of<a id="_idIndexMarker231"/> templates. Using templates, only one version of the explicit type casts is maintained by the programmer, yet many versions are truly made available on your behalf – one per actual concrete data type needed. These ideas encompass advan<a id="_idTextAnchor183"/>ced techniques, but we will see several of them in the chapters ahead, starting with <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor184"/>Looking ahead to smart pointers for safety</h1>
<p>We have seen<a id="_idIndexMarker232"/> many uses of pointers to add flexibility and efficiency to our programs. However, we have also seen that with the power that pointers can provide comes potential havoc! Dereferencing uninitialized pointers can take us to non-existent memory locations that will inevitably crash our programs. Accidentally dereferencing memory that we have marked for deletion is similarly destructive – the memory address may have already been reused by the heap management facility elsewhere in our program. Neglecting to delete dynamically allocated memory when we are done with it will cause memory leaks. Even more challenging is allocating memory in one scope and expecting to remember to delete that memory in another scope. Or, consider what happens when two or more pointers point to the same piece of heap memory. Which pointer is responsible for deleting the memory? This is an issue we will see several times throughout the book with various solutions. These issues are just a few of the potential landmines we may step on when we utilize pointers.</p>
<p>You may ask whether there is another way to have the benefits of dynamically allocated memory, and yet have a safety net to govern its use. Fortunately, the answer is yes. The concept is a <strong class="bold">smart pointer</strong>, and there are several types of smart pointers in C++, including <strong class="source-inline">unique_ptr</strong>, <strong class="source-inline">shared_ptr</strong>, and <strong class="source-inline">weak_ptr</strong>. The premise of a smart pointer is that it is a class to safely wrap the usage of a raw pointer, minimally handling the proper deallocation<a id="_idIndexMarker233"/> of heap memory when the outer smart pointer goes out of scope.</p>
<p>However, to best understand smart pointers, we will need to understand <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>, <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>, and <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>. After understanding these core C++ features, smart pointers will be a meaningful option for us to embrace for pointer safety in the new code that we create. Will you still need to understand how to use native pointers in C++? Yes. It is inevitable that you will utilize many class libraries in C++ that heavily use native pointers, so you will need to understand their usage as well. Additionally, you may be integrating with, or maintaining, existing C++ code that is heavily native pointer reliant. You may also look online at many C++ forums or tutorials, and native pointers will inevitably pop up there as well. </p>
<p>The bottom line is that as C++ programmers, we need to understand how to use native C++ pointers, yet also understand their dangers, potential misuse, and pitfalls. Then, once we have mastered classes, operator overloading, and templates, we can add smart pointers to our repertoire and wisely choose to use them in our wholly new code. Yet, we will be prepared for any C++ situation by also understanding native C++ pointers. </p>
<p>With that in mind, we will continue gaining facility with native C++ pointers until we have best laid the groundwork to add these useful smart pointer classes into our repertoire. Then, we will see each <a id="_idIndexMarker234"/>smart pointer type in full detail.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor185"/>Summary</h1>
<p>In this chapter, we have learned many aspects surrounding pointers in C++. We have seen how to allocate memory from the heap using <strong class="source-inline">new()</strong> and how to relinquish that memory to the heap management facility using <strong class="source-inline">delete()</strong>. We have seen examples using both standard and user defined types. We have also understood why we may want to dynamically allocate arrays and have seen how to do so for <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">N</strong> dimensions. We have seen how to release the corresponding memory using <strong class="source-inline">delete[]</strong>. We have reviewed functions by adding pointers as parameters to functions and as return values from functions. We have also learned how to <strong class="source-inline">const</strong> qualify pointers as well as the data to which they point (or both) and why you may want to do so. We have seen one way to genericize pointers by introducing void pointers. Lastly, we have looked ahead to the concept of smart pointers.</p>
<p>All of the skills using pointers from this chapter will be used freely in the upcoming chapters. C++ expects programmers to have great facility using pointers. Pointers allow the language great freedom and efficiency to utilize a vast number of data structures and to employ creative programming solutions. However, pointers can provide a massive way to introduce errors into a program with memory leakage, returning pointers to memory that no longer exists, dereferencing pointers that have been deleted, and so on. Not to worry; we will utilize many examples going forward using pointers so that you will be able to manipulate pointers with great facility. Additionally, we will later add specific types of smart pointers to our upcoming programming repertoire to allow us to use add pointer safety when constructing code from scratch. </p>
<p>Most importantly, you are now ready to move forward to <a href="B19087_04.xhtml#_idTextAnchor188"><em class="italic">Chapter 4</em></a>, <em class="italic">Indirect Addressing – References</em>, in which we will explore indirect addressing using references. Once you have understood both types of indirect addressing – pointers and references – and can manipulate either with ease, we will take on the core object-oriented concepts in this book, starting in <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>.</p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor186"/>Questions</h1>
<ol>
<li>Modify and augme<a id="_idTextAnchor187"/>nt your C++ program from <a href="B19087_02.xhtml#_idTextAnchor072"><em class="italic">Chapter 2</em></a>, <em class="italic">Adding Language Necessities</em>, <em class="italic">Question 2</em>, as follows:<ol><li>Create a function, <strong class="source-inline">ReadData()</strong>, which accepts a pointer to a Student as an argument to allow for <strong class="source-inline">firstName</strong>, <strong class="source-inline">lastName</strong>, and <strong class="source-inline">gpa</strong>, and the <strong class="source-inline">currentCourseEnrolled</strong> to be entered from the keyboard within the function and stored as the input parameter’s data.</li><li>Modify <strong class="source-inline">firstName</strong>, <strong class="source-inline">lastName</strong>, and <strong class="source-inline">currentCourseEnrolled</strong> to be modeled as <strong class="source-inline">char *</strong> (or <strong class="source-inline">string</strong>) in your <strong class="source-inline">Student</strong> class instead of using fixed-sized arrays (as they may have been modeled in <a href="B19087_02.xhtml#_idTextAnchor072"><em class="italic">Chapter 2</em></a>, <em class="italic">Adding Language Necessities</em>). You may utilize a <strong class="source-inline">temp</strong> variable that is a fixed size to initially capture user input for these values, and then allocate the proper, respective sizes for each of these data members. Note that using a <strong class="source-inline">string</strong> will be the simplest and safest approach.</li><li>Rewrite, if necessary, the <strong class="source-inline">Print()</strong> function from your solution in <a href="B19087_02.xhtml#_idTextAnchor072"><em class="italic">Chapter 2</em></a>, <em class="italic">Adding Language Necessities</em>, to take a <strong class="source-inline">Student</strong> as a parameter for <strong class="source-inline">Printd().</strong></li><li>Overload the <strong class="source-inline">Print()</strong> function with one that takes a <strong class="source-inline">const Student *</strong> as a parameter. Which one is more efficient? Why?</li><li>In <strong class="source-inline">main()</strong>, create an array of pointers to <strong class="source-inline">Student</strong> to accommodate five students. Allocate each <strong class="source-inline">Student</strong>, call <strong class="source-inline">ReadData()</strong> for each <strong class="source-inline">Student</strong>, and then <strong class="source-inline">Print()</strong> each <strong class="source-inline">Student</strong> using a selection from your previous functions. When done, remember to <strong class="source-inline">delete()</strong> the memory for each <strong class="source-inline">Student</strong> allocated.</li><li>Also in <strong class="source-inline">main()</strong>, create an array of void pointers that is the same size as the array of pointers to <strong class="source-inline">Student</strong>. Set each element in the array of <strong class="source-inline">void</strong> pointers to point to a corresponding <strong class="source-inline">Student</strong> from the array of <strong class="source-inline">Student</strong> pointers. Call the version of <strong class="source-inline">Print()</strong> that takes a <strong class="source-inline">const Student *</strong> as a parameter for each element in the <strong class="source-inline">void *</strong> array. Hint: you will need to cast <strong class="source-inline">void *</strong> elements to type <strong class="source-inline">Student *</strong> prior to making certain assignments and function calls.</li></ol></li>
<li>Write the following pointer declarations that include a <strong class="source-inline">const</strong> qualification:<ol><li>Write a declaration for a pointer to a constant object. Assume the object is of type <strong class="source-inline">Student</strong>. Hint: read your declaration from right to left to verify correctness.</li><li>Write a declaration for a constant pointer to a non-constant object. Again, assume the object is of type <strong class="source-inline">Student.</strong></li><li>Write a declaration for a constant pointer to a constant object. The object will again be of type <strong class="source-inline">Student</strong>.</li></ol></li>
<li>Why does passing an argument of type <strong class="source-inline">const Student *</strong> to <strong class="source-inline">Print()</strong> in your preceding program make sense, yet passing a parameter of type <strong class="source-inline">Student * const</strong> does not make sense?</li>
<li>Can you think of programming situations that may require a dynamically allocated 3-D array? What about a dynamically allocated array with more dimensions?</li>
</ol>
</div>
<div>
<div id="_idContainer020">
</div>
</div>
</div></body></html>