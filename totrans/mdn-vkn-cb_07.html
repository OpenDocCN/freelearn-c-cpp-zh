<html><head></head><body>
<div id="_idContainer059">
<h1 class="chapter-number" id="_idParaDest-262"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-263"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.2.1">Ray Tracing and Hybrid Rendering</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we venture </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.4.1">into the fascinating world of </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">ray tracing</span></strong><span class="koboSpan" id="kobo.6.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">hybrid rendering</span></strong><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">Ray tracing, to put it simply, is a special technique used in computer graphics </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.9.1">that simulates how light interacts with objects. </span><span class="koboSpan" id="kobo.9.2">This results in images that are so lifelike, they can be mistaken for reality. </span><span class="koboSpan" id="kobo.9.3">However, pure ray tracing is computationally intensive and requires significant hardware resources, which makes it unfeasible for real-time applications with the current generation of hardware. </span><span class="koboSpan" id="kobo.9.4">On the other hand, there’s hybrid rendering, which is a mix of conventional rasterization techniques and the realism of ray tracing. </span><span class="koboSpan" id="kobo.9.5">This blend offers both good performance and stunning visuals. </span><span class="koboSpan" id="kobo.9.6">This chapter will take you through how these techniques can be implemented using Vulkan. </span><span class="koboSpan" id="kobo.9.7">We’ll show you how to set up a ray tracing pipeline and guide you on how to integrate hybrid rendering into your work. </span><span class="koboSpan" id="kobo.9.8">By the end of this chapter, you will have a deeper understanding of how these advanced techniques work. </span><span class="koboSpan" id="kobo.9.9">More importantly, you’ll learn how to use them in your </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">own projects.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">The first part of the chapter focuses on developing a GPU-based ray tracer. </span><span class="koboSpan" id="kobo.11.2">We’ll elaborate on how to effectively develop this GPU-based ray tracer, detailing the steps involved, and how each function contributes to the final lifelike image. </span><span class="koboSpan" id="kobo.11.3">The second part of our chapter will revolve around the integration of shadows from a ray tracer along with rasterized deferred rendering. </span><span class="koboSpan" id="kobo.11.4">We will delve into how the shadows generated from a ray tracer can be combined with the rasterization technique of deferred rendering, a technique commonly referred to as </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">hybrid rendering.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Implementing a GPU </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">ray tracer</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Implementing a </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">hybrid renderer</span></span></li>
</ul>
<h1 id="_idParaDest-264"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">For this chapter, you will need to make sure you have Visual Studio 2022 installed along with the Vulkan SDK. </span><span class="koboSpan" id="kobo.20.2">Basic familiarity with the C++ programming language and an understanding of ray tracing concepts would be useful. </span><span class="koboSpan" id="kobo.20.3">Please revisit </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 1</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.22.1">, Vulkan Core Concepts,</span></em><span class="koboSpan" id="kobo.23.1"> for details about setting up and building the code in the repository. </span><span class="koboSpan" id="kobo.23.2">We also assume that by now you are familiar with the Vulkan API and various concepts that were introduced in previous chapters. </span><span class="koboSpan" id="kobo.23.3">This chapter has multiple recipes, which can be launched using the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">following executables:</span></span></p>
<ol>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">Chapter07_RayTracer.exe</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">Chapter07_HybridRenderer.exe</span></strong></span></li>
</ol>
<p><span class="koboSpan" id="kobo.27.1">The code files for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">here: </span></span><a href="https://github.com/PacktPublishing/The-Modern-Vulkan-Cookbook"><span class="No-Break"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/The-Modern-Vulkan-Cookbook</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.30.1">.</span></span></p>
<h1 id="_idParaDest-265"><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.31.1">Implementing a GPU ray tracer</span></h1>
<p><span class="koboSpan" id="kobo.32.1">Ray tracing is a rendering technique that simulates the physical behavior of light to generate highly </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.33.1">realistic graphics. </span><span class="koboSpan" id="kobo.33.2">Ray tracing works by tracing the path of light from a pixel in the image sensor back to its source. </span><span class="koboSpan" id="kobo.33.3">Each ray of light can interact with the objects in the scene, causing a variety of effects such as reflection, refraction, or absorption. </span><span class="koboSpan" id="kobo.33.4">This allows for the creation of realistic shadows, reflections, and light dispersion effects in complex 3D scenes. </span><span class="koboSpan" id="kobo.33.5">In previous chapters, specifically </span><a href="B18491_04.xhtml#_idTextAnchor241"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.34.1">Chapter 4</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.35.1">, Exploring Techniques for Lighting, Shading, and Shadows</span></em><span class="koboSpan" id="kobo.36.1">, we explored </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">rasterization</span></strong><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">It takes a more direct approach, converting </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.39.1">3D polygons that make up a scene directly into a 2D image. </span><span class="koboSpan" id="kobo.39.2">It essentially fills in the pixels of each polygon based on its color and texture. </span><span class="koboSpan" id="kobo.39.3">On the other hand, ray tracing simulates the path of light rays from the camera to the scene, accounting for how these rays interact with the </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">scene’s objects.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Before we delve into the specifics of how ray tracing is implemented in Vulkan, it is beneficial to gain an understanding of how ray tracing operates, along with several fundamental </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.42.1">concepts such as the </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">bidirectional reflectance distribution function</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.45.1">BRDF</span></strong><span class="koboSpan" id="kobo.46.1">), radiance, and irradiance. </span><span class="koboSpan" id="kobo.46.2">These concepts play a crucial role in determining how light interacts with surfaces in a scene and subsequently influences the final </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">rendered image.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">To simplify understanding, let’s break down the flow of the ray tracing algorithm, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.49.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.50.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.52.1"><img alt="Figure 7.1 – Ray tracing algorithm" src="image/B18491_07_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.53.1">Figure 7.1 – Ray tracing algorithm</span></p>
<p><span class="koboSpan" id="kobo.54.1">In the </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.55.1">following section, we will outline the fundamental principles of the ray </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">tracing algorithm:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.57.1">For each pixel on the screen, a ray is projected from the viewpoint or “eye” into the scene. </span><span class="koboSpan" id="kobo.57.2">This is the initial step in ray tracing and sets the stage for </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">further calculations.</span></span></li>
<li><span class="koboSpan" id="kobo.59.1">The algorithm then calculates the point of intersection between the ray and the objects within the scene. </span><span class="koboSpan" id="kobo.59.2">It identifies the closest object that is hit by the ray, along with the exact hit point on the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">object’s geometry.</span></span></li>
<li><span class="koboSpan" id="kobo.61.1">Once the intersection point is determined, shading is performed at the hit point. </span><span class="koboSpan" id="kobo.61.2">The color and lighting information calculated at this point is added to the radiance value for the pixel, which contributes to the final color of the pixel in the </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">rendered image.</span></span></li>
<li><span class="koboSpan" id="kobo.63.1">The ray doesn’t stop at the first hit. </span><span class="koboSpan" id="kobo.63.2">It can continue to propagate due to phenomena such as reflection or refraction. </span><span class="koboSpan" id="kobo.63.3">The rays resulting from reflection or refraction are assigned a throughput value, which represents the remaining energy of </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">the light.</span></span></li>
<li><span class="koboSpan" id="kobo.65.1">The recursive process can potentially go on indefinitely, which is computationally </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.66.1">expensive. </span><span class="koboSpan" id="kobo.66.2">To handle this, techniques such as </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">Russian Roulette</span></strong><span class="koboSpan" id="kobo.68.1"> are used. </span><span class="koboSpan" id="kobo.68.2">In Russian Roulette, the recursion is probabilistically terminated based on the remaining energy in the ray. </span><span class="koboSpan" id="kobo.68.3">If the ray’s energy falls below a certain threshold, it has a certain chance of being terminated early, which helps to control the computational cost of </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">the algorithm.</span></span></li>
<li><span class="koboSpan" id="kobo.70.1">Now that </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.71.1">we understand how the ray tracing algorithm functions, it’s beneficial to delve into the principles of </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">radiometry</span></strong><span class="koboSpan" id="kobo.73.1">. </span><span class="koboSpan" id="kobo.73.2">Radiometry is </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.74.1">a branch of physics that quantifies light’s behavior, providing a series of methods and units to describe and measure different aspects of light in a scene. </span><span class="koboSpan" id="kobo.74.2">Several key concepts that are fundamental to understanding radiometry include radiant intensity, irradiance, and radiance. </span><span class="koboSpan" id="kobo.74.3">The following diagram (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.75.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.76.1">.2</span></em><span class="koboSpan" id="kobo.77.1">) can help you remember </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">these concepts:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.79.1"><img alt="Figure 7.2 – Radiometry basics" src="image/B18491_07_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.80.1">Figure 7.2 – Radiometry basics</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.81.1">Radiant intensity</span></strong><span class="koboSpan" id="kobo.82.1">: This is </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.83.1">a measure of the power </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.84.1">of light emitted, or radiant flux, per unit solid angle, typically </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.85.1">measured in </span><strong class="bold"><span class="koboSpan" id="kobo.86.1">watts per steradian</span></strong><span class="koboSpan" id="kobo.87.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.88.1">W/sr</span></strong><span class="koboSpan" id="kobo.89.1">). </span><span class="koboSpan" id="kobo.89.2">The steradian, analogous to the radian in angular measure, quantifies solid angles in 3D space. </span><span class="koboSpan" id="kobo.89.3">In the context of ray tracing, it serves as a pivotal unit when calculating radiant intensity, capturing how light spreads across surfaces within the simulated environment. </span><span class="koboSpan" id="kobo.89.4">It is directional in nature, meaning it varies depending on the direction from which the light </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">is observed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.91.1">Irradiance</span></strong><span class="koboSpan" id="kobo.92.1">: Irradiance </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.93.1">measures the power of radiant flux incident upon a surface </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.94.1">per unit area, typically measured in </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">watts per square meter</span></strong><span class="koboSpan" id="kobo.96.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.97.1">W/m²</span></strong><span class="koboSpan" id="kobo.98.1">). </span><span class="koboSpan" id="kobo.98.2">In the context of ray tracing, irradiance </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.99.1">is used to calculate the amount of light energy striking a surface, which is then used for shading calculations. </span><span class="koboSpan" id="kobo.99.2">It plays a key role in determining how bright an object appears in </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">the scene.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.101.1">Radiance</span></strong><span class="koboSpan" id="kobo.102.1">: Radiance </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.103.1">refers to how much light is either coming from a </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.104.1">specific area or passing through it, considering the particular direction or viewpoint from which the light is observed. </span><span class="koboSpan" id="kobo.104.2">It is used to describe the amount of light that reaches the camera from a </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.105.1">specific point in the scene, through a specific direction. </span><span class="koboSpan" id="kobo.105.2">It’s measured in </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">watts per square meter per steradian</span></strong><span class="koboSpan" id="kobo.107.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.108.1">W/m²/sr</span></strong><span class="koboSpan" id="kobo.109.1">). </span><span class="koboSpan" id="kobo.109.2">Radiance is a critical concept in ray tracing as it integrates both directional and positional information, helping to generate accurate shading and </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">lighting effects.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.111.1">As the next step, we will </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.112.1">learn a bit about the </span><strong class="bold"><span class="koboSpan" id="kobo.113.1">rendering equation</span></strong><span class="koboSpan" id="kobo.114.1"> used in ray tracing. </span><span class="koboSpan" id="kobo.114.2">The equation essentially depicts that the light leaving a point in a certain direction is equal to the light emitted by the point in that direction plus the light reflected by the point in that direction. </span><span class="koboSpan" id="kobo.114.3">The reflected light is integral over all directions of incoming light, where each incoming direction is weighted by the BRDF and the cosine of the angle between the incoming light and the surface normal. </span><span class="koboSpan" id="kobo.114.4">The link provided below </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.115.1">offers a simplified explanation of the rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">equation: </span></span><a href="https://twitter.com/KostasAAA/status/1379918353553371139/photo/1"><span class="No-Break"><span class="koboSpan" id="kobo.117.1">https://twitter.com/KostasAAA/status/1379918353553371139/photo/1</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.118.1">.</span></span></p>
<ul>
<li><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.119.1">L</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.120.1"> </span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.121.1">o</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.122.1">(</span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.123.1">x</span></span><span class="_-----MathTools-_Math_Operator"><span class="koboSpan" id="kobo.124.1">,</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.125.1">ω</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.126.1"> </span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.127.1">o</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.128.1">)</span></span><span class="koboSpan" id="kobo.129.1"> is the total amount of radiance (light), leaving point </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.130.1">x</span></span><span class="koboSpan" id="kobo.131.1">s</span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.132.1">(</span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.133.1">x</span></span><span class="_-----MathTools-_Math_Operator"><span class="koboSpan" id="kobo.134.1">,</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.135.1">ω</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.136.1"> </span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.137.1">o</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.138.1">)</span></span><span class="koboSpan" id="kobo.139.1"> is the emitted light from the point </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.140.1">x</span></span><span class="koboSpan" id="kobo.141.1"> in the direction </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.142.1">ω</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.143.1"> </span></span><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.144.1">o</span></span><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">This term is usually only non-zero for </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">light sources.</span></span></li>
<li><span class="koboSpan" id="kobo.147.1">The term </span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.148.1">∫</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.149.1"> </span></span><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.150.1">Ω</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.151.1"> </span></span><span class="koboSpan" id="kobo.152.1"> represents an integral over the entire hemisphere </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.153.1">Ω</span></span><span class="koboSpan" id="kobo.154.1"> above </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">point </span></span><span class="No-Break"><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.156.1">x</span></span></span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">.</span></span></li>
<li><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.158.1">f</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.159.1"> </span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.160.1">r</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.161.1">(</span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.162.1">x</span></span><span class="_-----MathTools-_Math_Operator"><span class="koboSpan" id="kobo.163.1">,</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.164.1">ω</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.165.1"> </span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.166.1">i</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator"><span class="koboSpan" id="kobo.167.1">→</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.168.1">ω</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.169.1"> </span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.170.1">o</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.171.1">)</span></span><span class="koboSpan" id="kobo.172.1"> is the BRDF at point </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.173.1">x</span></span><span class="koboSpan" id="kobo.174.1">, which defines how much light is reflected off </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.175.1">x</span></span><span class="koboSpan" id="kobo.176.1"> in the direction </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.177.1">ω</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.178.1"> </span></span><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.179.1">o</span></span><span class="koboSpan" id="kobo.180.1"> when light comes in from direction </span><span class="No-Break"><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.181.1">ω</span></span></span><span class="No-Break"><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.182.1"> </span></span></span><span class="No-Break"><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.183.1">i</span></span></span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">.</span></span></li>
<li><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.185.1">L</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.186.1"> </span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.187.1">i</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.188.1">(</span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.189.1">x</span></span><span class="_-----MathTools-_Math_Operator"><span class="koboSpan" id="kobo.190.1">,</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.191.1">ω</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.192.1"> </span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.193.1">i</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.194.1">)</span></span><span class="koboSpan" id="kobo.195.1"> is the incoming light at point </span><em class="italic"><span class="koboSpan" id="kobo.196.1">p</span></em><span class="koboSpan" id="kobo.197.1"> from direction </span><span class="No-Break"><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.198.1">ω</span></span></span><span class="No-Break"><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.199.1"> </span></span></span><span class="No-Break"><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.200.1">i</span></span></span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">.</span></span></li>
<li><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.202.1">ω</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.203.1"> </span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.204.1">i</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator"><span class="koboSpan" id="kobo.205.1">∙</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.206.1">n</span></span><span class="koboSpan" id="kobo.207.1"> is the </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.208.1">cosine of the angle between </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.209.1">ω</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.210.1"> </span></span><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.211.1">i</span></span><span class="koboSpan" id="kobo.212.1"> and the normal at point </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.213.1">x</span></span><span class="koboSpan" id="kobo.214.1">. </span><span class="koboSpan" id="kobo.214.2">This accounts for the fact that light arriving at a shallow angle spread over a larger area. </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.215.1">d</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.216.1">ω</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.217.1"> </span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.218.1">i</span></span><span class="koboSpan" id="kobo.219.1"> is a small amount of solid angle around direction </span><span class="No-Break"><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.220.1">ω</span></span></span><span class="No-Break"><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.221.1"> </span></span></span><span class="No-Break"><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.222.1">i</span></span></span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">.</span></span></li>
</ul>
<h2 id="_idParaDest-266"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.224.1">Monte Carlo method</span></h2>
<p><span class="koboSpan" id="kobo.225.1">Next, we will </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.226.1">discuss the </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">Monte Carlo method</span></strong><span class="koboSpan" id="kobo.228.1">, which is a statistical technique that allows for numerical solutions to complex problems by </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.229.1">performing repeated random sampling. </span><span class="koboSpan" id="kobo.229.2">Suppose you want to calculate the area under a curve described by the function </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.230.1">f</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.231.1">(</span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.232.1">x</span></span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.233.1">)</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator"><span class="koboSpan" id="kobo.234.1">=</span></span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.235.1">x</span></span><span class="_-----MathTools-_Math_Base"><span class="koboSpan" id="kobo.236.1"> </span></span><span class="_-----MathTools-_Math_Number"><span class="koboSpan" id="kobo.237.1">2</span></span><span class="koboSpan" id="kobo.238.1"> between </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.239.1">x</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator"><span class="koboSpan" id="kobo.240.1">=</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number"><span class="koboSpan" id="kobo.241.1">0</span></span><span class="koboSpan" id="kobo.242.1"> and </span><span class="_-----MathTools-_Math_Variable"><span class="koboSpan" id="kobo.243.1">x</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator"><span class="koboSpan" id="kobo.244.1">=</span></span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number"><span class="koboSpan" id="kobo.245.1">1</span></span><span class="koboSpan" id="kobo.246.1">. </span><span class="koboSpan" id="kobo.246.2">Mathematically, you’d solve this using calculus with an integral. </span><span class="koboSpan" id="kobo.246.3">However, imagine now that the function is extremely complex or has many variables, such that you can’t easily integrate it using standard calculus techniques. </span><span class="koboSpan" id="kobo.246.4">This is where the Monte Carlo method comes into play. </span><span class="koboSpan" id="kobo.246.5">Instead of trying to compute the integral exactly, we can estimate it using random sampling. </span><span class="koboSpan" id="kobo.246.6">In the case of ray tracing, the rendering equation, which models how light interacts with surfaces, is quite complex, especially because it involves an integral over all possible directions of incoming light. </span><span class="koboSpan" id="kobo.246.7">This is the reason Monte Carlo is used. </span><span class="koboSpan" id="kobo.246.8">Instead of trying to calculate the exact value of the integral, we can approximate it by randomly sampling directions of incoming light, evaluating the integrand for each of these samples, and then averaging the results. </span><span class="koboSpan" id="kobo.246.9">This process is repeated many times to get a more </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">accurate estimate.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">We briefly talked about the BRDF during the rendering equation; it tells us how light bounces off a surface. </span><span class="koboSpan" id="kobo.248.2">When light hits a surface, it doesn’t just bounce back in one direction but scatters in many directions. </span><span class="koboSpan" id="kobo.248.3">The BRDF gives us a way to predict this behavior. </span><span class="koboSpan" id="kobo.248.4">It considers two directions: the direction from which the light is coming, and the direction in which it’s going after it hits </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">the surface.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">Imagine the sun shining on the surface. </span><span class="koboSpan" id="kobo.250.2">The BRDF helps us figure out how much light from the sun is reflected off that surface and in what direction it goes. </span><span class="koboSpan" id="kobo.250.3">This is important for calculating the color and brightness that we see in a rendered image. </span><span class="koboSpan" id="kobo.250.4">Here’s where the concept of throughput or contribution comes in. </span><span class="koboSpan" id="kobo.250.5">It’s like a measure of how much light energy is retained or lost when the light bounces off the surface. </span><span class="koboSpan" id="kobo.250.6">Think of it as the efficiency of light reflection. </span><span class="koboSpan" id="kobo.250.7">We need to include this in our calculations to get </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">accurate results.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">probability density function</span></strong><span class="koboSpan" id="kobo.254.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.255.1">PDF</span></strong><span class="koboSpan" id="kobo.256.1">) is a statistical tool that helps us handle the randomness </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.257.1">involved in these calculations. </span><span class="koboSpan" id="kobo.257.2">When light hits the surface, it can bounce off in many different directions, and the PDF helps us figure out the likelihood of each </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">possible direction.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.259.1">Importance sampling</span></strong><span class="koboSpan" id="kobo.260.1"> is a technique used in ray tracing where we choose to send more rays in </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.261.1">directions where the BRDF is high and fewer rays in directions where it is low. </span><span class="koboSpan" id="kobo.261.2">This helps us get a more accurate result with fewer rays, which can be computationally cheaper. </span><span class="koboSpan" id="kobo.261.3">However, since we’re sending more rays in certain directions and fewer in others, we’re biasing our sampling toward those directions. </span><span class="koboSpan" id="kobo.261.4">We divide our BRDF result by the PDF to get our result. </span><span class="koboSpan" id="kobo.261.5">The reason we divide the BRDF </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.262.1">by a PDF is essentially to correct for bias </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.263.1">that was introduced when we used importance sampling to choose the next direction in which to trace </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">the ray.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">In ray tracing, each light ray carries its own energy. </span><span class="koboSpan" id="kobo.265.2">Each time it bounces, we add the energy it carries times the BRDF to the overall brightness of </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">the image.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">In Vulkan, ray tracing is implemented through a series of distinct shader stages. </span><span class="koboSpan" id="kobo.267.2">In this recipe, we will guide you through the process of implementing a GPU ray tracer with Vulkan, providing a step-by-step walkthrough on how to set up each shader stage involved in the ray tracing process. </span><span class="koboSpan" id="kobo.267.3">By the end of this recipe, you’ll be able to create your own ray tracer that can produce highly realistic graphics by accurately simulating the behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">of light.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">The shader stages include </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.271.1">Ray generation shader</span></strong><span class="koboSpan" id="kobo.272.1">: This </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.273.1">is the starting point of the ray </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">tracing process</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.275.1">Intersection shader</span></strong><span class="koboSpan" id="kobo.276.1">: This </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.277.1">shader calculates how rays intersect with the </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">scene’s geometry</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.279.1">Miss and hit shaders</span></strong><span class="koboSpan" id="kobo.280.1">: These </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.281.1">define how rays behave when they hit or miss </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">an object</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.283.1">By understanding and implementing each of these stages, you’ll be well on your way to creating visually stunning and </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">realistic graphics.</span></span></p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.285.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.286.1">The ray tracing </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.287.1">pipeline in Vulkan is made up of six stages: ray generation, intersection, any-hit, closest hit, miss, and callable. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.288.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.289.1">.3</span></em><span class="koboSpan" id="kobo.290.1"> shows the stages and </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.291.1">their general layout in the pipeline. </span><span class="koboSpan" id="kobo.291.2">Another key component of Vulkan ray tracing is </span><strong class="bold"><span class="koboSpan" id="kobo.292.1">acceleration structure</span></strong><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">This structure is pivotal in efficiently handling the large amount of geometric data involved in ray tracing. </span><span class="koboSpan" id="kobo.293.3">The role of the acceleration structure is to organize data in a way that allows for rapid ray tracing </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.294.1">calculations. </span><strong class="bold"><span class="koboSpan" id="kobo.295.1">Bounding volume hierarchy</span></strong><strong class="bold"> </strong><span class="koboSpan" id="kobo.296.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.297.1">BVH</span></strong><span class="koboSpan" id="kobo.298.1">) is an algorithmic tree structure on a set of geometric objects. </span><span class="koboSpan" id="kobo.298.2">All geometric objects are wrapped in bounding volumes that form the leaf nodes of the tree. </span><span class="koboSpan" id="kobo.298.3">These nodes are then paired, bounded, and connected to form a parent node. </span><span class="koboSpan" id="kobo.298.4">This process continues up the tree until there is only one bounding volume remaining: the root of the tree. </span><span class="koboSpan" id="kobo.298.5">This structure allows the ray tracing algorithm to efficiently discard many objects that the ray cannot intersect, thereby speeding up the </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">process significantly.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">The acceleration structure is divided into two levels: the </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">bottom level acceleration structures</span></strong><span class="koboSpan" id="kobo.302.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.303.1">BLASs</span></strong><span class="koboSpan" id="kobo.304.1">) and the </span><strong class="bold"><span class="koboSpan" id="kobo.305.1">top level acceleration </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.306.1">structures</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.307.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.308.1">TLASs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">):</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.310.1">BLAS</span></strong><span class="koboSpan" id="kobo.311.1">: BLASs </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.312.1">are responsible for storing the geometric data for individual objects in the scene. </span><span class="koboSpan" id="kobo.312.2">Each object can have one or more BLAS associated with it, and each BLAS can contain one or more geometric primitives, such as triangles or instances of other BLASs. </span><span class="koboSpan" id="kobo.312.3">The BLAS is responsible for determining how rays intersect with the geometry they contains, making it a fundamental part of the ray </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">tracing process.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.314.1">TLAS</span></strong><span class="koboSpan" id="kobo.315.1">: The </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.316.1">TLAS, on the other hand, does not contain geometric data. </span><span class="koboSpan" id="kobo.316.2">Instead, it contains instances of BLASs. </span><span class="koboSpan" id="kobo.316.3">Each instance defines a transformation (such as translation, rotation, or scaling) and a BLAS to apply it to. </span><span class="koboSpan" id="kobo.316.4">When ray tracing, the system starts from the TLAS and works its way down to the appropriate BLAS. </span><span class="koboSpan" id="kobo.316.5">The TLAS essentially acts as a directory that guides the system to the correct BLAS based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">ray’s path.</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.318.1"><img alt="Figure 7.3 – Ray tracing pipeline and its stages" src="image/B18491_07_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.319.1">Figure 7.3 – Ray tracing pipeline and its stages</span></p>
<p><span class="koboSpan" id="kobo.320.1">The shader </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.321.1">stages are </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">as follows:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.323.1">Ray generation stage</span></strong><span class="koboSpan" id="kobo.324.1">: The ray generation shader is essentially the starting point for ray tracing. </span><span class="koboSpan" id="kobo.324.2">Its primary function is to generate the initial or primary rays that are shot from the camera. </span><span class="koboSpan" id="kobo.324.3">This is accomplished by utilizing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">traceRayExt</span></strong><span class="koboSpan" id="kobo.326.1"> function. </span><span class="koboSpan" id="kobo.326.2">These rays are what will eventually interact with the objects in the scene to create the final </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">rendered image.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.328.1">Acceleration structure traversal</span></strong><span class="koboSpan" id="kobo.329.1">: The acceleration structure is a key component in optimizing the process of ray tracing. </span><span class="koboSpan" id="kobo.329.2">It functions as a scene management tree, akin to a BVH. </span><span class="koboSpan" id="kobo.329.3">Its primary use is to speed up collision detection between rays and objects within the scene. </span><span class="koboSpan" id="kobo.329.4">This part of the pipeline is fixed, meaning Vulkan has already implemented the logic </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">behind it.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.331.1">Intersection stage</span></strong><span class="koboSpan" id="kobo.332.1">: As the rays traverse the BVH, they may call upon an intersection shader. </span><span class="koboSpan" id="kobo.332.2">This shader is particularly useful when dealing with custom types but isn’t necessary when using the default triangle mesh primitive. </span><span class="koboSpan" id="kobo.332.3">This is because Vulkan has already incorporated the logic required for these default primitives, thereby bypassing the need for the </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">intersection shader.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.334.1">Any-hit stage</span></strong><span class="koboSpan" id="kobo.335.1">: This stage processes intersection events found in the intersection stage; in case of an intersection, the any-hit shader is invoked. </span><span class="koboSpan" id="kobo.335.2">The any-hit shader </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.336.1">determines the subsequent steps after the intersection of light and material occurs, such as whether to abandon the intersection and so on. </span><span class="koboSpan" id="kobo.336.2">Depending on the specific requirements, the intersection point can be discarded, at which point it is considered that no intersection took place. </span><span class="koboSpan" id="kobo.336.3">This process is then returned to the </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">BLAS traversal.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.338.1">Closest hit stage</span></strong><span class="koboSpan" id="kobo.339.1">: This shader is responsible for processing the intersection that is currently the closest to the ray origin and has not yet been discarded by an any-hit stage. </span><span class="koboSpan" id="kobo.339.2">It typically involves applying light and material calculations to render the final color of </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">the pixel.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.341.1">Miss stage</span></strong><span class="koboSpan" id="kobo.342.1">: The miss stage determines how to handle the light in the event the ray doesn’t hit anything. </span><span class="koboSpan" id="kobo.342.2">This could involve assigning a default color, environment color, and </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.344.1">Callable stage</span></strong><span class="koboSpan" id="kobo.345.1">: This stage may be called from any other stage (from their </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">shader code).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.347.1">In the repository, the ray tracing code is encapsulated in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">RayTracer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.349.1"> class.</span></span></p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.350.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.351.1">As a first step, we will </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.352.1">look at the code that needs to be executed on the host side; most of the implementation is inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">RayTracer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.354.1"> class:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.355.1">The first critical step in setting up ray tracing with Vulkan is to verify if our physical device (GPU) supports ray tracing features. </span><span class="koboSpan" id="kobo.355.2">This verification is achieved by adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">VkPhysicalDeviceRayTracingPipelineFeaturesKHR</span></strong><span class="koboSpan" id="kobo.357.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">VkPhysicalDeviceAccelerationStructureFeaturesKHR</span></strong><span class="koboSpan" id="kobo.359.1"> to the list of physical features that are checked for support. </span><span class="koboSpan" id="kobo.359.2">This feature-checking operation is implemented in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">PhysicalDevice</span></strong><span class="koboSpan" id="kobo.361.1"> class. </span><span class="koboSpan" id="kobo.361.2">Here, these specific features are added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">VkPhysicalDeviceFeatures2</span></strong><span class="koboSpan" id="kobo.363.1"> structure’s chain, serving as a mechanism to query the support for a set of features. </span><span class="koboSpan" id="kobo.363.2">This class also supplies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">isRayTracingSupported</span></strong><span class="koboSpan" id="kobo.365.1"> function, which is utilized to activate the necessary features for ray tracing during the Vulkan device’s creation process. </span><span class="koboSpan" id="kobo.365.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">Context</span></strong><span class="koboSpan" id="kobo.367.1"> class, we introduce specific features for </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">VkPhysicalDeviceAccelerationStructureFeaturesKHR</span></strong><span class="koboSpan" id="kobo.369.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">VkPhysicalDeviceRayTracingPipelineFeaturesKHR</span></strong><span class="koboSpan" id="kobo.371.1">. </span><span class="koboSpan" id="kobo.371.2">However, these features are only activated during the construction of the Vulkan device if the demo application has ray tracing enabled and the physical device confirms its support for these features. </span><span class="koboSpan" id="kobo.371.3">Please also note that the demo application will only run if your GPU supports Vulkan </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">ray tracing.</span></span></li>
<li><span class="koboSpan" id="kobo.373.1">Next, we create </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.374.1">shader modules for each of the shaders that will be used by the ray </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">tracing pipeline:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.376.1">
auto rayGenShader = context_-&gt;createShaderModule(
  (resourcesFolder / "raytrace_raygen.rgen")
    .string(),
  VK_SHADER_STAGE_RAYGEN_BIT_KHR,
  "RayTracer RayGen Shader");
auto rayMissShader = context_-&gt;createShaderModule(
  (resourcesFolder / "raytrace_miss.rmiss")
    .string(),
  VK_SHADER_STAGE_MISS_BIT_KHR,
  "RayTracer Miss Shader");
auto rayMissShadowShader =
  context_-&gt;createShaderModule(
    (resourcesFolder / "raytrace_shadow.rmiss")
      .string(),
    VK_SHADER_STAGE_MISS_BIT_KHR,
    "RayTracer Miss Shadow Shader");
auto rayClosestHitShader =
  context_-&gt;createShaderModule(
    (resourcesFolder /
     "raytrace_closesthit.rchit")
      .string(),
    VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
    "RayTracer Closest hit Shader");</span></pre></li> <li><span class="koboSpan" id="kobo.377.1">Next, we </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.378.1">create a ray tracing pipeline by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">Pipeline::createRayTracingPipeline()</span></strong><span class="koboSpan" id="kobo.380.1">. </span><span class="koboSpan" id="kobo.380.2">To facilitate creating a ray tracing pipeline, we added a helper structure, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">Pipeline::RayTracingPipelineDescriptor</span></strong><span class="koboSpan" id="kobo.382.1">, which stores the descriptor sets and their bindings (just like in the graphics and compute pipelines descriptors), and all shaders required to create a ray tracing pipeline. </span><span class="koboSpan" id="kobo.382.2">An instance of this structure must be passed to the constructor of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">VulkanCore::Pipeline</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.385.1">
struct RayTracingPipelineDescriptor {
  std::vector&lt;SetDescriptor&gt; sets_;
  std::weak_ptr&lt;ShaderModule&gt; rayGenShader_;
  std::vector&lt;std::weak_ptr&lt;ShaderModule&gt;&gt;
    rayMissShaders_;
  std::vector&lt;std::weak_ptr&lt;ShaderModule&gt;&gt;
    rayClosestHitShaders_;
  std::vector&lt;VkPushConstantRange&gt; pushConstants_;
};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.386.1">A ray tracing pipeline in Vulkan necessitates an array of shader group structures. </span><span class="koboSpan" id="kobo.386.2">Rather than holding a list of shaders, each </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">shader group</span></strong><span class="koboSpan" id="kobo.388.1"> serves as a mapping structure, detailing the association of shaders to their designated pipeline stages. </span><span class="koboSpan" id="kobo.388.2">At the </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.389.1">time of creating the ray tracing pipeline, an array of all the shaders used by the pipeline must be provided, alongside the corresponding shader groups. </span><span class="koboSpan" id="kobo.389.2">Here’s the definition of the shader group (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">VkRayTracingShaderGroupCreateInfoKHR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">) structure:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.392.1">typedef struct </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">VkRayTracingShaderGroupCreateInfoKHR</span></strong><span class="koboSpan" id="kobo.394.1"> {
  VkStructureType sType;
  const void *pNext;
  VkRayTracingShaderGroupTypeKHR type;
  uint32_t generalShader;
  uint32_t closestHitShader;
  uint32_t anyHitShader;
  uint32_t intersectionShader;
  const void *pShaderGroupCaptureReplayHandle;
} VkRayTracingShaderGroupCreateInfoKHR;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.395.1">The structure contains fields to specify shaders for only four different stages of the pipeline (</span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">generalShader</span></strong><span class="koboSpan" id="kobo.397.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">closestHitShader</span></strong><span class="koboSpan" id="kobo.399.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">anyHitShader</span></strong><span class="koboSpan" id="kobo.401.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">intersectionShader</span></strong><span class="koboSpan" id="kobo.403.1">). </span><span class="koboSpan" id="kobo.403.2">That’s because the indices of shaders for the miss and callable stages are provided in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">generalShader</span></strong><span class="koboSpan" id="kobo.405.1"> field. </span><span class="koboSpan" id="kobo.405.2">It’s important to note that the function of these fields depends on the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">type</span></strong><span class="koboSpan" id="kobo.407.1"> member in </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">the structure.</span></span></p></li> <li><span class="koboSpan" id="kobo.409.1">For the sake of brevity, we show here only the creation of one shader stage and one shader group. </span><span class="koboSpan" id="kobo.409.2">The other shader modules passed along with the pipeline descriptor are grouped into their own shader groups. </span><span class="koboSpan" id="kobo.409.3">In the provided code snippet, we demonstrate the construction of a shader group specifically for a ray generation shader. </span><span class="koboSpan" id="kobo.409.4">It’s crucial to understand that each type of shader utilized in Vulkan ray tracing requires its own individual shader group. </span><span class="koboSpan" id="kobo.409.5">It’s necessary </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.410.1">because the design of the Vulkan ray tracing pipeline is such that it allows for different types of shaders to operate independently, each performing a unique task in the ray tracing process. </span><span class="koboSpan" id="kobo.410.2">By structuring each type of shader in its own shader group, we ensure that the corresponding tasks are executed independently and efficiently, aiding in the parallel computation capabilities of the GPU. </span><span class="koboSpan" id="kobo.410.3">Please refer to the code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">Pipeline::createrayTracingPipeline()</span></strong><span class="koboSpan" id="kobo.412.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">more details:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.414.1">
std::vector&lt;VkPipelineShaderStageCreateInfo&gt;
  shaderStages;
std::vector&lt;VkRayTracingShaderGroupCreateInfoKHR&gt;
  shaderGroups;
const VkPipelineShaderStageCreateInfo
  rayGenShaderInfo{
    .sType =
      VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
    .stage = rayGenShader-&gt;vkShaderStageFlags(),
    .module = rayGenShader-&gt;vkShaderModule(),
    .pName = rayGenShader-&gt;entryPoint().c_str(),
  };
shaderStages.push_back(rayGenShaderInfo);
const VkRayTracingShaderGroupCreateInfoKHR
  shaderGroup{
    .sType =
      VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
    .type =
      VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
    .generalShader =
      static_cast&lt;uint32_t&gt;(shaderStages.size()) -
      1,
    .closestHitShader = VK_SHADER_UNUSED_KHR,
    .anyHitShader = VK_SHADER_UNUSED_KHR,
    .intersectionShader = VK_SHADER_UNUSED_KHR,
  };
shaderGroups.push_back(shaderGroup);</span></pre></li> <li><span class="koboSpan" id="kobo.415.1">Finally, here’s </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.416.1">how you create a ray </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">tracing pipeline:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.418.1">
VkRayTracingPipelineCreateInfoKHR rayTracingPipelineInfo{
      .sType = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
      .stageCount = static_cast&lt;uint32_t&gt;(shaderStages.size()),
      .pStages = shaderStages.data(),
      .groupCount = static_cast&lt;uint32_t&gt;(shaderGroups.size()),
      .pGroups = shaderGroups.data(),
      .maxPipelineRayRecursionDepth = 10,
      .layout = vkPipelineLayout_,
  };
  VK_CHECK(vkCreateRayTracingPipelinesKHR(context_-&gt;device(), VK_NULL_HANDLE,
                                          VK_NULL_HANDLE, 1, &amp;rayTracingPipelineInfo,
                                          nullptr, &amp;vkPipeline_));</span></pre></li> <li><span class="koboSpan" id="kobo.419.1">The next </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.420.1">step is to create the </span><strong class="bold"><span class="koboSpan" id="kobo.421.1">shader binding table</span></strong><span class="koboSpan" id="kobo.422.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.423.1">SBT</span></strong><span class="koboSpan" id="kobo.424.1">). </span><span class="koboSpan" id="kobo.424.2">This structure facilitates the linking of shaders to the specific </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.425.1">parts of the scene where they will be applied. </span><span class="koboSpan" id="kobo.425.2">In the repository, we define a structure for the SBT, which contains a buffer to store the binding table and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">VkStridedDeviceAddressRegionKHR</span></strong><span class="koboSpan" id="kobo.427.1"> structure that describes the location and structure of the SBT </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">in memory:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.429.1">
struct SBT {
  std::shared_ptr&lt;VulkanCore::Buffer&gt; buffer;
  VkStridedDeviceAddressRegionKHR sbtAddress;
};</span></pre></li> <li><span class="koboSpan" id="kobo.430.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">createShaderBindingTable()</span></strong><span class="koboSpan" id="kobo.432.1"> function is where the SBT is created. </span><span class="koboSpan" id="kobo.432.2">This function begins by defining several variables to store the sizes and counts of various shader types in the application. </span><span class="koboSpan" id="kobo.432.3">In the code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">handleSize</span></strong><span class="koboSpan" id="kobo.434.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">handleSizeAligned</span></strong><span class="koboSpan" id="kobo.436.1"> represent the size of a single shader group handle in the SBT, with the latter ensuring correct </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">memory alignment:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.438.1">
void EngineCore::RayTracer::
  createShaderBindingTable() {
  const uint32_t handleSize =
    context_-&gt;physicalDevice()
      .rayTracingProperties()
      .shaderGroupHandleSize;
  const uint32_t handleSizeAligned =
    alignedSize(context_-&gt;physicalDevice()
                  .rayTracingProperties()
                  .shaderGroupHandleSize,
                context_-&gt;physicalDevice()
                  .rayTracingProperties()
                  .shaderGroupHandleAlignment);</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">numRayGenShaders</span></strong><span class="koboSpan" id="kobo.440.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">numRayMissShaders</span></strong><span class="koboSpan" id="kobo.442.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">numRayClosestHitShaders</span></strong><span class="koboSpan" id="kobo.444.1"> represent the number of each type of shader used in </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.445.1">the pipeline. </span><span class="koboSpan" id="kobo.445.2">Next, we calculate the total size of the SBT (</span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">sbtSize</span></strong><span class="koboSpan" id="kobo.447.1">) and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">shaderHandleStorage</span></strong><span class="koboSpan" id="kobo.449.1"> vector to store the </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">shader handles:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.451.1">const uint32_t numRayGenShaders = 1;
const uint32_t numRayMissShaders =
  2; // 1 for miss and 1 for shadow
const uint32_t numRayClosestHitShaders = 1;
const uint32_t numShaderGroups =
  numRayGenShaders + numRayMissShaders +
  numRayClosestHitShaders;
const uint32_t groupCount =
  static_cast&lt;uint32_t&gt;(numShaderGroups);
const uint32_t sbtSize =
  groupCount * handleSizeAligned;</span></pre></li> <li><span class="koboSpan" id="kobo.452.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">vkGetRayTracingShaderGroupHandlesKHR</span></strong><span class="koboSpan" id="kobo.454.1"> Vulkan function is then called to retrieve the shader group handles. </span><span class="koboSpan" id="kobo.454.2">These handles are unique identifiers </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.455.1">for the shader groups in the pipeline. </span><span class="koboSpan" id="kobo.455.2">Afterward, we create separate buffers for each shader type (</span><strong class="bold"><span class="koboSpan" id="kobo.456.1">RayGen</span></strong><span class="koboSpan" id="kobo.457.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">RayMiss</span></strong><span class="koboSpan" id="kobo.459.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">RayClosestHit</span></strong><span class="koboSpan" id="kobo.461.1">) and set the stride, size, and device address for each. </span><span class="koboSpan" id="kobo.461.2">For each buffer, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">copyDataToBuffer</span></strong><span class="koboSpan" id="kobo.463.1"> method is called to copy the relevant shader handles from </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">shaderHandleStorage</span></strong><span class="koboSpan" id="kobo.465.1"> into the buffer. </span><span class="koboSpan" id="kobo.465.2">We recommend looking at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">createShaderBindingTable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.467.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.468.1">
std::vector&lt;uint8_t&gt; shaderHandleStorage(sbtSize);
VK_CHECK(vkGetRayTracingShaderGroupHandlesKHR(
  context_-&gt;device(), pipeline_-&gt;vkPipeline(), 0,
  groupCount, sbtSize,
  shaderHandleStorage.data()));</span></pre></li> <li><span class="koboSpan" id="kobo.469.1">Each buffer and its respective </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">VkStridedDeviceAddressRegionKHR</span></strong><span class="koboSpan" id="kobo.471.1"> need to be filled. </span><span class="koboSpan" id="kobo.471.2">Here, we only show how ray generation is populated. </span><span class="koboSpan" id="kobo.471.3">The other groups follow a </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">similar pattern:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.473.1">
raygenSBT_.buffer = context_-&gt;createBuffer(
  context_-&gt;physicalDevice()
      .rayTracingProperties()
      .shaderGroupHandleSize *
    numRayGenShaders,
  VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR |
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
  VMA_MEMORY_USAGE_CPU_ONLY, "RayGen SBT Buffer");
raygenSBT_.sbtAddress.deviceAddress =
  raygenSBT_.buffer-&gt;vkDeviceAddress();
raygenSBT_.sbtAddress.size =
  handleSizeAligned * numRayGenShaders;
raygenSBT_.sbtAddress.stride = handleSizeAligned;
raygenSBT_.buffer-&gt;copyDataToBuffer(
  shaderHandleStorage.data(),
  handleSize *numRayGenShaders);</span></pre></li> <li><span class="koboSpan" id="kobo.474.1">Next, we need to load the environment map along with its acceleration structure. </span><span class="koboSpan" id="kobo.474.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">RayTracer::loadEnvMap()</span></strong><span class="koboSpan" id="kobo.476.1"> method performs the loading of the </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.477.1">environment map and the creation of the </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.478.1">acceleration structure. </span><span class="koboSpan" id="kobo.478.2">It loads a </span><strong class="bold"><span class="koboSpan" id="kobo.479.1">high dynamic range</span></strong><span class="koboSpan" id="kobo.480.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.481.1">HDR</span></strong><span class="koboSpan" id="kobo.482.1">) file and creates a corresponding Vulkan texture by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">context_-&gt;createTexture()</span></strong><span class="koboSpan" id="kobo.484.1">. </span><span class="koboSpan" id="kobo.484.2">It then calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">createEnvironmentAccel()</span></strong><span class="koboSpan" id="kobo.486.1">, which is responsible for creating an acceleration data structure for importance sampling of the environment map. </span><span class="koboSpan" id="kobo.486.2">This function computes a vector of </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">EnvAccel</span></strong><span class="koboSpan" id="kobo.488.1"> structures, one for each texel of the map. </span><span class="koboSpan" id="kobo.488.2">This data is uploaded to a </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">device-only buffer.</span></span></li>
<li><span class="koboSpan" id="kobo.490.1">Next, we create TLASs and BLASs with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">RayTracer::initBottomLevelAccelStruct()</span></strong><span class="koboSpan" id="kobo.492.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">RayTracer::initTopLevelAccelStruct()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1"> methods.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.495.1">In the following steps, you will learn how to set up BLAS </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">using Vulkan:</span></span></p><ol><li class="Alphabets"><strong class="bold"><span class="koboSpan" id="kobo.497.1">Creating acceleration structure geometry</span></strong><span class="koboSpan" id="kobo.498.1">: This describes the data used to </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.499.1">build the acceleration structure. </span><span class="koboSpan" id="kobo.499.2">In this case, it’s a triangle geometry (</span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">VK_GEOMETRY_TYPE_TRIANGLES_KHR</span></strong><span class="koboSpan" id="kobo.501.1">) with vertices and indices from the </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">model’s buffers:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.503.1">
VkAccelerationStructureGeometryKHR
  accelerationStructureGeometry{
    .sType =
      VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
    .geometryType = VK_GEOMETRY_TYPE_TRIANGLES_KHR,
    .geometry = {
        .triangles = {
            .sType =
              VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
            .vertexFormat =
              VK_FORMAT_R32G32B32_SFLOAT,
            .vertexData = vertexBufferDeviceAddress,
            .vertexStride =
              sizeof(EngineCore::Vertex),
            .maxVertex = numVertices,
            .indexType = VK_INDEX_TYPE_UINT32,
            .indexData = indexBufferDeviceAddress,
          },
      },
  };</span></pre><ol><li class="Alphabets" value="2"><strong class="bold"><span class="koboSpan" id="kobo.504.1">Getting the required sizes to build the acceleration structure</span></strong><span class="koboSpan" id="kobo.505.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">vkGetAccelerationStructureBuildSizesKHR</span></strong><span class="koboSpan" id="kobo.507.1"> function call returns the size information needed to allocate the acceleration structure and the </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.508.1">build scratch buffer. </span><span class="koboSpan" id="kobo.508.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">bLAS_[meshIdx].buffer</span></strong><span class="koboSpan" id="kobo.510.1"> buffer is populated as a direct result of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">vkGetAccelerationStructureBuildSizesKHR</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.512.1">function call:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.513.1">VkAccelerationStructureBuildSizesInfoKHR
  accelerationStructureBuildSizesInfo{
    .sType =
      VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
  };
vkGetAccelerationStructureBuildSizesKHR(
  context_-&gt;device(),
  VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
  &amp;accelerationStructureBuildGeometryInfo,
  &amp;numTriangles,
  &amp;accelerationStructureBuildSizesInfo);</span></pre><ol><li class="Alphabets" value="3"><strong class="bold"><span class="koboSpan" id="kobo.514.1">Building the acceleration structure</span></strong><span class="koboSpan" id="kobo.515.1">: After setting up the necessary data, the acceleration structure is finally built using a command buffer. </span><span class="koboSpan" id="kobo.515.2">First, we create a buffer named </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">bLAS_[meshIdx].buffer</span></strong><span class="koboSpan" id="kobo.517.1">, which is used to store the BLAS structure. </span><span class="koboSpan" id="kobo.517.2">We then create a structure of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">VkAccelerationStructureCreateInfoKHR</span></strong><span class="koboSpan" id="kobo.519.1"> type, to which we provide the buffer just created, its size, and specify that it’s a BLAS. </span><span class="koboSpan" id="kobo.519.2">Next, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">vkCreateAccelerationStructureKHR</span></strong><span class="koboSpan" id="kobo.521.1"> to create the actual acceleration structure and store the handle to it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">bLAS_[meshIdx].handle</span></strong><span class="koboSpan" id="kobo.523.1">. </span><span class="koboSpan" id="kobo.523.2">We created a temporary buffer named </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">tempBuffer</span></strong><span class="koboSpan" id="kobo.525.1"> to store the temporary data needed when building the acceleration structure. </span><span class="koboSpan" id="kobo.525.2">When you are building an acceleration structure in Vulkan, the build procedure often needs some temporary space to perform its calculations. </span><span class="koboSpan" id="kobo.525.3">This temporary space is also referred to as a scratch buffer. </span><span class="koboSpan" id="kobo.525.4">We then fill a </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">VkAccelerationStructureBuildGeometryInfoKHR</span></strong><span class="koboSpan" id="kobo.527.1"> structure with the details of the acceleration structure build, including the handle of the acceleration structure, the geometry, and the device address of </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">tempBuffer</span></strong><span class="koboSpan" id="kobo.529.1">. </span><span class="koboSpan" id="kobo.529.2">Next, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">VkAccelerationStructureBuildRangeInfoKHR</span></strong><span class="koboSpan" id="kobo.531.1"> structure to specify the </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.532.1">range of geometries to be used in the build. </span><span class="koboSpan" id="kobo.532.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">vkCmdBuildAccelerationStructuresKHR</span></strong><span class="koboSpan" id="kobo.534.1"> function records the command to build the acceleration structure into the </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">command buffer:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.536.1">// Creating buffer to hold the acceleration structure
bLAS_[meshIdx].buffer = context_-&gt;createBuffer(...);
// Creating acceleration structure
VkAccelerationStructureCreateInfoKHR accelerationStructureCreateInfo{
    .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
    .buffer = bLAS_[meshIdx].buffer-&gt;vkBuffer(),
    .size = accelerationStructureBuildSizesInfo.accelerationStructureSize,
    .type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR};
VK_CHECK(vkCreateAccelerationStructureKHR(context_-&gt;device(),
                                          &amp;accelerationStructureCreateInfo, nullptr,
                                          &amp;bLAS_[meshIdx].handle));
// Creating temporary buffer
auto tempBuffer = context_-&gt;createBuffer(...);
// Setting up geometry and build range info for acceleration structure
VkAccelerationStructureBuildGeometryInfoKHR accelerationBuildGeometryInfo{
    .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
    .dstAccelerationStructure = bLAS_[meshIdx].handle,
    .scratchData = {.deviceAddress = tempBuffer-&gt;vkDeviceAddress()}};
VkAccelerationStructureBuildRangeInfoKHR accelerationStructureBuildRangeInfo{
    .primitiveCount = numTriangles};
// Building acceleration structure
const auto commandBuffer = commandQueueMgr.getCmdBufferToBegin();
vkCmdBuildAccelerationStructuresKHR(
    commandBuffer, 1, &amp;accelerationBuildGeometryInfo,
    &amp;accelerationStructureBuildRangeInfo);</span></pre></li> <li><span class="koboSpan" id="kobo.537.1">In the following steps, you will learn how to set up a TLAS </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">in Vulkan:</span></span><ol><li class="Alphabets"><strong class="bold"><span class="koboSpan" id="kobo.539.1">Creating the acceleration structure instances</span></strong><span class="koboSpan" id="kobo.540.1">: The following loop creates the instances, each of which references a BLAS. </span><span class="koboSpan" id="kobo.540.2">Instances contain information </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.541.1">about the transformation matrix, mask, flags, and the device address of the BLAS </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">it references:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.543.1">
for (int meshIdx = 0; meshIdx &lt; model-&gt;meshes.size();
     ++meshIdx) {
  VkAccelerationStructureInstanceKHR instance{};
  ...
</span><span class="koboSpan" id="kobo.543.2">  instance.accelerationStructureReference =
    bLAS_[meshIdx].buffer-&gt;vkDeviceAddress();
  accelarationInstances_.push_back(instance);
}</span></pre><ol><li class="Alphabets" value="2"><strong class="bold"><span class="koboSpan" id="kobo.544.1">Creating acceleration structure geometry</span></strong><span class="koboSpan" id="kobo.545.1">: The following code describes the data used to build the acceleration structure. </span><span class="koboSpan" id="kobo.545.2">In this case, it’s a set of </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">instances (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">VK_GEOMETRY_TYPE_INSTANCES_KHR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">):</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.549.1">VkAccelerationStructureGeometryKHR
  accelerationStructureGeometry{
  .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
  .geometryType = VK_GEOMETRY_TYPE_INSTANCES_KHR,
  .geometry = {
    .instances = {
      .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,
      .data = instanceDataDeviceAddress,
    },
  },
  .flags = VK_GEOMETRY_OPAQUE_BIT_KHR,
};</span></pre><ol><li class="Alphabets" value="3"><strong class="bold"><span class="koboSpan" id="kobo.550.1">Getting the required sizes to build the acceleration structure</span></strong><span class="koboSpan" id="kobo.551.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">vkGetAccelerationStructureBuildSizesKHR</span></strong><span class="koboSpan" id="kobo.553.1"> function call returns </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.554.1">the size information needed to allocate the acceleration structure and the build </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">scratch buffer:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.556.1">VkAccelerationStructureBuildSizesInfoKHR
  accelerationStructureBuildSizesInfo{
    .sType =
      VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
  };
vkGetAccelerationStructureBuildSizesKHR(
  context_-&gt;device(),
  VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
  &amp;accelerationStructureBuildGeometryInfo,
  &amp;primitiveCount,
  &amp;accelerationStructureBuildSizesInfo);</span></pre><ol><li class="Alphabets" value="4"><strong class="bold"><span class="koboSpan" id="kobo.557.1">Creating the acceleration structure</span></strong><span class="koboSpan" id="kobo.558.1">: The acceleration structure is created using the previously obtained size information. </span><span class="koboSpan" id="kobo.558.2">Notice the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR</span></strong><span class="koboSpan" id="kobo.560.1"> in the type field since we are building a TLAS. </span><span class="koboSpan" id="kobo.560.2">The final part is to record the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">vkCmdBuildAccelerationStructuresKHR</span></strong><span class="koboSpan" id="kobo.562.1"> command on the command buffer which is executed when the command buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">is submitted:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.564.1">VkAccelerationStructureCreateInfoKHR
  accelerationStructureCreateInfo{
    .sType =
      VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
    .buffer = tLAS_.buffer-&gt;vkBuffer(),
    .size = accelerationStructureBuildSizesInfo
              .accelerationStructureSize,
    .type =
      VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
  };
VK_CHECK(vkCreateAccelerationStructureKHR(
  context_-&gt;device(),
  &amp;accelerationStructureCreateInfo, nullptr,
  &amp;tLAS_.handle));
vkCmdBuildAccelerationStructuresKHR(
  commandBuffer, 1, &amp;accelerationBuildGeometryInfo,
  accelerationBuildStructureRangeInfos.data());</span></pre></li> <li><span class="koboSpan" id="kobo.565.1">We also </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.566.1">create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">RayTraced</span></strong><span class="koboSpan" id="kobo.568.1"> storage image (encapsulated in </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">initRayTracedStorageImages</span></strong><span class="koboSpan" id="kobo.570.1">) and bind resources by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">bindResource</span></strong><span class="koboSpan" id="kobo.572.1"> on the pipeline during </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">the initialization.</span></span></li>
<li><span class="koboSpan" id="kobo.574.1">To execute a ray tracer, we need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">RayTracer::execute()</span></strong><span class="koboSpan" id="kobo.576.1">, which is responsible for copying the camera data, binding the pipeline, and calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">vkCmdTraceRaysKHR</span></strong><span class="koboSpan" id="kobo.578.1">. </span><span class="koboSpan" id="kobo.578.2">This Vulkan function launches the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">RayGen</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.580.1"> shader.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.581.1">Now that we have understood the steps on the host side, it’s time to understand the device-side code. </span><span class="koboSpan" id="kobo.581.2">The device-side code for ray tracing is implemented using several shaders including </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">raytrace_raygen.rgen</span></strong><span class="koboSpan" id="kobo.583.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">raytrace_miss.rmiss</span></strong><span class="koboSpan" id="kobo.585.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">raytrace_closesthit.rchit</span></strong><span class="koboSpan" id="kobo.587.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">raytrace_shadow.rmiss</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.591.1">The process begins with the invocation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">raytrace_raygen.rgen</span></strong><span class="koboSpan" id="kobo.593.1"> shader via </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">vkCmdTraceRaysKHR</span></strong><span class="koboSpan" id="kobo.595.1">. </span><span class="koboSpan" id="kobo.595.2">In the following shader code block, the ray tracing process initiates by generating rays for each pixel sample through a unique </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.596.1">seed for randomness. </span><span class="koboSpan" id="kobo.596.2">These rays, defined by their origin and direction, are traced into the scene within a loop until either the maximum number of bounces is reached, or an exit condition is met in the payload. </span><span class="koboSpan" id="kobo.596.3">The payload carries essential information such as origin, direction, and bounce index. </span><span class="koboSpan" id="kobo.596.4">Once the final color for the pixel is calculated using an average from all samples, it is stored in the output image. </span><span class="koboSpan" id="kobo.596.5">If temporal accumulation is applied, the shader retrieves and adds colors from previous frames. </span><span class="koboSpan" id="kobo.596.6">Temporal accumulation is beneficial in ray tracing as it helps to reduce noise and improve image quality. </span><span class="koboSpan" id="kobo.596.7">Accumulating or averaging the color samples over multiple frames effectively increases the number of rays traced per pixel without the cost of tracing extra rays in a </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">single frame:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.598.1">
void main() {
  // Ray Generation
  // tea refers to Tiny Encryption Algorithm, used to generate a unique and reproducible seed for each task and frame.
</span><span class="koboSpan" id="kobo.598.2">  uint seed =
    tea(gl_LaunchIDEXT.y * gl_LaunchIDEXT.x +
          gl_LaunchIDEXT.x,
        camProps.frameId);
  vec3 finalOutColor = vec3(0);
  vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) +
                     vec2(0.5) +
                     vec2(rand(seed), rand(seed));
  vec4 target =
    camProps.projInverse *
    vec4(pixelCenter / vec2(gl_LaunchSizeEXT.xy) *
             2.0 -
           1.0,
         1, 1);
  vec4 direction =
    camProps.viewInverse *
    vec4(normalize(target.xyz / target.w), 0);
  // Initial Payload Setup
  rayPayload.currentBounceIndex = 0;
  rayPayload.exit = false;
  rayPayload.origin =
    (camProps.viewInverse * vec4(0, 0, 0, 1)).xyz;
  rayPayload.direction = direction.xyz;
  // Ray Tracing Loop
  for (int j = 0; j &lt; MAX_BOUNCES; ++j) {
    rayPayload.currentBounceIndex = j;
  // Traces a ray using a culling mask of 0xff to include all potential intersections.
</span><span class="koboSpan" id="kobo.598.3">    traceRayEXT(topLevelAccelStruct,
                gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0,
                rayPayload.origin.xyz, 0.001,
                rayPayload.direction.xyz, 10000.0, 0);
    if (rayPayload.exit)
      break;
  }
  // Final Color Calculation and Image Store
  finalOutColor += rayPayload.radiance / MAX_SAMPLES;
  imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy),
             vec4(linear2sRGB(finalOutColor), 0.0));
}</span></pre></li> <li><span class="koboSpan" id="kobo.599.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">raytrace_miss.rmiss</span></strong><span class="koboSpan" id="kobo.601.1"> shader is pretty simple: it is invoked if the ray doesn’t intersect any object. </span><span class="koboSpan" id="kobo.601.2">In such scenarios, the shader takes a sample from the environment map, determining the color based on the point of interaction between </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.602.1">the ray and the environment. </span><span class="koboSpan" id="kobo.602.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">envMapColor</span></strong><span class="koboSpan" id="kobo.604.1"> function takes a 3D direction vector as an input, normalizes it, and converts it into spherical coordinates (theta and phi). </span><span class="koboSpan" id="kobo.604.2">It then maps these coordinates onto a 2D plane (UV) and retrieves the corresponding color from the environment map texture. </span><span class="koboSpan" id="kobo.604.3">The following code block simply calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">envMapColor</span></strong><span class="koboSpan" id="kobo.606.1"> function to get the radiance for the current </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">ray payload:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.608.1">
void main() {
  rayPayload.radiance =
    envMapColor(gl_WorldRayDirectionEXT);
  rayPayload.exit = true;
}</span></pre></li> <li><span class="koboSpan" id="kobo.609.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">raytrace_closesthit.rchit</span></strong><span class="koboSpan" id="kobo.611.1"> shader is where most of the magic, including a calculation for shading and determining the subsequent direction of the </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">ray, happens:</span></span><ol><li class="Alphabets"><span class="koboSpan" id="kobo.613.1">The initial stage of the process involves extracting the vertex and material data for the mesh that has been struck by the ray. </span><span class="koboSpan" id="kobo.613.2">This is achieved by utilizing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">gl_InstanceID</span></strong><span class="koboSpan" id="kobo.615.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">gl_PrimitiveID</span></strong><span class="koboSpan" id="kobo.617.1"> variables, which are populated with the relevant data by the intersection shader. </span><span class="koboSpan" id="kobo.617.2">The hit shader also </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.618.1">provides access to </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">hitAttributeEXT vec2 attribs</span></strong><span class="koboSpan" id="kobo.620.1">. </span><span class="koboSpan" id="kobo.620.2">In the context of triangles, these attributes represent the barycentric coordinates of the intersection point. </span><span class="koboSpan" id="kobo.620.3">Barycentric coordinates are a form of coordinate system used to specify the position of a point within a triangle. </span><span class="koboSpan" id="kobo.620.4">They are particularly useful in computer graphics because they allow for easy interpolation across a triangle. </span><span class="koboSpan" id="kobo.620.5">By using these coordinates, we can interpolate the positions of the vertices to determine the precise point of intersection within the triangle where the ray has made contact. </span><span class="koboSpan" id="kobo.620.6">Please refer to the code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">raytrace_closesthit.rchit</span></strong><span class="koboSpan" id="kobo.622.1"> to understand how we use barycentric coordinates to get world </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">space position.</span></span></li><li class="Alphabets"><span class="koboSpan" id="kobo.624.1">The next step is to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">envSample()</span></strong><span class="koboSpan" id="kobo.626.1"> function. </span><span class="koboSpan" id="kobo.626.2">This function is a crucial part of the ray tracing process, responsible for sampling the HDR environment map using importance sampling. </span><span class="koboSpan" id="kobo.626.3">The environment map is represented as a 2D texture (latitude-longitude format) and contains the illumination data of the surrounding environment. </span><span class="koboSpan" id="kobo.626.4">The function starts by uniformly picking a texel index in the environment map. </span><span class="koboSpan" id="kobo.626.5">It fetches the sampling data for that texel, which includes the ratio between the texel’s emitted radiance and the environment map’s average, the texel alias, and the distribution function values for that texel and its alias. </span><span class="koboSpan" id="kobo.626.6">The function then decides to either pick the texel directly or pick its alias based on a random variable and the intensity ratio. </span><span class="koboSpan" id="kobo.626.7">It computes the 2D integer coordinates of the chosen texel and uniformly samples the solid angle subtended by the pixel. </span><span class="koboSpan" id="kobo.626.8">The function converts the sampled UV coordinates to a direction in spherical coordinates, which is then converted to a light direction vector in Cartesian coordinates. </span><span class="koboSpan" id="kobo.626.9">This light direction vector is then returned along with the </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">texel’s PDF:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.628.1">
vec3 envLightColor = vec3(0);
vec4 dirPdf =
  envSample(envLightColor, rayPayload.seed);
vec3 lightDir = dirPdf.xyz;
float lightPdf = dirPdf.w</span></pre><ol><li class="Alphabets" value="3"><span class="koboSpan" id="kobo.629.1">Shadow rays play a crucial role in the ray tracing process. </span><span class="koboSpan" id="kobo.629.2">They help in creating realistic lighting effects by determining which parts of the scene are in shadow, thus adding depth and realism to the rendered image. </span><span class="koboSpan" id="kobo.629.3">The next step is to </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.630.1">trace a shadow ray from the intersection point towards the light source to check for any occluding objects. </span><span class="koboSpan" id="kobo.630.2">This is a critical step in determining whether a point is in shadow or not. </span><span class="koboSpan" id="kobo.630.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">inshadow</span></strong><span class="koboSpan" id="kobo.632.1"> variable is declared using </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">layout(location = 1) rayPayloadEXT bool inshadow</span></strong><span class="koboSpan" id="kobo.634.1">. </span><span class="koboSpan" id="kobo.634.2">When a ray is traced in a ray tracing shader, it carries with it a payload. </span><span class="koboSpan" id="kobo.634.3">This payload can be used to store information that needs to be passed between different stages of the ray tracing pipeline, such as from the closest hit shader to the ray generation shader. </span><span class="koboSpan" id="kobo.634.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">inshadow</span></strong><span class="koboSpan" id="kobo.636.1"> variable is a Boolean that is used to store the information of whether a particular point is in shadow. </span><span class="koboSpan" id="kobo.636.2">When the shadow ray (a ray traced from the intersection point towards the light) is occluded by another object, this variable will be set to true, indicating that the point is in shadow. </span><span class="koboSpan" id="kobo.636.3">Please be aware that in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">traceRayEXT</span></strong><span class="koboSpan" id="kobo.638.1"> function, the 6th parameter is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">1</span></strong><span class="koboSpan" id="kobo.640.1">. </span><span class="koboSpan" id="kobo.640.2">This value serves as an index to specify which miss shader should be invoked. </span><span class="koboSpan" id="kobo.640.3">In this context, it refers to the miss shader found </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">raytrace_shadow.miss</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">:</span></span></li></ol><pre class="source-code"><span class="koboSpan" id="kobo.644.1">inshadow = true;
const int layoutLocation = 1;
// Trace the shadow ray
traceRayEXT(topLevelAccelStruct, rayFlags, cullMask,
            0, 0, 1, worldPosition, rayMinDist,
            lightDir, rayMaxDist, layoutLocation);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.645.1">The next step is responsible for lighting calculation using the </span><strong class="bold"><span class="koboSpan" id="kobo.646.1">physically based rendering</span></strong><span class="koboSpan" id="kobo.647.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.648.1">PBR</span></strong><span class="koboSpan" id="kobo.649.1">) model. </span><span class="koboSpan" id="kobo.649.2">The PBR model is evaluated with inputs such as the </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.650.1">material’s properties, incoming light direction, and the normal at the point of intersection. </span><span class="koboSpan" id="kobo.650.2">The resulting color is then calculated based on the light’s color, the evaluated PBR, and the cosine of the angle between the light direction and the normal. </span><span class="koboSpan" id="kobo.650.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">PbrEval</span></strong><span class="koboSpan" id="kobo.652.1"> function evaluates the PBR model for a given set of inputs. </span><span class="koboSpan" id="kobo.652.2">It uses the material properties (such as base color, specular color, roughness, and metallic factors), </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">view direction</span></strong><span class="koboSpan" id="kobo.654.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.655.1">V</span></strong><span class="koboSpan" id="kobo.656.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">normal</span></strong><span class="koboSpan" id="kobo.658.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.659.1">N</span></strong><span class="koboSpan" id="kobo.660.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">light direction</span></strong><span class="koboSpan" id="kobo.662.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.663.1">L</span></strong><span class="koboSpan" id="kobo.664.1">) to compute the BRDF. </span><span class="koboSpan" id="kobo.664.2">This function handles both diffuse and specular contributions </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.665.1">using the </span><strong class="bold"><span class="koboSpan" id="kobo.666.1">Graphics Library Transmission Format’s</span></strong><span class="koboSpan" id="kobo.667.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.668.1">glTF</span></strong><span class="koboSpan" id="kobo.669.1">) PBR model, with respect to the Fresnel equations. </span><span class="koboSpan" id="kobo.669.2">The function balances these contributions based on </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.670.1">the metallic factor and returns the combined BRDF and its associated PDF. </span><span class="koboSpan" id="kobo.670.2">The final step is an accumulation of the light contribution (radiance) that a ray receives as it travels through the scene; </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">rayPayload.radiance</span></strong><span class="koboSpan" id="kobo.672.1"> is the accumulated color or light contribution that the ray has gathered from all the light sources it has encountered up until now. </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">rayPayload.throughput</span></strong><span class="koboSpan" id="kobo.674.1"> is a measure of how much light makes it through a certain path without being absorbed or scattered. </span><span class="koboSpan" id="kobo.674.2">Essentially, it’s a measure of the energy left of a light path. </span><span class="koboSpan" id="kobo.674.3">For details on PBR theory, please </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">visit</span></span><span class="No-Break"><span class="hidden"> </span></span><a href="https://learnopengl.com/PBR/Theory"><span class="No-Break"><span class="koboSpan" id="kobo.676.1">https://learnopengl.com/PBR/Theory</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.677.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.678.1">
if (!inshadow) {
  float pdf;
  // returns diffuse &amp; specular both
  vec3 F =
    PbrEval(eta, metallic, roughness, baseColor.rgb,
            specularColor, -rayPayload.direction, N,
            lightDir, pdf);
  float cosTheta = abs(dot(lightDir, N));
  float misWeight =
    max(0.0, powerHeuristic(lightPdf, pdf));
  if (misWeight &gt; 0.0) {
    directLightColor += misWeight * F * cosTheta *
                        envLightColor /
                        (lightPdf + EPS);
  }
}
rayPayload.radiance +=
  directLightColor * rayPayload.throughput;</span></pre> <ol>
<li class="Alphabets"><span class="koboSpan" id="kobo.679.1">The final </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.680.1">part is to figure out the next ray direction as well as the throughput (energy left) for the next ray. </span><span class="koboSpan" id="kobo.680.2">It starts by sampling a direction for the next ray (</span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">bsdfDirNextRay</span></strong><span class="koboSpan" id="kobo.682.1">) using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">PbrSample</span></strong><span class="koboSpan" id="kobo.684.1"> function, which uses the material properties and the current ray direction to generate this direction. </span><span class="koboSpan" id="kobo.684.2">We calculate </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">cosTheta</span></strong><span class="koboSpan" id="kobo.686.1">, which is the cosine of the angle between the surface normal and the direction of the next ray. </span><span class="koboSpan" id="kobo.686.2">This is used in the calculation of the new throughput because the amount of </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.687.1">light reflected is proportional to the cosine of this angle (</span><strong class="bold"><span class="koboSpan" id="kobo.688.1">Lambert’s cosine law</span></strong><span class="koboSpan" id="kobo.689.1">). </span><span class="koboSpan" id="kobo.689.2">Finally, we update the ray’s direction and origin for the next bounce. </span><span class="koboSpan" id="kobo.689.3">The direction is the sampled direction </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">bsdfDirNextRay</span></strong><span class="koboSpan" id="kobo.691.1">, and the origin is slightly offset from the current position to avoid self-intersection. </span><span class="koboSpan" id="kobo.691.2">Please note </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">PBREval</span></strong><span class="koboSpan" id="kobo.693.1"> is used to evaluate the BRDF in a specific direction while </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">PBRSample</span></strong><span class="koboSpan" id="kobo.695.1"> is used to generate a new direction and evaluate the BRDF in </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">that direction:</span></span></li>
</ol>
<pre class="source-code"><span class="koboSpan" id="kobo.697.1">
Vec3 F = PbrSample(baseColor.rgb, specularColor, eta,
                   materialIOR, metallic, roughness,
                   T, B, -rayPayload.direction,
                   ffnormal, bsdfDirNextRay,
                   bsdfpdfNextRay, rayPayload.seed);
float cosTheta = abs(dot(N, bsdfDirNextRay));
rayPayload.throughput *=
  F * cosTheta / (bsdfpdfNextRay);
// Russian roulette
float rrPcont =
  min(max3(rayPayload.throughput) * eta * eta + 0.001,
      0.95);
rayPayload.throughput /= rrPcont;
// update new ray direction &amp; position
rayPayload.direction = bsdfDirNextRay;
rayPayload.origin = offsetRay(
  worldPosition, dot(bsdfDirNextRay, worldNormal) &gt; 0
                   ? </span><span class="koboSpan" id="kobo.697.2">worldNormal
                   : -worldNormal);</span></pre> <p><span class="koboSpan" id="kobo.698.1">This concludes </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.699.1">various parts of how to implement a simple GPU-based ray tracer </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">in Vulkan.</span></span></p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.701.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.702.1">We recommend reading the </span><em class="italic"><span class="koboSpan" id="kobo.703.1">Ray Tracing in One Weekend</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.704.1">book series:</span></span></p>
<ul>
<li><a href="https://github.com/RayTracing/raytracing.github.io"><span class="No-Break"><span class="koboSpan" id="kobo.705.1">https://github.com/RayTracing/raytracing.github.io</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.706.1">Adam Celarek and Bernhard Kerbl’s YouTube channel contains a trove of information about lighting </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">and ray-tracing:</span></span></p>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLmIqTlJ6KsE2yXzeq02hqCDpOdtj6n6A9"><span class="No-Break"><span class="koboSpan" id="kobo.708.1">https://www.youtube.com/playlist?list=PLmIqTlJ6KsE2yXzeq02hqCDpOdtj6n6A9</span></span></a></li>
</ul>
<h1 id="_idParaDest-270"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.709.1">Implementing hybrid rendering</span></h1>
<p><span class="koboSpan" id="kobo.710.1">In this recipe, we will explore the integration of rasterization, specifically deferred rendering, with </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">ray-traced shadows.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">In </span><a href="B18491_04.xhtml#_idTextAnchor241"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.713.1">Chapter 4</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.714.1">, Exploring Techniques for Lighting, Shading, and Shadows</span></em><span class="koboSpan" id="kobo.715.1">, we implemented deferred rendering, incorporating techniques such as shadow mapping, screen space AO, and screen space reflections. </span><span class="koboSpan" id="kobo.715.2">These techniques allowed us to </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.716.1">generate multiple textures, which were then composited during the lighting pass. </span><span class="koboSpan" id="kobo.716.2">Within this recipe, you will gain insights into generating shadow textures using ray tracing, which will help in overcoming challenges associated with techniques such as screen space shadow mapping. </span><span class="koboSpan" id="kobo.716.3">Screen space shadow mapping relies on the information available in the rendered image. </span><span class="koboSpan" id="kobo.716.4">It doesn’t have complete access to the entire 3D scene geometry. </span><span class="koboSpan" id="kobo.716.5">This limitation can result in inaccuracies and artifacts. </span><span class="koboSpan" id="kobo.716.6">Screen space shadow mapping is susceptible to aliasing issues, particularly along edges and boundaries due to the resolution of the screen space texture. </span><span class="koboSpan" id="kobo.716.7">The ray tracing approach doesn’t have these problems as it works on a </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">full scene.</span></span></p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.718.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.719.1">Within the code repository, the hybrid rendering functionality is realized through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">RayTracedShadowPass</span></strong><span class="koboSpan" id="kobo.721.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">LightingPassHybridRenderer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.723.1"> classes.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">The process begins with the execution of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">Gbuffer</span></strong><span class="koboSpan" id="kobo.726.1"> pass, generating G-buffer textures based on the concepts discussed in </span><a href="B18491_04.xhtml#_idTextAnchor241"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.727.1">Chapter 4</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.728.1">, Exploring Techniques for Lighting, Shading, and Shadows</span></em><span class="koboSpan" id="kobo.729.1">. </span><span class="koboSpan" id="kobo.729.2">Following this, </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">RayTracedShadowPass</span></strong><span class="koboSpan" id="kobo.731.1"> is initiated, employing the ray tracing stages outlined in the preceding section. </span><span class="koboSpan" id="kobo.731.2">However, in this pass, ray tracing is specifically employed to generate the shadow texture. </span><span class="koboSpan" id="kobo.731.3">The final step involves employing </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">LightingPassHybridRenderer</span></strong><span class="koboSpan" id="kobo.733.1"> to compose information from the G-buffer and the ray-traced shadow texture, culminating in the production of a final image </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">for display.</span></span></p>
<p><span class="koboSpan" id="kobo.735.1">The device side code for the ray tracing shader is in </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.737.1">
 raytrace_raygen_shadow_hybrid.rgen, raytrace_miss_shadow_hybrid.rmiss, raytrace_closesthit_shadow_hybrid.rchit</span></pre> <p><span class="koboSpan" id="kobo.738.1">The device </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.739.1">side code for compositing is in </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.741.1">
 hybridRenderer_lighting_composite.frag.</span></pre> <p><span class="koboSpan" id="kobo.742.1">Now that we have understood the code structure, we will investigate how to implement it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">following section.</span></span></p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.744.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.745.1">The host side part of the code is in </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">RayTracedShadowPass</span></strong><span class="koboSpan" id="kobo.747.1"> and the setup for it is very similar to what we described during the previous recipe. </span><span class="koboSpan" id="kobo.747.2">We will focus on the device side code to look at how we </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">generate shadows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.749.1">As usual, we start the shader with a declaration for the input and uniform variables that the shader will use. </span><span class="koboSpan" id="kobo.749.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">layout(location = 0) rayPayloadEXT float visibilityRayPayload;</span></strong><span class="koboSpan" id="kobo.751.1"> line defines the payload that will be returned by the ray tracing operation. </span><span class="koboSpan" id="kobo.751.2">The other uniform variables declared are for the acceleration structure, output image, and textures for the normal and </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">position G-buffers:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.753.1">
layout(location = 0) rayPayloadEXT
  float visibilityRayPayload;
layout(set = 0, binding = 0) uniform
  accelerationStructureEXT topLevelAccelStruct;
layout(set = 0, binding = 1,
       rgba8) uniform image2D outputImage;
layout(set = 1,
       binding = 0) uniform sampler2D gbufferNormal;
layout(set = 1,
       binding = 1) uniform sampler2D gbufferPosition;</span></pre></li> <li><span class="koboSpan" id="kobo.754.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">main</span></strong><span class="koboSpan" id="kobo.756.1"> function is where the actual computation happens. </span><span class="koboSpan" id="kobo.756.2">It starts by calculating the pixel center and the UV coordinates for the current pixel (or launch). </span><span class="koboSpan" id="kobo.756.3">Then, it fetches the normal and world position from the G-buffers using the UV coordinates. </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">rayOrigin</span></strong><span class="koboSpan" id="kobo.758.1"> is calculated by offsetting the world position slightly along </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.759.1">the normal direction. </span><span class="koboSpan" id="kobo.759.2">This is to prevent </span><strong class="bold"><span class="koboSpan" id="kobo.760.1">self-intersection</span></strong><span class="koboSpan" id="kobo.761.1">, where the ray might incorrectly intersect with the surface it was </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">launched from:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.763.1">
const vec2 pixelCenter =
  vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
const vec2 inUV =
  pixelCenter / vec2(gl_LaunchSizeEXT.xy);
vec3 normal =
  normalize(texture(gbufferNormal, inUV).xyz);
vec3 worldPosition =
  texture(gbufferPosition, inUV).xyz;
vec3 rayOrigin = worldPosition + normal * 0.1f;</span></pre></li> <li><span class="koboSpan" id="kobo.764.1">The shader launches multiple shadow rays towards random points on the light source. </span><span class="koboSpan" id="kobo.764.2">The loop runs for several samples, generating a random point on the light source for each sample, and then calculates the direction to that point. </span><span class="koboSpan" id="kobo.764.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">traceRayEXT</span></strong><span class="koboSpan" id="kobo.766.1"> function is called to trace a ray from </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">rayOrigin</span></strong><span class="koboSpan" id="kobo.768.1"> toward the light source. </span><span class="koboSpan" id="kobo.768.2">If the ray hits something before it reaches the light, the payload will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">0</span></strong><span class="koboSpan" id="kobo.770.1">, indicating that the light source is occluded. </span><span class="koboSpan" id="kobo.770.2">If the ray reaches the light source without hitting anything, the payload will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">1</span></strong><span class="koboSpan" id="kobo.772.1">, indicating that the light source is visible. </span><span class="koboSpan" id="kobo.772.2">The visibility for each sample is accumulated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">visible</span></strong><span class="koboSpan" id="kobo.774.1"> variable. </span><span class="koboSpan" id="kobo.774.2">The accumulated visibility for each sample, represented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">visible</span></strong><span class="koboSpan" id="kobo.776.1"> variable, is then stored in the corresponding location of the </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">final image:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.778.1">
for (int i = 0; i &lt; numSamples; i++) {
  vec3 randomPointOnLight =
    lightData.lightPos.xyz +
    (rand3(seed) - 0.5) * lightSize;
  vec3 directionToLight =
    normalize(randomPointOnLight - worldPosition);
  // Start the raytrace
  traceRayEXT(topLevelAccelStruct, rayFlags, 0xFF, 0,
              0, 0, rayOrigin.xyz, tMin,
              directionToLight.xyz, tMax, 0);
  visible += visibilityRayPayload;
}
visible /= float(numSamples);</span></pre></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">raytrace_miss_shadow_hybrid.rmiss</span></strong><span class="koboSpan" id="kobo.780.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">raytrace_closesthit_shadow_hybrid.rchit</span></strong><span class="koboSpan" id="kobo.782.1"> are pretty straightforward; they simply set </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">visibilityRayPayload</span></strong><span class="koboSpan" id="kobo.784.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">1.0</span></strong><span class="koboSpan" id="kobo.786.1"> if it’s a miss and </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">0.0</span></strong><span class="koboSpan" id="kobo.788.1"> in case we </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">hit something.</span></span></li>
<li><span class="koboSpan" id="kobo.790.1">The last </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.791.1">step is the compositing step. </span><span class="koboSpan" id="kobo.791.2">This is the same as the lighting pass we discussed in </span><a href="B18491_04.xhtml#_idTextAnchor241"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.792.1">Chapter 4</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.793.1">, Exploring Techniques for Lighting, Shading, and Shadows</span></em><span class="koboSpan" id="kobo.794.1">, the only difference being that now we are using a shadow texture that has been created using </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">ray tracing.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.796.1">In this chapter, we explored the world of ray tracing and hybrid rendering in Vulkan. </span><span class="koboSpan" id="kobo.796.2">We delved into these advanced graphical techniques, understanding how they can provide unprecedented levels of realism in rendered images. </span><span class="koboSpan" id="kobo.796.3">We learned how ray tracing algorithms work, tracing the path of rays of light to create highly detailed and physically accurate reflections and shadows in a 3D scene. </span><span class="koboSpan" id="kobo.796.4">Through hybrid rendering, we uncovered the process of combining traditional rasterization with ray tracing to achieve a balance between performance and visual fidelity. </span><span class="koboSpan" id="kobo.796.5">This blend allows for the high speed of rasterization </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.797.1">where the utmost precision isn’t required while using ray tracing to handle complex light interactions that rasterization struggles with. </span><span class="koboSpan" id="kobo.797.2">Vulkan’s robust support for both techniques was explored, leveraging its efficient capabilities and explicit control over </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">hardware resources.</span></span></p>
</div>
</body></html>