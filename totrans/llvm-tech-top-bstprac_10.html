<html><head></head><body>
		<div><h1 id="_idParaDest-104"><em class="italic"><a id="_idTextAnchor108"/>Chapter 8</em>: Working with Compiler Flags and Toolchains</h1>
			<p>In the previous chapter, we learned how to process Clang's AST – one of the most common formats for analyzing programs. In addition, we learned how to develop an AST plugin, which is an easy way to insert custom logic into the Clang compilation pipeline. This knowledge will help you augment your skillset for tasks such as source code linting or finding potential security vulnerabilities.</p>
			<p>In this chapter, we are ascending from specific subsystems and looking at the bigger picture – the compiler <strong class="bold">driver</strong> and <strong class="bold">toolchain</strong> that orchestrate, configure, and run individual LLVM and Clang components according to users' needs. More specifically, we will focus on how to add new compiler flags and how to create a custom toolchain. As we mentioned in <a href="B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Clang's Architecture</em>, compiler drivers and toolchains are often under-appreciated and have long been ignored. However, without these two important pieces of software, compilers will become extremely difficult to use. For example, users need to pass over <em class="italic">10</em> different compiler flags merely to build a simple <em class="italic">hello world</em> program, owing to the lack of flag translation. Users also need to run at least three different kinds of tools in order to create an executable to run, since there are no drivers or toolchains to help us invoke <em class="italic">assemblers</em> and <em class="italic">linkers</em>. In this chapter, you will learn how compiler drivers and toolchains work in Clang and how to customize them, which is extremely useful if you want to support Clang on a new operating system or architecture.</p>
			<p>In this section, we will cover the following topics:</p>
			<ul>
				<li>Understanding drivers and toolchains in Clang</li>
				<li>Adding custom driver flags</li>
				<li>Adding a custom toolchain</li>
			</ul>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor109"/>Technical requirements</h1>
			<p>In this chapter, we are still relying on the <code>clang</code> executable, so make sure you build it,  like this:</p>
			<pre>$ ninja clang</pre>
			<p>Since we are working with a driver, as we mentioned in <a href="B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Clang's Architecture</em>, you can use the <code>-###</code> command-line option to print out the frontend flags that have been translated from the driver, like so:</p>
			<pre>$ clang++ <strong class="bold">-###</strong> -std=c++11 -Wall hello_world.cpp -o hello_world
"/path/to/clang" "-cc1" "-triple" "x86_64-apple-macosx11.0.0" "-Wdeprecated-objc-isa-usage" "-Werror=deprecated-objc-isa-usage" "-Werror=implicit-function-declaration" "-emit-obj" "-mrelax-all" "-disable-free" "-disable-llvm-verifier" … "-fno-strict-return" "-masm-verbose" "-munwind-tables" "-target-sdk-version=11.0" … "-resource-dir" "/Library/Developer/CommandLineTools/usr/lib/clang/12.0.0" "-isysroot" "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk" "-I/usr/local/include" "-stdlib=libc++" … "-Wall" "-Wno-reorder-init-list" "-Wno-implicit-int-float-conversion" "-Wno-c99-designator" … "-std=c++11" "-fdeprecated-macro" "-fdebug-compilation-dir" "/Users/Rem" "-ferror-limit" "19" "-fmessage-length" "87" "-stack-protector" "1" "-fstack-check" "-mdarwin-stkchk-strong-link" … "-fexceptions" … "-fdiagnostics-show-option" "-fcolor-diagnostics" "-o" "/path/to/temp/hello_world-dEadBeEf.o" "-x" "c++" "hello_world.cpp"…</pre>
			<p>Using this flag will <em class="italic">not</em> run the rest of the compilation but merely execute the driver and toolchain. This makes it a good way to verify and debug specific flags and check they are correctly propagated from the driver to the frontend.</p>
			<p>Last but not least, in the last section of this chapter, <em class="italic">Adding a custom toolchain</em>, we will work on a project that can only run on Linux systems. Also, please install OpenSSL beforehand. It is usually available as a package in most Linux systems. For example, on Ubuntu, you can use the following command to install it:</p>
			<pre>$ sudo apt install <strong class="bold">openssl</strong></pre>
			<p>We are only using the command-line utility, so there's no need to install any OpenSSL libraries that are normally used for development.</p>
			<p>The code that will be used in this chapter can be found here: <a href="https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter08">https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter08</a>.</p>
			<p>In the first section of this chapter, we will provide a brief introduction to Clang's driver and toolchain infrastructure.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor110"/>Understanding drivers and toolchains in Clang</h1>
			<p>Before we<a id="_idIndexMarker331"/> talk about the compiler <a id="_idIndexMarker332"/>driver in Clang, it is necessary to highlight the <a id="_idIndexMarker333"/>fact that <em class="italic">compiling a piece of code</em> is never a <em class="italic">single</em> task (and not a simple one, either). In school, we were taught that a compiler consists of a <strong class="bold">lexer</strong>, a <strong class="bold">parser</strong>, sometimes came with an <strong class="bold">optimizer</strong>, and ended with an <strong class="bold">assembly code printer</strong>. While you still can see these stages in real-world compilers, they <a id="_idIndexMarker334"/>give you nothing but textual assembly code rather than an executable or library, as we would normally expect. Furthermore, this naïve compiler only provides limited flexibility – it can't be ported to any other operating systems or platforms.</p>
			<p>To make this toy compiler more realistic and usable, many other <em class="italic">plumber</em> tools need to be put together, along with the core compiler: an <strong class="bold">assembler</strong> to<a id="_idIndexMarker335"/> transform assembly code into (binary format) object file, a <strong class="bold">linker</strong> to <a id="_idIndexMarker336"/>put multiple object files into an executable or library, and many other routines to resolve platform-specific configurations, such as data<a id="_idIndexMarker337"/> width, default header file paths, or <strong class="bold">Application Binary Interfaces</strong> (<strong class="bold">ABIs</strong>). Only with help from these <em class="italic">plumbers</em> can we use a compiler by just typing a few words:</p>
			<pre>$ clang hello_world.c -o hello_world</pre>
			<p>A <strong class="bold">compiler driver</strong> is <a id="_idIndexMarker338"/>software that organizes these <em class="italic">plumber</em> jobs. Despite having multiple different tasks to do during the compilation, we will only focus on two of the most important ones in this chapter – handling compiler flags and invoking the right tools on different platforms – which is what toolchains are designed for.</p>
			<p>The<a id="_idIndexMarker339"/> following <a id="_idIndexMarker340"/>diagram shows the interactions between the driver, the<a id="_idIndexMarker341"/> toolchains, and <a id="_idIndexMarker342"/>the rest of the compiler:</p>
			<div><div><img src="img/Figure_8.1_B14590.jpg" alt="Figure 8.1 – Typical workflow of Clang's driver, toolchains, and the rest of the compiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Typical workflow of Clang's driver, toolchains, and the rest of the compiler</p>
			<p>As shown in the preceding diagram, Clang's driver acts as <a id="_idIndexMarker343"/>a <em class="italic">dispatcher</em> and distributes flags and workloads to each of the compilation phases, namely the frontend/backend, the assembler, and the linker. To give you a more concrete idea of what the flags for each of these phases look like, recall the <code>-###</code> compiler option we introduced at the beginning of this chapter. The (massive amount of) content that's printed by that option is the flags for the frontend (<code>-internal-isystem</code> carries the information about the system header path, including the path where the C/C++ standard library header files are stored. It is obvious that Clang's frontend needs to know where the standard library headers are stored, but as per your past experiences of using <code>clang</code> (or <code>gcc</code>), you rarely <a id="_idIndexMarker344"/>need to tell them where those headers are <em class="italic">explicitly</em> – the driver will do that for you. The same logic applies to the linking phase as well. Linkers usually need <a id="_idIndexMarker345"/>more than just an object file to properly generate an executable or a library. For example, they need to know where the C/C++ standard library's library files (<code>*.a</code> or <code>*.so</code> on Unix/Linux systems) are. In that case, Clang's driver will provide that information to the linkers via linker flags.</p>
			<p>Flags and workloads – or <em class="italic">configurations</em>, in short – that<a id="_idIndexMarker346"/> are provided to individual compiler <a id="_idIndexMarker347"/>phases are <em class="italic">translated</em> from two sources: driver flags (<code>-c</code>, <code>-Wall</code>, and <code>-std=c++11</code>. In the next section, <em class="italic">Adding custom driver flags</em>, we will show you some examples of how Clang translates driver flags into frontend flags or even assembler/linker flags.</p>
			<p>On the other hand, a <code>/usr/include</code> and <code>/usr/lib</code>. Also, macOS X uses an executable format <a id="_idIndexMarker350"/>called <strong class="bold">Mach-O</strong>, which is different from Linux's ELF format. This greatly affects how compilers (Clang) build the code.</p>
			<p>For Clang to compile code for various platforms, it uses toolchains (which are effectively represented by the <code>ToolChain</code> C++ class internally) to encapsulate platform-specific information and configurations. In the early stage of compilation, Clang's driver selects a correct toolchain based on the system currently running (called <a id="_idIndexMarker351"/>the <code>-target=</code> driver flag to ask Clang to build a program for a specific platform that is different from the host system, which is effectively <a id="_idIndexMarker352"/>doing <code>ld64</code> and <code>lld</code> linkers for now, whereas Linux can use <code>ld</code> (BFD linker), <code>ld.gold</code>, and <code>lld</code> as linkers. Therefore, a toolchain should also specify what assembler and linker to use. In the last section of this chapter, <em class="italic">Adding a custom toolchain</em>, we will go through an example project to learn how Clang's toolchains work. Let's start our journey by learning how driver flags work in Clang.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor111"/>Adding custom driver flags</h1>
			<p>In the<a id="_idIndexMarker353"/> previous section, we explained the role of the driver and toolchains in Clang. In this section, we are going to learn how Clang's driver does this translation by adding a custom driver flag to Clang. Again, we will go through the overview for this example project first before demonstrating the detailed steps in a separate section.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor112"/>Project overview</h2>
			<p>The example<a id="_idIndexMarker354"/> project we will be using for this section is going to add a new driver flag so that when that flag is given by users, a header file will be <em class="italic">implicitly</em> included in the input code.</p>
			<p>To be more specific, here, we have a header file – <code>simple_log.h</code> – shown in the following code that defines some simple APIs to print log messages:</p>
			<pre>#ifndef SIMPLE_LOG_H
#define SIMPLE_LOG_H
#include &lt;iostream&gt;
#include &lt;string&gt;
#ifdef <strong class="bold">SLG_ENABLE_DEBUG</strong>
inline void <strong class="bold">print_debug</strong>(const std::string &amp;M) {
  std::cout &lt;&lt; "[DEBUG] " &lt;&lt; M &lt;&lt; std::endl;
}
#endif
#ifdef <strong class="bold">SLG_ENABLE_ERROR</strong>
inline void <strong class="bold">print_error</strong>(const std::string &amp;M) {
  std::cout &lt;&lt; "[ERROR] " &lt;&lt; M &lt;&lt; std::endl;
}
#endif
#ifdef <strong class="bold">SLG_ENABLE_INFO</strong>
inline void <strong class="bold">print_info</strong>(const std::string &amp;M) {
  std::cout &lt;&lt; "[INFO] " &lt;&lt; M &lt;&lt; std::endl;
}
#endif
#endif</pre>
			<p>The goal here is <a id="_idIndexMarker355"/>to use these APIs in our code <em class="italic">without</em> writing the <code>#include "simple_log.h"</code> line to import the header file. And this feature will only be enabled when we give a custom driver flag, <code>-fuse-simple-log</code>, to <code>clang</code>. For example, let's write the following code, <code>test.cc</code>:</p>
			<pre>int main() {
  <strong class="bold">print_info</strong>("Hello world!!");
  return 0;
}</pre>
			<p>Despite its lack of any <code>#include</code> directives, it can still be compiled (with the <code>-fuse-simple-log</code> flag) and run without any problems:</p>
			<pre>$ clang++ <strong class="bold">-fuse-simple-log</strong> test.cc -o test
$ ./test
[INFO] Hello world!!
$</pre>
			<p>Moreover, we <a id="_idIndexMarker356"/>can use <code>-fuse-&lt;log level&gt;-simple-log </code>/<code>-fno-use-&lt;log level&gt;-simple-log</code> to include or exclude a function for a specific log level. For example, let's use the same preceding code snippets but add <code>-fno-use-info-simple-log</code> when we compile the code:</p>
			<pre>$ clang++ -fuse-simple-log <strong class="bold">-fno-use-info-simple-log</strong> test.cc -o test
test.cc:2:3: <strong class="bold">error</strong>: use of undeclared identifier 'print_info'
  print_info("Hello World!!");
  ^
1 error generated
$</pre>
			<p>The switch for each log printing function is simply controlled by its surrounding <code>#ifdef</code> statements in <code>simple_log.h</code>. For example, <code>print_info</code> will only be included if <code>SLG_ENABLE_INFO</code> is defined. Later, in the <em class="italic">Translating custom driver flags</em> section, we will show you how these macro definitions are toggled by driver flags.</p>
			<p>Last but not least, you can specify a custom path to the <code>simple_log.h</code> file. By default, our feature will include <code>simple_log.h</code> in the current folder of the source code. You can change this by supplying <code>-fsimple-log-path=&lt;file path&gt;</code> or <code>-fuse-simple-log=&lt;file path&gt;</code>. For example, we want to use an alternative version of <code>simple_log.h</code> – <code>advanced_log.h</code>, which is stored in <code>/home/user</code> – which provides functions with the same interfaces but different implementations. Now, we can use the following commands:</p>
			<pre>$ clang++ <strong class="bold">-fuse-simple-log=/home/user/advanced_log.h</strong> test.cc -o test
[01/28/2021 20:51 PST][INFO] Hello World!!
$</pre>
			<p>The following section will show you how to change the code in Clang's driver so that you can implement these features.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor113"/>Declaring custom driver flags</h2>
			<p>First, we will lead <a id="_idIndexMarker357"/>you through the steps to <em class="italic">declare</em> custom driver flags such as <code>-fuse-simple-log</code> and <code>-fno-use-info-simple-log</code>. Then, we are going to <em class="italic">wire</em> those flags to the real frontend functionalities.</p>
			<p>Clang uses <strong class="bold">TableGen</strong> syntax to declare all kinds of compiler flags – both driver flags and frontend flags.</p>
			<p class="callout-heading">TableGen</p>
			<p class="callout"><strong class="bold">TableGen</strong> is a <strong class="bold">Domain-Specific Language</strong> (<strong class="bold">DSL</strong>) that's used for declaring structural and <a id="_idIndexMarker358"/>relational data. To learn<a id="_idIndexMarker359"/> more, please check out <a href="B14590_04_Final_JC_ePub.xhtml#_idTextAnchor052"><em class="italic">Chapter 4</em></a>, <em class="italic">TableGen Development</em>.</p>
			<p>All these flag declarations are put in <code>clang/include/clang/Driver/Options.td</code>. Take the common <code>-g</code> flag, for example, which tells you that you want to generate source-level debug information. For example, it has a declaration like this:</p>
			<pre>def g_Flag : <strong class="bold">Flag&lt;["-"], "g"&gt;</strong>, Group&lt;g_Group&gt;,
  HelpText&lt;"Generate source-level debug information"&gt;;</pre>
			<p>The TableGen record, <code>g_Flag</code>, is created from several TableGen classes: <code>Flag</code>, <code>Group</code>, and <code>HelpText</code>. Among them, we are most interested in <code>Flag</code>, whose template values (<code>["-"]</code> and <code>"g"</code>) describe the actual command-line flag format. Note that when we are declaring a <em class="italic">boolean</em> flag – the value of this flag is determined by its presence and no other values follow – as in this case, we inherit from the <code>Flag</code> class.</p>
			<p>In cases where we want to declare a flag that has values that follow an equal sign ("="), we inherit from the <code>Joined</code> class. For example, the TableGen declaration for <code>-std=&lt;C++ standard name&gt;</code> looks like this:</p>
			<pre>def std_EQ : <strong class="bold">Joined&lt;["-", "--"], "std="&gt;</strong>, Flags&lt;[CC1Option]&gt;, …;</pre>
			<p>Usually, the record names (<code>std_EQ</code>, in this case) for these kinds of flags have <code>_EQ</code> as their suffices.</p>
			<p>Last but not least, the <code>Flags</code> (plural) class can be used to specify some properties. For example, <code>CC1Options</code> in the preceding snippet tells us that this flag can also be a frontend flag.</p>
			<p>Now that we've <a id="_idIndexMarker360"/>learned how driver flags are generally declared, it is time to create our own:</p>
			<ol>
				<li>First, we are going to deal with the <code>-fuse-simple-log</code> flag. Here is how we declare it:<pre>def fuse_simple_log : Flag&lt;["-"], "fuse-simple-log"&gt;,
                  Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;</pre><p>This snippet basically has no differences from the examples we used previously, except for the <code>Group</code> class and <code>NoXarchOption</code>. The former specifies the <em class="italic">logical</em> group this flag belongs to – for example, <code>f_Group</code> is for flags starting with <code>-f</code>. The latter tells us that this flag can <em class="italic">only</em> be used in the driver. You cannot, for example, pass it to the frontend (but how do we pass flags directly to the frontend? We will answer this question shortly, at the end of this section).</p><p>Note that we only declare <code>-fuse-simple-log</code> here but not <code>-fuse-simple-log=&lt;file path&gt;</code> – that will be done in <em class="italic">another</em> flag that we will introduce shortly.</p></li>
				<li>Next, we are dealing with <code>-fuse-&lt;log level&gt;-simple-log</code> and <code>-fno-use-&lt;log level&gt;-simple-log</code>. In both GCC and Clang, it is pretty common to see pairwise flags such as <code>-f&lt;flag name&gt;</code>/<code>-fno-&lt;flag name&gt;</code> to enable or disable a certain feature. Therefore, Clang provides a handy TableGen utility – <code>BooleanFFlag</code> – to make creating pairwise flags easier. Please see the declarations for <code>-fuse-error-simple-log</code>/<code>-fno-use-error-simple-log</code> in the following code:<pre>defm use_error_simple_log : BooleanFFlag&lt;"use-error-simple-log"&gt;, Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;</pre><p><code>BooleanFFlag</code> is a <em class="italic">multiclass</em> (so make sure you use <code>defm</code> rather than <code>def</code> to create the TableGen record). Under the hood, it creates TableGen records for both <code>-f&lt;flag name&gt;</code> and <code>-fno-&lt;flag name&gt;</code> <em class="italic">at the same time</em>.</p><p>Now that we've<a id="_idIndexMarker361"/> learned how <code>use_error_simple_log</code> was created, we can use the same trick to create TableGen records for other log levels:</p><pre>defm use_debug_simple_log : BooleanFFlag&lt;"use-debug-simple-log"&gt;, Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;
defm use_info_simple_log : BooleanFFlag&lt;"use-info-simple-log"&gt;, Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;</pre></li>
				<li>Finally, we are declaring the <code>-fuse-simple-log=&lt;file path&gt;</code> and <code>-fsimple-log-path=&lt;file path&gt;</code> flags. In the previous steps, we were only dealing with boolean flags, but here, we are creating flags that have values that follow the equal sign, so we are using the <code>Joined</code> class we introduced earlier:<pre>def fsimple_log_path_EQ : Joined&lt;["-"], "fsimple-log-path="&gt;, Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;
def fuse_simple_log_EQ : Joined&lt;["-"], "fuse-simple-log="&gt;, Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;</pre><p>Again, flags with values will usually use <code>_EQ</code> in their TableGen record name suffix.</p></li>
			</ol>
			<p>That wraps up all the<a id="_idIndexMarker362"/> necessary steps for declaring our custom driver flags. During Clang's building process, these TableGen directives will be translated into C++ enums and other utilities that are used by the driver. For example, <code>-fuse-simple-log=&lt;file path&gt;</code> will be represented by an enum; that is, <code>options::OPT_fuse_simple_log_EQ</code>. The next section will show you how to query these flags from all the command-line flags given by users and, most importantly, how to translate our custom flags into their frontend counterparts.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor114"/>Translating custom driver flags</h2>
			<p>Recall that compiler<a id="_idIndexMarker363"/> drivers do a lot of things for users under the hood. For instance, they figure out the correct toolchain based on the compilation target and translate driver flags that have been designated by users, which is what we are going to do next. In our case here, we want to include the <code>simple_log.h</code> header file for users when our newly created <code>-fuse-simple-log</code> is given and define macro variables such as <code>SLG_ENABLE_ERROR</code> to include or exclude certain log printing functions, depending on the <code>-fuse-&lt;log level&gt;-simple-log</code>/<code>-fno-use-&lt;log level&gt;-simple-log</code> flags. More specifically, these tasks can be broken down into two parts:</p>
			<ul>
				<li>If <code>-fuse-simple-log</code> is given, we are translating it into a frontend flag:<pre><code>-include</code> frontend flag, as its name suggests, <em class="italic">implicitly</em> includes the designated file in the compiling source code.</p><p>Using the same logic, if <code>-fuse-simple-log=/other/file.h</code> or <code>-fuse-simple-log -fsimple-log-path=/other/file.h</code> are given, they will be translated into the following:</p><pre>-include <strong class="bold">"/other/file.h"</strong></pre></li>
				<li>If either <code>-fuse-&lt;log level&gt;-simple-log</code> or <code>-fno-use-&lt;log level&gt;-simple-log</code> is given – for instance, <code>-fuse-error-simple-log</code> – it will be<a id="_idTextAnchor115"/> translated into the following:<pre><code>-D</code> flag implicitly defines a macro variable for the compiling source code.</p><p>However, if only <code>-fuse-simple-only</code> is given, the flag will implicitly include all the log printing functions. In other words, <code>-fuse-simple-only</code> will not only be translated into the <code>-include</code> flag, as introduced in previous bullet point, but also the following flags:</p><pre>-D <code>-fuse-simple-log</code> and <code>-fno-use-&lt;log level&gt;-simple-log</code> are used together, for example:</p><pre>-fuse-simple-log -fno-use-error-simple-log</pre><p>They will be<a id="_idIndexMarker364"/> translated into the following code:</p><pre>-include "simple_log.h" -D SLG_ENABLE_DEBUG -D SLG_ENABLE_INFO</pre><p>Last but not least, we also allow the following combinations:</p><pre>-fuse-info-simple-log -fsimple-log-path="my_log.h"</pre><p>That is, we only enable a single log printing function without using <code>-fuse-simple-log</code> (instead of using the latter flag and subtracting two other log printing functions) and use a custom simple log header file. These driver flags will be translated into the following code:</p><pre>-include "my_log.h" -D SLG_ENABLE_INFO</pre><p>The aforementioned rules and combinations of flags can actually be handled in a pretty elegant way, albeit being complex at first glance. We will show you how to do this shortly.</p></li>
			</ul>
			<p>Now that we have learned <em class="italic">what</em> frontend flags we are going to translate to, it is time to learn <em class="italic">how</em> to do these translations.</p>
			<p>The place where many driver flags translations happen is inside the <code>driver::tools::Clang</code> C++ class. More specifically, this happens in its <code>Clang::ConstructJob</code> method, which is located in the <code>clang/lib/Driver/ToolChains/Clang.cpp</code> file.</p>
			<p class="callout-heading">About driver::tools::Clang</p>
			<p class="callout">Some of the most prominent questions for this C++ class are probably, what <em class="italic">concept</em> does it represent? Why is it put under the folder named <em class="italic">ToolChains</em>? Does that mean it is also a toolchain? While we will answer these questions in detail in the next section, <em class="italic">Adding a custom toolchain</em>, for now, you can just think of it as the representative of Clang's frontend. This (kind of) explains why it is responsible for translating driver flags into frontend ones.</p>
			<p>Here are the <a id="_idIndexMarker365"/>steps to translate our custom driver flags. The following code can be inserted anywhere within the <code>Clang::ConstructJob</code> method, before the <code>addDashXForInput</code> function is called, which starts to wrap up the translation process:</p>
			<ol>
				<li value="1">First, we are defining a help class – <code>SimpleLogOpts</code> – to carry our custom flag's information:<pre>struct SimpleLogOpts {
  // If a certain log level is enabled
  bool Error = false,
       Info = false,
       Debug = false;
  static inline SimpleLogOpts All() { 
    return {true, true, true};
  }
  // If any of the log level is enabled
  inline operator bool() const {
    return Error || Info || Debug;
  }
};
// The object we are going to work on later
SimpleLogOpts SLG;</pre><p>The <code>bool</code> fields in <code>SimpleLogOpts</code> – <code>Error</code>, <code>Info</code>, and <code>Debug</code> – represent log levels that are enabled by our custom flags. We also define a helper function <code>SimpleLogOpts::All()</code> to create a <code>SimpleLogOpts</code> in which all log levels are enabled, and a <code>bool</code> type conversion operator such that we can use a cleaner <a id="_idIndexMarker366"/>syntax, shown here, to tell us if any of the levels are enabled:</p><pre>if (SLG) {
  // At least one log level is enabled!
}</pre></li>
				<li>Let's handle the simplest case first – the <code>-fuse-simple-log</code> flag. In this step, we are only going to turn on all the log levels in <code>SLG</code> when we see a <code>-fuse-simple-log</code> flag.<p>Inside the <code>Clang::ConstructJob</code> method, the driver flags given by users are stored in the <code>Args</code> variable (one of the arguments for <code>ConstructJob</code>), which is of the <code>ArgList</code> type. There are many ways to query <code>Args</code>, but here, since we only care about the <em class="italic">presence</em> of <code>-fuse-simple-log</code>, <code>hasArg</code> is the most suitable option:</p><pre>if (Args.hasArg(options::OPT_fuse_simple_log)) {
  SLG = SimpleLogOpts::All();
}</pre><p>Each flag we declared in the previous code via TableGen syntax will be represented by a unique <em class="italic">enum</em> under the <code>options</code> namespace. In this case, the enum value is <code>OPT_fuse_simple_log</code>. The name of the enum value is usually <code>OPT_</code>, followed by the <code>def</code> or <code>defm</code>) when we were declaring the flag. The <code>ArgList::hasArg</code> function will return true if the given flag identifier is present in the input driver flags.</p><p>In <a id="_idIndexMarker367"/>addition to <code>-fuse-simple-log</code>, we also need to turn on all the log levels when <code>-fuse-simple-log=&lt;file path&gt;</code> is given, even though we are only going to handle the file path that follows later. Thus, we will change the preceding snippet into the following:</p><pre>if (Args.hasArg(options::OPT_fuse_simple_log,
                options::OPT_fuse_simple_log_EQ)) {
  SLG = SimpleLogOpts::All();
}</pre><p><code>ArgList::hasArg</code> can actually take multiple flag identifiers and return true if <em class="italic">any</em> of them are present in the input driver flags. And again, the <code>-fuse-simple-log=&lt;…&gt;</code> flag is represented by <code>OPT_fuse_simple_log_EQ</code> since its TableGen record name is <code>fuse_simple_log_EQ</code>.</p></li>
				<li>Next, we are going to handle <code>-fuse-&lt;log level&gt;-simple-log</code>/<code>-fno-use-&lt;log level&gt;-simple-log</code>. Taking the error level, as an example (flags for other levels are used in the exact same way, so we are not showing them here), here, we are leveraging the <code>ArgList::hasFlag</code> function:<pre>SLG.Error = Args.hasFlag(options::OPT_fuse_error_simple_log, options::OPT_fno_use_error_simple_log, SLG.Error);</pre><p>The <code>hasFlag</code> function will return true or false if the flag that's represented by the first (<code>OPT_fuse_error_simple_log</code> here) or second (<code>OPT_fno_use_error_simple_log</code> here) argument is present in the input driver flags, respectively.</p><p>If <em class="italic">neither</em> of the flags are present, <code>hasFlag</code> will return a default value that's designated by its third argument (<code>SLG.Error</code>, in this case).</p><p>Using this mechanism, we have already implemented some of the (complex) rule and flag combinations we mentioned earlier in this section:</p><p>a) The <code>-fno-use-&lt;log level&gt;-simple-log</code> flags can disable certain log printing function(s) when <code>-fuse-simple-log</code> – which effectively includes all the log printing functions in the first place – is present.</p><p>b) Even <em class="italic">without</em> the presence of <code>-fuse-simple-log</code>, we can still enable individual log printing functions by using the <code>-fuse-&lt;log level&gt;-simple-log</code> flag(s).</p></li>
				<li>Currently, we <a id="_idIndexMarker368"/>are only playing around with the <code>SimpleLogOpts</code> data structure. Starting from the next step, we will start to generate frontend flags according to the <code>SimpleLogOpts</code> instance we have built so far. The first frontend flag we are generating here is <code>-include &lt;file path&gt;</code>. First, it only makes sense to proceed if at least one log level has been enabled. Therefore, we will wrap the generation of <code>-include</code> with an <code>if</code> statement by checking on <code>SLG</code>, as we explained earlier:<pre>if (SLG) {
  CmdArgs.push_back("-include");
  …
}</pre><p>The <code>CmdArgs</code> (a local variable – with a vector-like type – inside <code>Clang::ConstructJob</code>) is the place where we will put our <code>CmdArgs</code>) will be treated as <code>argv</code>, which we can see in the <code>main</code> function of C/C++, and any white space within a single argument will create failures when those arguments are realized.</p><p>Instead, we are <a id="_idIndexMarker369"/>pushing the path to a simple log header file <em class="italic">separately</em>, as follows:</p><pre>if (SLG) {
  CmdArgs.push_back("-include");
  if (Arg *A = Args.getLastArg(options::OPT_fuse_simple_  log_EQ, options::OPT_fsimple_log_path_EQ))
    CmdArgs.push_back(A-&gt;getValue());
  else
    CmdArgs.push_back("simple_log.h");
  …
}</pre><p>The <code>ArgList::getLastArg</code> function will retrieve the value (the last value, if there are multiple occurrences of the same flag), follow a given flag, and return null if none of those flags are present. For instance, in this case, the flag is <code>-fuse-simple-log=</code> (<code>-fsimple-log-path=</code> in the second argument is just the <em class="italic">alias</em> flag of the first one).</p></li>
				<li>Finally, we are generating frontend flags that control which log printing functions should be enabled. Again, we are only showing the code for one of the log levels here since other levels are using the same approach:<pre>if (SLG) {
  …
  if (SLG.Error) {
    CmdArgs.push_back("-D");
    CmdArgs.push_back("SLG_ENABLE_ERROR");
  }
  …
}</pre></li>
			</ol>
			<p>These are basically <a id="_idIndexMarker370"/>all the modifications that are required for our project. The final thing we must do before we move on is verify our work. Recall the <code>-###</code> command-line flag, which is used to print all the flags that are passed to the frontend. We are using it here to see if our custom driver flags are translated pr<a id="_idTextAnchor116"/>operly.</p>
			<p>First, let's try this command:</p>
			<pre>$ clang++ <strong class="bold">-###</strong> <strong class="bold">-fuse-simple-log</strong> -c test.cc</pre>
			<p>The output should contain these strings:</p>
			<pre>"-include" "simple_log.h" "-D" "SLG_ENABLE_ERROR" "-D" "SLG_ENABLE_INFO" "-D" "SLG_ENABLE_DEBUG"</pre>
			<p>Now, let's try the following command:</p>
			<pre>$ clang++ -### <strong class="bold">-fuse-simple-log=my_log.h</strong> <strong class="bold">-fno-use-error-simple-log</strong> -c test.cc</pre>
			<p>Tthe output should contain these strings:</p>
			<pre>"-include" "<strong class="bold">my_log.h</strong>" "-D" "SLG_ENABLE_INFO" "-D" "SLG_ENABLE_DEBUG"</pre>
			<p>Finally, let's use the following command:</p>
			<pre>$ clang++ -### <strong class="bold">-fuse-info-simple-log</strong> <strong class="bold">-fsimple-log-path=my_log.h</strong> -c test.cc</pre>
			<p>The output <a id="_idIndexMarker371"/>should contain the following strings :</p>
			<pre>"-include" "<strong class="bold">my_log.h</strong>" "-D" "SLG_ENABLE_INFO"</pre>
			<p>In the last subsection of this section, we are going to talk about some miscellaneous ways to pass flags to the frontend.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor117"/>Passing flags to the frontend</h2>
			<p>In the previous <a id="_idIndexMarker372"/>sections, we showed you the differences between driver flags and frontend flags, how they are related, and how Clang's driver translates the former into the latter. At this point, you might be wondering, can we skip through the driver and pass the flags directly to the frontend? What flags are we allowed to pass?</p>
			<p>The short answer for the first question is <em class="italic">yes, and you have actually already done that several times in previous chapters</em>. Recall that in <a href="B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling AST</em>, we developed a plugin – more specifically, an AST plugin. We were using command-line arguments like the one shown here to load and run our plugin inside Clang:</p>
			<pre>$ clang++ -fplugin=MyPlugin.so \
          <strong class="bold">-Xclang</strong> -plugin <strong class="bold">-Xclang</strong> ternary-converter \
          -fsyntax-only test.cc</pre>
			<p>You might already find that, somehow, we need to precede a <code>-Xclang</code> flag before the <code>-plugin</code> and <code>ternary-converter</code> arguments. And the answer is simple: this is because <code>-plugin</code> (and its value, <code>ternary-converter</code>) is a <em class="italic">frontend-only</em> flag.</p>
			<p>To pass a flag directly to the frontend, we can put <code>-Xclang</code> in front of it. But there is a caveat of using <code>-Xclang</code>: a single <code>-Xclang</code> will only relay <em class="italic">one</em> succeeding command-line argument (a string without any whitespace) to the frontend. In other words, you cannot rewrite the preceding plugin loading example like this:</p>
			<pre># Error: `ternary-converter` will not be recognized
$ clang++ -fplugin=MyPlugin.so \
          <strong class="bold">-Xclang -plugin ternary-converter</strong> \
          -fsyntax-only test.cc</pre>
			<p>This is because <code>-Xclang</code> will only transfer <code>-plugin</code> to the frontend and leave <code>ternary-converter</code> behind, in which case Clang will fail to know which plugin to run.</p>
			<p>Another way to<a id="_idIndexMarker373"/> pass flags directly to the frontend would be using <code>-cc1</code>. Recall that when we were using <code>-###</code> to print out the frontend flags that had been translated by the driver in the previous sections, among those frontend flags, the first one that followed the path to the <code>clang</code> executable was always <code>-cc1</code>. This flag effectively collects all the command-line arguments and sends them to the frontend. Though this looks handy – there's no need to prefix every flag we want to pass to the frontend with <code>-Xclang</code> anymore – be careful that you are not allowed to mix any <em class="italic">driver-only</em> flags inside that list of flags. For example, earlier in this section, when we were declaring our <code>-fuse-simple-log</code> flag in TableGen syntax, we annotated the flag with <code>NoXarchOption</code>, which stated that it can only be used by the driver. In that case, <code>-fuse-simple-log</code> cannot appear after <code>-cc1</code>.</p>
			<p>This leads us to our final question: what flags can be used by either the driver or the frontend, and what flags are accepted by both? The answer can actually be seen via <code>NoXarchOption</code>, which was just mentioned. When declaring flags – either for the driver or the frontend – in TableGen syntax, you can use the <code>Flags&lt;…&gt;</code> TableGen class and its template parameters to enforce some constraints. For instance, using the following directives, you can <em class="italic">prevent</em> the <code>-foo</code> flag from being used by the driver:</p>
			<pre>def foo : Flag&lt;["-"], "foo"&gt;, <strong class="bold">Flags</strong>&lt;[<strong class="bold">NoDriverOption</strong>]&gt;;</pre>
			<p>In addition to <code>NoXarchOption</code> and <code>NoDriverOption</code>, here are some other common annotations you can use in <code>Flags&lt;…&gt;</code>:</p>
			<ul>
				<li><code>CoreOption</code>: States that this flag can be shared by both <code>clang</code> and <code>clang-cl</code>. <code>clang-cl</code> is an interesting driver that is compatible with the command-line interface (including command-line arguments) used<a id="_idIndexMarker374"/> by <strong class="bold">MSVC</strong> (the compiler framework used by Microsoft Visual Studio).</li>
				<li><code>CC1Option</code>: States that this flag can be accepted by the frontend. It doesn't say it's a frontend-only flag, though.</li>
				<li><code>Ignored</code>: States that this flag is going to be ignored by Clang's driver (but continue the compilation process). GCC has many flags that are not supported in Clang (either obsolete or just not applicable). However, Clang actually tries to <em class="italic">recognize</em> those flags but does nothing except show a warning message about a lack of implementation. The rationale behind this is we hope that Clang can be a <em class="italic">drop-in</em> replacement for<a id="_idIndexMarker375"/> GCC without the need to modify the existing building scripts in many projects (without this compatibility layer, Clang will terminate the compilation when it sees unknown flags).</li>
			</ul>
			<p>In this section, we learned how to add custom flags for Clang's driver and implemented the logic to translate them into frontend flags. This skill is pretty useful when you want to toggle custom features in a more straightforward and clean way.</p>
			<p>In the next section, we are going to learn the role of a toolchain and how it works in Clang by creating our own custom one.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor118"/>Adding a custom toolchain</h1>
			<p>In the previous<a id="_idIndexMarker376"/> section, we learned how to add custom flags for the driver in Clang and learned how the driver translated them into flags that are accepted by the frontend. In this section, we are going to talk about the toolchain – an important module inside the driver that helps it adapt to different platforms.</p>
			<p>Recall that in the first section of this chapter, <em class="italic">Understanding drivers and toolchains in Clang</em>, we showed the relationships between driver and toolchains in <em class="italic">Figure 8.1</em>: the driver chooses a proper toolchain based on the target platform before leveraging its knowledge to do the following:</p>
			<ol>
				<li value="1">Execute the correct <em class="italic">assembler</em>, <em class="italic">linker</em>, or any tool that is required for the target code's generation.</li>
				<li>Pass <em class="italic">platform-specific</em> flags to the compiler, assembler, or linker.</li>
			</ol>
			<p>This information is crucial for building the source code since each platform might have its own unique characteristics, such as system library paths and supported assembler/linker variants. Without them, a correct executable or library cannot even be generated.</p>
			<p>This section hopes to teach you how to create Clang toolchains for custom platforms in the future. The toolchain framework in Clang is powerful enough to be adapted to a wide variety of use cases. For example, you can create a toolchain that resembles conventional compilers on Linux – including using GNU AS to assemble and GNU LD for linking – without you needing to make many customizations to a default library path or compiler flags. On the other hand, you can have an exotic toolchain that does not even use Clang to compile source code and uses a propriety assembler and linker with uncommon command-line flags. This section will try to use an example that catches the most common use cases without missing this framework's flexible aspect.</p>
			<p>This section is<a id="_idIndexMarker377"/> organized as follows: as usual, we will start with an overview of the project we are going to work on. After that, we will break down our project workload into three parts – adding custom compiler options, setting up a custom assembler, and setting up a custom linker – before we put them together to wrap up this section.</p>
			<p class="callout-heading">System requirements</p>
			<p class="callout">As another friendly reminder, the following project can only work on Linux systems. Please make sure OpenSSL is installed.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor119"/>Project overview</h2>
			<p>We are going to <a id="_idIndexMarker378"/>create a toolchain<a id="_idIndexMarker379"/> called <code>.tarbell</code> file) during the linking phase.</p>
			<p class="callout-heading">Base64</p>
			<p class="callout"><strong class="bold">Base64</strong> is an<a id="_idIndexMarker380"/> encoding scheme that is commonly used to convert binary into plain text. It can be easily transmitted in a context that does not support binary format (for example, HTTP headers). You can also apply Base64 to normal textual files, just like in our case.</p>
			<p>This toolchain is basically useless in production environments. It's merely a demo that emulates common situations a developer might encounter when they're creating a new toolchain for custom platforms.</p>
			<p>This toolchain is<a id="_idIndexMarker381"/> enabled by a custom driver flag, <code>-zipline</code>/<code>--zipline</code>. When the flag is provided, first, the compiler will implicitly add the <code>my_include</code> folder to your home directory as one of the header files searching the path. For example, recall that in the previous section, <em class="italic">Adding custom driver flags</em>, our custom <code>-fuse-simple-log</code> flag would implicitly include a header file, <code>simple_log.h</code>, in the input source code:</p>
			<pre>$ ls
main.cc <strong class="bold">simple_log.h</strong>
$ clang++ <strong class="bold">-fuse-simple-log</strong> -fsyntax-only main.cc
$ # OK</pre>
			<p>However, if <code>simple_log.h</code> is not in the current directory, as in the preceding snippet, we need to specify its full path via another flag:</p>
			<pre>$ ls .
# No simple_log.h in current folder
main.cc
$ clang++ <strong class="bold">-fuse-simple-log=/path/to/simple_log.h</strong> -fsyntax-only main.cc
$ # OK</pre>
			<p>With the help of Zipline, you can put <code>simple_log.h</code> inside <code>/home/&lt;user name&gt;/my_include</code>, and the compiler will find it:</p>
			<pre>$ ls .
# No simple_log.h in current folder
main.cc
$ ls ~/my_include
simple_log.h
$ clang++ <strong class="bold">-zipline</strong> -fuse-simple-log -fsyntax-only main.cc
$ # OK</pre>
			<p>The second<a id="_idIndexMarker382"/> feature of Zipline is that the <code>clang</code> executable will compile the source code into assembly code that's encoded by Base64 under the <code>-c</code> flag, which <em class="italic">was</em> supposed to assemble the assembly file – coming out from the compiler – into an object file. Here is an example command:</p>
			<pre>$ clang <strong class="bold">-zipline</strong> -c test.c
$ file <strong class="bold">test.o</strong>
test.o: <strong class="bold">ASCII</strong> text # Not (binary) object file anymore
$ cat <strong class="bold">test.o</strong>
CS50ZXh0CgkuZmlsZQkidGVzdC5jYyIKCS 5nbG9ibAlfWjNmb29pCgkucDJhbGln
bgk0LCAweDkwCgkudHlwZQlfWjNmb29p LEBmdW5jdGlvbgpfWjNmb29pOgoJLmNm
… # Base64 encoded contents
$</pre>
			<p>The preceding <code>file</code> command showed that the generated file, <code>test.o</code>, from the previous invocation of <code>clang</code>, is no longer a binary format object file. The content of this file is now a Base64-encoded version of the assembly code that was generated from the compiler's backend.</p>
			<p>Finally, Zipline replaces the original linking stage with a custom one that packages and compresses the aforementioned Base64-encoded assembly files into a <code>.zip</code> file. Here is an example:</p>
			<pre>$ clang -zipline test.c <strong class="bold">-o test.zip</strong>
$ file test.zip
test.zip: <strong class="bold">Zip archive</strong>, at least v2.0 to extract
$</pre>
			<p>If you unzip <code>test.zip</code>, you will find that those extracted files are Base64-encoded assembly files, as we mentioned earlier.</p>
			<p>Alternatively, we can<a id="_idIndexMarker383"/> use Linux's <code>tar</code> and <code>gzip</code> utilities to package and compress them in Zipline. Let's look at an example:</p>
			<pre>$ clang -zipline <strong class="bold">-fuse-ld=tar</strong> test.c -o <strong class="bold">test.tar.gz</strong>
$ file test.tar.gz
test.tar.gz: <strong class="bold">gzip compressed data</strong>, from Unix, original size…
$</pre>
			<p>By using the existing <code>-fuse-ld=&lt;linker name&gt;</code> flag, we can choose between using <code>zip</code> or <code>tar</code> and <code>gzip</code> for our custom linking phase.</p>
			<p>In the next section, we are going to create the skeleton code for this toolchain and show you how to add an additional folder to the header file searching path.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor120"/>Creating the toolchain and adding a custom include path</h2>
			<p>In this section, we<a id="_idIndexMarker384"/> are going to create the skeleton for our Zipline toolchain and<a id="_idIndexMarker385"/> show you how to add an extra include folder path – more specifically, an extra <strong class="bold">system include path</strong> – to the <a id="_idIndexMarker386"/>compilation stage within Zipline. Here are the detailed steps:</p>
			<ol>
				<li value="1">Before we add a real toolchain implementation, don't forget that we are going to use a custom driver flag, <code>-zipline</code>/<code>--zipline</code>, to enable our toolchain. Let's use the same skill we learned in the previous section, <em class="italic">Adding custom driver flags</em>, to do that. Inside <code>clang/include/clang/Driver/Options.td</code>, we will add the following lines:<pre>// zipline toolchain
def zipline : Flag&lt;["-", "--"], "zipline"&gt;,
              Flags&lt;[NoXarchOption]&gt;; </pre><p>Again, <code>Flag</code> tells us this is a boolean flag and <code>NoXarchOption</code> tells us that this flag is driver-only. We will use this driver flag shortly.</p></li>
				<li>Toolchains in Clang are represented by the <code>clang::driver::ToolChain</code> class. Each toolchain supported by Clang is derived from it, and their source files are put <a id="_idIndexMarker387"/>under the <code>clang/lib/Driver/ToolChains</code> folder. We are going to create two new files there: <code>Zipline.h</code> and <code>Zipline.cpp</code>.</li>
				<li>For <code>Zipline.h</code>, let's add<a id="_idIndexMarker388"/> the following skeleton code first:<pre>namespace clang {
namespace driver {
namespace toolchains {
struct LLVM_LIBRARY_VISIBILITY ZiplineToolChain 
  : public Generic_ELF {
  ZiplineToolChain(const Driver &amp;D, const llvm::Triple    &amp;Triple, const llvm::opt::ArgList &amp;Args)
    : Generic_ELF(D, Triple, Args) {}
  ~ZiplineToolChain() override {}
  // Disable the integrated assembler
  bool IsIntegratedAssemblerDefault() const override
    { return false; }
  bool useIntegratedAs() const override { return false; }
  void
  AddClangSystemIncludeArgs(const llvm::opt::ArgList    &amp;DriverArgs, llvm::opt::ArgStringList &amp;CC1Args) 
    const override;
protected:
  Tool *buildAssembler() const override;
  Tool *buildLinker() const override;
};
} // end namespace toolchains
} // end namespace driver
} // end namespace clang</pre><p>The class we created here, <code>ZiplineToolChain</code>, is derived from <code>Generic_ELF</code>, which is a subclass of <code>ToolChain</code> that's specialized for systems that use ELF<a id="_idIndexMarker389"/> as its execution format – including Linux. In addition<a id="_idIndexMarker390"/> to the parent class, there are three important methods that we are going to implement in this or later sections: <code>AddClangSystemIncludeArgs</code>, <code>buildAssembler</code>, and <code>buildLinker</code>.</p></li>
				<li>The <code>buildAssembler</code> and <code>buildLinker</code> methods generate <code>Tool</code> instances that represent the <code>AddClangSystemIncludeArgs</code> method. Inside <code>Zipline.cpp</code>, we will add its method body:<pre>void ZiplineToolChain::AddClangSystemIncludeArgs(
                       const ArgList &amp;DriverArgs,
                       ArgStringList &amp;CC1Args) const {
  using namespace llvm;
  SmallString&lt;16&gt; CustomIncludePath;
  sys::fs::expand_tilde("~/my_include",                         CustomIncludePath);
  addSystemInclude(DriverArgs,
                   CC1Args, CustomIncludePath.c_str());
}</pre><p>The only thing we are doing here is calling the <code>addSystemInclude</code> function with the full path to the <code>my_include</code> folder located in the home directory. Since each user's home directory is different, we are using the <code>sys::fs::expand_tilde</code> helper function to expand <code>~/my_include</code> – where <code>~</code> represents the home directory in Linux and Unix systems – in the absolute path. The <code>addSystemInclude</code> function, on the other hand, helps you add <code>"-internal-isystem" "/path/to/my_include"</code> flags to the list of all the<a id="_idIndexMarker391"/> frontend flags. The <code>-internal-isystem</code> flag is used <a id="_idIndexMarker392"/>for designating folders of system header files, including standard library headers and some platform-specific header files.</p></li>
				<li>Last but not least, we need to teach the driver to use the Zipline toolchain when it sees our newly created <code>-zipline</code>/<code>--zipline</code> driver flag. We are going to modify the <code>Driver::getToolChain</code> method inside <code>clang/lib/Driver/Driver.cpp</code> to do so. The <code>Driver::getToolChain</code> method contains a huge switch case for selecting different toolchains based on the target operating system and hardware architecture. Please navigate to the code handling the Linux system; we are going to add an extra branch condition there:<pre>const ToolChain
&amp;Driver::getToolChain(const ArgList &amp;Args,
                      const llvm::Triple &amp;Target) const {
  …
  switch (Target.getOS()) {
  case llvm::Triple::Linux:
  …
    else if (Args.hasArg(options::OPT_zipline))
     TC = std::make_unique&lt;toolchains::ZiplineToolChain&gt;     (*this, Target, Args);
  …
    break;
  case …
  case …
  }
}</pre><p>The extra <code><a id="_idIndexMarker393"/></code><code>else-if</code> statement basically says that if the target OS is<a id="_idIndexMarker394"/> Linux, then we will use Zipline when the <code>-zipline</code>/<code>--zipline</code> flag is given.</p></li>
			</ol>
			<p>With that, you have added the skeleton of Zipline and successfully told the driver to use Zipline when a custom driver flag is given. On top of that, you've also learned how to add extra system library folders to the header file search path.</p>
			<p>In the next section, we are going to create a custom assembling stage and connect it to the toolchain we created here.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor121"/>Creating a custom assembling stage</h2>
			<p>As we <a id="_idIndexMarker395"/>mentioned in the <em class="italic">Project overview</em> section, instead of doing regular assembling to convert assembly code into an object file in the assembling stage of Zipline, we are invoking a program to convert the assembly file we generated from Clang into its Base64-encoded counterpart. Before we go deeper into its implementation, let's learn how each of these <em class="italic">stages</em> in a toolchain is represented.</p>
			<p>In the previous section, we learned that a toolchain in Clang is represented by the <code>ToolChain</code> class. Each of these <code>ToolChain</code> instances is responsible for telling the driver what <em class="italic">tool</em> to run in each compilation stage – namely compiling, assembling, and linking. And this information is encapsulated inside a <code>clang::driver::Tool</code> type object. Recall the <code>buildAssembler</code> and <code>buildLinker</code> methods in the previous section; they return the very <code>Tool</code> type objects that depict the actions to perform and the tool to run in the assembling and linking stages, respectively. In this section, we will show you how to implement the <code>Tool</code> object that's returned by <code>buildAssembler</code>. Let's get started:</p>
			<ol>
				<li value="1">Let's go back to <code>Zipline.h</code> first. Here, we are adding an extra class, <code>Assembler</code>, inside the <code>clang::driver::tools::zipline</code> namespace:<pre>namespace clang {
namespace driver {
namespace tools {
namespace zipline {
struct LLVM_LIBRARY_VISIBILITY Assembler : public Tool {
  Assembler(const ToolChain &amp;TC)
    : Tool("zipeline::toBase64", "toBase64", TC) {}
  bool hasIntegratedCPP() const override { return false; }
  void ConstructJob(Compilation &amp;C, const JobAction &amp;JA,
                    const InputInfo &amp;Output,
                    const InputInfoList &amp;Inputs,
                    const llvm::opt::ArgList &amp;TCArgs,
                    const char *LinkingOutput) const                     override;
};
} // end namespace zipline
} // end namespace tools
namespace toolchains {
struct LLVM_LIBRARY_VISIBILITY ZiplineToolChain … {
…
};
} // end namespace toolchains
} // end namespace driver
} // end namespace clang</pre><p>Be <a id="_idIndexMarker396"/>careful because the newly created <code>Assembler</code> resides in the <code>clang::driver::tools::zipline</code> namespace, while <code>ZiplineToolChain</code>, which we created in the previous section, is in <code>clang::driver::toolchains</code>.</p><p>The <code>Assembler::ConstructJob</code> method is where we will put our logic for invoking Base64 encoding tools.</p></li>
				<li>Inside <code>Zipline.cpp</code>, we will<a id="_idIndexMarker397"/> implement the method body of <code>Assembler::ConstructJob</code>:<pre>void
tools::zipline::Assembler::ConstructJob(Compilation &amp;C,
                            const JobAction &amp;JA,
                            const InputInfo &amp;Output,
                            const InputInfoList &amp;Inputs,
                            const ArgList &amp;Args,
                            const char *LinkingOutput)                            const {
                            ArgStringList CmdArgs;
                            const InputInfo &amp;II =                             Inputs[0];
  std::string Exec =
    Args.MakeArgString(getToolChain().     GetProgramPath("openssl"));
  // opeenssl base64 arguments
  CmdArgs.push_back("base64");
  CmdArgs.push_back("-in");
  CmdArgs.push_back(II.getFilename());
  CmdArgs.push_back("-out");
  CmdArgs.push_back(Output.getFilename());
  
  C.addCommand(
    std::make_unique&lt;Command&gt;(
           JA, *this, ResponseFileSupport::None(),
           Args.MakeArgString(Exec), CmdArgs,
           Inputs, Output));
}</pre><p>We are <a id="_idIndexMarker398"/>using OpenSSL to do the Base64 encoding, and the command we hope to run is as follows:</p><pre>$ openssl base64 -in &lt;input file&gt; -out &lt;output file&gt;</pre><p>The job of the <code>ConstructJob</code> method is building a <em class="italic">program invocation</em> to run the previous command. It is realized by the <code>C.addCommand(…)</code> function call at the very end of <code>ConstructJob</code>. The <code>Command</code> instance that's passed to the <code>addCommand</code> call represents the concrete command to be run during the assembling stage. It contains necessary information such as the path to the program executable (the <code>Exec</code> variable) and its arguments (the <code>CmdArgs</code> variable).</p><p>For the <code>Exec</code> variable, the toolchain has provided a handy utility, the <code>GetProgramPath</code> function, to resolve the absolute path of an executable for you.</p><p>The way we build arguments for <code>openssl</code> (the <code>CmdArgs</code> variable), on the other hand, is very similar to the thing we did in the <em class="italic">Adding custom driver flags</em> section: translating driver flags (the <code>Args</code> argument) and the input/output file information (the <code>Output</code> and <code>Inputs</code> argument) into a new set of command-line arguments and storing them in <code>CmdArgs</code>.</p></li>
				<li>Finally, we <a id="_idIndexMarker399"/>connect this <code>Assembler</code> class with <code>ZiplineToolChain</code> by implementing the <code>ZiplineToolChain::buildAssembler</code> method:<pre>Tool *ZiplineToolChain::buildAssembler() const {
  return new tools::zipline::Assembler(*this);
}</pre></li>
			</ol>
			<p>These are all the<a id="_idIndexMarker400"/> steps we need to follow to create a <code>Tool</code> instance that represents the command to run during the linking stage of our Zipline toolchain.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor122"/>Creating a custom linking stage</h2>
			<p>Now that we've<a id="_idIndexMarker401"/> finished the assembler stage, it's time to move on to the next stage – the linking stage. We are going to use the same approach we used in the previous section; that is, we will create a custom <code>Tool</code> class representing the linker. Here are the steps:</p>
			<ol>
				<li value="1">Inside <code>Zipline.h</code>, create a <code>Linker</code> class that is derived from <code>Tool</code>:<pre>namespace zipline {
struct LLVM_LIBRARY_VISIBILITY Assembler : public Tool {
…
};
struct LLVM_LIBRARY_VISIBILITY Linker : public Tool {
  Linker(const ToolChain &amp;TC)
    : Tool("zipeline::zipper", "zipper", TC) {}
  bool hasIntegratedCPP() const override { return false; }
  bool isLinkJob() const override { return true; }
  void ConstructJob(Compilation &amp;C, const JobAction &amp;JA,
                    const InputInfo &amp;Output,
                    const InputInfoList &amp;Inputs,
                    const llvm::opt::ArgList &amp;TCArgs,
                    const char *LinkingOutput) const                     override;
private:
  void buildZipArgs(const JobAction&amp;, const InputInfo&amp;,
                    const InputInfoList&amp;,
                    const llvm::opt::ArgList&amp;, 
                    llvm::opt::ArgStringList&amp;) const;
  void buildTarArgs(const JobAction&amp;,
                    const InputInfo&amp;,                     const InputInfoList&amp;,
                    const llvm::opt::ArgList&amp;, 
                    llvm::opt::ArgStringList&amp;) const;
};
} // end namespace zipline</pre><p>In this <code>Linker</code> class, we also need to implement the <code>ConstructJob</code> method to tell <a id="_idIndexMarker402"/>the driver what to execute during the linking stage. Differently from <code>Assembler</code>, since we need to support both the <code>zip</code> and <code>tar</code> + <code>gzip</code> packaging/compression schemes, we will add two extra methods, <code>buildZipArgs</code> and <code>buildTarArgs</code>, to handle argument building for each.</p></li>
				<li>Inside <code>Zipline.cpp</code>, we'll<a id="_idIndexMarker403"/> focus on the implementation of <code>Linker::ConstructJob</code> first:<pre>void
tools::zipline::Linker::ConstructJob(Compilation &amp;C,
                        const JobAction &amp;JA,
                        const InputInfo &amp;Output,
                        const InputInfoList &amp;Inputs,
                        const ArgList &amp;Args,
                        const char *LinkingOutput) const {
  ArgStringList CmdArgs;
  std::string Compressor = "zip";
  if (Arg *A = Args.getLastArg(options::OPT_fuse_ld_EQ))
    Compressor = A-&gt;getValue();
  std::string Exec = Args.MakeArgString(
      getToolChain().GetProgramPath(Compressor.c_str()));
  if (Compressor == "zip")
    buildZipArgs(JA, Output, Inputs, Args, CmdArgs);
  if (Compressor == "tar" || Compressor == "gzip")
    buildTarArgs(JA, Output, Inputs, Args, CmdArgs);
  else
    llvm_unreachable("Unsupported compressor name");
  C.addCommand(
    std::make_unique&lt;Command&gt;(
      JA, *this, ResponseFileSupport::None(), 
      Args.MakeArgString(Exec),
      CmdArgs, Inputs, Output));
}</pre><p>In this <a id="_idIndexMarker404"/>custom linking stage, we hope to use either the <code>zip</code> command or the <code>tar</code> command – depending on the <code>-fuse-ld</code> flag specified by users – to package all the (Base64-encoded) files generated by our custom <code>Assembler</code>.</p><p>The detailed command format for both <code>zip</code> and <code>tar</code> will be explained shortly. From the preceding snippet, we can see that the thing we are doing here is similar to <code>Assembler::ConstructJob</code>. The <code>Exec</code> variable carries the absolute path to either the <code>zip</code> or <code>tar</code> program; the <code>CmdArgs</code> variable, which is populated by either <code>buildZipArgs</code> or <code>buildTarArgs</code>, which will be explained later, carries the command-line arguments for the tool (<code>zip</code> or <code>tar</code>).</p><p>The biggest difference compared to <code>Assembler::ConstructJob</code> is that the command to execute can be designated by the <code>-fuse-ld</code> flag that's supplied by users. Thus, we are using the skill we learned about in the <em class="italic">Adding custom driver flags</em> section to read that driver flag and set up the command.</p></li>
				<li>If your<a id="_idIndexMarker405"/> users decide to package files in a ZIP file (which is the default scheme, or you can specify it explicitly via <code>-fuse-ld=zip</code>), we are going to run the following command:<pre>$ zip &lt;output zip file&gt; &lt;input file 1&gt; &lt;input file 2&gt;…</pre><p>Therefore, we will build our <code>Linker::buildZipArgs</code> method, which constructs an argument list for the preceding command, as follows:</p><pre>void
tools::zipline::Linker::buildZipArgs(const JobAction &amp;JA,
                             const InputInfo &amp;Output,
                             const InputInfoList &amp;Inputs,
                             const ArgList &amp;Args,
                             ArgStringList &amp;CmdArgs)                             const {
  // output file
  CmdArgs.push_back(Output.getFilename());
  // input files
  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs, JA);
}</pre><p>The <code>CmdArgs</code> argument of <code>Linker::buildZipArgs</code> will be where we'll export our results. While<a id="_idIndexMarker406"/> we are still using the same way to fetch the output filename (via <code>Output.getFilename()</code>), since a linker might accept multiple inputs at a time, we are leveraging another helper function, <code>AddLinkerInputs</code>, to add all the input filenames to <code>CmdArgs</code> for us.</p></li>
				<li>If your users decide to use the <code>tar</code> + <code>gzip</code> packaging scheme (via the <code>-fuse-ld=tar</code> or <code>-fuse-ld=gzip</code> flags), we are going to run the following command:<pre>$ tar -czf &lt;output tar.gz file&gt; &lt;input file 1&gt; &lt;input file 2&gt;…</pre><p>Therefore, we<a id="_idIndexMarker407"/> will build our <code>Linker::buildTarArgs</code> method, which constructs an argument list for the previous command, as follows:</p><pre>void
tools::zipline::Linker::buildTarArgs(const JobAction &amp;JA,
                             const InputInfo &amp;Output,
                             const InputInfoList &amp;Inputs,
                             const ArgList &amp;Args,
                             ArgStringList &amp;CmdArgs)                              const {
  // arguments and output file
  CmdArgs.push_back("-czf");
  CmdArgs.push_back(Output.getFilename());
  // input files
  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,    JA);
}</pre><p>Just like <code>buildZipArgs</code>, we grab the output filename via <code>Output.getFilename()</code> and add all the input filenames, using <code>AddLinkerInput</code>, into <code>CmdArgs</code>.</p></li>
				<li>Last but not least, let's connect our <code>Linker</code> to <code>ZiplineToolChain</code>:<pre>Tool *ZiplineToolChain::buildLinker() const {
  return new tools::zipline::Linker(*this);
}</pre></li>
			</ol>
			<p>That's all of the<a id="_idIndexMarker408"/> steps for implementing a custom linking phase for our Zipline toolchain.</p>
			<p>Now that we have created the necessary components for the Zipline toolchain, we can execute our custom features – encode the source files and package them into an archive – when users select this toolchain. In the next section, we are going to learn how to verify these functionalities.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor123"/>Verifying the custom toolchain</h2>
			<p>To test the <a id="_idIndexMarker409"/>functionalities we implemented in this chapter, we can run the example commands depicted in the project overview or we can leverage the <code>-###</code> driver flag again to dump all the expected compiler, assembler, and linker command details.</p>
			<p>So far, we've learned that the <code>-###</code> flag will show all the frontend flags that have been translated by the driver. But actually, it will also show the assembler and linker commands that have been scheduled to run. For instance, let's invoke the following command:</p>
			<pre>$ clang -### <strong class="bold">-zipline</strong> <strong class="bold">-c</strong> test.c</pre>
			<p>Since the <code>-c</code> flag always tries to run the assembler over the assembly file generated by Clang, our custom assembler (that is, the Base64 encoder) within Zipline will be triggered. Therefore, you will see an output similar to the following:</p>
			<pre>$ clang -### -zipline -c test.c
"/path/to/clang" "-cc1" …
"<strong class="bold">/usr/bin/openssl</strong>" "base64" "-in" "<strong class="bold">/tmp/test_ae4f5b.s</strong>" "-out" "<strong class="bold">test.o</strong>"
$</pre>
			<p>The line starting with <code>/path/to/clang -cc1</code> contains the frontend flags we learned about earlier. The line that follows is the assembler invocation command. This, in our case, runs <code>openssl</code> to perform Base64 encoding.</p>
			<p>Note that the weird <code>/tmp/test_ae4f5b.s</code> filename is the temporary file that's created by the driver to accommodate the assembly code that's generated by the compiler.</p>
			<p>Using the same trick, we can verify our custom linker stage, as follows:</p>
			<pre>$ clang -### <strong class="bold">-zipline</strong> test.c <strong class="bold">-o</strong> test.zip
"/path/to/clang" "-cc1" …
"/usr/bin/openssl" "base64" "-in" "/tmp/test_ae4f5b.s" "-out" "<strong class="bold">/tmp/test_ae4f5b.o</strong>"
"<strong class="bold">/usr/bin/zip</strong>" "test.zip" "<strong class="bold">/tmp/test_ae4f5b.o</strong>"
$</pre>
			<p>Since<a id="_idIndexMarker410"/> the <code>-o</code> flag was used in the previous command, Clang will build a complete executable from <code>test.c</code> involving the assembler and the linker. Therefore, our custom linking stage is up here due to the <code>zip</code> command taking the result (the <code>/tmp/test_ae4f5b.o</code> file) from the previous assembling stage. Feel free to add the <code>-fuse-ld=tar</code> flag to see the <code>zip</code> command replace the <code>tar</code> command with a completely different argument list.</p>
			<p>In this section, we showed you how to create a toolchain for Clang's driver. This is a crucial skill for supporting Clang on custom or new platforms. We also learned that the toolchain framework in Clang is flexible and can handle a variety of tasks that are required by the target platform.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor124"/>Summary</h1>
			<p>In this chapter, we started by introducing Clang's driver and the role of the toolchain – the module that provides platform-specific information such as the supported assemblers and linkers – that assisted it. Then, we showed you one of the most common ways to customize the driver – adding a new driver flag. After that, we talked about the toolchain and, most importantly, how to create a custom one. These skills are really useful when you want to create a new feature in Clang (or even LLVM) and need a custom compiler flag to enable it. Also, the ability to develop a custom toolchain is crucial for supporting Clang on new operating systems, or even new hardware architecture.</p>
			<p>This is the final chapter of the second part of this book. Starting from the next chapter, we will talk about LLVM's middle end – the <em class="italic">platform-independent</em> program analysis and optimization framework.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor125"/>Exercises</h1>
			<ol>
				<li value="1">It is common to override the assembling and linking stage since different platforms tend to support different assemblers and linkers. However, is it possible to override the <em class="italic">compiling</em> stage (which is Clang)? If it is possible, how can we do this? Why may people wish to do this? </li>
				<li>When we were working on <code>tools::zipline::Linker::ConstructJob</code>, we simply use <code>llvm_unreachable</code> to bail out the compilation process if a user provides an unsupported compressor name through the <code>-fuse-ld</code> flag. Can we replace it with Clang's <strong class="bold">diagnostic</strong> framework, which we learned about in <a href="B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling AST</em>, to print out better messages?</li>
				<li>Just like we can use <code>-Xclang</code> to pass flags directly to the frontend, we can also pass assembler-specific or linker-specific flags directly to the assembler or linker using driver flags such as <code>-Wa</code> (for the assembler) or <code>-Wl</code> (for the linker). How can we consume those flags in our custom assembler and linker stages within Zipline?</li>
			</ol>
		</div>
	</body></html>